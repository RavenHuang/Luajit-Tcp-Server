# 1 "c_include/windows/original/ws2tcpip.h"
static const int __STDC__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __STDC_HOSTED__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GNUC__ = 4;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GNUC_MINOR__ = 8;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GNUC_PATCHLEVEL__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const char __VERSION__ = "4.8.1 20130328 (prerelease)";
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_RELAXED = 0;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_SEQ_CST = 5;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_ACQUIRE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_RELEASE = 3;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_ACQ_REL = 4;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_CONSUME = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __pic__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __PIC__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FINITE_MATH_ONLY__ = 0;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_INT__ = 4;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_LONG__ = 4;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_LONG_LONG__ = 8;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_SHORT__ = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_FLOAT__ = 4;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_DOUBLE__ = 8;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_LONG_DOUBLE__ = 16;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_SIZE_T__ = 8;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __CHAR_BIT__ = 8;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __BIGGEST_ALIGNMENT__ = 16;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ORDER_LITTLE_ENDIAN__ = 1234;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ORDER_BIG_ENDIAN__ = 4321;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ORDER_PDP_ENDIAN__ = 3412;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLOAT_WORD_ORDER__ = __ORDER_LITTLE_ENDIAN__;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_POINTER__ = 8;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZE_TYPE__ = long long unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __PTRDIFF_TYPE__ = long long int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WCHAR_TYPE__ = short unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WINT_TYPE__ = short unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INTMAX_TYPE__ = long long int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINTMAX_TYPE__ = long long unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __CHAR16_TYPE__ = short unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __CHAR32_TYPE__ = unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIG_ATOMIC_TYPE__ = int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT8_TYPE__ = signed char;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT16_TYPE__ = short int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT32_TYPE__ = int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT64_TYPE__ = long long int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT8_TYPE__ = unsigned char;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT16_TYPE__ = short unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT32_TYPE__ = unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT64_TYPE__ = long long unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_LEAST8_TYPE__ = signed char;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_LEAST16_TYPE__ = short int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_LEAST32_TYPE__ = int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_LEAST64_TYPE__ = long long int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST8_TYPE__ = unsigned char;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST16_TYPE__ = short unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST32_TYPE__ = unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST64_TYPE__ = long long unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_FAST8_TYPE__ = signed char;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_FAST16_TYPE__ = short int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_FAST32_TYPE__ = int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_FAST64_TYPE__ = long long int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST8_TYPE__ = unsigned char;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST16_TYPE__ = short unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST32_TYPE__ = unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST64_TYPE__ = long long unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INTPTR_TYPE__ = long long int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINTPTR_TYPE__ = long long unsigned int;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GXX_ABI_VERSION = 1002;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SCHAR_MAX__ = 127;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SHRT_MAX__ = 32767;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_MAX__ = 2147483647;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long __LONG_MAX__ = 2147483647L;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long long __LONG_LONG_MAX__ = 9223372036854775807LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WCHAR_MAX__ = 65535;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WCHAR_MIN__ = 0;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WINT_MAX__ = 65535;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WINT_MIN__ = 0;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long long __PTRDIFF_MAX__ = 9223372036854775807LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZE_MAX__ = 18446744073709551615ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long long __INTMAX_MAX__ = 9223372036854775807LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INTMAX_C(c) = c ## LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINTMAX_MAX__ = 18446744073709551615ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINTMAX_C(c) = c ## ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIG_ATOMIC_MAX__ = 2147483647;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIG_ATOMIC_MIN__ = (-__SIG_ATOMIC_MAX__ - 1);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT8_MAX__ = 127;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT16_MAX__ = 32767;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT32_MAX__ = 2147483647;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long long __INT64_MAX__ = 9223372036854775807LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT8_MAX__ = 255;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT16_MAX__ = 65535;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT32_MAX__ = 4294967295U;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT64_MAX__ = 18446744073709551615ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_LEAST8_MAX__ = 127;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT8_C(c) = c;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_LEAST16_MAX__ = 32767;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT16_C(c) = c;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_LEAST32_MAX__ = 2147483647;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT32_C(c) = c;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long long __INT_LEAST64_MAX__ = 9223372036854775807LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT64_C(c) = c ## LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST8_MAX__ = 255;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT8_C(c) = c;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST16_MAX__ = 65535;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT16_C(c) = c;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST32_MAX__ = 4294967295U;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT32_C(c) = c ## U;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_LEAST64_MAX__ = 18446744073709551615ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT64_C(c) = c ## ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_FAST8_MAX__ = 127;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_FAST16_MAX__ = 32767;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __INT_FAST32_MAX__ = 2147483647;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long long __INT_FAST64_MAX__ = 9223372036854775807LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST8_MAX__ = 255;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST16_MAX__ = 65535;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST32_MAX__ = 4294967295U;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINT_FAST64_MAX__ = 18446744073709551615ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long long __INTPTR_MAX__ = 9223372036854775807LL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __UINTPTR_MAX__ = 18446744073709551615ULL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_EVAL_METHOD__ = 0;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC_EVAL_METHOD__ = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_RADIX__ = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_MANT_DIG__ = 24;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_DIG__ = 6;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_MIN_EXP__ = (-125);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_MIN_10_EXP__ = (-37);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_MAX_EXP__ = 128;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_MAX_10_EXP__ = 38;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_DECIMAL_DIG__ = 9;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __FLT_MAX__ = 3.40282346638528859812e+38F;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __FLT_MIN__ = 1.17549435082228750797e-38F;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __FLT_EPSILON__ = 1.19209289550781250000e-7F;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __FLT_DENORM_MIN__ = 1.40129846432481707092e-45F;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_HAS_DENORM__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_HAS_INFINITY__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __FLT_HAS_QUIET_NAN__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_MANT_DIG__ = 53;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_DIG__ = 15;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_MIN_EXP__ = (-1021);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_MIN_10_EXP__ = (-307);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_MAX_EXP__ = 1024;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_MAX_10_EXP__ = 308;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_DECIMAL_DIG__ = 17;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DBL_MAX__ = ((double)1.79769313486231570815e+308L);
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DBL_MIN__ = ((double)2.22507385850720138309e-308L);
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DBL_EPSILON__ = ((double)2.22044604925031308085e-16L);
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DBL_DENORM_MIN__ = ((double)4.94065645841246544177e-324L);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_HAS_DENORM__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_HAS_INFINITY__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DBL_HAS_QUIET_NAN__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_MANT_DIG__ = 64;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_DIG__ = 18;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_MIN_EXP__ = (-16381);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_MIN_10_EXP__ = (-4931);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_MAX_EXP__ = 16384;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_MAX_10_EXP__ = 4932;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DECIMAL_DIG__ = 21;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long __LDBL_MAX__ = 1.18973149535723176502e+4932L;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long __LDBL_MIN__ = 3.36210314311209350626e-4932L;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long __LDBL_EPSILON__ = 1.08420217248550443401e-19L;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long __LDBL_DENORM_MIN__ = 3.64519953188247460253e-4951L;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_HAS_DENORM__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_HAS_INFINITY__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __LDBL_HAS_QUIET_NAN__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC32_MANT_DIG__ = 7;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC32_MIN_EXP__ = (-94);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC32_MAX_EXP__ = 97;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC32_MIN__ = 1E-95DF;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC32_MAX__ = 9.999999E96DF;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC32_EPSILON__ = 1E-6DF;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC32_SUBNORMAL_MIN__ = 0.000001E-95DF;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC64_MANT_DIG__ = 16;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC64_MIN_EXP__ = (-382);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC64_MAX_EXP__ = 385;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC64_MIN__ = 1E-383DD;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC64_MAX__ = 9.999999999999999E384DD;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC64_EPSILON__ = 1E-15DD;
# 1 "c_include/windows/original/ws2tcpip.h"
static const double __DEC64_SUBNORMAL_MIN__ = 0.000000000000001E-383DD;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC128_MANT_DIG__ = 34;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC128_MIN_EXP__ = (-6142);
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DEC128_MAX_EXP__ = 6145;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long double __DEC128_MIN__ = 1E-6143DL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long double __DEC128_MAX__ = 9.999999999999999999999999999999999E6144DL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long double __DEC128_EPSILON__ = 1E-33DL;
# 1 "c_include/windows/original/ws2tcpip.h"
static const long double __DEC128_SUBNORMAL_MIN__ = 0.000000000000000000000000000000001E-6143DL;
# 1 "c_include/windows/original/ws2tcpip.h"
# 1 "c_include/windows/original/ws2tcpip.h"
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GNUC_GNU_INLINE__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __NO_INLINE__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_BOOL_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_CHAR_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_CHAR16_T_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_CHAR32_T_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_WCHAR_T_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_SHORT_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_INT_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_LONG_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_LLONG_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GCC_ATOMIC_POINTER_LOCK_FREE = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __PRAGMA_REDEFINE_EXTNAME = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_INT128__ = 16;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_WCHAR_T__ = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_WINT_T__ = 2;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SIZEOF_PTRDIFF_T__ = 8;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __amd64 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __amd64__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __x86_64 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __x86_64__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_HLE_ACQUIRE = 65536;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __ATOMIC_HLE_RELEASE = 131072;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __k8 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __k8__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __code_model_small__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __MMX__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SSE__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SSE2__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SSE_MATH__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SSE2_MATH__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __SEH__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __stdcall = __attribute__((__stdcall__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __fastcall = __attribute__((__fastcall__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __thiscall = __attribute__((__thiscall__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __cdecl = __attribute__((__cdecl__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _stdcall = __attribute__((__stdcall__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _fastcall = __attribute__((__fastcall__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _thiscall = __attribute__((__thiscall__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _cdecl = __attribute__((__cdecl__));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GXX_MERGED_TYPEINFO_NAMES = 0;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __GXX_TYPEINFO_EQUALITY_INLINE = 0;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __MSVCRT__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __MINGW32__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _WIN32 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WIN32 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WIN32__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int WIN32 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WINNT = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WINNT__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int WINNT = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _INTEGRAL_MAX_BITS = 64;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __MINGW64__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WIN64 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __WIN64__ = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int WIN64 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _WIN64 = 1;
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __declspec(x) = __attribute__((x));
# 1 "c_include/windows/original/ws2tcpip.h"
static const int __DECIMAL_BID_FORMAT__ = 1;
# 1 "<command-line>"
# 1 "c_include/windows/original/ws2tcpip.h"
static const int _WIN32_WINNT = 0x0602;
static const int WINVER = _WIN32_WINNT;
#pragma comment (lib, "Ws2_32.lib")
/*
**  WS2TCPIP.H - WinSock2 Extension for TCP/IP protocols
**
**  This file contains TCP/IP specific information for use
**  by WinSock2 compatible applications.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**  To provide the backward compatibility, all the TCP/IP
**  specific definitions that were included in the WINSOCK.H
**   file are now included in WINSOCK2.H file. WS2TCPIP.H
**  file includes only the definitions  introduced in the
**  "WinSock 2 Protocol-Specific Annex" document.
**
**  Rev 0.3 Nov 13, 1995
**      Rev 0.4 Dec 15, 1996
*/
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 1
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    118736
//  $AgreementName:  berkeley software distribution license
//  $AgreementType:  oss license
//  $ExternalOrigin: regents of the university of california
//$ENDTAG
//$TAG ENGR 
//  $Owner:    vadime
//  $Module:   published_inc
//
//$ENDTAG
/* Winsock2.h -- definitions to be used with the WinSock 2 DLL and
 *               WinSock 2 applications.
 *
 * This header file corresponds to version 2.2.x of the WinSock API
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 */
# 28 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * Ensure structures are packed consistently.
 * Not necessary for WIN32, it is already packed >=4 and there are
 * no structures in this header that have alignment requirement 
 * higher than 4.
 * For WIN64 we do not have compatibility requirement because it is
 * not possible to mix 32/16 bit code with 64 bit code in the same
 * process.
 */
/*
 * Default: include function prototypes, don't include function typedefs.
 */
static const int INCL_WINSOCK_API_PROTOTYPES = 1;
static const int INCL_WINSOCK_API_TYPEDEFS = 0;
/*
 * Pull in WINDOWS.H if necessary
 */
# 66 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 1
/*++ BUILD Version: 0001    Increment this if a change has global effects
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    windows.h
Abstract:
    Master include file for Windows applications.
--*/
# 18 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h" 1
/*
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    sdkddkver.h
Abstract:
    Master include file for versioning windows SDK/DDK.
*/
# 16 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
//
// _WIN32_WINNT version constants
//
static const int _WIN32_WINNT_NT4 = 0x0400;
static const int _WIN32_WINNT_WIN2K = 0x0500;
static const int _WIN32_WINNT_WINXP = 0x0501;
static const int _WIN32_WINNT_WS03 = 0x0502;
static const int _WIN32_WINNT_WIN6 = 0x0600;
static const int _WIN32_WINNT_VISTA = 0x0600;
static const int _WIN32_WINNT_WS08 = 0x0600;
static const int _WIN32_WINNT_LONGHORN = 0x0600;
static const int _WIN32_WINNT_WIN7 = 0x0601;
//
// _WIN32_IE_ version constants
//
static const int _WIN32_IE_IE20 = 0x0200;
static const int _WIN32_IE_IE30 = 0x0300;
static const int _WIN32_IE_IE302 = 0x0302;
static const int _WIN32_IE_IE40 = 0x0400;
static const int _WIN32_IE_IE401 = 0x0401;
static const int _WIN32_IE_IE50 = 0x0500;
static const int _WIN32_IE_IE501 = 0x0501;
static const int _WIN32_IE_IE55 = 0x0550;
static const int _WIN32_IE_IE60 = 0x0600;
static const int _WIN32_IE_IE60SP1 = 0x0601;
static const int _WIN32_IE_IE60SP2 = 0x0603;
static const int _WIN32_IE_IE70 = 0x0700;
static const int _WIN32_IE_IE80 = 0x0800;
//
// IE <-> OS version mapping
//
// NT4 supports IE versions 2.0 -> 6.0 SP1
static const int _WIN32_IE_NT4 = _WIN32_IE_IE20;
static const int _WIN32_IE_NT4SP1 = _WIN32_IE_IE20;
static const int _WIN32_IE_NT4SP2 = _WIN32_IE_IE20;
static const int _WIN32_IE_NT4SP3 = _WIN32_IE_IE302;
static const int _WIN32_IE_NT4SP4 = _WIN32_IE_IE401;
static const int _WIN32_IE_NT4SP5 = _WIN32_IE_IE401;
static const int _WIN32_IE_NT4SP6 = _WIN32_IE_IE50;
// Win98 supports IE versions 4.01 -> 6.0 SP1
static const int _WIN32_IE_WIN98 = _WIN32_IE_IE401;
// Win98SE supports IE versions 5.0 -> 6.0 SP1
static const int _WIN32_IE_WIN98SE = _WIN32_IE_IE50;
// WinME supports IE versions 5.5 -> 6.0 SP1
static const int _WIN32_IE_WINME = _WIN32_IE_IE55;
// Win2k supports IE versions 5.01 -> 6.0 SP1
static const int _WIN32_IE_WIN2K = _WIN32_IE_IE501;
static const int _WIN32_IE_WIN2KSP1 = _WIN32_IE_IE501;
static const int _WIN32_IE_WIN2KSP2 = _WIN32_IE_IE501;
static const int _WIN32_IE_WIN2KSP3 = _WIN32_IE_IE501;
static const int _WIN32_IE_WIN2KSP4 = _WIN32_IE_IE501;
static const int _WIN32_IE_XP = _WIN32_IE_IE60;
static const int _WIN32_IE_XPSP1 = _WIN32_IE_IE60SP1;
static const int _WIN32_IE_XPSP2 = _WIN32_IE_IE60SP2;
static const int _WIN32_IE_WS03 = 0x0602;
static const int _WIN32_IE_WS03SP1 = _WIN32_IE_IE60SP2;
static const int _WIN32_IE_WIN6 = _WIN32_IE_IE70;
static const int _WIN32_IE_LONGHORN = _WIN32_IE_IE70;
static const int _WIN32_IE_WIN7 = _WIN32_IE_IE80;
//
// NTDDI version constants
//
static const int NTDDI_WIN2K = 0x05000000;
static const int NTDDI_WIN2KSP1 = 0x05000100;
static const int NTDDI_WIN2KSP2 = 0x05000200;
static const int NTDDI_WIN2KSP3 = 0x05000300;
static const int NTDDI_WIN2KSP4 = 0x05000400;
static const int NTDDI_WINXP = 0x05010000;
static const int NTDDI_WINXPSP1 = 0x05010100;
static const int NTDDI_WINXPSP2 = 0x05010200;
static const int NTDDI_WINXPSP3 = 0x05010300;
static const int NTDDI_WINXPSP4 = 0x05010400;
static const int NTDDI_WS03 = 0x05020000;
static const int NTDDI_WS03SP1 = 0x05020100;
static const int NTDDI_WS03SP2 = 0x05020200;
static const int NTDDI_WS03SP3 = 0x05020300;
static const int NTDDI_WS03SP4 = 0x05020400;
static const int NTDDI_WIN6 = 0x06000000;
static const int NTDDI_WIN6SP1 = 0x06000100;
static const int NTDDI_WIN6SP2 = 0x06000200;
static const int NTDDI_WIN6SP3 = 0x06000300;
static const int NTDDI_WIN6SP4 = 0x06000400;
static const int NTDDI_VISTA = NTDDI_WIN6;
static const int NTDDI_VISTASP1 = NTDDI_WIN6SP1;
static const int NTDDI_VISTASP2 = NTDDI_WIN6SP2;
static const int NTDDI_VISTASP3 = NTDDI_WIN6SP3;
static const int NTDDI_VISTASP4 = NTDDI_WIN6SP4;
static const int NTDDI_LONGHORN = NTDDI_VISTA;
static const int NTDDI_WS08 = NTDDI_WIN6SP1;
static const int NTDDI_WS08SP2 = NTDDI_WIN6SP2;
static const int NTDDI_WS08SP3 = NTDDI_WIN6SP3;
static const int NTDDI_WS08SP4 = NTDDI_WIN6SP4;
static const int NTDDI_WIN7 = 0x06010000;
//
// masks for version macros
//
static const int OSVERSION_MASK = 0xFFFF0000;
static const int SPVERSION_MASK = 0x0000FF00;
static const int SUBVERSION_MASK = 0x000000FF;
//
// macros to extract various version fields from the NTDDI version
//
static const int OSVER(Version) = ((Version) & OSVERSION_MASK);
static const int SPVER(Version) = (((Version) & SPVERSION_MASK) >> 8);
static const int SUBVER(Version) = (((Version) & SUBVERSION_MASK) );
# 183 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
//
// if versions aren't already defined, default to most current
//
static const int NTDDI_VERSION_FROM_WIN32_WINNT2(ver) = ver ##0000;
static const int NTDDI_VERSION_FROM_WIN32_WINNT(ver) = NTDDI_VERSION_FROM_WIN32_WINNT2(ver);
# 202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
// set NTDDI_VERSION based on _WIN32_WINNT
static const int NTDDI_VERSION = NTDDI_VERSION_FROM_WIN32_WINNT(_WIN32_WINNT);
# 220 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
// set _WIN32_IE based on _WIN32_WINNT
# 230 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
static const int _WIN32_IE = 0x0800;
//
// Sanity check for compatible versions
//
# 22 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NONLS             - All NLS defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSERVICE         - All Service Controller routines, SERVICE_ equates, etc.
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 *  NOMCX             - Modem Configuration Extensions
 */
# 151 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h" 1
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */
/* Define _CRTIMP */
# 47 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Note on use of "deprecate":
 * Various places in this header and other headers use __declspec(deprecate) or macros that have the term DEPRECATE in them.
 * We use deprecate here ONLY to signal the compiler to emit a warning about these items. The use of deprecate
 * should NOT be taken to imply that any standard committee has deprecated these functions from the relevant standards.
 * In fact, these functions are NOT deprecated from the standard.
 *
 * Full details can be found in our documentation by searching for "Security Enhancements in the CRT".
*/
# 56 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h" 1
/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
/*==========================================================================
   The macros are defined in 3 layers:
   _In_\_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.
   _Pre_\_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_\_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.
   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.
   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|
   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.
   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.
   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply
   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ\Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|
   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.
   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2
   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)
   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.
   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.
============================================================================*/
# 106 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
# 140 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
// Disable expansion of SAL macros in non-Prefast mode to 
// improve compiler throughput.
static const int _USE_DECLSPECS_FOR_SAL = 0;
static const int _USE_ATTRIBUTES_FOR_SAL = 0;
// safeguard for MIDL and RC builds
# 163 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
//============================================================================
//   _In_\_Out_ Layer:
//============================================================================
// 'in' parameters --------------------------
// input pointer parameter
// e.g. void SetPoint( _In_ const POINT* pPT );
static const int _In_ = _Pre1_impl_(_$notnull) _Deref_pre2_impl_(_$valid, _$readaccess);
static const int _In_opt_ = _Pre_opt_valid_ _Deref_pre_readonly_;
// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
static const int _In_z_ = _Pre_z_ _Deref_pre_readonly_;
static const int _In_opt_z_ = _Pre_opt_z_ _Deref_pre_readonly_;
// 'input' buffers with given size
// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter
static const int _In_count_(size) = _Pre_count_(size) _Deref_pre_readonly_;
static const int _In_opt_count_(size) = _Pre_opt_count_(size) _Deref_pre_readonly_;
static const int _In_bytecount_(size) = _Pre_bytecount_(size) _Deref_pre_readonly_;
static const int _In_opt_bytecount_(size) = _Pre_opt_bytecount_(size) _Deref_pre_readonly_;
// valid buffer extent described by a constant extression
static const int _In_count_c_(size) = _Pre_count_c_(size) _Deref_pre_readonly_;
static const int _In_opt_count_c_(size) = _Pre_opt_count_c_(size) _Deref_pre_readonly_;
static const int _In_bytecount_c_(size) = _Pre_bytecount_c_(size) _Deref_pre_readonly_;
static const int _In_opt_bytecount_c_(size) = _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_;
// nullterminated  'input' buffers with given size
// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter
static const int _In_z_count_(size) = _Pre_z_ _Pre_count_(size) _Deref_pre_readonly_;
static const int _In_opt_z_count_(size) = _Pre_opt_z_ _Pre_opt_count_(size) _Deref_pre_readonly_;
static const int _In_z_bytecount_(size) = _Pre_z_ _Pre_bytecount_(size) _Deref_pre_readonly_;
static const int _In_opt_z_bytecount_(size) = _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_;
// nullterminated valid buffer extent described by a constant extression
static const int _In_z_count_c_(size) = _Pre_z_ _Pre_count_c_(size) _Deref_pre_readonly_;
static const int _In_opt_z_count_c_(size) = _Pre_opt_z_ _Pre_opt_count_c_(size) _Deref_pre_readonly_;
static const int _In_z_bytecount_c_(size) = _Pre_z_ _Pre_bytecount_c_(size) _Deref_pre_readonly_;
static const int _In_opt_z_bytecount_c_(size) = _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_;
// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
static const int _In_ptrdiff_count_(size) = _Pre_ptrdiff_count_(size) _Deref_pre_readonly_;
static const int _In_opt_ptrdiff_count_(size) = _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_;
// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );
static const int _In_count_x_(size) = _Pre_count_x_(size) _Deref_pre_readonly_;
static const int _In_opt_count_x_(size) = _Pre_opt_count_x_(size) _Deref_pre_readonly_;
static const int _In_bytecount_x_(size) = _Pre_bytecount_x_(size) _Deref_pre_readonly_;
static const int _In_opt_bytecount_x_(size) = _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_;
// 'out' parameters --------------------------
// output pointer parameter
// e.g. void GetPoint( _Out_ POINT* pPT );
static const int _Out_ = _Pre_cap_c_(1) _Pre_invalid_;
static const int _Out_opt_ = _Pre_opt_cap_c_(1) _Pre_invalid_;
// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter
static const int _Out_cap_(size) = _Pre_cap_(size) _Pre_invalid_;
static const int _Out_opt_cap_(size) = _Pre_opt_cap_(size) _Pre_invalid_;
static const int _Out_bytecap_(size) = _Pre_bytecap_(size) _Pre_invalid_;
static const int _Out_opt_bytecap_(size) = _Pre_opt_bytecap_(size) _Pre_invalid_;
// buffer capacity is described by a constant expression
static const int _Out_cap_c_(size) = _Pre_cap_c_(size) _Pre_invalid_;
static const int _Out_opt_cap_c_(size) = _Pre_opt_cap_c_(size) _Pre_invalid_;
static const int _Out_bytecap_c_(size) = _Pre_bytecap_c_(size) _Pre_invalid_;
static const int _Out_opt_bytecap_c_(size) = _Pre_opt_bytecap_c_(size) _Pre_invalid_;
// buffer capacity is described by another parameter multiplied by a constant expression
static const int _Out_cap_m_(mult,size) = _Pre_cap_m_(mult,size) _Pre_invalid_;
static const int _Out_opt_cap_m_(mult,size) = _Pre_opt_cap_m_(mult,size) _Pre_invalid_;
static const int _Out_z_cap_m_(mult,size) = _Pre_cap_m_(mult,size) _Pre_invalid_ _Post_z_;
static const int _Out_opt_z_cap_m_(mult,size) = _Pre_opt_cap_m_(mult,size) _Pre_invalid_ _Post_z_;
// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
static const int _Out_ptrdiff_cap_(size) = _Pre_ptrdiff_cap_(size) _Pre_invalid_;
static const int _Out_opt_ptrdiff_cap_(size) = _Pre_opt_ptrdiff_cap_(size) _Pre_invalid_;
// buffer capacity is described by a complex expression
static const int _Out_cap_x_(size) = _Pre_cap_x_(size) _Pre_invalid_;
static const int _Out_opt_cap_x_(size) = _Pre_opt_cap_x_(size) _Pre_invalid_;
static const int _Out_bytecap_x_(size) = _Pre_bytecap_x_(size) _Pre_invalid_;
static const int _Out_opt_bytecap_x_(size) = _Pre_opt_bytecap_x_(size) _Pre_invalid_;
// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter
static const int _Out_z_cap_(size) = _Pre_cap_(size) _Pre_invalid_ _Post_z_;
static const int _Out_opt_z_cap_(size) = _Pre_opt_cap_(size) _Pre_invalid_ _Post_z_;
static const int _Out_z_bytecap_(size) = _Pre_bytecap_(size) _Pre_invalid_ _Post_z_;
static const int _Out_opt_z_bytecap_(size) = _Pre_opt_bytecap_(size) _Pre_invalid_ _Post_z_;
// buffer capacity is described by a constant expression
static const int _Out_z_cap_c_(size) = _Pre_cap_c_(size) _Pre_invalid_ _Post_z_;
static const int _Out_opt_z_cap_c_(size) = _Pre_opt_cap_c_(size) _Pre_invalid_ _Post_z_;
static const int _Out_z_bytecap_c_(size) = _Pre_bytecap_c_(size) _Pre_invalid_ _Post_z_;
static const int _Out_opt_z_bytecap_c_(size) = _Pre_opt_bytecap_c_(size) _Pre_invalid_ _Post_z_;
// buffer capacity is described by a complex expression
static const int _Out_z_cap_x_(size) = _Pre_cap_x_(size) _Pre_invalid_ _Post_z_;
static const int _Out_opt_z_cap_x_(size) = _Pre_opt_cap_x_(size) _Pre_invalid_ _Post_z_;
static const int _Out_z_bytecap_x_(size) = _Pre_bytecap_x_(size) _Pre_invalid_ _Post_z_;
static const int _Out_opt_z_bytecap_x_(size) = _Pre_opt_bytecap_x_(size) _Pre_invalid_ _Post_z_;
// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );
static const int _Out_cap_post_count_(cap,count) = _Pre_cap_(cap) _Pre_invalid_ _Post_count_(count);
static const int _Out_opt_cap_post_count_(cap,count) = _Pre_opt_cap_(cap) _Pre_invalid_ _Post_count_(count);
static const int _Out_bytecap_post_bytecount_(cap,count) = _Pre_bytecap_(cap) _Pre_invalid_ _Post_bytecount_(count);
static const int _Out_opt_bytecap_post_bytecount_(cap,count) = _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_bytecount_(count);
// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );
static const int _Out_z_cap_post_count_(cap,count) = _Pre_cap_(cap) _Pre_invalid_ _Post_z_count_(count);
static const int _Out_opt_z_cap_post_count_(cap,count) = _Pre_opt_cap_(cap) _Pre_invalid_ _Post_z_count_(count);
static const int _Out_z_bytecap_post_bytecount_(cap,count) = _Pre_bytecap_(cap) _Pre_invalid_ _Post_z_bytecount_(count);
static const int _Out_opt_z_bytecap_post_bytecount_(cap,count) = _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_z_bytecount_(count);
// only use with dereferenced arguments e.g. '*pcch' 
static const int _Out_capcount_(capcount) = _Pre_cap_(capcount) _Pre_invalid_ _Post_count_(capcount);
static const int _Out_opt_capcount_(capcount) = _Pre_opt_cap_(capcount) _Pre_invalid_ _Post_count_(capcount);
static const int _Out_bytecapcount_(capcount) = _Pre_bytecap_(capcount) _Pre_invalid_ _Post_bytecount_(capcount);
static const int _Out_opt_bytecapcount_(capcount) = _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_bytecount_(capcount);
static const int _Out_capcount_x_(capcount) = _Pre_cap_x_(capcount) _Pre_invalid_ _Post_count_x_(capcount);
static const int _Out_opt_capcount_x_(capcount) = _Pre_opt_cap_x_(capcount) _Pre_invalid_ _Post_count_x_(capcount);
static const int _Out_bytecapcount_x_(capcount) = _Pre_bytecap_x_(capcount) _Pre_invalid_ _Post_bytecount_x_(capcount);
static const int _Out_opt_bytecapcount_x_(capcount) = _Pre_opt_bytecap_x_(capcount) _Pre_invalid_ _Post_bytecount_x_(capcount);
// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );
static const int _Out_z_capcount_(capcount) = _Pre_cap_(capcount) _Pre_invalid_ _Post_z_count_(capcount);
static const int _Out_opt_z_capcount_(capcount) = _Pre_opt_cap_(capcount) _Pre_invalid_ _Post_z_count_(capcount);
static const int _Out_z_bytecapcount_(capcount) = _Pre_bytecap_(capcount) _Pre_invalid_ _Post_z_bytecount_(capcount);
static const int _Out_opt_z_bytecapcount_(capcount) = _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_z_bytecount_(capcount);
// inout parameters ----------------------------
// inout pointer parameter
// e.g. void ModifyPoint( _Inout_ POINT* pPT );
static const int _Inout_ = _Prepost_valid_;
static const int _Inout_opt_ = _Prepost_opt_valid_;
// string buffers
// e.g. void toupper( _Inout_z_ char* sz );
static const int _Inout_z_ = _Prepost_z_;
static const int _Inout_opt_z_ = _Prepost_opt_z_;
// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
static const int _Inout_count_(size) = _Prepost_count_(size);
static const int _Inout_opt_count_(size) = _Prepost_opt_count_(size);
static const int _Inout_bytecount_(size) = _Prepost_bytecount_(size);
static const int _Inout_opt_bytecount_(size) = _Prepost_opt_bytecount_(size);
static const int _Inout_count_c_(size) = _Prepost_count_c_(size);
static const int _Inout_opt_count_c_(size) = _Prepost_opt_count_c_(size);
static const int _Inout_bytecount_c_(size) = _Prepost_bytecount_c_(size);
static const int _Inout_opt_bytecount_c_(size) = _Prepost_opt_bytecount_c_(size);
// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
static const int _Inout_z_count_(size) = _Prepost_z_ _Prepost_count_(size);
static const int _Inout_opt_z_count_(size) = _Prepost_z_ _Prepost_opt_count_(size);
static const int _Inout_z_bytecount_(size) = _Prepost_z_ _Prepost_bytecount_(size);
static const int _Inout_opt_z_bytecount_(size) = _Prepost_z_ _Prepost_opt_bytecount_(size);
static const int _Inout_z_count_c_(size) = _Prepost_z_ _Prepost_count_c_(size);
static const int _Inout_opt_z_count_c_(size) = _Prepost_z_ _Prepost_opt_count_c_(size);
static const int _Inout_z_bytecount_c_(size) = _Prepost_z_ _Prepost_bytecount_c_(size);
static const int _Inout_opt_z_bytecount_c_(size) = _Prepost_z_ _Prepost_opt_bytecount_c_(size);
static const int _Inout_ptrdiff_count_(size) = _Pre_ptrdiff_count_(size);
static const int _Inout_opt_ptrdiff_count_(size) = _Pre_opt_ptrdiff_count_(size);
static const int _Inout_count_x_(size) = _Prepost_count_x_(size);
static const int _Inout_opt_count_x_(size) = _Prepost_opt_count_x_(size);
static const int _Inout_bytecount_x_(size) = _Prepost_bytecount_x_(size);
static const int _Inout_opt_bytecount_x_(size) = _Prepost_opt_bytecount_x_(size);
// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );
static const int _Inout_cap_(size) = _Pre_valid_cap_(size) _Post_valid_;
static const int _Inout_opt_cap_(size) = _Pre_opt_valid_cap_(size) _Post_valid_;
static const int _Inout_bytecap_(size) = _Pre_valid_bytecap_(size) _Post_valid_;
static const int _Inout_opt_bytecap_(size) = _Pre_opt_valid_bytecap_(size) _Post_valid_;
static const int _Inout_cap_c_(size) = _Pre_valid_cap_c_(size) _Post_valid_;
static const int _Inout_opt_cap_c_(size) = _Pre_opt_valid_cap_c_(size) _Post_valid_;
static const int _Inout_bytecap_c_(size) = _Pre_valid_bytecap_c_(size) _Post_valid_;
static const int _Inout_opt_bytecap_c_(size) = _Pre_opt_valid_bytecap_c_(size) _Post_valid_;
static const int _Inout_cap_x_(size) = _Pre_valid_cap_x_(size) _Post_valid_;
static const int _Inout_opt_cap_x_(size) = _Pre_opt_valid_cap_x_(size) _Post_valid_;
static const int _Inout_bytecap_x_(size) = _Pre_valid_bytecap_x_(size) _Post_valid_;
static const int _Inout_opt_bytecap_x_(size) = _Pre_opt_valid_bytecap_x_(size) _Post_valid_;
// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
static const int _Inout_z_cap_(size) = _Pre_z_cap_(size) _Post_z_;
static const int _Inout_opt_z_cap_(size) = _Pre_opt_z_cap_(size) _Post_z_;
static const int _Inout_z_bytecap_(size) = _Pre_z_bytecap_(size) _Post_z_;
static const int _Inout_opt_z_bytecap_(size) = _Pre_opt_z_bytecap_(size) _Post_z_;
static const int _Inout_z_cap_c_(size) = _Pre_z_cap_c_(size) _Post_z_;
static const int _Inout_opt_z_cap_c_(size) = _Pre_opt_z_cap_c_(size) _Post_z_;
static const int _Inout_z_bytecap_c_(size) = _Pre_z_bytecap_c_(size) _Post_z_;
static const int _Inout_opt_z_bytecap_c_(size) = _Pre_opt_z_bytecap_c_(size) _Post_z_;
static const int _Inout_z_cap_x_(size) = _Pre_z_cap_x_(size) _Post_z_;
static const int _Inout_opt_z_cap_x_(size) = _Pre_opt_z_cap_x_(size) _Post_z_;
static const int _Inout_z_bytecap_x_(size) = _Pre_z_bytecap_x_(size) _Post_z_;
static const int _Inout_opt_z_bytecap_x_(size) = _Pre_opt_z_bytecap_x_(size) _Post_z_;
// return values -------------------------------
// returning pointers to valid objects
static const int _Ret_ = _Ret_valid_;
static const int _Ret_opt_ = _Ret_opt_valid_;
// More _Ret_ annotations are defined below
// Pointer to pointers -------------------------
// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );
static const int _Deref_out_ = _Out_ _Deref_pre_invalid_ _Deref_post_valid_;
static const int _Deref_out_opt_ = _Out_ _Deref_pre_invalid_ _Deref_post_opt_valid_;
static const int _Deref_opt_out_ = _Out_opt_ _Deref_pre_invalid_ _Deref_post_valid_;
static const int _Deref_opt_out_opt_ = _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_valid_;
// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );
static const int _Deref_out_z_ = _Out_ _Deref_pre_invalid_ _Deref_post_z_;
static const int _Deref_out_opt_z_ = _Out_ _Deref_pre_invalid_ _Deref_post_opt_z_;
static const int _Deref_opt_out_z_ = _Out_opt_ _Deref_pre_invalid_ _Deref_post_z_;
static const int _Deref_opt_out_opt_z_ = _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_z_;
// More _Deref_ annotations are defined below
// Other annotations
// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();
static const int _Check_return_ = _Check_return_impl_;
// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );
static const int _Printf_format_string_ = _Printf_format_string_impl_;
static const int _Scanf_format_string_ = _Scanf_format_string_impl_;
static const int _Scanf_s_format_string_ = _Scanf_s_format_string_impl_;
// <expr> indicates whether post conditions apply
static const int _Success_(expr) = _Success_impl_(expr);
// annotations to express 'boundedness' of integral value parameter
static const int _In_bound_ = _In_bound_impl_;
static const int _Out_bound_ = _Out_bound_impl_;
static const int _Ret_bound_ = _Ret_bound_impl_;
static const int _Deref_in_bound_ = _Deref_in_bound_impl_;
static const int _Deref_out_bound_ = _Deref_out_bound_impl_;
static const int _Deref_inout_bound_ = _Deref_in_bound_ _Deref_out_bound_;
static const int _Deref_ret_bound_ = _Deref_ret_bound_impl_;
// annotations to express upper and lower bounds of integral value parameter
static const int _In_range_(lb,ub) = _In_range_impl_(lb,ub);
static const int _Out_range_(lb,ub) = _Out_range_impl_(lb,ub);
static const int _Ret_range_(lb,ub) = _Ret_range_impl_(lb,ub);
static const int _Deref_in_range_(lb,ub) = _Deref_in_range_impl_(lb,ub);
static const int _Deref_out_range_(lb,ub) = _Deref_out_range_impl_(lb,ub);
static const int _Deref_ret_range_(lb,ub) = _Deref_ret_range_impl_(lb,ub);
//============================================================================
//   _Pre_\_Post_ Layer:
//============================================================================
//
// _Pre_ annotation ---
//
// describing conditions that must be met before the call of the function
// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string
static const int _Pre_z_ = _Pre2_impl_(_$notnull, _$zterm) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_z_ = _Pre2_impl_(_$maybenull,_$zterm) _Deref_pre1_impl_(_$valid);
// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter
static const int _Pre_cap_(size) = _Pre2_impl_(_$notnull, _$cap(size));
static const int _Pre_opt_cap_(size) = _Pre2_impl_(_$maybenull,_$cap(size));
static const int _Pre_bytecap_(size) = _Pre2_impl_(_$notnull, _$bytecap(size));
static const int _Pre_opt_bytecap_(size) = _Pre2_impl_(_$maybenull,_$bytecap(size));
// buffer capacity described by a constant expression
static const int _Pre_cap_c_(size) = _Pre2_impl_(_$notnull, _$cap_c(size));
static const int _Pre_opt_cap_c_(size) = _Pre2_impl_(_$maybenull,_$cap_c(size));
static const int _Pre_bytecap_c_(size) = _Pre2_impl_(_$notnull, _$bytecap_c(size));
static const int _Pre_opt_bytecap_c_(size) = _Pre2_impl_(_$maybenull,_$bytecap_c(size));
// buffer capacity is described by another parameter multiplied by a constant expression
static const int _Pre_cap_m_(mult,size) = _Pre2_impl_(_$notnull, _$mult(mult,size));
static const int _Pre_opt_cap_m_(mult,size) = _Pre2_impl_(_$maybenull,_$mult(mult,size));
// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);
static const int _Pre_cap_for_(param) = _Pre2_impl_(_$notnull, _$cap_for(param));
static const int _Pre_opt_cap_for_(param) = _Pre2_impl_(_$maybenull,_$cap_for(param));
// buffer capacity described by a complex condition
static const int _Pre_cap_x_(size) = _Pre2_impl_(_$notnull, _$cap_x(size));
static const int _Pre_opt_cap_x_(size) = _Pre2_impl_(_$maybenull,_$cap_x(size));
static const int _Pre_bytecap_x_(size) = _Pre2_impl_(_$notnull, _$bytecap_x(size));
static const int _Pre_opt_bytecap_x_(size) = _Pre2_impl_(_$maybenull,_$bytecap_x(size));
// buffer capacity described by the difference to another pointer parameter
static const int _Pre_ptrdiff_cap_(ptr) = _Pre2_impl_(_$notnull, _$cap_x(__ptrdiff(ptr)));
static const int _Pre_opt_ptrdiff_cap_(ptr) = _Pre2_impl_(_$maybenull,_$cap_x(__ptrdiff(ptr)));
// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );
static const int _Pre_z_cap_(size) = _Pre3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_z_cap_(size) = _Pre3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_z_bytecap_(size) = _Pre3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_z_bytecap_(size) = _Pre3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_z_cap_c_(size) = _Pre3_impl_(_$notnull, _$zterm,_$cap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_z_cap_c_(size) = _Pre3_impl_(_$maybenull,_$zterm,_$cap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_z_bytecap_c_(size) = _Pre3_impl_(_$notnull, _$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_z_bytecap_c_(size) = _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_z_cap_x_(size) = _Pre3_impl_(_$notnull, _$zterm,_$cap_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_z_cap_x_(size) = _Pre3_impl_(_$maybenull,_$zterm,_$cap_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_z_bytecap_x_(size) = _Pre3_impl_(_$notnull, _$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_z_bytecap_x_(size) = _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid);
// known capacity and valid but unknown readable extent
static const int _Pre_valid_cap_(size) = _Pre2_impl_(_$notnull, _$cap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_valid_cap_(size) = _Pre2_impl_(_$maybenull,_$cap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_valid_bytecap_(size) = _Pre2_impl_(_$notnull, _$bytecap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_valid_bytecap_(size) = _Pre2_impl_(_$maybenull,_$bytecap(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_valid_cap_c_(size) = _Pre2_impl_(_$notnull, _$cap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_valid_cap_c_(size) = _Pre2_impl_(_$maybenull,_$cap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_valid_bytecap_c_(size) = _Pre2_impl_(_$notnull, _$bytecap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_valid_bytecap_c_(size) = _Pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_valid_cap_x_(size) = _Pre2_impl_(_$notnull, _$cap_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_valid_cap_x_(size) = _Pre2_impl_(_$maybenull,_$cap_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_valid_bytecap_x_(size) = _Pre2_impl_(_$notnull, _$bytecap_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_valid_bytecap_x_(size) = _Pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid);
// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter
static const int _Pre_count_(size) = _Pre2_impl_(_$notnull, _$count(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_count_(size) = _Pre2_impl_(_$maybenull,_$count(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_bytecount_(size) = _Pre2_impl_(_$notnull, _$bytecount(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_bytecount_(size) = _Pre2_impl_(_$maybenull,_$bytecount(size)) _Deref_pre1_impl_(_$valid);
// Valid buffer extent described by a constant expression
static const int _Pre_count_c_(size) = _Pre2_impl_(_$notnull, _$count_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_count_c_(size) = _Pre2_impl_(_$maybenull,_$count_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_bytecount_c_(size) = _Pre2_impl_(_$notnull, _$bytecount_c(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_bytecount_c_(size) = _Pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_pre1_impl_(_$valid);
// Valid buffer extent described by a complex expression
static const int _Pre_count_x_(size) = _Pre2_impl_(_$notnull, _$count_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_count_x_(size) = _Pre2_impl_(_$maybenull,_$count_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_bytecount_x_(size) = _Pre2_impl_(_$notnull, _$bytecount_x(size)) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_bytecount_x_(size) = _Pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_pre1_impl_(_$valid);
// Valid buffer extent described by the difference to another pointer parameter
static const int _Pre_ptrdiff_count_(ptr) = _Pre2_impl_(_$notnull, _$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_ptrdiff_count_(ptr) = _Pre2_impl_(_$maybenull,_$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid);
// valid size unknown or indicated by type (e.g.:LPSTR)
static const int _Pre_valid_ = _Pre1_impl_(_$notnull) _Deref_pre1_impl_(_$valid);
static const int _Pre_opt_valid_ = _Pre1_impl_(_$maybenull) _Deref_pre1_impl_(_$valid);
static const int _Pre_invalid_ = _Deref_pre1_impl_(_$notvalid);
// used with allocated but not yet initialized objects
static const int _Pre_notnull_ = _Pre1_impl_(_$notnull);
static const int _Pre_maybenull_ = _Pre1_impl_(_$maybenull);
static const int _Pre_null_ = _Pre1_impl_(_$null);
// restrict access rights
static const int _Pre_readonly_ = _Pre1_impl_(_$readaccess);
static const int _Pre_writeonly_ = _Pre1_impl_(_$writeaccess);
//
// _Post_ annotations ---
//
// describing conditions that hold after the function call
// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call
static const int _Post_z_ = _Post1_impl_(_$zterm) _Deref_post1_impl_(_$valid);
// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call
static const int _Post_maybez_ = _Post1_impl_(_$maybezterm);
// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );
static const int _Post_cap_(size) = _Post1_impl_(_$cap(size));
static const int _Post_bytecap_(size) = _Post1_impl_(_$bytecap(size));
// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );
static const int _Post_count_(size) = _Post1_impl_(_$count(size)) _Deref_post1_impl_(_$valid);
static const int _Post_bytecount_(size) = _Post1_impl_(_$bytecount(size)) _Deref_post1_impl_(_$valid);
static const int _Post_count_c_(size) = _Post1_impl_(_$count_c(size)) _Deref_post1_impl_(_$valid);
static const int _Post_bytecount_c_(size) = _Post1_impl_(_$bytecount_c(size)) _Deref_post1_impl_(_$valid);
static const int _Post_count_x_(size) = _Post1_impl_(_$count_x(size)) _Deref_post1_impl_(_$valid);
static const int _Post_bytecount_x_(size) = _Post1_impl_(_$bytecount_x(size)) _Deref_post1_impl_(_$valid);
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );
static const int _Post_z_count_(size) = _Post2_impl_(_$zterm,_$count(size)) _Deref_post1_impl_(_$valid);
static const int _Post_z_bytecount_(size) = _Post2_impl_(_$zterm,_$bytecount(size)) _Deref_post1_impl_(_$valid);
static const int _Post_z_count_c_(size) = _Post2_impl_(_$zterm,_$count_c(size)) _Deref_post1_impl_(_$valid);
static const int _Post_z_bytecount_c_(size) = _Post2_impl_(_$zterm,_$bytecount_c(size)) _Deref_post1_impl_(_$valid);
static const int _Post_z_count_x_(size) = _Post2_impl_(_$zterm,_$count_x(size)) _Deref_post1_impl_(_$valid);
static const int _Post_z_bytecount_x_(size) = _Post2_impl_(_$zterm,_$bytecount_x(size)) _Deref_post1_impl_(_$valid);
// e.g. void free( _Post_ptr_invalid_ void* pv );
static const int _Post_ptr_invalid_ = _Post1_impl_(_$notvalid);
// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );
static const int _Post_valid_ = _Deref_post1_impl_(_$valid);
static const int _Post_invalid_ = _Deref_post1_impl_(_$notvalid);
// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );
static const int _Post_notnull_ = _Post1_impl_(_$notnull);
//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call
// e.g. _Ret_z_ CString::operator const wchar_t*() const throw();
static const int _Ret_z_ = _Ret2_impl_(_$notnull, _$zterm) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_z_ = _Ret2_impl_(_$maybenull,_$zterm) _Deref_ret1_impl_(_$valid);
// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter
static const int _Ret_cap_(size) = _Ret2_impl_(_$notnull, _$cap(size));
static const int _Ret_opt_cap_(size) = _Ret2_impl_(_$maybenull,_$cap(size));
static const int _Ret_bytecap_(size) = _Ret2_impl_(_$notnull, _$bytecap(size));
static const int _Ret_opt_bytecap_(size) = _Ret2_impl_(_$maybenull,_$bytecap(size));
// Buffer capacity is described by a constant expression
static const int _Ret_cap_c_(size) = _Ret2_impl_(_$notnull, _$cap_c(size));
static const int _Ret_opt_cap_c_(size) = _Ret2_impl_(_$maybenull,_$cap_c(size));
static const int _Ret_bytecap_c_(size) = _Ret2_impl_(_$notnull, _$bytecap_c(size));
static const int _Ret_opt_bytecap_c_(size) = _Ret2_impl_(_$maybenull,_$bytecap_c(size));
// Buffer capacity is described by a complex condition
static const int _Ret_cap_x_(size) = _Ret2_impl_(_$notnull, _$cap_x(size));
static const int _Ret_opt_cap_x_(size) = _Ret2_impl_(_$maybenull,_$cap_x(size));
static const int _Ret_bytecap_x_(size) = _Ret2_impl_(_$notnull, _$bytecap_x(size));
static const int _Ret_opt_bytecap_x_(size) = _Ret2_impl_(_$maybenull,_$bytecap_x(size));
// return value is nullterminated and capacity is given by another parameter
static const int _Ret_z_cap_(size) = _Ret3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_z_cap_(size) = _Ret3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_z_bytecap_(size) = _Ret3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_z_bytecap_(size) = _Ret3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid);
// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter
static const int _Ret_count_(size) = _Ret2_impl_(_$notnull, _$count(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_count_(size) = _Ret2_impl_(_$maybenull,_$count(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_bytecount_(size) = _Ret2_impl_(_$notnull, _$bytecount(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_bytecount_(size) = _Ret2_impl_(_$maybenull,_$bytecount(size)) _Deref_ret1_impl_(_$valid);
// Valid Buffer extent is described by a constant expression
static const int _Ret_count_c_(size) = _Ret2_impl_(_$notnull, _$count_c(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_count_c_(size) = _Ret2_impl_(_$maybenull,_$count_c(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_bytecount_c_(size) = _Ret2_impl_(_$notnull, _$bytecount_c(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_bytecount_c_(size) = _Ret2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_ret1_impl_(_$valid);
// Valid Buffer extent is described by a complex expression
static const int _Ret_count_x_(size) = _Ret2_impl_(_$notnull, _$count_x(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_count_x_(size) = _Ret2_impl_(_$maybenull,_$count_x(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_bytecount_x_(size) = _Ret2_impl_(_$notnull, _$bytecount_x(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_bytecount_x_(size) = _Ret2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_ret1_impl_(_$valid);
// return value is nullterminated and length is given by another parameter
static const int _Ret_z_count_(size) = _Ret3_impl_(_$notnull, _$zterm,_$count(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_z_count_(size) = _Ret3_impl_(_$maybenull,_$zterm,_$count(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_z_bytecount_(size) = _Ret3_impl_(_$notnull, _$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_z_bytecount_(size) = _Ret3_impl_(_$maybenull,_$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid);
// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );
static const int _Ret_valid_ = _Ret1_impl_(_$notnull) _Deref_ret1_impl_(_$valid);
static const int _Ret_opt_valid_ = _Ret1_impl_(_$maybenull) _Deref_ret1_impl_(_$valid);
// used with allocated but not yet initialized objects
static const int _Ret_notnull_ = _Ret1_impl_(_$notnull);
static const int _Ret_maybenull_ = _Ret1_impl_(_$maybenull);
static const int _Ret_null_ = _Ret1_impl_(_$null);
//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call
// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );
static const int _Deref_pre_z_ = _Deref_pre2_impl_(_$notnull, _$zterm) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_z_ = _Deref_pre2_impl_(_$maybenull,_$zterm) _Deref2_pre1_impl_(_$valid);
// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter
static const int _Deref_pre_cap_(size) = _Deref_pre2_impl_(_$notnull, _$cap(size));
static const int _Deref_pre_opt_cap_(size) = _Deref_pre2_impl_(_$maybenull,_$cap(size));
static const int _Deref_pre_bytecap_(size) = _Deref_pre2_impl_(_$notnull, _$bytecap(size));
static const int _Deref_pre_opt_bytecap_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecap(size));
// buffer capacity is described by a constant expression
static const int _Deref_pre_cap_c_(size) = _Deref_pre2_impl_(_$notnull, _$cap_c(size));
static const int _Deref_pre_opt_cap_c_(size) = _Deref_pre2_impl_(_$maybenull,_$cap_c(size));
static const int _Deref_pre_bytecap_c_(size) = _Deref_pre2_impl_(_$notnull, _$bytecap_c(size));
static const int _Deref_pre_opt_bytecap_c_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size));
// buffer capacity is described by a complex condition
static const int _Deref_pre_cap_x_(size) = _Deref_pre2_impl_(_$notnull, _$cap_x(size));
static const int _Deref_pre_opt_cap_x_(size) = _Deref_pre2_impl_(_$maybenull,_$cap_x(size));
static const int _Deref_pre_bytecap_x_(size) = _Deref_pre2_impl_(_$notnull, _$bytecap_x(size));
static const int _Deref_pre_opt_bytecap_x_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size));
// convenience macros for nullterminated buffers with given capacity
static const int _Deref_pre_z_cap_(size) = _Deref_pre3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_z_cap_(size) = _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_z_bytecap_(size) = _Deref_pre3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_z_bytecap_(size) = _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_z_cap_c_(size) = _Deref_pre3_impl_(_$notnull, _$zterm,_$cap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_z_cap_c_(size) = _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_z_bytecap_c_(size) = _Deref_pre3_impl_(_$notnull, _$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_z_bytecap_c_(size) = _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_z_cap_x_(size) = _Deref_pre3_impl_(_$notnull, _$zterm,_$cap_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_z_cap_x_(size) = _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_z_bytecap_x_(size) = _Deref_pre3_impl_(_$notnull, _$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_z_bytecap_x_(size) = _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid);
// known capacity and valid but unknown readable extent
static const int _Deref_pre_valid_cap_(size) = _Deref_pre2_impl_(_$notnull, _$cap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_valid_cap_(size) = _Deref_pre2_impl_(_$maybenull,_$cap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_valid_bytecap_(size) = _Deref_pre2_impl_(_$notnull, _$bytecap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_valid_bytecap_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecap(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_valid_cap_c_(size) = _Deref_pre2_impl_(_$notnull, _$cap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_valid_cap_c_(size) = _Deref_pre2_impl_(_$maybenull,_$cap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_valid_bytecap_c_(size) = _Deref_pre2_impl_(_$notnull, _$bytecap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_valid_bytecap_c_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_valid_cap_x_(size) = _Deref_pre2_impl_(_$notnull, _$cap_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_valid_cap_x_(size) = _Deref_pre2_impl_(_$maybenull,_$cap_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_valid_bytecap_x_(size) = _Deref_pre2_impl_(_$notnull, _$bytecap_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_valid_bytecap_x_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid);
// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n ); 
// valid buffer extent is described by another parameter
static const int _Deref_pre_count_(size) = _Deref_pre2_impl_(_$notnull, _$count(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_count_(size) = _Deref_pre2_impl_(_$maybenull,_$count(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_bytecount_(size) = _Deref_pre2_impl_(_$notnull, _$bytecount(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_bytecount_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecount(size)) _Deref2_pre1_impl_(_$valid);
// valid buffer extent is described by a constant expression
static const int _Deref_pre_count_c_(size) = _Deref_pre2_impl_(_$notnull, _$count_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_count_c_(size) = _Deref_pre2_impl_(_$maybenull,_$count_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_bytecount_c_(size) = _Deref_pre2_impl_(_$notnull, _$bytecount_c(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_bytecount_c_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_pre1_impl_(_$valid);
// valid buffer extent is described by a complex expression
static const int _Deref_pre_count_x_(size) = _Deref_pre2_impl_(_$notnull, _$count_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_count_x_(size) = _Deref_pre2_impl_(_$maybenull,_$count_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_bytecount_x_(size) = _Deref_pre2_impl_(_$notnull, _$bytecount_x(size)) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_bytecount_x_(size) = _Deref_pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_pre1_impl_(_$valid);
// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );
static const int _Deref_pre_valid_ = _Deref_pre1_impl_(_$notnull) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_opt_valid_ = _Deref_pre1_impl_(_$maybenull) _Deref2_pre1_impl_(_$valid);
static const int _Deref_pre_invalid_ = _Deref2_pre1_impl_(_$notvalid);
static const int _Deref_pre_notnull_ = _Deref_pre1_impl_(_$notnull);
static const int _Deref_pre_maybenull_ = _Deref_pre1_impl_(_$maybenull);
static const int _Deref_pre_null_ = _Deref_pre1_impl_(_$null);
// restrict access rights
static const int _Deref_pre_readonly_ = _Deref_pre1_impl_(_$readaccess);
static const int _Deref_pre_writeonly_ = _Deref_pre1_impl_(_$writeaccess);
//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call
// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );
static const int _Deref_post_z_ = _Deref_post2_impl_(_$notnull, _$zterm) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_z_ = _Deref_post2_impl_(_$maybenull,_$zterm) _Deref2_post1_impl_(_$valid);
// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter
static const int _Deref_post_cap_(size) = _Deref_post2_impl_(_$notnull, _$cap(size));
static const int _Deref_post_opt_cap_(size) = _Deref_post2_impl_(_$maybenull,_$cap(size));
static const int _Deref_post_bytecap_(size) = _Deref_post2_impl_(_$notnull, _$bytecap(size));
static const int _Deref_post_opt_bytecap_(size) = _Deref_post2_impl_(_$maybenull,_$bytecap(size));
// buffer capacity is described by a constant expression
static const int _Deref_post_cap_c_(size) = _Deref_post2_impl_(_$notnull, _$cap_z(size));
static const int _Deref_post_opt_cap_c_(size) = _Deref_post2_impl_(_$maybenull,_$cap_z(size));
static const int _Deref_post_bytecap_c_(size) = _Deref_post2_impl_(_$notnull, _$bytecap_z(size));
static const int _Deref_post_opt_bytecap_c_(size) = _Deref_post2_impl_(_$maybenull,_$bytecap_z(size));
// buffer capacity is described by a complex expression
static const int _Deref_post_cap_x_(size) = _Deref_post2_impl_(_$notnull, _$cap_x(size));
static const int _Deref_post_opt_cap_x_(size) = _Deref_post2_impl_(_$maybenull,_$cap_x(size));
static const int _Deref_post_bytecap_x_(size) = _Deref_post2_impl_(_$notnull, _$bytecap_x(size));
static const int _Deref_post_opt_bytecap_x_(size) = _Deref_post2_impl_(_$maybenull,_$bytecap_x(size));
// convenience macros for nullterminated buffers with given capacity
static const int _Deref_post_z_cap_(size) = _Deref_post3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_z_cap_(size) = _Deref_post3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_z_bytecap_(size) = _Deref_post3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_z_bytecap_(size) = _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_z_cap_c_(size) = _Deref_post3_impl_(_$notnull, _$zterm,_$cap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_z_cap_c_(size) = _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_z_bytecap_c_(size) = _Deref_post3_impl_(_$notnull, _$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_z_bytecap_c_(size) = _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_z_cap_x_(size) = _Deref_post3_impl_(_$notnull, _$zterm,_$cap_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_z_cap_x_(size) = _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_z_bytecap_x_(size) = _Deref_post3_impl_(_$notnull, _$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_z_bytecap_x_(size) = _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid);
// known capacity and valid but unknown readable extent
static const int _Deref_post_valid_cap_(size) = _Deref_post2_impl_(_$notnull, _$cap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_valid_cap_(size) = _Deref_post2_impl_(_$maybenull,_$cap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_valid_bytecap_(size) = _Deref_post2_impl_(_$notnull, _$bytecap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_valid_bytecap_(size) = _Deref_post2_impl_(_$maybenull,_$bytecap(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_valid_cap_c_(size) = _Deref_post2_impl_(_$notnull, _$cap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_valid_cap_c_(size) = _Deref_post2_impl_(_$maybenull,_$cap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_valid_bytecap_c_(size) = _Deref_post2_impl_(_$notnull, _$bytecap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_valid_bytecap_c_(size) = _Deref_post2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_valid_cap_x_(size) = _Deref_post2_impl_(_$notnull, _$cap_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_valid_cap_x_(size) = _Deref_post2_impl_(_$maybenull,_$cap_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_valid_bytecap_x_(size) = _Deref_post2_impl_(_$notnull, _$bytecap_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_valid_bytecap_x_(size) = _Deref_post2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid);
// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter
static const int _Deref_post_count_(size) = _Deref_post2_impl_(_$notnull, _$count(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_count_(size) = _Deref_post2_impl_(_$maybenull,_$count(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_bytecount_(size) = _Deref_post2_impl_(_$notnull, _$bytecount(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_bytecount_(size) = _Deref_post2_impl_(_$maybenull,_$bytecount(size)) _Deref2_post1_impl_(_$valid);
// buffer capacity is described by a constant expression
static const int _Deref_post_count_c_(size) = _Deref_post2_impl_(_$notnull, _$count_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_count_c_(size) = _Deref_post2_impl_(_$maybenull,_$count_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_bytecount_c_(size) = _Deref_post2_impl_(_$notnull, _$bytecount_c(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_bytecount_c_(size) = _Deref_post2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_post1_impl_(_$valid);
// buffer capacity is described by a complex expression
static const int _Deref_post_count_x_(size) = _Deref_post2_impl_(_$notnull, _$count_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_count_x_(size) = _Deref_post2_impl_(_$maybenull,_$count_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_bytecount_x_(size) = _Deref_post2_impl_(_$notnull, _$bytecount_x(size)) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_bytecount_x_(size) = _Deref_post2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_post1_impl_(_$valid);
// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );
static const int _Deref_post_valid_ = _Deref_post1_impl_(_$notnull) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_opt_valid_ = _Deref_post1_impl_(_$maybenull) _Deref2_post1_impl_(_$valid);
static const int _Deref_post_notnull_ = _Deref_post1_impl_(_$notnull);
static const int _Deref_post_maybenull_ = _Deref_post1_impl_(_$maybenull);
static const int _Deref_post_null_ = _Deref_post1_impl_(_$null);
//
// _Deref_ret_ ---
//
static const int _Deref_ret_z_ = _Deref_ret2_impl_(_$notnull, _$zterm);
static const int _Deref_ret_opt_z_ = _Deref_ret2_impl_(_$maybenull,_$zterm);
//
// special _Deref_ ---
//
static const int _Deref2_pre_readonly_ = _Deref2_pre1_impl_(_$readaccess);
// Convenience macros for more concise annotations
//
// _Pre_post ---
//
// describing conditions that hold before and after the function call
static const int _Prepost_z_ = _Pre_z_ _Post_z_;
static const int _Prepost_opt_z_ = _Pre_opt_z_ _Post_z_;
static const int _Prepost_count_(size) = _Pre_count_(size) _Post_count_(size);
static const int _Prepost_opt_count_(size) = _Pre_opt_count_(size) _Post_count_(size);
static const int _Prepost_bytecount_(size) = _Pre_bytecount_(size) _Post_bytecount_(size);
static const int _Prepost_opt_bytecount_(size) = _Pre_opt_bytecount_(size) _Post_bytecount_(size);
static const int _Prepost_count_c_(size) = _Pre_count_c_(size) _Post_count_c_(size);
static const int _Prepost_opt_count_c_(size) = _Pre_opt_count_c_(size) _Post_count_c_(size);
static const int _Prepost_bytecount_c_(size) = _Pre_bytecount_c_(size) _Post_bytecount_c_(size);
static const int _Prepost_opt_bytecount_c_(size) = _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size);
static const int _Prepost_count_x_(size) = _Pre_count_x_(size) _Post_count_x_(size);
static const int _Prepost_opt_count_x_(size) = _Pre_opt_count_x_(size) _Post_count_x_(size);
static const int _Prepost_bytecount_x_(size) = _Pre_bytecount_x_(size) _Post_bytecount_x_(size);
static const int _Prepost_opt_bytecount_x_(size) = _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size);
static const int _Prepost_valid_ = _Pre_valid_ _Post_valid_;
static const int _Prepost_opt_valid_ = _Pre_opt_valid_ _Post_valid_;
//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call
static const int _Deref_prepost_z_ = _Deref_pre_z_ _Deref_post_z_;
static const int _Deref_prepost_opt_z_ = _Deref_pre_opt_z_ _Deref_post_opt_z_;
static const int _Deref_prepost_cap_(size) = _Deref_pre_cap_(size) _Deref_post_cap_(size);
static const int _Deref_prepost_opt_cap_(size) = _Deref_pre_opt_cap_(size) _Deref_post_opt_cap_(size);
static const int _Deref_prepost_bytecap_(size) = _Deref_pre_bytecap_(size) _Deref_post_bytecap_(size);
static const int _Deref_prepost_opt_bytecap_(size) = _Deref_pre_opt_bytecap_(size) _Deref_post_opt_bytecap_(size);
static const int _Deref_prepost_cap_x_(size) = _Deref_pre_cap_x_(size) _Deref_post_cap_x_(size);
static const int _Deref_prepost_opt_cap_x_(size) = _Deref_pre_opt_cap_x_(size) _Deref_post_opt_cap_x_(size);
static const int _Deref_prepost_bytecap_x_(size) = _Deref_pre_bytecap_x_(size) _Deref_post_bytecap_x_(size);
static const int _Deref_prepost_opt_bytecap_x_(size) = _Deref_pre_opt_bytecap_x_(size) _Deref_post_opt_bytecap_x_(size);
static const int _Deref_prepost_z_cap_(size) = _Deref_pre_z_cap_(size) _Deref_post_z_cap_(size);
static const int _Deref_prepost_opt_z_cap_(size) = _Deref_pre_opt_z_cap_(size) _Deref_post_opt_z_cap_(size);
static const int _Deref_prepost_z_bytecap_(size) = _Deref_pre_z_bytecap_(size) _Deref_post_z_bytecap_(size);
static const int _Deref_prepost_opt_z_bytecap_(size) = _Deref_pre_opt_z_bytecap_(size) _Deref_post_opt_z_bytecap_(size);
static const int _Deref_prepost_valid_cap_(size) = _Deref_pre_valid_cap_(size) _Deref_post_valid_cap_(size);
static const int _Deref_prepost_opt_valid_cap_(size) = _Deref_pre_opt_valid_cap_(size) _Deref_post_opt_valid_cap_(size);
static const int _Deref_prepost_valid_bytecap_(size) = _Deref_pre_valid_bytecap_(size) _Deref_post_valid_bytecap_(size);
static const int _Deref_prepost_opt_valid_bytecap_(size) = _Deref_pre_opt_valid_bytecap_(size) _Deref_post_opt_valid_bytecap_(size);
static const int _Deref_prepost_valid_cap_x_(size) = _Deref_pre_valid_cap_x_(size) _Deref_post_valid_cap_x_(size);
static const int _Deref_prepost_opt_valid_cap_x_(size) = _Deref_pre_opt_valid_cap_x_(size) _Deref_post_opt_valid_cap_x_(size);
static const int _Deref_prepost_valid_bytecap_x_(size) = _Deref_pre_valid_bytecap_x_(size) _Deref_post_valid_bytecap_x_(size);
static const int _Deref_prepost_opt_valid_bytecap_x_(size) = _Deref_pre_opt_valid_bytecap_x_(size) _Deref_post_opt_valid_bytecap_x_(size);
static const int _Deref_prepost_count_(size) = _Deref_pre_count_(size) _Deref_post_count_(size);
static const int _Deref_prepost_opt_count_(size) = _Deref_pre_opt_count_(size) _Deref_post_opt_count_(size);
static const int _Deref_prepost_bytecount_(size) = _Deref_pre_bytecount_(size) _Deref_post_bytecount_(size);
static const int _Deref_prepost_opt_bytecount_(size) = _Deref_pre_opt_bytecount_(size) _Deref_post_opt_bytecount_(size);
static const int _Deref_prepost_count_x_(size) = _Deref_pre_count_x_(size) _Deref_post_count_x_(size);
static const int _Deref_prepost_opt_count_x_(size) = _Deref_pre_opt_count_x_(size) _Deref_post_opt_count_x_(size);
static const int _Deref_prepost_bytecount_x_(size) = _Deref_pre_bytecount_x_(size) _Deref_post_bytecount_x_(size);
static const int _Deref_prepost_opt_bytecount_x_(size) = _Deref_pre_opt_bytecount_x_(size) _Deref_post_opt_bytecount_x_(size);
static const int _Deref_prepost_valid_ = _Deref_pre_valid_ _Deref_post_valid_;
static const int _Deref_prepost_opt_valid_ = _Deref_pre_opt_valid_ _Deref_post_opt_valid_;
//
// _Deref_<miscellaneous>
//
// used with references to arrays
static const int _Deref_out_z_cap_c_(size) = _Deref_pre_cap_c_(size) _Deref_pre_invalid_ _Deref_post_z_;
static const int _Deref_inout_z_cap_c_(size) = _Deref_pre_z_cap_c_(size) _Deref_post_z_;
static const int _Deref_out_z_bytecap_c_(size) = _Deref_pre_bytecap_c_(size) _Deref_pre_invalid_ _Deref_post_z_;
static const int _Deref_inout_z_bytecap_c_(size) = _Deref_pre_z_bytecap_c_(size) _Deref_post_z_;
static const int _Deref_inout_z_ = _Deref_prepost_z_;
//============================================================================
//   Implementation Layer:
//============================================================================
# 1231 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
// This section contains the deprecated annotations
/* 
 -------------------------------------------------------------------------------
 Introduction
 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.
 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.
 -------------------------------------------------------------------------------
 Buffer Annotations
 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.
 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.
 Only a single buffer annotation should be used for each parameter.
 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|
 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.
 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.
 Usage: Describes how the function uses the buffer.
 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.
 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.
 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.
 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.
 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.
 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz	 : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.
 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.
 Parameters: Gives explicit counts for the size and length of the buffer.
 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.
 -------------------------------------------------------------------------------
 Buffer Annotation Examples
 LWSTDAPI_(BOOL) StrToIntExA(
     LPCSTR pszString,                    -- No annotation required, const implies __in.
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );
 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );
 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     LPCSTR pszSrc,                       -- No annotation required, const implies __in.
     UINT cchMax,
     DWORD dwFlags
 );
 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );
 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.
 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.
 -------------------------------------------------------------------------------
 Advanced Annotations
 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.
 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.
 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.
 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.
 __reserved v :
     Value v must be 0/NULL, reserved for future use.
 __checkReturn v :
     Return value v must not be ignored by callers of this function.
 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.
 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.
 __callback f :
     Function f can be used as a function pointer.
 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.
 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.
 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.
 -------------------------------------------------------------------------------
 Advanced Annotation Examples
 __success(return == TRUE) LWSTDAPI_(BOOL) 
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.
 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.
 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.
 -------------------------------------------------------------------------------
*/
# 1488 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
# 1497 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions
 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/
# 1511 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
/*
The helper annotations are only understood by the compiler version used by various
defect detection tools. When the regular compiler is running, they are defined into
nothing, and do not affect the compiled code.
*/
# 1721 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
/* 
-------------------------------------------------------------------------------
Buffer Annotation Definitions
Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/
# 1766 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
static const int __ecount(size) = __notnull __elem_writableTo(size);
static const int __bcount(size) = __notnull __byte_writableTo(size);
static const int __in = __pre __valid __pre __deref __readonly;
static const int __in_ecount(size) = __in __pre __elem_readableTo(size);
static const int __in_bcount(size) = __in __pre __byte_readableTo(size);
static const int __in_z = __in __pre __nullterminated;
static const int __in_ecount_z(size) = __in_ecount(size) __pre __nullterminated;
static const int __in_bcount_z(size) = __in_bcount(size) __pre __nullterminated;
static const int __in_nz = __in;
static const int __in_ecount_nz(size) = __in_ecount(size);
static const int __in_bcount_nz(size) = __in_bcount(size);
static const int __out = __ecount(1) __post __valid __refparam;
static const int __out_ecount(size) = __ecount(size) __post __valid __refparam;
static const int __out_bcount(size) = __bcount(size) __post __valid __refparam;
static const int __out_ecount_part(size,length) = __out_ecount(size) __post __elem_readableTo(length);
static const int __out_bcount_part(size,length) = __out_bcount(size) __post __byte_readableTo(length);
static const int __out_ecount_full(size) = __out_ecount_part(size,size);
static const int __out_bcount_full(size) = __out_bcount_part(size,size);
static const int __out_z = __post __valid __refparam __post __nullterminated;
static const int __out_z_opt = __post __valid __refparam __post __nullterminated __exceptthat __maybenull;
static const int __out_ecount_z(size) = __ecount(size) __post __valid __refparam __post __nullterminated;
static const int __out_bcount_z(size) = __bcount(size) __post __valid __refparam __post __nullterminated;
static const int __out_ecount_part_z(size,length) = __out_ecount_part(size,length) __post __nullterminated;
static const int __out_bcount_part_z(size,length) = __out_bcount_part(size,length) __post __nullterminated;
static const int __out_ecount_full_z(size) = __out_ecount_full(size) __post __nullterminated;
static const int __out_bcount_full_z(size) = __out_bcount_full(size) __post __nullterminated;
static const int __out_nz = __post __valid __refparam __post;
static const int __out_nz_opt = __post __valid __refparam __post __exceptthat __maybenull;
static const int __out_ecount_nz(size) = __ecount(size) __post __valid __refparam;
static const int __out_bcount_nz(size) = __bcount(size) __post __valid __refparam;
static const int __inout = __pre __valid __post __valid __refparam;
static const int __inout_ecount(size) = __out_ecount(size) __pre __valid;
static const int __inout_bcount(size) = __out_bcount(size) __pre __valid;
static const int __inout_ecount_part(size,length) = __out_ecount_part(size,length) __pre __valid __pre __elem_readableTo(length);
static const int __inout_bcount_part(size,length) = __out_bcount_part(size,length) __pre __valid __pre __byte_readableTo(length);
static const int __inout_ecount_full(size) = __inout_ecount_part(size,size);
static const int __inout_bcount_full(size) = __inout_bcount_part(size,size);
static const int __inout_z = __inout __pre __nullterminated __post __nullterminated;
static const int __inout_ecount_z(size) = __inout_ecount(size) __pre __nullterminated __post __nullterminated;
static const int __inout_bcount_z(size) = __inout_bcount(size) __pre __nullterminated __post __nullterminated;
static const int __inout_nz = __inout;
static const int __inout_ecount_nz(size) = __inout_ecount(size);
static const int __inout_bcount_nz(size) = __inout_bcount(size);
static const int __ecount_opt(size) = __ecount(size) __exceptthat __maybenull;
static const int __bcount_opt(size) = __bcount(size) __exceptthat __maybenull;
static const int __in_opt = __in __exceptthat __maybenull;
static const int __in_ecount_opt(size) = __in_ecount(size) __exceptthat __maybenull;
static const int __in_bcount_opt(size) = __in_bcount(size) __exceptthat __maybenull;
static const int __in_z_opt = __in_opt __pre __nullterminated;
static const int __in_ecount_z_opt(size) = __in_ecount_opt(size) __pre __nullterminated;
static const int __in_bcount_z_opt(size) = __in_bcount_opt(size) __pre __nullterminated;
static const int __in_nz_opt = __in_opt;
static const int __in_ecount_nz_opt(size) = __in_ecount_opt(size);
static const int __in_bcount_nz_opt(size) = __in_bcount_opt(size);
static const int __out_opt = __out __exceptthat __maybenull;
static const int __out_ecount_opt(size) = __out_ecount(size) __exceptthat __maybenull;
static const int __out_bcount_opt(size) = __out_bcount(size) __exceptthat __maybenull;
static const int __out_ecount_part_opt(size,length) = __out_ecount_part(size,length) __exceptthat __maybenull;
static const int __out_bcount_part_opt(size,length) = __out_bcount_part(size,length) __exceptthat __maybenull;
static const int __out_ecount_full_opt(size) = __out_ecount_full(size) __exceptthat __maybenull;
static const int __out_bcount_full_opt(size) = __out_bcount_full(size) __exceptthat __maybenull;
static const int __out_ecount_z_opt(size) = __out_ecount_opt(size) __post __nullterminated;
static const int __out_bcount_z_opt(size) = __out_bcount_opt(size) __post __nullterminated;
static const int __out_ecount_part_z_opt(size,length) = __out_ecount_part_opt(size,length) __post __nullterminated;
static const int __out_bcount_part_z_opt(size,length) = __out_bcount_part_opt(size,length) __post __nullterminated;
static const int __out_ecount_full_z_opt(size) = __out_ecount_full_opt(size) __post __nullterminated;
static const int __out_bcount_full_z_opt(size) = __out_bcount_full_opt(size) __post __nullterminated;
static const int __out_ecount_nz_opt(size) = __out_ecount_opt(size) __post __nullterminated;
static const int __out_bcount_nz_opt(size) = __out_bcount_opt(size) __post __nullterminated;
static const int __inout_opt = __inout __exceptthat __maybenull;
static const int __inout_ecount_opt(size) = __inout_ecount(size) __exceptthat __maybenull;
static const int __inout_bcount_opt(size) = __inout_bcount(size) __exceptthat __maybenull;
static const int __inout_ecount_part_opt(size,length) = __inout_ecount_part(size,length) __exceptthat __maybenull;
static const int __inout_bcount_part_opt(size,length) = __inout_bcount_part(size,length) __exceptthat __maybenull;
static const int __inout_ecount_full_opt(size) = __inout_ecount_full(size) __exceptthat __maybenull;
static const int __inout_bcount_full_opt(size) = __inout_bcount_full(size) __exceptthat __maybenull;
static const int __inout_z_opt = __inout_opt __pre __nullterminated __post __nullterminated;
static const int __inout_ecount_z_opt(size) = __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated;
static const int __inout_ecount_z_opt(size) = __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated;
static const int __inout_bcount_z_opt(size) = __inout_bcount_opt(size);
static const int __inout_nz_opt = __inout_opt;
static const int __inout_ecount_nz_opt(size) = __inout_ecount_opt(size);
static const int __inout_bcount_nz_opt(size) = __inout_bcount_opt(size);
static const int __deref_ecount(size) = __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __elem_writableTo(size);
static const int __deref_bcount(size) = __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __byte_writableTo(size);
static const int __deref_out = __deref_ecount(1) __post __deref __valid __refparam;
static const int __deref_out_ecount(size) = __deref_ecount(size) __post __deref __valid __refparam;
static const int __deref_out_bcount(size) = __deref_bcount(size) __post __deref __valid __refparam;
static const int __deref_out_ecount_part(size,length) = __deref_out_ecount(size) __post __deref __elem_readableTo(length);
static const int __deref_out_bcount_part(size,length) = __deref_out_bcount(size) __post __deref __byte_readableTo(length);
static const int __deref_out_ecount_full(size) = __deref_out_ecount_part(size,size);
static const int __deref_out_bcount_full(size) = __deref_out_bcount_part(size,size);
static const int __deref_out_z = __post __deref __valid __refparam __post __deref __nullterminated;
static const int __deref_out_ecount_z(size) = __deref_out_ecount(size) __post __deref __nullterminated;
static const int __deref_out_bcount_z(size) = __deref_out_ecount(size) __post __deref __nullterminated;
static const int __deref_out_nz = __deref_out;
static const int __deref_out_ecount_nz(size) = __deref_out_ecount(size);
static const int __deref_out_bcount_nz(size) = __deref_out_ecount(size);
static const int __deref_inout = __notnull __elem_readableTo(1) __pre __deref __valid __post __deref __valid __refparam;
static const int __deref_inout_z = __deref_inout __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_inout_ecount(size) = __deref_inout __pre __deref __elem_writableTo(size) __post __deref __elem_writableTo(size);
static const int __deref_inout_bcount(size) = __deref_inout __pre __deref __byte_writableTo(size) __post __deref __byte_writableTo(size);
static const int __deref_inout_ecount_part(size,length) = __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length);
static const int __deref_inout_bcount_part(size,length) = __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length);
static const int __deref_inout_ecount_full(size) = __deref_inout_ecount_part(size,size);
static const int __deref_inout_bcount_full(size) = __deref_inout_bcount_part(size,size);
static const int __deref_inout_z = __deref_inout __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_inout_ecount_z(size) = __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_inout_bcount_z(size) = __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_inout_nz = __deref_inout;
static const int __deref_inout_ecount_nz(size) = __deref_inout_ecount(size);
static const int __deref_inout_bcount_nz(size) = __deref_inout_ecount(size);
static const int __deref_ecount_opt(size) = __deref_ecount(size) __post __deref __exceptthat __maybenull;
static const int __deref_bcount_opt(size) = __deref_bcount(size) __post __deref __exceptthat __maybenull;
static const int __deref_out_opt = __deref_out __post __deref __exceptthat __maybenull;
static const int __deref_out_ecount_opt(size) = __deref_out_ecount(size) __post __deref __exceptthat __maybenull;
static const int __deref_out_bcount_opt(size) = __deref_out_bcount(size) __post __deref __exceptthat __maybenull;
static const int __deref_out_ecount_part_opt(size,length) = __deref_out_ecount_part(size,length) __post __deref __exceptthat __maybenull;
static const int __deref_out_bcount_part_opt(size,length) = __deref_out_bcount_part(size,length) __post __deref __exceptthat __maybenull;
static const int __deref_out_ecount_full_opt(size) = __deref_out_ecount_full(size) __post __deref __exceptthat __maybenull;
static const int __deref_out_bcount_full_opt(size) = __deref_out_bcount_full(size) __post __deref __exceptthat __maybenull;
static const int __deref_out_z_opt = __post __deref __valid __refparam __execeptthat __maybenull __post __deref __nullterminated;
static const int __deref_out_ecount_z_opt(size) = __deref_out_ecount_opt(size) __post __deref __nullterminated;
static const int __deref_out_bcount_z_opt(size) = __deref_out_bcount_opt(size) __post __deref __nullterminated;
static const int __deref_out_nz_opt = __deref_out_opt;
static const int __deref_out_ecount_nz_opt(size) = __deref_out_ecount_opt(size);
static const int __deref_out_bcount_nz_opt(size) = __deref_out_bcount_opt(size);
static const int __deref_inout_opt = __deref_inout __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_ecount_opt(size) = __deref_inout_ecount(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_bcount_opt(size) = __deref_inout_bcount(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_ecount_part_opt(size,length) = __deref_inout_ecount_part(size,length) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_bcount_part_opt(size,length) = __deref_inout_bcount_part(size,length) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_ecount_full_opt(size) = __deref_inout_ecount_full(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_bcount_full_opt(size) = __deref_inout_bcount_full(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_z_opt = __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_inout_ecount_z_opt(size) = __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_inout_bcount_z_opt(size) = __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_inout_nz_opt = __deref_inout_opt;
static const int __deref_inout_ecount_nz_opt(size) = __deref_inout_ecount_opt(size);
static const int __deref_inout_bcount_nz_opt(size) = __deref_inout_bcount_opt(size);
static const int __deref_opt_ecount(size) = __deref_ecount(size) __exceptthat __maybenull;
static const int __deref_opt_bcount(size) = __deref_bcount(size) __exceptthat __maybenull;
static const int __deref_opt_out = __deref_out __exceptthat __maybenull;
static const int __deref_opt_out_z = __deref_opt_out __post __deref __nullterminated;
static const int __deref_opt_out_ecount(size) = __deref_out_ecount(size) __exceptthat __maybenull;
static const int __deref_opt_out_bcount(size) = __deref_out_bcount(size) __exceptthat __maybenull;
static const int __deref_opt_out_ecount_part(size,length) = __deref_out_ecount_part(size,length) __exceptthat __maybenull;
static const int __deref_opt_out_bcount_part(size,length) = __deref_out_bcount_part(size,length) __exceptthat __maybenull;
static const int __deref_opt_out_ecount_full(size) = __deref_out_ecount_full(size) __exceptthat __maybenull;
static const int __deref_opt_out_bcount_full(size) = __deref_out_bcount_full(size) __exceptthat __maybenull;
static const int __deref_opt_inout = __deref_inout __exceptthat __maybenull;
static const int __deref_opt_inout_ecount(size) = __deref_inout_ecount(size) __exceptthat __maybenull;
static const int __deref_opt_inout_bcount(size) = __deref_inout_bcount(size) __exceptthat __maybenull;
static const int __deref_opt_inout_ecount_part(size,length) = __deref_inout_ecount_part(size,length) __exceptthat __maybenull;
static const int __deref_opt_inout_bcount_part(size,length) = __deref_inout_bcount_part(size,length) __exceptthat __maybenull;
static const int __deref_opt_inout_ecount_full(size) = __deref_inout_ecount_full(size) __exceptthat __maybenull;
static const int __deref_opt_inout_bcount_full(size) = __deref_inout_bcount_full(size) __exceptthat __maybenull;
static const int __deref_opt_inout_z = __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_opt_inout_ecount_z(size) = __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_opt_inout_bcount_z(size) = __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_opt_inout_nz = __deref_opt_inout;
static const int __deref_opt_inout_ecount_nz(size) = __deref_opt_inout_ecount(size);
static const int __deref_opt_inout_bcount_nz(size) = __deref_opt_inout_bcount(size);
static const int __deref_opt_ecount_opt(size) = __deref_ecount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_bcount_opt(size) = __deref_bcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_out_opt = __deref_out_opt __exceptthat __maybenull;
static const int __deref_opt_out_ecount_opt(size) = __deref_out_ecount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_out_bcount_opt(size) = __deref_out_bcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_out_ecount_part_opt(size,length) = __deref_out_ecount_part_opt(size,length) __exceptthat __maybenull;
static const int __deref_opt_out_bcount_part_opt(size,length) = __deref_out_bcount_part_opt(size,length) __exceptthat __maybenull;
static const int __deref_opt_out_ecount_full_opt(size) = __deref_out_ecount_full_opt(size) __exceptthat __maybenull;
static const int __deref_opt_out_bcount_full_opt(size) = __deref_out_bcount_full_opt(size) __exceptthat __maybenull;
static const int __deref_opt_out_z_opt = __post __deref __valid __refparam __exceptthat __maybenull __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull __post __deref __nullterminated;
static const int __deref_opt_out_ecount_z_opt(size) = __deref_opt_out_ecount_opt(size) __post __deref __nullterminated;
static const int __deref_opt_out_bcount_z_opt(size) = __deref_opt_out_bcount_opt(size) __post __deref __nullterminated;
static const int __deref_opt_out_nz_opt = __deref_opt_out_opt;
static const int __deref_opt_out_ecount_nz_opt(size) = __deref_opt_out_ecount_opt(size);
static const int __deref_opt_out_bcount_nz_opt(size) = __deref_opt_out_bcount_opt(size);
static const int __deref_opt_inout_opt = __deref_inout_opt __exceptthat __maybenull;
static const int __deref_opt_inout_ecount_opt(size) = __deref_inout_ecount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_inout_bcount_opt(size) = __deref_inout_bcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_inout_ecount_part_opt(size,length) = __deref_inout_ecount_part_opt(size,length) __exceptthat __maybenull;
static const int __deref_opt_inout_bcount_part_opt(size,length) = __deref_inout_bcount_part_opt(size,length) __exceptthat __maybenull;
static const int __deref_opt_inout_ecount_full_opt(size) = __deref_inout_ecount_full_opt(size) __exceptthat __maybenull;
static const int __deref_opt_inout_bcount_full_opt(size) = __deref_inout_bcount_full_opt(size) __exceptthat __maybenull;
static const int __deref_opt_inout_z_opt = __deref_opt_inout_opt __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_opt_inout_ecount_z_opt(size) = __deref_opt_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_opt_inout_bcount_z_opt(size) = __deref_opt_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated;
static const int __deref_opt_inout_nz_opt = __deref_opt_inout_opt;
static const int __deref_opt_inout_ecount_nz_opt(size) = __deref_opt_inout_ecount_opt(size);
static const int __deref_opt_inout_bcount_nz_opt(size) = __deref_opt_inout_bcount_opt(size);
/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions
Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/
# 1968 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
static const int __success(expr) = __inner_success(expr);
static const int __nullterminated = __readableTo(sentinel(0));
static const int __reserved = __pre __null;
static const int __checkReturn = __inner_checkReturn;
static const int __typefix(ctype) = __inner_typefix(ctype);
static const int __override = __inner_override;
static const int __callback = __inner_callback;
static const int __blocksOn(resource) = __inner_blocksOn(resource);
static const int __control_entrypoint(category) = __inner_control_entrypoint(category);
static const int __data_entrypoint(category) = __inner_data_entrypoint(category);
static const int __fallthrough = __inner_fallthrough;
# 57 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 2
static const int _CRT_PACKING = 8;
#pragma pack(push,_CRT_PACKING)
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h" 1
/***
*vadefs.h - defines helper macros for stdarg.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is a helper file for stdarg.h
*
*       [Public]
*
****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
# 27 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
static const int _CRT_PACKING = 8;
#pragma pack(push,_CRT_PACKING)
# 40 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
typedef unsigned __int64 uintptr_t;
typedef char * va_list;
static const int _ADDRESSOF(v) = ( &(v) );
# 79 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
static const int _SLOTSIZEOF(t) = (sizeof(t));
static const int _APALIGN(t,ap) = (__alignof(t));
# 132 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
/* A guess at the proper definitions for other platforms */
static const int _INTSIZEOF(n) = ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) );
static const int _crt_va_start(ap,v) = ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) );
static const int _crt_va_arg(ap,t) = ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) );
static const int _crt_va_end(ap) = ( ap = (va_list)0 );
#pragma pack(pop)
# 64 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 2
/* preprocessor string helpers */
static const int __CRT_STRINGIZE(_Value) = #_Value;
static const int _CRT_STRINGIZE(_Value) = __CRT_STRINGIZE(_Value);
static const int __CRT_WIDE(_String) = L ## _String;
static const int _CRT_WIDE(_String) = __CRT_WIDE(_String);
static const int __CRT_APPEND(_Value1,_Value2) = _Value1 ## _Value2;
static const int _CRT_APPEND(_Value1,_Value2) = __CRT_APPEND(_Value1, _Value2);
# 94 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Define _CRTIMP_NOIA64 */
static const int _CRTIMP_NOIA64 = _CRTIMP;
/* Define _CRTIMP2 */
/* Define _CRTIMP_ALTERNATIVE */
# 124 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Define _MRTIMP */
static const int _MRTIMP = __declspec(dllimport);
/* Define _MRTIMP2 */
# 151 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int __CLRCALL_OR_CDECL = __cdecl;
static const int _CRTIMP_PURE = _CRTIMP;
# 187 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* define a specific constant for mixed mode */
/* Define __STDC_SECURE_LIB__ */
static const long __STDC_SECURE_LIB__ = 200411L;
/* Retain__GOT_SECURE_LIB__ for back-compat */
static const int __GOT_SECURE_LIB__ = __STDC_SECURE_LIB__;
/* Default value for __STDC_WANT_SECURE_LIB__ is 1 */
static const int __STDC_WANT_SECURE_LIB__ = 1;
/* Turn off warnings if __STDC_WANT_SECURE_LIB__ is 0 */
/* See note on use of deprecate at the top of this file */
static const int _CRT_DEPRECATE_TEXT(_Text) = __declspec(deprecated(_Text));
/* Define _CRT_INSECURE_DEPRECATE */
/* See note on use of deprecate at the top of this file */
# 235 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_INSECURE_DEPRECATE(_Replacement) = _CRT_DEPRECATE_TEXT("This function or variable may be unsafe. Consider using " #_Replacement " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.");
/* Define _CRT_INSECURE_DEPRECATE_MEMORY */
/* See note on use of deprecate at the top of this file */
/* Define _CRT_INSECURE_DEPRECATE_GLOBALS */
/* See note on use of deprecate at the top of this file */
# 268 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement) = _CRT_INSECURE_DEPRECATE(_Replacement);
/* Define _CRT_MANAGED_HEAP_DEPRECATE */
/* See note on use of deprecate at the top of this file */
# 289 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Change the __FILL_BUFFER_PATTERN to 0xFE to fix security function buffer overrun detection bug */
static const int _SECURECRT_FILL_BUFFER_PATTERN = 0xFE;
/* obsolete stuff */
/* Define _CRT_OBSOLETE */
/* See note on use of deprecate at the top of this file */
# 309 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_OBSOLETE(_NewItem) = _CRT_DEPRECATE_TEXT("This function or variable has been superceded by newer library or operating system functionality. Consider using " #_NewItem " instead. See online help for details.");
/* jit64 instrinsic stuff */
/* Define overload switches */
static const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;
# 337 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
  /* _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0 */
static const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;
# 349 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;
# 362 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;
# 372 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;
# 381 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_SECURE_CPP_NOTHROW = throw();
/* Define _CRT_NONSTDC_DEPRECATE */
/* See note on use of deprecate at the top of this file */
# 394 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_NONSTDC_DEPRECATE(_NewName) = _CRT_DEPRECATE_TEXT("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " #_NewName ". See online help for details.");
typedef unsigned __int64 size_t;
typedef size_t rsize_t;
typedef __int64 intptr_t;
# 434 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
typedef __int64 ptrdiff_t;
typedef unsigned short wchar_t;
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
# 468 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
typedef int errno_t;
typedef long __time32_t; /* 32-bit time value */
typedef __int64 __time64_t; /* 64-bit time value */
typedef __time64_t time_t; /* time value */
static const int _CRT_ALIGN(x) = __declspec(align(x));
/* Define _CRTNOALIAS, _CRTRESTRICT */
static const int _CRTNOALIAS = __declspec(noalias);
static const int _CRTRESTRICT = __declspec(restrict);
static const int __CRTDECL = __cdecl;
/* error reporting helpers */
static const int __STR2WSTR(str) = L ##str;
static const int _STR2WSTR(str) = __STR2WSTR(str);
static const int __FILEW__ = _STR2WSTR(__FILE__);
static const int __FUNCTIONW__ = _STR2WSTR(__FUNCTION__);
/* invalid_parameter */
 void __attribute__((__cdecl__)) _invalid_parameter_noinfo(void);
 __attribute__((noreturn)) void __attribute__((__cdecl__)) _invalid_parameter_noinfo_noreturn(void);
 __attribute__((noreturn))
void __attribute__((__cdecl__)) _invoke_watson( const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
 /* By default, _CRT_SECURE_INVALID_PARAMETER in retail invokes _invalid_parameter_noinfo_noreturn(),
  * which is marked __declspec(noreturn) and does not return control to the application. Even if 
  * _set_invalid_parameter_handler() is used to set a new invalid parameter handler which does return
  * control to the application, _invalid_parameter_noinfo_noreturn() will terminate the application and
  * invoke Watson. You can overwrite the definition of _CRT_SECURE_INVALID_PARAMETER if you need.
  *
  * _CRT_SECURE_INVALID_PARAMETER is used in the Standard C++ Libraries and the SafeInt library.
  */
# 566 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_SECURE_INVALID_PARAMETER(expr) = ::_invalid_parameter_noinfo_noreturn();
static const int _ARGMAX = 100;
/* _TRUNCATE */
static const int _TRUNCATE = ((size_t)-1);
/* helper macros for cpp overloads */
# 726 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _VFuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2);
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3);
# 1808 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SecureVFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);;
static const int __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);;
static const int __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst);
static const int __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1);
static const int __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);
static const int __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);
static const int __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst);
static const int __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1);
static const int __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);
static const int __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) = _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;
typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;
typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; /* LCID */
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;
# 2010 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
# 2033 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
static const int _CRT_UNUSED(x) = (void)x;
#pragma pack(pop)
# 21 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h" 2
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
# 26 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
#pragma pack(push,_CRT_PACKING)
/*
 * Exception disposition return values.
 */
# 35 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;
/*
 * Prototype for SEH support function.
 */
# 93 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
/*
 * Keywords and intrinsics for SEH
 */
# 97 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
static const int GetExceptionCode = _exception_code;
static const int exception_code = _exception_code;
static const int GetExceptionInformation = (struct _EXCEPTION_POINTERS *)_exception_info;
static const int exception_info = (struct _EXCEPTION_POINTERS *)_exception_info;
static const int AbnormalTermination = _abnormal_termination;
static const int abnormal_termination = _abnormal_termination;
unsigned long __attribute__((__cdecl__)) _exception_code(void);
void * __attribute__((__cdecl__)) _exception_info(void);
int __attribute__((__cdecl__)) _abnormal_termination(void);
/*
 * Legal values for expression in except().
 */
# 113 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
static const int EXCEPTION_EXECUTE_HANDLER = 1;
static const int EXCEPTION_CONTINUE_SEARCH = 0;
static const int EXCEPTION_CONTINUE_EXECUTION = -1;
#pragma pack(pop)
# 152 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/stdarg.h" 1
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/stdarg.h"
# 27 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/stdarg.h"
static const int va_start = _crt_va_start;
static const int va_arg = _crt_va_arg;
static const int va_end = _crt_va_end;
# 153 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h" 1
/****************************************************************************
*                                                                           *
* windef.h -- Basic Windows Type Definitions                                *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.                 *
*                                                                           *
****************************************************************************/
# 11 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
static const int STRICT = 1;
// Win32 defines _WIN32 automatically,
// but Macintosh doesn't, so if we are using
// Win32 Functions, we must do it here
# 42 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
/*
 * BASETYPES is defined in ntdef.h if these types are already defined
 */
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
static const int MAX_PATH = 260;
static const int NULL = ((void *)0);
static const int FALSE = 0;
static const int TRUE = 1;
# 105 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
# 130 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
static const int APIENTRY = WINAPI;
static const int PASCAL = pascal;
static const int WINAPI_INLINE = WINAPI;
static const int FAR = far;
static const int NEAR = near;
static const int CONST = const;
typedef unsigned long DWORD;
typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef float FLOAT;
typedef FLOAT *PFLOAT;
typedef BOOL *PBOOL;
typedef BOOL *LPBOOL;
typedef BYTE *PBYTE;
typedef BYTE *LPBYTE;
typedef int *PINT;
typedef int *LPINT;
typedef WORD *PWORD;
typedef WORD *LPWORD;
typedef long *LPLONG;
typedef DWORD *PDWORD;
typedef DWORD *LPDWORD;
typedef void *LPVOID;
typedef const void *LPCVOID;
typedef int INT;
typedef unsigned int UINT;
typedef unsigned int *PUINT;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 1
/*++ BUILD Version: 0091     Increment this if a change has global effects
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    winnt.h
Abstract:
    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.
Revision History:
--*/
# 19 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#pragma warning(disable:4201)
#pragma warning(disable:4214)
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h" 1
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/
# 14 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */
/* Define _CRTIMP */
# 20 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h" 2
static const int WEOF = (wint_t)(0xFFFF);
static const int __PCTYPE_FUNC = __pctype_func();
 const unsigned short * __attribute__((__cdecl__)) __pctype_func(void);
 extern const unsigned short *_pctype;
 extern const unsigned short _wctype[];
 const wctype_t * __attribute__((__cdecl__)) __pwctype_func(void);
 extern const wctype_t *_pwctype;
# 72 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
/* set bit masks for the possible character types */
static const int _UPPER = 0x1;
static const int _LOWER = 0x2;
static const int _DIGIT = 0x4;
static const int _SPACE = 0x8;
                                /* vertical tab or form feed */
static const int _PUNCT = 0x10;
static const int _CONTROL = 0x20;
static const int _BLANK = 0x40;
static const int _HEX = 0x80;
static const int _LEADBYTE = 0x8000;
static const int _ALPHA = (0x0100|_UPPER|_LOWER);
/* character classification function prototypes */
 int __attribute__((__cdecl__)) _isctype( int _C, int _Type);
 int __attribute__((__cdecl__)) _isctype_l( int _C, int _Type, _locale_t _Locale);
 int __attribute__((__cdecl__)) isalpha( int _C);
 int __attribute__((__cdecl__)) _isalpha_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isupper( int _C);
 int __attribute__((__cdecl__)) _isupper_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) islower( int _C);
 int __attribute__((__cdecl__)) _islower_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isdigit( int _C);
 int __attribute__((__cdecl__)) _isdigit_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isxdigit( int _C);
 int __attribute__((__cdecl__)) _isxdigit_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isspace( int _C);
 int __attribute__((__cdecl__)) _isspace_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) ispunct( int _C);
 int __attribute__((__cdecl__)) _ispunct_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isalnum( int _C);
 int __attribute__((__cdecl__)) _isalnum_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isprint( int _C);
 int __attribute__((__cdecl__)) _isprint_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isgraph( int _C);
 int __attribute__((__cdecl__)) _isgraph_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iscntrl( int _C);
 int __attribute__((__cdecl__)) _iscntrl_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) toupper( int _C);
 int __attribute__((__cdecl__)) tolower( int _C);
 int __attribute__((__cdecl__)) _tolower( int _C);
 int __attribute__((__cdecl__)) _tolower_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) _toupper( int _C);
 int __attribute__((__cdecl__)) _toupper_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) __isascii( int _C);
 int __attribute__((__cdecl__)) __toascii( int _C);
 int __attribute__((__cdecl__)) __iscsymf( int _C);
 int __attribute__((__cdecl__)) __iscsym( int _C);
/* wide function prototypes, also declared in wchar.h  */
/* character classification function prototypes */
 int __attribute__((__cdecl__)) iswalpha( wint_t _C);
 int __attribute__((__cdecl__)) _iswalpha_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswupper( wint_t _C);
 int __attribute__((__cdecl__)) _iswupper_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswlower( wint_t _C);
 int __attribute__((__cdecl__)) _iswlower_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswdigit( wint_t _C);
 int __attribute__((__cdecl__)) _iswdigit_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswxdigit( wint_t _C);
 int __attribute__((__cdecl__)) _iswxdigit_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswspace( wint_t _C);
 int __attribute__((__cdecl__)) _iswspace_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswpunct( wint_t _C);
 int __attribute__((__cdecl__)) _iswpunct_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswalnum( wint_t _C);
 int __attribute__((__cdecl__)) _iswalnum_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswprint( wint_t _C);
 int __attribute__((__cdecl__)) _iswprint_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswgraph( wint_t _C);
 int __attribute__((__cdecl__)) _iswgraph_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswcntrl( wint_t _C);
 int __attribute__((__cdecl__)) _iswcntrl_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswascii( wint_t _C);
 int __attribute__((__cdecl__)) isleadbyte( int _C);
 int __attribute__((__cdecl__)) _isleadbyte_l( int _C, _locale_t _Locale);
 wint_t __attribute__((__cdecl__)) towupper( wint_t _C);
 wint_t __attribute__((__cdecl__)) _towupper_l( wint_t _C, _locale_t _Locale);
 wint_t __attribute__((__cdecl__)) towlower( wint_t _C);
 wint_t __attribute__((__cdecl__)) _towlower_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswctype( wint_t _C, wctype_t _Type);
 int __attribute__((__cdecl__)) _iswctype_l( wint_t _C, wctype_t _Type, _locale_t _Locale);
 int __attribute__((__cdecl__)) __iswcsymf( wint_t _C);
 int __attribute__((__cdecl__)) _iswcsymf_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) __iswcsym( wint_t _C);
 int __attribute__((__cdecl__)) _iswcsym_l( wint_t _C, _locale_t _Locale);
__attribute__((deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "iswctype" " instead. See online help for details."))) int __attribute__((__cdecl__)) is_wctype( wint_t _C, wctype_t _Type);
/* the character classification macro definitions */
/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
static const int MB_CUR_MAX = ___mb_cur_max_func();
/* No data exports in pure code */
 extern int __mb_cur_max;
 int __attribute__((__cdecl__)) ___mb_cur_max_func(void);
 int __attribute__((__cdecl__)) ___mb_cur_max_l_func(_locale_t);
/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
static const int __chvalidchk(a,b) = (__PCTYPE_FUNC[(a)] & (b));
# 262 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
static const int _chvalidchk_l(_Char,_Flag,_Locale) = (_Locale==NULL ? __chvalidchk(_Char, _Flag) : ((_locale_t)_Locale)->locinfo->pctype[_Char] & (_Flag));
static const int _ischartype_l(_Char,_Flag,_Locale) = ( ((_Locale)!=NULL && (((_locale_t)(_Locale))->locinfo->mb_cur_max) > 1) ? _isctype_l(_Char, (_Flag), _Locale) : _chvalidchk_l(_Char,_Flag,_Locale));
static const int _isalpha_l(_Char,_Locale) = _ischartype_l(_Char, _ALPHA, _Locale);
static const int _isupper_l(_Char,_Locale) = _ischartype_l(_Char, _UPPER, _Locale);
static const int _islower_l(_Char,_Locale) = _ischartype_l(_Char, _LOWER, _Locale);
static const int _isdigit_l(_Char,_Locale) = _ischartype_l(_Char, _DIGIT, _Locale);
static const int _isxdigit_l(_Char,_Locale) = _ischartype_l(_Char, _HEX, _Locale);
static const int _isspace_l(_Char,_Locale) = _ischartype_l(_Char, _SPACE, _Locale);
static const int _ispunct_l(_Char,_Locale) = _ischartype_l(_Char, _PUNCT, _Locale);
static const int _isalnum_l(_Char,_Locale) = _ischartype_l(_Char, _ALPHA|_DIGIT, _Locale);
static const int _isprint_l(_Char,_Locale) = _ischartype_l(_Char, _BLANK|_PUNCT|_ALPHA|_DIGIT, _Locale);
static const int _isgraph_l(_Char,_Locale) = _ischartype_l(_Char, _PUNCT|_ALPHA|_DIGIT, _Locale);
static const int _iscntrl_l(_Char,_Locale) = _ischartype_l(_Char, _CONTROL, _Locale);
static const int _tolower(_Char) = ( (_Char)-'A'+'a' );
static const int _toupper(_Char) = ( (_Char)-'a'+'A' );
static const int __isascii(_Char) = ( (unsigned)(_Char) < 0x80 );
static const int __toascii(_Char) = ( (_Char) & 0x7f );
static const int iswalpha(_c) = ( iswctype(_c,_ALPHA) );
static const int iswupper(_c) = ( iswctype(_c,_UPPER) );
static const int iswlower(_c) = ( iswctype(_c,_LOWER) );
static const int iswdigit(_c) = ( iswctype(_c,_DIGIT) );
static const int iswxdigit(_c) = ( iswctype(_c,_HEX) );
static const int iswspace(_c) = ( iswctype(_c,_SPACE) );
static const int iswpunct(_c) = ( iswctype(_c,_PUNCT) );
static const int iswalnum(_c) = ( iswctype(_c,_ALPHA|_DIGIT) );
static const int iswprint(_c) = ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) );
static const int iswgraph(_c) = ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) );
static const int iswcntrl(_c) = ( iswctype(_c,_CONTROL) );
static const int iswascii(_c) = ( (unsigned)(_c) < 0x80 );
static const int _iswalpha_l(_c,_p) = ( iswctype(_c,_ALPHA) );
static const int _iswupper_l(_c,_p) = ( iswctype(_c,_UPPER) );
static const int _iswlower_l(_c,_p) = ( iswctype(_c,_LOWER) );
static const int _iswdigit_l(_c,_p) = ( iswctype(_c,_DIGIT) );
static const int _iswxdigit_l(_c,_p) = ( iswctype(_c,_HEX) );
static const int _iswspace_l(_c,_p) = ( iswctype(_c,_SPACE) );
static const int _iswpunct_l(_c,_p) = ( iswctype(_c,_PUNCT) );
static const int _iswalnum_l(_c,_p) = ( iswctype(_c,_ALPHA|_DIGIT) );
static const int _iswprint_l(_c,_p) = ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) );
static const int _iswgraph_l(_c,_p) = ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) );
static const int _iswcntrl_l(_c,_p) = ( iswctype(_c,_CONTROL) );
# 342 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
/* MS C version 2.0 extended ctype macros */
static const int __iscsymf(_c) = (isalpha(_c) || ((_c) == '_'));
static const int __iscsym(_c) = (isalnum(_c) || ((_c) == '_'));
static const int __iswcsymf(_c) = (iswalpha(_c) || ((_c) == '_'));
static const int __iswcsym(_c) = (iswalnum(_c) || ((_c) == '_'));
static const int _iscsymf_l(_c,_p) = (_isalpha_l(_c, _p) || ((_c) == '_'));
static const int _iscsym_l(_c,_p) = (_isalnum_l(_c, _p) || ((_c) == '_'));
static const int _iswcsymf_l(_c,_p) = (iswalpha(_c) || ((_c) == '_'));
static const int _iswcsym_l(_c,_p) = (iswalnum(_c) || ((_c) == '_'));
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
static const int ANYSIZE_ARRAY = 1;
//
// For compilers that don't support nameless unions/structs
//
static const int DUMMYUNIONNAME = u;
static const int DUMMYUNIONNAME2 = u2;
static const int DUMMYUNIONNAME3 = u3;
static const int DUMMYUNIONNAME4 = u4;
static const int DUMMYUNIONNAME5 = u5;
static const int DUMMYUNIONNAME6 = u6;
static const int DUMMYUNIONNAME7 = u7;
static const int DUMMYUNIONNAME8 = u8;
static const int DUMMYUNIONNAME9 = u9;
# 63 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int DUMMYSTRUCTNAME = s;
static const int DUMMYSTRUCTNAME2 = s2;
static const int DUMMYSTRUCTNAME3 = s3;
static const int DUMMYSTRUCTNAME4 = s4;
static const int DUMMYSTRUCTNAME5 = s5;
# 77 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 1
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sal_supp.h" 1
// A temporary header to supplement sal.h with things that currently 
// cannot be put into sal.h.
// This is designed to be included at the beginning of a compilation unit
// (via force-include) if necessary.
# 53 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sal_supp.h"
# 4 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_supp.h" 1
// A temporary header to supplement specstrings.h with things that currently 
// cannot be put into specstrings.h.
// This is designed to be included at the beginning of a compilation unit
// (via force-include) if necessary.
# 74 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_supp.h"
# 5 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2
/*************************************************************************
* See specstrings_strict.h for documentation of all user visible macros.
*************************************************************************/
static const int __SAL_H_FULL_VER = 140050727;
/* version specific fixes to bring sal.h upto date */
# 35 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
static const int __xcount(size) = __notnull __inexpressible_writableTo(size);
static const int __in_xcount(size) = __in __pre __inexpressible_readableTo(size);
static const int __out_xcount(size) = __xcount(size) __post __valid __refparam;
static const int __out_xcount_part(size,length) = __out_xcount(size) __post __inexpressible_readableTo(length);
static const int __out_xcount_full(size) = __out_xcount_part(size,size);
static const int __inout_xcount(size) = __out_xcount(size) __pre __valid;
static const int __inout_xcount_part(size,length) = __out_xcount_part(size,length) __pre __valid __pre __inexpressible_readableTo(length);
static const int __inout_xcount_full(size) = __inout_xcount_part(size,size);
static const int __xcount_opt(size) = __xcount(size) __exceptthat __maybenull;
static const int __in_xcount_opt(size) = __in_xcount(size) __exceptthat __maybenull;
static const int __out_xcount_opt(size) = __out_xcount(size) __exceptthat __maybenull;
static const int __out_xcount_part_opt(size,length) = __out_xcount_part(size,length) __exceptthat __maybenull;
static const int __out_xcount_full_opt(size) = __out_xcount_full(size) __exceptthat __maybenull;
static const int __inout_xcount_opt(size) = __inout_xcount(size) __exceptthat __maybenull;
static const int __inout_xcount_part_opt(size,length) = __inout_xcount_part(size,length) __exceptthat __maybenull;
static const int __inout_xcount_full_opt(size) = __inout_xcount_full(size) __exceptthat __maybenull;
static const int __deref_xcount(size) = __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size);
static const int __deref_in = __in __pre __deref __deref __readonly;
static const int __deref_in_ecount(size) = __deref_in __pre __deref __elem_readableTo(size);
static const int __deref_in_bcount(size) = __deref_in __pre __deref __byte_readableTo(size);
static const int __deref_in_xcount(size) = __deref_in __pre __deref __inexpressible_readableTo(size);
static const int __deref_out_xcount(size) = __deref_xcount(size) __post __deref __valid __refparam;
static const int __deref_out_xcount_part(size,length) = __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length);
static const int __deref_out_xcount_full(size) = __deref_out_xcount_part(size,size);
static const int __deref_out_xcount(size) = __deref_xcount(size) __post __deref __valid __refparam;
static const int __inout_xcount_opt(size) = __inout_xcount(size) __exceptthat __maybenull;
static const int __inout_xcount_part_opt(size,length) = __inout_xcount_part(size,length) __exceptthat __maybenull;
static const int __inout_xcount_full_opt(size) = __inout_xcount_full(size) __exceptthat __maybenull;
static const int __deref_xcount(size) = __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size);
static const int __deref_in = __in __pre __deref __deref __readonly;
static const int __deref_in_ecount(size) = __deref_in __pre __deref __elem_readableTo(size);
static const int __deref_in_bcount(size) = __deref_in __pre __deref __byte_readableTo(size);
static const int __deref_in_xcount(size) = __deref_in __pre __deref __inexpressible_readableTo(size);
static const int __deref_out_xcount(size) = __deref_xcount(size) __post __deref __valid __refparam;
static const int __deref_out_xcount_part(size,length) = __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length);
static const int __deref_out_xcount_full(size) = __deref_out_xcount_part(size,size);
static const int __deref_out_xcount(size) = __deref_xcount(size) __post __deref __valid __refparam;
static const int __deref_inout_xcount(size) = __deref_inout __pre __deref __inexpressible_writableTo(size) __post __deref __inexpressible_writableTo(size);
static const int __deref_inout_xcount_part(size,length) = __deref_inout_xcount(size) __pre __deref __inexpressible_readableTo(length) __post __deref __inexpressible_readableTo(length);
static const int __deref_inout_xcount_full(size) = __deref_inout_xcount_part(size,size);
static const int __deref_xcount_opt(size) = __deref_xcount(size) __post __deref __exceptthat __maybenull;
static const int __deref_in_opt = __deref_in __pre __deref __exceptthat __maybenull;
static const int __deref_in_opt_out = __deref_inout __pre __deref __exceptthat __maybenull __post __deref __notnull;
static const int __deref_in_ecount_opt(size) = __deref_in_ecount(size) __pre __deref __exceptthat __maybenull;
static const int __deref_in_bcount_opt(size) = __deref_in_bcount(size) __pre __deref __exceptthat __maybenull;
static const int __deref_in_xcount_opt(size) = __deref_in_xcount(size) __pre __deref __exceptthat __maybenull;
static const int __deref_out_xcount_opt(size) = __deref_out_xcount(size) __post __deref __exceptthat __maybenull;
static const int __deref_out_xcount_part_opt(size,length) = __deref_out_xcount_part(size,length) __post __deref __exceptthat __maybenull;
static const int __deref_out_xcount_full_opt(size) = __deref_out_xcount_full(size) __post __deref __exceptthat __maybenull;
static const int __deref_inout_xcount_opt(size) = __deref_inout_xcount(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_xcount_part_opt(size,length) = __deref_inout_xcount_part(size,length) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_inout_xcount_full_opt(size) = __deref_inout_xcount_full(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull;
static const int __deref_opt_xcount(size) = __deref_xcount(size) __exceptthat __maybenull;
static const int __deref_opt_in = __deref_in __exceptthat __maybenull;
static const int __deref_opt_in_ecount(size) = __deref_in_ecount(size) __exceptthat __maybenull;
static const int __deref_opt_in_bcount(size) = __deref_in_bcount(size) __exceptthat __maybenull;
static const int __deref_opt_in_xcount(size) = __deref_in_xcount(size) __exceptthat __maybenull;
static const int __deref_opt_out_xcount(size) = __deref_out_xcount(size) __exceptthat __maybenull;
static const int __deref_opt_out_xcount_part(size,length) = __deref_out_xcount_part(size,length) __exceptthat __maybenull;
static const int __deref_opt_out_xcount_full(size) = __deref_out_xcount_full(size) __exceptthat __maybenull;
static const int __deref_opt_inout_xcount(size) = __deref_inout_xcount(size) __exceptthat __maybenull;
static const int __deref_opt_inout_xcount_part(size,length) = __deref_inout_xcount_part(size,length) __exceptthat __maybenull;
static const int __deref_opt_inout_xcount_full(size) = __deref_inout_xcount_full(size) __exceptthat __maybenull;
static const int __deref_opt_xcount_opt(size) = __deref_xcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_in_opt = __deref_in_opt __exceptthat __maybenull;
static const int __deref_opt_in_ecount_opt(size) = __deref_in_ecount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_in_bcount_opt(size) = __deref_in_bcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_in_xcount_opt(size) = __deref_in_xcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_out_xcount_opt(size) = __deref_out_xcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_out_xcount_part_opt(size,length) = __deref_out_xcount_part_opt(size,length) __exceptthat __maybenull;
static const int __deref_opt_out_xcount_full_opt(size) = __deref_out_xcount_full_opt(size) __exceptthat __maybenull;
static const int __deref_opt_inout_xcount_opt(size) = __deref_inout_xcount_opt(size) __exceptthat __maybenull;
static const int __deref_opt_inout_xcount_part_opt(size,length) = __deref_inout_xcount_part_opt(size,length) __exceptthat __maybenull;
static const int __deref_opt_inout_xcount_full_opt(size) = __deref_inout_xcount_full_opt(size) __exceptthat __maybenull;
/* Must protect redfinitions of macros to workaround rc.exe issues. */
static const int __nullnullterminated = __inexpressible_readableTo("string terminated by two nulls") __nullterminated;
static const int __checkReturn = __post __inner_checkReturn;
/************************************************************************
 New extensions to sal.h follow here.
*************************************************************************/
# 164 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
/* Internal defintions */
static const int __field_ecount(size) = __notnull __elem_writableTo(size);
static const int __field_bcount(size) = __notnull __byte_writableTo(size);
static const int __field_xcount(size) = __notnull __inexpressible_writableTo(size);
static const int __field_ecount_opt(size) = __maybenull __elem_writableTo(size);
static const int __field_bcount_opt(size) = __maybenull __byte_writableTo(size);
static const int __field_xcount_opt(size) = __maybenull __inexpressible_writableTo(size);
static const int __field_ecount_part(size,init) = __notnull __elem_writableTo(size) __elem_readableTo(init);
static const int __field_bcount_part(size,init) = __notnull __byte_writableTo(size) __byte_readableTo(init);
static const int __field_xcount_part(size,init) = __notnull __inexpressible_writableTo(size) __inexpressible_readableTo(init);
static const int __field_ecount_part_opt(size,init) = __maybenull __elem_writableTo(size) __elem_readableTo(init);
static const int __field_bcount_part_opt(size,init) = __maybenull __byte_writableTo(size) __byte_readableTo(init);
static const int __field_xcount_part_opt(size,init) = __maybenull __inexpressible_writableTo(size) __inexpressible_readableTo(init);
static const int __field_ecount_full(size) = __field_ecount_part(size,size);
static const int __field_bcount_full(size) = __field_bcount_part(size,size);
static const int __field_xcount_full(size) = __field_xcount_part(size,size);
static const int __field_ecount_full_opt(size) = __field_ecount_part_opt(size,size);
static const int __field_bcount_full_opt(size) = __field_bcount_part_opt(size,size);
static const int __field_xcount_full_opt(size) = __field_xcount_part_opt(size,size);
static const int __field_nullterminated = __nullterminated;
static const int __struct_bcount(size) = __byte_writableTo(size);
static const int __struct_xcount(size) = __inexpressible_writableTo(size);
static const int __out_awcount(expr,size) = __pre __notnull __byte_writableTo((expr) ? (size) : (size) * 2) __post __valid __refparam;
static const int __in_awcount(expr,size) = __pre __valid __pre __deref __readonly __byte_readableTo((expr) ? (size) : (size) * 2);
static const int __post_invalid = __post __notvalid;
/* integer related macros */
static const int __allocator = __inner_allocator;
static const int __deallocate(kind) = __pre __notnull __post_invalid;
static const int __deallocate_opt(kind) = __pre __maybenull __post_invalid;
static const int __bound = __inner_bound;
static const int __range(lb,ub) = __inner_range(lb,ub);
static const int __in_bound = __pre __inner_bound;
static const int __out_bound = __post __inner_bound;
static const int __deref_out_bound = __post __deref __inner_bound;
static const int __in_range(lb,ub) = __pre __inner_range(lb,ub);
static const int __out_range(lb,ub) = __post __inner_range(lb,ub);
static const int __deref_in_range(lb,ub) = __pre __deref __inner_range(lb,ub);
static const int __deref_out_range(lb,ub) = __post __deref __inner_range(lb,ub);
static const int __deref_inout_range(lb,ub) = __deref_in_range(lb,ub) __deref_out_range(lb,ub);
static const int __field_range(lb,ub) = __range(lb,ub);
static const int __field_data_source(src_sym) = __inner_data_source(#src_sym);
static const int __range_max(a,b) = __range(>=,a) __range(>=,b);
static const int __range_min(a,b) = __range(<=,a) __range(<=,b);
/* Penetration review macros */
static const int __in_data_source(src_sym) = __pre __inner_data_source(#src_sym);
static const int __out_data_source(src_sym) = __post __inner_data_source(#src_sym);
static const int __out_validated(typ_sym) = __inner_out_validated(#typ_sym);
static const int __this_out_data_source(src_sym) = __inner_this_data_source(#src_sym);
static const int __this_out_validated(typ_sym) = __inner_this_out_validated(#typ_sym);
static const int __transfer(formal) = __post __inner_transfer(formal);
static const int __rpc_entry = __inner_control_entrypoint(RPC);
static const int __kernel_entry = __inner_control_entrypoint(UserToKernel);
static const int __gdi_entry = __inner_control_entrypoint(GDI);
static const int __encoded_pointer = __inner_encoded;
static const int __encoded_array = __inner_encoded;
static const int __field_encoded_pointer = __inner_encoded;
static const int __field_encoded_array = __inner_encoded;
# 277 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
static const int __deref_volatile = __deref __volatile;
static const int __deref_nonvolatile = __deref __nonvolatile;
/* declare stub functions for macros */
static const int __analysis_assume_nullterminated(x) = __inner_analysis_assume_nullterminated(x);
static const int __assume_validated(p) = __inner_assume_validated(p);
static const int __assume_bound(i) = __inner_assume_bound(i);
# 315 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
/**************************************************************************
* This include should always be the last thing in this file.
* Must avoid redfinitions of macros to workaround rc.exe issues.
***************************************************************************/
# 320 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_strict.h" 1
/************************************************************************* 
*  This file documents all the macros approved for use in windows source
*  code. It includes some experimental macros which should only be used by
*  experts.
*
*  DO NOT include this file directly.  This file is include after
*  specstrings.h. So we can undefine every possible old definition including
*  private internal macros people should not be using, as well as macros from
*  sal.h.  Macros are redefined here in a way to cause syntax errors when used
*  incorrectly during a normal build when specstrings.h is included and
*  __SPECSTRINGS_STRICT_LEVEL is defined.
*
*  There are several levels of strictness, each level includes the behavior of
*  all previous levels.
*
*  0 - Disable strict checking 
*  1 - Break on unapproved macros and misuse of statement 
*      macros such as __fallthrough (default)
*  2 - Deprecated some old macros that should not be used
*  3 - Use VS 2005 Source Annotation to make sure every macro 
*      is used in the right context. For example placing __in on a return 
*      parameter will result in an error.
************************************************************************/
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_strict.h"
static const int __SPECSTRINGS_STRICT_LEVEL = 1;
/************************************************************************
*  Introduction
*
*  specstrings.h provides a set of annotations to describe how a function uses
*  its parameters - the assumptions it makes about them, and the guarantees it
*  makes upon finishing.
* 
*  Annotations must be placed before a function parameter's type or its return
*  type. There are two basic classes of common annotations buffer annotations
*  and advanced annotations.  Buffer annotations describe how functions use
*  their pointer parameters, and advanced annotations either describe
*  complex/unusual buffer behavior, or provide additional information about a
*  parameter that is not otherwise expressible.
* 
*  Buffer Annotations
* 
*  The most important annotations in SpecStrings.h provide a consistent way to
*  annotate buffer parameters or return values for a function. Each of these
*  annotations describes a single buffer (which could be a string, a
*  fixed-length or variable-length array, or just a pointer) that the function
*  interacts with: where it is, how large it is, how much is initialized, and
*  what the function does with it.
* 
*  The appropriate macro for a given buffer can be constructed using the table
*  below.  Just pick the appropriate values from each category, and combine
*  them together with a leading underscore. Some combinations of values do not
*  make sense as buffer annotations. Only meaningful annotations can be added
*  to your code; for a list of these, see the buffer annotation definitions
*  section.
* 
*  Only a single buffer annotation should be used for each parameter.
* 
*  |------------|------------|---------|--------|----------|---------------|
*  |   Level    |   Usage    |  Size   | Output | Optional |  Parameters   |
*  |------------|------------|---------|--------|----------|---------------|
*  | <>         | <>         | <>      | <>     | <>       | <>            |
*  | _deref     | _in        | _ecount | _full  | _opt     | (size)        |
*  | _deref_opt | _out       | _bcount | _part  |          | (size,length) |
*  |            | _inout     |         |        |          |               |
*  |            |            |         |        |          |               |
*  |------------|------------|---------|--------|----------|---------------|
*
*  Note: "<>" represents the empty string.
* 
*  Level: Describes the buffer pointer's level of indirection from the
*  parameter or return value 'p'.
* 
*  <>         : p is the buffer pointer.
*  _deref     : *p is the buffer pointer. p must not be NULL.
*  _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the 
*               rest of the annotation is ignored.
* 
*  Usage: Describes how the function uses the buffer.
* 
*  <> : The buffer is not accessed. If used on the return value or with
*  _deref, the function will provide the buffer, and it will be uninitialized
*  at exit.  Otherwise, the caller must provide the buffer. This should only
*  be used for alloc and free functions.
*
*  _in : The function will only read from the buffer. The caller must provide
*  the buffer and initialize it.
*
*  _out : The function will only write to the buffer. If used on the return
*  value or with _deref, the function will provide the buffer and initialize
*  it.  Otherwise, the caller must provide the buffer, and the function will
*  initialize it.
*
*  _inout : The function may freely read from and write to the buffer. The
*  caller must provide the buffer and initialize it. If used with _deref, the
*  buffer may be reallocated by the function.
*
*  Size: Describes the total size of the buffer. This may be less than the
*  space actually allocated for the buffer, in which case it describes the
*  accessible amount.
* 
*  <> : No buffer size is given. If the type specifies the buffer size (such
*  as with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is
*  one element long. Must be used with _in, _out, or _inout.
*
*  _ecount : The buffer size is an explicit element count.
*
*  _bcount : The buffer size is an explicit byte count.
* 
*  Output: Describes how much of the buffer will be initialized by the
*  function. For _inout buffers, this also describes how much is initialized
*  at entry. Omit this category for _in buffers; they must be fully
*  initialized by the caller.
* 
*  <> : The type specifies how much is initialized. For instance, a function
*  initializing an LPWSTR must NULL-terminate the string.
*
*  _full : The function initializes the entire buffer.
*
*  _part : The function initializes part of the buffer, and explicitly
*  indicates how much.
* 
*  Optional: Describes if the buffer itself is optional.
* 
*  <>   : The pointer to the buffer must not be NULL.
*
*  _opt : The pointer to the buffer might be NULL. It will be checked before
*  being dereferenced.
* 
*  Parameters: Gives explicit counts for the size and length of the buffer.
* 
*  <> : There is no explicit count. Use when neither _ecount nor _bcount is
*  used.
*
*  (size) : Only the buffer's total size is given. Use with _ecount or _bcount
*  but not _part.
*
*  (size,length) : The buffer's total size and initialized length are
*  given. Use with _ecount_part and _bcount_part.
* 
*  ----------------------------------------------------------------------------
*  Buffer Annotation Examples
* 
*  LWSTDAPI_(BOOL) StrToIntExA(
*      LPCSTR pszString,  //  No annotation required, const implies __in.
*      DWORD dwFlags,
*      __out int *piRet   // A pointer whose dereference will be filled in.
*  );
* 
*  void MyPaintingFunction(
*      __in HWND hwndControl,     //  An initialized read-only parameter.
*      __in_opt HDC hdcOptional,  //  An initialized read-only parameter that 
*                                 //  might be NULL.
*      __inout IPropertyStore *ppsStore // An initialized parameter that 
*                                       // may be freely used and modified.
*  );
* 
*  LWSTDAPI_(BOOL) PathCompactPathExA(
*      __out_ecount(cchMax) LPSTR pszOut, //  A string buffer with cch elements
*                                         //  that will be '\0' terminated 
*                                         //  on exit.
*      LPCSTR pszSrc,                     //  No annotation required, 
*                                         //  const implies __in.
*      UINT cchMax,                              
*      DWORD dwFlags
*  );
* 
*  HRESULT SHLocalAllocBytes(
*      size_t cb,
*      __deref_bcount(cb) T **ppv //  A pointer whose dereference will be set
*                                 //  to an uninitialized buffer with cb bytes.
*  );
* 
*  __inout_bcount_full(cb) : A buffer with cb elements that is fully
*  initialized at entry and exit, and may be written to by this function.
* 
*  __out_ecount_part(count, *countOut) : A buffer with count elements that
*  will be partially initialized by this function. The function indicates how
*  much it initialized by setting *countOut.
* 
************************************************************************/
# 321 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h" 1
/******************************************************************************                                                                             *
 *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.10                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/
# 12 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
/****************************************************************************** NOTE																		  *
 *
* NOTE																		  *
* NOTE																		  *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.																  *
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
\*****************************************************************************/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
/****************************************************************************** The annotations described by KernelSpecs.h and DriverSpecs.h, taken together,
r,
* are used to annotate drivers.  Many of the annotations are applicable to
* user space code (including subsystems) as well as to drivers.
*
* DriverSpecs.h contains those annotations which are appropriate to userspace
* code, or which might appear in headers that are shared between user space
* and kernel space.  In the case of annotations which might appear in such a
* shared header, but which are meaningless in user space, the annotations are
* #defined to nothing in DriverSpecs.h.
*
* KernelSpecs.h contains those annotations which either will only appear in
* kernel code or headers; or which might appear in shared headers.  In the
* latter case, it is assumed that DriverSpecs.h has been #included, and
* the anntoations are re-defined (using #undef) to give them a meaningful
* value.  In general, documentation for the shared-header annotations appears
* in DriverSpecs.h.
*
* Many annotations are context dependent.  They only apply to certain versions
* of Windows, or only to certain classes of driver.  These rules can be written
* using something like __drv_when(NTDDI_VERSION >= NTDDI_WINXP, ...)
* which causes the rule only to apply to Windows XP and later.  Many of these
* symbols are already defined in various Windows headers.
*
* To facilitate using this sort of conditional rule, we collect here the
* various known symbols that are (or reasonably might) be used in such
* a conditional annotation.  Some are speculative in that the symbol has
* not yet been defined because there are no known uses of it yet.
*
* Where the symbol already exists its relevant header is
* noted below (excluding the "really well known" ones).
*
* Each symbol is listed with the currently known possible values.
*
* Some symbols are marked as #define symbols -- they are used with #ifdef
* operators only.  To use them in __drv_when, use something like
* __drv_when(__drv_defined(NT), ...).
*
* WDK Version (copied for convenience from sdkddkver.h)
*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3 
*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2 
*					 NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA
*     The WDK version is taken as the WDM version as well.
*
* OS Version: (copied for convenience from sdkddkver.h)
*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP 
*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN
*     WINVER: 0x030B 0x0400 0x0500 0x0600
*     NT (#define symbol)
* (sdkddkver.h also defines symbols for IE versions should they be needed.)
*
* Compiler Version:
*	  _MSC_VER: too many to list.
*	  _MSC_FULL_VER: too many to list.
*
* KMDF Version:  (Currently defined/used only in makefiles.)
*     KMDF_VERSION_MAJOR: 1     
*
* UMDF Version:  (Currently defined/used only in makefiles.)
*     UMDF_VERSION_MAJOR: 1     
*
* Architecture kinds:
*     __WIN64 (#define symbols)
*     _X86_
*     _AMD64_
*     _IA64_ 
*
* Machine Architectures:
*     _M_IX86
*     _M_AMD64
*     _M_IA64
*
* Driver Kind (NYI: "not yet implemented")
*   Typically these will be defined in the most-common header for a 
*   particular driver (or in individual source files if appropriate).
*   These are not intended to necessarily be orthogonal: more than one might 
*   apply to a particular driver.
*     _DRIVER_TYPE_BUS: 1                // NYI
*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI
*     _DRIVER_TYPE_MINIPORT: 1           // NYI
*     _DRIVER_TYPE_STORAGE: 1            // NYI
*     _DRIVER_TYPE_DISPLAY: 1            // NYI
*     _DRIVER_TYPE_FILESYSTEM: 1
*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1
*
* NDIS driver version: (see ndis.h for much more detail.)
*   These can be used to both identify an NDIS driver and to check the version.
*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)
*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0
*     And many others in ndis.h (including MINIPORT)
*
\*****************************************************************************/
# 118 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
// In case driverspecs.h is included directly (and w/o specstrings.h)
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdv_driverspecs.h" 1
// general purpose save 
//-----------------------
// general purpose retrieve 
//-----------------------
// NDIS AdapterContext save 
//-----------------------
# 126 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h" 2
# 141 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
# 251 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
 // core macros: these provide syntatic wrappers to make other uses
 // simpler.
 // (Note: right now we can't safely use the ellipsis (...) macro
 // syntax.  If we could then '##__drv_nop(annotes)' below could be 
 // simply 'annotes', and we could code __$drv_group as __$drv_group(...) 
 // in the "expands to nothing" case.)
 //
 // For example:
 //	 __drv_in(__drv_nonconstant __setsIRQL)
static const int __drv_deref(annotes) = __deref __$drv_group( ##__drv_nop(annotes));
static const int __drv_in(annotes) = __pre __$drv_group( ##__drv_nop(annotes));
static const int __drv_in_deref(annotes) = __pre __deref __$drv_group( ##__drv_nop(annotes));
static const int __drv_out(annotes) = __post __$drv_group( ##__drv_nop(annotes));
static const int __drv_out_deref(annotes) = __post __deref __$drv_group( ##__drv_nop(annotes));
static const int __drv_when(cond,annotes) = __drv_declspec("SAL_when(" SPECSTRINGIZE(cond) ")") __$drv_group( ##__drv_nop(annotes));
static const int __drv_at(expr,annotes) = __drv_declspec("SAL_at(" SPECSTRINGIZE(expr) ")") __$drv_group( ##__drv_nop(annotes));
static const int __drv_fun(annotes) = __drv_at(return, ##__drv_nop(annotes));
static const int __drv_ret(annotes) = __drv_at(return, ##__drv_nop(annotes));
static const int __drv_arg(expr,annotes) = __drv_at(expr, ##__drv_nop(annotes));
static const int __drv_unit(p) = typedef int __$drv_unit_ ##p $GENSYM(__prefast_flag_kernel_driver_mode);;
 // Internal macros for convenience
static const int __$drv_unit_internal_kernel_driver = __drv_declspec("SAL_internal_kernel_driver");
 //
 // __drv_unit
 //
 // Flags for compilation units that indicated specifically what kind of
 // code it is.
 // These should be coded as early as possible in any compilation unit
 // (.c/.cpp file) that doesn't get the correct default.	 Whether before
 // or after __internal_kernel_driver is immaterial as long as it will
 // successfully parse.
 //
 // Indicate that the code is kernel, but not driver, code.
static const int __$drv_unit_kernel_code = __drv_declspec("SAL_kernel") __drv_declspec("SAL_nodriver");
 // Indicate that the code is kernel, driver, code.
static const int __$drv_unit_kernel_driver = __drv_declspec("SAL_kernel") __drv_declspec("SAL_driver");
 // Indicate that the code is a user mode driver.
static const int __$drv_unit_user_driver = __drv_declspec("SAL_nokernel") __drv_declspec("SAL_driver");
 // Indicate that the code is ordinary user mode code.
static const int __$drv_unit_user_code = __drv_declspec("SAL_nokernel") __drv_declspec("SAL_nodriver");
 // These are needed for backwards compatability.
# 335 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
 // ---------------------------------------------------------------------
 // Syntatic utilities:
 // 
 // Needed to make the annotations convenient to use.
 //
 // So we can use a macro name that might be used in #ifdef context,
 // where it's defined with no value.  
 // This should only be used inside a __drv_when condition.
 //
static const int __drv_defined(x) = macroDefined$( #x );
 // ---------------------------------------------------------------------
 // Callback properties:
 //
 // __drv_functionClass(x)
 //
 // Flag that the  the annotated function
 // is a member of that function class.	Some class names are recognized
 // by PREfast itself for special treatment.
 // This can be tested by the condition function inFunctionClass$()
 //
static const int __drv_functionClass(x) = __drv_out(__drv_declspec("SAL_functionClass(\""#x"\")"));
 // ---------------------------------------------------------------------
 // Resources:
 // 
 // __drv_acquiresResource(kind)
 // __drv_releasesResource(kind)
 // __drv_acquiresResourceGlobal(kind,param)
 // __drv_releasesResourceGlobal(kind,param)
 // __drv_mustHold(kind)
 // __drv_neverHold(kind)
 // __drv_mustHoldGlobal(kind,param)
 // __drv_neverHoldGlobal(kind,param)
 //
 // Flag that the annotated parameter acquires a resource of type kind.
 //
static const int __drv_acquiresResource(kind) = __post __drv_declspec("SAL_acquire(\"" #kind "\")");
 //
 // Flag that the annotated parameter releases a resource of type kind.
 //
static const int __drv_releasesResource(kind) = __post __drv_declspec("SAL_release(\"" #kind "\")");
 //
 // Flag that the annotated object acquires a global (otherwise anonymous)
 // resource of type kind named by param.
 //
static const int __drv_innerAcquiresGlobal(kind,param) = __post __drv_declspec("SAL_acquireGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")");
static const int __drv_acquiresResourceGlobal(kind,param) = __drv_innerAcquiresGlobal(kind, param);
 //
 // Flag that the annotated object acquires a global (otherwise anonymous)
 // resource of type kind named by param.
 //
static const int __drv_innerReleasesGlobal(kind,param) = __post __drv_declspec("SAL_releaseGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")");
static const int __drv_releasesResourceGlobal(kind,param) = __drv_innerReleasesGlobal(kind, param);
 //
 // Flag that the annotated parameter must hold a resource of type kind
 //
static const int __drv_mustHold(kind) = __pre __drv_declspec("SAL_mustHold(\""#kind"\")");
 //
 // Flag that the annotated object must hold a global resource
 // of type kind named by param.
 //
static const int __drv_innerMustHoldGlobal(kind,param) = __pre __drv_declspec("SAL_mustHoldGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")");
static const int __drv_mustHoldGlobal(kind,param) = __drv_innerMustHoldGlobal(kind, param);
 //
 // Flag that the annotated parameter must never hold a resource of type kind
 //
static const int __drv_neverHold(kind) = __pre __drv_declspec("SAL_neverHold(\"" #kind "\")");
 //
 // Flag that the annotated object must never hold a global resource
 // of type kind named by param.
 //
static const int __drv_innerNeverHoldGlobal(kind,param) = __pre __drv_declspec("SAL_neverHoldGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")");
static const int __drv_neverHoldGlobal(kind,param) = __drv_innerNeverHoldGlobal(kind, param);
 // Predicates to determine if a resource is held
 // ---------------------------------------------------------------------
 // Maintenance of IRQL values
 //
 // __drv_setsIRQL(irql)
 // __drv_raisesIRQL(irql)
 // __drv_requiresIRQL(irql)
 // __drv_maxIRQL(irql)
 // __drv_minIRQL(irql)
 // __drv_savesIRQL
 // __drv_restoresIRQL
 // __drv_savesIRQLGlobal(kind,param)
 // __drv_restoresIRQLGlobal(kind,param)
 // __drv_minFunctionIRQL(irql)
 // __drv_maxFunctionIRQL(irql)
 // __drv_useCancelIRQL
 // __drv_sameIRQL
 // 
 // The funciton exits at IRQL irql
 //
 // 
 // The funciton exits at IRQL irql, but this may only raise the irql.
 //
 // 
 // The called function must be entered at IRQL level
 //
 // 
 // The maximum IRQL at which the function may be called.
 //
 // 
 // The minimum IRQL at which the function may be called.
 //
 // 
 // The current IRQL is saved in the annotated parameter
 //
 // 
 // The current IRQL is saved in the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
 // 
 // The current IRQL is restored from the annotated parameter
 //
 // 
 // The current IRQL is restored from the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
 // The minimum IRQL to which the function can lower itself.	 The IRQL
 // at entry is assumed to be that value unless overridden.
 // The maximum IRQL to which the function can raise itself.
 // The function must exit with the same IRQL it was entered with.
 // (It may change it but it must restore it.)
 // The annotated parameter contains the cancelIRQL, which will be restored
 // by the called function.
 // ---------------------------------------------------------------------
 // Specific function behaviors
    // The annotated function clears the requirement that DoInitializeing
 // is cleared (or not).
static const int __drv_clearDoInit(yesNo) = __post __drv_declspec("SAL_clearDoInit(" SPECSTRINGIZE(yesNo) ")");
 // This is (or is like) IoGetDmaAdapter: look for misuse of DMA pointers
static const int __drv_IoGetDmaAdapter = __post __drv_declspec("SAL_IoGetDmaAdapter");
 // ---------------------------------------------------------------------
 // Function and out parameter return values.
 //
 // __drv_valueIs(<list>)
 //
 // The function being annotated will return each of the specified values
 // during simulation.  The items in the list are <relational op><constant>,
 // e.g. ==0 or <0.
 // This is a ; separated list of values.  The internal parser will accept
 // a comma-separated list.  In the future __VA_ARGS__ could be used.
 // See the documentation for use of this.
 //
static const int __drv_valueIs(arglist) = __post __drv_declspec("SAL_return("SPECSTRINGIZE(arglist)")");
 // ---------------------------------------------------------------------
 // Additional parameter checking.
 //
 // __drv_constant
 // __drv_nonConstant
 // __drv_strictTypeMatch(mode)
 // __drv_strictType(type,mode)
 //
 // The actual parameter must evaluate to a constant (not a const).
 //
static const int __drv_constant = __pre __drv_declspec("SAL_constant(__yes)");
 //
 // The actual parameter may never evaluate to a numeric constant 
 // (exclusive of a const symbol).
 //
static const int __drv_nonConstant = __pre __drv_declspec("SAL_constant(__no)");
 //
 // The actual parameter must match the type of the annotated formal
 // within the specifications set by mode.
 //
static const int __drv_strictTypeMatch(mode) = __pre __drv_declspec("SAL_strictTypeMatch("SPECSTRINGIZE(mode)")");
 //
 // The actual parameter must match the type of typename (below) 
 // within the specifications set by mode.
 //
 // currently 1/2 args
static const int __drv_strictType(typename,mode) = __pre __drv_declspec("SAL_strictType("SPECSTRINGIZE(typename)"," SPECSTRINGIZE(mode)")");
 //
 //    The following modes are defined:
static const int __drv_typeConst = 0;
static const int __drv_typeCond = 1;
static const int __drv_typeBitset = 2;
static const int __drv_typeExpr = 3;
 // 
 // The actual parameter must be data (not a pointer).  Used to
 // prevent passing pointers to pointers when pointers to structures
 // are needed (because &pXXX is a common error when pXXX is 
 // intended).
static const int __drv_notPointer = __pre __drv_declspec("SAL_mayBePointer(__no)");
 //
 // Convenience for the most common form of the above.
static const int __drv_isObjectPointer = __drv_deref(__drv_notPointer);
 // ---------------------------------------------------------------------
 // Memory management
 //
 // __drv_aliasesMem
 // __drv_allocatesMem
 // __drv_freesMem
 //
 // The annotated parameter is "kept" by the function, creating an
 // alias, and relieving any obligation to free the object.
 //
static const int __drv_aliasesMem = __post __drv_declspec("SAL_IsAliased");
 //
 // Allocate/release memory-like objects.
 // Kind is unused, but should be "mem" for malloc/free
 // and "object" for new/delete.
static const int __drv_allocatesMem(kind) = __post __drv_declspec("SAL_NeedsRelease(__yes)");
static const int __drv_freesMem(kind) = __post __drv_declspec("SAL_NeedsRelease(__no)");
 // ---------------------------------------------------------------------
 // Additional diagnostics
 //
 // __drv_preferredFunction
 // __drv_reportError
 //
 //
 // Function 'func' should be used for reason 'why'.	 Often used
 // conditionally.
 //
static const int __drv_preferredFunction(func,why) = __pre __drv_declspec( "SAL_preferredFunction(" SPECSTRINGIZE(func) "," SPECSTRINGIZE(why) ")");
 //
 // The error given by 'why' was detected.  Used conditionally.
 //
static const int __drv_reportError(why) = __pre __drv_declspec("SAL_error(" SPECSTRINGIZE(why) ")");
 // ---------------------------------------------------------------------
 // Floating point save/restore:
 //
 // __drv_floatSaved
 // __drv_floatRestored
 // __drv_floatUsed
 //
 // The floating point hardware was saved (available to kernel)
static const int __drv_floatSaved = __post __drv_declspec("SAL_floatSaved");
 //
 // The floating point hardware was restored (no longer available)
static const int __drv_floatRestored = __post __drv_declspec("SAL_floatRestored");
 //
 // The function uses floating point.  Functions with floating point
 // in their type signature get this automatically.
static const int __drv_floatUsed = __post __drv_declspec("SAL_floatUsed");
 // ---------------------------------------------------------------------
 // Usage:
 // 
 // __drv_interlocked
 // __drv_inTry
 // __drv_notInTry
 //
 // The parameter is used for interlocked instructions.
static const int __drv_interlocked = __pre __drv_declspec("SAL_interlocked");
 // The function must be called inside a try block
static const int __drv_inTry = __pre __drv_declspec("SAL_inTry(__yes)");
 // The function must not be called inside a try block
static const int __drv_notInTry = __pre __drv_declspec("SAL_inTry(__no)");
 // ---------------------------------------------------------------------
 // FormatString:
 //
 // kind can be "printf", "scanf", "strftime" or "FormatMessage".
static const int __drv_formatString(kind) = __drv_declspec("SAL_IsFormatString(\"" #kind "\")");
 // ---------------------------------------------------------------------
 // SDV support: see the SDV documentation for details
 // Identify dispatch callback types
static const int __drv_dispatchType(kindlist) = __pre __drv_declspec("SAL_dispatchType(" SPECSTRINGIZE(kindlist) ")" );
 // Identify dispatch callback types - special case
static const int __drv_dispatchType_other = __drv_dispatchType(-1);
 // Identify completion callback types
static const int __drv_completionType(kindlist) = __drv_declspec("SAL_completionType(" #kindlist ")" );
 // Identify callback types (FDO or PDO)
static const int __drv_callbackType(kind) = __drv_declspec("SAL_callbackType(" #kind ")" );
 // ---------------------------------------------------------------------
 // Composite:
# 811 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
 // Passing the cancel Irql to a utility function
 // Check if this is kernel or driver code
# 324 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2
# 78 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h" 1
/******************************************************************************                                                                             *
 *
* KernelSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See DriverSpecs.h for detailed comments                     *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.00                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/
# 13 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
/****************************************************************************** NOTE																		  *
 *
* NOTE																		  *
* NOTE																		  *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.																  *
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
\*****************************************************************************/
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
/****************************************************************************** As noted in DriverSpecs.h, this header contains "real" definitions for
or
* annotations that either never appear in user space, or which are meaningles
* in user space and are #defined to nothing by DriverSpecs.h.
*
* Further commentary appears in DriverSpecs.h.
\*****************************************************************************/
# 33 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/DriverSpecs.h" 1
/******************************************************************************                                                                             *
 *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.10                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/
# 12 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/DriverSpecs.h"
/****************************************************************************** NOTE																		  *
 *
* NOTE																		  *
* NOTE																		  *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.																  *
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
\*****************************************************************************/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/DriverSpecs.h"
/****************************************************************************** The annotations described by KernelSpecs.h and DriverSpecs.h, taken together,
r,
* are used to annotate drivers.  Many of the annotations are applicable to
* user space code (including subsystems) as well as to drivers.
*
* DriverSpecs.h contains those annotations which are appropriate to userspace
* code, or which might appear in headers that are shared between user space
* and kernel space.  In the case of annotations which might appear in such a
* shared header, but which are meaningless in user space, the annotations are
* #defined to nothing in DriverSpecs.h.
*
* KernelSpecs.h contains those annotations which either will only appear in
* kernel code or headers; or which might appear in shared headers.  In the
* latter case, it is assumed that DriverSpecs.h has been #included, and
* the anntoations are re-defined (using #undef) to give them a meaningful
* value.  In general, documentation for the shared-header annotations appears
* in DriverSpecs.h.
*
* Many annotations are context dependent.  They only apply to certain versions
* of Windows, or only to certain classes of driver.  These rules can be written
* using something like __drv_when(NTDDI_VERSION >= NTDDI_WINXP, ...)
* which causes the rule only to apply to Windows XP and later.  Many of these
* symbols are already defined in various Windows headers.
*
* To facilitate using this sort of conditional rule, we collect here the
* various known symbols that are (or reasonably might) be used in such
* a conditional annotation.  Some are speculative in that the symbol has
* not yet been defined because there are no known uses of it yet.
*
* Where the symbol already exists its relevant header is
* noted below (excluding the "really well known" ones).
*
* Each symbol is listed with the currently known possible values.
*
* Some symbols are marked as #define symbols -- they are used with #ifdef
* operators only.  To use them in __drv_when, use something like
* __drv_when(__drv_defined(NT), ...).
*
* WDK Version (copied for convenience from sdkddkver.h)
*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3 
*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2 
*					 NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA
*     The WDK version is taken as the WDM version as well.
*
* OS Version: (copied for convenience from sdkddkver.h)
*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP 
*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN
*     WINVER: 0x030B 0x0400 0x0500 0x0600
*     NT (#define symbol)
* (sdkddkver.h also defines symbols for IE versions should they be needed.)
*
* Compiler Version:
*	  _MSC_VER: too many to list.
*	  _MSC_FULL_VER: too many to list.
*
* KMDF Version:  (Currently defined/used only in makefiles.)
*     KMDF_VERSION_MAJOR: 1     
*
* UMDF Version:  (Currently defined/used only in makefiles.)
*     UMDF_VERSION_MAJOR: 1     
*
* Architecture kinds:
*     __WIN64 (#define symbols)
*     _X86_
*     _AMD64_
*     _IA64_ 
*
* Machine Architectures:
*     _M_IX86
*     _M_AMD64
*     _M_IA64
*
* Driver Kind (NYI: "not yet implemented")
*   Typically these will be defined in the most-common header for a 
*   particular driver (or in individual source files if appropriate).
*   These are not intended to necessarily be orthogonal: more than one might 
*   apply to a particular driver.
*     _DRIVER_TYPE_BUS: 1                // NYI
*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI
*     _DRIVER_TYPE_MINIPORT: 1           // NYI
*     _DRIVER_TYPE_STORAGE: 1            // NYI
*     _DRIVER_TYPE_DISPLAY: 1            // NYI
*     _DRIVER_TYPE_FILESYSTEM: 1
*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1
*
* NDIS driver version: (see ndis.h for much more detail.)
*   These can be used to both identify an NDIS driver and to check the version.
*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)
*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0
*     And many others in ndis.h (including MINIPORT)
*
\*****************************************************************************/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h" 2
# 43 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
 // ---------------------------------------------------------------------
 // The symbolic IRQL values can sometimes end up undefined, so define
 // the usual ones here, for PREfast purposes only.
static const int DISPATCH_LEVEL = 2;
static const int APC_LEVEL = 1;
static const int PASSIVE_LEVEL = 0;
 // ---------------------------------------------------------------------
 // Maintenance of IRQL values
 //
 // __drv_setsIRQL(irql)
 // __drv_raisesIRQL(irql)
 // __drv_requiresIRQL(irql)
 // __drv_maxIRQL(irql)
 // __drv_minIRQL(irql)
 // __drv_savesIRQL
 // __drv_restoresIRQL
 // __drv_savesIRQLGlobal(kind,param)
 // __drv_restoresIRQLGlobal(kind,param)
 // __drv_minFunctionIRQL(irql)
 // __drv_maxFunctionIRQL(irql)
 // __drv_useCancelIRQL
 // __drv_sameIRQL
 // 
 // The funciton exits at IRQL irql
 //
 // ';' inside the parens to keep MIDL happy
static const int __drv_setsIRQL(irql) = __post __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")");
 // 
 // The funciton exits at IRQL irql, but this may only raise the irql.
 //
static const int __drv_raisesIRQL(irql) = __post __drv_declspec("SAL_raiseIRQL("SPECSTRINGIZE(irql)")");
 // 
 // The called function must be entered at IRQL level
 //
static const int __drv_requiresIRQL(irql) = __pre __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")");
 // 
 // The maximum IRQL at which the function may be called.
 //
static const int __drv_maxIRQL(irql) = __pre __drv_declspec("SAL_maxIRQL("SPECSTRINGIZE(irql)")");
 // 
 // The minimum IRQL at which the function may be called.
 //
static const int __drv_minIRQL(irql) = __pre __drv_declspec("SAL_minIRQL("SPECSTRINGIZE(irql)")");
 // 
 // The current IRQL is saved in the annotated parameter
 //
static const int __drv_savesIRQL = __post __drv_declspec("SAL_saveIRQL");
 // 
 // The current IRQL is saved in the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
static const int __drv_savesIRQLGlobal(kind,param) = __post __drv_declspec("SAL_saveIRQLGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")");
 // 
 // The current IRQL is restored from the annotated parameter
 //
static const int __drv_restoresIRQL = __post __drv_declspec("SAL_restoreIRQL");
 // 
 // The current IRQL is restored from the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
static const int __drv_restoresIRQLGlobal(kind,param) = __post __drv_declspec("SAL_restoreIRQLGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")");
 // The minimum IRQL to which the function can lower itself.	 The IRQL
 // at entry is assumed to be that value unless overridden.
static const int __drv_minFunctionIRQL(irql) = __pre __drv_declspec("SAL_minFunctionIrql(" SPECSTRINGIZE(irql) ")");
 // The maximum IRQL to which the function can raise itself.
static const int __drv_maxFunctionIRQL(irql) = __pre __drv_declspec("SAL_maxFunctionIrql(" SPECSTRINGIZE(irql) ")");
 // The function must exit with the same IRQL it was entered with.
 // (It may change it but it must restore it.)
static const int __drv_sameIRQL = __post __drv_declspec("SAL_sameIRQL");
 // The annotated parameter contains the cancelIRQL, which will be restored
 // by the called function.
static const int __drv_useCancelIRQL = __post __drv_declspec("SAL_UseCancelIrql");
# 79 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
# 87 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
# 99 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int MAX_NATURAL_ALIGNMENT = sizeof(ULONGLONG);
static const int MEMORY_ALLOCATION_ALIGNMENT = 16;
//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//
static const int TYPE_ALIGNMENT(t) = FIELD_OFFSET( struct { char x; t test; }, test );
# 138 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int PROBE_ALIGNMENT32(_s) = TYPE_ALIGNMENT( DWORD );
//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//
static const int C_ASSERT(e) = typedef char __C_ASSERT__[(e)?1:-1];
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    basetsd.h
Abstract:
    Type definitions for the basic sized types.
Author:
Revision History:
--*/
# 20 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
# 38 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
  typedef unsigned long POINTER_64_INT;
static const int FIRMWARE_PTR = POINTER_32;
//
// A compiler with support for __sptr and __uptr is in qualification.  To
// participate in qualification, remove the "0 &&" term below and also
// enable warning 4826 in warning.w
// 
static const int SPOINTER_32 = POINTER_SIGNED POINTER_32;
static const int UPOINTER_32 = POINTER_UNSIGNED POINTER_32;
# 76 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
typedef signed char INT8, *PINT8;
typedef signed short INT16, *PINT16;
typedef signed int INT32, *PINT32;
typedef signed __int64 INT64, *PINT64;
typedef unsigned char UINT8, *PUINT8;
typedef unsigned short UINT16, *PUINT16;
typedef unsigned int UINT32, *PUINT32;
typedef unsigned __int64 UINT64, *PUINT64;
//
// The following types are guaranteed to be signed and 32 bits wide.
//
typedef signed int LONG32, *PLONG32;
//
// The following types are guaranteed to be unsigned and 32 bits wide.
//
typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
# 106 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
# 123 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
// old midl and C++ compiler
    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;
    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;
static const int __int3264 = __int64;
# 146 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
//
// HALF_PTR is half the size of a pointer it intended for use with
// within structures which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//
static const int ADDRESS_TAG_BIT = 0x40000000000UI64;
typedef __int64 SHANDLE_PTR;
typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;
__inline
unsigned long
HandleToULong(
    const void *h
    )
{
    return((unsigned long) (ULONG_PTR) h );
}
__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) (LONG_PTR) h );
}
__inline
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}
__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}
__inline
unsigned long
PtrToUlong(
    const void *p
    )
{
    return((unsigned long) (ULONG_PTR) p );
}
__inline
unsigned int
PtrToUint(
    const void *p
    )
{
    return((unsigned int) (UINT_PTR) p );
}
__inline
unsigned short
PtrToUshort(
    const void *p
    )
{
    return((unsigned short) (unsigned long) (ULONG_PTR) p );
}
__inline
long
PtrToLong(
    const void *p
    )
{
    return((long) (LONG_PTR) p );
}
__inline
int
PtrToInt(
    const void *p
    )
{
    return((int) (INT_PTR) p );
}
__inline
short
PtrToShort(
    const void *p
    )
{
    return((short) (long) (LONG_PTR) p );
}
__inline
void *
IntToPtr(
    const int i
    )
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}
__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}
__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}
__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}
static const int PtrToPtr64(p) = ((void * POINTER_64) p);
static const int Ptr64ToPtr(p) = ((void *) p);
static const int HandleToHandle64(h) = (PtrToPtr64( h ));
static const int Handle64ToHandle(h) = (Ptr64ToPtr( h ));
__inline
void *
Ptr32ToPtr(
    const void * p
    )
{
    return((void *) (ULONG_PTR) (unsigned long) p);
}
__inline
void *
Handle32ToHandle(
    const void * h
    )
{
    return((void *) (LONG_PTR) (long) h);
}
__inline
void *
PtrToPtr32(
    const void *p
    )
{
    return((void * ) (unsigned long) (ULONG_PTR) p);
}
static const int HandleToHandle32(h) = (PtrToPtr32( h ));
# 399 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
static const int HandleToUlong(h) = HandleToULong(h);
static const int UlongToHandle(ul) = ULongToHandle(ul);
static const int UlongToPtr(ul) = ULongToPtr(ul);
static const int UintToPtr(ui) = UIntToPtr(ui);
static const int MAXUINT_PTR = (~((UINT_PTR)0));
static const int MAXINT_PTR = ((INT_PTR)(MAXUINT_PTR >> 1));
static const int MININT_PTR = (~MAXINT_PTR);
static const int MAXULONG_PTR = (~((ULONG_PTR)0));
static const int MAXLONG_PTR = ((LONG_PTR)(MAXULONG_PTR >> 1));
static const int MINLONG_PTR = (~MAXLONG_PTR);
static const int MAXUHALF_PTR = ((UHALF_PTR)~0);
static const int MAXHALF_PTR = ((HALF_PTR)(MAXUHALF_PTR >> 1));
static const int MINHALF_PTR = (~MAXHALF_PTR);
//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//
typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;
static const int MAXUINT8 = ((UINT8)~((UINT8)0));
static const int MAXINT8 = ((INT8)(MAXUINT8 >> 1));
static const int MININT8 = ((INT8)~MAXINT8);
static const int MAXUINT16 = ((UINT16)~((UINT16)0));
static const int MAXINT16 = ((INT16)(MAXUINT16 >> 1));
static const int MININT16 = ((INT16)~MAXINT16);
static const int MAXUINT32 = ((UINT32)~((UINT32)0));
static const int MAXINT32 = ((INT32)(MAXUINT32 >> 1));
static const int MININT32 = ((INT32)~MAXINT32);
static const int MAXUINT64 = ((UINT64)~((UINT64)0));
static const int MAXINT64 = ((INT64)(MAXUINT64 >> 1));
static const int MININT64 = ((INT64)~MAXINT64);
static const int MAXULONG32 = ((ULONG32)~((ULONG32)0));
static const int MAXLONG32 = ((LONG32)(MAXULONG32 >> 1));
static const int MINLONG32 = ((LONG32)~MAXLONG32);
static const int MAXULONG64 = ((ULONG64)~((ULONG64)0));
static const int MAXLONG64 = ((LONG64)(MAXULONG64 >> 1));
static const int MINLONG64 = ((LONG64)~MAXLONG64);
static const int MAXULONGLONG = ((ULONGLONG)~((ULONGLONG)0));
static const int MINLONGLONG = ((LONGLONG)~MAXLONGLONG);
static const int MAXSIZE_T = ((SIZE_T)~((SIZE_T)0));
static const int MAXSSIZE_T = ((SSIZE_T)(MAXSIZE_T >> 1));
static const int MINSSIZE_T = ((SSIZE_T)~MAXSSIZE_T);
static const int MAXUINT = ((UINT)~((UINT)0));
static const int MAXINT = ((INT)(MAXUINT >> 1));
static const int MININT = ((INT)~MAXINT);
static const int MAXDWORD32 = ((DWORD32)~((DWORD32)0));
static const int MAXDWORD64 = ((DWORD64)~((DWORD64)0));
//
// Add Windows flavor DWORD_PTR types
//
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
//
// The following types are guaranteed to be signed and 64 bits wide.
//
typedef __int64 LONG64, *PLONG64;
//
// The following types are guaranteed to be unsigned and 64 bits wide.
//
typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;
//
// Legacy thread affinity.
//
typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;
# 160 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
static const int SYSTEM_CACHE_ALIGNMENT_SIZE = 128;
static const int DECLSPEC_CACHEALIGN = DECLSPEC_ALIGN(SYSTEM_CACHE_ALIGNMENT_SIZE);
static const int NOP_FUNCTION = (void)0;
static const int FORCEINLINE = __inline;
# 265 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
# 281 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int PRAGMA_DEPRECATED_DDK = 0;
//
// Void
//
typedef void *PVOID;
typedef void * PVOID64;
static const int NTAPI_INLINE = NTAPI;
//
// Define API decoration for direct importing system DLL references.
//
static const int NTSYSAPI = DECLSPEC_IMPORT;
static const int NTSYSCALLAPI = DECLSPEC_IMPORT;
# 325 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Basics
//
static const int VOID = void;
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef int INT;
//
// UNICODE (Wide Character) types
//
typedef wchar_t WCHAR; // wc,   16-bit UNICODE character
typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef PWSTR *PZPWSTR;
typedef const PWSTR *PCZPWSTR;
typedef WCHAR *LPUWSTR, *PUWSTR;
typedef const WCHAR *LPCWSTR, *PCWSTR;
typedef PCWSTR *PZPCWSTR;
typedef const WCHAR *LPCUWSTR, *PCUWSTR;
typedef WCHAR *PZZWSTR;
typedef const WCHAR *PCZZWSTR;
typedef WCHAR *PUZZWSTR;
typedef const WCHAR *PCUZZWSTR;
typedef __possibly_notnullterminated WCHAR *PNZWCH;
typedef __possibly_notnullterminated const WCHAR *PCNZWCH;
typedef __possibly_notnullterminated WCHAR *PUNZWCH;
typedef __possibly_notnullterminated const WCHAR *PCUNZWCH;
typedef const WCHAR *LPCWCHAR, *PCWCHAR;
typedef const WCHAR *LPCUWCHAR, *PCUWCHAR;
//
//  UCS (Universal Character Set) types
//
typedef unsigned long UCSCHAR;
//
//  Even pre-Unicode agreement, UCS values are always in the
//  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
//  value.
static const int UCSCHAR_INVALID_CHARACTER = (0xffffffff);
static const int MIN_UCSCHAR = (0);
//
//  We'll assume here that the ISO-10646 / Unicode agreement
//  not to assign code points after U+0010FFFF holds so that
//  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
//  types.
//
static const int MAX_UCSCHAR = (0x0010FFFF);
typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;
typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR *PUUCSSTR;
typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR *PCUUCSSTR;
typedef UCSCHAR *PUUCSCHAR;
typedef const UCSCHAR *PCUUCSCHAR;
//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR, *LPSTR, *PSTR;
typedef PSTR *PZPSTR;
typedef const PSTR *PCZPSTR;
typedef const CHAR *LPCSTR, *PCSTR;
typedef PCSTR *PZPCSTR;
typedef CHAR *PZZSTR;
typedef const CHAR *PCZZSTR;
typedef __possibly_notnullterminated CHAR *PNZCH;
typedef __possibly_notnullterminated const CHAR *PCNZCH;
//
// Neutral ANSI/UNICODE types and macros
//
# 464 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;
typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;
static const int __TEXT(quote) = quote;
static const int TEXT(quote) = __TEXT(quote);
typedef SHORT *PSHORT;
typedef LONG *PLONG;
static const int ALL_PROCESSOR_GROUPS = 0xffff;
//
// Structure to represent a system wide processor number. It contains a
// group number and relative processor number within the group.
//
typedef struct _PROCESSOR_NUMBER {
    WORD Group;
    BYTE Number;
    BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
//
// Structure to represent a group-specific affinity, such as that of a
// thread.  Specifies the group number and the affinity within that group.
//
typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD Group;
    WORD Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;
//
// Handle to an Object
//
typedef void *HANDLE;
static const int DECLARE_HANDLE(name) = struct name ##__{int unused;}; typedef struct name ##__ *name;
typedef HANDLE *PHANDLE;
//
// Flag (bit) fields
//
typedef BYTE FCHAR;
typedef WORD FSHORT;
typedef DWORD FLONG;
// Component Object Model defines, and macros
typedef long HRESULT;
static const int EXTERN_C = extern;
// Win32 doesn't support __export
static const int STDMETHODCALLTYPE = __stdcall;
static const int STDMETHODVCALLTYPE = __cdecl;
static const int STDAPICALLTYPE = __stdcall;
static const int STDAPIVCALLTYPE = __cdecl;
# 577 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int STDAPI = EXTERN_C HRESULT STDAPICALLTYPE;
static const int STDAPI_(type) = EXTERN_C type STDAPICALLTYPE;
static const int STDMETHODIMP = HRESULT STDMETHODCALLTYPE;
static const int STDMETHODIMP_(type) = type STDMETHODCALLTYPE;
static const int STDOVERRIDEMETHODIMP = __override STDMETHODIMP;
static const int STDOVERRIDEMETHODIMP_(type) = __override STDMETHODIMP_(type);
static const int IFACEMETHODIMP = __override STDMETHODIMP;
static const int IFACEMETHODIMP_(type) = __override STDMETHODIMP_(type);
// The 'V' versions allow Variable Argument lists.
static const int STDAPIV = EXTERN_C HRESULT STDAPIVCALLTYPE;
static const int STDAPIV_(type) = EXTERN_C type STDAPIVCALLTYPE;
static const int STDMETHODIMPV = HRESULT STDMETHODVCALLTYPE;
static const int STDMETHODIMPV_(type) = type STDMETHODVCALLTYPE;
static const int STDOVERRIDEMETHODIMPV = __override STDMETHODIMPV;
static const int STDOVERRIDEMETHODIMPV_(type) = __override STDMETHODIMPV_(type);
static const int IFACEMETHODIMPV = __override STDMETHODIMPV;
static const int IFACEMETHODIMPV_(type) = __override STDMETHODIMPV_(type);
typedef char CCHAR;
typedef DWORD LCID;
typedef PDWORD PLCID;
typedef WORD LANGID;
static const int APPLICATION_ERROR_MASK = 0x20000000;
static const int ERROR_SEVERITY_SUCCESS = 0x00000000;
static const int ERROR_SEVERITY_INFORMATIONAL = 0x40000000;
static const int ERROR_SEVERITY_WARNING = 0x80000000;
static const int ERROR_SEVERITY_ERROR = 0xC0000000;
//
// _M_IX86 included so that EM CONTEXT structure compiles with
// x86 programs. *** TBD should this be for all architectures?
//
//
// 16 byte aligned type for 128 bit floats
//
//
// For we define a 128 bit structure and use __declspec(align(16)) pragma to
// align to 128 bits.
//
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;
typedef FLOAT128 *PFLOAT128;
//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
static const int MAXLONGLONG = (0x7fffffffffffffff);
# 667 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;
// Update Sequence Number
typedef LONGLONG USN;
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    } s;
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
    LONGLONG QuadPart;
} LARGE_INTEGER;
typedef LARGE_INTEGER *PLARGE_INTEGER;
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } s;
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
    ULONGLONG QuadPart;
} ULARGE_INTEGER;
typedef ULARGE_INTEGER *PULARGE_INTEGER;
// end_ntminiport end_ntndis end_ntminitape
//
// Locally Unique Identifier
//
typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;
typedef ULONGLONG DWORDLONG;
typedef DWORDLONG *PDWORDLONG;
//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//
# 855 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Define rotate intrinsics.
//
# 955 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int ANSI_NULL = ((CHAR)0);
static const int UNICODE_NULL = ((WCHAR)0);
static const int UNICODE_STRING_MAX_BYTES = ((WORD ) 65534);
static const int UNICODE_STRING_MAX_CHARS = (32767);
typedef BYTE BOOLEAN;
typedef BOOLEAN *PBOOLEAN;
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;
//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//
typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
//
// These are needed for portable debugger support.
//
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;
typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h" 1
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------
# 22 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
typedef struct _GUID {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
} GUID;
# 64 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
static const int DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) = EXTERN_C const GUID FAR name;
static const int DEFINE_OLEGUID(name,l,w1,w2) = DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46);
typedef GUID *LPGUID;
typedef const GUID *LPCGUID;
typedef GUID IID;
typedef IID *LPIID;
static const int IID_NULL = GUID_NULL;
static const int IsEqualIID(riid1,riid2) = IsEqualGUID(riid1, riid2);
typedef GUID CLSID;
typedef CLSID *LPCLSID;
static const int CLSID_NULL = GUID_NULL;
static const int IsEqualCLSID(rclsid1,rclsid2) = IsEqualGUID(rclsid1, rclsid2);
typedef GUID FMTID;
typedef FMTID *LPFMTID;
static const int FMTID_NULL = GUID_NULL;
static const int IsEqualFMTID(rfmtid1,rfmtid2) = IsEqualGUID(rfmtid1, rfmtid2);
static const int __MIDL_CONST = const;
static const int REFGUID = const GUID * __MIDL_CONST;
static const int REFIID = const IID * __MIDL_CONST;
static const int REFCLSID = const IID * __MIDL_CONST;
static const int REFFMTID = const IID * __MIDL_CONST;
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h" 1
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */
/* Define _CRTIMP */
# 21 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h" 2
static const int _NLSCMPERROR = 2147483647;
/* Define NULL pointer value */
# 40 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
/* For backwards compatibility */
static const int _WConst_return = _CONST_RETURN;
/* Function prototypes */
 void * _memccpy( void * _Dst, const void * _Src, int _Val, size_t _MaxCount);
 void * memchr( const void * _Buf , int _Val, size_t _MaxCount);
 int _memicmp( const void * _Buf1, const void * _Buf2, size_t _Size);
 int _memicmp_l( const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale);
        int memcmp( const void * _Buf1, const void * _Buf2, size_t _Size);
        void * memcpy( void * _Dst, const void * _Src, size_t _Size);
 errno_t memcpy_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);
# 88 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
        void * memset( void * _Dst, int _Val, size_t _Size);
# 98 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
 errno_t _strset_s( char * _Dst, size_t _DstSize, int _Value);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strset( char *_Dest, int _Value);
 errno_t strcpy_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strcpy( char *_Dest, const char * _Source);
 errno_t strcat_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strcat( char *_Dest, const char * _Source);
        int strcmp( const char * _Str1, const char * _Str2);
        size_t strlen( const char * _Str);
 size_t strnlen( const char * _Str, size_t _MaxCount);
 static __inline size_t strnlen_s( const char * _Str, size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
 errno_t memmove_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);
 void * memmove( void * _Dst, const void * _Src, size_t _Size);
 char * _strdup( const char * _Src);
 char * strchr( const char * _Str, int _Val);
 int _stricmp( const char * _Str1, const char * _Str2);
 int _strcmpi( const char * _Str1, const char * _Str2);
 int _stricmp_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
 int strcoll( const char * _Str1, const char * _Str2);
 int _strcoll_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
 int _stricoll( const char * _Str1, const char * _Str2);
 int _stricoll_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
 int _strncoll ( const char * _Str1, const char * _Str2, size_t _MaxCount);
 int _strncoll_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);
 int _strnicoll ( const char * _Str1, const char * _Str2, size_t _MaxCount);
 int _strnicoll_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);
 size_t strcspn( const char * _Str, const char * _Control);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strerror( const char * _ErrMsg);
 errno_t _strerror_s( char * _Buf, size_t _SizeInBytes, const char * _ErrMsg);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strerror( int);
 errno_t strerror_s( char * _Buf, size_t _SizeInBytes, int _ErrNum);
 errno_t _strlwr_s( char * _Str, size_t _Size);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strlwr( char *_String);
 errno_t _strlwr_s_l( char * _Str, size_t _Size, _locale_t _Locale);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strlwr_l( char *_String, _locale_t _Locale);
 errno_t strncat_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount);
#pragma warning(push)
#pragma warning(disable:6059)
/* prefast noise VSW 489802 */
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strncat( char *_Dest, const char * _Source, size_t _Count);
#pragma warning(pop)
 int strncmp( const char * _Str1, const char * _Str2, size_t _MaxCount);
 int _strnicmp( const char * _Str1, const char * _Str2, size_t _MaxCount);
 int _strnicmp_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);
 errno_t strncpy_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strncpy( char *_Dest, const char * _Source, size_t _Count);
 errno_t _strnset_s( char * _Str, size_t _SizeInBytes, int _Val, size_t _MaxCount);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strnset( char *_Dest, int _Val, size_t _Count);
 char * strpbrk( const char * _Str, const char * _Control);
 char * strrchr( const char * _Str, int _Ch);
 char * _strrev( char * _Str);
 size_t strspn( const char * _Str, const char * _Control);
 char * strstr( const char * _Str, const char * _SubStr);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strtok( char * _Str, const char * _Delim);
 char * strtok_s( char * _Str, const char * _Delim, char ** _Context);
 errno_t _strupr_s( char * _Str, size_t _Size);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strupr( char *_String);
 errno_t _strupr_s_l( char * _Str, size_t _Size, _locale_t _Locale);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strupr_l( char *_String, _locale_t _Locale);
 size_t strxfrm ( char * _Dst, const char * _Src, size_t _MaxCount);
 size_t _strxfrm_l( char * _Dst, const char * _Src, size_t _MaxCount, _locale_t _Locale);
# 259 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
/* wide function prototypes, also declared in wchar.h  */
 wchar_t * _wcsdup( const wchar_t * _Str);
 errno_t wcscat_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcscat( wchar_t *_Dest, const wchar_t * _Source);
 wchar_t * wcschr( const wchar_t * _Str, wchar_t _Ch);
 int wcscmp( const wchar_t * _Str1, const wchar_t * _Str2);
 errno_t wcscpy_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcscpy( wchar_t *_Dest, const wchar_t * _Source);
 size_t wcscspn( const wchar_t * _Str, const wchar_t * _Control);
 size_t wcslen( const wchar_t * _Str);
 size_t wcsnlen( const wchar_t * _Src, size_t _MaxCount);
 static __inline size_t wcsnlen_s( const wchar_t * _Src, size_t _MaxCount)
{
    return (_Src == ((void *)0)) ? 0 : wcsnlen(_Src, _MaxCount);
}
 errno_t wcsncat_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src, rsize_t _MaxCount);
#pragma warning(push)
#pragma warning(disable:6059)
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcsncat( wchar_t *_Dest, const wchar_t * _Source, size_t _Count);
#pragma warning(pop)
 int wcsncmp( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
 errno_t wcsncpy_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src, rsize_t _MaxCount);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcsncpy( wchar_t *_Dest, const wchar_t * _Source, size_t _Count);
 wchar_t * wcspbrk( const wchar_t * _Str, const wchar_t * _Control);
 wchar_t * wcsrchr( const wchar_t * _Str, wchar_t _Ch);
 size_t wcsspn( const wchar_t * _Str, const wchar_t * _Control);
 wchar_t * wcsstr( const wchar_t * _Str, const wchar_t * _SubStr);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcstok( wchar_t * _Str, const wchar_t * _Delim);
 wchar_t * wcstok_s( wchar_t * _Str, const wchar_t * _Delim, wchar_t ** _Context);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcserror( int _ErrNum);
 errno_t _wcserror_s( wchar_t * _Buf, size_t _SizeInWords, int _ErrNum);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * __wcserror( const wchar_t * _Str);
 errno_t __wcserror_s( wchar_t * _Buffer, size_t _SizeInWords, const wchar_t * _ErrMsg);
 int _wcsicmp( const wchar_t * _Str1, const wchar_t * _Str2);
 int _wcsicmp_l( const wchar_t * _Str1, const wchar_t * _Str2, _locale_t _Locale);
 int _wcsnicmp( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
 int _wcsnicmp_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
 errno_t _wcsnset_s( wchar_t * _Dst, size_t _SizeInWords, wchar_t _Val, size_t _MaxCount);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsnset( wchar_t *_Str, wchar_t _Val, size_t _MaxCount);
 wchar_t * _wcsrev( wchar_t * _Str);
 errno_t _wcsset_s( wchar_t * _Dst, size_t _SizeInWords, wchar_t _Value);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsset( wchar_t *_Str, wchar_t _Val);
 errno_t _wcslwr_s( wchar_t * _Str, size_t _SizeInWords);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcslwr( wchar_t *_String);
 errno_t _wcslwr_s_l( wchar_t * _Str, size_t _SizeInWords, _locale_t _Locale);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcslwr_l( wchar_t *_String, _locale_t _Locale);
 errno_t _wcsupr_s( wchar_t * _Str, size_t _Size);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsupr( wchar_t *_String);
 errno_t _wcsupr_s_l( wchar_t * _Str, size_t _Size, _locale_t _Locale);
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsupr_l( wchar_t *_String, _locale_t _Locale);
 size_t wcsxfrm( wchar_t * _Dst, const wchar_t * _Src, size_t _MaxCount);
 size_t _wcsxfrm_l( wchar_t * _Dst, const wchar_t *_Src, size_t _MaxCount, _locale_t _Locale);
 int wcscoll( const wchar_t * _Str1, const wchar_t * _Str2);
 int _wcscoll_l( const wchar_t * _Str1, const wchar_t * _Str2, _locale_t _Locale);
 int _wcsicoll( const wchar_t * _Str1, const wchar_t * _Str2);
 int _wcsicoll_l( const wchar_t * _Str1, const wchar_t *_Str2, _locale_t _Locale);
 int _wcsncoll( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
 int _wcsncoll_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
 int _wcsnicoll( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
 int _wcsnicoll_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
# 401 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
# 147 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h" 2
// Faster (but makes code fatter) inline version...use sparingly
# 166 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
static const int InlineIsEqualGUID(rguid1,rguid2) = (((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] && ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] && ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] && ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3]);
static const int IsEqualGUID(rguid1,rguid2) = (!memcmp(rguid1, rguid2, sizeof(GUID)));
# 181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
// Same type, different name
static const int IsEqualIID(riid1,riid2) = IsEqualGUID(riid1, riid2);
static const int IsEqualCLSID(rclsid1,rclsid2) = IsEqualGUID(rclsid1, rclsid2);
// A couple of C++ helpers
# 999 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
typedef struct _OBJECTID { // size is 20
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
static const int MINCHAR = 0x80;
static const int MAXCHAR = 0x7f;
static const int MINSHORT = 0x8000;
static const int MAXSHORT = 0x7fff;
static const int MINLONG = 0x80000000;
static const int MAXLONG = 0x7fffffff;
static const int MAXBYTE = 0xff;
static const int MAXWORD = 0xffff;
static const int MAXDWORD = 0xffffffff;
//
// Calculate the byte offset of a field in a structure of type type.
//
static const int FIELD_OFFSET(type,field) = ((LONG)(LONG_PTR)&(((type *)0)->field));
//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
static const int RTL_FIELD_SIZE(type,field) = (sizeof(((type *)0)->field));
//
// Calculate the size of a structure of type type up through and
// including a field.
//
static const int RTL_SIZEOF_THROUGH_FIELD(type,field) = (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field));
//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
static const int RTL_CONTAINS_FIELD(Struct,Size,Field) = ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) );
//
// Return the number of elements in a statically sized array.
//   DWORD Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
static const int RTL_NUMBER_OF_V1(A) = (sizeof(A)/sizeof((A)[0]));
# 1125 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int RTL_NUMBER_OF_V2(A) = RTL_NUMBER_OF_V1(A);
static const int RTL_NUMBER_OF(A) = RTL_NUMBER_OF_V1(A);
//
// ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
// it regardless of ENABLE_RTL_NUMBER_OF_V2
//
// _ARRAYSIZE is a version useful for anonymous types
//
static const int ARRAYSIZE(A) = RTL_NUMBER_OF_V2(A);
static const int _ARRAYSIZE(A) = RTL_NUMBER_OF_V1(A);
//
// An expression that yields the type of a field in a struct.
//
static const int RTL_FIELD_TYPE(type,field) = (((type*)0)->field);
// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
static const int RTL_NUMBER_OF_FIELD(type,field) = (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)));
//
// eg:
// typedef struct FOO {
//   DWORD Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
static const int RTL_PADDING_BETWEEN_FIELDS(T,F1,F2) = ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)));
// RTL_ to avoid collisions in the global namespace.
static const int RTL_CONST_CAST(type) = (type);
// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
static const int RTL_BITS_OF(sizeOfArg) = (sizeof(sizeOfArg) * 8);
static const int RTL_BITS_OF_FIELD(type,field) = (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)));
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//
static const int CONTAINING_RECORD(address,type,field) = ((type *)( (PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)));
// end_ntminiport end_ntndis
//
// Exception handler routine definition.
//
typedef
EXCEPTION_DISPOSITION
EXCEPTION_ROUTINE (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    PVOID EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    PVOID DispatcherContext
    );
typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;
static const int VER_SERVER_NT = 0x80000000;
static const int VER_WORKSTATION_NT = 0x40000000;
static const int VER_SUITE_SMALLBUSINESS = 0x00000001;
static const int VER_SUITE_ENTERPRISE = 0x00000002;
static const int VER_SUITE_BACKOFFICE = 0x00000004;
static const int VER_SUITE_COMMUNICATIONS = 0x00000008;
static const int VER_SUITE_TERMINAL = 0x00000010;
static const int VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020;
static const int VER_SUITE_EMBEDDEDNT = 0x00000040;
static const int VER_SUITE_DATACENTER = 0x00000080;
static const int VER_SUITE_SINGLEUSERTS = 0x00000100;
static const int VER_SUITE_PERSONAL = 0x00000200;
static const int VER_SUITE_BLADE = 0x00000400;
static const int VER_SUITE_EMBEDDED_RESTRICTED = 0x00000800;
static const int VER_SUITE_SECURITY_APPLIANCE = 0x00001000;
static const int VER_SUITE_STORAGE_SERVER = 0x00002000;
static const int VER_SUITE_COMPUTE_SERVER = 0x00004000;
static const int VER_SUITE_WH_SERVER = 0x00008000;
//
// Product types
// This list grows with each OS release.
//
// There is no ordering of values to ensure callers
// do an equality test i.e. greater-than and less-than
// comparisons are not useful.
//
// NOTE: Values in this list should never be deleted.
//       When a product-type 'X' gets dropped from a
//       OS release onwards, the value of 'X' continues
//       to be used in the mapping table of GetProductInfo.
//
static const int PRODUCT_UNDEFINED = 0x00000000;
static const int PRODUCT_ULTIMATE = 0x00000001;
static const int PRODUCT_HOME_BASIC = 0x00000002;
static const int PRODUCT_HOME_PREMIUM = 0x00000003;
static const int PRODUCT_ENTERPRISE = 0x00000004;
static const int PRODUCT_HOME_BASIC_N = 0x00000005;
static const int PRODUCT_BUSINESS = 0x00000006;
static const int PRODUCT_STANDARD_SERVER = 0x00000007;
static const int PRODUCT_DATACENTER_SERVER = 0x00000008;
static const int PRODUCT_SMALLBUSINESS_SERVER = 0x00000009;
static const int PRODUCT_ENTERPRISE_SERVER = 0x0000000A;
static const int PRODUCT_STARTER = 0x0000000B;
static const int PRODUCT_DATACENTER_SERVER_CORE = 0x0000000C;
static const int PRODUCT_STANDARD_SERVER_CORE = 0x0000000D;
static const int PRODUCT_ENTERPRISE_SERVER_CORE = 0x0000000E;
static const double PRODUCT_ENTERPRISE_SERVER_IA64 = 0x0000000F;
static const int PRODUCT_BUSINESS_N = 0x00000010;
static const int PRODUCT_WEB_SERVER = 0x00000011;
static const int PRODUCT_CLUSTER_SERVER = 0x00000012;
static const int PRODUCT_HOME_SERVER = 0x00000013;
static const int PRODUCT_STORAGE_EXPRESS_SERVER = 0x00000014;
static const int PRODUCT_STORAGE_STANDARD_SERVER = 0x00000015;
static const int PRODUCT_STORAGE_WORKGROUP_SERVER = 0x00000016;
static const int PRODUCT_STORAGE_ENTERPRISE_SERVER = 0x00000017;
static const int PRODUCT_SERVER_FOR_SMALLBUSINESS = 0x00000018;
static const int PRODUCT_SMALLBUSINESS_SERVER_PREMIUM = 0x00000019;
static const int PRODUCT_HOME_PREMIUM_N = 0x0000001A;
static const int PRODUCT_ENTERPRISE_N = 0x0000001B;
static const int PRODUCT_ULTIMATE_N = 0x0000001C;
static const int PRODUCT_WEB_SERVER_CORE = 0x0000001D;
static const int PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT = 0x0000001E;
static const double PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY = 0x0000001F;
static const int PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING = 0x00000020;
static const int PRODUCT_SERVER_FOUNDATION = 0x00000021;
static const int PRODUCT_HOME_PREMIUM_SERVER = 0x00000022;
static const int PRODUCT_SERVER_FOR_SMALLBUSINESS_V = 0x00000023;
static const int PRODUCT_STANDARD_SERVER_V = 0x00000024;
static const int PRODUCT_DATACENTER_SERVER_V = 0x00000025;
static const int PRODUCT_ENTERPRISE_SERVER_V = 0x00000026;
static const int PRODUCT_DATACENTER_SERVER_CORE_V = 0x00000027;
static const int PRODUCT_STANDARD_SERVER_CORE_V = 0x00000028;
static const int PRODUCT_ENTERPRISE_SERVER_CORE_V = 0x00000029;
static const int PRODUCT_HYPERV = 0x0000002A;
static const int PRODUCT_STORAGE_EXPRESS_SERVER_CORE = 0x0000002B;
static const int PRODUCT_STORAGE_STANDARD_SERVER_CORE = 0x0000002C;
static const int PRODUCT_STORAGE_WORKGROUP_SERVER_CORE = 0x0000002D;
static const int PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE = 0x0000002E;
static const double PRODUCT_STARTER_N = 0x0000002F;
static const int PRODUCT_PROFESSIONAL = 0x00000030;
static const int PRODUCT_PROFESSIONAL_N = 0x00000031;
static const int PRODUCT_SB_SOLUTION_SERVER = 0x00000032;
static const int PRODUCT_SERVER_FOR_SB_SOLUTIONS = 0x00000033;
static const int PRODUCT_STANDARD_SERVER_SOLUTIONS = 0x00000034;
static const int PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE = 0x00000035;
static const int PRODUCT_SB_SOLUTION_SERVER_EM = 0x00000036;
static const int PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM = 0x00000037;
static const int PRODUCT_SOLUTION_EMBEDDEDSERVER = 0x00000038;
static const int PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE = 0x00000039;
static const double PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE = 0x0000003F;
static const int PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT = 0x0000003B;
static const int PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL = 0x0000003C;
static const int PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC = 0x0000003D;
static const int PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC = 0x0000003E;
static const int PRODUCT_CLUSTER_SERVER_V = 0x00000040;
static const int PRODUCT_EMBEDDED = 0x00000041;
static const int PRODUCT_STARTER_E = 0x00000042;
static const int PRODUCT_HOME_BASIC_E = 0x00000043;
static const int PRODUCT_HOME_PREMIUM_E = 0x00000044;
static const int PRODUCT_PROFESSIONAL_E = 0x00000045;
static const int PRODUCT_ENTERPRISE_E = 0x00000046;
static const int PRODUCT_ULTIMATE_E = 0x00000047;
static const int PRODUCT_UNLICENSED = 0xABCDABCD;
//
//  Language IDs.
//
//  Note that the named locale APIs (eg GetLocaleInfoEx) are preferred.
//
//  Not all locales have unique Language IDs
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//    LANG_INVARIANT        SUBLANG_NEUTRAL     Invariant locale
//
//  It is recommended that applications test for locale names instead of
//  Language IDs / LCIDs.
//
//  Primary language IDs.
//
//  WARNING: These aren't always unique.  Bosnian, Serbian & Croation for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
static const int LANG_NEUTRAL = 0x00;
static const int LANG_INVARIANT = 0x7f;
static const int LANG_AFRIKAANS = 0x36;
static const int LANG_ALBANIAN = 0x1c;
static const int LANG_ALSATIAN = 0x84;
static const int LANG_AMHARIC = 0x5e;
static const int LANG_ARABIC = 0x01;
static const int LANG_ARMENIAN = 0x2b;
static const int LANG_ASSAMESE = 0x4d;
static const int LANG_AZERI = 0x2c;
static const int LANG_BASHKIR = 0x6d;
static const int LANG_BASQUE = 0x2d;
static const int LANG_BELARUSIAN = 0x23;
static const int LANG_BENGALI = 0x45;
static const int LANG_BRETON = 0x7e;
static const int LANG_BOSNIAN = 0x1a;
static const int LANG_BOSNIAN_NEUTRAL = 0x781a;
static const int LANG_BULGARIAN = 0x02;
static const int LANG_CATALAN = 0x03;
static const int LANG_CHINESE = 0x04;
static const int LANG_CHINESE_SIMPLIFIED = 0x04;
static const int LANG_CHINESE_TRADITIONAL = 0x7c04;
static const int LANG_CORSICAN = 0x83;
static const int LANG_CROATIAN = 0x1a;
static const int LANG_CZECH = 0x05;
static const int LANG_DANISH = 0x06;
static const int LANG_DARI = 0x8c;
static const int LANG_DIVEHI = 0x65;
static const int LANG_DUTCH = 0x13;
static const int LANG_ENGLISH = 0x09;
static const int LANG_ESTONIAN = 0x25;
static const int LANG_FAEROESE = 0x38;
static const int LANG_FARSI = 0x29;
static const int LANG_FILIPINO = 0x64;
static const int LANG_FINNISH = 0x0b;
static const int LANG_FRENCH = 0x0c;
static const int LANG_FRISIAN = 0x62;
static const int LANG_GALICIAN = 0x56;
static const int LANG_GEORGIAN = 0x37;
static const int LANG_GERMAN = 0x07;
static const int LANG_GREEK = 0x08;
static const int LANG_GREENLANDIC = 0x6f;
static const int LANG_GUJARATI = 0x47;
static const int LANG_HAUSA = 0x68;
static const int LANG_HEBREW = 0x0d;
static const int LANG_HINDI = 0x39;
static const int LANG_HUNGARIAN = 0x0e;
static const int LANG_ICELANDIC = 0x0f;
static const int LANG_IGBO = 0x70;
static const int LANG_INDONESIAN = 0x21;
static const int LANG_INUKTITUT = 0x5d;
static const int LANG_IRISH = 0x3c;
static const int LANG_ITALIAN = 0x10;
static const int LANG_JAPANESE = 0x11;
static const int LANG_KANNADA = 0x4b;
static const int LANG_KASHMIRI = 0x60;
static const int LANG_KAZAK = 0x3f;
static const int LANG_KHMER = 0x53;
static const int LANG_KICHE = 0x86;
static const int LANG_KINYARWANDA = 0x87;
static const int LANG_KONKANI = 0x57;
static const int LANG_KOREAN = 0x12;
static const int LANG_KYRGYZ = 0x40;
static const int LANG_LAO = 0x54;
static const int LANG_LATVIAN = 0x26;
static const int LANG_LITHUANIAN = 0x27;
static const int LANG_LOWER_SORBIAN = 0x2e;
static const int LANG_LUXEMBOURGISH = 0x6e;
static const int LANG_MACEDONIAN = 0x2f;
static const int LANG_MALAY = 0x3e;
static const int LANG_MALAYALAM = 0x4c;
static const int LANG_MALTESE = 0x3a;
static const int LANG_MANIPURI = 0x58;
static const int LANG_MAORI = 0x81;
static const int LANG_MAPUDUNGUN = 0x7a;
static const int LANG_MARATHI = 0x4e;
static const int LANG_MOHAWK = 0x7c;
static const int LANG_MONGOLIAN = 0x50;
static const int LANG_NEPALI = 0x61;
static const int LANG_NORWEGIAN = 0x14;
static const int LANG_OCCITAN = 0x82;
static const int LANG_ORIYA = 0x48;
static const int LANG_PASHTO = 0x63;
static const int LANG_PERSIAN = 0x29;
static const int LANG_POLISH = 0x15;
static const int LANG_PORTUGUESE = 0x16;
static const int LANG_PUNJABI = 0x46;
static const int LANG_QUECHUA = 0x6b;
static const int LANG_ROMANIAN = 0x18;
static const int LANG_ROMANSH = 0x17;
static const int LANG_RUSSIAN = 0x19;
static const int LANG_SAMI = 0x3b;
static const int LANG_SANSKRIT = 0x4f;
static const int LANG_SCOTTISH_GAELIC = 0x91;
static const int LANG_SERBIAN = 0x1a;
static const int LANG_SERBIAN_NEUTRAL = 0x7c1a;
static const int LANG_SINDHI = 0x59;
static const int LANG_SINHALESE = 0x5b;
static const int LANG_SLOVAK = 0x1b;
static const int LANG_SLOVENIAN = 0x24;
static const int LANG_SOTHO = 0x6c;
static const int LANG_SPANISH = 0x0a;
static const int LANG_SWAHILI = 0x41;
static const int LANG_SWEDISH = 0x1d;
static const int LANG_SYRIAC = 0x5a;
static const int LANG_TAJIK = 0x28;
static const int LANG_TAMAZIGHT = 0x5f;
static const int LANG_TAMIL = 0x49;
static const int LANG_TATAR = 0x44;
static const int LANG_TELUGU = 0x4a;
static const int LANG_THAI = 0x1e;
static const int LANG_TIBETAN = 0x51;
static const int LANG_TIGRIGNA = 0x73;
static const int LANG_TSWANA = 0x32;
static const int LANG_TURKISH = 0x1f;
static const int LANG_TURKMEN = 0x42;
static const int LANG_UIGHUR = 0x80;
static const int LANG_UKRAINIAN = 0x22;
static const int LANG_UPPER_SORBIAN = 0x2e;
static const int LANG_URDU = 0x20;
static const int LANG_UZBEK = 0x43;
static const int LANG_VIETNAMESE = 0x2a;
static const int LANG_WELSH = 0x52;
static const int LANG_WOLOF = 0x88;
static const int LANG_XHOSA = 0x34;
static const int LANG_YAKUT = 0x85;
static const int LANG_YI = 0x78;
static const int LANG_YORUBA = 0x6a;
static const int LANG_ZULU = 0x35;
//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
static const int SUBLANG_NEUTRAL = 0x00;
static const int SUBLANG_DEFAULT = 0x01;
static const int SUBLANG_SYS_DEFAULT = 0x02;
static const int SUBLANG_CUSTOM_DEFAULT = 0x03;
static const int SUBLANG_CUSTOM_UNSPECIFIED = 0x04;
static const int SUBLANG_UI_CUSTOM_DEFAULT = 0x05;
static const int SUBLANG_AFRIKAANS_SOUTH_AFRICA = 0x01;
static const int SUBLANG_ALBANIAN_ALBANIA = 0x01;
static const int SUBLANG_ALSATIAN_FRANCE = 0x01;
static const int SUBLANG_AMHARIC_ETHIOPIA = 0x01;
static const int SUBLANG_ARABIC_SAUDI_ARABIA = 0x01;
static const int SUBLANG_ARABIC_IRAQ = 0x02;
static const int SUBLANG_ARABIC_EGYPT = 0x03;
static const int SUBLANG_ARABIC_LIBYA = 0x04;
static const int SUBLANG_ARABIC_ALGERIA = 0x05;
static const int SUBLANG_ARABIC_MOROCCO = 0x06;
static const int SUBLANG_ARABIC_TUNISIA = 0x07;
static const int SUBLANG_ARABIC_OMAN = 0x08;
static const int SUBLANG_ARABIC_YEMEN = 0x09;
static const int SUBLANG_ARABIC_SYRIA = 0x0a;
static const int SUBLANG_ARABIC_JORDAN = 0x0b;
static const int SUBLANG_ARABIC_LEBANON = 0x0c;
static const int SUBLANG_ARABIC_KUWAIT = 0x0d;
static const int SUBLANG_ARABIC_UAE = 0x0e;
static const int SUBLANG_ARABIC_BAHRAIN = 0x0f;
static const int SUBLANG_ARABIC_QATAR = 0x10;
static const int SUBLANG_ARMENIAN_ARMENIA = 0x01;
static const int SUBLANG_ASSAMESE_INDIA = 0x01;
static const int SUBLANG_AZERI_LATIN = 0x01;
static const int SUBLANG_AZERI_CYRILLIC = 0x02;
static const int SUBLANG_BASHKIR_RUSSIA = 0x01;
static const int SUBLANG_BASQUE_BASQUE = 0x01;
static const int SUBLANG_BELARUSIAN_BELARUS = 0x01;
static const int SUBLANG_BENGALI_INDIA = 0x01;
static const int SUBLANG_BENGALI_BANGLADESH = 0x02;
static const int SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN = 0x05;
static const int SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 0x08;
static const int SUBLANG_BRETON_FRANCE = 0x01;
static const int SUBLANG_BULGARIAN_BULGARIA = 0x01;
static const int SUBLANG_CATALAN_CATALAN = 0x01;
static const int SUBLANG_CHINESE_TRADITIONAL = 0x01;
static const int SUBLANG_CHINESE_SIMPLIFIED = 0x02;
static const int SUBLANG_CHINESE_HONGKONG = 0x03;
static const int SUBLANG_CHINESE_SINGAPORE = 0x04;
static const int SUBLANG_CHINESE_MACAU = 0x05;
static const int SUBLANG_CORSICAN_FRANCE = 0x01;
static const int SUBLANG_CZECH_CZECH_REPUBLIC = 0x01;
static const int SUBLANG_CROATIAN_CROATIA = 0x01;
static const int SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN = 0x04;
static const int SUBLANG_DANISH_DENMARK = 0x01;
static const int SUBLANG_DARI_AFGHANISTAN = 0x01;
static const int SUBLANG_DIVEHI_MALDIVES = 0x01;
static const int SUBLANG_DUTCH = 0x01;
static const int SUBLANG_DUTCH_BELGIAN = 0x02;
static const int SUBLANG_ENGLISH_US = 0x01;
static const int SUBLANG_ENGLISH_UK = 0x02;
static const int SUBLANG_ENGLISH_AUS = 0x03;
static const int SUBLANG_ENGLISH_CAN = 0x04;
static const int SUBLANG_ENGLISH_NZ = 0x05;
static const int SUBLANG_ENGLISH_EIRE = 0x06;
static const int SUBLANG_ENGLISH_SOUTH_AFRICA = 0x07;
static const int SUBLANG_ENGLISH_JAMAICA = 0x08;
static const int SUBLANG_ENGLISH_CARIBBEAN = 0x09;
static const int SUBLANG_ENGLISH_BELIZE = 0x0a;
static const int SUBLANG_ENGLISH_TRINIDAD = 0x0b;
static const int SUBLANG_ENGLISH_ZIMBABWE = 0x0c;
static const int SUBLANG_ENGLISH_PHILIPPINES = 0x0d;
static const int SUBLANG_ENGLISH_INDIA = 0x10;
static const int SUBLANG_ENGLISH_MALAYSIA = 0x11;
static const int SUBLANG_ENGLISH_SINGAPORE = 0x12;
static const int SUBLANG_ESTONIAN_ESTONIA = 0x01;
static const int SUBLANG_FAEROESE_FAROE_ISLANDS = 0x01;
static const int SUBLANG_FILIPINO_PHILIPPINES = 0x01;
static const int SUBLANG_FINNISH_FINLAND = 0x01;
static const int SUBLANG_FRENCH = 0x01;
static const int SUBLANG_FRENCH_BELGIAN = 0x02;
static const int SUBLANG_FRENCH_CANADIAN = 0x03;
static const int SUBLANG_FRENCH_SWISS = 0x04;
static const int SUBLANG_FRENCH_LUXEMBOURG = 0x05;
static const int SUBLANG_FRENCH_MONACO = 0x06;
static const int SUBLANG_FRISIAN_NETHERLANDS = 0x01;
static const int SUBLANG_GALICIAN_GALICIAN = 0x01;
static const int SUBLANG_GEORGIAN_GEORGIA = 0x01;
static const int SUBLANG_GERMAN = 0x01;
static const int SUBLANG_GERMAN_SWISS = 0x02;
static const int SUBLANG_GERMAN_AUSTRIAN = 0x03;
static const int SUBLANG_GERMAN_LUXEMBOURG = 0x04;
static const int SUBLANG_GERMAN_LIECHTENSTEIN = 0x05;
static const int SUBLANG_GREEK_GREECE = 0x01;
static const int SUBLANG_GREENLANDIC_GREENLAND = 0x01;
static const int SUBLANG_GUJARATI_INDIA = 0x01;
static const int SUBLANG_HAUSA_NIGERIA_LATIN = 0x01;
static const int SUBLANG_HEBREW_ISRAEL = 0x01;
static const int SUBLANG_HINDI_INDIA = 0x01;
static const int SUBLANG_HUNGARIAN_HUNGARY = 0x01;
static const int SUBLANG_ICELANDIC_ICELAND = 0x01;
static const int SUBLANG_IGBO_NIGERIA = 0x01;
static const int SUBLANG_INDONESIAN_INDONESIA = 0x01;
static const int SUBLANG_INUKTITUT_CANADA = 0x01;
static const int SUBLANG_INUKTITUT_CANADA_LATIN = 0x02;
static const int SUBLANG_IRISH_IRELAND = 0x02;
static const int SUBLANG_ITALIAN = 0x01;
static const int SUBLANG_ITALIAN_SWISS = 0x02;
static const int SUBLANG_JAPANESE_JAPAN = 0x01;
static const int SUBLANG_KANNADA_INDIA = 0x01;
static const int SUBLANG_KASHMIRI_SASIA = 0x02;
static const int SUBLANG_KASHMIRI_INDIA = 0x02;
static const int SUBLANG_KAZAK_KAZAKHSTAN = 0x01;
static const int SUBLANG_KHMER_CAMBODIA = 0x01;
static const int SUBLANG_KICHE_GUATEMALA = 0x01;
static const int SUBLANG_KINYARWANDA_RWANDA = 0x01;
static const int SUBLANG_KONKANI_INDIA = 0x01;
static const int SUBLANG_KOREAN = 0x01;
static const int SUBLANG_KYRGYZ_KYRGYZSTAN = 0x01;
static const int SUBLANG_LAO_LAO = 0x01;
static const int SUBLANG_LATVIAN_LATVIA = 0x01;
static const int SUBLANG_LITHUANIAN = 0x01;
static const int SUBLANG_LOWER_SORBIAN_GERMANY = 0x02;
static const int SUBLANG_LUXEMBOURGISH_LUXEMBOURG = 0x01;
static const int SUBLANG_MACEDONIAN_MACEDONIA = 0x01;
static const int SUBLANG_MALAY_MALAYSIA = 0x01;
static const int SUBLANG_MALAY_BRUNEI_DARUSSALAM = 0x02;
static const int SUBLANG_MALAYALAM_INDIA = 0x01;
static const int SUBLANG_MALTESE_MALTA = 0x01;
static const int SUBLANG_MAORI_NEW_ZEALAND = 0x01;
static const int SUBLANG_MAPUDUNGUN_CHILE = 0x01;
static const int SUBLANG_MARATHI_INDIA = 0x01;
static const int SUBLANG_MOHAWK_MOHAWK = 0x01;
static const int SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA = 0x01;
static const int SUBLANG_MONGOLIAN_PRC = 0x02;
static const int SUBLANG_NEPALI_INDIA = 0x02;
static const int SUBLANG_NEPALI_NEPAL = 0x01;
static const int SUBLANG_NORWEGIAN_BOKMAL = 0x01;
static const int SUBLANG_NORWEGIAN_NYNORSK = 0x02;
static const int SUBLANG_OCCITAN_FRANCE = 0x01;
static const int SUBLANG_ORIYA_INDIA = 0x01;
static const int SUBLANG_PASHTO_AFGHANISTAN = 0x01;
static const int SUBLANG_PERSIAN_IRAN = 0x01;
static const int SUBLANG_POLISH_POLAND = 0x01;
static const int SUBLANG_PORTUGUESE = 0x02;
static const int SUBLANG_PORTUGUESE_BRAZILIAN = 0x01;
static const int SUBLANG_PUNJABI_INDIA = 0x01;
static const int SUBLANG_QUECHUA_BOLIVIA = 0x01;
static const int SUBLANG_QUECHUA_ECUADOR = 0x02;
static const int SUBLANG_QUECHUA_PERU = 0x03;
static const int SUBLANG_ROMANIAN_ROMANIA = 0x01;
static const int SUBLANG_ROMANSH_SWITZERLAND = 0x01;
static const int SUBLANG_RUSSIAN_RUSSIA = 0x01;
static const int SUBLANG_SAMI_NORTHERN_NORWAY = 0x01;
static const int SUBLANG_SAMI_NORTHERN_SWEDEN = 0x02;
static const int SUBLANG_SAMI_NORTHERN_FINLAND = 0x03;
static const int SUBLANG_SAMI_LULE_NORWAY = 0x04;
static const int SUBLANG_SAMI_LULE_SWEDEN = 0x05;
static const int SUBLANG_SAMI_SOUTHERN_NORWAY = 0x06;
static const int SUBLANG_SAMI_SOUTHERN_SWEDEN = 0x07;
static const int SUBLANG_SAMI_SKOLT_FINLAND = 0x08;
static const int SUBLANG_SAMI_INARI_FINLAND = 0x09;
static const int SUBLANG_SANSKRIT_INDIA = 0x01;
static const int SUBLANG_SCOTTISH_GAELIC = 0x01;
static const int SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN = 0x06;
static const int SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 0x07;
static const int SUBLANG_SERBIAN_MONTENEGRO_LATIN = 0x0b;
static const int SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC = 0x0c;
static const int SUBLANG_SERBIAN_SERBIA_LATIN = 0x09;
static const int SUBLANG_SERBIAN_SERBIA_CYRILLIC = 0x0a;
static const int SUBLANG_SERBIAN_CROATIA = 0x01;
static const int SUBLANG_SERBIAN_LATIN = 0x02;
static const int SUBLANG_SERBIAN_CYRILLIC = 0x03;
static const int SUBLANG_SINDHI_INDIA = 0x01;
static const int SUBLANG_SINDHI_PAKISTAN = 0x02;
static const int SUBLANG_SINDHI_AFGHANISTAN = 0x02;
static const int SUBLANG_SINHALESE_SRI_LANKA = 0x01;
static const int SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA = 0x01;
static const int SUBLANG_SLOVAK_SLOVAKIA = 0x01;
static const int SUBLANG_SLOVENIAN_SLOVENIA = 0x01;
static const int SUBLANG_SPANISH = 0x01;
static const int SUBLANG_SPANISH_MEXICAN = 0x02;
static const int SUBLANG_SPANISH_MODERN = 0x03;
static const int SUBLANG_SPANISH_GUATEMALA = 0x04;
static const int SUBLANG_SPANISH_COSTA_RICA = 0x05;
static const int SUBLANG_SPANISH_PANAMA = 0x06;
static const int SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 0x07;
static const int SUBLANG_SPANISH_VENEZUELA = 0x08;
static const int SUBLANG_SPANISH_COLOMBIA = 0x09;
static const int SUBLANG_SPANISH_PERU = 0x0a;
static const int SUBLANG_SPANISH_ARGENTINA = 0x0b;
static const int SUBLANG_SPANISH_ECUADOR = 0x0c;
static const int SUBLANG_SPANISH_CHILE = 0x0d;
static const int SUBLANG_SPANISH_URUGUAY = 0x0e;
static const int SUBLANG_SPANISH_PARAGUAY = 0x0f;
static const int SUBLANG_SPANISH_BOLIVIA = 0x10;
static const int SUBLANG_SPANISH_EL_SALVADOR = 0x11;
static const int SUBLANG_SPANISH_HONDURAS = 0x12;
static const int SUBLANG_SPANISH_NICARAGUA = 0x13;
static const int SUBLANG_SPANISH_PUERTO_RICO = 0x14;
static const int SUBLANG_SPANISH_US = 0x15;
static const int SUBLANG_SWAHILI_KENYA = 0x01;
static const int SUBLANG_SWEDISH = 0x01;
static const int SUBLANG_SWEDISH_FINLAND = 0x02;
static const int SUBLANG_SYRIAC_SYRIA = 0x01;
static const int SUBLANG_TAJIK_TAJIKISTAN = 0x01;
static const int SUBLANG_TAMAZIGHT_ALGERIA_LATIN = 0x02;
static const int SUBLANG_TAMIL_INDIA = 0x01;
static const int SUBLANG_TATAR_RUSSIA = 0x01;
static const int SUBLANG_TELUGU_INDIA = 0x01;
static const int SUBLANG_THAI_THAILAND = 0x01;
static const int SUBLANG_TIBETAN_PRC = 0x01;
static const int SUBLANG_TIGRIGNA_ERITREA = 0x02;
static const int SUBLANG_TSWANA_SOUTH_AFRICA = 0x01;
static const int SUBLANG_TURKISH_TURKEY = 0x01;
static const int SUBLANG_TURKMEN_TURKMENISTAN = 0x01;
static const int SUBLANG_UIGHUR_PRC = 0x01;
static const int SUBLANG_UKRAINIAN_UKRAINE = 0x01;
static const int SUBLANG_UPPER_SORBIAN_GERMANY = 0x01;
static const int SUBLANG_URDU_PAKISTAN = 0x01;
static const int SUBLANG_URDU_INDIA = 0x02;
static const int SUBLANG_UZBEK_LATIN = 0x01;
static const int SUBLANG_UZBEK_CYRILLIC = 0x02;
static const int SUBLANG_VIETNAMESE_VIETNAM = 0x01;
static const int SUBLANG_WELSH_UNITED_KINGDOM = 0x01;
static const int SUBLANG_WOLOF_SENEGAL = 0x01;
static const int SUBLANG_XHOSA_SOUTH_AFRICA = 0x01;
static const int SUBLANG_YAKUT_RUSSIA = 0x01;
static const int SUBLANG_YI_PRC = 0x01;
static const int SUBLANG_YORUBA_NIGERIA = 0x01;
static const int SUBLANG_ZULU_SOUTH_AFRICA = 0x01;
//
//  Sorting IDs.
//
//  Note that the named locale APIs (eg CompareStringExEx) are recommended.
//
static const int SORT_DEFAULT = 0x0;
static const int SORT_INVARIANT_MATH = 0x1;
static const int SORT_JAPANESE_XJIS = 0x0;
static const int SORT_JAPANESE_UNICODE = 0x1;
static const int SORT_JAPANESE_RADICALSTROKE = 0x4;
static const int SORT_CHINESE_BIG5 = 0x0;
static const int SORT_CHINESE_PRCP = 0x0;
static const int SORT_CHINESE_UNICODE = 0x1;
static const int SORT_CHINESE_PRC = 0x2;
static const int SORT_CHINESE_BOPOMOFO = 0x3;
static const int SORT_CHINESE_RADICALSTROKE = 0x4;
static const int SORT_KOREAN_KSC = 0x0;
static const int SORT_KOREAN_UNICODE = 0x1;
static const int SORT_GERMAN_PHONE_BOOK = 0x1;
static const int SORT_HUNGARIAN_DEFAULT = 0x0;
static const int SORT_HUNGARIAN_TECHNICAL = 0x1;
static const int SORT_GEORGIAN_TRADITIONAL = 0x0;
static const int SORT_GEORGIAN_MODERN = 0x1;
// end_r_winnt
//
//  A language ID is a 16 bit value which is the combination of a
//  primary language ID and a secondary language ID.  The bits are
//  allocated as follows:
//
//       +-----------------------+-------------------------+
//       |     Sublanguage ID    |   Primary Language ID   |
//       +-----------------------+-------------------------+
//        15                   10 9                       0   bit
//
//  WARNING:  This pattern isn't always follows, Serbina, Bosnian & Croation
//            for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Language ID creation/extraction macros:
//
//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//    PRIMARYLANGID - extract primary language id from a language id.
//    SUBLANGID     - extract sublanguage id from a language id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  Language IDs do not exist for all locales
//
static const int MAKELANGID(p,s) = ((((WORD )(s)) << 10) | (WORD )(p));
static const int PRIMARYLANGID(lgid) = ((WORD )(lgid) & 0x3ff);
static const int SUBLANGID(lgid) = ((WORD )(lgid) >> 10);
//
//  A locale ID is a 32 bit value which is the combination of a
//  language ID, a sort ID, and a reserved area.  The bits are
//  allocated as follows:
//
//       +-------------+---------+-------------------------+
//       |   Reserved  | Sort ID |      Language ID        |
//       +-------------+---------+-------------------------+
//        31         20 19     16 15                      0   bit
//
//  WARNING: This pattern isn't always followed (es-ES_tradnl vs es-ES for example)
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Locale ID creation/extraction macros:
//
//    MAKELCID            - construct the locale id from a language id and a sort id.
//    MAKESORTLCID        - construct the locale id from a language id, sort id, and sort version.
//    LANGIDFROMLCID      - extract the language id from a locale id.
//    SORTIDFROMLCID      - extract the sort id from a locale id.
//    SORTVERSIONFROMLCID - extract the sort version from a locale id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  LCIDs do not exist for all locales.
//
static const int NLS_VALID_LOCALE_MASK = 0x000fffff;
static const int MAKELCID(lgid,srtid) = ((DWORD)((((DWORD)((WORD )(srtid))) << 16) | ((DWORD)((WORD )(lgid)))));
static const int MAKESORTLCID(lgid,srtid,ver) = ((DWORD)((MAKELCID(lgid, srtid)) | (((DWORD)((WORD )(ver))) << 20)));
static const int LANGIDFROMLCID(lcid) = ((WORD )(lcid));
static const int SORTIDFROMLCID(lcid) = ((WORD )((((DWORD)(lcid)) >> 16) & 0xf));
static const int SORTVERSIONFROMLCID(lcid) = ((WORD )((((DWORD)(lcid)) >> 20) & 0xf));
// 8 characters for language
// 8 characters for region
// 64 characters for suffix (script)
// 2 characters for '-' separators
// 2 characters for prefix like "i-" or "x-"
// 1 null termination
static const int LOCALE_NAME_MAX_LENGTH = 85;
//
//  Default System and User IDs for language and locale.
//  Locale names such as LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_NAME_USER_DEFAULT,
//  and LOCALE_NAME_INVARIANT are preferred.
//
static const int LANG_SYSTEM_DEFAULT = (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT));
static const int LANG_USER_DEFAULT = (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT));
static const int LOCALE_SYSTEM_DEFAULT = (MAKELCID(LANG_SYSTEM_DEFAULT, SORT_DEFAULT));
static const int LOCALE_USER_DEFAULT = (MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT));
//
//  Other special IDs for language and locale.
//
static const int LOCALE_CUSTOM_DEFAULT = (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_DEFAULT), SORT_DEFAULT));
static const int LOCALE_CUSTOM_UNSPECIFIED = (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_UNSPECIFIED), SORT_DEFAULT));
static const int LOCALE_CUSTOM_UI_DEFAULT = (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_UI_CUSTOM_DEFAULT), SORT_DEFAULT));
static const int LOCALE_NEUTRAL = (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT));
static const int LOCALE_INVARIANT = (MAKELCID(MAKELANGID(LANG_INVARIANT, SUBLANG_NEUTRAL), SORT_DEFAULT));
// begin_ntminiport begin_ntndis begin_ntminitape
//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//
static const int UNREFERENCED_PARAMETER(P) = (P);
static const int DBG_UNREFERENCED_PARAMETER(P) = (P);
static const int DBG_UNREFERENCED_LOCAL_VARIABLE(V) = (V);
# 1923 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//
//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//
# 1967 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
// Compile-time macros for initializing flag values in const data.
// 
// When using DEFINE_ENUM_FLAG_OPERATORS for enum values you should use the macros below
// when you need to initialize global const data.  Without these macros the inline operators 
// from DEFINE_ENUM_FLAG_OPERATORS force a runtime initialization rather than a
// compile time initialization.  This applies even if you have declared the data as const.
static const int COMPILETIME_OR_2FLAGS(a,b) = ((UINT)(a)|(UINT)(b));
static const int COMPILETIME_OR_3FLAGS(a,b,c) = ((UINT)(a)|(UINT)(b)|(UINT)(c));
static const int COMPILETIME_OR_4FLAGS(a,b,c,d) = ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d));
static const int COMPILETIME_OR_5FLAGS(a,b,c,d,e) = ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d)|(UINT)(e));
/*lint -save -e767 */
static const int STATUS_WAIT_0 = ((DWORD )0x00000000L);
static const int STATUS_ABANDONED_WAIT_0 = ((DWORD )0x00000080L);
static const int STATUS_USER_APC = ((DWORD )0x000000C0L);
static const int STATUS_TIMEOUT = ((DWORD )0x00000102L);
static const int STATUS_PENDING = ((DWORD )0x00000103L);
static const int DBG_EXCEPTION_HANDLED = ((DWORD )0x00010001L);
static const int DBG_CONTINUE = ((DWORD )0x00010002L);
static const int STATUS_SEGMENT_NOTIFICATION = ((DWORD )0x40000005L);
static const int DBG_TERMINATE_THREAD = ((DWORD )0x40010003L);
static const int DBG_TERMINATE_PROCESS = ((DWORD )0x40010004L);
static const int DBG_CONTROL_C = ((DWORD )0x40010005L);
static const int DBG_PRINTEXCEPTION_C = ((DWORD )0x40010006L);
static const int DBG_RIPEXCEPTION = ((DWORD )0x40010007L);
static const int DBG_CONTROL_BREAK = ((DWORD )0x40010008L);
static const int DBG_COMMAND_EXCEPTION = ((DWORD )0x40010009L);
static const int STATUS_GUARD_PAGE_VIOLATION = ((DWORD )0x80000001L);
static const int STATUS_DATATYPE_MISALIGNMENT = ((DWORD )0x80000002L);
static const int STATUS_BREAKPOINT = ((DWORD )0x80000003L);
static const int STATUS_SINGLE_STEP = ((DWORD )0x80000004L);
static const int STATUS_LONGJUMP = ((DWORD )0x80000026L);
static const int STATUS_UNWIND_CONSOLIDATE = ((DWORD )0x80000029L);
static const int DBG_EXCEPTION_NOT_HANDLED = ((DWORD )0x80010001L);
static const int STATUS_ACCESS_VIOLATION = ((DWORD )0xC0000005L);
static const int STATUS_IN_PAGE_ERROR = ((DWORD )0xC0000006L);
static const int STATUS_INVALID_HANDLE = ((DWORD )0xC0000008L);
static const int STATUS_INVALID_PARAMETER = ((DWORD )0xC000000DL);
static const int STATUS_NO_MEMORY = ((DWORD )0xC0000017L);
static const int STATUS_ILLEGAL_INSTRUCTION = ((DWORD )0xC000001DL);
static const int STATUS_NONCONTINUABLE_EXCEPTION = ((DWORD )0xC0000025L);
static const int STATUS_INVALID_DISPOSITION = ((DWORD )0xC0000026L);
static const int STATUS_ARRAY_BOUNDS_EXCEEDED = ((DWORD )0xC000008CL);
static const int STATUS_FLOAT_DENORMAL_OPERAND = ((DWORD )0xC000008DL);
static const int STATUS_FLOAT_DIVIDE_BY_ZERO = ((DWORD )0xC000008EL);
static const int STATUS_FLOAT_INEXACT_RESULT = ((DWORD )0xC000008FL);
static const int STATUS_FLOAT_INVALID_OPERATION = ((DWORD )0xC0000090L);
static const int STATUS_FLOAT_OVERFLOW = ((DWORD )0xC0000091L);
static const int STATUS_FLOAT_STACK_CHECK = ((DWORD )0xC0000092L);
static const int STATUS_FLOAT_UNDERFLOW = ((DWORD )0xC0000093L);
static const int STATUS_INTEGER_DIVIDE_BY_ZERO = ((DWORD )0xC0000094L);
static const int STATUS_INTEGER_OVERFLOW = ((DWORD )0xC0000095L);
static const int STATUS_PRIVILEGED_INSTRUCTION = ((DWORD )0xC0000096L);
static const int STATUS_STACK_OVERFLOW = ((DWORD )0xC00000FDL);
static const int STATUS_DLL_NOT_FOUND = ((DWORD )0xC0000135L);
static const int STATUS_ORDINAL_NOT_FOUND = ((DWORD )0xC0000138L);
static const int STATUS_ENTRYPOINT_NOT_FOUND = ((DWORD )0xC0000139L);
static const int STATUS_CONTROL_C_EXIT = ((DWORD )0xC000013AL);
static const int STATUS_DLL_INIT_FAILED = ((DWORD )0xC0000142L);
static const int STATUS_FLOAT_MULTIPLE_FAULTS = ((DWORD )0xC00002B4L);
static const int STATUS_FLOAT_MULTIPLE_TRAPS = ((DWORD )0xC00002B5L);
static const int STATUS_REG_NAT_CONSUMPTION = ((DWORD )0xC00002C9L);
static const int STATUS_STACK_BUFFER_OVERRUN = ((DWORD )0xC0000409L);
static const int STATUS_INVALID_CRUNTIME_PARAMETER = ((DWORD )0xC0000417L);
static const int STATUS_ASSERTION_FAILURE = ((DWORD )0xC0000420L);
static const int STATUS_SXS_EARLY_DEACTIVATION = ((DWORD )0xC015000FL);
static const int STATUS_SXS_INVALID_DEACTIVATION = ((DWORD )0xC0150010L);
/*lint -restore */
static const int MAXIMUM_WAIT_OBJECTS = 64;
static const int MAXIMUM_SUSPEND_COUNT = MAXCHAR;
typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;
//
// Define 128-bit 16-byte aligned xmm register type.
//
typedef struct _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;
//
// Format of data for (F)XSAVE/(F)XRSTOR instruction
//
typedef struct _XSAVE_FORMAT {
    WORD ControlWord;
    WORD StatusWord;
    BYTE TagWord;
    BYTE Reserved1;
    WORD ErrorOpcode;
    DWORD ErrorOffset;
    WORD ErrorSelector;
    WORD Reserved2;
    DWORD DataOffset;
    WORD DataSelector;
    WORD Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];
    M128A XmmRegisters[16];
    BYTE Reserved4[96];
# 2100 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
} XSAVE_FORMAT, *PXSAVE_FORMAT;
typedef struct _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 Reserved[7];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;
typedef struct _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;
typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
    PXSAVE_AREA Area;
    PVOID Buffer;
} XSTATE_CONTEXT, *PXSTATE_CONTEXT;
static const int XSAVE_ALIGN = 64;
static const int MINIMAL_XSTATE_AREA_LENGTH = sizeof(XSAVE_AREA);
//
// This structure specifies an offset (from the beginning of CONTEXT_EX
// structure) and size of a single chunk of an extended context structure.
//
// N.B. Offset may be negative.
//
typedef struct _CONTEXT_CHUNK {
    LONG Offset;
    DWORD Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;
//
// CONTEXT_EX structure is an extension to CONTEXT structure. It defines
// a context record as a set of disjoint variable-sized buffers (chunks)
// each containing a portion of processor state. Currently there are only
// two buffers (chunks) are defined:
//
//   - Legacy, that stores traditional CONTEXT structure;
//   - XState, that stores XSAVE save area buffer starting from
//     XSAVE_AREA_HEADER, i.e. without the first 512 bytes.
//
// There a few assumptions exists that simplify conversion of PCONTEXT
// pointer to PCONTEXT_EX pointer.
//
// 1. APIs that work with PCONTEXT pointers assume that CONTEXT_EX is
//    stored right after the CONTEXT structure. It is also assumed that
//    CONTEXT_EX is present if and only if corresponding CONTEXT_XXX
//    flags are set in CONTEXT.ContextFlags.
//
// 2. CONTEXT_EX.Legacy is always present if CONTEXT_EX structure is
//    present. All other chunks are optional.
//
// 3. CONTEXT.ContextFlags unambigiously define which chunks are
//    present. I.e. if CONTEXT_XSTATE is set CONTEXT_EX.XState is valid.
//
typedef struct _CONTEXT_EX {
    //
    // The total length of the structure starting from the chunk with
    // the smallest offset. N.B. that the offset may be negative.
    //
    CONTEXT_CHUNK All;
    //
    // Wrapper for the traditional CONTEXT structure. N.B. the size of
    // the chunk may be less than sizeof(CONTEXT) is some cases (when
    // CONTEXT_EXTENDED_REGISTERS is not set on x86 for instance).
    //
    CONTEXT_CHUNK Legacy;
    //
    // CONTEXT_XSTATE: Extended processor state chunk. The state is
    // stored in the same format XSAVE operation strores it with
    // exception of the first 512 bytes, i.e. staring from
    // XSAVE_AREA_HEADER. The lower two bits corresponding FP and
    // SSE state must be zero.
    //
    CONTEXT_CHUNK XState;
} CONTEXT_EX, *PCONTEXT_EX;
static const int CONTEXT_EX_LENGTH = ALIGN_UP_BY(sizeof(CONTEXT_EX), STACK_ALIGN);
//
// These macros make context chunks manupulations easier.
//
static const int RTL_CONTEXT_EX_OFFSET(ContextEx,Chunk) = ((ContextEx)->Chunk.Offset);
static const int RTL_CONTEXT_EX_LENGTH(ContextEx,Chunk) = ((ContextEx)->Chunk.Length);
static const int RTL_CONTEXT_EX_CHUNK(Base,Layout,Chunk) = ((PVOID)((PCHAR)(Base) + RTL_CONTEXT_EX_OFFSET(Layout, Chunk)));
static const int RTL_CONTEXT_OFFSET(Context,Chunk) = RTL_CONTEXT_EX_OFFSET((PCONTEXT_EX)(Context + 1), Chunk);
static const int RTL_CONTEXT_LENGTH(Context,Chunk) = RTL_CONTEXT_EX_LENGTH((PCONTEXT_EX)(Context + 1), Chunk);
static const int RTL_CONTEXT_CHUNK(Context,Chunk) = RTL_CONTEXT_EX_CHUNK((PCONTEXT_EX)(Context + 1), (PCONTEXT_EX)(Context + 1), Chunk);
//
// XSAVE/XRSTOR save area should be aligned on 64 byte boundary
//
typedef char __C_ASSERT__[((sizeof(XSAVE_FORMAT) & (64 - 1)) == 0)?1:-1];
typedef char __C_ASSERT__[((((LONG)(LONG_PTR)&(((XSAVE_AREA *)0)->Header)) & (64 - 1)) == 0)?1:-1];
// XSAVE_AREA structure must be sized uniformly on all architectures
typedef char __C_ASSERT__[(sizeof(XSAVE_AREA) == 512 + 64)?1:-1];
# 4288 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef struct _LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1; // Declare as bytes to avoid alignment
            BYTE Flags2; // Problems.
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;
# 6143 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int WOW64_CONTEXT_i386 = 0x00010000;
static const int WOW64_CONTEXT_i486 = 0x00010000;
static const int WOW64_CONTEXT_CONTROL = (WOW64_CONTEXT_i386 | 0x00000001L);
static const int WOW64_CONTEXT_INTEGER = (WOW64_CONTEXT_i386 | 0x00000002L);
static const int WOW64_CONTEXT_SEGMENTS = (WOW64_CONTEXT_i386 | 0x00000004L);
static const int WOW64_CONTEXT_FLOATING_POINT = (WOW64_CONTEXT_i386 | 0x00000008L);
static const int WOW64_CONTEXT_DEBUG_REGISTERS = (WOW64_CONTEXT_i386 | 0x00000010L);
static const int WOW64_CONTEXT_EXTENDED_REGISTERS = (WOW64_CONTEXT_i386 | 0x00000020L);
static const int WOW64_CONTEXT_FULL = (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS);
static const int WOW64_CONTEXT_ALL = (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS | WOW64_CONTEXT_FLOATING_POINT | WOW64_CONTEXT_DEBUG_REGISTERS | WOW64_CONTEXT_EXTENDED_REGISTERS);
static const int WOW64_CONTEXT_XSTATE = (WOW64_CONTEXT_i386 | 0x00000040L);
//
//  Define the size of the 80387 save area, which is in the context frame.
//
static const int WOW64_SIZE_OF_80387_REGISTERS = 80;
static const int WOW64_MAXIMUM_SUPPORTED_EXTENSION = 512;
typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;
typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack4.h
Abstract:
    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 6186 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//
typedef struct _WOW64_CONTEXT {
    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //
    DWORD ContextFlags;
    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //
    WOW64_FLOATING_SAVE_AREA FloatSave;
    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs; // MUST BE SANITIZED
    DWORD EFlags; // MUST BE SANITIZED
    DWORD Esp;
    DWORD SegSs;
    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //
    BYTE ExtendedRegisters[512];
} WOW64_CONTEXT;
typedef WOW64_CONTEXT *PWOW64_CONTEXT;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 6286 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
typedef struct _WOW64_LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1; // Declare as bytes to avoid alignment
            BYTE Flags2; // Problems.
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;
typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;
static const int EXCEPTION_NONCONTINUABLE = 0x1;
static const int EXCEPTION_MAXIMUM_PARAMETERS = 15;
//
// Exception record definition.
//
typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
    } EXCEPTION_RECORD;
typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
typedef struct _EXCEPTION_RECORD32 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;
typedef struct _EXCEPTION_RECORD64 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;
//
// Typedef for pointer returned by exception_info()
//
typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
// end_wdm
void
RtlUnwind (
    PVOID TargetFrame,
    PVOID TargetIp,
    PEXCEPTION_RECORD ExceptionRecord,
    PVOID ReturnValue
    );
# 6421 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef PVOID PSID;
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//
// begin_wdm
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////
// begin_wdm
//
//  The following are masks for the predefined standard access types
//
static const int DELETE = (0x00010000L);
static const int READ_CONTROL = (0x00020000L);
static const int WRITE_DAC = (0x00040000L);
static const int WRITE_OWNER = (0x00080000L);
static const int SYNCHRONIZE = (0x00100000L);
static const int STANDARD_RIGHTS_REQUIRED = (0x000F0000L);
static const int STANDARD_RIGHTS_READ = (READ_CONTROL);
static const int STANDARD_RIGHTS_WRITE = (READ_CONTROL);
static const int STANDARD_RIGHTS_EXECUTE = (READ_CONTROL);
static const int STANDARD_RIGHTS_ALL = (0x001F0000L);
static const int SPECIFIC_RIGHTS_ALL = (0x0000FFFFL);
//
// AccessSystemAcl access type
//
static const int ACCESS_SYSTEM_SECURITY = (0x01000000L);
//
// MaximumAllowed access type
//
static const int MAXIMUM_ALLOWED = (0x02000000L);
//
//  These are the generic rights.
//
static const int GENERIC_READ = (0x80000000L);
static const int GENERIC_WRITE = (0x40000000L);
static const int GENERIC_EXECUTE = (0x20000000L);
static const int GENERIC_ALL = (0x10000000L);
//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//
typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack4.h
Abstract:
    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 6541 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 6550 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//
// begin_ntifs
typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
typedef struct _SID {
   BYTE Revision;
   BYTE SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   DWORD SubAuthority[1];
} SID, *PISID;
static const int SID_REVISION = (1);
static const int SID_MAX_SUB_AUTHORITIES = (15);
static const int SID_RECOMMENDED_SUB_AUTHORITIES = (1);
                                                // in a future release.
static const int SECURITY_MAX_SID_SIZE = (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)));
typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel
} SID_NAME_USE, *PSID_NAME_USE;
typedef struct _SID_AND_ATTRIBUTES {
    PSID Sid;
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;
static const int SID_HASH_SIZE = 32;
typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;
typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
static const int SECURITY_NULL_SID_AUTHORITY = {0,0,0,0,0,0};
static const int SECURITY_WORLD_SID_AUTHORITY = {0,0,0,0,0,1};
static const int SECURITY_LOCAL_SID_AUTHORITY = {0,0,0,0,0,2};
static const int SECURITY_CREATOR_SID_AUTHORITY = {0,0,0,0,0,3};
static const int SECURITY_NON_UNIQUE_AUTHORITY = {0,0,0,0,0,4};
static const int SECURITY_RESOURCE_MANAGER_AUTHORITY = {0,0,0,0,0,9};
static const int SECURITY_NULL_RID = (0x00000000L);
static const int SECURITY_WORLD_RID = (0x00000000L);
static const int SECURITY_LOCAL_RID = (0x00000000L);
static const int SECURITY_LOCAL_LOGON_RID = (0x00000001L);
static const int SECURITY_CREATOR_OWNER_RID = (0x00000000L);
static const int SECURITY_CREATOR_GROUP_RID = (0x00000001L);
static const int SECURITY_CREATOR_OWNER_SERVER_RID = (0x00000002L);
static const int SECURITY_CREATOR_GROUP_SERVER_RID = (0x00000003L);
static const int SECURITY_CREATOR_OWNER_RIGHTS_RID = (0x00000004L);
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// NT well-known SIDs                                                        //
//                                                                           //
//     NT Authority            S-1-5                                         //
//     Dialup                  S-1-5-1                                       //
//                                                                           //
//     Network                 S-1-5-2                                       //
//     Batch                   S-1-5-3                                       //
//     Interactive             S-1-5-4                                       //
//     (Logon IDs)             S-1-5-5-X-Y                                   //
//     Service                 S-1-5-6                                       //
//     AnonymousLogon          S-1-5-7       (aka null logon session)        //
//     Proxy                   S-1-5-8                                       //
//     Enterprise DC (EDC)     S-1-5-9       (aka domain controller account) //
//     Self                    S-1-5-10      (self RID)                      //
//     Authenticated User      S-1-5-11      (Authenticated user somewhere)  //
//     Restricted Code         S-1-5-12      (Running restricted code)       //
//     Terminal Server         S-1-5-13      (Running on Terminal Server)    //
//     Remote Logon            S-1-5-14      (Remote Interactive Logon)      //
//     This Organization       S-1-5-15                                      //
//                                                                           //
//     IUser                   S-1-5-17
//     Local System            S-1-5-18                                      //
//     Local Service           S-1-5-19                                      //
//     Network Service         S-1-5-20                                      //
//                                                                           //
//     (NT non-unique IDs)     S-1-5-0x15-... (NT Domain Sids)               //
//                                                                           //
//     (Built-in domain)       S-1-5-0x20                                    //
//                                                                           //
//     (Security Package IDs)  S-1-5-0x40                                    //
//     NTLM Authentication     S-1-5-0x40-10                                 //
//     SChannel Authentication S-1-5-0x40-14                                 //
//     Digest Authentication   S-1-5-0x40-21                                 //
//                                                                           //
//     Other Organization      S-1-5-1000    (>=1000 can not be filtered)    //
//                                                                           //
//                                                                           //
// NOTE: the relative identifier values (RIDs) determine which security      //
//       boundaries the SID is allowed to cross.  Before adding new RIDs,    //
//       a determination needs to be made regarding which range they should  //
//       be added to in order to ensure proper "SID filtering"               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static const int SECURITY_NT_AUTHORITY = {0,0,0,0,0,5};
static const int SECURITY_DIALUP_RID = (0x00000001L);
static const int SECURITY_NETWORK_RID = (0x00000002L);
static const int SECURITY_BATCH_RID = (0x00000003L);
static const int SECURITY_INTERACTIVE_RID = (0x00000004L);
static const int SECURITY_LOGON_IDS_RID = (0x00000005L);
static const int SECURITY_LOGON_IDS_RID_COUNT = (3L);
static const int SECURITY_SERVICE_RID = (0x00000006L);
static const int SECURITY_ANONYMOUS_LOGON_RID = (0x00000007L);
static const int SECURITY_PROXY_RID = (0x00000008L);
static const int SECURITY_ENTERPRISE_CONTROLLERS_RID = (0x00000009L);
static const int SECURITY_SERVER_LOGON_RID = SECURITY_ENTERPRISE_CONTROLLERS_RID;
static const int SECURITY_PRINCIPAL_SELF_RID = (0x0000000AL);
static const int SECURITY_AUTHENTICATED_USER_RID = (0x0000000BL);
static const int SECURITY_RESTRICTED_CODE_RID = (0x0000000CL);
static const int SECURITY_TERMINAL_SERVER_RID = (0x0000000DL);
static const int SECURITY_REMOTE_LOGON_RID = (0x0000000EL);
static const int SECURITY_THIS_ORGANIZATION_RID = (0x0000000FL);
static const int SECURITY_IUSER_RID = (0x00000011L);
static const int SECURITY_LOCAL_SYSTEM_RID = (0x00000012L);
static const int SECURITY_LOCAL_SERVICE_RID = (0x00000013L);
static const int SECURITY_NETWORK_SERVICE_RID = (0x00000014L);
static const int SECURITY_NT_NON_UNIQUE = (0x00000015L);
static const int SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT = (3L);
static const int SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID = (0x00000016L);
static const int SECURITY_BUILTIN_DOMAIN_RID = (0x00000020L);
static const int SECURITY_WRITE_RESTRICTED_CODE_RID = (0x00000021L);
static const int SECURITY_PACKAGE_BASE_RID = (0x00000040L);
static const int SECURITY_PACKAGE_RID_COUNT = (2L);
static const int SECURITY_PACKAGE_NTLM_RID = (0x0000000AL);
static const int SECURITY_PACKAGE_SCHANNEL_RID = (0x0000000EL);
static const int SECURITY_PACKAGE_DIGEST_RID = (0x00000015L);
static const int SECURITY_CRED_TYPE_BASE_RID = (0x00000041L);
static const int SECURITY_CRED_TYPE_RID_COUNT = (2L);
static const int SECURITY_CRED_TYPE_THIS_ORG_CERT_RID = (0x00000001L);
static const int SECURITY_MIN_BASE_RID = (0x00000050L);
static const int SECURITY_SERVICE_ID_BASE_RID = (0x00000050L);
static const int SECURITY_SERVICE_ID_RID_COUNT = (6L);
static const int SECURITY_RESERVED_ID_BASE_RID = (0x00000051L);
static const int SECURITY_APPPOOL_ID_BASE_RID = (0x00000052L);
static const int SECURITY_APPPOOL_ID_RID_COUNT = (6L);
static const int SECURITY_VIRTUALSERVER_ID_BASE_RID = (0x00000053L);
static const int SECURITY_VIRTUALSERVER_ID_RID_COUNT = (6L);
static const int SECURITY_USERMODEDRIVERHOST_ID_BASE_RID = (0x00000054L);
static const int SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT = (6L);
static const int SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID = (0x00000055L);
static const int SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT = (6L);
static const int SECURITY_WMIHOST_ID_BASE_RID = (0x00000056L);
static const int SECURITY_WMIHOST_ID_RID_COUNT = (6L);
static const int SECURITY_TASK_ID_BASE_RID = (0x00000057L);
static const int SECURITY_NFS_ID_BASE_RID = (0x00000058L);
static const int SECURITY_COM_ID_BASE_RID = (0x00000059L);
static const int SECURITY_VIRTUALACCOUNT_ID_RID_COUNT = (6L);
static const int SECURITY_MAX_BASE_RID = (0x0000006FL);
static const int SECURITY_MAX_ALWAYS_FILTERED = (0x000003E7L);
static const int SECURITY_MIN_NEVER_FILTERED = (0x000003E8L);
static const int SECURITY_OTHER_ORGANIZATION_RID = (0x000003E8L);
//
//Service SID type RIDs are in the range 0x50- 0x6F.  Therefore, we are giving  the next available RID to Windows Mobile team.
//
static const int SECURITY_WINDOWSMOBILE_ID_BASE_RID = (0x00000070L);
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
static const int DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS = (0x000001F2L);
static const int FOREST_USER_RID_MAX = (0x000001F3L);
// Well-known users ...
static const int DOMAIN_USER_RID_ADMIN = (0x000001F4L);
static const int DOMAIN_USER_RID_GUEST = (0x000001F5L);
static const int DOMAIN_USER_RID_KRBTGT = (0x000001F6L);
static const int DOMAIN_USER_RID_MAX = (0x000003E7L);
// well-known groups ...
static const int DOMAIN_GROUP_RID_ADMINS = (0x00000200L);
static const int DOMAIN_GROUP_RID_USERS = (0x00000201L);
static const int DOMAIN_GROUP_RID_GUESTS = (0x00000202L);
static const int DOMAIN_GROUP_RID_COMPUTERS = (0x00000203L);
static const int DOMAIN_GROUP_RID_CONTROLLERS = (0x00000204L);
static const int DOMAIN_GROUP_RID_CERT_ADMINS = (0x00000205L);
static const int DOMAIN_GROUP_RID_SCHEMA_ADMINS = (0x00000206L);
static const int DOMAIN_GROUP_RID_ENTERPRISE_ADMINS = (0x00000207L);
static const int DOMAIN_GROUP_RID_POLICY_ADMINS = (0x00000208L);
static const int DOMAIN_GROUP_RID_READONLY_CONTROLLERS = (0x00000209L);
// well-known aliases ...
static const int DOMAIN_ALIAS_RID_ADMINS = (0x00000220L);
static const int DOMAIN_ALIAS_RID_USERS = (0x00000221L);
static const int DOMAIN_ALIAS_RID_GUESTS = (0x00000222L);
static const int DOMAIN_ALIAS_RID_POWER_USERS = (0x00000223L);
static const int DOMAIN_ALIAS_RID_ACCOUNT_OPS = (0x00000224L);
static const int DOMAIN_ALIAS_RID_SYSTEM_OPS = (0x00000225L);
static const int DOMAIN_ALIAS_RID_PRINT_OPS = (0x00000226L);
static const int DOMAIN_ALIAS_RID_BACKUP_OPS = (0x00000227L);
static const int DOMAIN_ALIAS_RID_REPLICATOR = (0x00000228L);
static const int DOMAIN_ALIAS_RID_RAS_SERVERS = (0x00000229L);
static const int DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = (0x0000022AL);
static const int DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS = (0x0000022BL);
static const int DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS = (0x0000022CL);
static const int DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = (0x0000022DL);
static const int DOMAIN_ALIAS_RID_MONITORING_USERS = (0x0000022EL);
static const int DOMAIN_ALIAS_RID_LOGGING_USERS = (0x0000022FL);
static const int DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS = (0x00000230L);
static const int DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS = (0x00000231L);
static const int DOMAIN_ALIAS_RID_DCOM_USERS = (0x00000232L);
static const int DOMAIN_ALIAS_RID_IUSERS = (0x00000238L);
static const int DOMAIN_ALIAS_RID_CRYPTO_OPERATORS = (0x00000239L);
static const int DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP = (0x0000023BL);
static const int DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = (0x0000023CL);
static const int DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP = (0x0000023DL);
static const int DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP = (0x0000023EL);
static const int SECURITY_MANDATORY_LABEL_AUTHORITY = {0,0,0,0,0,16};
static const int SECURITY_MANDATORY_UNTRUSTED_RID = (0x00000000L);
static const int SECURITY_MANDATORY_LOW_RID = (0x00001000L);
static const int SECURITY_MANDATORY_MEDIUM_RID = (0x00002000L);
static const int SECURITY_MANDATORY_MEDIUM_PLUS_RID = (SECURITY_MANDATORY_MEDIUM_RID + 0x100);
static const int SECURITY_MANDATORY_HIGH_RID = (0x00003000L);
static const int SECURITY_MANDATORY_SYSTEM_RID = (0x00004000L);
static const int SECURITY_MANDATORY_PROTECTED_PROCESS_RID = (0x00005000L);
//
// SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
// can be set by a usermode caller.
//
static const int SECURITY_MANDATORY_MAXIMUM_USER_RID = SECURITY_MANDATORY_SYSTEM_RID;
static const int MANDATORY_LEVEL_TO_MANDATORY_RID(IL) = (IL * 0x1000);
//
// Well known SID definitions for lookup.
//
typedef enum {
    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
} WELL_KNOWN_SID_TYPE;
//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3e7 = 999)
//
static const int SYSTEM_LUID = { 0x3e7, 0x0 };
static const int ANONYMOUS_LOGON_LUID = { 0x3e6, 0x0 };
static const int LOCALSERVICE_LUID = { 0x3e5, 0x0 };
static const int NETWORKSERVICE_LUID = { 0x3e4, 0x0 };
static const int IUSER_LUID = { 0x3e3, 0x0 };
// end_ntifs
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
// Group attributes
//
static const int SE_GROUP_MANDATORY = (0x00000001L);
static const int SE_GROUP_ENABLED_BY_DEFAULT = (0x00000002L);
static const int SE_GROUP_ENABLED = (0x00000004L);
static const int SE_GROUP_OWNER = (0x00000008L);
static const int SE_GROUP_USE_FOR_DENY_ONLY = (0x00000010L);
static const int SE_GROUP_INTEGRITY = (0x00000020L);
static const int SE_GROUP_INTEGRITY_ENABLED = (0x00000040L);
static const int SE_GROUP_LOGON_ID = (0xC0000000L);
static const int SE_GROUP_RESOURCE = (0x20000000L);
static const int SE_GROUP_VALID_ATTRIBUTES = (SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED | SE_GROUP_OWNER | SE_GROUP_USE_FOR_DENY_ONLY | SE_GROUP_LOGON_ID | SE_GROUP_RESOURCE | SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED);
# 7039 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// User attributes
//
// (None yet defined.)
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//
// begin_wdm
// This is the *current* ACL revision
static const int ACL_REVISION = (2);
static const int ACL_REVISION_DS = (4);
// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated
static const int ACL_REVISION1 = (1);
static const int MIN_ACL_REVISION = ACL_REVISION2;
static const int ACL_REVISION2 = (2);
static const int ACL_REVISION3 = (3);
static const int ACL_REVISION4 = (4);
static const int MAX_ACL_REVISION = ACL_REVISION4;
typedef struct _ACL {
    BYTE AclRevision;
    BYTE Sbz1;
    WORD AclSize;
    WORD AceCount;
    WORD Sbz2;
} ACL;
typedef ACL *PACL;
// end_wdm
// begin_ntifs
//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.
typedef struct _ACE_HEADER {
    BYTE AceType;
    BYTE AceFlags;
    WORD AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;
//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//
static const int ACCESS_MIN_MS_ACE_TYPE = (0x0);
static const int ACCESS_ALLOWED_ACE_TYPE = (0x0);
static const int ACCESS_DENIED_ACE_TYPE = (0x1);
static const int SYSTEM_AUDIT_ACE_TYPE = (0x2);
static const int SYSTEM_ALARM_ACE_TYPE = (0x3);
static const int ACCESS_MAX_MS_V2_ACE_TYPE = (0x3);
static const int ACCESS_ALLOWED_COMPOUND_ACE_TYPE = (0x4);
static const int ACCESS_MAX_MS_V3_ACE_TYPE = (0x4);
static const int ACCESS_MIN_MS_OBJECT_ACE_TYPE = (0x5);
static const int ACCESS_ALLOWED_OBJECT_ACE_TYPE = (0x5);
static const int ACCESS_DENIED_OBJECT_ACE_TYPE = (0x6);
static const int SYSTEM_AUDIT_OBJECT_ACE_TYPE = (0x7);
static const int SYSTEM_ALARM_OBJECT_ACE_TYPE = (0x8);
static const int ACCESS_MAX_MS_OBJECT_ACE_TYPE = (0x8);
static const int ACCESS_MAX_MS_V4_ACE_TYPE = (0x8);
static const int ACCESS_MAX_MS_ACE_TYPE = (0x8);
static const int ACCESS_ALLOWED_CALLBACK_ACE_TYPE = (0x9);
static const int ACCESS_DENIED_CALLBACK_ACE_TYPE = (0xA);
static const int ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE = (0xB);
static const int ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE = (0xC);
static const int SYSTEM_AUDIT_CALLBACK_ACE_TYPE = (0xD);
static const int SYSTEM_ALARM_CALLBACK_ACE_TYPE = (0xE);
static const int SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE = (0xF);
static const int SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE = (0x10);
static const int SYSTEM_MANDATORY_LABEL_ACE_TYPE = (0x11);
static const int ACCESS_MAX_MS_V5_ACE_TYPE = (0x11);
//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//
static const int OBJECT_INHERIT_ACE = (0x1);
static const int CONTAINER_INHERIT_ACE = (0x2);
static const int NO_PROPAGATE_INHERIT_ACE = (0x4);
static const int INHERIT_ONLY_ACE = (0x8);
static const int INHERITED_ACE = (0x10);
static const int VALID_INHERIT_FLAGS = (0x1F);
//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//
//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//
static const int SUCCESSFUL_ACCESS_ACE_FLAG = (0x40);
static const int FAILED_ACCESS_ACE_FLAG = (0x80);
//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//
//  The following are the four predefined ACE types.
//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.
typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;
typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;
typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;
typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;
typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;
typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;
static const int SYSTEM_MANDATORY_LABEL_NO_WRITE_UP = 0x1;
static const int SYSTEM_MANDATORY_LABEL_NO_READ_UP = 0x2;
static const int SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP = 0x4;
static const int SYSTEM_MANDATORY_LABEL_VALID_MASK = (SYSTEM_MANDATORY_LABEL_NO_WRITE_UP | SYSTEM_MANDATORY_LABEL_NO_READ_UP | SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP);
// end_ntifs
typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;
typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;
typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;
typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;
//
// Callback ace support in post Win2000.
// Resource managers can put their own data after Sidstart + Length of the sid
//
typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;
typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;
typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;
typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;
typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;
typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;
//
// Currently define Flags for "OBJECT" ACE types.
//
static const int ACE_OBJECT_TYPE_PRESENT = 0x1;
static const int ACE_INHERITED_OBJECT_TYPE_PRESENT = 0x2;
//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//
typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;
//
//  This record is returned/sent if the user is requesting/setting the
//  AclRevisionInformation
//
typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;
//
//  This record is returned if the user is requesting AclSizeInformation
//
typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//
// begin_wdm
//
// Current security descriptor revision value
//
static const int SECURITY_DESCRIPTOR_REVISION = (1);
static const int SECURITY_DESCRIPTOR_REVISION1 = (1);
// end_wdm
// begin_ntifs
static const int SECURITY_DESCRIPTOR_MIN_LENGTH = (sizeof(SECURITY_DESCRIPTOR));
typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;
static const int SE_OWNER_DEFAULTED = (0x0001);
static const int SE_GROUP_DEFAULTED = (0x0002);
static const int SE_DACL_PRESENT = (0x0004);
static const int SE_DACL_DEFAULTED = (0x0008);
static const int SE_SACL_PRESENT = (0x0010);
static const int SE_SACL_DEFAULTED = (0x0020);
static const int SE_DACL_AUTO_INHERIT_REQ = (0x0100);
static const int SE_SACL_AUTO_INHERIT_REQ = (0x0200);
static const int SE_DACL_AUTO_INHERITED = (0x0400);
static const int SE_SACL_AUTO_INHERITED = (0x0800);
static const int SE_DACL_PROTECTED = (0x1000);
static const int SE_SACL_PROTECTED = (0x2000);
static const int SE_RM_CONTROL_VALID = (0x4000);
static const int SE_SELF_RELATIVE = (0x8000);
//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//
typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;
typedef struct _SECURITY_DESCRIPTOR {
   BYTE Revision;
   BYTE Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;
   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;
// end_ntifs
// Where:
//
//     Revision - Contains the revision level of the security
//         descriptor.  This allows this structure to be passed between
//         systems or stored on disk even though it is expected to
//         change in the future.
//
//     Control - A set of flags which qualify the meaning of the
//         security descriptor or individual fields of the security
//         descriptor.
//
//     Owner - is a pointer to an SID representing an object's owner.
//         If this field is null, then no owner SID is present in the
//         security descriptor.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Group - is a pointer to an SID representing an object's primary
//         group.  If this field is null, then no primary group SID is
//         present in the security descriptor.  If the security descriptor
//         is in self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Sacl - is a pointer to a system ACL.  This field value is only
//         valid if the DaclPresent control flag is set.  If the
//         SaclPresent flag is set and this field is null, then a null
//         ACL  is specified.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the ACL, rather than a pointer.
//
//     Dacl - is a pointer to a discretionary ACL.  This field value is
//         only valid if the DaclPresent control flag is set.  If the
//         DaclPresent flag is set and this field is null, then a null
//         ACL (unconditionally granting access) is specified.  If the
//         security descriptor is in self-relative form, then this field
//         contains an offset to the ACL, rather than a pointer.
//
////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Object Type list for AccessCheckByType               //
//                                                                    //
////////////////////////////////////////////////////////////////////////
typedef struct _OBJECT_TYPE_LIST {
    WORD Level;
    WORD Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;
//
// DS values for Level
//
static const int ACCESS_OBJECT_GUID = 0;
static const int ACCESS_PROPERTY_SET_GUID = 1;
static const int ACCESS_PROPERTY_GUID = 2;
static const int ACCESS_MAX_LEVEL = 4;
//
// Parameters to NtAccessCheckByTypeAndAditAlarm
//
typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;
static const int AUDIT_ALLOW_NO_PRIVILEGE = 0x1;
//
// DS values for Source and ObjectTypeName
//
static const char ACCESS_DS_SOURCE_A = "DS";
static const char ACCESS_DS_SOURCE_W = L"DS";
static const char ACCESS_DS_OBJECT_TYPE_NAME_A = "Directory Service Object";
static const char ACCESS_DS_OBJECT_TYPE_NAME_W = L"Directory Service Object";
////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
// end_ntifs
// begin_wdm
//
// Privilege attributes
//
static const int SE_PRIVILEGE_ENABLED_BY_DEFAULT = (0x00000001L);
static const int SE_PRIVILEGE_ENABLED = (0x00000002L);
static const int SE_PRIVILEGE_REMOVED = (0X00000004L);
static const int SE_PRIVILEGE_USED_FOR_ACCESS = (0x80000000L);
static const int SE_PRIVILEGE_VALID_ATTRIBUTES = (SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_REMOVED | SE_PRIVILEGE_USED_FOR_ACCESS);
//
// Privilege Set Control flags
//
static const int PRIVILEGE_SET_ALL_NECESSARY = (1);
//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//
typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;
//
// Values for different access granted\denied reasons:
// AccessReasonAceN = AccessReasonAce + N.
// AccessReasonPrivilegeN = AccessReasonPrivilege + N.
//
static const int ACCESS_REASON_TYPE_MASK = 0xffff0000;
static const int ACCESS_REASON_DATA_MASK = 0x0000ffff;
typedef enum _ACCESS_REASON_TYPE{
    AccessReasonNone = 0x00000000, // Indicate no reason for the bit. The bit may not be checked, or just no known reason.
    //
    // The lowest 2 bytes store the index of the ACE that grant/deny this bit.
    // If the corresponding access maskt is zero, then it is deny ACE; otherwise,
    // it is allow ACE.
    //
    AccessReasonAllowedAce = 0x00010000, // Granted a permission.
    AccessReasonDeniedAce = 0x00020000, // Denied a permission.
    AccessReasonAllowedParentAce = 0x00030000, // Granted a permission from parent ACE
    AccessReasonDeniedParentAce = 0x00040000, // Denied a permission from parent ACE
    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,
    AccessReasonIntegrityLevel = 0x00300000,
    AccessReasonOwnership = 0x00400000,
    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,
    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000 // this access bit is not granted by any ACE.
} ACCESS_REASON_TYPE;
 //
// Structure to hold access denied\granted reason for every bit of ACCESS_MASK.
// There are 32-bits in ACCESS_MASK and only 27-bits are actually valid on
// return from AccessCheck because MAXIMUM_ALLOWED, GENERIC_READ,
// GENERIC_WRITE, GENERIC_EXECUTE, and GENERIC_ALL are never returned.
//
// The content in Data fields depends on the Access Reason, for example,
// if the reason is AccessReasonAce, the Data will be the ACE ID.
// If there are more than one reason (more than one bit is set), the array size
// of the Data is equal to the number of bits set (or number of reasons).
// The Data could be null for a particular reason.
//
typedef DWORD ACCESS_REASON;
typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;
/*
The following data structures are defined to consolidate various falvors of
access check functions. In particular for Windows 7, the new access check
function will enable security attribute check, plus returning the reason
for a access check result.
The new access check function based on these data structures will
form the foundation to reimplement other flavors of access check
functions.
*/
# 7765 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Structure to hold pointer to security descriptor and its unique id, which
// can be used for caching access check results.
// (NOTE NOTE) The cache key can be constructed by SecurityDescriptorId, Token and
// PrincipalSelfSid. Watch how GenericMapping affects the cache results.
//
static const int SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE = 0x00000001;
static const int SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE = 0x00000002;
static const int SE_SECURITY_DESCRIPTOR_VALID_FLAGS = 0x00000003;
typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;
typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid; // Need to watch how this field affects the cache.
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;
typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount; // Indicate the array size of GrantedAccess and AccessStatus, it only can be either 1 or ObjectTypeListCount.
    PACCESS_MASK GrantedAccess;
    PDWORD AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;
////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////
static const int SE_CREATE_TOKEN_NAME = TEXT("SeCreateTokenPrivilege");
static const int SE_ASSIGNPRIMARYTOKEN_NAME = TEXT("SeAssignPrimaryTokenPrivilege");
static const int SE_LOCK_MEMORY_NAME = TEXT("SeLockMemoryPrivilege");
static const int SE_INCREASE_QUOTA_NAME = TEXT("SeIncreaseQuotaPrivilege");
static const int SE_UNSOLICITED_INPUT_NAME = TEXT("SeUnsolicitedInputPrivilege");
static const int SE_MACHINE_ACCOUNT_NAME = TEXT("SeMachineAccountPrivilege");
static const int SE_TCB_NAME = TEXT("SeTcbPrivilege");
static const int SE_SECURITY_NAME = TEXT("SeSecurityPrivilege");
static const int SE_TAKE_OWNERSHIP_NAME = TEXT("SeTakeOwnershipPrivilege");
static const int SE_LOAD_DRIVER_NAME = TEXT("SeLoadDriverPrivilege");
static const int SE_SYSTEM_PROFILE_NAME = TEXT("SeSystemProfilePrivilege");
static const int SE_SYSTEMTIME_NAME = TEXT("SeSystemtimePrivilege");
static const int SE_PROF_SINGLE_PROCESS_NAME = TEXT("SeProfileSingleProcessPrivilege");
static const int SE_INC_BASE_PRIORITY_NAME = TEXT("SeIncreaseBasePriorityPrivilege");
static const int SE_CREATE_PAGEFILE_NAME = TEXT("SeCreatePagefilePrivilege");
static const int SE_CREATE_PERMANENT_NAME = TEXT("SeCreatePermanentPrivilege");
static const int SE_BACKUP_NAME = TEXT("SeBackupPrivilege");
static const int SE_RESTORE_NAME = TEXT("SeRestorePrivilege");
static const int SE_SHUTDOWN_NAME = TEXT("SeShutdownPrivilege");
static const int SE_DEBUG_NAME = TEXT("SeDebugPrivilege");
static const int SE_AUDIT_NAME = TEXT("SeAuditPrivilege");
static const int SE_SYSTEM_ENVIRONMENT_NAME = TEXT("SeSystemEnvironmentPrivilege");
static const int SE_CHANGE_NOTIFY_NAME = TEXT("SeChangeNotifyPrivilege");
static const int SE_REMOTE_SHUTDOWN_NAME = TEXT("SeRemoteShutdownPrivilege");
static const int SE_UNDOCK_NAME = TEXT("SeUndockPrivilege");
static const int SE_SYNC_AGENT_NAME = TEXT("SeSyncAgentPrivilege");
static const int SE_ENABLE_DELEGATION_NAME = TEXT("SeEnableDelegationPrivilege");
static const int SE_MANAGE_VOLUME_NAME = TEXT("SeManageVolumePrivilege");
static const int SE_IMPERSONATE_NAME = TEXT("SeImpersonatePrivilege");
static const int SE_CREATE_GLOBAL_NAME = TEXT("SeCreateGlobalPrivilege");
static const int SE_TRUSTED_CREDMAN_ACCESS_NAME = TEXT("SeTrustedCredManAccessPrivilege");
static const int SE_RELABEL_NAME = TEXT("SeRelabelPrivilege");
static const int SE_INC_WORKING_SET_NAME = TEXT("SeIncreaseWorkingSetPrivilege");
static const int SE_TIME_ZONE_NAME = TEXT("SeTimeZonePrivilege");
static const int SE_CREATE_SYMBOLIC_LINK_NAME = TEXT("SeCreateSymbolicLinkPrivilege");
////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////
// begin_wdm
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//
typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;
static const int SECURITY_MAX_IMPERSONATION_LEVEL = SecurityDelegation;
static const int SECURITY_MIN_IMPERSONATION_LEVEL = SecurityAnonymous;
static const int DEFAULT_IMPERSONATION_LEVEL = SecurityImpersonation;
static const int VALID_IMPERSONATION_LEVEL(L) = (((L) >= SECURITY_MIN_IMPERSONATION_LEVEL) && ((L) <= SECURITY_MAX_IMPERSONATION_LEVEL));
////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////
//
// Token Specific Access Rights.
//
static const int TOKEN_ASSIGN_PRIMARY = (0x0001);
static const int TOKEN_DUPLICATE = (0x0002);
static const int TOKEN_IMPERSONATE = (0x0004);
static const int TOKEN_QUERY = (0x0008);
static const int TOKEN_QUERY_SOURCE = (0x0010);
static const int TOKEN_ADJUST_PRIVILEGES = (0x0020);
static const int TOKEN_ADJUST_GROUPS = (0x0040);
static const int TOKEN_ADJUST_DEFAULT = (0x0080);
static const int TOKEN_ADJUST_SESSIONID = (0x0100);
static const int TOKEN_ALL_ACCESS_P = (STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT );
# 7912 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int TOKEN_ALL_ACCESS = (TOKEN_ALL_ACCESS_P | TOKEN_ADJUST_SESSIONID );
static const int TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY);
static const int TOKEN_WRITE = (STANDARD_RIGHTS_WRITE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT);
static const int TOKEN_EXECUTE = (STANDARD_RIGHTS_EXECUTE);
//
//
// Token Types
//
typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;
//
// Token elevation values describe the relative strength of a given token.
// A full token is a token with all groups and privileges to which the principal
// is authorized.  A limited token is one with some groups or privileges removed.
//
typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;
//
// Token Information Classes.
//
typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    MaxTokenInfoClass // MaxTokenInfoClass should always be the last enum
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;
//
// Token information class structures
//
typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;
typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;
    SID_AND_ATTRIBUTES Groups[1];
} TOKEN_GROUPS, *PTOKEN_GROUPS;
typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;
typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;
typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;
typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;
typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;
typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;
typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;
typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;
static const int TOKEN_MANDATORY_POLICY_OFF = 0x0;
static const int TOKEN_MANDATORY_POLICY_NO_WRITE_UP = 0x1;
static const int TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN = 0x2;
static const int TOKEN_MANDATORY_POLICY_VALID_MASK = (TOKEN_MANDATORY_POLICY_NO_WRITE_UP | TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN);
typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;
typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;
//
// Valid bits for each TOKEN_AUDIT_POLICY policy mask field.
//
static const int POLICY_AUDIT_SUBCATEGORY_COUNT = (53);
typedef struct _TOKEN_AUDIT_POLICY {
    BYTE PerUserPolicy[(((53)) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;
static const int TOKEN_SOURCE_LENGTH = 8;
typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;
typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;
typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;
typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;
typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;
//
// Security Tracking Mode
//
static const int SECURITY_DYNAMIC_TRACKING = (TRUE);
static const int SECURITY_STATIC_TRACKING = (FALSE);
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;
//
// Quality Of Service
//
typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;
//
// Used to represent information related to a thread impersonation
//
typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;
static const int DISABLE_MAX_PRIVILEGE = 0x1;
static const int SANDBOX_INERT = 0x2;
static const int LUA_TOKEN = 0x4;
static const int WRITE_RESTRICTED = 0x8;
typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;
static const int OWNER_SECURITY_INFORMATION = (0x00000001L);
static const int GROUP_SECURITY_INFORMATION = (0x00000002L);
static const int DACL_SECURITY_INFORMATION = (0x00000004L);
static const int SACL_SECURITY_INFORMATION = (0x00000008L);
static const int LABEL_SECURITY_INFORMATION = (0x00000010L);
static const int PROTECTED_DACL_SECURITY_INFORMATION = (0x80000000L);
static const int PROTECTED_SACL_SECURITY_INFORMATION = (0x40000000L);
static const int UNPROTECTED_DACL_SECURITY_INFORMATION = (0x20000000L);
static const int UNPROTECTED_SACL_SECURITY_INFORMATION = (0x10000000L);
static const int PROCESS_TERMINATE = (0x0001);
static const int PROCESS_CREATE_THREAD = (0x0002);
static const int PROCESS_SET_SESSIONID = (0x0004);
static const int PROCESS_VM_OPERATION = (0x0008);
static const int PROCESS_VM_READ = (0x0010);
static const int PROCESS_VM_WRITE = (0x0020);
static const int PROCESS_DUP_HANDLE = (0x0040);
static const int PROCESS_CREATE_PROCESS = (0x0080);
static const int PROCESS_SET_QUOTA = (0x0100);
static const int PROCESS_SET_INFORMATION = (0x0200);
static const int PROCESS_QUERY_INFORMATION = (0x0400);
static const int PROCESS_SUSPEND_RESUME = (0x0800);
static const int PROCESS_QUERY_LIMITED_INFORMATION = (0x1000);
static const int PROCESS_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF);
# 8209 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int MAXIMUM_PROC_PER_GROUP = 64;
static const int MAXIMUM_PROCESSORS = MAXIMUM_PROC_PER_GROUP;
static const int THREAD_TERMINATE = (0x0001);
static const int THREAD_SUSPEND_RESUME = (0x0002);
static const int THREAD_GET_CONTEXT = (0x0008);
static const int THREAD_SET_CONTEXT = (0x0010);
static const int THREAD_QUERY_INFORMATION = (0x0040);
static const int THREAD_SET_INFORMATION = (0x0020);
static const int THREAD_SET_THREAD_TOKEN = (0x0080);
static const int THREAD_IMPERSONATE = (0x0100);
static const int THREAD_DIRECT_IMPERSONATION = (0x0200);
// begin_wdm
static const int THREAD_SET_LIMITED_INFORMATION = (0x0400);
static const int THREAD_QUERY_LIMITED_INFORMATION = (0x0800);
static const int THREAD_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF);
static const int JOB_OBJECT_ASSIGN_PROCESS = (0x0001);
static const int JOB_OBJECT_SET_ATTRIBUTES = (0x0002);
static const int JOB_OBJECT_QUERY = (0x0004);
static const int JOB_OBJECT_TERMINATE = (0x0008);
static const int JOB_OBJECT_SET_SECURITY_ATTRIBUTES = (0x0010);
static const int JOB_OBJECT_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1F );
typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle; // Handle to job object to insert
    DWORD MemberLevel; // Level of this job in the set. Must be > 0. Can be sparse.
    DWORD Flags; // Unused. Must be zero
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;
static const int FLS_MAXIMUM_AVAILABLE = 128;
static const int TLS_MINIMUM_AVAILABLE = 64;
typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    PVOID FiberData;
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    DWORD FiberData;
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;
typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
# 8308 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
    DWORD64 FiberData;
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
static const int THREAD_BASE_PRIORITY_LOWRT = 15;
static const int THREAD_BASE_PRIORITY_MAX = 2;
static const int THREAD_BASE_PRIORITY_MIN = (-2);
static const int THREAD_BASE_PRIORITY_IDLE = (-15);
typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {
    DWORD UmsVersion;
        PVOID UmsContext;
        PVOID UmsCompletionList;
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES;
typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;
static const int QUOTA_LIMITS_HARDWS_MIN_ENABLE = 0x00000001;
static const int QUOTA_LIMITS_HARDWS_MIN_DISABLE = 0x00000002;
static const int QUOTA_LIMITS_HARDWS_MAX_ENABLE = 0x00000004;
static const int QUOTA_LIMITS_HARDWS_MAX_DISABLE = 0x00000008;
static const int QUOTA_LIMITS_USE_DEFAULT_LIMITS = 0x00000010;
typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0 : 25;
    } s;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;
typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit; // Limit expressed in pages
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit; // Limit expressed in pages
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;
typedef struct _IO_COUNTERS {
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
static const int MAX_HW_COUNTERS = 16;
static const int THREAD_PROFILING_FLAG_DISPATCH = 0x00000001;
typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;
typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;
typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;
//
// N.B. The JOBOBJECT_SECURITY_LIMIT_INFORMATION information class is no longer supported.
//
typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;
typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;
typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;
typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;
static const int JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0;
static const int JOB_OBJECT_POST_AT_END_OF_JOB = 1;
//
// Completion Port Messages for job objects
//
// These values are returned via the lpNumberOfBytesTransferred parameter
//
static const int JOB_OBJECT_MSG_END_OF_JOB_TIME = 1;
static const int JOB_OBJECT_MSG_END_OF_PROCESS_TIME = 2;
static const int JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT = 3;
static const int JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO = 4;
static const int JOB_OBJECT_MSG_NEW_PROCESS = 6;
static const int JOB_OBJECT_MSG_EXIT_PROCESS = 7;
static const int JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS = 8;
static const int JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT = 9;
static const int JOB_OBJECT_MSG_JOB_MEMORY_LIMIT = 10;
//
// Basic Limits
//
static const int JOB_OBJECT_LIMIT_WORKINGSET = 0x00000001;
static const int JOB_OBJECT_LIMIT_PROCESS_TIME = 0x00000002;
static const int JOB_OBJECT_LIMIT_JOB_TIME = 0x00000004;
static const int JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x00000008;
static const int JOB_OBJECT_LIMIT_AFFINITY = 0x00000010;
static const int JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x00000020;
static const int JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x00000040;
static const int JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x00000080;
//
// Extended Limits
//
static const int JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x00000100;
static const int JOB_OBJECT_LIMIT_JOB_MEMORY = 0x00000200;
static const int JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400;
static const int JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800;
static const int JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000;
static const int JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x00002000;
static const int JOB_OBJECT_LIMIT_SUBSET_AFFINITY = 0x00004000;
static const int JOB_OBJECT_LIMIT_RESERVED3 = 0x00008000;
static const int JOB_OBJECT_LIMIT_RESERVED4 = 0x00010000;
static const int JOB_OBJECT_LIMIT_RESERVED5 = 0x00020000;
static const int JOB_OBJECT_LIMIT_RESERVED6 = 0x00040000;
static const int JOB_OBJECT_LIMIT_VALID_FLAGS = 0x0007ffff;
static const int JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS = 0x000000ff;
static const int JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS = 0x00007fff;
static const int JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS = 0x0007ffff;
//
// UI restrictions for jobs
//
static const int JOB_OBJECT_UILIMIT_NONE = 0x00000000;
static const int JOB_OBJECT_UILIMIT_HANDLES = 0x00000001;
static const int JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x00000002;
static const int JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x00000004;
static const int JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008;
static const int JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x00000010;
static const int JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x00000020;
static const int JOB_OBJECT_UILIMIT_DESKTOP = 0x00000040;
static const int JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x00000080;
static const int JOB_OBJECT_UILIMIT_ALL = 0x000000FF;
static const int JOB_OBJECT_UI_VALID_FLAGS = 0x000000FF;
static const int JOB_OBJECT_SECURITY_NO_ADMIN = 0x00000001;
static const int JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002;
static const int JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x00000004;
static const int JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x00000008;
static const int JOB_OBJECT_SECURITY_VALID_FLAGS = 0x0000000f;
typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation, // deprecated
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    MaxJobObjectInfoClass
    } JOBOBJECTINFOCLASS;
//
static const int EVENT_MODIFY_STATE = 0x0002;
static const int EVENT_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3);
static const int MUTANT_QUERY_STATE = 0x0001;
static const int MUTANT_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE| MUTANT_QUERY_STATE);
static const int SEMAPHORE_MODIFY_STATE = 0x0002;
static const int SEMAPHORE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3);
//
// Timer Specific Access Rights.
//
static const int TIMER_QUERY_STATE = 0x0001;
static const int TIMER_MODIFY_STATE = 0x0002;
static const int TIMER_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE| TIMER_QUERY_STATE|TIMER_MODIFY_STATE);
static const int TIME_ZONE_ID_UNKNOWN = 0;
static const int TIME_ZONE_ID_STANDARD = 1;
static const int TIME_ZONE_ID_DAYLIGHT = 2;
typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;
static const int LTP_PC_SMT = 0x1;
typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;
static const int CACHE_FULLY_ASSOCIATIVE = 0xFF;
typedef struct _CACHE_DESCRIPTOR {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;
typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG Reserved[2];
    } u;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;
typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE Flags;
    BYTE Reserved[21];
    WORD GroupCount;
    GROUP_AFFINITY GroupMask[1];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;
typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;
typedef struct _CACHE_RELATIONSHIP {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;
typedef struct _PROCESSOR_GROUP_INFO {
    BYTE MaximumProcessorCount;
    BYTE ActiveProcessorCount;
    BYTE Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;
typedef struct _GROUP_RELATIONSHIP {
    WORD MaximumGroupCount;
    WORD ActiveGroupCount;
    BYTE Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;
 struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    } u;
};
typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
// end_wdm end_ntminiport
typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
static const int PROCESSOR_INTEL_386 = 386;
static const int PROCESSOR_INTEL_486 = 486;
static const int PROCESSOR_INTEL_PENTIUM = 586;
static const int PROCESSOR_INTEL_IA64 = 2200;
static const int PROCESSOR_AMD_X8664 = 8664;
static const int PROCESSOR_MIPS_R4000 = 4000;
static const int PROCESSOR_ALPHA_21064 = 21064;
static const int PROCESSOR_PPC_601 = 601;
static const int PROCESSOR_PPC_603 = 603;
static const int PROCESSOR_PPC_604 = 604;
static const int PROCESSOR_PPC_620 = 620;
static const int PROCESSOR_HITACHI_SH3 = 10003;
static const int PROCESSOR_HITACHI_SH3E = 10004;
static const int PROCESSOR_HITACHI_SH4 = 10005;
static const int PROCESSOR_MOTOROLA_821 = 821;
static const int PROCESSOR_SHx_SH3 = 103;
static const int PROCESSOR_SHx_SH4 = 104;
static const int PROCESSOR_STRONGARM = 2577;
static const int PROCESSOR_ARM720 = 1824;
static const int PROCESSOR_ARM820 = 2080;
static const int PROCESSOR_ARM920 = 2336;
static const int PROCESSOR_ARM_7TDMI = 70001;
static const int PROCESSOR_OPTIL = 0x494f;
static const int PROCESSOR_ARCHITECTURE_INTEL = 0;
static const int PROCESSOR_ARCHITECTURE_MIPS = 1;
static const int PROCESSOR_ARCHITECTURE_ALPHA = 2;
static const int PROCESSOR_ARCHITECTURE_PPC = 3;
static const int PROCESSOR_ARCHITECTURE_SHX = 4;
static const int PROCESSOR_ARCHITECTURE_ARM = 5;
static const int PROCESSOR_ARCHITECTURE_IA64 = 6;
static const int PROCESSOR_ARCHITECTURE_ALPHA64 = 7;
static const int PROCESSOR_ARCHITECTURE_MSIL = 8;
static const int PROCESSOR_ARCHITECTURE_AMD64 = 9;
static const int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 = 10;
static const int PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF;
static const int PF_FLOATING_POINT_PRECISION_ERRATA = 0;
static const int PF_FLOATING_POINT_EMULATED = 1;
static const int PF_COMPARE_EXCHANGE_DOUBLE = 2;
static const int PF_MMX_INSTRUCTIONS_AVAILABLE = 3;
static const int PF_PPC_MOVEMEM_64BIT_OK = 4;
static const int PF_ALPHA_BYTE_INSTRUCTIONS = 5;
static const int PF_XMMI_INSTRUCTIONS_AVAILABLE = 6;
static const int PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7;
static const int PF_RDTSC_INSTRUCTION_AVAILABLE = 8;
static const int PF_PAE_ENABLED = 9;
static const int PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10;
static const int PF_SSE_DAZ_MODE_AVAILABLE = 11;
static const int PF_NX_ENABLED = 12;
static const int PF_SSE3_INSTRUCTIONS_AVAILABLE = 13;
static const int PF_COMPARE_EXCHANGE128 = 14;
static const int PF_COMPARE64_EXCHANGE128 = 15;
static const int PF_CHANNELS_ENABLED = 16;
static const int PF_XSAVE_ENABLED = 17;
//
// Known extended CPU state feature IDs
//
static const int XSTATE_LEGACY_FLOATING_POINT = 0;
static const int XSTATE_LEGACY_SSE = 1;
static const int XSTATE_GSSE = 2;
static const int XSTATE_MASK_LEGACY_FLOATING_POINT = (1i64 << (XSTATE_LEGACY_FLOATING_POINT));
static const int XSTATE_MASK_LEGACY_SSE = (1i64 << (XSTATE_LEGACY_SSE));
static const int XSTATE_MASK_LEGACY = (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE);
static const int XSTATE_MASK_GSSE = (1i64 << (XSTATE_GSSE));
static const int MAXIMUM_XSTATE_FEATURES = 64;
//
// Extended processor state configuration
//
typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;
typedef struct _XSTATE_CONFIGURATION {
    // Mask of enabled features
    DWORD64 EnabledFeatures;
    // Total size of the save area
    DWORD Size;
    DWORD OptimizedSave : 1;
    // List of features (
    XSTATE_FEATURE Features[64];
} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;
typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;
typedef struct _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD AllocationProtect;
    DWORD __alignment1;
    ULONGLONG RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
    DWORD __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;
static const int SECTION_QUERY = 0x0001;
static const int SECTION_MAP_WRITE = 0x0002;
static const int SECTION_MAP_READ = 0x0004;
static const int SECTION_MAP_EXECUTE = 0x0008;
static const int SECTION_EXTEND_SIZE = 0x0010;
static const int SECTION_MAP_EXECUTE_EXPLICIT = 0x0020;
static const int SECTION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY| SECTION_MAP_WRITE | SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_EXTEND_SIZE);
static const int SESSION_QUERY_ACCESS = 0x0001;
static const int SESSION_MODIFY_ACCESS = 0x0002;
static const int SESSION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SESSION_QUERY_ACCESS | SESSION_MODIFY_ACCESS);
static const int PAGE_NOACCESS = 0x01;
static const int PAGE_READONLY = 0x02;
static const int PAGE_READWRITE = 0x04;
static const int PAGE_WRITECOPY = 0x08;
static const int PAGE_EXECUTE = 0x10;
static const int PAGE_EXECUTE_READ = 0x20;
static const int PAGE_EXECUTE_READWRITE = 0x40;
static const int PAGE_EXECUTE_WRITECOPY = 0x80;
static const int PAGE_GUARD = 0x100;
static const int PAGE_NOCACHE = 0x200;
static const int PAGE_WRITECOMBINE = 0x400;
static const int MEM_COMMIT = 0x1000;
static const int MEM_RESERVE = 0x2000;
static const int MEM_DECOMMIT = 0x4000;
static const int MEM_RELEASE = 0x8000;
static const int MEM_FREE = 0x10000;
static const int MEM_PRIVATE = 0x20000;
static const int MEM_MAPPED = 0x40000;
static const int MEM_RESET = 0x80000;
static const int MEM_TOP_DOWN = 0x100000;
static const int MEM_WRITE_WATCH = 0x200000;
static const int MEM_PHYSICAL = 0x400000;
static const int MEM_ROTATE = 0x800000;
static const int MEM_LARGE_PAGES = 0x20000000;
static const int MEM_4MB_PAGES = 0x80000000;
static const int SEC_FILE = 0x800000;
static const int SEC_IMAGE = 0x1000000;
static const int SEC_PROTECTED_IMAGE = 0x2000000;
static const int SEC_RESERVE = 0x4000000;
static const int SEC_COMMIT = 0x8000000;
static const int SEC_NOCACHE = 0x10000000;
static const int SEC_WRITECOMBINE = 0x40000000;
static const int SEC_LARGE_PAGES = 0x80000000;
static const int MEM_IMAGE = SEC_IMAGE;
static const int WRITE_WATCH_FLAG_RESET = 0x01;
//
// Define access rights to files and directories
//
//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//
static const int FILE_READ_DATA = ( 0x0001 );
static const int FILE_LIST_DIRECTORY = ( 0x0001 );
static const int FILE_WRITE_DATA = ( 0x0002 );
static const int FILE_ADD_FILE = ( 0x0002 );
static const int FILE_APPEND_DATA = ( 0x0004 );
static const int FILE_ADD_SUBDIRECTORY = ( 0x0004 );
static const int FILE_CREATE_PIPE_INSTANCE = ( 0x0004 );
static const int FILE_READ_EA = ( 0x0008 );
static const int FILE_WRITE_EA = ( 0x0010 );
static const int FILE_EXECUTE = ( 0x0020 );
static const int FILE_TRAVERSE = ( 0x0020 );
static const int FILE_DELETE_CHILD = ( 0x0040 );
static const int FILE_READ_ATTRIBUTES = ( 0x0080 );
static const int FILE_WRITE_ATTRIBUTES = ( 0x0100 );
static const int FILE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF);
static const int FILE_GENERIC_READ = (STANDARD_RIGHTS_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE);
static const int FILE_GENERIC_WRITE = (STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE);
static const int FILE_GENERIC_EXECUTE = (STANDARD_RIGHTS_EXECUTE | FILE_READ_ATTRIBUTES | FILE_EXECUTE | SYNCHRONIZE);
static const int FILE_SHARE_READ = 0x00000001;
static const int FILE_SHARE_WRITE = 0x00000002;
static const int FILE_SHARE_DELETE = 0x00000004;
static const int FILE_ATTRIBUTE_READONLY = 0x00000001;
static const int FILE_ATTRIBUTE_HIDDEN = 0x00000002;
static const int FILE_ATTRIBUTE_SYSTEM = 0x00000004;
static const int FILE_ATTRIBUTE_DIRECTORY = 0x00000010;
static const int FILE_ATTRIBUTE_ARCHIVE = 0x00000020;
static const int FILE_ATTRIBUTE_DEVICE = 0x00000040;
static const int FILE_ATTRIBUTE_NORMAL = 0x00000080;
static const int FILE_ATTRIBUTE_TEMPORARY = 0x00000100;
static const int FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200;
static const int FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400;
static const int FILE_ATTRIBUTE_COMPRESSED = 0x00000800;
static const int FILE_ATTRIBUTE_OFFLINE = 0x00001000;
static const int FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000;
static const int FILE_ATTRIBUTE_ENCRYPTED = 0x00004000;
static const int FILE_ATTRIBUTE_VIRTUAL = 0x00010000;
static const int FILE_NOTIFY_CHANGE_FILE_NAME = 0x00000001;
static const int FILE_NOTIFY_CHANGE_DIR_NAME = 0x00000002;
static const int FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x00000004;
static const int FILE_NOTIFY_CHANGE_SIZE = 0x00000008;
static const int FILE_NOTIFY_CHANGE_LAST_WRITE = 0x00000010;
static const int FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x00000020;
static const int FILE_NOTIFY_CHANGE_CREATION = 0x00000040;
static const int FILE_NOTIFY_CHANGE_SECURITY = 0x00000100;
static const int FILE_ACTION_ADDED = 0x00000001;
static const int FILE_ACTION_REMOVED = 0x00000002;
static const int FILE_ACTION_MODIFIED = 0x00000003;
static const int FILE_ACTION_RENAMED_OLD_NAME = 0x00000004;
static const int FILE_ACTION_RENAMED_NEW_NAME = 0x00000005;
static const int MAILSLOT_NO_MESSAGE = ((DWORD)-1);
static const int MAILSLOT_WAIT_FOREVER = ((DWORD)-1);
static const int FILE_CASE_SENSITIVE_SEARCH = 0x00000001;
static const int FILE_CASE_PRESERVED_NAMES = 0x00000002;
static const int FILE_UNICODE_ON_DISK = 0x00000004;
static const int FILE_PERSISTENT_ACLS = 0x00000008;
static const int FILE_FILE_COMPRESSION = 0x00000010;
static const int FILE_VOLUME_QUOTAS = 0x00000020;
static const int FILE_SUPPORTS_SPARSE_FILES = 0x00000040;
static const int FILE_SUPPORTS_REPARSE_POINTS = 0x00000080;
static const int FILE_SUPPORTS_REMOTE_STORAGE = 0x00000100;
static const int FILE_VOLUME_IS_COMPRESSED = 0x00008000;
static const int FILE_SUPPORTS_OBJECT_IDS = 0x00010000;
static const int FILE_SUPPORTS_ENCRYPTION = 0x00020000;
static const int FILE_NAMED_STREAMS = 0x00040000;
static const int FILE_READ_ONLY_VOLUME = 0x00080000;
static const int FILE_SEQUENTIAL_WRITE_ONCE = 0x00100000;
static const int FILE_SUPPORTS_TRANSACTIONS = 0x00200000;
static const int FILE_SUPPORTS_HARD_LINKS = 0x00400000;
static const int FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000;
static const int FILE_SUPPORTS_OPEN_BY_FILE_ID = 0x01000000;
static const int FILE_SUPPORTS_USN_JOURNAL = 0x02000000;
//
// Define the file notification information structure
//
typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;
//
// Define segement buffer structure for scatter/gather read/write.
//
typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
//
// The reparse GUID structure is used by all 3rd party layered drivers to
// store data in a reparse point. For non-Microsoft tags, The GUID field
// cannot be GUID_NULL.
// The constraints on reparse tags are defined below.
// Microsoft tags can also be used with this format of the reparse point buffer.
//
typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD ReparseTag;
    WORD ReparseDataLength;
    WORD Reserved;
    GUID ReparseGuid;
    struct {
        BYTE DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;
static const int REPARSE_GUID_DATA_BUFFER_HEADER_SIZE = FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer);
//
// Maximum allowed size of the reparse data.
//
static const int MAXIMUM_REPARSE_DATA_BUFFER_SIZE = ( 16 * 1024 );
//
// Predefined reparse tags.
// These tags need to avoid conflicting with IO_REMOUNT defined in ntos\inc\io.h
//
static const int IO_REPARSE_TAG_RESERVED_ZERO = (0);
static const int IO_REPARSE_TAG_RESERVED_ONE = (1);
//
// The value of the following constant needs to satisfy the following conditions:
//  (1) Be at least as large as the largest of the reserved tags.
//  (2) Be strictly smaller than all the tags in use.
//
static const int IO_REPARSE_TAG_RESERVED_RANGE = IO_REPARSE_TAG_RESERVED_ONE;
//
// The reparse tags are a DWORD. The 32 bits are laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-----------------------+-------------------------------+
//  |M|R|N|R|     Reserved bits     |       Reparse Tag Value       |
//  +-+-+-+-+-----------------------+-------------------------------+
//
// M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
//   All ISVs must use a tag with a 0 in this position.
//   Note: If a Microsoft tag is used by non-Microsoft software, the
//   behavior is not defined.
//
// R is reserved.  Must be zero for non-Microsoft tags.
//
// N is name surrogate. When set to 1, the file represents another named
//   entity in the system.
//
// The M and N bits are OR-able.
// The following macros check for the M and N bit values:
//
//
// Macro to determine whether a reparse point tag corresponds to a tag
// owned by Microsoft.
//
static const int IsReparseTagMicrosoft(_tag) = ( ((_tag) & 0x80000000) );
//
// Macro to determine whether a reparse point tag is a name surrogate
//
static const int IsReparseTagNameSurrogate(_tag) = ( ((_tag) & 0x20000000) );
static const int IO_REPARSE_TAG_MOUNT_POINT = (0xA0000003L);
static const int IO_REPARSE_TAG_HSM = (0xC0000004L);
static const int IO_REPARSE_TAG_HSM2 = (0x80000006L);
static const int IO_REPARSE_TAG_SIS = (0x80000007L);
static const int IO_REPARSE_TAG_WIM = (0x80000008L);
static const int IO_REPARSE_TAG_CSV = (0x80000009L);
static const int IO_REPARSE_TAG_DFS = (0x8000000AL);
static const int IO_REPARSE_TAG_SYMLINK = (0xA000000CL);
static const int IO_REPARSE_TAG_DFSR = (0x80000012L);
//
// I/O Completion Specific Access Rights.
//
static const int IO_COMPLETION_MODIFY_STATE = 0x0002;
static const int IO_COMPLETION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3);
//
// Object Manager Symbolic Link Specific Access Rights.
//
static const int DUPLICATE_CLOSE_SOURCE = 0x00000001;
static const int DUPLICATE_SAME_ACCESS = 0x00000002;
//
// =========================================
// Define GUIDs which represent well-known power schemes
// =========================================
//
//
// Maximum Power Savings - indicates that very aggressive power savings measures will be used to help
//                         stretch battery life.
//
// {a1841308-3541-4fab-bc81-f71556f20b4a}
//
extern const GUID GUID_MAX_POWER_SAVINGS;
//
// No Power Savings - indicates that almost no power savings measures will be used.
//
// {8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}
//
extern const GUID GUID_MIN_POWER_SAVINGS;
//
// Typical Power Savings - indicates that fairly aggressive power savings measures will be used.
//
// {381b4222-f694-41f0-9685-ff5bb260df2e}
//
extern const GUID GUID_TYPICAL_POWER_SAVINGS;
//
// This is a special GUID that represents "no subgroup" of settings.  That is, it indicates
// that settings that are in the root of the power policy hierarchy as opposed to settings
// that are buried under a subgroup of settings.  This should be used when querying for
// power settings that may not fall into a subgroup.
//
extern const GUID NO_SUBGROUP_GUID;
//
// This is a special GUID that represents "every power scheme".  That is, it indicates
// that any write to this power scheme should be reflected to every scheme present.
// This allows users to write a single setting once and have it apply to all schemes.  They
// can then apply custom settings to specific power schemes that they care about.
//
extern const GUID ALL_POWERSCHEMES_GUID;
//
// This is a special GUID that represents a 'personality' that each power scheme will have.
// In other words, each power scheme will have this key indicating "I'm most like *this* base
// power scheme."  This individual setting will have one of three settings:
// GUID_MAX_POWER_SAVINGS
// GUID_MIN_POWER_SAVINGS
// GUID_TYPICAL_POWER_SAVINGS
//
// This allows several features:
// 1. Drivers and applications can register for notification of this GUID.  So when this power
//    scheme is activiated, this GUID's setting will be sent across the system and drivers/applications
//    can see "GUID_MAX_POWER_SAVINGS" which will tell them in a generic fashion "get real aggressive
//    about conserving power".
// 2. UserB may install a driver or application which creates power settings, and UserB may modify
//    those power settings.  Now UserA logs in.  How does he see those settings?  They simply don't
//    exist in his private power key.  Well they do exist over in the system power key.  When we
//    enumerate all the power settings in this system power key and don't find a corresponding entry
//    in the user's private power key, then we can go look at this "personality" key in the users
//    power scheme.  We can then go get a default value for the power setting, depending on which
//    "personality" power scheme is being operated on.  Here's an example:
//    A. UserB installs an application that creates a power setting Seetting1
//    B. UserB changes Setting1 to have a value of 50 because that's one of the possible settings
//       available for setting1.
//    C. UserB logs out
//    D. UserA logs in and his active power scheme is some custom scheme that was derived from
//       the GUID_TYPICAL_POWER_SAVINGS.  But remember that UserA has no setting1 in his
//       private power key.
//    E. When activating UserA's selected power scheme, all power settings in the system power key will
//       be enumerated (including Setting1).
//    F. The power manager will see that UserA has no Setting1 power setting in his private power scheme.
//    G. The power manager will query UserA's power scheme for its personality and retrieve
//       GUID_TYPICAL_POWER_SAVINGS.
//    H. The power manager then looks in Setting1 in the system power key and looks in its set of default
//       values for the corresponding value for GUID_TYPICAL_POWER_SAVINGS power schemes.
//    I. This derived power setting is applied.
extern const GUID GUID_POWERSCHEME_PERSONALITY;
//
// Define a special GUID which will be used to define the active power scheme.
// User will register for this power setting GUID, and when the active power
// scheme changes, they'll get a callback where the payload is the GUID
// representing the active powerscheme.
// ( 31F9F286-5084-42FE-B720-2B0264993763 }
//
extern const GUID GUID_ACTIVE_POWERSCHEME;
//
// =========================================
// Define GUIDs which represent well-known power settings
// =========================================
//
// Video settings
// --------------
//
// Specifies the subgroup which will contain all of the video
// settings for a single policy.
//
extern const GUID GUID_VIDEO_SUBGROUP;
//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we power off the video.
//
extern const GUID GUID_VIDEO_POWERDOWN_TIMEOUT;
//
// Specifies whether adaptive display dimming is turned on or off.
// 82DBCF2D-CD67-40C5-BFDC-9F1A5CCD4663
//
extern const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT;
//
// Specifies how much adaptive dim time out will be increased by.
// EED904DF-B142-4183-B10B-5A1197A37864
//
extern const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;
//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we dim the video.
//
extern const GUID GUID_VIDEO_DIM_TIMEOUT;
//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the video,
//
extern const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN;
//
// Specifies if the monitor is currently being powered or not.
// 02731015-4510-4526-99E6-E5A17EBD1AEA
//
extern const GUID GUID_MONITOR_POWER_ON;
//
// Monitor brightness policy when in normal state
// {aded5e82-b909-4619-9949-f5d71dac0bcb}
extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;
//
//
// Monitor brightness policy when in dim state
// {f1fbfde2-a960-4165-9f88-50667911ce96}
extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;
//
// Current Monitor brightness
// {8ffee2c6-2d01-46be-adb9-398addc5b4ff}
extern const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;
//
// Specifies if the operating system should use ambient light sensor to change
// disply brightness adatively.
// {FBD9AA66-9553-4097-BA44-ED6E9D65EAB8}
extern const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;
//
// Specifies a change in the session's display state.
// 73A5E93A-5BB1-4F93-895B-DBD0DA855967
//
// N.B. This is a session-specific notification, sent only to interactive
//      session registrants. Session 0 and kernel mode consumers do not receive
//      this notification.
extern const GUID GUID_SESSION_DISPLAY_STATE;
//
// Specifies a change in the current monitor's display state.
// 6fe69556-704a-47a0-8f24-c28d936fda47
//
extern const GUID GUID_CONSOLE_DISPLAY_STATE;
//
// Defines a guid for enabling/disabling the ability to create display required 
// power requests.
//
// {A9CEB8DA-CD46-44FB-A98B-02AF69DE4623}
//
extern const GUID GUID_ALLOW_DISPLAY_REQUIRED;
// Harddisk settings
// -----------------
//
// Specifies the subgroup which will contain all of the harddisk
// settings for a single policy.
//
extern const GUID GUID_DISK_SUBGROUP;
//
// Specifies (in seconds) how long we wait after the last disk access
// before we power off the disk.
//
extern const GUID GUID_DISK_POWERDOWN_TIMEOUT;
//
// Specifies the amount of contiguous disk activity time to ignore when
// calculating disk idleness.
//
// 80e3c60e-bb94-4ad8-bbe0-0d3195efc663
//
extern const GUID GUID_DISK_BURST_IGNORE_THRESHOLD;
//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the disk,
//
extern const GUID GUID_DISK_ADAPTIVE_POWERDOWN;
// System sleep settings
// ---------------------
//
// Specifies the subgroup which will contain all of the sleep
// settings for a single policy.
// { 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 }
//
extern const GUID GUID_SLEEP_SUBGROUP;
//
// Specifies an idle treshold percentage (0-100). The system must be this idle
// over a period of time in order to idle to sleep.
//
// N.B. DEPRECATED IN WINDOWS 6.1
//
extern const GUID GUID_SLEEP_IDLE_THRESHOLD;
//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to standby (S1, S2 or S3).
//
extern const GUID GUID_STANDBY_TIMEOUT;
//
// Specifies (in seconds) how long the system should go back to sleep after
// waking unattended. 0 indicates that the standard standby/hibernate idle
// policy should be used instead.
//
// {7bc4a2f9-d8fc-4469-b07b-33eb785aaca0}
//
extern const GUID GUID_UNATTEND_SLEEP_TIMEOUT;
//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to hibernate (S4).
//
extern const GUID GUID_HIBERNATE_TIMEOUT;
//
// Specifies whether or not Fast S4 should be enabled if the system supports it
// 94AC6D29-73CE-41A6-809F-6363BA21B47E
//
extern const GUID GUID_HIBERNATE_FASTS4_POLICY;
//
// Define a GUID for controlling the criticality of sleep state transitions.
// Critical sleep transitions do not query applications, services or drivers
// before transitioning the platform to a sleep state.
//
// {B7A27025-E569-46c2-A504-2B96CAD225A1}
//
extern const GUID GUID_CRITICAL_POWER_TRANSITION;
//
// Specifies if the system is entering or exiting 'away mode'.
// 98A7F580-01F7-48AA-9C0F-44352C29E5C0
//
extern const GUID GUID_SYSTEM_AWAYMODE;
// Specify whether away mode is allowed
//
// {25DFA149-5DD1-4736-B5AB-E8A37B5B8187}
//
extern const GUID GUID_ALLOW_AWAYMODE;
//
// Defines a guid for enabling/disabling standby (S1-S3) states. This does not
// affect hibernation (S4).
//
// {abfc2519-3608-4c2a-94ea-171b0ed546ab}
//
extern const GUID GUID_ALLOW_STANDBY_STATES;
//
// Defines a guid for enabling/disabling the ability to wake via RTC.
//
// {BD3B718A-0680-4D9D-8AB2-E1D2B4AC806D}
//
extern const GUID GUID_ALLOW_RTC_WAKE;
//
// Defines a guid for enabling/disabling the ability to create system required 
// power requests.
//
// {A4B195F5-8225-47D8-8012-9D41369786E2}
//
extern const GUID GUID_ALLOW_SYSTEM_REQUIRED;
// System button actions
// ---------------------
//
//
// Specifies the subgroup which will contain all of the system button
// settings for a single policy.
//
extern const GUID GUID_SYSTEM_BUTTON_SUBGROUP;
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system power button is pressed.
//
extern const GUID GUID_POWERBUTTON_ACTION;
extern const GUID GUID_POWERBUTTON_ACTION_FLAGS;
//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
//
extern const GUID GUID_SLEEPBUTTON_ACTION;
extern const GUID GUID_SLEEPBUTTON_ACTION_FLAGS;
//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
// { A7066653-8D6C-40A8-910E-A1F54B84C7E5 }
//
extern const GUID GUID_USERINTERFACEBUTTON_ACTION;
//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system lid is closed.
//
extern const GUID GUID_LIDCLOSE_ACTION;
extern const GUID GUID_LIDCLOSE_ACTION_FLAGS;
extern const GUID GUID_LIDOPEN_POWERSTATE;
// Battery Discharge Settings
// --------------------------
//
// Specifies the subgroup which will contain all of the battery discharge
// settings for a single policy.
//
extern const GUID GUID_BATTERY_SUBGROUP;
//
// 4 battery discharge alarm settings.
//
// GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take.  It is a value
//                                   of type POWER_ACTION
// GUID_BATTERY_DISCHARGE_LEVEL_x  - This is the battery level (%)
// GUID_BATTERY_DISCHARGE_FLAGS_x  - Flags defined below:
//                                   POWER_ACTION_POLICY->EventCode flags
//                                   BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
//                                   BATTERY_DISCHARGE_FLAGS_ENABLE
extern const GUID GUID_BATTERY_DISCHARGE_ACTION_0;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_0;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_0;
extern const GUID GUID_BATTERY_DISCHARGE_ACTION_1;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_1;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_1;
extern const GUID GUID_BATTERY_DISCHARGE_ACTION_2;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_2;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_2;
extern const GUID GUID_BATTERY_DISCHARGE_ACTION_3;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_3;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_3;
// Processor power settings
// ------------------------
//
// Specifies the subgroup which will contain all of the processor
// settings for a single policy.
//
extern const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP;
//
// Specifies various attributes that control processor performance/throttle
// states.
// 
extern const GUID GUID_PROCESSOR_THROTTLE_POLICY;
static const int PERFSTATE_POLICY_CHANGE_IDEAL = 0;
static const int PERFSTATE_POLICY_CHANGE_SINGLE = 1;
static const int PERFSTATE_POLICY_CHANGE_ROCKET = 2;
static const int PERFSTATE_POLICY_CHANGE_MAX = PERFSTATE_POLICY_CHANGE_ROCKET;
//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above.  For example, if this value is set to 80, then
// the processor frequency will never be throttled above 80 percent of its
// maximum frequency by the system.
//
extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM;
//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below.  For example, if this value is set to 50, then the
// processor frequency will never be throttled below 50 percent of its
// maximum frequency by the system.
//
extern const GUID GUID_PROCESSOR_THROTTLE_MINIMUM;
//
// Specifies whether throttle states are allowed to be used even when
// performance states are available.
//
// {3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb}
//
extern const GUID GUID_PROCESSOR_ALLOW_THROTTLING;
//
// Specifies processor power settings for CState policy data
// {68F262A7-F621-4069-B9A5-4874169BE23C}
//
extern const GUID GUID_PROCESSOR_IDLESTATE_POLICY;
//
// Specifies processor power settings for PerfState policy data
// {BBDC3814-18E9-4463-8A55-D197327C45C0}
//
extern const GUID GUID_PROCESSOR_PERFSTATE_POLICY;
//
// Specifies the increase busy percentage threshold that must be met before
// increasing the processor performance state.
//
// {06cadf0e-64ed-448a-8927-ce7bf90eb35d}
//
extern const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;
//
// Specifies the decrease busy percentage threshold that must be met before
// decreasing the processor performance state.
//
// {12a0ab44-fe28-4fa9-b3bd-4b64f44960a6}
//
extern const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;
//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when increasing the processor performance state.
//
// {465E1F50-B610-473a-AB58-00D1077DC418}
//
extern const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY;
//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when decreasing the processor performance state.
//
// {40FBEFC7-2E9D-4d25-A185-0CFD8574BAC6}
//
extern const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY;
//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {984CF492-3BED-4488-A8F9-4286C97BF5AA}
//
extern const GUID GUID_PROCESSOR_PERF_INCREASE_TIME;
//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {D8EDEB9B-95CF-4f95-A73C-B061973693C8}
//
extern const GUID GUID_PROCESSOR_PERF_DECREASE_TIME;
//
// Specifies the time, in milliseconds, that must expire before considering
// a change in the processor performance states or parked core set.
//
// {4D2B0152-7D5C-498b-88E2-34345392A2C5}
//
extern const GUID GUID_PROCESSOR_PERF_TIME_CHECK;
//
// Specifies whether a processor may opportunistically increase frequency above
// the maximum when operating contitions allow it to do so safely.
//
// {45BCC044-D885-43e2-8605-EE0EC6E96B59}
//
extern const GUID GUID_PROCESSOR_PERF_BOOST_POLICY
                                                                         ;
static const int PROCESSOR_PERF_BOOST_POLICY_DISABLED = 0;
static const int PROCESSOR_PERF_BOOST_POLICY_MAX = 100;
//
// Specifies if idle state promotion and demotion values should be scaled based
// on the current peformance state.
//
// {6C2993B0-8F48-481f-BCC6-00DD2742AA06}
//
extern const GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING;
//
// Specifies if idle states should be disabled.
//
// {5D76A2CA-E8C0-402f-A133-2158492D58AD}
//
extern const GUID GUID_PROCESSOR_IDLE_DISABLE;
//
// Specifies the time that elapsed since the last idle state promotion or
// demotion before idle states may be promoted or demoted again (in 
// microseconds).
//
// {C4581C31-89AB-4597-8E2B-9C9CAB440E6B}
//
extern const GUID GUID_PROCESSOR_IDLE_TIME_CHECK;
//
// Specifies the upper busy threshold that must be met before demoting the
// processor to a lighter idle state (in percentage).
//
// {4B92D758-5A24-4851-A470-815D78AEE119}
//
extern const GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;
//
// Specifies the lower busy threshold that must be met before promoting the 
// processor to a deeper idle state (in percentage).
//
// {7B224883-B3CC-4d79-819F-8374152CBE7C}
//
extern const GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;
//
// Specifies the utilization threshold in percent that must be crossed in order to un-park cores.
// 
// {df142941-20f3-4edf-9a4a-9c83d3d717d1}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;
//
// Specifies the utilization threshold in percent that must be crossed in order to park cores.
// 
// {68dd2f27-a4ce-4e11-8487-3794e4135dfa}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;
//
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be unparked.
// 
// {c7be0679-2817-4d69-9d02-519a537ed0c6}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;
static const int CORE_PARKING_POLICY_CHANGE_IDEAL = 0;
static const int CORE_PARKING_POLICY_CHANGE_SINGLE = 1;
static const int CORE_PARKING_POLICY_CHANGE_ROCKET = 2;
static const int CORE_PARKING_POLICY_CHANGE_MAX = CORE_PARKING_POLICY_CHANGE_ROCKET;
// 
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be parked.
// 
// {71021b41-c749-4d21-be74-a00f335d582b}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;
//
// Specifies, on a per processor group basis, the maximum number of cores that can be kept unparked. 
// 
// {ea062031-0e34-4ff1-9b6d-eb1059334028}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES;
//
// Specifies, on a per processor group basis, the minimum number of cores that must be kept unparked.
// 
// {0cc5b647-c1df-4637-891a-dec35c318583}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES;
//
// Specifies, in milliseconds, the minimum amount of time a core must be parked before it can be unparked.
// 
// {2ddd5a84-5a71-437e-912a-db0b8c788732}
//
extern const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;
//
// Specifies, in milliseconds, the minimum amount of time a core must be unparked before it can be parked.
// 
// {dfd10d17-d5eb-45dd-877a-9a34ddd15c82}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;
//
// Specifies the factor by which to decrease affinity history on each core after each check.
// 
// {8f7b45e3-c393-480a-878c-f67ac3d07082}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;
//
// Specifies the threshold above which a core is considered to have had significant affinitized work scheduled to it while parked.
// 
// {5b33697b-e89d-4d38-aa46-9e7dfb7cd2f9}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;
//
// Specifies the weighting given to each occurence where affinitized work was scheduled to a parked core.
// 
// {e70867f1-fa2f-4f4e-aea1-4d8a0ba23b20}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;
//
// Specifies the factor by which to decrease the over utilization history on each core after the current performance check.
// 
// {1299023c-bc28-4f0a-81ec-d3295a8d815d}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;
//
// Specifies the threshold above which a core is considered to have been recently over utilized while parked.
// 
// {9ac18e92-aa3c-4e27-b307-01ae37307129}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;
//
// Specifies the weighting given to each occurence where a parked core is found to be over utilized.
// 
// {8809c2d8-b155-42d4-bcda-0d345651b1db}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;
//
// Specifies, in percentage, the busy threshold that must be met before a parked core is considered over utilized.
// 
// {943c8cb6-6f93-4227-ad87-e9a3feec08d1}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;
//
// Specifies if at least one processor per core should always remain unparked.
// 
// {a55612aa-f624-42c6-a443-7397d064c04f}
// 
extern const GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE;
//
// Specifies what performance state a processor should enter when first parked.
// 
// {447235c7-6a8d-4cc0-8e24-9eaf70b96e2b}
// 
extern const GUID GUID_PROCESSOR_PARKING_PERF_STATE;
//
// Specifies the number of perf time check intervals to average utility over.
//
// {7d24baa7-0b84-480f-840c-1b0743c00f5f}
//
extern const GUID GUID_PROCESSOR_PERF_HISTORY;
//
// Specifies active vs passive cooling.  Although not directly related to
// processor settings, it is the processor that gets throttled if we're doing
// passive cooling, so it is fairly strongly related.
// {94D3A615-A899-4AC5-AE2B-E4D8F634367F}
//
extern const GUID GUID_SYSTEM_COOLING_POLICY;
// Lock Console on Wake
// --------------------
//
// Specifies the behavior of the system when we wake from standby or
// hibernate.  If this is set, then we will cause the console to lock
// after we resume.
//
extern const GUID GUID_LOCK_CONSOLE_ON_WAKE;
// Device idle characteristics
// ---------------------------
//
// Specifies whether to use the "performance" or "conservative" timeouts for
// device idle management.
//
// 4faab71a-92e5-4726-b531-224559672d19
//
extern const GUID GUID_DEVICE_IDLE_POLICY;
static const int POWER_DEVICE_IDLE_POLICY_PERFORMANCE = 0;
static const int POWER_DEVICE_IDLE_POLICY_CONSERVATIVE = 1;
// AC/DC power source
// ------------------
//
// Specifies the power source for the system.  consumers may register for
// notification when the power source changes and will be notified with
// one of 3 values:
// 0 - Indicates the system is being powered by an AC power source.
// 1 - Indicates the system is being powered by a DC power source.
// 2 - Indicates the system is being powered by a short-term DC power
//     source.  For example, this would be the case if the system is
//     being powed by a short-term battery supply in a backing UPS
//     system.  When this value is recieved, the consumer should make
//     preparations for either a system hibernate or system shutdown.
//
// { 5D3E9A59-E9D5-4B00-A6BD-FF34FF516548 }
extern const GUID GUID_ACDC_POWER_SOURCE;
// Lid state changes
// -----------------
//
// Specifies the current state of the lid (open or closed). The callback won't
// be called at all until a lid device is found and its current state is known.
//
// Values:
//
// 0 - closed
// 1 - opened
//
// { BA3E0F4D-B817-4094-A2D1-D56379E6A0F3 }
//
extern const GUID GUID_LIDSWITCH_STATE_CHANGE;
// Battery life remaining
// ----------------------
//
// Specifies the percentage of battery life remaining.  The consumer
// may register for notification in order to track battery life in
// a fine-grained manner.
//
// Once registered, the consumer can expect to be notified as the battery
// life percentage changes.
//
// The consumer will recieve a value between 0 and 100 (inclusive) which
// indicates percent battery life remaining.
//
// { A7AD8041-B45A-4CAE-87A3-EECBB468A9E1 }
extern const GUID GUID_BATTERY_PERCENTAGE_REMAINING;
// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
extern const GUID GUID_IDLE_BACKGROUND_TASK;
// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
// { CF23F240-2A54-48D8-B114-DE1518FF052E }
extern const GUID GUID_BACKGROUND_TASK_NOTIFICATION;
// Define a GUID that will represent the action of a direct experience button
// on the platform.  Users will register for this DPPE setting and recieve
// notification when the h/w button is pressed.
//
// { 1A689231-7399-4E9A-8F99-B71F999DB3FA }
//
extern const GUID GUID_APPLAUNCH_BUTTON;
// PCI Express power settings
// ------------------------
//
// Specifies the subgroup which will contain all of the PCI Express
// settings for a single policy.
//
// {501a4d13-42af-4429-9fd1-a8218c268e20}
//
extern const GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP;
// Specifies the PCI Express ASPM power policy.
//
// {ee12f906-d277-404b-b6da-e5fa1a576df5}
//
extern const GUID GUID_PCIEXPRESS_ASPM_POLICY;
// POWER Shutdown settings
// ------------------------
//
// Specifies if forced shutdown should be used for all button and lid initiated
// shutdown actions.
//
// {833a6b62-dfa4-46d1-82f8-e09e34d029d6}
//
extern const GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;
typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;
static const int POWER_SYSTEM_MAXIMUM = 7;
typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;
typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;
typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;
static const int ES_SYSTEM_REQUIRED = ((DWORD)0x00000001);
static const int ES_DISPLAY_REQUIRED = ((DWORD)0x00000002);
static const int ES_USER_PRESENT = ((DWORD)0x00000004);
static const int ES_AWAYMODE_REQUIRED = ((DWORD)0x00000040);
static const int ES_CONTINUOUS = ((DWORD)0x80000000);
typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;
typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;
static const int DIAGNOSTIC_REASON_VERSION = 0;
static const int DIAGNOSTIC_REASON_SIMPLE_STRING = 0x00000001;
static const int DIAGNOSTIC_REASON_DETAILED_STRING = 0x00000002;
static const int DIAGNOSTIC_REASON_NOT_SPECIFIED = 0x80000000;
static const int DIAGNOSTIC_REASON_INVALID_FLAGS = (~0x80000003);
//
// Defines for power request APIs
//
static const int POWER_REQUEST_CONTEXT_VERSION = 0;
static const int POWER_REQUEST_CONTEXT_SIMPLE_STRING = 0x00000001;
static const int POWER_REQUEST_CONTEXT_DETAILED_STRING = 0x00000002;
//
// N.B. The maximum is a macro (rather than part of enum) for cgen to be able
// to parse power.h correctly. When a new power request type is added, the
// PowerRequestMaximum should be manually incremented.
//
typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;
static const int PowerRequestMaximum = 3;
// end_ntminiport
//-----------------------------------------------------------------------------
// Device Power Information
// Accessable via CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
//-----------------------------------------------------------------------------
static const int PDCAP_D0_SUPPORTED = 0x00000001;
static const int PDCAP_D1_SUPPORTED = 0x00000002;
static const int PDCAP_D2_SUPPORTED = 0x00000004;
static const int PDCAP_D3_SUPPORTED = 0x00000008;
static const int PDCAP_WAKE_FROM_D0_SUPPORTED = 0x00000010;
static const int PDCAP_WAKE_FROM_D1_SUPPORTED = 0x00000020;
static const int PDCAP_WAKE_FROM_D2_SUPPORTED = 0x00000040;
static const int PDCAP_WAKE_FROM_D3_SUPPORTED = 0x00000080;
static const int PDCAP_WARM_EJECT_SUPPORTED = 0x00000100;
typedef struct CM_Power_Data_s {
    DWORD PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    DWORD PD_Capabilities;
    DWORD PD_D1Latency;
    DWORD PD_D2Latency;
    DWORD PD_D3Latency;
    DEVICE_POWER_STATE PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;
// begin_wdm
typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime, // Compare with KeQueryInterruptTime()
    LastSleepTime, // Compare with KeQueryInterruptTime()
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    PowerInformationLevelUnused1,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;
//
// Power Setting definitions
//
typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;
typedef struct {
    //
    // Version of this structure.  Currently should be set to
    // POWER_SETTING_VALUE_VERSION.
    //
    DWORD Version;
    //
    // GUID representing the power setting being applied.
    //
    GUID Guid;
    //
    // What power state should this setting be applied to?  E.g.
    // AC, DC, thermal, ...
    //
    SYSTEM_POWER_CONDITION PowerCondition;
    //
    // Length (in bytes) of the 'Data' member.
    //
    DWORD DataLength;
    //
    // Data which contains the actual setting value.
    //
    BYTE Data[1];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;
static const int POWER_SETTING_VALUE_VERSION = (0x1);
typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;
//
// Package definition for an experience button device notification.  When
// someone registers for GUID_EXPERIENCE_BUTTON, this is the definition of
// the setting data they'll get.
//
typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {
    //
    // System time when the most recent button press ocurred.  Note that this is
    // specified in 100ns internvals since January 1, 1601.
    //
    LARGE_INTEGER ActivationTime;
    //
    // Reserved for internal use.
    //
    DWORD Flags;
    //
    // which instance of this device was pressed?
    //
    DWORD ButtonInstanceID;
} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;
//
// define platform roles
//
typedef enum {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE;
//
// System power manager capabilities
//
typedef struct {
    DWORD Granularity;
    DWORD Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
//
typedef struct {
    DWORD Frequency;
    DWORD Flags;
    DWORD PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;
typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE PromotePercent;
    BYTE DemotePercent;
    BYTE StateType;
    BYTE Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1; // reserved for future use
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;
typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState; // current idle state
    DWORD OldState; // previous idle state
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;
typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState; // current idle state
    DWORD OldState; // previous idle state
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;
typedef struct {
    DWORD Frequency; // in Mhz
    DWORD Power; // in milliwatts
    BYTE PercentFrequency;
    BYTE IncreaseLevel; // goto higher state
    BYTE DecreaseLevel; // goto lower state
    BYTE Type; // performance or throttle
    DWORD IncreaseTime; // in tick counts
    DWORD DecreaseTime; // in tick counts
    DWORD64 Control; // control value
    DWORD64 Status; // control value
    DWORD HitCount;
    DWORD Reserved1; // reserved for future use
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;
typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState; // current state
    DWORD MaxPerfState; // fastest state considering policy restrictions
    DWORD MinPerfState; // slowest state considering policy restrictions
    DWORD LowestPerfState; // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType; // domain coordination
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors; // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;
typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState; // current state
    DWORD MaxPerfState; // fastest state considering policy restrictions
    DWORD MinPerfState; // slowest state considering policy restrictions
    DWORD LowestPerfState; // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType; // domain coordination
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors; // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;
//
// Legacy processor idle accounting.
//
static const int PROC_IDLE_BUCKET_COUNT = 6;
typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;
typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;
//
// Processor idle accounting.
//
static const int PROC_IDLE_BUCKET_COUNT_EX = 16;
typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;
typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;
typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING_EX State[1];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;
//
// Definitions of coordination types for _PSD, _TSD, and _CSD BIOS objects from
// the Acpi 3.0 specification
//
static const int ACPI_PPM_SOFTWARE_ALL = 0xFC;
static const int ACPI_PPM_SOFTWARE_ANY = 0xFD;
static const int ACPI_PPM_HARDWARE_ALL = 0xFE;
//
// Definition of Microsoft PPM coordination types.
//
static const int MS_PPM_SOFTWARE_ALL = 0x1;
//
// Processor firmware rundown feature bit definitions.
//
static const int PPM_FIRMWARE_ACPI1C2 = 0x00000001;
static const int PPM_FIRMWARE_ACPI1C3 = 0x00000002;
static const int PPM_FIRMWARE_ACPI1TSTATES = 0x00000004;
static const int PPM_FIRMWARE_CST = 0x00000008;
static const int PPM_FIRMWARE_CSD = 0x00000010;
static const int PPM_FIRMWARE_PCT = 0x00000020;
static const int PPM_FIRMWARE_PSS = 0x00000040;
static const int PPM_FIRMWARE_XPSS = 0x00000080;
static const int PPM_FIRMWARE_PPC = 0x00000100;
static const int PPM_FIRMWARE_PSD = 0x00000200;
static const int PPM_FIRMWARE_PTC = 0x00000400;
static const int PPM_FIRMWARE_TSS = 0x00000800;
static const int PPM_FIRMWARE_TPC = 0x00001000;
static const int PPM_FIRMWARE_TSD = 0x00002000;
static const int PPM_FIRMWARE_PCCH = 0x00004000;
static const int PPM_FIRMWARE_PCCP = 0x00008000;
//
// Processor Power Management WMI interface.
//
// {A5B32DDD-7F39-4abc-B892-900E43B59EBB}
extern const GUID PPM_PERFSTATE_CHANGE_GUID
                                                                          ;
// {995e6b7f-d653-497a-b978-36a30c29bf01}
extern const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID
                                                                         ;
// {4838fe4f-f71c-4e51-9ecc-8430a7ac4c6c}
extern const GUID PPM_IDLESTATE_CHANGE_GUID
                                                                           ;
// {5708cc20-7d40-4bf4-b4aa-2b01338d0126}
extern const GUID PPM_PERFSTATES_DATA_GUID
                                                                           ;
// {ba138e10-e250-4ad7-8616-cf1a7ad410e7}
extern const GUID PPM_IDLESTATES_DATA_GUID
                                                                           ;
// {e2a26f78-ae07-4ee0-a30f-ce354f5a94cd}
extern const GUID PPM_IDLE_ACCOUNTING_GUID
                                                                           ;
// {d67abd39-81f8-4a5e-8152-72e31ec912ee}
extern const GUID PPM_IDLE_ACCOUNTING_EX_GUID
                                                                           ;
// {a852c2c8-1a4c-423b-8c2c-f30d82931a88}
extern const GUID PPM_THERMALCONSTRAINT_GUID
                                                                           ;
// {7fd18652-0cfe-40d2-b0a1-0b066a87759e}
extern const GUID PPM_PERFMON_PERFSTATE_GUID
                                                                        ;
// {48f377b8-6880-4c7b-8bdc-380176c6654d}
extern const GUID PPM_THERMAL_POLICY_CHANGE_GUID
                                                                          ;
typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;
typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;
typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;
typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;
#pragma warning(push)
#pragma warning(disable:4121)
typedef struct {
    BYTE Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;
#pragma warning(pop)
// Power Policy Management interfaces
//
typedef struct {
    POWER_ACTION Action;
    DWORD Flags;
    DWORD EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;
// POWER_ACTION_POLICY->Flags:
static const int POWER_ACTION_QUERY_ALLOWED = 0x00000001;
static const int POWER_ACTION_UI_ALLOWED = 0x00000002;
static const int POWER_ACTION_OVERRIDE_APPS = 0x00000004;
static const int POWER_ACTION_PSEUDO_TRANSITION = 0x08000000;
static const int POWER_ACTION_LIGHTEST_FIRST = 0x10000000;
static const int POWER_ACTION_LOCK_CONSOLE = 0x20000000;
static const int POWER_ACTION_DISABLE_WAKES = 0x40000000;
static const int POWER_ACTION_CRITICAL = 0x80000000;
// POWER_ACTION_POLICY->EventCode flags
static const int POWER_LEVEL_USER_NOTIFY_TEXT = 0x00000001;
static const int POWER_LEVEL_USER_NOTIFY_SOUND = 0x00000002;
static const int POWER_LEVEL_USER_NOTIFY_EXEC = 0x00000004;
static const int POWER_USER_NOTIFY_BUTTON = 0x00000008;
static const int POWER_USER_NOTIFY_SHUTDOWN = 0x00000010;
static const int POWER_USER_NOTIFY_FORCED_SHUTDOWN = 0x00000020;
static const int POWER_FORCE_TRIGGER_RESET = 0x80000000;
// Note: for battery alarm EventCodes, the ID of the battery alarm << 16 is ORed
// into the flags.  For example: DISCHARGE_POLICY_LOW << 16
//
// The GUID_BATTERY_DISCHARGE_FLAGS_x power settings use a subset of EventCode
// flags.  The POWER_FORCE_TRIGGER_RESET flag doesn't make sense for a battery
// alarm so it is overloaded for other purposes (gerneral enable/disable).
static const int BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK = 0x00000007;
static const int BATTERY_DISCHARGE_FLAGS_ENABLE = 0x80000000;
// system battery drain policies
typedef struct {
    BOOLEAN Enable;
    BYTE Spare[3];
    DWORD BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;
// Discharge policy constants
static const int NUM_DISCHARGE_POLICIES = 4;
static const int DISCHARGE_POLICY_CRITICAL = 0;
static const int DISCHARGE_POLICY_LOW = 1;
// system power policies
typedef struct _SYSTEM_POWER_POLICY {
    DWORD Revision; // 1
    // events
    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE LidOpenWake;
    DWORD Reserved;
    // "system idle" detection
    POWER_ACTION_POLICY Idle;
    DWORD IdleTimeout;
    BYTE IdleSensitivity;
    BYTE DynamicThrottle;
    BYTE Spare2[2];
    // meaning of power action "sleep"
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    SYSTEM_POWER_STATE ReducedLatencySleep;
    DWORD WinLogonFlags;
    DWORD Spare3;
    // parameters for dozing
    //
    DWORD DozeS4Timeout;
    // battery policies
    DWORD BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy[4];
    // video policies
    DWORD VideoTimeout;
    BOOLEAN VideoDimDisplay;
    DWORD VideoReserved[3];
    // hard disk policies
    DWORD SpindownTimeout;
    // processor policies
    BOOLEAN OptimizeForPower;
    BYTE FanThrottleTolerance;
    BYTE ForcedThrottle;
    BYTE MinThrottle;
    POWER_ACTION_POLICY OverThrottled;
} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;
// processor power policy state
//
// Processor Idle State Policy.
//
static const int PROCESSOR_IDLESTATE_POLICY_COUNT = 0x3;
typedef struct {
    DWORD TimeCheck;
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;
typedef struct {
    WORD Revision;
    union {
        WORD AsWORD ;
        struct {
            WORD AllowScaling : 1;
            WORD Disabled : 1;
            WORD Reserved : 14;
        } s;
    } Flags;
    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;
//
// Legacy Processor Policy.  This is only provided to allow legacy
// applications to compile.  New applications must use
// PROCESSOR_IDLESTATE_POLICY.
//
static const int PO_THROTTLE_NONE = 0;
static const int PO_THROTTLE_CONSTANT = 1;
static const int PO_THROTTLE_DEGRADE = 2;
static const int PO_THROTTLE_ADAPTIVE = 3;
static const int PO_THROTTLE_MAXIMUM = 4;
typedef struct _PROCESSOR_POWER_POLICY_INFO {
    // Time based information (will be converted to kernel units)
    DWORD TimeCheck; // in US
    DWORD DemoteLimit; // in US
    DWORD PromoteLimit; // in US
    // Percentage based information
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];
    // Flags
    DWORD AllowDemotion:1;
    DWORD AllowPromotion:1;
    DWORD Reserved:30;
} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;
// processor power policy
typedef struct _PROCESSOR_POWER_POLICY {
    DWORD Revision; // 1
    // Dynamic Throttling Policy
    BYTE DynamicThrottle;
    BYTE Spare[3];
    // Flags
    DWORD DisableCStates:1;
    DWORD Reserved:31;
    // System policy information
    // The Array is last, in case it needs to be grown and the structure
    // revision incremented.
    DWORD PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];
} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;
//
// Processor Perf State Policy.
//
typedef struct {
    DWORD Revision;
    BYTE MaxThrottle;
    BYTE MinThrottle;
    BYTE BusyAdjThreshold;
    union {
        BYTE Spare;
        union {
            BYTE AsBYTE ;
            struct {
                BYTE NoDomainAccounting : 1;
                BYTE IncreasePolicy: 2;
                BYTE DecreasePolicy: 2;
                BYTE Reserved : 3;
            } s;
        } Flags;
    } u;
    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;
// administrator power policy overrides
typedef struct _ADMINISTRATOR_POWER_POLICY {
    // meaning of power action "sleep"
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    // video policies
    DWORD MinVideoTimeout;
    DWORD MaxVideoTimeout;
    // disk policies
    DWORD MinSpindownTimeout;
    DWORD MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;
typedef struct {
    // Misc supported system features
    BOOLEAN PowerButtonPresent;
    BOOLEAN SleepButtonPresent;
    BOOLEAN LidPresent;
    BOOLEAN SystemS1;
    BOOLEAN SystemS2;
    BOOLEAN SystemS3;
    BOOLEAN SystemS4; // hibernate
    BOOLEAN SystemS5; // off
    BOOLEAN HiberFilePresent;
    BOOLEAN FullWake;
    BOOLEAN VideoDimPresent;
    BOOLEAN ApmPresent;
    BOOLEAN UpsPresent;
    // Processors
    BOOLEAN ThermalControl;
    BOOLEAN ProcessorThrottle;
    BYTE ProcessorMinThrottle;
    BYTE ProcessorMaxThrottle;
    BOOLEAN FastSystemS4;
    BYTE spare2[3];
    // Disk
    BOOLEAN DiskSpinDown;
    BYTE spare3[8];
    // System Battery
    BOOLEAN SystemBatteriesPresent;
    BOOLEAN BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];
    // Wake
    SYSTEM_POWER_STATE AcOnLineWake;
    SYSTEM_POWER_STATE SoftLidWake;
    SYSTEM_POWER_STATE RtcWake;
    SYSTEM_POWER_STATE MinDeviceWakeState; // note this may change on driver load
    SYSTEM_POWER_STATE DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;
typedef struct {
    BOOLEAN AcOnLine;
    BOOLEAN BatteryPresent;
    BOOLEAN Charging;
    BOOLEAN Discharging;
    BOOLEAN Spare1[4];
    DWORD MaxCapacity;
    DWORD RemainingCapacity;
    DWORD Rate;
    DWORD EstimatedTime;
    DWORD DefaultAlert1;
    DWORD DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;
//
// Image Format
//
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack4.h
Abstract:
    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 10774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
static const int IMAGE_DOS_SIGNATURE = 0x5A4D;
static const int IMAGE_OS2_SIGNATURE = 0x454E;
static const int IMAGE_OS2_SIGNATURE_LE = 0x454C;
static const int IMAGE_VXD_SIGNATURE = 0x454C;
static const int IMAGE_NT_SIGNATURE = 0x00004550;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack2.h
Abstract:
    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 10782 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
# 10793 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header
    WORD e_magic; // Magic number
    WORD e_cblp; // Bytes on last page of file
    WORD e_cp; // Pages in file
    WORD e_crlc; // Relocations
    WORD e_cparhdr; // Size of header in paragraphs
    WORD e_minalloc; // Minimum extra paragraphs needed
    WORD e_maxalloc; // Maximum extra paragraphs needed
    WORD e_ss; // Initial (relative) SS value
    WORD e_sp; // Initial SP value
    WORD e_csum; // Checksum
    WORD e_ip; // Initial IP value
    WORD e_cs; // Initial (relative) CS value
    WORD e_lfarlc; // File address of relocation table
    WORD e_ovno; // Overlay number
    WORD e_res[4]; // Reserved words
    WORD e_oemid; // OEM identifier (for e_oeminfo)
    WORD e_oeminfo; // OEM information; e_oemid specific
    WORD e_res2[10]; // Reserved words
    LONG e_lfanew; // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
typedef struct _IMAGE_OS2_HEADER { // OS/2 .EXE header
    WORD ne_magic; // Magic number
    CHAR ne_ver; // Version number
    CHAR ne_rev; // Revision number
    WORD ne_enttab; // Offset of Entry Table
    WORD ne_cbenttab; // Number of bytes in Entry Table
    LONG ne_crc; // Checksum of whole file
    WORD ne_flags; // Flag word
    WORD ne_autodata; // Automatic data segment number
    WORD ne_heap; // Initial heap allocation
    WORD ne_stack; // Initial stack allocation
    LONG ne_csip; // Initial CS:IP setting
    LONG ne_sssp; // Initial SS:SP setting
    WORD ne_cseg; // Count of file segments
    WORD ne_cmod; // Entries in Module Reference Table
    WORD ne_cbnrestab; // Size of non-resident name table
    WORD ne_segtab; // Offset of Segment Table
    WORD ne_rsrctab; // Offset of Resource Table
    WORD ne_restab; // Offset of resident name table
    WORD ne_modtab; // Offset of Module Reference Table
    WORD ne_imptab; // Offset of Imported Names Table
    LONG ne_nrestab; // Offset of Non-resident Names Table
    WORD ne_cmovent; // Count of movable entries
    WORD ne_align; // Segment alignment shift count
    WORD ne_cres; // Count of resource segments
    BYTE ne_exetyp; // Target Operating system
    BYTE ne_flagsothers; // Other .EXE flags
    WORD ne_pretthunks; // offset to return thunks
    WORD ne_psegrefbytes; // offset to segment ref. bytes
    WORD ne_swaparea; // Minimum code swap area size
    WORD ne_expver; // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;
typedef struct _IMAGE_VXD_HEADER { // Windows VXD header
    WORD e32_magic; // Magic number
    BYTE e32_border; // The byte ordering for the VXD
    BYTE e32_worder; // The word ordering for the VXD
    DWORD e32_level; // The EXE format level for now = 0
    WORD e32_cpu; // The CPU type
    WORD e32_os; // The OS type
    DWORD e32_ver; // Module version
    DWORD e32_mflags; // Module flags
    DWORD e32_mpages; // Module # pages
    DWORD e32_startobj; // Object # for instruction pointer
    DWORD e32_eip; // Extended instruction pointer
    DWORD e32_stackobj; // Object # for stack pointer
    DWORD e32_esp; // Extended stack pointer
    DWORD e32_pagesize; // VXD page size
    DWORD e32_lastpagesize; // Last page size in VXD
    DWORD e32_fixupsize; // Fixup section size
    DWORD e32_fixupsum; // Fixup section checksum
    DWORD e32_ldrsize; // Loader section size
    DWORD e32_ldrsum; // Loader section checksum
    DWORD e32_objtab; // Object table offset
    DWORD e32_objcnt; // Number of objects in module
    DWORD e32_objmap; // Object page map offset
    DWORD e32_itermap; // Object iterated data map offset
    DWORD e32_rsrctab; // Offset of Resource Table
    DWORD e32_rsrccnt; // Number of resource entries
    DWORD e32_restab; // Offset of resident name table
    DWORD e32_enttab; // Offset of Entry Table
    DWORD e32_dirtab; // Offset of Module Directive Table
    DWORD e32_dircnt; // Number of module directives
    DWORD e32_fpagetab; // Offset of Fixup Page Table
    DWORD e32_frectab; // Offset of Fixup Record Table
    DWORD e32_impmod; // Offset of Import Module Name Table
    DWORD e32_impmodcnt; // Number of entries in Import Module Name Table
    DWORD e32_impproc; // Offset of Import Procedure Name Table
    DWORD e32_pagesum; // Offset of Per-Page Checksum Table
    DWORD e32_datapage; // Offset of Enumerated Data Pages
    DWORD e32_preload; // Number of preload pages
    DWORD e32_nrestab; // Offset of Non-resident Names Table
    DWORD e32_cbnrestab; // Size of Non-resident Name Table
    DWORD e32_nressum; // Non-resident Name Table Checksum
    DWORD e32_autodata; // Object # for automatic data object
    DWORD e32_debuginfo; // Offset of the debugging information
    DWORD e32_debuglen; // The length of the debugging info. in bytes
    DWORD e32_instpreload; // Number of instance pages in preload section of VXD file
    DWORD e32_instdemand; // Number of instance pages in demand load section of VXD file
    DWORD e32_heapsize; // Size of heap - for 16-bit apps
    BYTE e32_res3[12]; // Reserved words
    DWORD e32_winresoff;
    DWORD e32_winreslen;
    WORD e32_devid; // Device ID for VxD
    WORD e32_ddkver; // DDK version for VxD
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 10904 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
//
// File header format.
//
typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
static const int IMAGE_SIZEOF_FILE_HEADER = 20;
static const int IMAGE_FILE_RELOCS_STRIPPED = 0x0001;
static const int IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
static const int IMAGE_FILE_LINE_NUMS_STRIPPED = 0x0004;
static const int IMAGE_FILE_LOCAL_SYMS_STRIPPED = 0x0008;
static const int IMAGE_FILE_AGGRESIVE_WS_TRIM = 0x0010;
static const int IMAGE_FILE_LARGE_ADDRESS_AWARE = 0x0020;
static const int IMAGE_FILE_BYTES_REVERSED_LO = 0x0080;
static const int IMAGE_FILE_32BIT_MACHINE = 0x0100;
static const int IMAGE_FILE_DEBUG_STRIPPED = 0x0200;
static const int IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400;
static const int IMAGE_FILE_NET_RUN_FROM_SWAP = 0x0800;
static const int IMAGE_FILE_SYSTEM = 0x1000;
static const int IMAGE_FILE_DLL = 0x2000;
static const int IMAGE_FILE_UP_SYSTEM_ONLY = 0x4000;
static const int IMAGE_FILE_BYTES_REVERSED_HI = 0x8000;
static const int IMAGE_FILE_MACHINE_UNKNOWN = 0;
static const int IMAGE_FILE_MACHINE_I386 = 0x014c;
static const int IMAGE_FILE_MACHINE_R3000 = 0x0162;
static const int IMAGE_FILE_MACHINE_R4000 = 0x0166;
static const int IMAGE_FILE_MACHINE_R10000 = 0x0168;
static const int IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x0169;
static const int IMAGE_FILE_MACHINE_ALPHA = 0x0184;
static const int IMAGE_FILE_MACHINE_SH3 = 0x01a2;
static const int IMAGE_FILE_MACHINE_SH3DSP = 0x01a3;
static const int IMAGE_FILE_MACHINE_SH3E = 0x01a4;
static const int IMAGE_FILE_MACHINE_SH4 = 0x01a6;
static const int IMAGE_FILE_MACHINE_SH5 = 0x01a8;
static const int IMAGE_FILE_MACHINE_ARM = 0x01c0;
static const int IMAGE_FILE_MACHINE_THUMB = 0x01c2;
static const int IMAGE_FILE_MACHINE_AM33 = 0x01d3;
static const int IMAGE_FILE_MACHINE_POWERPC = 0x01F0;
static const int IMAGE_FILE_MACHINE_POWERPCFP = 0x01f1;
static const int IMAGE_FILE_MACHINE_IA64 = 0x0200;
static const int IMAGE_FILE_MACHINE_MIPS16 = 0x0266;
static const int IMAGE_FILE_MACHINE_ALPHA64 = 0x0284;
static const int IMAGE_FILE_MACHINE_MIPSFPU = 0x0366;
static const int IMAGE_FILE_MACHINE_MIPSFPU16 = 0x0466;
static const int IMAGE_FILE_MACHINE_AXP64 = IMAGE_FILE_MACHINE_ALPHA64;
static const int IMAGE_FILE_MACHINE_TRICORE = 0x0520;
static const int IMAGE_FILE_MACHINE_CEF = 0x0CEF;
static const int IMAGE_FILE_MACHINE_EBC = 0x0EBC;
static const int IMAGE_FILE_MACHINE_AMD64 = 0x8664;
static const int IMAGE_FILE_MACHINE_M32R = 0x9041;
static const int IMAGE_FILE_MACHINE_CEE = 0xC0EE;
//
// Directory format.
//
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
static const int IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;
//
// Optional header format.
//
typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    //
    // NT additional fields.
    //
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD BaseOfBss;
    DWORD GprMask;
    DWORD CprMask[4];
    DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
static const int IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
static const int IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
static const int IMAGE_ROM_OPTIONAL_HDR_MAGIC = 0x107;
typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;
static const int IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;
typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;
// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is the same either way.
static const int IMAGE_FIRST_SECTION(ntheader) = ((PIMAGE_SECTION_HEADER) ((ULONG_PTR)(ntheader) + FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) + ((ntheader))->FileHeader.SizeOfOptionalHeader ));
// Subsystem Values
static const int IMAGE_SUBSYSTEM_UNKNOWN = 0;
static const int IMAGE_SUBSYSTEM_NATIVE = 1;
static const int IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
static const int IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
static const int IMAGE_SUBSYSTEM_OS2_CUI = 5;
static const int IMAGE_SUBSYSTEM_POSIX_CUI = 7;
static const int IMAGE_SUBSYSTEM_NATIVE_WINDOWS = 8;
static const int IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = 9;
static const int IMAGE_SUBSYSTEM_EFI_APPLICATION = 10;
static const int IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = 11;
static const int IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER = 12;
static const int IMAGE_SUBSYSTEM_EFI_ROM = 13;
static const int IMAGE_SUBSYSTEM_XBOX = 14;
static const int IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16;
// DllCharacteristics Entries
//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.
//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.
//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.
//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.
static const int IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040;
static const int IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = 0x0080;
static const int IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 0x0100;
static const int IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = 0x0200;
static const int IMAGE_DLLCHARACTERISTICS_NO_SEH = 0x0400;
static const int IMAGE_DLLCHARACTERISTICS_NO_BIND = 0x0800;
//                                            0x1000     // Reserved.
static const int IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = 0x2000;
//                                            0x4000     // Reserved.
static const int IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000;
// Directory Entries
static const int IMAGE_DIRECTORY_ENTRY_EXPORT = 0;
static const int IMAGE_DIRECTORY_ENTRY_IMPORT = 1;
static const int IMAGE_DIRECTORY_ENTRY_RESOURCE = 2;
static const int IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3;
static const int IMAGE_DIRECTORY_ENTRY_SECURITY = 4;
static const int IMAGE_DIRECTORY_ENTRY_BASERELOC = 5;
static const int IMAGE_DIRECTORY_ENTRY_DEBUG = 6;
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
static const int IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7;
static const int IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8;
static const int IMAGE_DIRECTORY_ENTRY_TLS = 9;
static const int IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10;
static const int IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11;
static const int IMAGE_DIRECTORY_ENTRY_IAT = 12;
static const int IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13;
static const int IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14;
//
// Non-COFF Object file header
//
typedef struct ANON_OBJECT_HEADER {
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be 0xffff
    WORD Version; // >= 1 (implies the CLSID field is present)
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID; // Used to invoke CoCreateInstance
    DWORD SizeOfData; // Size of data that follows the header
} ANON_OBJECT_HEADER;
typedef struct ANON_OBJECT_HEADER_V2 {
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be 0xffff
    WORD Version; // >= 2 (implies the Flags field is present - otherwise V1)
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID; // Used to invoke CoCreateInstance
    DWORD SizeOfData; // Size of data that follows the header
    DWORD Flags; // 0x1 -> contains metadata
    DWORD MetaDataSize; // Size of CLR metadata
    DWORD MetaDataOffset; // Offset of CLR metadata
} ANON_OBJECT_HEADER_V2;
typedef struct ANON_OBJECT_HEADER_BIGOBJ {
   /* same as ANON_OBJECT_HEADER_V2 */
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be 0xffff
    WORD Version; // >= 2 (implies the Flags field is present)
    WORD Machine; // Actual machine - IMAGE_FILE_MACHINE_xxx
    DWORD TimeDateStamp;
    CLSID ClassID; // {D1BAA1C7-BAEE-4ba9-AF20-FAF66AA4DCB8}
    DWORD SizeOfData; // Size of data that follows the header
    DWORD Flags; // 0x1 -> contains metadata
    DWORD MetaDataSize; // Size of CLR metadata
    DWORD MetaDataOffset; // Offset of CLR metadata
    /* bigobj specifics */
    DWORD NumberOfSections; // extended from WORD
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;
//
// Section header format.
//
static const int IMAGE_SIZEOF_SHORT_NAME = 8;
typedef struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union {
            DWORD PhysicalAddress;
            DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
static const int IMAGE_SIZEOF_SECTION_HEADER = 40;
//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
static const int IMAGE_SCN_TYPE_NO_PAD = 0x00000008;
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.
static const int IMAGE_SCN_CNT_CODE = 0x00000020;
static const int IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040;
static const int IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080;
static const int IMAGE_SCN_LNK_OTHER = 0x00000100;
static const int IMAGE_SCN_LNK_INFO = 0x00000200;
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
static const int IMAGE_SCN_LNK_REMOVE = 0x00000800;
static const int IMAGE_SCN_LNK_COMDAT = 0x00001000;
//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
static const int IMAGE_SCN_NO_DEFER_SPEC_EXC = 0x00004000;
static const int IMAGE_SCN_GPREL = 0x00008000;
static const int IMAGE_SCN_MEM_FARDATA = 0x00008000;
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
static const int IMAGE_SCN_MEM_PURGEABLE = 0x00020000;
static const int IMAGE_SCN_MEM_16BIT = 0x00020000;
static const int IMAGE_SCN_MEM_LOCKED = 0x00040000;
static const int IMAGE_SCN_MEM_PRELOAD = 0x00080000;
static const int IMAGE_SCN_ALIGN_1BYTES = 0x00100000;
static const int IMAGE_SCN_ALIGN_2BYTES = 0x00200000;
static const int IMAGE_SCN_ALIGN_4BYTES = 0x00300000;
static const int IMAGE_SCN_ALIGN_8BYTES = 0x00400000;
static const int IMAGE_SCN_ALIGN_16BYTES = 0x00500000;
static const int IMAGE_SCN_ALIGN_32BYTES = 0x00600000;
static const int IMAGE_SCN_ALIGN_64BYTES = 0x00700000;
static const int IMAGE_SCN_ALIGN_128BYTES = 0x00800000;
static const int IMAGE_SCN_ALIGN_256BYTES = 0x00900000;
static const int IMAGE_SCN_ALIGN_512BYTES = 0x00A00000;
static const int IMAGE_SCN_ALIGN_1024BYTES = 0x00B00000;
static const int IMAGE_SCN_ALIGN_2048BYTES = 0x00C00000;
static const int IMAGE_SCN_ALIGN_4096BYTES = 0x00D00000;
static const int IMAGE_SCN_ALIGN_8192BYTES = 0x00E00000;
// Unused                                    0x00F00000
static const int IMAGE_SCN_ALIGN_MASK = 0x00F00000;
static const int IMAGE_SCN_LNK_NRELOC_OVFL = 0x01000000;
static const int IMAGE_SCN_MEM_DISCARDABLE = 0x02000000;
static const int IMAGE_SCN_MEM_NOT_CACHED = 0x04000000;
static const int IMAGE_SCN_MEM_NOT_PAGED = 0x08000000;
static const int IMAGE_SCN_MEM_SHARED = 0x10000000;
static const int IMAGE_SCN_MEM_EXECUTE = 0x20000000;
static const int IMAGE_SCN_MEM_READ = 0x40000000;
static const int IMAGE_SCN_MEM_WRITE = 0x80000000;
//
// TLS Chaacteristic Flags
//
static const int IMAGE_SCN_SCALE_INDEX = 0x00000001;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack2.h
Abstract:
    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 11308 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
//
// Symbol format.
//
typedef struct _IMAGE_SYMBOL {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short; // if 0, use LongName
            DWORD Long; // offset into string table
        } Name;
        DWORD LongName[2]; // PBYTE [2]
    } N;
    DWORD Value;
    SHORT SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL *PIMAGE_SYMBOL;
static const int IMAGE_SIZEOF_SYMBOL = 18;
typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short; // if 0, use LongName
            DWORD Long; // offset into string table
        } Name;
        DWORD LongName[2]; // PBYTE  [2]
    } N;
    DWORD Value;
    LONG SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX *PIMAGE_SYMBOL_EX;
//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//
static const int IMAGE_SYM_UNDEFINED = (SHORT)0;
static const int IMAGE_SYM_ABSOLUTE = (SHORT)-1;
static const int IMAGE_SYM_DEBUG = (SHORT)-2;
static const int IMAGE_SYM_SECTION_MAX = 0xFEFF;
static const int IMAGE_SYM_SECTION_MAX_EX = MAXLONG;
//
// Type (fundamental) values.
//
static const int IMAGE_SYM_TYPE_NULL = 0x0000;
static const int IMAGE_SYM_TYPE_VOID = 0x0001;
static const int IMAGE_SYM_TYPE_CHAR = 0x0002;
static const int IMAGE_SYM_TYPE_SHORT = 0x0003;
static const int IMAGE_SYM_TYPE_INT = 0x0004;
static const int IMAGE_SYM_TYPE_LONG = 0x0005;
static const int IMAGE_SYM_TYPE_FLOAT = 0x0006;
static const int IMAGE_SYM_TYPE_DOUBLE = 0x0007;
static const int IMAGE_SYM_TYPE_STRUCT = 0x0008;
static const int IMAGE_SYM_TYPE_UNION = 0x0009;
static const int IMAGE_SYM_TYPE_ENUM = 0x000A;
static const int IMAGE_SYM_TYPE_MOE = 0x000B;
static const int IMAGE_SYM_TYPE_BYTE = 0x000C;
static const int IMAGE_SYM_TYPE_WORD = 0x000D;
static const int IMAGE_SYM_TYPE_UINT = 0x000E;
static const double IMAGE_SYM_TYPE_DWORD = 0x000F;
static const int IMAGE_SYM_TYPE_PCODE = 0x8000;
//
// Type (derived) values.
//
static const int IMAGE_SYM_DTYPE_NULL = 0;
static const int IMAGE_SYM_DTYPE_POINTER = 1;
static const int IMAGE_SYM_DTYPE_FUNCTION = 2;
static const int IMAGE_SYM_DTYPE_ARRAY = 3;
//
// Storage classes.
//
static const int IMAGE_SYM_CLASS_END_OF_FUNCTION = (BYTE )-1;
static const int IMAGE_SYM_CLASS_NULL = 0x0000;
static const int IMAGE_SYM_CLASS_AUTOMATIC = 0x0001;
static const int IMAGE_SYM_CLASS_EXTERNAL = 0x0002;
static const int IMAGE_SYM_CLASS_STATIC = 0x0003;
static const int IMAGE_SYM_CLASS_REGISTER = 0x0004;
static const int IMAGE_SYM_CLASS_EXTERNAL_DEF = 0x0005;
static const int IMAGE_SYM_CLASS_LABEL = 0x0006;
static const int IMAGE_SYM_CLASS_UNDEFINED_LABEL = 0x0007;
static const int IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = 0x0008;
static const int IMAGE_SYM_CLASS_ARGUMENT = 0x0009;
static const int IMAGE_SYM_CLASS_STRUCT_TAG = 0x000A;
static const int IMAGE_SYM_CLASS_MEMBER_OF_UNION = 0x000B;
static const int IMAGE_SYM_CLASS_UNION_TAG = 0x000C;
static const int IMAGE_SYM_CLASS_TYPE_DEFINITION = 0x000D;
static const int IMAGE_SYM_CLASS_UNDEFINED_STATIC = 0x000E;
static const double IMAGE_SYM_CLASS_ENUM_TAG = 0x000F;
static const int IMAGE_SYM_CLASS_MEMBER_OF_ENUM = 0x0010;
static const int IMAGE_SYM_CLASS_REGISTER_PARAM = 0x0011;
static const int IMAGE_SYM_CLASS_BIT_FIELD = 0x0012;
static const int IMAGE_SYM_CLASS_FAR_EXTERNAL = 0x0044;
static const int IMAGE_SYM_CLASS_BLOCK = 0x0064;
static const int IMAGE_SYM_CLASS_FUNCTION = 0x0065;
static const int IMAGE_SYM_CLASS_END_OF_STRUCT = 0x0066;
static const int IMAGE_SYM_CLASS_FILE = 0x0067;
// new
static const int IMAGE_SYM_CLASS_SECTION = 0x0068;
static const int IMAGE_SYM_CLASS_WEAK_EXTERNAL = 0x0069;
static const int IMAGE_SYM_CLASS_CLR_TOKEN = 0x006B;
// type packing constants
static const double N_BTMASK = 0x000F;
static const int N_TMASK = 0x0030;
static const int N_TMASK1 = 0x00C0;
static const int N_TMASK2 = 0x00F0;
static const int N_BTSHFT = 4;
static const int N_TSHIFT = 2;
// MACROS
// Basic Type of  x
static const int BTYPE(x) = ((x) & N_BTMASK);
// Is x a pointer?
static const int ISPTR(x) = (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT));
// Is x a function?
static const int ISFCN(x) = (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT));
// Is x an array?
static const int ISARY(x) = (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT));
// Is x a structure, union, or enumeration TAG?
static const int ISTAG(x) = ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG);
static const int INCREF(x) = ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK));
static const int DECREF(x) = ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK));
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack2.h
Abstract:
    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 11471 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE bAuxType; // IMAGE_AUX_SYMBOL_TYPE
    BYTE bReserved; // Must be 0
    DWORD SymbolTableIndex;
    BYTE rgbReserved[12]; // Must be 0
} IMAGE_AUX_SYMBOL_TOKEN_DEF;
typedef IMAGE_AUX_SYMBOL_TOKEN_DEF *PIMAGE_AUX_SYMBOL_TOKEN_DEF;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 11482 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
//
// Auxiliary entry format.
//
typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD TagIndex; // struct, union, or enum tag index
        union {
            struct {
                WORD Linenumber; // declaration line number
                WORD Size; // size of struct, union, or enum
            } LnSz;
           DWORD TotalSize;
        } Misc;
        union {
            struct { // if ISFCN, tag, or .bb
                DWORD PointerToLinenumber;
                DWORD PointerToNextFunction;
            } Function;
            struct { // if ISARY, up to 4 dimen.
                WORD Dimension[4];
            } Array;
        } FcnAry;
        WORD TvIndex; // tv index
    } Sym;
    struct {
        BYTE Name[18];
    } File;
    struct {
        DWORD Length; // section length
        WORD NumberOfRelocations; // number of relocation entries
        WORD NumberOfLinenumbers; // number of line numbers
        DWORD CheckSum; // checksum for communal
        SHORT Number; // section number to associate with
        BYTE Selection; // communal selection type
 BYTE bReserved;
 SHORT HighNumber; // high bits of the section number
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOL;
typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD WeakDefaultSymIndex; // the weak extern default symbol index
        DWORD WeakSearchType;
        BYTE rgbReserved[12];
    } Sym;
    struct {
        BYTE Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD Length; // section length
        WORD NumberOfRelocations; // number of relocation entries
        WORD NumberOfLinenumbers; // number of line numbers
        DWORD CheckSum; // checksum for communal
        SHORT Number; // section number to associate with
        BYTE Selection; // communal selection type
        BYTE bReserved;
        SHORT HighNumber; // high bits of the section number
        BYTE rgbReserved[2];
    } Section;
    struct{
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE rgbReserved[2];
    };
    struct {
        DWORD crc;
        BYTE rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX *PIMAGE_AUX_SYMBOL_EX;
typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;
//
// Communal selection types.
//
static const int IMAGE_COMDAT_SELECT_NODUPLICATES = 1;
static const int IMAGE_COMDAT_SELECT_ANY = 2;
static const int IMAGE_COMDAT_SELECT_SAME_SIZE = 3;
static const int IMAGE_COMDAT_SELECT_EXACT_MATCH = 4;
static const int IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5;
static const int IMAGE_COMDAT_SELECT_LARGEST = 6;
static const int IMAGE_COMDAT_SELECT_NEWEST = 7;
static const int IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = 1;
static const int IMAGE_WEAK_EXTERN_SEARCH_LIBRARY = 2;
static const int IMAGE_WEAK_EXTERN_SEARCH_ALIAS = 3;
//
// Relocation format.
//
typedef struct _IMAGE_RELOCATION {
    union {
        DWORD VirtualAddress;
        DWORD RelocCount; // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
    } u;
    DWORD SymbolTableIndex;
    WORD Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION *PIMAGE_RELOCATION;
//
// I386 relocation types.
//
static const int IMAGE_REL_I386_ABSOLUTE = 0x0000;
static const int IMAGE_REL_I386_DIR16 = 0x0001;
static const int IMAGE_REL_I386_REL16 = 0x0002;
static const int IMAGE_REL_I386_DIR32 = 0x0006;
static const int IMAGE_REL_I386_DIR32NB = 0x0007;
static const int IMAGE_REL_I386_SEG12 = 0x0009;
static const int IMAGE_REL_I386_SECTION = 0x000A;
static const int IMAGE_REL_I386_SECREL = 0x000B;
static const int IMAGE_REL_I386_TOKEN = 0x000C;
static const int IMAGE_REL_I386_SECREL7 = 0x000D;
static const int IMAGE_REL_I386_REL32 = 0x0014;
//
// MIPS relocation types.
//
static const int IMAGE_REL_MIPS_ABSOLUTE = 0x0000;
static const int IMAGE_REL_MIPS_REFHALF = 0x0001;
static const int IMAGE_REL_MIPS_REFWORD = 0x0002;
static const int IMAGE_REL_MIPS_JMPADDR = 0x0003;
static const int IMAGE_REL_MIPS_REFHI = 0x0004;
static const int IMAGE_REL_MIPS_REFLO = 0x0005;
static const int IMAGE_REL_MIPS_GPREL = 0x0006;
static const int IMAGE_REL_MIPS_LITERAL = 0x0007;
static const int IMAGE_REL_MIPS_SECTION = 0x000A;
static const int IMAGE_REL_MIPS_SECREL = 0x000B;
static const int IMAGE_REL_MIPS_SECRELLO = 0x000C;
static const int IMAGE_REL_MIPS_SECRELHI = 0x000D;
static const int IMAGE_REL_MIPS_TOKEN = 0x000E;
static const int IMAGE_REL_MIPS_JMPADDR16 = 0x0010;
static const int IMAGE_REL_MIPS_REFWORDNB = 0x0022;
static const int IMAGE_REL_MIPS_PAIR = 0x0025;
//
// Alpha Relocation types.
//
static const int IMAGE_REL_ALPHA_ABSOLUTE = 0x0000;
static const int IMAGE_REL_ALPHA_REFLONG = 0x0001;
static const int IMAGE_REL_ALPHA_REFQUAD = 0x0002;
static const int IMAGE_REL_ALPHA_GPREL32 = 0x0003;
static const int IMAGE_REL_ALPHA_LITERAL = 0x0004;
static const int IMAGE_REL_ALPHA_LITUSE = 0x0005;
static const int IMAGE_REL_ALPHA_GPDISP = 0x0006;
static const int IMAGE_REL_ALPHA_BRADDR = 0x0007;
static const int IMAGE_REL_ALPHA_HINT = 0x0008;
static const int IMAGE_REL_ALPHA_INLINE_REFLONG = 0x0009;
static const int IMAGE_REL_ALPHA_REFHI = 0x000A;
static const int IMAGE_REL_ALPHA_REFLO = 0x000B;
static const int IMAGE_REL_ALPHA_PAIR = 0x000C;
static const int IMAGE_REL_ALPHA_MATCH = 0x000D;
static const int IMAGE_REL_ALPHA_SECTION = 0x000E;
static const double IMAGE_REL_ALPHA_SECREL = 0x000F;
static const int IMAGE_REL_ALPHA_REFLONGNB = 0x0010;
static const int IMAGE_REL_ALPHA_SECRELLO = 0x0011;
static const int IMAGE_REL_ALPHA_SECRELHI = 0x0012;
static const int IMAGE_REL_ALPHA_REFQ3 = 0x0013;
static const int IMAGE_REL_ALPHA_REFQ2 = 0x0014;
static const int IMAGE_REL_ALPHA_REFQ1 = 0x0015;
static const int IMAGE_REL_ALPHA_GPRELLO = 0x0016;
static const int IMAGE_REL_ALPHA_GPRELHI = 0x0017;
//
// IBM PowerPC relocation types.
//
static const int IMAGE_REL_PPC_ABSOLUTE = 0x0000;
static const int IMAGE_REL_PPC_ADDR64 = 0x0001;
static const int IMAGE_REL_PPC_ADDR32 = 0x0002;
static const int IMAGE_REL_PPC_ADDR24 = 0x0003;
static const int IMAGE_REL_PPC_ADDR16 = 0x0004;
static const int IMAGE_REL_PPC_ADDR14 = 0x0005;
static const int IMAGE_REL_PPC_REL24 = 0x0006;
static const int IMAGE_REL_PPC_REL14 = 0x0007;
static const int IMAGE_REL_PPC_TOCREL16 = 0x0008;
static const int IMAGE_REL_PPC_TOCREL14 = 0x0009;
static const int IMAGE_REL_PPC_ADDR32NB = 0x000A;
static const int IMAGE_REL_PPC_SECREL = 0x000B;
static const int IMAGE_REL_PPC_SECTION = 0x000C;
static const int IMAGE_REL_PPC_IFGLUE = 0x000D;
static const int IMAGE_REL_PPC_IMGLUE = 0x000E;
static const double IMAGE_REL_PPC_SECREL16 = 0x000F;
static const int IMAGE_REL_PPC_REFHI = 0x0010;
static const int IMAGE_REL_PPC_REFLO = 0x0011;
static const int IMAGE_REL_PPC_PAIR = 0x0012;
static const int IMAGE_REL_PPC_SECRELLO = 0x0013;
static const int IMAGE_REL_PPC_SECRELHI = 0x0014;
static const int IMAGE_REL_PPC_GPREL = 0x0015;
static const int IMAGE_REL_PPC_TOKEN = 0x0016;
static const int IMAGE_REL_PPC_TYPEMASK = 0x00FF;
// Flag bits in IMAGE_RELOCATION.TYPE
static const int IMAGE_REL_PPC_NEG = 0x0100;
static const int IMAGE_REL_PPC_BRTAKEN = 0x0200;
static const int IMAGE_REL_PPC_BRNTAKEN = 0x0400;
static const int IMAGE_REL_PPC_TOCDEFN = 0x0800;
//
// Hitachi SH3 relocation types.
//
static const int IMAGE_REL_SH3_ABSOLUTE = 0x0000;
static const int IMAGE_REL_SH3_DIRECT16 = 0x0001;
static const int IMAGE_REL_SH3_DIRECT32 = 0x0002;
static const int IMAGE_REL_SH3_DIRECT8 = 0x0003;
static const int IMAGE_REL_SH3_DIRECT8_WORD = 0x0004;
static const int IMAGE_REL_SH3_DIRECT8_LONG = 0x0005;
static const int IMAGE_REL_SH3_DIRECT4 = 0x0006;
static const int IMAGE_REL_SH3_DIRECT4_WORD = 0x0007;
static const int IMAGE_REL_SH3_DIRECT4_LONG = 0x0008;
static const int IMAGE_REL_SH3_PCREL8_WORD = 0x0009;
static const int IMAGE_REL_SH3_PCREL8_LONG = 0x000A;
static const int IMAGE_REL_SH3_PCREL12_WORD = 0x000B;
static const int IMAGE_REL_SH3_STARTOF_SECTION = 0x000C;
static const int IMAGE_REL_SH3_SIZEOF_SECTION = 0x000D;
static const int IMAGE_REL_SH3_SECTION = 0x000E;
static const double IMAGE_REL_SH3_SECREL = 0x000F;
static const int IMAGE_REL_SH3_DIRECT32_NB = 0x0010;
static const int IMAGE_REL_SH3_GPREL4_LONG = 0x0011;
static const int IMAGE_REL_SH3_TOKEN = 0x0012;
static const int IMAGE_REL_SHM_PCRELPT = 0x0013;
                                                //  instruction in longwords
                                                //  if not NOMODE, insert the
                                                //  inverse of the low bit at
                                                //  bit 32 to select PTA/PTB
static const int IMAGE_REL_SHM_REFLO = 0x0014;
static const int IMAGE_REL_SHM_REFHALF = 0x0015;
static const int IMAGE_REL_SHM_RELLO = 0x0016;
static const int IMAGE_REL_SHM_RELHALF = 0x0017;
static const int IMAGE_REL_SHM_PAIR = 0x0018;
static const int IMAGE_REL_SH_NOMODE = 0x8000;
static const int IMAGE_REL_ARM_ABSOLUTE = 0x0000;
static const int IMAGE_REL_ARM_ADDR32 = 0x0001;
static const int IMAGE_REL_ARM_ADDR32NB = 0x0002;
static const int IMAGE_REL_ARM_BRANCH24 = 0x0003;
static const int IMAGE_REL_ARM_BRANCH11 = 0x0004;
static const int IMAGE_REL_ARM_TOKEN = 0x0005;
static const int IMAGE_REL_ARM_GPREL12 = 0x0006;
static const int IMAGE_REL_ARM_GPREL7 = 0x0007;
static const int IMAGE_REL_ARM_BLX24 = 0x0008;
static const int IMAGE_REL_ARM_BLX11 = 0x0009;
static const int IMAGE_REL_ARM_SECTION = 0x000E;
static const double IMAGE_REL_ARM_SECREL = 0x000F;
static const int IMAGE_REL_AM_ABSOLUTE = 0x0000;
static const int IMAGE_REL_AM_ADDR32 = 0x0001;
static const int IMAGE_REL_AM_ADDR32NB = 0x0002;
static const int IMAGE_REL_AM_CALL32 = 0x0003;
static const int IMAGE_REL_AM_FUNCINFO = 0x0004;
static const int IMAGE_REL_AM_REL32_1 = 0x0005;
static const int IMAGE_REL_AM_REL32_2 = 0x0006;
static const int IMAGE_REL_AM_SECREL = 0x0007;
static const int IMAGE_REL_AM_SECTION = 0x0008;
static const int IMAGE_REL_AM_TOKEN = 0x0009;
//
// x64 relocations
//
static const int IMAGE_REL_AMD64_ABSOLUTE = 0x0000;
static const int IMAGE_REL_AMD64_ADDR64 = 0x0001;
static const int IMAGE_REL_AMD64_ADDR32 = 0x0002;
static const int IMAGE_REL_AMD64_ADDR32NB = 0x0003;
static const int IMAGE_REL_AMD64_REL32 = 0x0004;
static const int IMAGE_REL_AMD64_REL32_1 = 0x0005;
static const int IMAGE_REL_AMD64_REL32_2 = 0x0006;
static const int IMAGE_REL_AMD64_REL32_3 = 0x0007;
static const int IMAGE_REL_AMD64_REL32_4 = 0x0008;
static const int IMAGE_REL_AMD64_REL32_5 = 0x0009;
static const int IMAGE_REL_AMD64_SECTION = 0x000A;
static const int IMAGE_REL_AMD64_SECREL = 0x000B;
static const int IMAGE_REL_AMD64_SECREL7 = 0x000C;
static const int IMAGE_REL_AMD64_TOKEN = 0x000D;
static const int IMAGE_REL_AMD64_SREL32 = 0x000E;
static const double IMAGE_REL_AMD64_PAIR = 0x000F;
static const int IMAGE_REL_AMD64_SSPAN32 = 0x0010;
//
// IA64 relocation types.
//
static const int IMAGE_REL_IA64_ABSOLUTE = 0x0000;
static const int IMAGE_REL_IA64_IMM14 = 0x0001;
static const int IMAGE_REL_IA64_IMM22 = 0x0002;
static const int IMAGE_REL_IA64_IMM64 = 0x0003;
static const int IMAGE_REL_IA64_DIR32 = 0x0004;
static const int IMAGE_REL_IA64_DIR64 = 0x0005;
static const int IMAGE_REL_IA64_PCREL21B = 0x0006;
static const int IMAGE_REL_IA64_PCREL21M = 0x0007;
static const int IMAGE_REL_IA64_PCREL21F = 0x0008;
static const int IMAGE_REL_IA64_GPREL22 = 0x0009;
static const int IMAGE_REL_IA64_LTOFF22 = 0x000A;
static const int IMAGE_REL_IA64_SECTION = 0x000B;
static const int IMAGE_REL_IA64_SECREL22 = 0x000C;
static const int IMAGE_REL_IA64_SECREL64I = 0x000D;
static const int IMAGE_REL_IA64_SECREL32 = 0x000E;
//
static const int IMAGE_REL_IA64_DIR32NB = 0x0010;
static const int IMAGE_REL_IA64_SREL14 = 0x0011;
static const int IMAGE_REL_IA64_SREL22 = 0x0012;
static const int IMAGE_REL_IA64_SREL32 = 0x0013;
static const int IMAGE_REL_IA64_UREL32 = 0x0014;
static const int IMAGE_REL_IA64_PCREL60X = 0x0015;
static const int IMAGE_REL_IA64_PCREL60B = 0x0016;
static const int IMAGE_REL_IA64_PCREL60F = 0x0017;
static const int IMAGE_REL_IA64_PCREL60I = 0x0018;
static const int IMAGE_REL_IA64_PCREL60M = 0x0019;
static const int IMAGE_REL_IA64_IMMGPREL64 = 0x001A;
static const int IMAGE_REL_IA64_TOKEN = 0x001B;
static const int IMAGE_REL_IA64_GPREL32 = 0x001C;
static const double IMAGE_REL_IA64_ADDEND = 0x001F;
//
// CEF relocation types.
//
static const int IMAGE_REL_CEF_ABSOLUTE = 0x0000;
static const int IMAGE_REL_CEF_ADDR32 = 0x0001;
static const int IMAGE_REL_CEF_ADDR64 = 0x0002;
static const int IMAGE_REL_CEF_ADDR32NB = 0x0003;
static const int IMAGE_REL_CEF_SECTION = 0x0004;
static const int IMAGE_REL_CEF_SECREL = 0x0005;
static const int IMAGE_REL_CEF_TOKEN = 0x0006;
//
// clr relocation types.
//
static const int IMAGE_REL_CEE_ABSOLUTE = 0x0000;
static const int IMAGE_REL_CEE_ADDR32 = 0x0001;
static const int IMAGE_REL_CEE_ADDR64 = 0x0002;
static const int IMAGE_REL_CEE_ADDR32NB = 0x0003;
static const int IMAGE_REL_CEE_SECTION = 0x0004;
static const int IMAGE_REL_CEE_SECREL = 0x0005;
static const int IMAGE_REL_CEE_TOKEN = 0x0006;
static const int IMAGE_REL_M32R_ABSOLUTE = 0x0000;
static const int IMAGE_REL_M32R_ADDR32 = 0x0001;
static const int IMAGE_REL_M32R_ADDR32NB = 0x0002;
static const int IMAGE_REL_M32R_ADDR24 = 0x0003;
static const int IMAGE_REL_M32R_GPREL16 = 0x0004;
static const int IMAGE_REL_M32R_PCREL24 = 0x0005;
static const int IMAGE_REL_M32R_PCREL16 = 0x0006;
static const int IMAGE_REL_M32R_PCREL8 = 0x0007;
static const int IMAGE_REL_M32R_REFHALF = 0x0008;
static const int IMAGE_REL_M32R_REFHI = 0x0009;
static const int IMAGE_REL_M32R_REFLO = 0x000A;
static const int IMAGE_REL_M32R_PAIR = 0x000B;
static const int IMAGE_REL_M32R_SECTION = 0x000C;
static const int IMAGE_REL_M32R_SECREL32 = 0x000D;
static const int IMAGE_REL_M32R_TOKEN = 0x000E;
static const int IMAGE_REL_EBC_ABSOLUTE = 0x0000;
static const int IMAGE_REL_EBC_ADDR32NB = 0x0001;
static const int IMAGE_REL_EBC_REL32 = 0x0002;
static const int IMAGE_REL_EBC_SECTION = 0x0003;
static const int IMAGE_REL_EBC_SECREL = 0x0004;
static const int EXT_IMM64(Value,Address,Size,InstPos,ValPos) = Value |= (((ULONGLONG)((*(Address) >> InstPos) & (((ULONGLONG)1 << Size) - 1))) << ValPos);
static const int INS_IMM64(Value,Address,Size,InstPos,ValPos) = *(PDWORD)Address = (*(PDWORD)Address & ~(((1 << Size) - 1) << InstPos)) | ((DWORD)((((ULONGLONG)Value >> ValPos) & (((ULONGLONG)1 << Size) - 1))) << InstPos);
static const int EMARCH_ENC_I17_IMM7B_INST_WORD_X = 3;
static const int EMARCH_ENC_I17_IMM7B_SIZE_X = 7;
static const int EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X = 4;
static const int EMARCH_ENC_I17_IMM7B_VAL_POS_X = 0;
static const int EMARCH_ENC_I17_IMM9D_INST_WORD_X = 3;
static const int EMARCH_ENC_I17_IMM9D_SIZE_X = 9;
static const int EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X = 18;
static const int EMARCH_ENC_I17_IMM9D_VAL_POS_X = 7;
static const int EMARCH_ENC_I17_IMM5C_INST_WORD_X = 3;
static const int EMARCH_ENC_I17_IMM5C_SIZE_X = 5;
static const int EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X = 13;
static const int EMARCH_ENC_I17_IMM5C_VAL_POS_X = 16;
static const int EMARCH_ENC_I17_IC_INST_WORD_X = 3;
static const int EMARCH_ENC_I17_IC_SIZE_X = 1;
static const int EMARCH_ENC_I17_IC_INST_WORD_POS_X = 12;
static const int EMARCH_ENC_I17_IC_VAL_POS_X = 21;
static const int EMARCH_ENC_I17_IMM41a_INST_WORD_X = 1;
static const int EMARCH_ENC_I17_IMM41a_SIZE_X = 10;
static const int EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X = 14;
static const int EMARCH_ENC_I17_IMM41a_VAL_POS_X = 22;
static const int EMARCH_ENC_I17_IMM41b_INST_WORD_X = 1;
static const int EMARCH_ENC_I17_IMM41b_SIZE_X = 8;
static const int EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X = 24;
static const int EMARCH_ENC_I17_IMM41b_VAL_POS_X = 32;
static const int EMARCH_ENC_I17_IMM41c_INST_WORD_X = 2;
static const int EMARCH_ENC_I17_IMM41c_SIZE_X = 23;
static const int EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X = 0;
static const int EMARCH_ENC_I17_IMM41c_VAL_POS_X = 40;
static const int EMARCH_ENC_I17_SIGN_INST_WORD_X = 3;
static const int EMARCH_ENC_I17_SIGN_SIZE_X = 1;
static const int EMARCH_ENC_I17_SIGN_INST_WORD_POS_X = 27;
static const int EMARCH_ENC_I17_SIGN_VAL_POS_X = 63;
static const int X3_OPCODE_INST_WORD_X = 3;
static const int X3_OPCODE_SIZE_X = 4;
static const int X3_OPCODE_INST_WORD_POS_X = 28;
static const int X3_OPCODE_SIGN_VAL_POS_X = 0;
static const int X3_I_INST_WORD_X = 3;
static const int X3_I_SIZE_X = 1;
static const int X3_I_INST_WORD_POS_X = 27;
static const int X3_I_SIGN_VAL_POS_X = 59;
static const int X3_D_WH_INST_WORD_X = 3;
static const int X3_D_WH_SIZE_X = 3;
static const int X3_D_WH_INST_WORD_POS_X = 24;
static const int X3_D_WH_SIGN_VAL_POS_X = 0;
static const int X3_IMM20_INST_WORD_X = 3;
static const int X3_IMM20_SIZE_X = 20;
static const int X3_IMM20_INST_WORD_POS_X = 4;
static const int X3_IMM20_SIGN_VAL_POS_X = 0;
static const int X3_IMM39_1_INST_WORD_X = 2;
static const int X3_IMM39_1_SIZE_X = 23;
static const int X3_IMM39_1_INST_WORD_POS_X = 0;
static const int X3_IMM39_1_SIGN_VAL_POS_X = 36;
static const int X3_IMM39_2_INST_WORD_X = 1;
static const int X3_IMM39_2_SIZE_X = 16;
static const int X3_IMM39_2_INST_WORD_POS_X = 16;
static const int X3_IMM39_2_SIGN_VAL_POS_X = 20;
static const int X3_P_INST_WORD_X = 3;
static const int X3_P_SIZE_X = 4;
static const int X3_P_INST_WORD_POS_X = 0;
static const int X3_P_SIGN_VAL_POS_X = 0;
static const int X3_TMPLT_INST_WORD_X = 0;
static const int X3_TMPLT_SIZE_X = 4;
static const int X3_TMPLT_INST_WORD_POS_X = 0;
static const int X3_TMPLT_SIGN_VAL_POS_X = 0;
static const int X3_BTYPE_QP_INST_WORD_X = 2;
static const int X3_BTYPE_QP_SIZE_X = 9;
static const int X3_BTYPE_QP_INST_WORD_POS_X = 23;
static const int X3_BTYPE_QP_INST_VAL_POS_X = 0;
static const int X3_EMPTY_INST_WORD_X = 1;
static const int X3_EMPTY_SIZE_X = 2;
static const int X3_EMPTY_INST_WORD_POS_X = 14;
static const int X3_EMPTY_INST_VAL_POS_X = 0;
//
// Line number format.
//
typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD SymbolTableIndex; // Symbol table index of function name if Linenumber is 0.
        DWORD VirtualAddress; // Virtual address of line number.
    } Type;
    WORD Linenumber; // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER *PIMAGE_LINENUMBER;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 11967 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
//
// Based relocation format.
//
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION * PIMAGE_BASE_RELOCATION;
//
// Based relocation types.
//
static const int IMAGE_REL_BASED_ABSOLUTE = 0;
static const int IMAGE_REL_BASED_HIGH = 1;
static const int IMAGE_REL_BASED_LOW = 2;
static const int IMAGE_REL_BASED_HIGHLOW = 3;
static const int IMAGE_REL_BASED_HIGHADJ = 4;
static const int IMAGE_REL_BASED_MIPS_JMPADDR = 5;
static const int IMAGE_REL_BASED_MIPS_JMPADDR16 = 9;
static const int IMAGE_REL_BASED_IA64_IMM64 = 9;
static const int IMAGE_REL_BASED_DIR64 = 10;
//
// Archive format.
//
static const int IMAGE_ARCHIVE_START_SIZE = 8;
static const char IMAGE_ARCHIVE_START = "!<arch>\n";
static const char IMAGE_ARCHIVE_END = "`\n";
static const char IMAGE_ARCHIVE_PAD = "\n";
static const char IMAGE_ARCHIVE_LINKER_MEMBER = "/               ";
static const int IMAGE_ARCHIVE_LONGNAMES_MEMBER = ";  //              "
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE Name[16]; // File member name - `/' terminated.
    BYTE Date[12]; // File member date - decimal.
    BYTE UserID[6]; // File member user id - decimal.
    BYTE GroupID[6]; // File member group id - decimal.
    BYTE Mode[8]; // File member mode - octal.
    BYTE Size[10]; // File member size - decimal.
    BYTE EndHeader[2]; // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
static const int IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60;
//
// DLL support.
//
//
// Export Format
//
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions; // RVA from base of image
    DWORD AddressOfNames; // RVA from base of image
    DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
//
// Import Format
//
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    BYTE Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack8.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack8.h
Abstract:
    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack8.h"
#pragma pack(8)
# 12050 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString; // PBYTE 
        ULONGLONG Function; // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 12062 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString; // PBYTE 
        DWORD Function; // PDWORD
        DWORD Ordinal;
        DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
static const int IMAGE_ORDINAL_FLAG64 = 0x8000000000000000;
static const int IMAGE_ORDINAL_FLAG32 = 0x80000000;
static const int IMAGE_ORDINAL64(Ordinal) = (Ordinal & 0xffff);
static const int IMAGE_ORDINAL32(Ordinal) = (Ordinal & 0xffff);
static const int IMAGE_SNAP_BY_ORDINAL64(Ordinal) = ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0);
static const int IMAGE_SNAP_BY_ORDINAL32(Ordinal) = ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0);
//
// Thread Local Storage
//
typedef void
( *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );
typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex; // PDWORD
    ULONGLONG AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *;
    DWORD SizeOfZeroFill;
    DWORD Characteristics;
} IMAGE_TLS_DIRECTORY64;
typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;
typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD StartAddressOfRawData;
    DWORD EndAddressOfRawData;
    DWORD AddressOfIndex; // PDWORD
    DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *
    DWORD SizeOfZeroFill;
    DWORD Characteristics;
} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;
static const int IMAGE_ORDINAL_FLAG = IMAGE_ORDINAL_FLAG64;
static const int IMAGE_ORDINAL(Ordinal) = IMAGE_ORDINAL64(Ordinal);
typedef IMAGE_THUNK_DATA64 IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64 PIMAGE_THUNK_DATA;
static const int IMAGE_SNAP_BY_ORDINAL(Ordinal) = IMAGE_SNAP_BY_ORDINAL64(Ordinal);
typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;
# 12129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics; // 0 for terminating null import descriptor
        DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } u;
    DWORD TimeDateStamp; // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)
    DWORD ForwarderChain; // -1 if no forwarders
    DWORD Name;
    DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR *PIMAGE_IMPORT_DESCRIPTOR;
//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//
typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;
//
// Resource Format.
//
//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//
typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    WORD NumberOfNamedEntries;
    WORD NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
static const int IMAGE_RESOURCE_NAME_IS_STRING = 0x80000000;
static const int IMAGE_RESOURCE_DATA_IS_DIRECTORY = 0x80000000;
//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//
typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } s;
        DWORD Name;
        WORD Id;
    } u;
    union {
        DWORD OffsetToData;
        struct {
            DWORD OffsetToDirectory:31;
            DWORD DataIsDirectory:1;
        } s2;
    } u2;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;
//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD Length;
    CHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD Length;
    WCHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;
//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;
//
// Load Configuration Directory Entry
//
typedef struct {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    DWORD DeCommitFreeBlockThreshold;
    DWORD DeCommitTotalFreeThreshold;
    DWORD LockPrefixTable; // VA
    DWORD MaximumAllocationSize;
    DWORD VirtualMemoryThreshold;
    DWORD ProcessHeapFlags;
    DWORD ProcessAffinityMask;
    WORD CSDVersion;
    WORD Reserved1;
    DWORD EditList; // VA
    DWORD SecurityCookie; // VA
    DWORD SEHandlerTable; // VA
    DWORD SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;
typedef struct {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    ULONGLONG DeCommitFreeBlockThreshold;
    ULONGLONG DeCommitTotalFreeThreshold;
    ULONGLONG LockPrefixTable; // VA
    ULONGLONG MaximumAllocationSize;
    ULONGLONG VirtualMemoryThreshold;
    ULONGLONG ProcessAffinityMask;
    DWORD ProcessHeapFlags;
    WORD CSDVersion;
    WORD Reserved1;
    ULONGLONG EditList; // VA
    ULONGLONG SecurityCookie; // VA
    ULONGLONG SEHandlerTable; // VA
    ULONGLONG SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;
typedef IMAGE_LOAD_CONFIG_DIRECTORY64 IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64 PIMAGE_LOAD_CONFIG_DIRECTORY;
//
// WIN CE Exception table format
//
//
// Function table entry format.  Function table is pointed to by the
// IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
//
typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindInfoAddress;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
# 12376 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;
//
// Debug Format
//
typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Type;
    DWORD SizeOfData;
    DWORD AddressOfRawData;
    DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;
static const int IMAGE_DEBUG_TYPE_UNKNOWN = 0;
static const int IMAGE_DEBUG_TYPE_COFF = 1;
static const int IMAGE_DEBUG_TYPE_CODEVIEW = 2;
static const int IMAGE_DEBUG_TYPE_FPO = 3;
static const int IMAGE_DEBUG_TYPE_MISC = 4;
static const int IMAGE_DEBUG_TYPE_EXCEPTION = 5;
static const int IMAGE_DEBUG_TYPE_FIXUP = 6;
static const int IMAGE_DEBUG_TYPE_OMAP_TO_SRC = 7;
static const int IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = 8;
static const int IMAGE_DEBUG_TYPE_BORLAND = 9;
static const int IMAGE_DEBUG_TYPE_RESERVED10 = 10;
static const int IMAGE_DEBUG_TYPE_CLSID = 11;
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD NumberOfSymbols;
    DWORD LvaToFirstSymbol;
    DWORD NumberOfLinenumbers;
    DWORD LvaToFirstLinenumber;
    DWORD RvaToFirstByteOfCode;
    DWORD RvaToLastByteOfCode;
    DWORD RvaToFirstByteOfData;
    DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;
static const int FRAME_FPO = 0;
static const int FRAME_TRAP = 1;
static const int FRAME_TSS = 2;
static const int FRAME_NONFPO = 3;
typedef struct _FPO_DATA {
    DWORD ulOffStart; // offset 1st byte of function code
    DWORD cbProcSize; // # bytes in function
    DWORD cdwLocals; // # bytes in locals/4
    WORD cdwParams; // # bytes in params/4
    WORD cbProlog : 8; // # bytes in prolog
    WORD cbRegs : 3; // # regs saved
    WORD fHasSEH : 1; // TRUE if SEH in func
    WORD fUseBP : 1; // TRUE if EBP has been allocated
    WORD reserved : 1; // reserved for future use
    WORD cbFrame : 2; // frame type
} FPO_DATA, *PFPO_DATA;
static const int SIZEOF_RFPO_DATA = 16;
static const int IMAGE_DEBUG_MISC_EXENAME = 1;
typedef struct _IMAGE_DEBUG_MISC {
    DWORD DataType; // type of misc data, see defines
    DWORD Length; // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN Unicode; // TRUE if data is unicode string
    BYTE Reserved[ 3 ];
    BYTE Data[ 1 ]; // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;
//
// Function table extracted from MIPS/ALPHA/IA64 images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//
typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;
typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG StartingAddress;
    ULONGLONG EndingAddress;
    union {
        ULONGLONG EndOfPrologue;
        ULONGLONG UnwindInfoAddress;
    } u;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;
//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD Signature;
    WORD Flags;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;
    DWORD NumberOfSections;
    DWORD ExportedNamesSize;
    DWORD DebugDirectorySize;
    DWORD SectionAlignment;
    DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;
typedef struct _NON_PAGED_DEBUG_INFO {
    WORD Signature;
    WORD Flags;
    DWORD Size;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD SizeOfImage;
    ULONGLONG ImageBase;
    //DebugDirectorySize
    //IMAGE_DEBUG_DIRECTORY
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;
static const int IMAGE_SEPARATE_DEBUG_SIGNATURE = 0x4944;
static const int NON_PAGED_DEBUG_SIGNATURE = 0x494E;
static const int IMAGE_SEPARATE_DEBUG_FLAGS_MASK = 0x8000;
static const int IMAGE_SEPARATE_DEBUG_MISMATCH = 0x8000;
                                                // old checksum didn't match.
//
//  The .arch section is made up of headers, each describing an amask position/value
//  pointing to an array of IMAGE_ARCHITECTURE_ENTRY's.  Each "array" (both the header
//  and entry arrays) are terminiated by a quadword of 0xffffffffL.
//
//  NOTE: There may be quadwords of 0 sprinkled around and must be skipped.
//
typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1; // 1 -> code section depends on mask bit
                                                // 0 -> new instruction depends on mask bit
    int :7; // MBZ
    unsigned int AmaskShift: 8; // Amask bit in question for this fixup
    int :16; // MBZ
    DWORD FirstEntryRVA; // RVA into .arch section to array of ARCHITECTURE_ENTRY's
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;
typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA; // RVA of instruction to fixup
    DWORD NewInst; // fixup instruction (see alphaops.h)
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 12559 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
// The following structure defines the new import object.  Note the values of the first two fields,
// which must be set as stated in order to differentiate old and new import members.
// Following this structure, the linker emits two null-terminated strings used to recreate the
// import at the time of use.  The first string is the import's name, the second is the dll's name.
static const int IMPORT_OBJECT_HDR_SIG2 = 0xffff;
typedef struct IMPORT_OBJECT_HEADER {
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be IMPORT_OBJECT_HDR_SIG2.
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp; // Time/date stamp
    DWORD SizeOfData; // particularly useful for incremental links
    union {
        WORD Ordinal; // if grf & IMPORT_OBJECT_ORDINAL
        WORD Hint;
    } u;
    WORD Type : 2; // IMPORT_TYPE
    WORD NameType : 3; // IMPORT_NAME_TYPE
    WORD Reserved : 11; // Reserved. Must be zero.
} IMPORT_OBJECT_HEADER;
typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;
typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0, // Import by ordinal
    IMPORT_OBJECT_NAME = 1, // Import name == public symbol name.
    IMPORT_OBJECT_NAME_NO_PREFIX = 2, // Import name == public symbol name skipping leading ?, @, or optionally _.
    IMPORT_OBJECT_NAME_UNDECORATE = 3, // Import name == public symbol name skipping leading ?, @, or optionally _
                                        // and truncating at first @
} IMPORT_OBJECT_NAME_TYPE;
typedef enum ReplacesCorHdrNumericDefines
{
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA =0x00010000,
// Version flags for image.
    COR_VERSION_MAJOR_V2 =2,
    COR_VERSION_MAJOR =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR =0,
    COR_DELETED_NAME_LENGTH =8,
    COR_VTABLEGAP_NAME_LENGTH =8,
// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,
// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA =0x01,
    IMAGE_COR_MIH_EHRVA =0x02,
    IMAGE_COR_MIH_BASICBLOCK =0x08,
// V-table constants
    COR_VTABLE_32BIT =0x01, // V-table slots are 32-bits in size.
    COR_VTABLE_64BIT =0x02, // V-table slots are 64-bits in size.
    COR_VTABLE_FROM_UNMANAGED =0x04, // If set, transition from unmanaged.
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN =0x08, // If set, transition from unmanaged with keeping the current appdomain.
    COR_VTABLE_CALL_MOST_DERIVED =0x10, // Call most derived method described by
// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE =32, // Size of a jump thunk reserved range.
// Max name lengths
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME =1024,
    MAX_PACKAGE_NAME =1024,
} ReplacesCorHdrNumericDefines;
// CLR 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    DWORD cb;
    WORD MajorRuntimeVersion;
    WORD MinorRuntimeVersion;
    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY MetaData;
    DWORD Flags;
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.
    union {
        DWORD EntryPointToken;
        DWORD EntryPointRVA;
    } u;
    // Binding information
    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;
    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY CodeManagerTable;
    IMAGE_DATA_DIRECTORY VTableFixups;
    IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY ManagedNativeHeader;
} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;
//
// End Image Format
//
//
// for move macros
//
# 12699 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//
#pragma warning(push)
#pragma warning(disable:4324)
typedef struct _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)
typedef struct _SLIST_ENTRY32 {
    DWORD Next;
} SLIST_ENTRY32, *PSLIST_ENTRY32;
# 12736 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef union _SLIST_HEADER {
    struct { // original struct
        ULONGLONG Alignment;
        ULONGLONG Region;
    } s;
    struct { // 8-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:9;
        ULONGLONG NextEntry:39;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1; // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:59;
        ULONGLONG Region:3;
    } Header8;
    struct { // ia64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1; // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:2;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } Header16;
    struct { // x64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Reserved:3;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;
typedef union _SLIST_HEADER32{
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY32 Next;
        WORD Depth;
        WORD Sequence;
    } s;
} SLIST_HEADER32, *PSLIST_HEADER32;
# 12794 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
void
RtlInitializeSListHead (
    PSLIST_HEADER ListHead
    );
PSLIST_ENTRY
RtlFirstEntrySList (
    const SLIST_HEADER *ListHead
    );
PSLIST_ENTRY
RtlInterlockedPopEntrySList (
    PSLIST_HEADER ListHead
    );
PSLIST_ENTRY
RtlInterlockedPushEntrySList (
    PSLIST_HEADER ListHead,
    PSLIST_ENTRY ListEntry
    );
PSLIST_ENTRY
RtlInterlockedFlushSList (
    PSLIST_HEADER ListHead
    );
WORD
RtlQueryDepthSList (
    PSLIST_HEADER ListHead
    );
# 12849 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
// begin_ntddk
//
// Run once
//
static const int RTL_RUN_ONCE_INIT = {0};
//
// Run once flags
//
static const int RTL_RUN_ONCE_CHECK_ONLY = 0x00000001UL;
static const int RTL_RUN_ONCE_ASYNC = 0x00000002UL;
static const int RTL_RUN_ONCE_INIT_FAILED = 0x00000004UL;
//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//
static const int RTL_RUN_ONCE_CTX_RESERVED_BITS = 2;
typedef union _RTL_RUN_ONCE {
    PVOID Ptr;
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;
typedef
DWORD /* LOGICAL */
RTL_RUN_ONCE_INIT_FN (
    PRTL_RUN_ONCE RunOnce,
    PVOID Parameter,
    PVOID *Context
    );
typedef RTL_RUN_ONCE_INIT_FN *PRTL_RUN_ONCE_INIT_FN;
void
RtlRunOnceInitialize (
    PRTL_RUN_ONCE RunOnce
    );
DWORD
RtlRunOnceExecuteOnce (
    PRTL_RUN_ONCE RunOnce,
    PRTL_RUN_ONCE_INIT_FN InitFn,
    PVOID Parameter,
    PVOID *Context
    );
DWORD
RtlRunOnceBeginInitialize (
    PRTL_RUN_ONCE RunOnce,
    DWORD Flags,
    PVOID *Context
    );
DWORD
RtlRunOnceComplete (
    PRTL_RUN_ONCE RunOnce,
    DWORD Flags,
    PVOID Context
    );
static const int HEAP_NO_SERIALIZE = 0x00000001;
static const int HEAP_GROWABLE = 0x00000002;
static const int HEAP_GENERATE_EXCEPTIONS = 0x00000004;
static const int HEAP_ZERO_MEMORY = 0x00000008;
static const int HEAP_REALLOC_IN_PLACE_ONLY = 0x00000010;
static const int HEAP_TAIL_CHECKING_ENABLED = 0x00000020;
static const int HEAP_FREE_CHECKING_ENABLED = 0x00000040;
static const int HEAP_DISABLE_COALESCE_ON_FREE = 0x00000080;
static const int HEAP_CREATE_ALIGN_16 = 0x00010000;
static const int HEAP_CREATE_ENABLE_TRACING = 0x00020000;
static const int HEAP_CREATE_ENABLE_EXECUTE = 0x00040000;
static const int HEAP_MAXIMUM_TAG = 0x0FFF;
static const int HEAP_PSEUDO_TAG_FLAG = 0x8000;
static const int HEAP_TAG_SHIFT = 18;
__inline
DWORD
HEAP_MAKE_TAG_FLAGS (
    DWORD TagBase,
    DWORD Tag
    )
{
    ;
    return ((DWORD)((TagBase) + ((Tag) << 18)));
}
WORD
RtlCaptureStackBackTrace(
    DWORD FramesToSkip,
    DWORD FramesToCapture,
    PVOID *BackTrace,
    PDWORD BackTraceHash
   );
void
RtlCaptureContext (
    PCONTEXT ContextRecord
    );
static const int IS_TEXT_UNICODE_ASCII16 = 0x0001;
static const int IS_TEXT_UNICODE_REVERSE_ASCII16 = 0x0010;
static const int IS_TEXT_UNICODE_STATISTICS = 0x0002;
static const int IS_TEXT_UNICODE_REVERSE_STATISTICS = 0x0020;
static const int IS_TEXT_UNICODE_CONTROLS = 0x0004;
static const int IS_TEXT_UNICODE_REVERSE_CONTROLS = 0x0040;
static const int IS_TEXT_UNICODE_SIGNATURE = 0x0008;
static const int IS_TEXT_UNICODE_REVERSE_SIGNATURE = 0x0080;
static const int IS_TEXT_UNICODE_ILLEGAL_CHARS = 0x0100;
static const int IS_TEXT_UNICODE_ODD_LENGTH = 0x0200;
static const int IS_TEXT_UNICODE_DBCS_LEADBYTE = 0x0400;
static const int IS_TEXT_UNICODE_NULL_BYTES = 0x1000;
static const double IS_TEXT_UNICODE_UNICODE_MASK = 0x000F;
static const int IS_TEXT_UNICODE_REVERSE_MASK = 0x00F0;
static const int IS_TEXT_UNICODE_NOT_UNICODE_MASK = 0x0F00;
static const int IS_TEXT_UNICODE_NOT_ASCII_MASK = 0xF000;
static const int COMPRESSION_FORMAT_NONE = (0x0000);
static const int COMPRESSION_FORMAT_DEFAULT = (0x0001);
static const int COMPRESSION_FORMAT_LZNT1 = (0x0002);
static const int COMPRESSION_ENGINE_STANDARD = (0x0000);
static const int COMPRESSION_ENGINE_MAXIMUM = (0x0100);
static const int COMPRESSION_ENGINE_HIBER = (0x0200);
# 13042 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
SIZE_T
RtlCompareMemory (
    const void *Source1,
    const void *Source2,
    SIZE_T Length
    );
static const int RtlEqualMemory(Destination,Source,Length) = (!memcmp((Destination),(Source),(Length)));
static const int RtlMoveMemory(Destination,Source,Length) = memmove((Destination),(Source),(Length));
static const int RtlCopyMemory(Destination,Source,Length) = memcpy((Destination),(Source),(Length));
static const int RtlFillMemory(Destination,Length,Fill) = memset((Destination),(Fill),(Length));
static const int RtlZeroMemory(Destination,Length) = memset((Destination),0,(Length));
__inline
PVOID
RtlSecureZeroMemory(
    PVOID ptr,
    SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
    return ptr;
}
static const int SEF_DACL_AUTO_INHERIT = 0x01;
static const int SEF_SACL_AUTO_INHERIT = 0x02;
static const int SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT = 0x04;
static const int SEF_AVOID_PRIVILEGE_CHECK = 0x08;
static const int SEF_AVOID_OWNER_CHECK = 0x10;
static const int SEF_DEFAULT_OWNER_FROM_PARENT = 0x20;
static const int SEF_DEFAULT_GROUP_FROM_PARENT = 0x40;
static const int SEF_MACL_NO_WRITE_UP = 0x100;
static const int SEF_MACL_NO_READ_UP = 0x200;
static const int SEF_MACL_NO_EXECUTE_UP = 0x400;
static const int SEF_AVOID_OWNER_RESTRICTION = 0x1000;
static const int SEF_MACL_VALID_FLAGS = (SEF_MACL_NO_WRITE_UP | SEF_MACL_NO_READ_UP | SEF_MACL_NO_EXECUTE_UP);
typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD Length;
    WORD Flags;
    BYTE Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;
static const int MESSAGE_RESOURCE_UNICODE = 0x0001;
typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;
typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;
PVOID
RtlPcToFileHeader(
    PVOID PcValue,
    PVOID *BaseOfImage
    );
typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
//
// RtlVerifyVersionInfo() conditions
//
static const int VER_EQUAL = 1;
static const int VER_GREATER = 2;
static const int VER_GREATER_EQUAL = 3;
static const int VER_LESS = 4;
static const int VER_LESS_EQUAL = 5;
static const int VER_AND = 6;
static const int VER_OR = 7;
static const int VER_CONDITION_MASK = 7;
static const int VER_NUM_BITS_PER_CONDITION_MASK = 3;
//
// RtlVerifyVersionInfo() type mask bits
//
static const int VER_MINORVERSION = 0x0000001;
static const int VER_MAJORVERSION = 0x0000002;
static const int VER_BUILDNUMBER = 0x0000004;
static const int VER_PLATFORMID = 0x0000008;
static const int VER_SERVICEPACKMINOR = 0x0000010;
static const int VER_SERVICEPACKMAJOR = 0x0000020;
static const int VER_SUITENAME = 0x0000040;
static const int VER_PRODUCT_TYPE = 0x0000080;
//
// RtlVerifyVersionInfo() os product type values
//
static const int VER_NT_WORKSTATION = 0x0000001;
static const int VER_NT_DOMAIN_CONTROLLER = 0x0000002;
static const int VER_NT_SERVER = 0x0000003;
//
// dwPlatformId defines:
//
static const int VER_PLATFORM_WIN32s = 0;
static const int VER_PLATFORM_WIN32_WINDOWS = 1;
static const int VER_PLATFORM_WIN32_NT = 2;
//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//
static const int VER_SET_CONDITION(_m_,_t_,_c_) = ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)));
ULONGLONG
VerSetConditionMask(
    ULONGLONG ConditionMask,
    DWORD TypeMask,
    BYTE Condition
    );
//
BOOLEAN
RtlGetProductInfo(
    DWORD OSMajorVersion,
    DWORD OSMinorVersion,
    DWORD SpMajorVersion,
    DWORD SpMinorVersion,
    PDWORD ReturnedProductType
    );
static const int RTL_UMS_VERSION = (0x0100);
typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;
typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;
typedef
void
RTL_UMS_SCHEDULER_ENTRY_POINT(
    RTL_UMS_SCHEDULER_REASON Reason,
    ULONG_PTR ActivationPayload,
    PVOID SchedulerParam
    );
typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
DWORD
RtlCopyExtendedContext (
    PCONTEXT_EX Destination,
    DWORD ContextFlags,
    PCONTEXT_EX Source
    );
DWORD
RtlInitializeExtendedContext (
    PVOID Context,
    DWORD ContextFlags,
    PCONTEXT_EX* ContextEx
    );
DWORD64
RtlGetEnabledExtendedFeatures (
    DWORD64 FeatureMask
    );
DWORD
RtlGetExtendedContextLength (
    DWORD ContextFlags,
    PDWORD ContextLength
    );
DWORD64
RtlGetExtendedFeaturesMask (
    PCONTEXT_EX ContextEx
    );
PVOID
RtlLocateExtendedFeature (
    PCONTEXT_EX ContextEx,
    DWORD FeatureId,
    PDWORD Length
    );
PCONTEXT
RtlLocateLegacyContext (
    PCONTEXT_EX ContextEx,
    PDWORD Length
    );
void
RtlSetExtendedFeaturesMask (
    PCONTEXT_EX ContextEx,
    DWORD64 FeatureMask
    );
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;
static const int RTL_CRITSECT_TYPE = 0;
static const int RTL_RESOURCE_TYPE = 1;
//
// These flags define the upper byte of the critical section SpinCount field
//
static const int RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO = 0x01000000;
static const int RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN = 0x02000000;
static const int RTL_CRITICAL_SECTION_FLAG_STATIC_INIT = 0x04000000;
static const int RTL_CRITICAL_SECTION_ALL_FLAG_BITS = 0xFF000000;
static const int RTL_CRITICAL_SECTION_FLAG_RESERVED = (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & (~(RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO | RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN | RTL_CRITICAL_SECTION_FLAG_STATIC_INIT)));
//
// These flags define possible values stored in the Flags field of a critsec debuginfo.
//
static const int RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT = 0x00000001;
#pragma pack(push, 8)
typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread; // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount; // force size on 64-bit systems when packed
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
#pragma pack(pop)
typedef struct _RTL_SRWLOCK {
        PVOID Ptr;
} RTL_SRWLOCK, *PRTL_SRWLOCK;
static const int RTL_SRWLOCK_INIT = {0};
typedef struct _RTL_CONDITION_VARIABLE {
        PVOID Ptr;
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;
static const int RTL_CONDITION_VARIABLE_INIT = {0};
static const int RTL_CONDITION_VARIABLE_LOCKMODE_SHARED = 0x1;
typedef
void
( *PAPCFUNC)(
    ULONG_PTR Parameter
    );
typedef LONG ( *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef enum _HEAP_INFORMATION_CLASS {
    HeapCompatibilityInformation,
    HeapEnableTerminationOnCorruption
} HEAP_INFORMATION_CLASS;
static const int WT_EXECUTEDEFAULT = 0x00000000;
static const int WT_EXECUTEINIOTHREAD = 0x00000001;
static const int WT_EXECUTEINUITHREAD = 0x00000002;
static const int WT_EXECUTEINWAITTHREAD = 0x00000004;
static const int WT_EXECUTEONLYONCE = 0x00000008;
static const int WT_EXECUTEINTIMERTHREAD = 0x00000020;
static const int WT_EXECUTELONGFUNCTION = 0x00000010;
static const int WT_EXECUTEINPERSISTENTIOTHREAD = 0x00000040;
static const int WT_EXECUTEINPERSISTENTTHREAD = 0x00000080;
static const int WT_TRANSFER_IMPERSONATION = 0x00000100;
static const int WT_SET_MAX_THREADPOOL_THREADS(Flags,Limit) = ((Flags) |= (Limit)<<16);
typedef void ( * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
typedef void ( * WORKERCALLBACKFUNC) (PVOID );
typedef void ( * APC_CALLBACK_FUNCTION) (DWORD , PVOID, PVOID);
typedef
void
( *PFLS_CALLBACK_FUNCTION) (
    PVOID lpFlsData
    );
typedef
BOOLEAN
( *PSECURE_MEMORY_CACHE_CALLBACK) (
    PVOID Addr,
    SIZE_T Range
    );
static const int WT_EXECUTEINLONGTHREAD = 0x00000010;
static const int WT_EXECUTEDELETEWAIT = 0x00000008;
typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass,
    //
    // compatibility with old names
    //
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4
} ACTIVATION_CONTEXT_INFO_CLASS;
static const int ACTIVATIONCONTEXTINFOCLASS = ACTIVATION_CONTEXT_INFO_CLASS;
typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;
typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;
static const int ACTIVATION_CONTEXT_PATH_TYPE_NONE = (1);
static const int ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE = (2);
static const int ACTIVATION_CONTEXT_PATH_TYPE_URL = (3);
static const int ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF = (4);
typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;
    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;
//
// compatibility with old names
// The new names use "file" consistently.
//
static const int _ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION;
static const int ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = ASSEMBLY_FILE_DETAILED_INFORMATION;
static const int PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = PASSEMBLY_FILE_DETAILED_INFORMATION;
static const int PCASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = PCASSEMBLY_FILE_DETAILED_INFORMATION;
typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength; // in bytes
    DWORD ulManifestPathType; // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulManifestPathLength; // in bytes
    LARGE_INTEGER liManifestLastWriteTime; // FILETIME
    DWORD ulPolicyPathType; // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulPolicyPathLength; // in bytes
    LARGE_INTEGER liPolicyLastWriteTime; // FILETIME
    DWORD ulMetadataSatelliteRosterIndex;
    DWORD ulManifestVersionMajor; // 1
    DWORD ulManifestVersionMinor; // 0
    DWORD ulPolicyVersionMajor; // 0
    DWORD ulPolicyVersionMinor; // 0
    DWORD ulAssemblyDirectoryNameLength; // in bytes
    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;
    DWORD ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;
typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;
typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;
typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;
typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;
typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;
#pragma warning(push)
#pragma warning(disable:4200)
typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
#pragma warning(pop)
typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
static const int MAX_SUPPORTED_OS_NUM = (4);
static const int INVALID_OS_COUNT = (0xffff);
typedef struct _SUPPORTED_OS_INFO {
    WORD OsCount;
    WORD MitigationExist;
    WORD OsList[(4)];
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;
typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;
typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;
static const int PERFORMANCE_DATA_VERSION = 1;
typedef struct _PERFORMANCE_DATA {
    WORD Size;
    BYTE Version;
    BYTE HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;
static const int READ_THREAD_PROFILING_FLAG_DISPATCHING = 0x00000001;
static const int READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS = 0x00000002;
static const int DLL_PROCESS_ATTACH = 1;
static const int DLL_THREAD_ATTACH = 2;
static const int DLL_THREAD_DETACH = 3;
static const int DLL_PROCESS_DETACH = 0;
//
// Defines for the READ flags for Eventlogging
//
static const int EVENTLOG_SEQUENTIAL_READ = 0x0001;
static const int EVENTLOG_SEEK_READ = 0x0002;
static const int EVENTLOG_FORWARDS_READ = 0x0004;
static const int EVENTLOG_BACKWARDS_READ = 0x0008;
//
// The types of events that can be logged.
//
static const int EVENTLOG_SUCCESS = 0x0000;
static const int EVENTLOG_ERROR_TYPE = 0x0001;
static const int EVENTLOG_WARNING_TYPE = 0x0002;
static const int EVENTLOG_INFORMATION_TYPE = 0x0004;
static const int EVENTLOG_AUDIT_SUCCESS = 0x0008;
static const int EVENTLOG_AUDIT_FAILURE = 0x0010;
//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//
static const int EVENTLOG_START_PAIRED_EVENT = 0x0001;
static const int EVENTLOG_END_PAIRED_EVENT = 0x0002;
static const int EVENTLOG_END_ALL_PAIRED_EVENTS = 0x0004;
static const int EVENTLOG_PAIRED_EVENT_ACTIVE = 0x0008;
static const int EVENTLOG_PAIRED_EVENT_INACTIVE = 0x0010;
//
// Structure that defines the header of the Eventlog record. This is the
// fixed-sized portion before all the variable-length strings, binary
// data and pad bytes.
//
// TimeGenerated is the time it was generated at the client.
// TimeWritten is the time it was put into the log at the server end.
//
typedef struct _EVENTLOGRECORD {
    DWORD Length; // Length of full record
    DWORD Reserved; // Used by the service
    DWORD RecordNumber; // Absolute record number
    DWORD TimeGenerated; // Seconds since 1-1-1970
    DWORD TimeWritten; // Seconds since 1-1-1970
    DWORD EventID;
    WORD EventType;
    WORD NumStrings;
    WORD EventCategory;
    WORD ReservedFlags; // For use with paired events (auditing)
    DWORD ClosingRecordNumber; // For use with paired events (auditing)
    DWORD StringOffset; // Offset from beginning of record
    DWORD UserSidLength;
    DWORD UserSidOffset;
    DWORD DataLength;
    DWORD DataOffset; // Offset from beginning of record
    //
    // Then follow:
    //
    // WCHAR SourceName[]
    // WCHAR Computername[]
    // SID   UserSid
    // WCHAR Strings[]
    // BYTE  Data[]
    // CHAR  Pad[]
    // DWORD Length;
    //
} EVENTLOGRECORD, *PEVENTLOGRECORD;
//SS: start of changes to support clustering
//SS: ideally the
static const int MAXLOGICALLOGNAMESIZE = 256;
#pragma warning(disable : 4200)
struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;
struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;
# 13774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#pragma warning(default : 4200)
//SS: end of changes to support clustering
//
// begin_wdm 
//
// Registry Specific Access Rights.
//
static const int KEY_QUERY_VALUE = (0x0001);
static const int KEY_SET_VALUE = (0x0002);
static const int KEY_CREATE_SUB_KEY = (0x0004);
static const int KEY_ENUMERATE_SUB_KEYS = (0x0008);
static const int KEY_NOTIFY = (0x0010);
static const int KEY_CREATE_LINK = (0x0020);
static const int KEY_WOW64_32KEY = (0x0200);
static const int KEY_WOW64_64KEY = (0x0100);
static const int KEY_WOW64_RES = (0x0300);
static const int KEY_READ = ((STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY) & (~SYNCHRONIZE));
static const int KEY_WRITE = ((STANDARD_RIGHTS_WRITE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY) & (~SYNCHRONIZE));
static const int KEY_EXECUTE = ((KEY_READ) & (~SYNCHRONIZE));
static const int KEY_ALL_ACCESS = ((STANDARD_RIGHTS_ALL | KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY | KEY_CREATE_LINK) & (~SYNCHRONIZE));
# 13822 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Open/Create Options
//
static const int REG_OPTION_RESERVED = (0x00000000L);
static const int REG_OPTION_NON_VOLATILE = (0x00000000L);
                                                    // when system is rebooted
static const int REG_OPTION_VOLATILE = (0x00000001L);
                                                    // when system is rebooted
static const int REG_OPTION_CREATE_LINK = (0x00000002L);
                                                    // symbolic link
static const int REG_OPTION_BACKUP_RESTORE = (0x00000004L);
                                                    // special access rules
                                                    // privilege required
static const int REG_OPTION_OPEN_LINK = (0x00000008L);
static const int REG_LEGAL_OPTION = (REG_OPTION_RESERVED | REG_OPTION_NON_VOLATILE | REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK | REG_OPTION_BACKUP_RESTORE | REG_OPTION_OPEN_LINK);
static const int REG_OPEN_LEGAL_OPTION = (REG_OPTION_RESERVED | REG_OPTION_BACKUP_RESTORE | REG_OPTION_OPEN_LINK);
//
// Key creation/open disposition
//
static const int REG_CREATED_NEW_KEY = (0x00000001L);
static const int REG_OPENED_EXISTING_KEY = (0x00000002L);
//
// hive format to be used by Reg(Nt)SaveKeyEx
//
static const int REG_STANDARD_FORMAT = 1;
static const int REG_LATEST_FORMAT = 2;
static const int REG_NO_COMPRESSION = 4;
//
// Key restore & hive load flags
//
static const int REG_WHOLE_HIVE_VOLATILE = (0x00000001L);
static const int REG_REFRESH_HIVE = (0x00000002L);
static const int REG_NO_LAZY_FLUSH = (0x00000004L);
static const int REG_FORCE_RESTORE = (0x00000008L);
static const int REG_APP_HIVE = (0x00000010L);
static const int REG_PROCESS_PRIVATE = (0x00000020L);
static const int REG_START_JOURNAL = (0x00000040L);
static const int REG_HIVE_EXACT_FILE_GROWTH = (0x00000080L);
static const int REG_HIVE_NO_RM = (0x00000100L);
static const int REG_HIVE_SINGLE_LOG = (0x00000200L);
static const int REG_BOOT_HIVE = (0x00000400L);
//
// Unload Flags
//
static const int REG_FORCE_UNLOAD = 1;
//
// Notify filter values
//
static const int REG_NOTIFY_CHANGE_NAME = (0x00000001L);
static const int REG_NOTIFY_CHANGE_ATTRIBUTES = (0x00000002L);
static const int REG_NOTIFY_CHANGE_LAST_SET = (0x00000004L);
static const int REG_NOTIFY_CHANGE_SECURITY = (0x00000008L);
static const int REG_LEGAL_CHANGE_FILTER = (REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES | REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY);
// end_wdm 
//
//
// Predefined Value Types.
//
static const int REG_NONE = ( 0 );
static const int REG_SZ = ( 1 );
static const int REG_EXPAND_SZ = ( 2 );
                                            // (with environment variable references)
static const int REG_BINARY = ( 3 );
static const int REG_DWORD = ( 4 );
static const int REG_DWORD_LITTLE_ENDIAN = ( 4 );
static const int REG_DWORD_BIG_ENDIAN = ( 5 );
static const int REG_LINK = ( 6 );
static const int REG_MULTI_SZ = ( 7 );
static const int REG_RESOURCE_LIST = ( 8 );
static const int REG_FULL_RESOURCE_DESCRIPTOR = ( 9 );
static const int REG_RESOURCE_REQUIREMENTS_LIST = ( 10 );
static const int REG_QWORD = ( 11 );
static const int REG_QWORD_LITTLE_ENDIAN = ( 11 );
// end_wdm
// begin_wdm
//
// Service Types (Bit Mask)
//
static const int SERVICE_KERNEL_DRIVER = 0x00000001;
static const int SERVICE_FILE_SYSTEM_DRIVER = 0x00000002;
static const int SERVICE_ADAPTER = 0x00000004;
static const int SERVICE_RECOGNIZER_DRIVER = 0x00000008;
static const int SERVICE_DRIVER = (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_RECOGNIZER_DRIVER);
static const int SERVICE_WIN32_OWN_PROCESS = 0x00000010;
static const int SERVICE_WIN32_SHARE_PROCESS = 0x00000020;
static const int SERVICE_WIN32 = (SERVICE_WIN32_OWN_PROCESS | SERVICE_WIN32_SHARE_PROCESS);
static const int SERVICE_INTERACTIVE_PROCESS = 0x00000100;
static const int SERVICE_TYPE_ALL = (SERVICE_WIN32 | SERVICE_ADAPTER | SERVICE_DRIVER | SERVICE_INTERACTIVE_PROCESS);
//
// Start Type
//
static const int SERVICE_BOOT_START = 0x00000000;
static const int SERVICE_SYSTEM_START = 0x00000001;
static const int SERVICE_AUTO_START = 0x00000002;
static const int SERVICE_DEMAND_START = 0x00000003;
static const int SERVICE_DISABLED = 0x00000004;
//
// Error control type
//
static const int SERVICE_ERROR_IGNORE = 0x00000000;
static const int SERVICE_ERROR_NORMAL = 0x00000001;
static const int SERVICE_ERROR_SEVERE = 0x00000002;
static const int SERVICE_ERROR_CRITICAL = 0x00000003;
//
//
// Define the registry driver node enumerations
//
typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType = 0x00000001,
    FileSystemType = 0x00000002,
    Win32ServiceOwnProcess = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType = 0x00000004,
    RecognizerType = 0x00000008
} SERVICE_NODE_TYPE;
typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad = 0x00000000,
    SystemLoad = 0x00000001,
    AutoLoad = 0x00000002,
    DemandLoad = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;
typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError = 0x00000000,
    NormalError = 0x00000001,
    SevereError = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;
//
// Service node Flags. These flags are used by the OS loader to promote
// a driver's start type to boot start if the system is booting using
// the specified mechanism. The flags should be set in the driver's
// registry configuration.
//
// CM_SERVICE_NETWORK_BOOT_LOAD - Specified if a driver should be
// promoted on network boot.
//
// CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD - Specified if a driver should be
// promoted on booting from a VHD.
//
// CM_SERVICE_USB_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from a USB disk.
//
static const int CM_SERVICE_NETWORK_BOOT_LOAD = 0x00000001;
static const int CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD = 0x00000002;
static const int CM_SERVICE_USB_DISK_BOOT_LOAD = 0x00000004;
//
// Mask defining the legal promotion flag values.
//
static const int CM_SERVICE_VALID_PROMOTION_MASK = (CM_SERVICE_NETWORK_BOOT_LOAD | CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD | CM_SERVICE_USB_DISK_BOOT_LOAD);
//
// IOCTL_TAPE_ERASE definitions
//
static const long TAPE_ERASE_SHORT = 0L;
static const long TAPE_ERASE_LONG = 1L;
typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;
//
// IOCTL_TAPE_PREPARE definitions
//
static const long TAPE_LOAD = 0L;
static const long TAPE_UNLOAD = 1L;
static const long TAPE_TENSION = 2L;
static const long TAPE_LOCK = 3L;
static const long TAPE_UNLOCK = 4L;
static const long TAPE_FORMAT = 5L;
typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;
//
// IOCTL_TAPE_WRITE_MARKS definitions
//
static const long TAPE_SETMARKS = 0L;
static const long TAPE_FILEMARKS = 1L;
static const long TAPE_SHORT_FILEMARKS = 2L;
static const long TAPE_LONG_FILEMARKS = 3L;
typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;
//
// IOCTL_TAPE_GET_POSITION definitions
//
static const long TAPE_ABSOLUTE_POSITION = 0L;
static const long TAPE_LOGICAL_POSITION = 1L;
static const long TAPE_PSEUDO_LOGICAL_POSITION = 2L;
typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;
//
// IOCTL_TAPE_SET_POSITION definitions
//
static const long TAPE_REWIND = 0L;
static const long TAPE_ABSOLUTE_BLOCK = 1L;
static const long TAPE_LOGICAL_BLOCK = 2L;
static const long TAPE_PSEUDO_LOGICAL_BLOCK = 3L;
static const long TAPE_SPACE_END_OF_DATA = 4L;
static const long TAPE_SPACE_RELATIVE_BLOCKS = 5L;
static const long TAPE_SPACE_FILEMARKS = 6L;
static const long TAPE_SPACE_SEQUENTIAL_FMKS = 7L;
static const long TAPE_SPACE_SETMARKS = 8L;
static const long TAPE_SPACE_SEQUENTIAL_SMKS = 9L;
typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;
//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//
//
// Definitions for FeaturesLow parameter
//
static const int TAPE_DRIVE_FIXED = 0x00000001;
static const int TAPE_DRIVE_SELECT = 0x00000002;
static const int TAPE_DRIVE_INITIATOR = 0x00000004;
static const int TAPE_DRIVE_ERASE_SHORT = 0x00000010;
static const int TAPE_DRIVE_ERASE_LONG = 0x00000020;
static const int TAPE_DRIVE_ERASE_BOP_ONLY = 0x00000040;
static const int TAPE_DRIVE_ERASE_IMMEDIATE = 0x00000080;
static const int TAPE_DRIVE_TAPE_CAPACITY = 0x00000100;
static const int TAPE_DRIVE_TAPE_REMAINING = 0x00000200;
static const int TAPE_DRIVE_FIXED_BLOCK = 0x00000400;
static const int TAPE_DRIVE_VARIABLE_BLOCK = 0x00000800;
static const int TAPE_DRIVE_WRITE_PROTECT = 0x00001000;
static const int TAPE_DRIVE_EOT_WZ_SIZE = 0x00002000;
static const int TAPE_DRIVE_ECC = 0x00010000;
static const int TAPE_DRIVE_COMPRESSION = 0x00020000;
static const int TAPE_DRIVE_PADDING = 0x00040000;
static const int TAPE_DRIVE_REPORT_SMKS = 0x00080000;
static const int TAPE_DRIVE_GET_ABSOLUTE_BLK = 0x00100000;
static const int TAPE_DRIVE_GET_LOGICAL_BLK = 0x00200000;
static const int TAPE_DRIVE_SET_EOT_WZ_SIZE = 0x00400000;
static const int TAPE_DRIVE_EJECT_MEDIA = 0x01000000;
static const int TAPE_DRIVE_CLEAN_REQUESTS = 0x02000000;
static const int TAPE_DRIVE_SET_CMP_BOP_ONLY = 0x04000000;
static const int TAPE_DRIVE_RESERVED_BIT = 0x80000000;
//                                              //can't be a low features bit!
//                                              //reserved; high features only
//
// Definitions for FeaturesHigh parameter
//
static const int TAPE_DRIVE_LOAD_UNLOAD = 0x80000001;
static const int TAPE_DRIVE_TENSION = 0x80000002;
static const int TAPE_DRIVE_LOCK_UNLOCK = 0x80000004;
static const int TAPE_DRIVE_REWIND_IMMEDIATE = 0x80000008;
static const int TAPE_DRIVE_SET_BLOCK_SIZE = 0x80000010;
static const int TAPE_DRIVE_LOAD_UNLD_IMMED = 0x80000020;
static const int TAPE_DRIVE_TENSION_IMMED = 0x80000040;
static const int TAPE_DRIVE_LOCK_UNLK_IMMED = 0x80000080;
static const int TAPE_DRIVE_SET_ECC = 0x80000100;
static const int TAPE_DRIVE_SET_COMPRESSION = 0x80000200;
static const int TAPE_DRIVE_SET_PADDING = 0x80000400;
static const int TAPE_DRIVE_SET_REPORT_SMKS = 0x80000800;
static const int TAPE_DRIVE_ABSOLUTE_BLK = 0x80001000;
static const int TAPE_DRIVE_ABS_BLK_IMMED = 0x80002000;
static const int TAPE_DRIVE_LOGICAL_BLK = 0x80004000;
static const int TAPE_DRIVE_LOG_BLK_IMMED = 0x80008000;
static const int TAPE_DRIVE_END_OF_DATA = 0x80010000;
static const int TAPE_DRIVE_RELATIVE_BLKS = 0x80020000;
static const int TAPE_DRIVE_FILEMARKS = 0x80040000;
static const int TAPE_DRIVE_SEQUENTIAL_FMKS = 0x80080000;
static const int TAPE_DRIVE_SETMARKS = 0x80100000;
static const int TAPE_DRIVE_SEQUENTIAL_SMKS = 0x80200000;
static const int TAPE_DRIVE_REVERSE_POSITION = 0x80400000;
static const int TAPE_DRIVE_SPACE_IMMEDIATE = 0x80800000;
static const int TAPE_DRIVE_WRITE_SETMARKS = 0x81000000;
static const int TAPE_DRIVE_WRITE_FILEMARKS = 0x82000000;
static const int TAPE_DRIVE_WRITE_SHORT_FMKS = 0x84000000;
static const int TAPE_DRIVE_WRITE_LONG_FMKS = 0x88000000;
static const int TAPE_DRIVE_WRITE_MARK_IMMED = 0x90000000;
static const int TAPE_DRIVE_FORMAT = 0xA0000000;
static const int TAPE_DRIVE_FORMAT_IMMEDIATE = 0xC0000000;
static const int TAPE_DRIVE_HIGH_FEATURES = 0x80000000;
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;
//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//
typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;
//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//
typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;
//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//
typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;
//
// IOCTL_TAPE_CREATE_PARTITION definitions
//
static const long TAPE_FIXED_PARTITIONS = 0L;
static const long TAPE_SELECT_PARTITIONS = 1L;
static const long TAPE_INITIATOR_PARTITIONS = 2L;
typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;
//
// WMI Methods
//
static const long TAPE_QUERY_DRIVE_PARAMETERS = 0L;
static const long TAPE_QUERY_MEDIA_CAPACITY = 1L;
static const long TAPE_CHECK_FOR_DRIVE_PROBLEM = 2L;
static const long TAPE_QUERY_IO_ERROR_DATA = 3L;
static const long TAPE_QUERY_DEVICE_ERROR_DATA = 4L;
typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;
//
// Type of drive errors
//
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ktmtypes.h" 1
/*++
Copyright (c) 2000  Microsoft Corporation
Module Name:
    ktmtypes.h
Abstract:
    Common types for KTM exposed at both the Nt- and Win32-layer.
Revision History:
--*/
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ktmtypes.h"
// begin_wdm begin_winnt
typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;
//
// Define the TransactionManager option values
//
static const int TRANSACTION_MANAGER_VOLATILE = 0x00000001;
static const int TRANSACTION_MANAGER_COMMIT_DEFAULT = 0x00000000;
static const int TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME = 0x00000002;
static const int TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES = 0x00000004;
static const int TRANSACTION_MANAGER_COMMIT_LOWEST = 0x00000008;
static const int TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY = 0x00000010;
static const int TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS = 0x00000020;
static const double TRANSACTION_MANAGER_MAXIMUM_OPTION = 0x0000003F;
//
// Define the Transaction option values
//
static const int TRANSACTION_DO_NOT_PROMOTE = 0x00000001;
static const int TRANSACTION_MAXIMUM_OPTION = 0x00000001;
//
// Define the ResourceManager option values
//
static const int RESOURCE_MANAGER_VOLATILE = 0x00000001;
static const int RESOURCE_MANAGER_COMMUNICATION = 0x00000002;
static const int RESOURCE_MANAGER_MAXIMUM_OPTION = 0x00000003;
//
// Define the RegisterProtocol option values
//
static const int CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY = 0x00000001;
static const int CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO = 0x00000002;
static const int CRM_PROTOCOL_MAXIMUM_OPTION = 0x00000003;
//
// Define the Enlistment option values
//
static const int ENLISTMENT_SUPERIOR = 0x00000001;
static const int ENLISTMENT_MAXIMUM_OPTION = 0x00000001;
typedef ULONG NOTIFICATION_MASK;
static const int TRANSACTION_NOTIFY_MASK = 0x3FFFFFFF;
static const int TRANSACTION_NOTIFY_PREPREPARE = 0x00000001;
static const int TRANSACTION_NOTIFY_PREPARE = 0x00000002;
static const int TRANSACTION_NOTIFY_COMMIT = 0x00000004;
static const int TRANSACTION_NOTIFY_ROLLBACK = 0x00000008;
static const int TRANSACTION_NOTIFY_PREPREPARE_COMPLETE = 0x00000010;
static const int TRANSACTION_NOTIFY_PREPARE_COMPLETE = 0x00000020;
static const int TRANSACTION_NOTIFY_COMMIT_COMPLETE = 0x00000040;
static const int TRANSACTION_NOTIFY_ROLLBACK_COMPLETE = 0x00000080;
static const int TRANSACTION_NOTIFY_RECOVER = 0x00000100;
static const int TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT = 0x00000200;
static const int TRANSACTION_NOTIFY_DELEGATE_COMMIT = 0x00000400;
static const int TRANSACTION_NOTIFY_RECOVER_QUERY = 0x00000800;
static const int TRANSACTION_NOTIFY_ENLIST_PREPREPARE = 0x00001000;
static const int TRANSACTION_NOTIFY_LAST_RECOVER = 0x00002000;
static const int TRANSACTION_NOTIFY_INDOUBT = 0x00004000;
static const int TRANSACTION_NOTIFY_PROPAGATE_PULL = 0x00008000;
static const int TRANSACTION_NOTIFY_PROPAGATE_PUSH = 0x00010000;
static const int TRANSACTION_NOTIFY_MARSHAL = 0x00020000;
static const int TRANSACTION_NOTIFY_ENLIST_MASK = 0x00040000;
static const int TRANSACTION_NOTIFY_RM_DISCONNECTED = 0x01000000;
static const int TRANSACTION_NOTIFY_TM_ONLINE = 0x02000000;
static const int TRANSACTION_NOTIFY_COMMIT_REQUEST = 0x04000000;
static const int TRANSACTION_NOTIFY_PROMOTE = 0x08000000;
static const int TRANSACTION_NOTIFY_PROMOTE_NEW = 0x10000000;
static const int TRANSACTION_NOTIFY_REQUEST_OUTCOME = 0x20000000;
//
//  Note that this flag is not included in the TRANSACTION_NOTIFY_MASK.
//  The reason being that KTM does not understand this flag yet. This
//  flag is strictly for the use of filter manager. In fact we mask it
//  out before enlisting in any transaction.
//
static const int TRANSACTION_NOTIFY_COMMIT_FINALIZE = 0x40000000;
//
// Path to the transaction manager objects in the NT
// object namespace.
//
static const char TRANSACTIONMANAGER_OBJECT_PATH = L"\\TransactionManager\\";
static const char TRANSACTION_OBJECT_PATH = L"\\Transaction\\";
static const char ENLISTMENT_OBJECT_PATH = L"\\Enlistment\\";
static const char RESOURCE_MANAGER_OBJECT_PATH = L"\\ResourceManager\\";
//
// The following three defines are here to ease the allocation
// of string buffers which are to contain a fully qualified 
// transaction manager object name, e.g., \Transaction\{GUID}
//
static const int TRANSACTIONMANAGER_OBJECT_NAME_LENGTH_IN_BYTES = (sizeof(TRANSACTIONMANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)));
static const int TRANSACTION_OBJECT_NAME_LENGTH_IN_BYTES = (sizeof(TRANSACTION_OBJECT_PATH)+(38*sizeof(WCHAR)));
static const int ENLISTMENT_OBJECT_NAME_LENGTH_IN_BYTES = (sizeof(ENLISTMENT_OBJECT_PATH)+(38*sizeof(WCHAR)));
static const int RESOURCE_MANAGER_OBJECT_NAME_LENGTH_IN_BYTES = (sizeof(RESOURCE_MANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)));
// TODO: warning, duplicated def in tm.h.
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID TransactionKey;
    ULONG TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;
typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID EnlistmentId;
    UOW UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
static const int TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED = 0x1;
typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;
typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID UOW;
    GUID TmIdentity;
    ULONG BufferLength;
    // Bufferlength bytes of Buffer follow
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;
static const int KTM_MARSHAL_BLOB_VERSION_MAJOR = 1;
static const int KTM_MARSHAL_BLOB_VERSION_MINOR = 1;
static const int MAX_TRANSACTION_DESCRIPTION_LENGTH = 64;
static const int MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH = 64;
typedef struct _KCRM_MARSHAL_HEADER {
    ULONG VersionMajor;
    ULONG VersionMinor;
    ULONG NumProtocols;
    ULONG Unused; // for alignment purposes
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, * PRKCRM_MARSHAL_HEADER;
typedef struct _KCRM_TRANSACTION_BLOB {
    UOW UOW;
    GUID TmIdentity;
    ULONG IsolationLevel;
    ULONG IsolationFlags;
    ULONG Timeout;
    WCHAR Description[64];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, * PRKCRM_TRANSACTION_BLOB;
typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID ProtocolId;
    ULONG StaticInfoLength;
    ULONG TransactionIdInfoLength; //??? ProtocolDynamicInfoLength;
    ULONG Unused1; // for alignment purposes
    ULONG Unused2; // for alignment purposes
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, * PRKCRM_PROTOCOL_BLOB;
# 14297 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
//
// Types for Nt level TM calls
//
//
// KTM Tm object rights
//
static const int TRANSACTIONMANAGER_QUERY_INFORMATION = ( 0x0001 );
static const int TRANSACTIONMANAGER_SET_INFORMATION = ( 0x0002 );
static const int TRANSACTIONMANAGER_RECOVER = ( 0x0004 );
static const int TRANSACTIONMANAGER_RENAME = ( 0x0008 );
static const int TRANSACTIONMANAGER_CREATE_RM = ( 0x0010 );
// The following right is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
static const int TRANSACTIONMANAGER_BIND_TRANSACTION = ( 0x0020 );
//
// Generic mappings for transaction manager rights.
//
static const int TRANSACTIONMANAGER_GENERIC_READ = (STANDARD_RIGHTS_READ | TRANSACTIONMANAGER_QUERY_INFORMATION);
static const int TRANSACTIONMANAGER_GENERIC_WRITE = (STANDARD_RIGHTS_WRITE | TRANSACTIONMANAGER_SET_INFORMATION | TRANSACTIONMANAGER_RECOVER | TRANSACTIONMANAGER_RENAME | TRANSACTIONMANAGER_CREATE_RM);
static const int TRANSACTIONMANAGER_GENERIC_EXECUTE = (STANDARD_RIGHTS_EXECUTE);
static const int TRANSACTIONMANAGER_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | TRANSACTIONMANAGER_GENERIC_READ | TRANSACTIONMANAGER_GENERIC_WRITE | TRANSACTIONMANAGER_GENERIC_EXECUTE | TRANSACTIONMANAGER_BIND_TRANSACTION);
//
// KTM transaction object rights.
//
static const int TRANSACTION_QUERY_INFORMATION = ( 0x0001 );
static const int TRANSACTION_SET_INFORMATION = ( 0x0002 );
static const int TRANSACTION_ENLIST = ( 0x0004 );
static const int TRANSACTION_COMMIT = ( 0x0008 );
static const int TRANSACTION_ROLLBACK = ( 0x0010 );
static const int TRANSACTION_PROPAGATE = ( 0x0020 );
static const int TRANSACTION_RIGHT_RESERVED1 = ( 0x0040 );
//
// Generic mappings for transaction rights.
// Resource managers, when enlisting, should generally use the macro
// TRANSACTION_RESOURCE_MANAGER_RIGHTS when opening a transaction.
// It's the same as generic read and write except that it does not allow
// a commit decision to be made.
//
static const int TRANSACTION_GENERIC_READ = (STANDARD_RIGHTS_READ | TRANSACTION_QUERY_INFORMATION | SYNCHRONIZE);
static const int TRANSACTION_GENERIC_WRITE = (STANDARD_RIGHTS_WRITE | TRANSACTION_SET_INFORMATION | TRANSACTION_COMMIT | TRANSACTION_ENLIST | TRANSACTION_ROLLBACK | TRANSACTION_PROPAGATE | SYNCHRONIZE);
static const int TRANSACTION_GENERIC_EXECUTE = (STANDARD_RIGHTS_EXECUTE | TRANSACTION_COMMIT | TRANSACTION_ROLLBACK | SYNCHRONIZE);
static const int TRANSACTION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | TRANSACTION_GENERIC_READ | TRANSACTION_GENERIC_WRITE | TRANSACTION_GENERIC_EXECUTE);
static const int TRANSACTION_RESOURCE_MANAGER_RIGHTS = (TRANSACTION_GENERIC_READ | STANDARD_RIGHTS_WRITE | TRANSACTION_SET_INFORMATION | TRANSACTION_ENLIST | TRANSACTION_ROLLBACK | TRANSACTION_PROPAGATE | SYNCHRONIZE);
//
// KTM resource manager object rights.
//
static const int RESOURCEMANAGER_QUERY_INFORMATION = ( 0x0001 );
static const int RESOURCEMANAGER_SET_INFORMATION = ( 0x0002 );
static const int RESOURCEMANAGER_RECOVER = ( 0x0004 );
static const int RESOURCEMANAGER_ENLIST = ( 0x0008 );
static const int RESOURCEMANAGER_GET_NOTIFICATION = ( 0x0010 );
static const int RESOURCEMANAGER_REGISTER_PROTOCOL = ( 0x0020 );
static const int RESOURCEMANAGER_COMPLETE_PROPAGATION = ( 0x0040 );
//
// Generic mappings for resource manager rights.
//
static const int RESOURCEMANAGER_GENERIC_READ = (STANDARD_RIGHTS_READ | RESOURCEMANAGER_QUERY_INFORMATION | SYNCHRONIZE);
static const int RESOURCEMANAGER_GENERIC_WRITE = (STANDARD_RIGHTS_WRITE | RESOURCEMANAGER_SET_INFORMATION | RESOURCEMANAGER_RECOVER | RESOURCEMANAGER_ENLIST | RESOURCEMANAGER_GET_NOTIFICATION | RESOURCEMANAGER_REGISTER_PROTOCOL | RESOURCEMANAGER_COMPLETE_PROPAGATION | SYNCHRONIZE);
# 14413 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int RESOURCEMANAGER_GENERIC_EXECUTE = (STANDARD_RIGHTS_EXECUTE | RESOURCEMANAGER_RECOVER | RESOURCEMANAGER_ENLIST | RESOURCEMANAGER_GET_NOTIFICATION | RESOURCEMANAGER_COMPLETE_PROPAGATION | SYNCHRONIZE);
static const int RESOURCEMANAGER_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | RESOURCEMANAGER_GENERIC_READ | RESOURCEMANAGER_GENERIC_WRITE | RESOURCEMANAGER_GENERIC_EXECUTE);
//
// KTM enlistment object rights.
//
static const int ENLISTMENT_QUERY_INFORMATION = ( 0x0001 );
static const int ENLISTMENT_SET_INFORMATION = ( 0x0002 );
static const int ENLISTMENT_RECOVER = ( 0x0004 );
static const int ENLISTMENT_SUBORDINATE_RIGHTS = ( 0x0008 );
static const int ENLISTMENT_SUPERIOR_RIGHTS = ( 0x0010 );
//
// Generic mappings for enlistment rights.
//
static const int ENLISTMENT_GENERIC_READ = (STANDARD_RIGHTS_READ | ENLISTMENT_QUERY_INFORMATION);
static const int ENLISTMENT_GENERIC_WRITE = (STANDARD_RIGHTS_WRITE | ENLISTMENT_SET_INFORMATION | ENLISTMENT_RECOVER | ENLISTMENT_SUBORDINATE_RIGHTS | ENLISTMENT_SUPERIOR_RIGHTS);
static const int ENLISTMENT_GENERIC_EXECUTE = (STANDARD_RIGHTS_EXECUTE | ENLISTMENT_RECOVER | ENLISTMENT_SUBORDINATE_RIGHTS | ENLISTMENT_SUPERIOR_RIGHTS);
static const int ENLISTMENT_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | ENLISTMENT_GENERIC_READ | ENLISTMENT_GENERIC_WRITE | ENLISTMENT_GENERIC_EXECUTE);
//
// Transaction outcomes.
//
// TODO: warning, must match values in KTRANSACTION_OUTCOME duplicated def 
// in tm.h.
//
typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;
typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;
typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID TransactionId;
    DWORD State;
    DWORD Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;
typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;
typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;
typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
    WCHAR LogPath[1]; // Variable size
//  Data[1];                                        // Variable size data not declared
} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;
typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;
// end_wdm
typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;
// begin_wdm
typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD IsolationLevel;
    DWORD IsolationFlags;
    LARGE_INTEGER Timeout;
    DWORD Outcome;
    DWORD DescriptionLength;
    WCHAR Description[1]; // Variable size
//          Data[1];            // Variable size data not declared
} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;
// The following info-class is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;
typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID EnlistmentId;
    GUID ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;
typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1]; // Variable size
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;
typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID ResourceManagerId;
    DWORD DescriptionLength;
    WCHAR Description[1]; // Variable size
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;
typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;
// end_wdm
// begin_wdm
typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation
// end_wdm
    ,
// The following info-classes are intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
    TransactionBindInformation, // private and deprecated
    TransactionDTCPrivateInformation // private and deprecated
    ,
// begin_wdm
} TRANSACTION_INFORMATION_CLASS;
// begin_wdm
typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4
// end_wdm
    ,
// The following info-classes are intended for internal use only; they
// are considered deprecated, and no one else should take a dependency
// on them.
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5
// end_wdm
// begin_wdm
} TRANSACTIONMANAGER_INFORMATION_CLASS;
// begin_wdm
typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;
typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;
typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;
// begin_wdm
typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;
typedef struct _TRANSACTION_LIST_ENTRY {
    UOW UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;
typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1]; // Var size
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;
//
// Types of objects known to the kernel transaction manager.
//
typedef enum _KTMOBJECT_TYPE {
    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID
} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;
//
// KTMOBJECT_CURSOR
//
// Used by NtEnumerateTransactionObject to enumerate a transaction
// object namespace (e.g. enlistments in a resource manager).
//
typedef struct _KTMOBJECT_CURSOR {
    //
    // The last GUID enumerated; zero if beginning enumeration.
    // 
    GUID LastQuery;
    //
    // A count of GUIDs filled in by this last enumeration.
    // 
    DWORD ObjectIdCount;
    //
    // ObjectIdCount GUIDs from the namespace specified.
    // 
    GUID ObjectIds[1];
} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;
// begin_wdm
typedef DWORD TP_VERSION, *PTP_VERSION;
typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;
typedef void ( *PTP_SIMPLE_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context
    );
typedef struct _TP_POOL TP_POOL, *PTP_POOL;
typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;
typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;
typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;
typedef void ( *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
    PVOID ObjectContext,
    PVOID CleanupContext
    );
//
// Do not manipulate this structure directly!  Allocate space for it
// and use the inline interfaces below.
//
typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION Version;
    PTP_POOL Pool;
    PTP_CLEANUP_GROUP CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
    PVOID RaceDll;
    struct _ACTIVATION_CONTEXT *ActivationContext;
    PTP_SIMPLE_CALLBACK FinalizationCallback;
    union {
        DWORD Flags;
        struct {
            DWORD LongFunction : 1;
            DWORD Persistent : 1;
            DWORD Private : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY CallbackPriority;
    DWORD Size;
} TP_CALLBACK_ENVIRON_V3;
typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;
# 14764 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
__inline
void
TpInitializeCallbackEnviron(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->Version = 3;
    CallbackEnviron->Pool = ((void *)0);
    CallbackEnviron->CleanupGroup = ((void *)0);
    CallbackEnviron->CleanupGroupCancelCallback = ((void *)0);
    CallbackEnviron->RaceDll = ((void *)0);
    CallbackEnviron->ActivationContext = ((void *)0);
    CallbackEnviron->FinalizationCallback = ((void *)0);
    CallbackEnviron->u.Flags = 0;
    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);
}
__inline
void
TpSetCallbackThreadpool(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_POOL Pool
    )
{
    CallbackEnviron->Pool = Pool;
}
__inline
void
TpSetCallbackCleanupGroup(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_CLEANUP_GROUP CleanupGroup,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}
__inline
void
TpSetCallbackActivationContext(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}
__inline
void
TpSetCallbackNoActivationContext(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1; // INVALID_ACTIVATION_CONTEXT
}
__inline
void
TpSetCallbackLongFunction(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}
__inline
void
TpSetCallbackRaceWithDll(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PVOID DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}
__inline
void
TpSetCallbackFinalizationCallback(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_SIMPLE_CALLBACK FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}
__inline
void
TpSetCallbackPriority(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    TP_CALLBACK_PRIORITY Priority
    )
{
    CallbackEnviron->CallbackPriority = Priority;
}
__inline
void
TpSetCallbackPersistent(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}
__inline
void
TpDestroyCallbackEnviron(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    //
    // For the current version of the callback environment, no actions
    // need to be taken to tear down an initialized structure.  This
    // may change in a future release.
    //
    (CallbackEnviron);
}
typedef struct _TP_WORK TP_WORK, *PTP_WORK;
typedef void ( *PTP_WORK_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_WORK Work
    );
typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;
typedef void ( *PTP_TIMER_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_TIMER Timer
    );
typedef DWORD TP_WAIT_RESULT;
typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;
typedef void ( *PTP_WAIT_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_WAIT Wait,
    TP_WAIT_RESULT WaitResult
    );
typedef struct _TP_IO TP_IO, *PTP_IO;
# 15005 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
static const int ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION = (1);
static const int ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION = (2);
static const int ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION = (3);
static const int ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION = (4);
static const int ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION = (5);
static const int ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION = (6);
static const int ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION = (7);
static const int ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE = (8);
static const int ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES = (9);
static const int ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS = (10);
static const int ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO = (11);
# 15025 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#pragma warning(default:4201)
#pragma warning(default:4214)
# 178 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h" 2
/* Types use for passing & returning polymorphic values */
typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;
static const int max(a,b) = (((a) > (b)) ? (a) : (b));
static const int min(a,b) = (((a) < (b)) ? (a) : (b));
static const int MAKEWORD(a,b) = ((WORD)(((BYTE)(((DWORD_PTR)(a)) & 0xff)) | ((WORD)((BYTE)(((DWORD_PTR)(b)) & 0xff))) << 8));
static const int MAKELONG(a,b) = ((LONG)(((WORD)(((DWORD_PTR)(a)) & 0xffff)) | ((DWORD)((WORD)(((DWORD_PTR)(b)) & 0xffff))) << 16));
static const int LOWORD(l) = ((WORD)(((DWORD_PTR)(l)) & 0xffff));
static const int HIWORD(l) = ((WORD)((((DWORD_PTR)(l)) >> 16) & 0xffff));
static const int LOBYTE(w) = ((BYTE)(((DWORD_PTR)(w)) & 0xff));
static const int HIBYTE(w) = ((BYTE)((((DWORD_PTR)(w)) >> 8) & 0xff));
struct HWND__{int unused;}; typedef struct HWND__ *HWND;
struct HHOOK__{int unused;}; typedef struct HHOOK__ *HHOOK;
typedef WORD ATOM;
typedef HANDLE *SPHANDLE;
typedef HANDLE *LPHANDLE;
typedef HANDLE HGLOBAL;
typedef HANDLE HLOCAL;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;
typedef INT_PTR ( *FARPROC)();
typedef INT_PTR ( *NEARPROC)();
typedef INT_PTR ( *PROC)();
# 247 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
typedef void * HGDIOBJ;
struct HKEY__{int unused;}; typedef struct HKEY__ *HKEY;
typedef HKEY *PHKEY;
struct HACCEL__{int unused;}; typedef struct HACCEL__ *HACCEL;
struct HBITMAP__{int unused;}; typedef struct HBITMAP__ *HBITMAP;
struct HBRUSH__{int unused;}; typedef struct HBRUSH__ *HBRUSH;
struct HCOLORSPACE__{int unused;}; typedef struct HCOLORSPACE__ *HCOLORSPACE;
struct HDC__{int unused;}; typedef struct HDC__ *HDC;
struct HGLRC__{int unused;}; typedef struct HGLRC__ *HGLRC; // OpenGL
struct HDESK__{int unused;}; typedef struct HDESK__ *HDESK;
struct HENHMETAFILE__{int unused;}; typedef struct HENHMETAFILE__ *HENHMETAFILE;
struct HFONT__{int unused;}; typedef struct HFONT__ *HFONT;
struct HICON__{int unused;}; typedef struct HICON__ *HICON;
struct HMENU__{int unused;}; typedef struct HMENU__ *HMENU;
struct HMETAFILE__{int unused;}; typedef struct HMETAFILE__ *HMETAFILE;
struct HINSTANCE__{int unused;}; typedef struct HINSTANCE__ *HINSTANCE;
typedef HINSTANCE HMODULE; /* HMODULEs can be used in place of HINSTANCEs */
struct HPALETTE__{int unused;}; typedef struct HPALETTE__ *HPALETTE;
struct HPEN__{int unused;}; typedef struct HPEN__ *HPEN;
struct HRGN__{int unused;}; typedef struct HRGN__ *HRGN;
struct HRSRC__{int unused;}; typedef struct HRSRC__ *HRSRC;
struct HSPRITE__{int unused;}; typedef struct HSPRITE__ *HSPRITE;
struct HLSURF__{int unused;}; typedef struct HLSURF__ *HLSURF;
struct HSTR__{int unused;}; typedef struct HSTR__ *HSTR;
struct HTASK__{int unused;}; typedef struct HTASK__ *HTASK;
struct HWINSTA__{int unused;}; typedef struct HWINSTA__ *HWINSTA;
struct HKL__{int unused;}; typedef struct HKL__ *HKL;
struct HWINEVENTHOOK__{int unused;}; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK;
struct HMONITOR__{int unused;}; typedef struct HMONITOR__ *HMONITOR;
struct HUMPD__{int unused;}; typedef struct HUMPD__ *HUMPD;
typedef int HFILE;
typedef HICON HCURSOR; /* HICONs & HCURSORs are polymorphic */
typedef DWORD COLORREF;
typedef DWORD *LPCOLORREF;
static const int HFILE_ERROR = ((HFILE)-1);
typedef struct tagRECT
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT, *PRECT, *NPRECT, *LPRECT;
typedef const RECT * LPCRECT;
typedef struct _RECTL /* rcl */
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECTL, *PRECTL, *LPRECTL;
typedef const RECTL * LPCRECTL;
typedef struct tagPOINT
{
    LONG x;
    LONG y;
} POINT, *PPOINT, *NPPOINT, *LPPOINT;
typedef struct _POINTL /* ptl  */
{
    LONG x;
    LONG y;
} POINTL, *PPOINTL;
typedef struct tagSIZE
{
    LONG cx;
    LONG cy;
} SIZE, *PSIZE, *LPSIZE;
typedef SIZE SIZEL;
typedef SIZE *PSIZEL, *LPSIZEL;
typedef struct tagPOINTS
{
    SHORT x;
    SHORT y;
} POINTS, *PPOINTS, *LPPOINTS;
//
//  File System time stamps are represented with the following structure:
//
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;
/* mode selections for the device mode function */
static const int DM_UPDATE = 1;
static const int DM_COPY = 2;
static const int DM_PROMPT = 4;
static const int DM_MODIFY = 8;
static const int DM_IN_BUFFER = DM_MODIFY;
static const int DM_IN_PROMPT = DM_PROMPT;
static const int DM_OUT_BUFFER = DM_COPY;
static const int DM_OUT_DEFAULT = DM_UPDATE;
/* device capabilities indices */
static const int DC_FIELDS = 1;
static const int DC_PAPERS = 2;
static const int DC_PAPERSIZE = 3;
static const int DC_MINEXTENT = 4;
static const int DC_MAXEXTENT = 5;
static const int DC_BINS = 6;
static const int DC_DUPLEX = 7;
static const int DC_SIZE = 8;
static const int DC_EXTRA = 9;
static const int DC_VERSION = 10;
static const int DC_DRIVER = 11;
static const int DC_BINNAMES = 12;
static const int DC_ENUMRESOLUTIONS = 13;
static const int DC_FILEDEPENDENCIES = 14;
static const int DC_TRUETYPE = 15;
static const int DC_PAPERNAMES = 16;
static const int DC_ORIENTATION = 17;
static const int DC_COPIES = 18;
# 156 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h" 1
/************************************************************************
*                                                                       *
*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/
# 9 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
# 20 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
//
// Define API decoration for direct importing of DLL references.
//
static const int WINADVAPI = DECLSPEC_IMPORT;
static const int WINBASEAPI = DECLSPEC_IMPORT;
static const int ZAWPROXYAPI = DECLSPEC_IMPORT;
# 46 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
/*
 * Compatibility macros
 */
# 50 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
static const int DefineHandleTable(w) = ((w),TRUE);
static const int SetSwapAreaSize(w) = (w);
static const int LockSegment(w) = GlobalFix((HANDLE)(w));
static const int UnlockSegment(w) = GlobalUnfix((HANDLE)(w));
static const int GetCurrentTime() = GetTickCount();
static const int INVALID_HANDLE_VALUE = ((HANDLE)(LONG_PTR)-1);
static const int INVALID_FILE_SIZE = ((DWORD)0xFFFFFFFF);
static const int INVALID_SET_FILE_POINTER = ((DWORD)-1);
static const int INVALID_FILE_ATTRIBUTES = ((DWORD)-1);
static const int FILE_BEGIN = 0;
static const int FILE_CURRENT = 1;
static const int FILE_END = 2;
static const int TIME_ZONE_ID_INVALID = ((DWORD)0xFFFFFFFF);
static const int WAIT_FAILED = ((DWORD)0xFFFFFFFF);
static const int WAIT_OBJECT_0 = ((STATUS_WAIT_0 ) + 0 );
static const int WAIT_ABANDONED = ((STATUS_ABANDONED_WAIT_0 ) + 0 );
static const int WAIT_ABANDONED_0 = ((STATUS_ABANDONED_WAIT_0 ) + 0 );
static const int WAIT_IO_COMPLETION = STATUS_USER_APC;
static const int STILL_ACTIVE = STATUS_PENDING;
static const int EXCEPTION_ACCESS_VIOLATION = STATUS_ACCESS_VIOLATION;
static const int EXCEPTION_DATATYPE_MISALIGNMENT = STATUS_DATATYPE_MISALIGNMENT;
static const int EXCEPTION_BREAKPOINT = STATUS_BREAKPOINT;
static const int EXCEPTION_SINGLE_STEP = STATUS_SINGLE_STEP;
static const int EXCEPTION_ARRAY_BOUNDS_EXCEEDED = STATUS_ARRAY_BOUNDS_EXCEEDED;
static const int EXCEPTION_FLT_DENORMAL_OPERAND = STATUS_FLOAT_DENORMAL_OPERAND;
static const int EXCEPTION_FLT_DIVIDE_BY_ZERO = STATUS_FLOAT_DIVIDE_BY_ZERO;
static const int EXCEPTION_FLT_INEXACT_RESULT = STATUS_FLOAT_INEXACT_RESULT;
static const int EXCEPTION_FLT_INVALID_OPERATION = STATUS_FLOAT_INVALID_OPERATION;
static const int EXCEPTION_FLT_OVERFLOW = STATUS_FLOAT_OVERFLOW;
static const int EXCEPTION_FLT_STACK_CHECK = STATUS_FLOAT_STACK_CHECK;
static const int EXCEPTION_FLT_UNDERFLOW = STATUS_FLOAT_UNDERFLOW;
static const int EXCEPTION_INT_DIVIDE_BY_ZERO = STATUS_INTEGER_DIVIDE_BY_ZERO;
static const int EXCEPTION_INT_OVERFLOW = STATUS_INTEGER_OVERFLOW;
static const int EXCEPTION_PRIV_INSTRUCTION = STATUS_PRIVILEGED_INSTRUCTION;
static const int EXCEPTION_IN_PAGE_ERROR = STATUS_IN_PAGE_ERROR;
static const int EXCEPTION_ILLEGAL_INSTRUCTION = STATUS_ILLEGAL_INSTRUCTION;
static const int EXCEPTION_NONCONTINUABLE_EXCEPTION = STATUS_NONCONTINUABLE_EXCEPTION;
static const int EXCEPTION_STACK_OVERFLOW = STATUS_STACK_OVERFLOW;
static const int EXCEPTION_INVALID_DISPOSITION = STATUS_INVALID_DISPOSITION;
static const int EXCEPTION_GUARD_PAGE = STATUS_GUARD_PAGE_VIOLATION;
static const int EXCEPTION_INVALID_HANDLE = STATUS_INVALID_HANDLE;
static const int EXCEPTION_POSSIBLE_DEADLOCK = STATUS_POSSIBLE_DEADLOCK;
static const int CONTROL_C_EXIT = STATUS_CONTROL_C_EXIT;
static const int MoveMemory = RtlMoveMemory;
static const int CopyMemory = RtlCopyMemory;
static const int FillMemory = RtlFillMemory;
static const int ZeroMemory = RtlZeroMemory;
static const int SecureZeroMemory = RtlSecureZeroMemory;
static const int CaptureStackBackTrace = RtlCaptureStackBackTrace;
//
// File creation flags must start at the high end since they
// are combined with the attributes
//
static const int FILE_FLAG_WRITE_THROUGH = 0x80000000;
static const int FILE_FLAG_OVERLAPPED = 0x40000000;
static const int FILE_FLAG_NO_BUFFERING = 0x20000000;
static const int FILE_FLAG_RANDOM_ACCESS = 0x10000000;
static const int FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000;
static const int FILE_FLAG_DELETE_ON_CLOSE = 0x04000000;
static const int FILE_FLAG_BACKUP_SEMANTICS = 0x02000000;
static const int FILE_FLAG_POSIX_SEMANTICS = 0x01000000;
static const int FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000;
static const int FILE_FLAG_OPEN_NO_RECALL = 0x00100000;
static const int FILE_FLAG_FIRST_PIPE_INSTANCE = 0x00080000;
static const int CREATE_NEW = 1;
static const int CREATE_ALWAYS = 2;
static const int OPEN_EXISTING = 3;
static const int OPEN_ALWAYS = 4;
static const int TRUNCATE_EXISTING = 5;
//
// Define possible return codes from the CopyFileEx callback routine
//
static const int PROGRESS_CONTINUE = 0;
static const int PROGRESS_CANCEL = 1;
static const int PROGRESS_STOP = 2;
static const int PROGRESS_QUIET = 3;
//
// Define CopyFileEx callback routine state change values
//
static const int CALLBACK_CHUNK_FINISHED = 0x00000000;
static const int CALLBACK_STREAM_SWITCH = 0x00000001;
//
// Define CopyFileEx option flags
//
static const int COPY_FILE_FAIL_IF_EXISTS = 0x00000001;
static const int COPY_FILE_RESTARTABLE = 0x00000002;
static const int COPY_FILE_OPEN_SOURCE_FOR_WRITE = 0x00000004;
static const int COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 0x00000008;
//
//  Gap for private copyfile flags
//
static const int COPY_FILE_COPY_SYMLINK = 0x00000800;
static const int COPY_FILE_NO_BUFFERING = 0x00001000;
//
// Define ReplaceFile option flags
//
static const int REPLACEFILE_WRITE_THROUGH = 0x00000001;
static const int REPLACEFILE_IGNORE_MERGE_ERRORS = 0x00000002;
static const int REPLACEFILE_IGNORE_ACL_ERRORS = 0x00000004;
//
// Define the NamedPipe definitions
//
//
// Define the dwOpenMode values for CreateNamedPipe
//
static const int PIPE_ACCESS_INBOUND = 0x00000001;
static const int PIPE_ACCESS_OUTBOUND = 0x00000002;
static const int PIPE_ACCESS_DUPLEX = 0x00000003;
//
// Define the Named Pipe End flags for GetNamedPipeInfo
//
static const int PIPE_CLIENT_END = 0x00000000;
static const int PIPE_SERVER_END = 0x00000001;
//
// Define the dwPipeMode values for CreateNamedPipe
//
static const int PIPE_WAIT = 0x00000000;
static const int PIPE_NOWAIT = 0x00000001;
static const int PIPE_READMODE_BYTE = 0x00000000;
static const int PIPE_READMODE_MESSAGE = 0x00000002;
static const int PIPE_TYPE_BYTE = 0x00000000;
static const int PIPE_TYPE_MESSAGE = 0x00000004;
static const int PIPE_ACCEPT_REMOTE_CLIENTS = 0x00000000;
static const int PIPE_REJECT_REMOTE_CLIENTS = 0x00000008;
//
// Define the well known values for CreateNamedPipe nMaxInstances
//
static const int PIPE_UNLIMITED_INSTANCES = 255;
//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//
static const int SECURITY_ANONYMOUS = ( SecurityAnonymous << 16 );
static const int SECURITY_IDENTIFICATION = ( SecurityIdentification << 16 );
static const int SECURITY_IMPERSONATION = ( SecurityImpersonation << 16 );
static const int SECURITY_DELEGATION = ( SecurityDelegation << 16 );
static const int SECURITY_CONTEXT_TRACKING = 0x00040000;
static const int SECURITY_EFFECTIVE_ONLY = 0x00080000;
static const int SECURITY_SQOS_PRESENT = 0x00100000;
static const int SECURITY_VALID_SQOS_FLAGS = 0x001F0000;
//
//  File structures
//
typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } s;
        PVOID Pointer;
    } u;
    HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;
typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;
typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;
//
//  File System time stamps are represented with the following structure:
//
# 289 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
//
// System time is represented with the following structure:
//
typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;
typedef DWORD ( *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;
typedef void ( *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;
typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;
typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;
//
// Define one-time initialization primitive
//
typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;
static const int INIT_ONCE_STATIC_INIT = RTL_RUN_ONCE_INIT;
//
// Run once flags
//
static const int INIT_ONCE_CHECK_ONLY = RTL_RUN_ONCE_CHECK_ONLY;
static const int INIT_ONCE_ASYNC = RTL_RUN_ONCE_ASYNC;
static const int INIT_ONCE_INIT_FAILED = RTL_RUN_ONCE_INIT_FAILED;
//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//
static const int INIT_ONCE_CTX_RESERVED_BITS = RTL_RUN_ONCE_CTX_RESERVED_BITS;
//
// FailFast Exception Flags
//
static const int FAIL_FAST_GENERATE_EXCEPTION_ADDRESS = 0x1;
static const int FAIL_FAST_NO_HARD_ERROR_DLG = 0x2;
typedef
BOOL
( *PINIT_ONCE_FN) (
    PINIT_ONCE InitOnce,
    PVOID Parameter,
    PVOID *Context
    );
void
InitOnceInitialize (
    PINIT_ONCE InitOnce
    );
BOOL
InitOnceExecuteOnce (
    PINIT_ONCE InitOnce,
    PINIT_ONCE_FN InitFn,
    PVOID Parameter,
    LPVOID *Context
    );
BOOL
InitOnceBeginInitialize (
    LPINIT_ONCE lpInitOnce,
    DWORD dwFlags,
    PBOOL fPending,
    LPVOID *lpContext
    );
BOOL
InitOnceComplete (
    LPINIT_ONCE lpInitOnce,
    DWORD dwFlags,
    LPVOID lpContext
    );
//
// Define the slim r/w lock
//
typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
static const int SRWLOCK_INIT = RTL_SRWLOCK_INIT;
void
InitializeSRWLock (
     PSRWLOCK SRWLock
     );
void
ReleaseSRWLockExclusive (
     PSRWLOCK SRWLock
     );
void
ReleaseSRWLockShared (
     PSRWLOCK SRWLock
     );
void
AcquireSRWLockExclusive (
     PSRWLOCK SRWLock
     );
void
AcquireSRWLockShared (
     PSRWLOCK SRWLock
     );
BOOLEAN
TryAcquireSRWLockExclusive (
    PSRWLOCK SRWLock
    );
BOOLEAN
TryAcquireSRWLockShared (
    PSRWLOCK SRWLock
    );
//
// Define condition variable
//
typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;
void
InitializeConditionVariable (
    PCONDITION_VARIABLE ConditionVariable
    );
void
WakeConditionVariable (
    PCONDITION_VARIABLE ConditionVariable
    );
void
WakeAllConditionVariable (
    PCONDITION_VARIABLE ConditionVariable
    );
BOOL
SleepConditionVariableCS (
    PCONDITION_VARIABLE ConditionVariable,
    PCRITICAL_SECTION CriticalSection,
    DWORD dwMilliseconds
    );
BOOL
SleepConditionVariableSRW (
    PCONDITION_VARIABLE ConditionVariable,
    PSRWLOCK SRWLock,
    DWORD dwMilliseconds,
    ULONG Flags
    );
//
// Static initializer for the condition variable
//
static const int CONDITION_VARIABLE_INIT = RTL_CONDITION_VARIABLE_INIT;
//
// Flags for condition variables
//
static const int CONDITION_VARIABLE_LOCKMODE_SHARED = RTL_CONDITION_VARIABLE_LOCKMODE_SHARED;
PVOID
EncodePointer (
    PVOID Ptr
    );
PVOID
DecodePointer (
    PVOID Ptr
    );
PVOID
EncodeSystemPointer (
    PVOID Ptr
    );
PVOID
DecodeSystemPointer (
    PVOID Ptr
    );
typedef LPVOID LPLDT_ENTRY;
static const int MUTEX_MODIFY_STATE = MUTANT_QUERY_STATE;
static const int MUTEX_ALL_ACCESS = MUTANT_ALL_ACCESS;
//
// Serial provider type.
//
static const int SP_SERIALCOMM = ((DWORD)0x00000001);
//
// Provider SubTypes
//
static const int PST_UNSPECIFIED = ((DWORD)0x00000000);
static const int PST_RS232 = ((DWORD)0x00000001);
static const int PST_PARALLELPORT = ((DWORD)0x00000002);
static const int PST_RS422 = ((DWORD)0x00000003);
static const int PST_RS423 = ((DWORD)0x00000004);
static const int PST_RS449 = ((DWORD)0x00000005);
static const int PST_MODEM = ((DWORD)0x00000006);
static const int PST_FAX = ((DWORD)0x00000021);
static const int PST_SCANNER = ((DWORD)0x00000022);
static const int PST_NETWORK_BRIDGE = ((DWORD)0x00000100);
static const int PST_LAT = ((DWORD)0x00000101);
static const int PST_TCPIP_TELNET = ((DWORD)0x00000102);
static const int PST_X25 = ((DWORD)0x00000103);
//
// Provider capabilities flags.
//
static const int PCF_DTRDSR = ((DWORD)0x0001);
static const int PCF_RTSCTS = ((DWORD)0x0002);
static const int PCF_RLSD = ((DWORD)0x0004);
static const int PCF_PARITY_CHECK = ((DWORD)0x0008);
static const int PCF_XONXOFF = ((DWORD)0x0010);
static const int PCF_SETXCHAR = ((DWORD)0x0020);
static const int PCF_TOTALTIMEOUTS = ((DWORD)0x0040);
static const int PCF_INTTIMEOUTS = ((DWORD)0x0080);
static const int PCF_SPECIALCHARS = ((DWORD)0x0100);
static const int PCF_16BITMODE = ((DWORD)0x0200);
//
// Comm provider settable parameters.
//
static const int SP_PARITY = ((DWORD)0x0001);
static const int SP_BAUD = ((DWORD)0x0002);
static const int SP_DATABITS = ((DWORD)0x0004);
static const int SP_STOPBITS = ((DWORD)0x0008);
static const int SP_HANDSHAKING = ((DWORD)0x0010);
static const int SP_PARITY_CHECK = ((DWORD)0x0020);
static const int SP_RLSD = ((DWORD)0x0040);
//
// Settable baud rates in the provider.
//
static const int BAUD_075 = ((DWORD)0x00000001);
static const int BAUD_110 = ((DWORD)0x00000002);
static const int BAUD_134_5 = ((DWORD)0x00000004);
static const int BAUD_150 = ((DWORD)0x00000008);
static const int BAUD_300 = ((DWORD)0x00000010);
static const int BAUD_600 = ((DWORD)0x00000020);
static const int BAUD_1200 = ((DWORD)0x00000040);
static const int BAUD_1800 = ((DWORD)0x00000080);
static const int BAUD_2400 = ((DWORD)0x00000100);
static const int BAUD_4800 = ((DWORD)0x00000200);
static const int BAUD_7200 = ((DWORD)0x00000400);
static const int BAUD_9600 = ((DWORD)0x00000800);
static const int BAUD_14400 = ((DWORD)0x00001000);
static const int BAUD_19200 = ((DWORD)0x00002000);
static const int BAUD_38400 = ((DWORD)0x00004000);
static const int BAUD_56K = ((DWORD)0x00008000);
static const int BAUD_128K = ((DWORD)0x00010000);
static const int BAUD_115200 = ((DWORD)0x00020000);
static const int BAUD_57600 = ((DWORD)0x00040000);
static const int BAUD_USER = ((DWORD)0x10000000);
//
// Settable Data Bits
//
static const int DATABITS_5 = ((WORD)0x0001);
static const int DATABITS_6 = ((WORD)0x0002);
static const int DATABITS_7 = ((WORD)0x0004);
static const int DATABITS_8 = ((WORD)0x0008);
static const int DATABITS_16 = ((WORD)0x0010);
static const int DATABITS_16X = ((WORD)0x0020);
//
// Settable Stop and Parity bits.
//
static const int STOPBITS_10 = ((WORD)0x0001);
static const int STOPBITS_15 = ((WORD)0x0002);
static const int STOPBITS_20 = ((WORD)0x0004);
static const int PARITY_NONE = ((WORD)0x0100);
static const int PARITY_ODD = ((WORD)0x0200);
static const int PARITY_EVEN = ((WORD)0x0400);
static const int PARITY_MARK = ((WORD)0x0800);
static const int PARITY_SPACE = ((WORD)0x1000);
typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;
//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//
static const int COMMPROP_INITIALIZED = ((DWORD)0xE73CF52E);
typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;
//
// DTR Control Flow Values.
//
static const int DTR_CONTROL_DISABLE = 0x00;
static const int DTR_CONTROL_ENABLE = 0x01;
static const int DTR_CONTROL_HANDSHAKE = 0x02;
//
// RTS Control Flow Values
//
static const int RTS_CONTROL_DISABLE = 0x00;
static const int RTS_CONTROL_ENABLE = 0x01;
static const int RTS_CONTROL_HANDSHAKE = 0x02;
static const int RTS_CONTROL_TOGGLE = 0x03;
typedef struct _DCB {
    DWORD DCBlength; /* sizeof(DCB)                     */
    DWORD BaudRate; /* Baudrate at which running       */
    DWORD fBinary: 1; /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1; /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2; /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1; /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1; /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1; /* Enable Err Replacement          */
    DWORD fNull: 1; /* Enable Null stripping           */
    DWORD fRtsControl:2; /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17; /* Reserved                        */
    WORD wReserved; /* Not currently used              */
    WORD XonLim; /* Transmit X-ON threshold         */
    WORD XoffLim; /* Transmit X-OFF threshold        */
    BYTE ByteSize; /* Number of bits/byte, 4-8        */
    BYTE Parity; /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits; /* 0,1,2 = 1, 1.5, 2               */
    char XonChar; /* Tx and Rx X-ON character        */
    char XoffChar; /* Tx and Rx X-OFF character       */
    char ErrorChar; /* Error replacement char          */
    char EofChar; /* End of Input character          */
    char EvtChar; /* Received Event character        */
    WORD wReserved1; /* Fill for now.                   */
} DCB, *LPDCB;
typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout; /* Maximum time between read chars. */
    DWORD ReadTotalTimeoutMultiplier; /* Multiplier of characters.        */
    DWORD ReadTotalTimeoutConstant; /* Constant in milliseconds.        */
    DWORD WriteTotalTimeoutMultiplier; /* Multiplier of characters.        */
    DWORD WriteTotalTimeoutConstant; /* Constant in milliseconds.        */
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;
typedef struct _COMMCONFIG {
    DWORD dwSize; /* Size of the entire struct */
    WORD wVersion; /* version of the structure */
    WORD wReserved; /* alignment */
    DCB dcb; /* device control block */
    DWORD dwProviderSubType; /* ordinal value for identifying
                                   provider-defined data structure format*/
# 764 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
    DWORD dwProviderOffset; /* Specifies the offset of provider specific
                                   data field in bytes from the start */
# 766 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
    DWORD dwProviderSize; /* size of the provider-specific data field */
    WCHAR wcProviderData[1]; /* provider-specific data */
} COMMCONFIG,*LPCOMMCONFIG;
typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId; // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } s;
    } u;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;
//
//
static const int FreeModule(hLibModule) = FreeLibrary((hLibModule));
static const int MakeProcInstance(lpProc,hInstance) = (lpProc);
static const int FreeProcInstance(lpProc) = (lpProc);
/* Global Memory Flags */
static const int GMEM_FIXED = 0x0000;
static const int GMEM_MOVEABLE = 0x0002;
static const int GMEM_NOCOMPACT = 0x0010;
static const int GMEM_NODISCARD = 0x0020;
static const int GMEM_ZEROINIT = 0x0040;
static const int GMEM_MODIFY = 0x0080;
static const int GMEM_DISCARDABLE = 0x0100;
static const int GMEM_NOT_BANKED = 0x1000;
static const int GMEM_SHARE = 0x2000;
static const int GMEM_DDESHARE = 0x2000;
static const int GMEM_NOTIFY = 0x4000;
static const int GMEM_LOWER = GMEM_NOT_BANKED;
static const int GMEM_VALID_FLAGS = 0x7F72;
static const int GMEM_INVALID_HANDLE = 0x8000;
static const int GHND = (GMEM_MOVEABLE | GMEM_ZEROINIT);
static const int GPTR = (GMEM_FIXED | GMEM_ZEROINIT);
static const int GlobalLRUNewest(h) = ((HANDLE)(h));
static const int GlobalLRUOldest(h) = ((HANDLE)(h));
static const int GlobalDiscard(h) = GlobalReAlloc( (h), 0, GMEM_MOVEABLE );
/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
static const int GMEM_DISCARDED = 0x4000;
static const int GMEM_LOCKCOUNT = 0x00FF;
typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;
/* Local Memory Flags */
static const int LMEM_FIXED = 0x0000;
static const int LMEM_MOVEABLE = 0x0002;
static const int LMEM_NOCOMPACT = 0x0010;
static const int LMEM_NODISCARD = 0x0020;
static const int LMEM_ZEROINIT = 0x0040;
static const int LMEM_MODIFY = 0x0080;
static const int LMEM_DISCARDABLE = 0x0F00;
static const int LMEM_VALID_FLAGS = 0x0F72;
static const int LMEM_INVALID_HANDLE = 0x8000;
static const int LHND = (LMEM_MOVEABLE | LMEM_ZEROINIT);
static const int LPTR = (LMEM_FIXED | LMEM_ZEROINIT);
static const int NONZEROLHND = (LMEM_MOVEABLE);
static const int NONZEROLPTR = (LMEM_FIXED);
static const int LocalDiscard(h) = LocalReAlloc( (h), 0, LMEM_MOVEABLE );
/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
static const int LMEM_DISCARDED = 0x4000;
static const int LMEM_LOCKCOUNT = 0x00FF;
//
// NUMA values
//
static const int NUMA_NO_PREFERRED_NODE = ((DWORD) -1);
//
// Process dwCreationFlag values
//
static const int DEBUG_PROCESS = 0x00000001;
static const int DEBUG_ONLY_THIS_PROCESS = 0x00000002;
static const int CREATE_SUSPENDED = 0x00000004;
static const int DETACHED_PROCESS = 0x00000008;
static const int CREATE_NEW_CONSOLE = 0x00000010;
static const int NORMAL_PRIORITY_CLASS = 0x00000020;
static const int IDLE_PRIORITY_CLASS = 0x00000040;
static const int HIGH_PRIORITY_CLASS = 0x00000080;
static const int REALTIME_PRIORITY_CLASS = 0x00000100;
static const int CREATE_NEW_PROCESS_GROUP = 0x00000200;
static const int CREATE_UNICODE_ENVIRONMENT = 0x00000400;
static const int CREATE_SEPARATE_WOW_VDM = 0x00000800;
static const int CREATE_SHARED_WOW_VDM = 0x00001000;
static const int CREATE_FORCEDOS = 0x00002000;
static const int BELOW_NORMAL_PRIORITY_CLASS = 0x00004000;
static const int ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000;
static const int INHERIT_PARENT_AFFINITY = 0x00010000;
static const int INHERIT_CALLER_PRIORITY = 0x00020000;
static const int CREATE_PROTECTED_PROCESS = 0x00040000;
static const int EXTENDED_STARTUPINFO_PRESENT = 0x00080000;
static const int PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000;
static const int PROCESS_MODE_BACKGROUND_END = 0x00200000;
static const int CREATE_BREAKAWAY_FROM_JOB = 0x01000000;
static const int CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000;
static const int CREATE_DEFAULT_ERROR_MODE = 0x04000000;
static const int CREATE_NO_WINDOW = 0x08000000;
static const int PROFILE_USER = 0x10000000;
static const int PROFILE_KERNEL = 0x20000000;
static const int PROFILE_SERVER = 0x40000000;
static const int CREATE_IGNORE_SYSTEM_DEFAULT = 0x80000000;
//
// Thread dwCreationFlag values
//
//#define CREATE_SUSPENDED                  0x00000004
static const int STACK_SIZE_PARAM_IS_A_RESERVATION = 0x00010000;
//
// Priority flags
//
static const int THREAD_PRIORITY_LOWEST = THREAD_BASE_PRIORITY_MIN;
static const int THREAD_PRIORITY_BELOW_NORMAL = (THREAD_PRIORITY_LOWEST+1);
static const int THREAD_PRIORITY_NORMAL = 0;
static const int THREAD_PRIORITY_HIGHEST = THREAD_BASE_PRIORITY_MAX;
static const int THREAD_PRIORITY_ABOVE_NORMAL = (THREAD_PRIORITY_HIGHEST-1);
static const int THREAD_PRIORITY_ERROR_RETURN = (MAXLONG);
static const int THREAD_PRIORITY_TIME_CRITICAL = THREAD_BASE_PRIORITY_LOWRT;
static const int THREAD_PRIORITY_IDLE = THREAD_BASE_PRIORITY_IDLE;
static const int THREAD_MODE_BACKGROUND_BEGIN = 0x00010000;
static const int THREAD_MODE_BACKGROUND_END = 0x00020000;
//
// GetFinalPathNameByHandle
//
static const int VOLUME_NAME_DOS = 0x0;
static const int VOLUME_NAME_GUID = 0x1;
static const int VOLUME_NAME_NT = 0x2;
static const int VOLUME_NAME_NONE = 0x4;
static const int FILE_NAME_NORMALIZED = 0x0;
static const int FILE_NAME_OPENED = 0x8;
//
// Debug APIs
//
static const int EXCEPTION_DEBUG_EVENT = 1;
static const int CREATE_THREAD_DEBUG_EVENT = 2;
static const int CREATE_PROCESS_DEBUG_EVENT = 3;
static const int EXIT_THREAD_DEBUG_EVENT = 4;
static const int EXIT_PROCESS_DEBUG_EVENT = 5;
static const int LOAD_DLL_DEBUG_EVENT = 6;
static const int UNLOAD_DLL_DEBUG_EVENT = 7;
static const int OUTPUT_DEBUG_STRING_EVENT = 8;
static const int RIP_EVENT = 9;
typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;
typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;
typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;
typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;
typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;
typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;
typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;
typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;
typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;
typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;
//
// JIT Debugging Info. This structure is defined to have constant size in
// both the emulated and native environment.
//
typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;
typedef PCONTEXT LPCONTEXT;
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
static const int DRIVE_UNKNOWN = 0;
static const int DRIVE_NO_ROOT_DIR = 1;
static const int DRIVE_REMOVABLE = 2;
static const int DRIVE_FIXED = 3;
static const int DRIVE_REMOTE = 4;
static const int DRIVE_CDROM = 5;
static const int DRIVE_RAMDISK = 6;
static const int GetFreeSpace(w) = (0x100000L);
static const int FILE_TYPE_UNKNOWN = 0x0000;
static const int FILE_TYPE_DISK = 0x0001;
static const int FILE_TYPE_CHAR = 0x0002;
static const int FILE_TYPE_PIPE = 0x0003;
static const int FILE_TYPE_REMOTE = 0x8000;
static const int STD_INPUT_HANDLE = ((DWORD)-10);
static const int STD_OUTPUT_HANDLE = ((DWORD)-11);
static const int STD_ERROR_HANDLE = ((DWORD)-12);
static const int NOPARITY = 0;
static const int ODDPARITY = 1;
static const int EVENPARITY = 2;
static const int MARKPARITY = 3;
static const int SPACEPARITY = 4;
static const int ONESTOPBIT = 0;
static const int ONE5STOPBITS = 1;
static const int TWOSTOPBITS = 2;
static const int IGNORE = 0;
static const int INFINITE = 0xFFFFFFFF;
//
// Baud rates at which the communication device operates
//
static const int CBR_110 = 110;
static const int CBR_300 = 300;
static const int CBR_600 = 600;
static const int CBR_1200 = 1200;
static const int CBR_2400 = 2400;
static const int CBR_4800 = 4800;
static const int CBR_9600 = 9600;
static const int CBR_14400 = 14400;
static const int CBR_19200 = 19200;
static const int CBR_38400 = 38400;
static const int CBR_56000 = 56000;
static const int CBR_57600 = 57600;
static const int CBR_115200 = 115200;
static const int CBR_128000 = 128000;
static const int CBR_256000 = 256000;
//
// Error Flags
//
static const int CE_RXOVER = 0x0001;
static const int CE_OVERRUN = 0x0002;
static const int CE_RXPARITY = 0x0004;
static const int CE_FRAME = 0x0008;
static const int CE_BREAK = 0x0010;
static const int CE_TXFULL = 0x0100;
static const int CE_PTO = 0x0200;
static const int CE_IOE = 0x0400;
static const int CE_DNS = 0x0800;
static const int CE_OOP = 0x1000;
static const int CE_MODE = 0x8000;
static const int IE_BADID = (-1);
static const int IE_OPEN = (-2);
static const int IE_NOPEN = (-3);
static const int IE_MEMORY = (-4);
static const int IE_DEFAULT = (-5);
static const int IE_HARDWARE = (-10);
static const int IE_BYTESIZE = (-11);
static const int IE_BAUDRATE = (-12);
//
// Events
//
static const int EV_RXCHAR = 0x0001;
static const int EV_RXFLAG = 0x0002;
static const int EV_TXEMPTY = 0x0004;
static const int EV_CTS = 0x0008;
static const int EV_DSR = 0x0010;
static const int EV_RLSD = 0x0020;
static const int EV_BREAK = 0x0040;
static const int EV_ERR = 0x0080;
static const int EV_RING = 0x0100;
static const int EV_PERR = 0x0200;
static const int EV_RX80FULL = 0x0400;
static const int EV_EVENT1 = 0x0800;
static const int EV_EVENT2 = 0x1000;
//
// Escape Functions
//
static const int SETXOFF = 1;
static const int SETXON = 2;
static const int SETRTS = 3;
static const int CLRRTS = 4;
static const int SETDTR = 5;
static const int CLRDTR = 6;
static const int RESETDEV = 7;
static const int SETBREAK = 8;
static const int CLRBREAK = 9;
//
// PURGE function flags.
//
static const int PURGE_TXABORT = 0x0001;
static const int PURGE_RXABORT = 0x0002;
static const int PURGE_TXCLEAR = 0x0004;
static const int PURGE_RXCLEAR = 0x0008;
static const int LPTx = 0x80;
//
// Modem Status Flags
//
static const int MS_CTS_ON = ((DWORD)0x0010);
static const int MS_DSR_ON = ((DWORD)0x0020);
static const int MS_RING_ON = ((DWORD)0x0040);
static const int MS_RLSD_ON = ((DWORD)0x0080);
//
// WaitSoundState() Constants
//
static const int S_QUEUEEMPTY = 0;
static const int S_THRESHOLD = 1;
static const int S_ALLTHRESHOLD = 2;
//
// Accent Modes
//
static const int S_NORMAL = 0;
static const int S_LEGATO = 1;
static const int S_STACCATO = 2;
//
// SetSoundNoise() Sources
//
static const int S_PERIOD512 = 0;
static const int S_PERIOD1024 = 1;
static const int S_PERIOD2048 = 2;
static const int S_PERIODVOICE = 3;
static const int S_WHITE512 = 4;
static const int S_WHITE1024 = 5;
static const int S_WHITE2048 = 6;
static const int S_WHITEVOICE = 7;
static const int S_SERDVNA = (-1);
static const int S_SEROFM = (-2);
static const int S_SERMACT = (-3);
static const int S_SERQFUL = (-4);
static const int S_SERBDNT = (-5);
static const int S_SERDLN = (-6);
static const int S_SERDCC = (-7);
static const int S_SERDTP = (-8);
static const int S_SERDVL = (-9);
static const int S_SERDMD = (-10);
static const int S_SERDSH = (-11);
static const int S_SERDPT = (-12);
static const int S_SERDFQ = (-13);
static const int S_SERDDR = (-14);
static const int S_SERDSR = (-15);
static const int S_SERDST = (-16);
static const int NMPWAIT_WAIT_FOREVER = 0xffffffff;
static const int NMPWAIT_NOWAIT = 0x00000001;
static const int NMPWAIT_USE_DEFAULT_WAIT = 0x00000000;
static const int FS_CASE_IS_PRESERVED = FILE_CASE_PRESERVED_NAMES;
static const int FS_CASE_SENSITIVE = FILE_CASE_SENSITIVE_SEARCH;
static const int FS_UNICODE_STORED_ON_DISK = FILE_UNICODE_ON_DISK;
static const int FS_PERSISTENT_ACLS = FILE_PERSISTENT_ACLS;
static const int FS_VOL_IS_COMPRESSED = FILE_VOLUME_IS_COMPRESSED;
static const int FS_FILE_COMPRESSION = FILE_FILE_COMPRESSION;
static const int FS_FILE_ENCRYPTION = FILE_SUPPORTS_ENCRYPTION;
static const int FILE_MAP_COPY = SECTION_QUERY;
static const int FILE_MAP_WRITE = SECTION_MAP_WRITE;
static const int FILE_MAP_READ = SECTION_MAP_READ;
static const int FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;
static const int FILE_MAP_EXECUTE = SECTION_MAP_EXECUTE_EXPLICIT;
static const int OF_READ = 0x00000000;
static const int OF_WRITE = 0x00000001;
static const int OF_READWRITE = 0x00000002;
static const int OF_SHARE_COMPAT = 0x00000000;
static const int OF_SHARE_EXCLUSIVE = 0x00000010;
static const int OF_SHARE_DENY_WRITE = 0x00000020;
static const int OF_SHARE_DENY_READ = 0x00000030;
static const int OF_SHARE_DENY_NONE = 0x00000040;
static const int OF_PARSE = 0x00000100;
static const int OF_DELETE = 0x00000200;
static const int OF_VERIFY = 0x00000400;
static const int OF_CANCEL = 0x00000800;
static const int OF_CREATE = 0x00001000;
static const int OF_PROMPT = 0x00002000;
static const int OF_EXIST = 0x00004000;
static const int OF_REOPEN = 0x00008000;
static const int OFS_MAXPATHNAME = 128;
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;
# 2283 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
LONG
InterlockedIncrement (
    LONG volatile *lpAddend
    );
LONG
InterlockedDecrement (
    LONG volatile *lpAddend
    );
LONG
InterlockedExchange (
    LONG volatile *Target,
    LONG Value
    );
static const int InterlockedExchangePointer(Target,Value) = (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value));
LONG
InterlockedExchangeAdd (
    LONG volatile *Addend,
    LONG Value
    );
LONG
InterlockedCompareExchange (
    LONG volatile *Destination,
    LONG Exchange,
    LONG Comperand
    );
LONGLONG
InterlockedCompareExchange64 (
    LONGLONG volatile *Destination,
    LONGLONG Exchange,
    LONGLONG Comperand
    );
__inline
LONGLONG
InterlockedAnd64 (
    LONGLONG volatile *Destination,
    LONGLONG Value
    )
{
    LONGLONG Old;
    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);
    return Old;
}
__inline
LONGLONG
InterlockedOr64 (
    LONGLONG volatile *Destination,
    LONGLONG Value
    )
{
    LONGLONG Old;
    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);
    return Old;
}
__inline
LONGLONG
InterlockedXor64 (
    LONGLONG volatile *Destination,
    LONGLONG Value
    )
{
    LONGLONG Old;
    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);
    return Old;
}
__inline
LONGLONG
InterlockedIncrement64 (
    LONGLONG volatile *Addend
    )
{
    LONGLONG Old;
    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + 1,
                                          Old) != Old);
    return Old + 1;
}
__inline
LONGLONG
InterlockedDecrement64 (
    LONGLONG volatile *Addend
    )
{
    LONGLONG Old;
    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old - 1,
                                          Old) != Old);
    return Old - 1;
}
__inline
LONGLONG
InterlockedExchange64 (
    LONGLONG volatile *Target,
    LONGLONG Value
    )
{
    LONGLONG Old;
    do {
        Old = *Target;
    } while (InterlockedCompareExchange64(Target,
                                          Value,
                                          Old) != Old);
    return Old;
}
__inline
LONGLONG
InterlockedExchangeAdd64(
    LONGLONG volatile *Addend,
    LONGLONG Value
    )
{
    LONGLONG Old;
    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);
    return Old;
}
//
// Use a function for C++ so X86 will generate the same errors as RISC.
//
# 2495 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
static const int InterlockedCompareExchangePointer(Destination,ExChange,Comperand) = (PVOID)(LONG_PTR)InterlockedCompareExchange((LONG volatile *)(Destination), (LONG)(LONG_PTR)(ExChange), (LONG)(LONG_PTR)(Comperand));
static const int InterlockedIncrementAcquire = InterlockedIncrement;
static const int InterlockedIncrementRelease = InterlockedIncrement;
static const int InterlockedDecrementAcquire = InterlockedDecrement;
static const int InterlockedDecrementRelease = InterlockedDecrement;
static const int InterlockedIncrementAcquire = InterlockedIncrement;
static const int InterlockedIncrementRelease = InterlockedIncrement;
static const int InterlockedCompareExchangeAcquire = InterlockedCompareExchange;
static const int InterlockedCompareExchangeRelease = InterlockedCompareExchange;
static const int InterlockedCompareExchangeAcquire64 = InterlockedCompareExchange64;
static const int InterlockedCompareExchangeRelease64 = InterlockedCompareExchange64;
static const int InterlockedCompareExchangePointerAcquire = InterlockedCompareExchangePointer;
static const int InterlockedCompareExchangePointerRelease = InterlockedCompareExchangePointer;
void
InitializeSListHead (
    PSLIST_HEADER ListHead
    );
PSLIST_ENTRY
InterlockedPopEntrySList (
    PSLIST_HEADER ListHead
    );
PSLIST_ENTRY
InterlockedPushEntrySList (
    PSLIST_HEADER ListHead,
    PSLIST_ENTRY ListEntry
    );
PSLIST_ENTRY
InterlockedFlushSList (
    PSLIST_HEADER ListHead
    );
USHORT
QueryDepthSList (
    PSLIST_HEADER ListHead
    );
BOOL
FreeResource(
    HGLOBAL hResData
    );
LPVOID
LockResource(
    HGLOBAL hResData
    );
static const int UnlockResource(hResData) = ((hResData), 0);
static const int MAXINTATOM = 0xC000;
static const int MAKEINTATOM(i) = (LPTSTR)((ULONG_PTR)((WORD)(i)));
static const int INVALID_ATOM = ((ATOM)0);
int
WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    );
int
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR lpCmdLine,
    int nShowCmd
    );
BOOL
FreeLibrary (
    HMODULE hLibModule
    );
void
FreeLibraryAndExitThread (
    HMODULE hLibModule,
    DWORD dwExitCode
    );
BOOL
DisableThreadLibraryCalls (
    HMODULE hLibModule
    );
FARPROC
GetProcAddress (
    HMODULE hModule,
    LPCSTR lpProcName
    );
DWORD
GetVersion (
    void
    );
HGLOBAL
GlobalAlloc (
    UINT uFlags,
    SIZE_T dwBytes
    );
HGLOBAL
GlobalReAlloc (
    HGLOBAL hMem,
    SIZE_T dwBytes,
    UINT uFlags
    );
SIZE_T
GlobalSize (
    HGLOBAL hMem
    );
UINT
GlobalFlags (
    HGLOBAL hMem
    );
LPVOID
GlobalLock (
    HGLOBAL hMem
    );
HGLOBAL
GlobalHandle (
    LPCVOID pMem
    );
BOOL
GlobalUnlock(
    HGLOBAL hMem
    );
HGLOBAL
GlobalFree(
    HGLOBAL hMem
    );
SIZE_T
GlobalCompact(
    DWORD dwMinFree
    );
void
GlobalFix(
    HGLOBAL hMem
    );
void
GlobalUnfix(
    HGLOBAL hMem
    );
LPVOID
GlobalWire(
    HGLOBAL hMem
    );
BOOL
GlobalUnWire(
    HGLOBAL hMem
    );
void
GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    );
typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;
BOOL
GlobalMemoryStatusEx(
    LPMEMORYSTATUSEX lpBuffer
    );
HLOCAL
LocalAlloc(
    UINT uFlags,
    SIZE_T uBytes
    );
HLOCAL
LocalReAlloc(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    );
LPVOID
LocalLock(
    HLOCAL hMem
    );
HLOCAL
LocalHandle(
    LPCVOID pMem
    );
BOOL
LocalUnlock(
    HLOCAL hMem
    );
SIZE_T
LocalSize(
    HLOCAL hMem
    );
UINT
LocalFlags(
    HLOCAL hMem
    );
HLOCAL
LocalFree(
    HLOCAL hMem
    );
SIZE_T
LocalShrink(
    HLOCAL hMem,
    UINT cbNewSize
    );
SIZE_T
LocalCompact(
    UINT uMinFree
    );
BOOL
FlushInstructionCache(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    SIZE_T dwSize
    );
void
FlushProcessWriteBuffers(
    void
    );
BOOL
QueryThreadCycleTime (
    HANDLE ThreadHandle,
    PULONG64 CycleTime
    );
BOOL
QueryProcessCycleTime (
    HANDLE ProcessHandle,
    PULONG64 CycleTime
    );
BOOL
QueryIdleProcessorCycleTime (
    PULONG BufferLength,
    PULONG64 ProcessorIdleCycleTime
    );
BOOL
QueryIdleProcessorCycleTimeEx (
    USHORT Group,
    PULONG BufferLength,
    PULONG64 ProcessorIdleCycleTime
    );
BOOL
QueryUnbiasedInterruptTime (
    PULONGLONG UnbiasedTime
    );
BOOL
GetProcessorSystemCycleTime (
    USHORT Group,
    PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
    PDWORD ReturnedLength
    );
LPVOID
VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );
BOOL
VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    );
BOOL
VirtualProtect(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );
SIZE_T
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    );
LPVOID
VirtualAllocEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );
LPVOID
VirtualAllocExNuma(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect,
    DWORD nndPreferred
    );
UINT
GetWriteWatch(
    DWORD dwFlags,
    PVOID lpBaseAddress,
    SIZE_T dwRegionSize,
    PVOID *lpAddresses,
    ULONG_PTR *lpdwCount,
    PULONG lpdwGranularity
    );
UINT
ResetWriteWatch(
    LPVOID lpBaseAddress,
    SIZE_T dwRegionSize
    );
SIZE_T
GetLargePageMinimum(
    void
    );
UINT
EnumSystemFirmwareTables(
    DWORD FirmwareTableProviderSignature,
    PVOID pFirmwareTableEnumBuffer,
    DWORD BufferSize
    );
UINT
GetSystemFirmwareTable(
    DWORD FirmwareTableProviderSignature,
    DWORD FirmwareTableID,
    PVOID pFirmwareTableBuffer,
    DWORD BufferSize
    );
BOOL
GetPhysicallyInstalledSystemMemory(
    PULONGLONG TotalMemoryInKilobytes
    );
BOOL
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    );
BOOL
VirtualProtectEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );
SIZE_T
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    );
HANDLE
HeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    );
BOOL
HeapDestroy(
    HANDLE hHeap
    );
LPVOID
HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    SIZE_T dwBytes
    );
LPVOID
HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    SIZE_T dwBytes
    );
BOOL
HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );
SIZE_T
HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );
BOOL
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );
SIZE_T
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    );
HANDLE
GetProcessHeap( void );
DWORD
GetProcessHeaps(
    DWORD NumberOfHeaps,
    PHANDLE ProcessHeaps
    );
typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    } u;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;
static const int PROCESS_HEAP_REGION = 0x0001;
static const int PROCESS_HEAP_UNCOMMITTED_RANGE = 0x0002;
static const int PROCESS_HEAP_ENTRY_BUSY = 0x0004;
static const int PROCESS_HEAP_ENTRY_MOVEABLE = 0x0010;
static const int PROCESS_HEAP_ENTRY_DDESHARE = 0x0020;
BOOL
HeapLock(
    HANDLE hHeap
    );
BOOL
HeapUnlock(
    HANDLE hHeap
    );
BOOL
HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    );
BOOL
HeapSetInformation (
    HANDLE HeapHandle,
    HEAP_INFORMATION_CLASS HeapInformationClass,
    PVOID HeapInformation,
    SIZE_T HeapInformationLength
    );
BOOL
HeapQueryInformation (
    HANDLE HeapHandle,
    HEAP_INFORMATION_CLASS HeapInformationClass,
    PVOID HeapInformation,
    SIZE_T HeapInformationLength,
    PSIZE_T ReturnLength
    );
// GetBinaryType return values.
static const int SCS_32BIT_BINARY = 0;
static const int SCS_DOS_BINARY = 1;
static const int SCS_WOW_BINARY = 2;
static const int SCS_PIF_BINARY = 3;
static const int SCS_POSIX_BINARY = 4;
static const int SCS_OS216_BINARY = 5;
static const int SCS_64BIT_BINARY = 6;
static const int SCS_THIS_PLATFORM_BINARY = SCS_64BIT_BINARY;
BOOL
GetBinaryTypeA(
    LPCSTR lpApplicationName,
    LPDWORD lpBinaryType
    );
BOOL
GetBinaryTypeW(
    LPCWSTR lpApplicationName,
    LPDWORD lpBinaryType
    );
static const int GetBinaryType = GetBinaryTypeA;
DWORD
GetShortPathNameA(
    LPCSTR lpszLongPath,
    LPSTR lpszShortPath,
    DWORD cchBuffer
    );
DWORD
GetShortPathNameW(
    LPCWSTR lpszLongPath,
    LPWSTR lpszShortPath,
    DWORD cchBuffer
    );
static const int GetShortPathName = GetShortPathNameA;
DWORD
GetLongPathNameA(
    LPCSTR lpszShortPath,
    LPSTR lpszLongPath,
    DWORD cchBuffer
    );
DWORD
GetLongPathNameW(
    LPCWSTR lpszShortPath,
    LPWSTR lpszLongPath,
    DWORD cchBuffer
    );
static const int GetLongPathName = GetLongPathNameA;
DWORD
GetLongPathNameTransactedA(
    LPCSTR lpszShortPath,
    LPSTR lpszLongPath,
    DWORD cchBuffer,
    HANDLE hTransaction
    );
DWORD
GetLongPathNameTransactedW(
    LPCWSTR lpszShortPath,
    LPWSTR lpszLongPath,
    DWORD cchBuffer,
    HANDLE hTransaction
    );
static const int GetLongPathNameTransacted = GetLongPathNameTransactedA;
BOOL
GetProcessAffinityMask(
    HANDLE hProcess,
    PDWORD_PTR lpProcessAffinityMask,
    PDWORD_PTR lpSystemAffinityMask
    );
BOOL
SetProcessAffinityMask(
    HANDLE hProcess,
    DWORD_PTR dwProcessAffinityMask
    );
BOOL
GetProcessGroupAffinity(
    HANDLE hProcess,
    PUSHORT GroupCount,
    PUSHORT GroupArray
    );
BOOL
GetProcessHandleCount(
    HANDLE hProcess,
    PDWORD pdwHandleCount
    );
BOOL
GetProcessTimes(
    HANDLE hProcess,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );
BOOL
GetProcessIoCounters(
    HANDLE hProcess,
    PIO_COUNTERS lpIoCounters
    );
BOOL
GetProcessWorkingSetSize(
    HANDLE hProcess,
    PSIZE_T lpMinimumWorkingSetSize,
    PSIZE_T lpMaximumWorkingSetSize
    );
BOOL
GetProcessWorkingSetSizeEx(
    HANDLE hProcess,
    PSIZE_T lpMinimumWorkingSetSize,
    PSIZE_T lpMaximumWorkingSetSize,
    PDWORD Flags
    );
BOOL
SetProcessWorkingSetSize(
    HANDLE hProcess,
    SIZE_T dwMinimumWorkingSetSize,
    SIZE_T dwMaximumWorkingSetSize
    );
BOOL
SetProcessWorkingSetSizeEx(
    HANDLE hProcess,
    SIZE_T dwMinimumWorkingSetSize,
    SIZE_T dwMaximumWorkingSetSize,
    DWORD Flags
    );
static const int PROCESS_AFFINITY_ENABLE_AUTO_UPDATE = 0x00000001UL;
BOOL
SetProcessAffinityUpdateMode(
    HANDLE hProcess,
    DWORD dwFlags
    );
BOOL
QueryProcessAffinityUpdateMode(
    HANDLE hProcess,
    LPDWORD lpdwFlags
    );
HANDLE
OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    );
HANDLE
GetCurrentProcess(
    void
    );
DWORD
GetCurrentProcessId(
    void
    );
void
ExitProcess(
    UINT uExitCode
    );
BOOL
TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    );
BOOL
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    );
void
FatalExit(
    int ExitCode
    );
LPCH
GetEnvironmentStrings(
    void
    );
LPWCH
GetEnvironmentStringsW(
    void
    );
static const int GetEnvironmentStringsA = GetEnvironmentStrings;
BOOL
SetEnvironmentStringsA(
    LPCH NewEnvironment
    );
BOOL
SetEnvironmentStringsW(
    LPWCH NewEnvironment
    );
static const int SetEnvironmentStrings = SetEnvironmentStringsA;
BOOL
FreeEnvironmentStringsA(
    LPCH
    );
BOOL
FreeEnvironmentStringsW(
    LPWCH
    );
static const int FreeEnvironmentStrings = FreeEnvironmentStringsA;
void
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    const ULONG_PTR *lpArguments
    );
void
RaiseFailFastException(
    PEXCEPTION_RECORD pExceptionRecord,
    PCONTEXT pContextRecord,
    DWORD dwFlags
    );
LONG
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef LONG ( *PTOP_LEVEL_EXCEPTION_FILTER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
LPTOP_LEVEL_EXCEPTION_FILTER
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );
//
// Fiber creation flags
//
static const int FIBER_FLAG_FLOAT_SWITCH = 0x1;
LPVOID
CreateFiber(
    SIZE_T dwStackSize,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );
LPVOID
CreateFiberEx(
    SIZE_T dwStackCommitSize,
    SIZE_T dwStackReserveSize,
    DWORD dwFlags,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );
void
DeleteFiber(
    LPVOID lpFiber
    );
LPVOID
ConvertThreadToFiber(
    LPVOID lpParameter
    );
LPVOID
ConvertThreadToFiberEx(
    LPVOID lpParameter,
    DWORD dwFlags
    );
BOOL
ConvertFiberToThread(
    void
    );
BOOL
IsThreadAFiber(
    void
    );
void
SwitchToFiber(
    LPVOID lpFiber
    );
BOOL
SwitchToThread(
    void
    );
//
// UMS begin
//
static const int UMS_VERSION = RTL_UMS_VERSION;
typedef void *PUMS_CONTEXT;
typedef void *PUMS_COMPLETION_LIST;
typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;
typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;
typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;
typedef struct _UMS_SCHEDULER_STARTUP_INFO {
    //
    // UMS Version the application was built to. Should be set to UMS_VERSION
    //
    ULONG UmsVersion;
    //
    // Completion List to associate the new User Scheduler to.
    //
    PUMS_COMPLETION_LIST CompletionList;
    //
    // A pointer to the application-defined function that represents the starting
    // address of the Sheduler.
    //
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;
    //
    // pointer to a variable to be passed to the scheduler uppon first activation.
    //
    PVOID SchedulerParam;
} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;
BOOL
CreateUmsCompletionList(
    PUMS_COMPLETION_LIST* UmsCompletionList
    );
BOOL
DequeueUmsCompletionListItems(
    PUMS_COMPLETION_LIST UmsCompletionList,
    DWORD WaitTimeOut,
    PUMS_CONTEXT* UmsThreadList
    );
BOOL
GetUmsCompletionListEvent(
    PUMS_COMPLETION_LIST UmsCompletionList,
    PHANDLE UmsCompletionEvent
    );
BOOL
ExecuteUmsThread(
    PUMS_CONTEXT UmsThread
    );
BOOL
UmsThreadYield(
    PVOID SchedulerParam
    );
BOOL
DeleteUmsCompletionList(
    PUMS_COMPLETION_LIST UmsCompletionList
    );
PUMS_CONTEXT
GetCurrentUmsThread(
    void
    );
PUMS_CONTEXT
GetNextUmsListItem(
    PUMS_CONTEXT UmsContext
    );
BOOL
QueryUmsThreadInformation(
    PUMS_CONTEXT UmsThread,
    UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
    PVOID UmsThreadInformation,
    ULONG UmsThreadInformationLength,
    PULONG ReturnLength
    );
BOOL
SetUmsThreadInformation(
    PUMS_CONTEXT UmsThread,
    UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
    PVOID UmsThreadInformation,
    ULONG UmsThreadInformationLength
    );
BOOL
DeleteUmsThreadContext(
    PUMS_CONTEXT UmsThread
    );
BOOL
CreateUmsThreadContext(
    PUMS_CONTEXT *lpUmsThread
    );
BOOL
EnterUmsSchedulingMode(
    PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
    );
//
// UMS end
//
typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;
HANDLE
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );
HANDLE
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );
HANDLE
CreateRemoteThreadEx(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    LPDWORD lpThreadId
    );
HANDLE
GetCurrentThread(
    void
    );
DWORD
GetCurrentThreadId(
    void
    );
BOOL
SetThreadStackGuarantee (
    PULONG StackSizeInBytes
    );
DWORD
GetProcessIdOfThread(
    HANDLE Thread
    );
DWORD
GetThreadId(
    HANDLE Thread
    );
DWORD
GetProcessId(
    HANDLE Process
    );
DWORD
GetCurrentProcessorNumber(
    void
    );
void
GetCurrentProcessorNumberEx(
    PPROCESSOR_NUMBER ProcNumber
    );
BOOL
GetThreadGroupAffinity(
    HANDLE hThread,
    PGROUP_AFFINITY GroupAffinity
    );
DWORD_PTR
SetThreadAffinityMask(
    HANDLE hThread,
    DWORD_PTR dwThreadAffinityMask
    );
BOOL
SetThreadGroupAffinity(
    HANDLE hThread,
    const GROUP_AFFINITY *GroupAffinity,
    PGROUP_AFFINITY PreviousGroupAffinity
    );
BOOL
SetThreadIdealProcessorEx (
    HANDLE hThread,
    PPROCESSOR_NUMBER lpIdealProcessor,
    PPROCESSOR_NUMBER lpPreviousIdealProcessor
    );
BOOL
GetThreadIdealProcessorEx (
    HANDLE hThread,
    PPROCESSOR_NUMBER lpIdealProcessor
    );
DWORD
SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD dwIdealProcessor
    );
static const int PROCESS_DEP_ENABLE = 0x00000001;
static const int PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION = 0x00000002;
BOOL
SetProcessDEPPolicy(
    DWORD dwFlags
    );
BOOL
GetProcessDEPPolicy(
    HANDLE hProcess,
    LPDWORD lpFlags,
    PBOOL lpPermanent
    );
BOOL
SetProcessPriorityBoost(
    HANDLE hProcess,
    BOOL bDisablePriorityBoost
    );
BOOL
GetProcessPriorityBoost(
    HANDLE hProcess,
    PBOOL pDisablePriorityBoost
    );
BOOL
RequestWakeupLatency(
    LATENCY_TIME latency
    );
BOOL
IsSystemResumeAutomatic(
    void
    );
HANDLE
OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    );
BOOL
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    );
BOOL
SetThreadPriorityBoost(
    HANDLE hThread,
    BOOL bDisablePriorityBoost
    );
BOOL
GetThreadPriorityBoost(
    HANDLE hThread,
    PBOOL pDisablePriorityBoost
    );
int
GetThreadPriority(
    HANDLE hThread
    );
BOOL
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );
BOOL
GetThreadIOPendingFlag(
    HANDLE hThread,
    PBOOL lpIOIsPending
    );
void
ExitThread(
    DWORD dwExitCode
    );
BOOL
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    );
BOOL
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    );
BOOL
GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    );
EXECUTION_STATE
SetThreadExecutionState(
    EXECUTION_STATE esFlags
    );
typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;
        } Detailed;
        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;
//
// Power Request APIs
//
typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;
HANDLE
PowerCreateRequest (
    PREASON_CONTEXT Context
    );
BOOL
PowerSetRequest (
    HANDLE PowerRequest,
    POWER_REQUEST_TYPE RequestType
    );
BOOL
PowerClearRequest (
    HANDLE PowerRequest,
    POWER_REQUEST_TYPE RequestType
    );
DWORD
GetLastError(
    void
    );
void
SetLastError(
    DWORD dwErrCode
    );
//#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)
# 4286 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
static const int HasOverlappedIoCompleted(lpOverlapped) = (((DWORD)(lpOverlapped)->Internal) != STATUS_PENDING);
BOOL
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );
HANDLE
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    ULONG_PTR CompletionKey,
    DWORD NumberOfConcurrentThreads
    );
BOOL
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    );
BOOL
GetQueuedCompletionStatusEx(
    HANDLE CompletionPort,
    LPOVERLAPPED_ENTRY lpCompletionPortEntries,
    ULONG ulCount,
    PULONG ulNumEntriesRemoved,
    DWORD dwMilliseconds,
    BOOL fAlertable
    );
BOOL
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    ULONG_PTR dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    );
//
// The following flags allows an application to change
// the semantics of IO completion notification.
//
//
// Don't queue an entry to an associated completion port if returning success
// synchronously.
//
static const int FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = 0x1;
//
// Don't set the file handle event on IO completion.
//
static const int FILE_SKIP_SET_EVENT_ON_HANDLE = 0x2;
BOOL
SetFileCompletionNotificationModes(
    HANDLE FileHandle,
    UCHAR Flags
    );
BOOL
SetFileIoOverlappedRange(
    HANDLE FileHandle,
    PUCHAR OverlappedRangeStart,
    ULONG Length
    );
static const int SEM_FAILCRITICALERRORS = 0x0001;
static const int SEM_NOGPFAULTERRORBOX = 0x0002;
static const int SEM_NOALIGNMENTFAULTEXCEPT = 0x0004;
static const int SEM_NOOPENFILEERRORBOX = 0x8000;
UINT
GetErrorMode(
    void
    );
UINT
SetErrorMode(
    UINT uMode
    );
//
// Thread error mode support
//
DWORD
GetThreadErrorMode(
    void
    );
BOOL
SetThreadErrorMode(
    DWORD dwNewMode,
    LPDWORD lpOldMode
    );
BOOL
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T * lpNumberOfBytesRead
    );
BOOL
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T * lpNumberOfBytesWritten
    );
BOOL
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    );
BOOL
SetThreadContext(
    HANDLE hThread,
    const CONTEXT *lpContext
    );
BOOL
Wow64GetThreadContext(
    HANDLE hThread,
    PWOW64_CONTEXT lpContext
    );
BOOL
Wow64GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    PWOW64_LDT_ENTRY lpSelectorEntry
    );
BOOL
Wow64SetThreadContext(
    HANDLE hThread,
    const WOW64_CONTEXT *lpContext
    );
DWORD
SuspendThread(
    HANDLE hThread
    );
DWORD
Wow64SuspendThread(
    HANDLE hThread
    );
DWORD
ResumeThread(
    HANDLE hThread
    );
DWORD
QueueUserAPC(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
    );
BOOL
IsDebuggerPresent(
    void
    );
BOOL
CheckRemoteDebuggerPresent(
    HANDLE hProcess,
    PBOOL pbDebuggerPresent
    );
void
DebugBreak(
    void
    );
BOOL
WaitForDebugEvent(
    LPDEBUG_EVENT lpDebugEvent,
    DWORD dwMilliseconds
    );
BOOL
ContinueDebugEvent(
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwContinueStatus
    );
BOOL
DebugActiveProcess(
    DWORD dwProcessId
    );
BOOL
DebugActiveProcessStop(
    DWORD dwProcessId
    );
BOOL
DebugSetProcessKillOnExit(
    BOOL KillOnExit
    );
BOOL
DebugBreakProcess (
    HANDLE Process
    );
void
InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );
void
EnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );
void
LeaveCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );
static const int CRITICAL_SECTION_NO_DEBUG_INFO = RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO;
BOOL
InitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    );
BOOL
InitializeCriticalSectionEx(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount,
    DWORD Flags
    );
DWORD
SetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    );
BOOL
TryEnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );
void
DeleteCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );
BOOL
SetEvent(
    HANDLE hEvent
    );
BOOL
ResetEvent(
    HANDLE hEvent
    );
BOOL
PulseEvent(
    HANDLE hEvent
    );
BOOL
ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    );
BOOL
ReleaseMutex(
    HANDLE hMutex
    );
DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    );
DWORD
WaitForMultipleObjects(
    DWORD nCount,
    const HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    );
void
Sleep(
    DWORD dwMilliseconds
    );
HGLOBAL
LoadResource(
    HMODULE hModule,
    HRSRC hResInfo
    );
DWORD
SizeofResource(
    HMODULE hModule,
    HRSRC hResInfo
    );
ATOM
GlobalDeleteAtom(
    ATOM nAtom
    );
BOOL
InitAtomTable(
    DWORD nSize
    );
ATOM
DeleteAtom(
    ATOM nAtom
    );
UINT
SetHandleCount(
    UINT uNumber
    );
DWORD
GetLogicalDrives(
    void
    );
BOOL
LockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh
    );
BOOL
UnlockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh
    );
BOOL
LockFileEx(
    HANDLE hFile,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped
    );
static const int LOCKFILE_FAIL_IMMEDIATELY = 0x00000001;
static const int LOCKFILE_EXCLUSIVE_LOCK = 0x00000002;
BOOL
UnlockFileEx(
    HANDLE hFile,
    DWORD dwReserved,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh,
    LPOVERLAPPED lpOverlapped
    );
typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;
BOOL
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );
DWORD
GetFileType(
    HANDLE hFile
    );
DWORD
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    );
BOOL
GetFileSizeEx(
    HANDLE hFile,
    PLARGE_INTEGER lpFileSize
    );
HANDLE
GetStdHandle(
    DWORD nStdHandle
    );
BOOL
SetStdHandle(
    DWORD nStdHandle,
    HANDLE hHandle
    );
BOOL
SetStdHandleEx(
    DWORD nStdHandle,
    HANDLE hHandle,
    PHANDLE phPrevValue
    );
BOOL
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    );
BOOL
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );
BOOL
FlushFileBuffers(
    HANDLE hFile
    );
BOOL
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    );
BOOL
RequestDeviceWakeup(
    HANDLE hDevice
    );
BOOL
CancelDeviceWakeupRequest(
    HANDLE hDevice
    );
BOOL
GetDevicePowerState(
    HANDLE hDevice,
    BOOL *pfOn
    );
BOOL
SetMessageWaitingIndicator(
    HANDLE hMsgIndicator,
    ULONG ulMsgCount
    );
BOOL
SetEndOfFile(
    HANDLE hFile
    );
DWORD
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    );
BOOL
SetFilePointerEx(
    HANDLE hFile,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER lpNewFilePointer,
    DWORD dwMoveMethod
    );
BOOL
FindClose(
    HANDLE hFindFile
    );
BOOL
GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    );
BOOL
SetFileTime(
    HANDLE hFile,
    const FILETIME *lpCreationTime,
    const FILETIME *lpLastAccessTime,
    const FILETIME *lpLastWriteTime
    );
BOOL
SetFileValidData(
    HANDLE hFile,
    LONGLONG ValidDataLength
    );
BOOL
SetFileShortNameA(
    HANDLE hFile,
    LPCSTR lpShortName
    );
BOOL
SetFileShortNameW(
    HANDLE hFile,
    LPCWSTR lpShortName
    );
static const int SetFileShortName = SetFileShortNameA;
BOOL
CloseHandle(
    HANDLE hObject
    );
BOOL
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    );
BOOL
GetHandleInformation(
    HANDLE hObject,
    LPDWORD lpdwFlags
    );
BOOL
SetHandleInformation(
    HANDLE hObject,
    DWORD dwMask,
    DWORD dwFlags
    );
static const int HANDLE_FLAG_INHERIT = 0x00000001;
static const int HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002;
static const int HINSTANCE_ERROR = 32;
DWORD
LoadModule(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    );
UINT
WinExec(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    );
BOOL
ClearCommBreak(
    HANDLE hFile
    );
BOOL
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    );
BOOL
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    );
BOOL
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    );
BOOL
GetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );
BOOL
GetCommMask(
    HANDLE hFile,
    LPDWORD lpEvtMask
    );
BOOL
GetCommProperties(
    HANDLE hFile,
    LPCOMMPROP lpCommProp
    );
BOOL
GetCommModemStatus(
    HANDLE hFile,
    LPDWORD lpModemStat
    );
BOOL
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );
BOOL
GetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
BOOL
PurgeComm(
    HANDLE hFile,
    DWORD dwFlags
    );
BOOL
SetCommBreak(
    HANDLE hFile
    );
BOOL
SetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );
BOOL
SetCommMask(
    HANDLE hFile,
    DWORD dwEvtMask
    );
BOOL
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );
BOOL
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
BOOL
TransmitCommChar(
    HANDLE hFile,
    char cChar
    );
BOOL
WaitCommEvent(
    HANDLE hFile,
    LPDWORD lpEvtMask,
    LPOVERLAPPED lpOverlapped
    );
DWORD
SetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionMethod,
    DWORD dwPartition,
    DWORD dwOffsetLow,
    DWORD dwOffsetHigh,
    BOOL bImmediate
    );
DWORD
GetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionType,
    LPDWORD lpdwPartition,
    LPDWORD lpdwOffsetLow,
    LPDWORD lpdwOffsetHigh
    );
DWORD
PrepareTape(
    HANDLE hDevice,
    DWORD dwOperation,
    BOOL bImmediate
    );
DWORD
EraseTape(
    HANDLE hDevice,
    DWORD dwEraseType,
    BOOL bImmediate
    );
DWORD
CreateTapePartition(
    HANDLE hDevice,
    DWORD dwPartitionMethod,
    DWORD dwCount,
    DWORD dwSize
    );
DWORD
WriteTapemark(
    HANDLE hDevice,
    DWORD dwTapemarkType,
    DWORD dwTapemarkCount,
    BOOL bImmediate
    );
DWORD
GetTapeStatus(
    HANDLE hDevice
    );
DWORD
GetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPDWORD lpdwSize,
    LPVOID lpTapeInformation
    );
static const int GET_TAPE_MEDIA_INFORMATION = 0;
static const int GET_TAPE_DRIVE_INFORMATION = 1;
DWORD
SetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPVOID lpTapeInformation
    );
static const int SET_TAPE_MEDIA_INFORMATION = 0;
static const int SET_TAPE_DRIVE_INFORMATION = 1;
BOOL
Beep(
    DWORD dwFreq,
    DWORD dwDuration
    );
int
MulDiv(
    int nNumber,
    int nNumerator,
    int nDenominator
    );
void
GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    );
void
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    );
BOOL
SetSystemTime(
    const SYSTEMTIME *lpSystemTime
    );
void
GetLocalTime(
    LPSYSTEMTIME lpSystemTime
    );
BOOL
SetLocalTime(
    const SYSTEMTIME *lpSystemTime
    );
void
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );
typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;
DEP_SYSTEM_POLICY_TYPE
GetSystemDEPPolicy(
    void
    );
static const int FILE_CACHE_MAX_HARD_ENABLE = 0x00000001;
static const int FILE_CACHE_MAX_HARD_DISABLE = 0x00000002;
static const int FILE_CACHE_MIN_HARD_ENABLE = 0x00000004;
static const int FILE_CACHE_MIN_HARD_DISABLE = 0x00000008;
BOOL
SetSystemFileCacheSize (
    SIZE_T MinimumFileCacheSize,
    SIZE_T MaximumFileCacheSize,
    DWORD Flags
    );
BOOL
GetSystemFileCacheSize (
    PSIZE_T lpMinimumFileCacheSize,
    PSIZE_T lpMaximumFileCacheSize,
    PDWORD lpFlags
    );
BOOL
GetSystemRegistryQuota(
    PDWORD pdwQuotaAllowed,
    PDWORD pdwQuotaUsed
    );
BOOL
GetSystemTimes(
    LPFILETIME lpIdleTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );
void
GetNativeSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );
BOOL
IsProcessorFeaturePresent(
    DWORD ProcessorFeature
    );
typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;
typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;
BOOL
SystemTimeToTzSpecificLocalTime(
    const TIME_ZONE_INFORMATION *lpTimeZoneInformation,
    const SYSTEMTIME *lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    );
BOOL
TzSpecificLocalTimeToSystemTime(
    const TIME_ZONE_INFORMATION *lpTimeZoneInformation,
    const SYSTEMTIME *lpLocalTime,
    LPSYSTEMTIME lpUniversalTime
    );
BOOL
GetTimeZoneInformationForYear(
    USHORT wYear,
    PDYNAMIC_TIME_ZONE_INFORMATION pdtzi,
    LPTIME_ZONE_INFORMATION ptzi
    );
DWORD
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );
BOOL
SetTimeZoneInformation(
    const TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );
DWORD
GetDynamicTimeZoneInformation(
    PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );
BOOL
SetDynamicTimeZoneInformation(
    const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );
//
// Routines to convert back and forth between system time and file time
//
BOOL
SystemTimeToFileTime(
    const SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    );
BOOL
FileTimeToLocalFileTime(
    const FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    );
BOOL
LocalFileTimeToFileTime(
    const FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    );
BOOL
FileTimeToSystemTime(
    const FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    );
LONG
CompareFileTime(
    const FILETIME *lpFileTime1,
    const FILETIME *lpFileTime2
    );
BOOL
FileTimeToDosDateTime(
    const FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    );
BOOL
DosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    );
DWORD
GetTickCount(
    void
    );
ULONGLONG
GetTickCount64(
    void
    );
BOOL
SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL bTimeAdjustmentDisabled
    );
BOOL
GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL lpTimeAdjustmentDisabled
    );
DWORD
FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
DWORD
FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );
static const int FormatMessage = FormatMessageA;
# 5745 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
static const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;
static const int FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
static const int FORMAT_MESSAGE_FROM_STRING = 0x00000400;
static const int FORMAT_MESSAGE_FROM_HMODULE = 0x00000800;
static const int FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000;
static const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000;
static const int FORMAT_MESSAGE_MAX_WIDTH_MASK = 0x000000FF;
BOOL
CreatePipe(
    PHANDLE hReadPipe,
    PHANDLE hWritePipe,
    LPSECURITY_ATTRIBUTES lpPipeAttributes,
    DWORD nSize
    );
BOOL
ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    );
BOOL
DisconnectNamedPipe(
    HANDLE hNamedPipe
    );
BOOL
SetNamedPipeHandleState(
    HANDLE hNamedPipe,
    LPDWORD lpMode,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout
    );
BOOL
GetNamedPipeInfo(
    HANDLE hNamedPipe,
    LPDWORD lpFlags,
    LPDWORD lpOutBufferSize,
    LPDWORD lpInBufferSize,
    LPDWORD lpMaxInstances
    );
BOOL
PeekNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpBuffer,
    DWORD nBufferSize,
    LPDWORD lpBytesRead,
    LPDWORD lpTotalBytesAvail,
    LPDWORD lpBytesLeftThisMessage
    );
BOOL
TransactNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    LPOVERLAPPED lpOverlapped
    );
HANDLE
CreateMailslotA(
    LPCSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
HANDLE
CreateMailslotW(
    LPCWSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
static const int CreateMailslot = CreateMailslotA;
BOOL
GetMailslotInfo(
    HANDLE hMailslot,
    LPDWORD lpMaxMessageSize,
    LPDWORD lpNextSize,
    LPDWORD lpMessageCount,
    LPDWORD lpReadTimeout
    );
BOOL
SetMailslotInfo(
    HANDLE hMailslot,
    DWORD lReadTimeout
    );
LPVOID
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap
    );
BOOL
FlushViewOfFile(
    LPCVOID lpBaseAddress,
    SIZE_T dwNumberOfBytesToFlush
    );
BOOL
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );
//
// File Encryption API
//
BOOL
EncryptFileA(
    LPCSTR lpFileName
    );
BOOL
EncryptFileW(
    LPCWSTR lpFileName
    );
static const int EncryptFile = EncryptFileA;
BOOL
DecryptFileA(
    LPCSTR lpFileName,
    DWORD dwReserved
    );
BOOL
DecryptFileW(
    LPCWSTR lpFileName,
    DWORD dwReserved
    );
static const int DecryptFile = DecryptFileA;
//
//  Encryption Status Value
//
static const int FILE_ENCRYPTABLE = 0;
static const int FILE_IS_ENCRYPTED = 1;
static const int FILE_SYSTEM_ATTR = 2;
static const int FILE_ROOT_DIR = 3;
static const int FILE_SYSTEM_DIR = 4;
static const int FILE_UNKNOWN = 5;
static const int FILE_SYSTEM_NOT_SUPPORT = 6;
static const int FILE_USER_DISALLOWED = 7;
static const int FILE_READ_ONLY = 8;
static const int FILE_DIR_DISALLOWED = 9;
BOOL
FileEncryptionStatusA(
    LPCSTR lpFileName,
    LPDWORD lpStatus
    );
BOOL
FileEncryptionStatusW(
    LPCWSTR lpFileName,
    LPDWORD lpStatus
    );
static const int FileEncryptionStatus = FileEncryptionStatusA;
//
// Currently defined recovery flags
//
static const int EFS_USE_RECOVERY_KEYS = (0x1);
typedef
DWORD
( *PFE_EXPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    ULONG ulLength
    );
typedef
DWORD
( *PFE_IMPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    PULONG ulLength
    );
//
//  OpenRaw flag values
//
static const int CREATE_FOR_IMPORT = (1);
static const int CREATE_FOR_DIR = (2);
static const int OVERWRITE_HIDDEN = (4);
static const int EFSRPC_SECURE_ONLY = (8);
DWORD
OpenEncryptedFileRawA(
    LPCSTR lpFileName,
    ULONG ulFlags,
    PVOID *pvContext
    );
DWORD
OpenEncryptedFileRawW(
    LPCWSTR lpFileName,
    ULONG ulFlags,
    PVOID *pvContext
    );
static const int OpenEncryptedFileRaw = OpenEncryptedFileRawA;
DWORD
ReadEncryptedFileRaw(
    PFE_EXPORT_FUNC pfExportCallback,
    PVOID pvCallbackContext,
    PVOID pvContext
    );
DWORD
WriteEncryptedFileRaw(
    PFE_IMPORT_FUNC pfImportCallback,
    PVOID pvCallbackContext,
    PVOID pvContext
    );
void
CloseEncryptedFileRaw(
    PVOID pvContext
    );
//
// _l Compat Functions
//
int
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );
int
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
static const int lstrcmp = lstrcmpA;
int
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );
int
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
static const int lstrcmpi = lstrcmpiA;
LPSTR
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    );
LPWSTR
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );
static const int lstrcpyn = lstrcpynA;
LPSTR
lstrcpyA(
    LPSTR lpString1, // deprecated: annotation is as good as it gets
    LPCSTR lpString2
    );
LPWSTR
lstrcpyW(
    LPWSTR lpString1, // deprecated: annotation is as good as it gets
    LPCWSTR lpString2
    );
static const int lstrcpy = lstrcpyA;
LPSTR
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    );
LPWSTR
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
static const int lstrcat = lstrcatA;
int
lstrlenA(
    LPCSTR lpString
    );
int
lstrlenW(
    LPCWSTR lpString
    );
static const int lstrlen = lstrlenA;
HFILE
OpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    );
HFILE
_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    );
HFILE
_lcreat(
    LPCSTR lpPathName,
    int iAttribute
    );
UINT
_lread(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT uBytes
    );
UINT
_lwrite(
    HFILE hFile,
    LPCCH lpBuffer,
    UINT uBytes
    );
long
_hread(
    HFILE hFile,
    LPVOID lpBuffer,
    long lBytes
    );
long
_hwrite(
    HFILE hFile,
    LPCCH lpBuffer,
    long lBytes
    );
HFILE
_lclose(
    HFILE hFile
    );
LONG
_llseek(
    HFILE hFile,
    LONG lOffset,
    int iOrigin
    );
BOOL
IsTextUnicode(
    const void* lpv,
    int iSize,
    LPINT lpiResult
    );
static const int FLS_OUT_OF_INDEXES = ((DWORD)0xFFFFFFFF);
DWORD
FlsAlloc(
    PFLS_CALLBACK_FUNCTION lpCallback
    );
PVOID
FlsGetValue(
    DWORD dwFlsIndex
    );
BOOL
FlsSetValue(
    DWORD dwFlsIndex,
    PVOID lpFlsData
    );
BOOL
FlsFree(
    DWORD dwFlsIndex
    );
static const int TLS_OUT_OF_INDEXES = ((DWORD)0xFFFFFFFF);
DWORD
TlsAlloc(
    void
    );
LPVOID
TlsGetValue(
    DWORD dwTlsIndex
    );
BOOL
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    );
BOOL
TlsFree(
    DWORD dwTlsIndex
    );
typedef
void
( *LPOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );
DWORD
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    );
DWORD
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );
DWORD
WaitForMultipleObjectsEx(
    DWORD nCount,
    const HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );
DWORD
SignalObjectAndWait(
    HANDLE hObjectToSignal,
    HANDLE hObjectToWaitOn,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );
BOOL
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
BOOL
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
BOOL
BackupRead(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );
BOOL
BackupSeek(
    HANDLE hFile,
    DWORD dwLowBytesToSeek,
    DWORD dwHighBytesToSeek,
    LPDWORD lpdwLowByteSeeked,
    LPDWORD lpdwHighByteSeeked,
    LPVOID *lpContext
    );
BOOL
BackupWrite(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );
//
//  Stream id structure
//
typedef struct _WIN32_STREAM_ID {
        DWORD dwStreamId ;
        DWORD dwStreamAttributes ;
        LARGE_INTEGER Size ;
        DWORD dwStreamNameSize ;
        WCHAR cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;
//
//  Stream Ids
//
static const int BACKUP_INVALID = 0x00000000;
static const int BACKUP_DATA = 0x00000001;
static const int BACKUP_EA_DATA = 0x00000002;
static const int BACKUP_SECURITY_DATA = 0x00000003;
static const int BACKUP_ALTERNATE_DATA = 0x00000004;
static const int BACKUP_LINK = 0x00000005;
static const int BACKUP_PROPERTY_DATA = 0x00000006;
static const int BACKUP_OBJECT_ID = 0x00000007;
static const int BACKUP_REPARSE_DATA = 0x00000008;
static const int BACKUP_SPARSE_BLOCK = 0x00000009;
static const int BACKUP_TXFS_DATA = 0x0000000a;
//
//  Stream Attributes
//
static const int STREAM_NORMAL_ATTRIBUTE = 0x00000000;
static const int STREAM_MODIFIED_WHEN_READ = 0x00000001;
static const int STREAM_CONTAINS_SECURITY = 0x00000002;
static const int STREAM_CONTAINS_PROPERTIES = 0x00000004;
static const int STREAM_SPARSE_ATTRIBUTE = 0x00000008;
BOOL
ReadFileScatter(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray[],
    DWORD nNumberOfBytesToRead,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    );
BOOL
WriteFileGather(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray[],
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    );
//
// Dual Mode API below this line. Dual Mode Structures also included.
//
static const int STARTF_USESHOWWINDOW = 0x00000001;
static const int STARTF_USESIZE = 0x00000002;
static const int STARTF_USEPOSITION = 0x00000004;
static const int STARTF_USECOUNTCHARS = 0x00000008;
static const int STARTF_USEFILLATTRIBUTE = 0x00000010;
static const int STARTF_RUNFULLSCREEN = 0x00000020;
static const int STARTF_FORCEONFEEDBACK = 0x00000040;
static const int STARTF_FORCEOFFFEEDBACK = 0x00000080;
static const int STARTF_USESTDHANDLES = 0x00000100;
static const int STARTF_USEHOTKEY = 0x00000200;
static const int STARTF_TITLEISLINKNAME = 0x00000800;
static const int STARTF_TITLEISAPPID = 0x00001000;
static const int STARTF_PREVENTPINNING = 0x00002000;
typedef struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;
typedef STARTUPINFOEXA STARTUPINFOEX;
typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;
static const int SHUTDOWN_NORETRY = 0x00000001;
typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR cFileName[ 260 ];
    CHAR cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR cFileName[ 260 ];
    WCHAR cAlternateFileName[ 14 ];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;
//
// Synchronization APIs
//
HANDLE
CreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    );
HANDLE
CreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );
static const int CreateMutex = CreateMutexA;
HANDLE
OpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
HANDLE
OpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
static const int OpenMutex = OpenMutexA;
HANDLE
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );
HANDLE
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );
static const int CreateEvent = CreateEventA;
HANDLE
OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
HANDLE
OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
static const int OpenEvent = OpenEventA;
HANDLE
CreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    );
HANDLE
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );
static const int CreateSemaphore = CreateSemaphoreA;
HANDLE
OpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
HANDLE
OpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
static const int OpenSemaphore = OpenSemaphoreA;
typedef
void
( *PTIMERAPCROUTINE)(
    LPVOID lpArgToCompletionRoutine,
    DWORD dwTimerLowValue,
    DWORD dwTimerHighValue
    );
HANDLE
CreateWaitableTimerA(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    );
HANDLE
CreateWaitableTimerW(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCWSTR lpTimerName
    );
static const int CreateWaitableTimer = CreateWaitableTimerA;
HANDLE
OpenWaitableTimerA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpTimerName
    );
HANDLE
OpenWaitableTimerW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpTimerName
    );
static const int OpenWaitableTimer = OpenWaitableTimerA;
BOOL
SetWaitableTimerEx(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    PREASON_CONTEXT WakeContext,
    ULONG TolerableDelay
    );
BOOL
SetWaitableTimer(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );
BOOL
CancelWaitableTimer(
    HANDLE hTimer
    );
static const int CREATE_MUTEX_INITIAL_OWNER = 0x00000001;
HANDLE
CreateMutexExA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    LPCSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
HANDLE
CreateMutexExW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    LPCWSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
static const int CreateMutexEx = CreateMutexExA;
static const int CREATE_EVENT_MANUAL_RESET = 0x00000001;
static const int CREATE_EVENT_INITIAL_SET = 0x00000002;
HANDLE
CreateEventExA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    LPCSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
HANDLE
CreateEventExW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    LPCWSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
static const int CreateEventEx = CreateEventExA;
HANDLE
CreateSemaphoreExA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
HANDLE
CreateSemaphoreExW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
static const int CreateSemaphoreEx = CreateSemaphoreExA;
static const int CREATE_WAITABLE_TIMER_MANUAL_RESET = 0x00000001;
HANDLE
CreateWaitableTimerExA(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    LPCSTR lpTimerName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
HANDLE
CreateWaitableTimerExW(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    LPCWSTR lpTimerName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );
static const int CreateWaitableTimerEx = CreateWaitableTimerExA;
HANDLE
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );
HANDLE
CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );
static const int CreateFileMapping = CreateFileMappingA;
HANDLE
CreateFileMappingNumaA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName,
    DWORD nndPreferred
    );
HANDLE
CreateFileMappingNumaW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName,
    DWORD nndPreferred
    );
static const int CreateFileMappingNuma = CreateFileMappingNumaA;
HANDLE
OpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
HANDLE
OpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
static const int OpenFileMapping = OpenFileMappingA;
DWORD
GetLogicalDriveStringsA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
DWORD
GetLogicalDriveStringsW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
static const int GetLogicalDriveStrings = GetLogicalDriveStringsA;
typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;
HANDLE
CreateMemoryResourceNotification(
    MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );
BOOL
QueryMemoryResourceNotification(
    HANDLE ResourceNotificationHandle,
    PBOOL ResourceState
    );
HMODULE
LoadLibraryA(
    LPCSTR lpLibFileName
    );
HMODULE
LoadLibraryW(
    LPCWSTR lpLibFileName
    );
static const int LoadLibrary = LoadLibraryA;
HMODULE
LoadLibraryExA(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );
HMODULE
LoadLibraryExW(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );
static const int LoadLibraryEx = LoadLibraryExA;
static const int DONT_RESOLVE_DLL_REFERENCES = 0x00000001;
static const int LOAD_LIBRARY_AS_DATAFILE = 0x00000002;
static const int LOAD_WITH_ALTERED_SEARCH_PATH = 0x00000008;
static const int LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010;
static const int LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020;
static const int LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040;
static const int LOAD_LIBRARY_REQUIRE_SIGNED_TARGET = 0x00000080;
DWORD
GetModuleFileNameA(
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );
DWORD
GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );
static const int GetModuleFileName = GetModuleFileNameA;
HMODULE
GetModuleHandleA(
    LPCSTR lpModuleName
    );
HMODULE
GetModuleHandleW(
    LPCWSTR lpModuleName
    );
static const int GetModuleHandle = GetModuleHandleA;
static const int GET_MODULE_HANDLE_EX_FLAG_PIN = (0x00000001);
static const int GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = (0x00000002);
static const int GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = (0x00000004);
typedef
BOOL
(*
PGET_MODULE_HANDLE_EXA)(
    DWORD dwFlags,
    LPCSTR lpModuleName,
    HMODULE* phModule
    );
typedef
BOOL
(*
PGET_MODULE_HANDLE_EXW)(
    DWORD dwFlags,
    LPCWSTR lpModuleName,
    HMODULE* phModule
    );
static const int PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXA;
BOOL
GetModuleHandleExA(
    DWORD dwFlags,
    LPCSTR lpModuleName,
    HMODULE* phModule
    );
BOOL
GetModuleHandleExW(
    DWORD dwFlags,
    LPCWSTR lpModuleName,
    HMODULE* phModule
    );
static const int GetModuleHandleEx = GetModuleHandleExA;
BOOL
NeedCurrentDirectoryForExePathA(
    LPCSTR ExeName
    );
BOOL
NeedCurrentDirectoryForExePathW(
    LPCWSTR ExeName
    );
static const int NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathA;
static const int PROCESS_NAME_NATIVE = 0x00000001;
BOOL
QueryFullProcessImageNameA(
    HANDLE hProcess,
    DWORD dwFlags,
    LPSTR lpExeName,
    PDWORD lpdwSize
    );
BOOL
QueryFullProcessImageNameW(
    HANDLE hProcess,
    DWORD dwFlags,
    LPWSTR lpExeName,
    PDWORD lpdwSize
    );
static const int QueryFullProcessImageName = QueryFullProcessImageNameA;
//
// Extended process and thread attribute support
//
static const int PROC_THREAD_ATTRIBUTE_NUMBER = 0x0000FFFF;
static const int PROC_THREAD_ATTRIBUTE_THREAD = 0x00010000;
static const int PROC_THREAD_ATTRIBUTE_INPUT = 0x00020000;
static const int PROC_THREAD_ATTRIBUTE_ADDITIVE = 0x00040000;
typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeExtendedFlags,
    ProcThreadAttributeHandleList,
    ProcThreadAttributeGroupAffinity,
    ProcThreadAttributePreferredNode,
    ProcThreadAttributeIdealProcessor,
    ProcThreadAttributeUmsThread,
    ProcThreadAttributeMitigationPolicy,
    ProcThreadAttributeMax
} PROC_THREAD_ATTRIBUTE_NUM;
static const int ProcThreadAttributeValue(Number,Thread,Input,Additive) = (((Number) & PROC_THREAD_ATTRIBUTE_NUMBER) | ((Thread != FALSE) ? PROC_THREAD_ATTRIBUTE_THREAD : 0) | ((Input != FALSE) ? PROC_THREAD_ATTRIBUTE_INPUT : 0) | ((Additive != FALSE) ? PROC_THREAD_ATTRIBUTE_ADDITIVE : 0));
static const int PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = ProcThreadAttributeValue (ProcThreadAttributeParentProcess, FALSE, TRUE, FALSE);
static const int PROC_THREAD_ATTRIBUTE_EXTENDED_FLAGS = ProcThreadAttributeValue (ProcThreadAttributeExtendedFlags, FALSE, TRUE, TRUE);
static const int PROC_THREAD_ATTRIBUTE_HANDLE_LIST = ProcThreadAttributeValue (ProcThreadAttributeHandleList, FALSE, TRUE, FALSE);
static const int PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY = ProcThreadAttributeValue (ProcThreadAttributeGroupAffinity, TRUE, TRUE, FALSE);
static const int PROC_THREAD_ATTRIBUTE_PREFERRED_NODE = ProcThreadAttributeValue (ProcThreadAttributePreferredNode, FALSE, TRUE, FALSE);
static const int PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR = ProcThreadAttributeValue (ProcThreadAttributeIdealProcessor, TRUE, TRUE, FALSE);
static const int PROC_THREAD_ATTRIBUTE_UMS_THREAD = ProcThreadAttributeValue (ProcThreadAttributeUmsThread, TRUE, TRUE, FALSE);
static const int PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = ProcThreadAttributeValue (ProcThreadAttributeMitigationPolicy, FALSE, TRUE, FALSE);
static const int PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE = 0x01;
static const int PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE = 0x02;
static const int PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE = 0x04;
BOOL
InitializeProcThreadAttributeList(
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    DWORD dwAttributeCount,
    DWORD dwFlags,
    PSIZE_T lpSize
    );
void
DeleteProcThreadAttributeList(
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );
static const int PROC_THREAD_ATTRIBUTE_REPLACE_VALUE = 0x00000001;
BOOL
UpdateProcThreadAttribute(
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    DWORD dwFlags,
    DWORD_PTR Attribute,
    PVOID lpValue,
    SIZE_T cbSize,
    PVOID lpPreviousValue,
    PSIZE_T lpReturnSize
    );
BOOL
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
BOOL
CreateProcessW(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
static const int CreateProcess = CreateProcessA;
BOOL
SetProcessShutdownParameters(
    DWORD dwLevel,
    DWORD dwFlags
    );
BOOL
GetProcessShutdownParameters(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    );
DWORD
GetProcessVersion(
    DWORD ProcessId
    );
void
FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText
    );
void
FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText
    );
static const int FatalAppExit = FatalAppExitA;
void
GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo
    );
void
GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo
    );
static const int GetStartupInfo = GetStartupInfoA;
LPSTR
GetCommandLineA(
    void
    );
LPWSTR
GetCommandLineW(
    void
    );
static const int GetCommandLine = GetCommandLineA;
DWORD
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );
DWORD
GetEnvironmentVariableW(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    );
static const int GetEnvironmentVariable = GetEnvironmentVariableA;
# 7609 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    );
BOOL
SetEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpValue
    );
static const int SetEnvironmentVariable = SetEnvironmentVariableA;
# 7649 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
DWORD
ExpandEnvironmentStringsA(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    );
DWORD
ExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );
static const int ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
DWORD
GetFirmwareEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpGuid,
    PVOID pBuffer,
    DWORD nSize
    );
DWORD
GetFirmwareEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpGuid,
    PVOID pBuffer,
    DWORD nSize
    );
static const int GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableA;
BOOL
SetFirmwareEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpGuid,
    PVOID pValue,
    DWORD nSize
    );
BOOL
SetFirmwareEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpGuid,
    PVOID pValue,
    DWORD nSize
    );
static const int SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableA;
void
OutputDebugStringA(
    LPCSTR lpOutputString
    );
void
OutputDebugStringW(
    LPCWSTR lpOutputString
    );
static const int OutputDebugString = OutputDebugStringA;
HRSRC
FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    );
HRSRC
FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    );
static const int FindResource = FindResourceA;
HRSRC
FindResourceExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD wLanguage
    );
HRSRC
FindResourceExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD wLanguage
    );
static const int FindResourceEx = FindResourceExA;
typedef BOOL (* ENUMRESTYPEPROCA)( HMODULE hModule, LPSTR lpType,
 LONG_PTR lParam);
typedef BOOL (* ENUMRESTYPEPROCW)( HMODULE hModule, LPWSTR lpType,
 LONG_PTR lParam);
static const int ENUMRESTYPEPROC = ENUMRESTYPEPROCA;
typedef BOOL (* ENUMRESNAMEPROCA)( HMODULE hModule, LPCSTR lpType,
 LPSTR lpName, LONG_PTR lParam);
typedef BOOL (* ENUMRESNAMEPROCW)( HMODULE hModule, LPCWSTR lpType,
 LPWSTR lpName, LONG_PTR lParam);
static const int ENUMRESNAMEPROC = ENUMRESNAMEPROCA;
typedef BOOL (* ENUMRESLANGPROCA)( HMODULE hModule, LPCSTR lpType,
 LPCSTR lpName, WORD wLanguage, LONG_PTR lParam);
typedef BOOL (* ENUMRESLANGPROCW)( HMODULE hModule, LPCWSTR lpType,
 LPCWSTR lpName, WORD wLanguage, LONG_PTR lParam);
static const int ENUMRESLANGPROC = ENUMRESLANGPROCA;
# 7844 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
EnumResourceTypesA(
    HMODULE hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    LONG_PTR lParam
    );
BOOL
EnumResourceTypesW(
    HMODULE hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    LONG_PTR lParam
    );
static const int EnumResourceTypes = EnumResourceTypesA;
BOOL
EnumResourceNamesA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    LONG_PTR lParam
    );
BOOL
EnumResourceNamesW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    LONG_PTR lParam
    );
static const int EnumResourceNames = EnumResourceNamesA;
BOOL
EnumResourceLanguagesA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    LONG_PTR lParam
    );
BOOL
EnumResourceLanguagesW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    LONG_PTR lParam
    );
static const int EnumResourceLanguages = EnumResourceLanguagesA;
static const int RESOURCE_ENUM_LN = (0x0001);
static const int RESOURCE_ENUM_MUI = (0x0002);
static const int RESOURCE_ENUM_MUI_SYSTEM = (0x0004);
static const int RESOURCE_ENUM_VALIDATE = (0x0008);
static const int RESOURCE_ENUM_MODULE_EXACT = (0x0010);
BOOL
EnumResourceTypesExA(
    HMODULE hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
BOOL
EnumResourceTypesExW(
    HMODULE hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
static const int EnumResourceTypesEx = EnumResourceTypesExA;
BOOL
EnumResourceNamesExA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
BOOL
EnumResourceNamesExW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
static const int EnumResourceNamesEx = EnumResourceNamesExA;
BOOL
EnumResourceLanguagesExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
BOOL
EnumResourceLanguagesExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
static const int EnumResourceLanguagesEx = EnumResourceLanguagesExA;
HANDLE
BeginUpdateResourceA(
    LPCSTR pFileName,
    BOOL bDeleteExistingResources
    );
HANDLE
BeginUpdateResourceW(
    LPCWSTR pFileName,
    BOOL bDeleteExistingResources
    );
static const int BeginUpdateResource = BeginUpdateResourceA;
BOOL
UpdateResourceA(
    HANDLE hUpdate,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD wLanguage,
    LPVOID lpData,
    DWORD cb
    );
BOOL
UpdateResourceW(
    HANDLE hUpdate,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD wLanguage,
    LPVOID lpData,
    DWORD cb
    );
static const int UpdateResource = UpdateResourceA;
BOOL
EndUpdateResourceA(
    HANDLE hUpdate,
    BOOL fDiscard
    );
BOOL
EndUpdateResourceW(
    HANDLE hUpdate,
    BOOL fDiscard
    );
static const int EndUpdateResource = EndUpdateResourceA;
ATOM
GlobalAddAtomA(
    LPCSTR lpString
    );
ATOM
GlobalAddAtomW(
    LPCWSTR lpString
    );
static const int GlobalAddAtom = GlobalAddAtomA;
ATOM
GlobalFindAtomA(
    LPCSTR lpString
    );
ATOM
GlobalFindAtomW(
    LPCWSTR lpString
    );
static const int GlobalFindAtom = GlobalFindAtomA;
UINT
GlobalGetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );
UINT
GlobalGetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );
static const int GlobalGetAtomName = GlobalGetAtomNameA;
ATOM
AddAtomA(
    LPCSTR lpString
    );
ATOM
AddAtomW(
    LPCWSTR lpString
    );
static const int AddAtom = AddAtomA;
ATOM
FindAtomA(
    LPCSTR lpString
    );
ATOM
FindAtomW(
    LPCWSTR lpString
    );
static const int FindAtom = FindAtomA;
UINT
GetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );
UINT
GetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );
static const int GetAtomName = GetAtomNameA;
UINT
GetProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault
    );
UINT
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );
static const int GetProfileInt = GetProfileIntA;
DWORD
GetProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize
    );
DWORD
GetProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
    );
static const int GetProfileString = GetProfileStringA;
BOOL
WriteProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString
    );
BOOL
WriteProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    );
static const int WriteProfileString = WriteProfileStringA;
DWORD
GetProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize
    );
DWORD
GetProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize
    );
static const int GetProfileSection = GetProfileSectionA;
BOOL
WriteProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString
    );
BOOL
WriteProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString
    );
static const int WriteProfileSection = WriteProfileSectionA;
UINT
GetPrivateProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    );
UINT
GetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    );
static const int GetPrivateProfileInt = GetPrivateProfileIntA;
# 8352 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
DWORD
GetPrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );
DWORD
GetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
static const int GetPrivateProfileString = GetPrivateProfileStringA;
# 8408 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
WritePrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );
BOOL
WritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );
static const int WritePrivateProfileString = WritePrivateProfileStringA;
DWORD
GetPrivateProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );
DWORD
GetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );
static const int GetPrivateProfileSection = GetPrivateProfileSectionA;
# 8480 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
WritePrivateProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );
BOOL
WritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );
static const int WritePrivateProfileSection = WritePrivateProfileSectionA;
DWORD
GetPrivateProfileSectionNamesA(
    LPSTR lpszReturnBuffer,
    DWORD nSize,
    LPCSTR lpFileName
    );
DWORD
GetPrivateProfileSectionNamesW(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    );
static const int GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
# 8547 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
GetPrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    );
BOOL
GetPrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    );
static const int GetPrivateProfileStruct = GetPrivateProfileStructA;
# 8599 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
WritePrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    );
BOOL
WritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    );
static const int WritePrivateProfileStruct = WritePrivateProfileStructA;
UINT
GetDriveTypeA(
    LPCSTR lpRootPathName
    );
UINT
GetDriveTypeW(
    LPCWSTR lpRootPathName
    );
static const int GetDriveType = GetDriveTypeA;
UINT
GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
UINT
GetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
static const int GetSystemDirectory = GetSystemDirectoryA;
DWORD
GetTempPathA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
DWORD
GetTempPathW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
static const int GetTempPath = GetTempPathA;
UINT
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );
UINT
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );
static const int GetTempFileName = GetTempFileNameA;
# 8732 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
UINT
GetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
UINT
GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
static const int GetWindowsDirectory = GetWindowsDirectoryA;
UINT
GetSystemWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
UINT
GetSystemWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
static const int GetSystemWindowsDirectory = GetSystemWindowsDirectoryA;
UINT
GetSystemWow64DirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );
UINT
GetSystemWow64DirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );
static const int GetSystemWow64Directory = GetSystemWow64DirectoryA;
BOOLEAN
Wow64EnableWow64FsRedirection (
    BOOLEAN Wow64FsEnableRedirection
    );
BOOL
Wow64DisableWow64FsRedirection (
    PVOID *OldValue
    );
BOOL
Wow64RevertWow64FsRedirection (
    PVOID OlValue
    );
//
// for GetProcAddress
//
typedef UINT (* PGET_SYSTEM_WOW64_DIRECTORY_A)( LPSTR lpBuffer, UINT uSize);
typedef UINT (* PGET_SYSTEM_WOW64_DIRECTORY_W)( LPWSTR lpBuffer, UINT uSize);
//
// GetProcAddress only accepts GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A,
// GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A.
// The others are if you want to use the strings in some other way.
//
static const char GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A = "GetSystemWow64DirectoryA";
static const char GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W = L"GetSystemWow64DirectoryA";
static const int GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T = TEXT("GetSystemWow64DirectoryA");
static const char GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A = "GetSystemWow64DirectoryW";
static const char GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W = L"GetSystemWow64DirectoryW";
static const int GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T = TEXT("GetSystemWow64DirectoryW");
static const int GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A;
static const int GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W;
static const int GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T;
BOOL
SetCurrentDirectoryA(
    LPCSTR lpPathName
    );
BOOL
SetCurrentDirectoryW(
    LPCWSTR lpPathName
    );
static const int SetCurrentDirectory = SetCurrentDirectoryA;
# 8884 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
DWORD
GetCurrentDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
DWORD
GetCurrentDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
static const int GetCurrentDirectory = GetCurrentDirectoryA;
# 8926 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
SetDllDirectoryA(
    LPCSTR lpPathName
    );
BOOL
SetDllDirectoryW(
    LPCWSTR lpPathName
    );
static const int SetDllDirectory = SetDllDirectoryA;
DWORD
GetDllDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );
DWORD
GetDllDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );
static const int GetDllDirectory = GetDllDirectoryA;
static const int BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 0x1;
static const int BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 0x10000;
static const int BASE_SEARCH_PATH_PERMANENT = 0x8000;
static const int BASE_SEARCH_PATH_INVALID_FLAGS = ~0x18001;
BOOL
SetSearchPathMode (
    DWORD Flags
    );
BOOL
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
BOOL
GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
static const int GetDiskFreeSpace = GetDiskFreeSpaceA;
BOOL
GetDiskFreeSpaceExA(
    LPCSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
BOOL
GetDiskFreeSpaceExW(
    LPCWSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
static const int GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
BOOL
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
BOOL
CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
static const int CreateDirectory = CreateDirectoryA;
# 9068 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
CreateDirectoryExA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
BOOL
CreateDirectoryExW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
static const int CreateDirectoryEx = CreateDirectoryExA;
BOOL
CreateDirectoryTransactedA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );
BOOL
CreateDirectoryTransactedW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );
static const int CreateDirectoryTransacted = CreateDirectoryTransactedA;
BOOL
RemoveDirectoryA(
    LPCSTR lpPathName
    );
BOOL
RemoveDirectoryW(
    LPCWSTR lpPathName
    );
static const int RemoveDirectory = RemoveDirectoryA;
BOOL
RemoveDirectoryTransactedA(
    LPCSTR lpPathName,
    HANDLE hTransaction
    );
BOOL
RemoveDirectoryTransactedW(
    LPCWSTR lpPathName,
    HANDLE hTransaction
    );
static const int RemoveDirectoryTransacted = RemoveDirectoryTransactedA;
DWORD
GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );
DWORD
GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );
static const int GetFullPathName = GetFullPathNameA;
DWORD
GetFullPathNameTransactedA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart,
    HANDLE hTransaction
    );
DWORD
GetFullPathNameTransactedW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart,
    HANDLE hTransaction
    );
static const int GetFullPathNameTransacted = GetFullPathNameTransactedA;
static const int DDD_RAW_TARGET_PATH = 0x00000001;
static const int DDD_REMOVE_DEFINITION = 0x00000002;
static const int DDD_EXACT_MATCH_ON_REMOVE = 0x00000004;
static const int DDD_NO_BROADCAST_SYSTEM = 0x00000008;
static const int DDD_LUID_BROADCAST_DRIVE = 0x00000010;
BOOL
DefineDosDeviceA(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPCSTR lpTargetPath
    );
BOOL
DefineDosDeviceW(
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPCWSTR lpTargetPath
    );
static const int DefineDosDevice = DefineDosDeviceA;
DWORD
QueryDosDeviceA(
    LPCSTR lpDeviceName,
    LPSTR lpTargetPath,
    DWORD ucchMax
    );
DWORD
QueryDosDeviceW(
    LPCWSTR lpDeviceName,
    LPWSTR lpTargetPath,
    DWORD ucchMax
    );
static const int QueryDosDevice = QueryDosDeviceA;
HANDLE
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
HANDLE
CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
static const int CreateFile = CreateFileA;
HANDLE
CreateFileTransactedA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    HANDLE hTransaction,
    PUSHORT pusMiniVersion,
    PVOID lpExtendedParameter
    );
HANDLE
CreateFileTransactedW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    HANDLE hTransaction,
    PUSHORT pusMiniVersion,
    PVOID lpExtendedParameter
    );
static const int CreateFileTransacted = CreateFileTransactedA;
HANDLE
ReOpenFile(
    HANDLE hOriginalFile,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    DWORD dwFlagsAndAttributes
    );
BOOL
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );
BOOL
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );
static const int SetFileAttributes = SetFileAttributesA;
DWORD
GetFileAttributesA(
    LPCSTR lpFileName
    );
DWORD
GetFileAttributesW(
    LPCWSTR lpFileName
    );
static const int GetFileAttributes = GetFileAttributesA;
BOOL
SetFileAttributesTransactedA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes,
    HANDLE hTransaction
    );
BOOL
SetFileAttributesTransactedW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes,
    HANDLE hTransaction
    );
static const int SetFileAttributesTransacted = SetFileAttributesTransactedA;
typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;
BOOL
GetFileAttributesTransactedA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation,
    HANDLE hTransaction
    );
BOOL
GetFileAttributesTransactedW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation,
    HANDLE hTransaction
    );
static const int GetFileAttributesTransacted = GetFileAttributesTransactedA;
BOOL
GetFileAttributesExA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );
BOOL
GetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );
static const int GetFileAttributesEx = GetFileAttributesExA;
DWORD
GetCompressedFileSizeA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );
DWORD
GetCompressedFileSizeW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );
static const int GetCompressedFileSize = GetCompressedFileSizeA;
DWORD
GetCompressedFileSizeTransactedA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh,
    HANDLE hTransaction
    );
DWORD
GetCompressedFileSizeTransactedW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh,
    HANDLE hTransaction
    );
static const int GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedA;
BOOL
DeleteFileA(
    LPCSTR lpFileName
    );
BOOL
DeleteFileW(
    LPCWSTR lpFileName
    );
static const int DeleteFile = DeleteFileA;
BOOL
DeleteFileTransactedA(
    LPCSTR lpFileName,
    HANDLE hTransaction
    );
BOOL
DeleteFileTransactedW(
    LPCWSTR lpFileName,
    HANDLE hTransaction
    );
static const int DeleteFileTransacted = DeleteFileTransactedA;
# 9583 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
CheckNameLegalDOS8Dot3A(
    LPCSTR lpName,
    LPSTR lpOemName,
    DWORD OemNameSize,
    PBOOL pbNameContainsSpaces ,
    PBOOL pbNameLegal
    );
BOOL
CheckNameLegalDOS8Dot3W(
    LPCWSTR lpName,
    LPSTR lpOemName,
    DWORD OemNameSize,
    PBOOL pbNameContainsSpaces ,
    PBOOL pbNameLegal
    );
static const int CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3A;
typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;
typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
static const int FIND_FIRST_EX_CASE_SENSITIVE = 0x00000001;
static const int FIND_FIRST_EX_LARGE_FETCH = 0x00000002;
HANDLE
FindFirstFileExA(
    LPCSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    );
HANDLE
FindFirstFileExW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    );
static const int FindFirstFileEx = FindFirstFileExA;
HANDLE
FindFirstFileTransactedA(
    LPCSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags,
    HANDLE hTransaction
    );
HANDLE
FindFirstFileTransactedW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags,
    HANDLE hTransaction
    );
static const int FindFirstFileTransacted = FindFirstFileTransactedA;
HANDLE
FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    );
HANDLE
FindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );
static const int FindFirstFile = FindFirstFileA;
BOOL
FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    );
BOOL
FindNextFileW(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    );
static const int FindNextFile = FindNextFileA;
DWORD
SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );
DWORD
SearchPathW(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );
static const int SearchPath = SearchPathA;
BOOL
CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    );
BOOL
CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    );
static const int CopyFile = CopyFileA;
# 9812 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
typedef
DWORD
( *LPPROGRESS_ROUTINE)(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData
    );
BOOL
CopyFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags
    );
BOOL
CopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags
    );
static const int CopyFileEx = CopyFileExA;
BOOL
CopyFileTransactedA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags,
    HANDLE hTransaction
    );
BOOL
CopyFileTransactedW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags,
    HANDLE hTransaction
    );
static const int CopyFileTransacted = CopyFileTransactedA;
BOOL
MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
BOOL
MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    );
static const int MoveFile = MoveFileA;
# 9929 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    );
BOOL
MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );
static const int MoveFileEx = MoveFileExA;
BOOL
MoveFileWithProgressA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags
    );
BOOL
MoveFileWithProgressW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags
    );
static const int MoveFileWithProgress = MoveFileWithProgressA;
BOOL
MoveFileTransactedA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags,
    HANDLE hTransaction
    );
BOOL
MoveFileTransactedW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags,
    HANDLE hTransaction
    );
static const int MoveFileTransacted = MoveFileTransactedA;
static const int MOVEFILE_REPLACE_EXISTING = 0x00000001;
static const int MOVEFILE_COPY_ALLOWED = 0x00000002;
static const int MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004;
static const int MOVEFILE_WRITE_THROUGH = 0x00000008;
static const int MOVEFILE_CREATE_HARDLINK = 0x00000010;
static const int MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x00000020;
BOOL
ReplaceFileA(
    LPCSTR lpReplacedFileName,
    LPCSTR lpReplacementFileName,
    LPCSTR lpBackupFileName,
    DWORD dwReplaceFlags,
    LPVOID lpExclude,
    LPVOID lpReserved
    );
BOOL
ReplaceFileW(
    LPCWSTR lpReplacedFileName,
    LPCWSTR lpReplacementFileName,
    LPCWSTR lpBackupFileName,
    DWORD dwReplaceFlags,
    LPVOID lpExclude,
    LPVOID lpReserved
    );
static const int ReplaceFile = ReplaceFileA;
//
// API call to create hard links.
//
BOOL
CreateHardLinkA(
    LPCSTR lpFileName,
    LPCSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
BOOL
CreateHardLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
static const int CreateHardLink = CreateHardLinkA;
//
// API call to create hard links.
//
BOOL
CreateHardLinkTransactedA(
    LPCSTR lpFileName,
    LPCSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );
BOOL
CreateHardLinkTransactedW(
    LPCWSTR lpFileName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );
static const int CreateHardLinkTransacted = CreateHardLinkTransactedA;
//
// API call to enumerate for streams within a file
//
typedef enum _STREAM_INFO_LEVELS {
    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel
} STREAM_INFO_LEVELS;
typedef struct _WIN32_FIND_STREAM_DATA {
    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ 260 + 36 ];
} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;
HANDLE
FindFirstStreamW(
    LPCWSTR lpFileName,
    STREAM_INFO_LEVELS InfoLevel,
    LPVOID lpFindStreamData,
    DWORD dwFlags
    );
HANDLE
FindFirstStreamTransactedW (
    LPCWSTR lpFileName,
    STREAM_INFO_LEVELS InfoLevel,
    LPVOID lpFindStreamData,
    DWORD dwFlags,
    HANDLE hTransaction
    );
BOOL
FindNextStreamW(
    HANDLE hFindStream,
    LPVOID lpFindStreamData
    );
HANDLE
FindFirstFileNameW (
    LPCWSTR lpFileName,
    DWORD dwFlags,
    LPDWORD StringLength,
    PWCHAR LinkName
    );
BOOL
FindNextFileNameW (
    HANDLE hFindStream,
    LPDWORD StringLength,
    PWCHAR LinkName
    );
HANDLE
FindFirstFileNameTransactedW (
    LPCWSTR lpFileName,
    DWORD dwFlags,
    LPDWORD StringLength,
    PWCHAR LinkName,
    HANDLE hTransaction
    );
HANDLE
CreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
HANDLE
CreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
static const int CreateNamedPipe = CreateNamedPipeA;
BOOL
GetNamedPipeHandleStateA(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPSTR lpUserName,
    DWORD nMaxUserNameSize
    );
BOOL
GetNamedPipeHandleStateW(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    );
static const int GetNamedPipeHandleState = GetNamedPipeHandleStateA;
BOOL
CallNamedPipeA(
    LPCSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );
BOOL
CallNamedPipeW(
    LPCWSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );
static const int CallNamedPipe = CallNamedPipeA;
BOOL
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    );
BOOL
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    );
static const int WaitNamedPipe = WaitNamedPipeA;
typedef enum {
    PipeAttribute,
    PipeConnectionAttribute,
    PipeHandleAttribute
} PIPE_ATTRIBUTE_TYPE;
BOOL
GetNamedPipeAttribute(
    HANDLE Pipe,
    PIPE_ATTRIBUTE_TYPE AttributeType,
    PSTR AttributeName,
    PVOID AttributeValue,
    PSIZE_T AttributeValueLength
    );
BOOL
SetNamedPipeAttribute(
    HANDLE Pipe,
    PIPE_ATTRIBUTE_TYPE AttributeType,
    PSTR AttributeName,
    PVOID AttributeValue,
    SIZE_T AttributeValueLength
    );
BOOL
GetNamedPipeClientComputerNameA(
    HANDLE Pipe,
    LPSTR ClientComputerName,
    ULONG ClientComputerNameLength
    );
BOOL
GetNamedPipeClientComputerNameW(
    HANDLE Pipe,
    LPWSTR ClientComputerName,
    ULONG ClientComputerNameLength
    );
static const int GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameA;
BOOL
GetNamedPipeClientProcessId(
    HANDLE Pipe,
    PULONG ClientProcessId
    );
BOOL
GetNamedPipeClientSessionId(
    HANDLE Pipe,
    PULONG ClientSessionId
    );
BOOL
GetNamedPipeServerProcessId(
    HANDLE Pipe,
    PULONG ServerProcessId
    );
BOOL
GetNamedPipeServerSessionId(
    HANDLE Pipe,
    PULONG ServerSessionId
    );
BOOL
SetVolumeLabelA(
    LPCSTR lpRootPathName,
    LPCSTR lpVolumeName
    );
BOOL
SetVolumeLabelW(
    LPCWSTR lpRootPathName,
    LPCWSTR lpVolumeName
    );
static const int SetVolumeLabel = SetVolumeLabelA;
void
SetFileApisToOEM( void );
void
SetFileApisToANSI( void );
BOOL
AreFileApisANSI( void );
BOOL
GetVolumeInformationA(
    LPCSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );
BOOL
GetVolumeInformationW(
    LPCWSTR lpRootPathName,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );
static const int GetVolumeInformation = GetVolumeInformationA;
BOOL
GetVolumeInformationByHandleW(
    HANDLE hFile,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );
BOOL
CancelSynchronousIo(
    HANDLE hThread
    );
BOOL
CancelIoEx(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped
    );
BOOL
CancelIo(
    HANDLE hFile
    );
BOOL
SetFileBandwidthReservation(
    HANDLE hFile,
    DWORD nPeriodMilliseconds,
    DWORD nBytesPerPeriod,
    BOOL bDiscardable,
    LPDWORD lpTransferSize,
    LPDWORD lpNumOutstandingRequests
    );
BOOL
GetFileBandwidthReservation(
    HANDLE hFile,
    LPDWORD lpPeriodMilliseconds,
    LPDWORD lpBytesPerPeriod,
    LPBOOL pDiscardable,
    LPDWORD lpTransferSize,
    LPDWORD lpNumOutstandingRequests
    );
//
// Event logging APIs
//
BOOL
ClearEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );
BOOL
ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );
static const int ClearEventLog = ClearEventLogA;
BOOL
BackupEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );
BOOL
BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );
static const int BackupEventLog = BackupEventLogA;
BOOL
CloseEventLog (
    HANDLE hEventLog
    );
BOOL
DeregisterEventSource (
    HANDLE hEventLog
    );
BOOL
NotifyChangeEventLog(
    HANDLE hEventLog,
    HANDLE hEvent
    );
BOOL
GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    );
BOOL
GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    );
HANDLE
OpenEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );
HANDLE
OpenEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );
static const int OpenEventLog = OpenEventLogA;
HANDLE
RegisterEventSourceA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );
HANDLE
RegisterEventSourceW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );
static const int RegisterEventSource = RegisterEventSourceA;
HANDLE
OpenBackupEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpFileName
    );
HANDLE
OpenBackupEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpFileName
    );
static const int OpenBackupEventLog = OpenBackupEventLogA;
BOOL
ReadEventLogA (
    HANDLE hEventLog,
    DWORD dwReadFlags,
    DWORD dwRecordOffset,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    DWORD *pnBytesRead,
    DWORD *pnMinNumberOfBytesNeeded
    );
BOOL
ReadEventLogW (
    HANDLE hEventLog,
    DWORD dwReadFlags,
    DWORD dwRecordOffset,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    DWORD *pnBytesRead,
    DWORD *pnMinNumberOfBytesNeeded
    );
static const int ReadEventLog = ReadEventLogA;
BOOL
ReportEventA (
    HANDLE hEventLog,
    WORD wType,
    WORD wCategory,
    DWORD dwEventID,
    PSID lpUserSid,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCSTR *lpStrings,
    LPVOID lpRawData
    );
BOOL
ReportEventW (
    HANDLE hEventLog,
    WORD wType,
    WORD wCategory,
    DWORD dwEventID,
    PSID lpUserSid,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCWSTR *lpStrings,
    LPVOID lpRawData
    );
static const int ReportEvent = ReportEventA;
static const int EVENTLOG_FULL_INFO = 0;
typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;
BOOL
GetEventLogInformation (
    HANDLE hEventLog,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
//
//
// Security APIs
//
BOOL
DuplicateToken(
    HANDLE ExistingTokenHandle,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    PHANDLE DuplicateTokenHandle
    );
BOOL
GetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );
BOOL
ImpersonateNamedPipeClient(
    HANDLE hNamedPipe
    );
BOOL
ImpersonateSelf(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
BOOL
RevertToSelf (
    void
    );
BOOL
SetThreadToken (
    PHANDLE Thread,
    HANDLE Token
    );
BOOL
AccessCheck (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    );
BOOL
AccessCheckByType (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    );
BOOL
AccessCheckByTypeResultList (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList
    );
BOOL
OpenProcessToken (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    );
BOOL
OpenThreadToken (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    );
BOOL
GetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    );
BOOL
SetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength
    );
BOOL
AdjustTokenPrivileges (
    HANDLE TokenHandle,
    BOOL DisableAllPrivileges,
    PTOKEN_PRIVILEGES NewState,
    DWORD BufferLength,
    PTOKEN_PRIVILEGES PreviousState,
    PDWORD ReturnLength
    );
BOOL
AdjustTokenGroups (
    HANDLE TokenHandle,
    BOOL ResetToDefault,
    PTOKEN_GROUPS NewState,
    DWORD BufferLength,
    PTOKEN_GROUPS PreviousState,
    PDWORD ReturnLength
    );
BOOL
PrivilegeCheck (
    HANDLE ClientToken,
    PPRIVILEGE_SET RequiredPrivileges,
    LPBOOL pfResult
    );
BOOL
AccessCheckAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
BOOL
AccessCheckAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
static const int AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
BOOL
AccessCheckByTypeAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
BOOL
AccessCheckByTypeAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );
static const int AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmA;
BOOL
AccessCheckByTypeResultListAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );
BOOL
AccessCheckByTypeResultListAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );
static const int AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmA;
BOOL
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );
BOOL
AccessCheckByTypeResultListAndAuditAlarmByHandleW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );
static const int AccessCheckByTypeResultListAndAuditAlarmByHandle = AccessCheckByTypeResultListAndAuditAlarmByHandleA;
BOOL
ObjectOpenAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );
BOOL
ObjectOpenAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );
static const int ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
BOOL
ObjectPrivilegeAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
BOOL
ObjectPrivilegeAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
static const int ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
BOOL
ObjectCloseAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
BOOL
ObjectCloseAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
static const int ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
BOOL
ObjectDeleteAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
BOOL
ObjectDeleteAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );
static const int ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
BOOL
PrivilegedServiceAuditAlarmA (
    LPCSTR SubsystemName,
    LPCSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
BOOL
PrivilegedServiceAuditAlarmW (
    LPCWSTR SubsystemName,
    LPCWSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );
static const int PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
BOOL
IsWellKnownSid (
    PSID pSid,
    WELL_KNOWN_SID_TYPE WellKnownSidType
    );
 BOOL
CreateWellKnownSid(
    WELL_KNOWN_SID_TYPE WellKnownSidType,
    PSID DomainSid,
    PSID pSid,
    DWORD *cbSid
    );
 BOOL
EqualDomainSid(
    PSID pSid1,
    PSID pSid2,
    BOOL *pfEqual
    );
 BOOL
GetWindowsAccountDomainSid(
    PSID pSid,
    PSID pDomainSid,
    DWORD* cbDomainSid
    );
BOOL
IsValidSid (
    PSID pSid
    );
BOOL
EqualSid (
    PSID pSid1,
    PSID pSid2
    );
BOOL
EqualPrefixSid (
    PSID pSid1,
    PSID pSid2
    );
DWORD
GetSidLengthRequired (
    UCHAR nSubAuthorityCount
    );
BOOL
AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    );
PVOID
FreeSid(
    PSID pSid
    );
BOOL
InitializeSid (
    PSID Sid,
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount
    );
PSID_IDENTIFIER_AUTHORITY
GetSidIdentifierAuthority (
    PSID pSid
    );
PDWORD
GetSidSubAuthority (
    PSID pSid,
    DWORD nSubAuthority
    );
PUCHAR
GetSidSubAuthorityCount (
    PSID pSid
    );
DWORD
GetLengthSid (
    PSID pSid
    );
BOOL
CopySid (
    DWORD nDestinationSidLength,
    PSID pDestinationSid,
    PSID pSourceSid
    );
BOOL
AreAllAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );
BOOL
AreAnyAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );
void
MapGenericMask (
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping
    );
BOOL
IsValidAcl (
    PACL pAcl
    );
BOOL
InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    );
BOOL
GetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );
BOOL
SetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );
BOOL
AddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    LPVOID pAceList,
    DWORD nAceListLength
    );
BOOL
DeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    );
BOOL
GetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    LPVOID *pAce
    );
BOOL
AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );
BOOL
AddAccessAllowedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    );
BOOL
AddMandatoryAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD MandatoryPolicy,
    PSID pLabelSid
    );
BOOL
AddConditionalAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    UCHAR AceType,
    DWORD AccessMask,
    PSID pSid,
    PWCHAR ConditionStr,
    DWORD *ReturnLength
    );
BOOL
AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );
BOOL
AddAccessDeniedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    );
BOOL
AddAuditAccessAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );
BOOL
AddAuditAccessAceEx(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );
BOOL
AddAccessAllowedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    );
BOOL
AddAccessDeniedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    );
BOOL
AddAuditAccessObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );
BOOL
FindFirstFreeAce (
    PACL pAcl,
    LPVOID *pAce
    );
BOOL
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    );
BOOL
IsValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
BOOL
IsValidRelativeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    SECURITY_INFORMATION RequiredInformation
    );
DWORD
GetSecurityDescriptorLength (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
BOOL
GetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL pControl,
    LPDWORD lpdwRevision
    );
BOOL
SetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );
BOOL
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl,
    BOOL bDaclDefaulted
    );
BOOL
GetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbDaclPresent,
    PACL *pDacl,
    LPBOOL lpbDaclDefaulted
    );
BOOL
SetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bSaclPresent,
    PACL pSacl,
    BOOL bSaclDefaulted
    );
BOOL
GetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbSaclPresent,
    PACL *pSacl,
    LPBOOL lpbSaclDefaulted
    );
BOOL
SetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pOwner,
    BOOL bOwnerDefaulted
    );
BOOL
GetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pOwner,
    LPBOOL lpbOwnerDefaulted
    );
BOOL
SetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pGroup,
    BOOL bGroupDefaulted
    );
BOOL
GetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pGroup,
    LPBOOL lpbGroupDefaulted
    );
DWORD
SetSecurityDescriptorRMControl(
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PUCHAR RMControl
    );
DWORD
GetSecurityDescriptorRMControl(
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PUCHAR RMControl
    );
BOOL
CreatePrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    BOOL IsDirectoryObject,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );
BOOL
ConvertToAutoInheritPrivateObjectSecurity(
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    GUID *ObjectType,
    BOOLEAN IsDirectoryObject,
    PGENERIC_MAPPING GenericMapping
    );
BOOL
CreatePrivateObjectSecurityEx (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID *ObjectType,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );
BOOL
CreatePrivateObjectSecurityWithMultipleInheritance (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID **ObjectTypes,
    ULONG GuidCount,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );
BOOL
SetPrivateObjectSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );
BOOL
SetPrivateObjectSecurityEx (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    ULONG AutoInheritFlags,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );
 BOOL
GetPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ObjectDescriptor,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ResultantDescriptor,
    DWORD DescriptorLength,
    PDWORD ReturnLength
    );
BOOL
DestroyPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    );
 BOOL
MakeSelfRelativeSD (
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferLength
    );
 BOOL
MakeAbsoluteSD (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    PACL pDacl,
    LPDWORD lpdwDaclSize,
    PACL pSacl,
    LPDWORD lpdwSaclSize,
    PSID pOwner,
    LPDWORD lpdwOwnerSize,
    PSID pPrimaryGroup,
    LPDWORD lpdwPrimaryGroupSize
    );
 BOOL
MakeAbsoluteSD2 (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferSize
    );
void
QuerySecurityAccessMask(
    SECURITY_INFORMATION SecurityInformation,
    LPDWORD DesiredAccess
    );
void
SetSecurityAccessMask(
    SECURITY_INFORMATION SecurityInformation,
    LPDWORD DesiredAccess
    );
BOOL
SetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
BOOL
SetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
static const int SetFileSecurity = SetFileSecurityA;
BOOL
GetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );
BOOL
GetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );
static const int GetFileSecurity = GetFileSecurityA;
BOOL
SetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );
HANDLE
FindFirstChangeNotificationA(
    LPCSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );
HANDLE
FindFirstChangeNotificationW(
    LPCWSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );
static const int FindFirstChangeNotification = FindFirstChangeNotificationA;
BOOL
FindNextChangeNotification(
    HANDLE hChangeHandle
    );
BOOL
FindCloseChangeNotification(
    HANDLE hChangeHandle
    );
BOOL
ReadDirectoryChangesW(
    HANDLE hDirectory,
    LPVOID lpBuffer,
    DWORD nBufferLength,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
BOOL
VirtualLock(
    LPVOID lpAddress,
    SIZE_T dwSize
    );
BOOL
VirtualUnlock(
    LPVOID lpAddress,
    SIZE_T dwSize
    );
LPVOID
MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    );
LPVOID
MapViewOfFileExNuma(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap,
    LPVOID lpBaseAddress,
    DWORD nndPreferred
    );
BOOL
SetPriorityClass(
    HANDLE hProcess,
    DWORD dwPriorityClass
    );
DWORD
GetPriorityClass(
    HANDLE hProcess
    );
BOOL
IsBadReadPtr(
    const void *lp,
    UINT_PTR ucb
    );
BOOL
IsBadWritePtr(
    LPVOID lp,
    UINT_PTR ucb
    );
BOOL
IsBadHugeReadPtr(
    const void *lp,
    UINT_PTR ucb
    );
BOOL
IsBadHugeWritePtr(
    LPVOID lp,
    UINT_PTR ucb
    );
BOOL
IsBadCodePtr(
    FARPROC lpfn
    );
BOOL
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR ucchMax
    );
BOOL
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR ucchMax
    );
static const int IsBadStringPtr = IsBadStringPtrA;
 BOOL
LookupAccountSidA(
    LPCSTR lpSystemName,
    PSID Sid,
    LPSTR Name,
    LPDWORD cchName,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
 BOOL
LookupAccountSidW(
    LPCWSTR lpSystemName,
    PSID Sid,
    LPWSTR Name,
    LPDWORD cchName,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
static const int LookupAccountSid = LookupAccountSidA;
 BOOL
LookupAccountSidLocalA(
    PSID Sid,
    LPSTR Name,
    LPDWORD cchName,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
 BOOL
LookupAccountSidLocalW(
    PSID Sid,
    LPWSTR Name,
    LPDWORD cchName,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
static const int LookupAccountSidLocal = LookupAccountSidLocalA;
 BOOL
LookupAccountNameA(
    LPCSTR lpSystemName,
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
 BOOL
LookupAccountNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
static const int LookupAccountName = LookupAccountNameA;
 BOOL
LookupAccountNameLocalA(
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
 BOOL
LookupAccountNameLocalW(
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );
static const int LookupAccountNameLocal = LookupAccountNameLocalA;
BOOL
LookupPrivilegeValueA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    PLUID lpLuid
    );
BOOL
LookupPrivilegeValueW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID lpLuid
    );
static const int LookupPrivilegeValue = LookupPrivilegeValueA;
 BOOL
LookupPrivilegeNameA(
    LPCSTR lpSystemName,
    PLUID lpLuid,
    LPSTR lpName,
    LPDWORD cchName
    );
 BOOL
LookupPrivilegeNameW(
    LPCWSTR lpSystemName,
    PLUID lpLuid,
    LPWSTR lpName,
    LPDWORD cchName
    );
static const int LookupPrivilegeName = LookupPrivilegeNameA;
 BOOL
LookupPrivilegeDisplayNameA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    LPSTR lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    );
 BOOL
LookupPrivilegeDisplayNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    LPWSTR lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    );
static const int LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
BOOL
AllocateLocallyUniqueId(
    PLUID Luid
    );
BOOL
BuildCommDCBA(
    LPCSTR lpDef,
    LPDCB lpDCB
    );
BOOL
BuildCommDCBW(
    LPCWSTR lpDef,
    LPDCB lpDCB
    );
static const int BuildCommDCB = BuildCommDCBA;
BOOL
BuildCommDCBAndTimeoutsA(
    LPCSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
BOOL
BuildCommDCBAndTimeoutsW(
    LPCWSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );
static const int BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
BOOL
CommConfigDialogA(
    LPCSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );
BOOL
CommConfigDialogW(
    LPCWSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );
static const int CommConfigDialog = CommConfigDialogA;
BOOL
GetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );
BOOL
GetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );
static const int GetDefaultCommConfig = GetDefaultCommConfigA;
BOOL
SetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );
BOOL
SetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );
static const int SetDefaultCommConfig = SetDefaultCommConfigA;
static const int MAX_COMPUTERNAME_LENGTH = 15;
BOOL
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );
BOOL
GetComputerNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );
static const int GetComputerName = GetComputerNameA;
BOOL
SetComputerNameA (
    LPCSTR lpComputerName
    );
BOOL
SetComputerNameW (
    LPCWSTR lpComputerName
    );
static const int SetComputerName = SetComputerNameA;
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;
BOOL
GetComputerNameExA (
    COMPUTER_NAME_FORMAT NameType,
    LPSTR lpBuffer,
    LPDWORD nSize
    );
BOOL
GetComputerNameExW (
    COMPUTER_NAME_FORMAT NameType,
    LPWSTR lpBuffer,
    LPDWORD nSize
    );
static const int GetComputerNameEx = GetComputerNameExA;
BOOL
SetComputerNameExA (
    COMPUTER_NAME_FORMAT NameType,
    LPCSTR lpBuffer
    );
BOOL
SetComputerNameExW (
    COMPUTER_NAME_FORMAT NameType,
    LPCWSTR lpBuffer
    );
static const int SetComputerNameEx = SetComputerNameExA;
BOOL
DnsHostnameToComputerNameA (
    LPCSTR Hostname,
    LPSTR ComputerName,
    LPDWORD nSize
    );
BOOL
DnsHostnameToComputerNameW (
    LPCWSTR Hostname,
    LPWSTR ComputerName,
    LPDWORD nSize
    );
static const int DnsHostnameToComputerName = DnsHostnameToComputerNameA;
BOOL
GetUserNameA (
    LPSTR lpBuffer,
    LPDWORD pcbBuffer
    );
BOOL
GetUserNameW (
    LPWSTR lpBuffer,
    LPDWORD pcbBuffer
    );
static const int GetUserName = GetUserNameA;
//
// Logon Support APIs
//
static const int LOGON32_LOGON_INTERACTIVE = 2;
static const int LOGON32_LOGON_NETWORK = 3;
static const int LOGON32_LOGON_BATCH = 4;
static const int LOGON32_LOGON_SERVICE = 5;
static const int LOGON32_LOGON_UNLOCK = 7;
static const int LOGON32_LOGON_NETWORK_CLEARTEXT = 8;
static const int LOGON32_LOGON_NEW_CREDENTIALS = 9;
static const int LOGON32_PROVIDER_DEFAULT = 0;
static const int LOGON32_PROVIDER_WINNT35 = 1;
static const int LOGON32_PROVIDER_WINNT40 = 2;
static const int LOGON32_PROVIDER_WINNT50 = 3;
static const int LOGON32_PROVIDER_VIRTUAL = 4;
BOOL
LogonUserA (
    LPCSTR lpszUsername,
    LPCSTR lpszDomain,
    LPCSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );
BOOL
LogonUserW (
    LPCWSTR lpszUsername,
    LPCWSTR lpszDomain,
    LPCWSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );
static const int LogonUser = LogonUserA;
BOOL
LogonUserExA (
    LPCSTR lpszUsername,
    LPCSTR lpszDomain,
    LPCSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken,
    PSID *ppLogonSid,
    PVOID *ppProfileBuffer,
    LPDWORD pdwProfileLength,
    PQUOTA_LIMITS pQuotaLimits
    );
BOOL
LogonUserExW (
    LPCWSTR lpszUsername,
    LPCWSTR lpszDomain,
    LPCWSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken,
    PSID *ppLogonSid,
    PVOID *ppProfileBuffer,
    LPDWORD pdwProfileLength,
    PQUOTA_LIMITS pQuotaLimits
    );
static const int LogonUserEx = LogonUserExA;
# 12774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
BOOL
ImpersonateLoggedOnUser(
    HANDLE hToken
    );
BOOL
CreateProcessAsUserA (
    HANDLE hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
BOOL
CreateProcessAsUserW (
    HANDLE hToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
static const int CreateProcessAsUser = CreateProcessAsUserA;
//
// LogonFlags
//
static const int LOGON_WITH_PROFILE = 0x00000001;
static const int LOGON_NETCREDENTIALS_ONLY = 0x00000002;
static const int LOGON_ZERO_PASSWORD_BUFFER = 0x80000000;
 BOOL
CreateProcessWithLogonW(
    LPCWSTR lpUsername,
    LPCWSTR lpDomain,
    LPCWSTR lpPassword,
    DWORD dwLogonFlags,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
      );
 BOOL
CreateProcessWithTokenW(
    HANDLE hToken,
    DWORD dwLogonFlags,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
      );
BOOL
ImpersonateAnonymousToken(
    HANDLE ThreadHandle
    );
BOOL
DuplicateTokenEx(
    HANDLE hExistingToken,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpTokenAttributes,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    TOKEN_TYPE TokenType,
    PHANDLE phNewToken);
BOOL
CreateRestrictedToken(
    HANDLE ExistingTokenHandle,
    DWORD Flags,
    DWORD DisableSidCount,
    PSID_AND_ATTRIBUTES SidsToDisable,
    DWORD DeletePrivilegeCount,
    PLUID_AND_ATTRIBUTES PrivilegesToDelete,
    DWORD RestrictedSidCount,
    PSID_AND_ATTRIBUTES SidsToRestrict,
    PHANDLE NewTokenHandle
    );
BOOL
IsTokenRestricted(
    HANDLE TokenHandle
    );
BOOL
IsTokenUntrusted(
    HANDLE TokenHandle
    );
BOOL
CheckTokenMembership(
    HANDLE TokenHandle,
    PSID SidToCheck,
    PBOOL IsMember
    );
//
// Thread pool API's
//
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;
BOOL
RegisterWaitForSingleObject(
    PHANDLE phNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );
HANDLE
RegisterWaitForSingleObjectEx(
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );
BOOL
UnregisterWait(
    HANDLE WaitHandle
    );
BOOL
UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent
    );
BOOL
QueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    ULONG Flags
    );
BOOL
BindIoCompletionCallback (
    HANDLE FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    ULONG Flags
    );
HANDLE
CreateTimerQueue(
    void
    );
BOOL
CreateTimerQueueTimer(
    PHANDLE phNewTimer,
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    ULONG Flags
    ) ;
BOOL
ChangeTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    ULONG DueTime,
    ULONG Period
    );
BOOL
DeleteTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    HANDLE CompletionEvent
    );
BOOL
DeleteTimerQueueEx(
    HANDLE TimerQueue,
    HANDLE CompletionEvent
    );
HANDLE
SetTimerQueueTimer(
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    BOOL PreferIo
    );
BOOL
CancelTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer
    );
BOOL
DeleteTimerQueue(
    HANDLE TimerQueue
    );
typedef void ( *PTP_WIN32_IO_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PVOID Overlapped,
    ULONG IoResult,
    ULONG_PTR NumberOfBytesTransferred,
    PTP_IO Io
    );
PTP_POOL
CreateThreadpool(
    PVOID reserved
    );
void
SetThreadpoolThreadMaximum(
    PTP_POOL ptpp,
    DWORD cthrdMost
    );
BOOL
SetThreadpoolThreadMinimum(
    PTP_POOL ptpp,
    DWORD cthrdMic
    );
BOOL
SetThreadpoolStackInformation(
    PTP_POOL ptpp,
    PTP_POOL_STACK_INFORMATION ptpsi
    );
BOOL
QueryThreadpoolStackInformation(
    PTP_POOL ptpp,
    PTP_POOL_STACK_INFORMATION ptpsi
    );
void
CloseThreadpool(
    PTP_POOL ptpp
    );
PTP_CLEANUP_GROUP
CreateThreadpoolCleanupGroup(
    void
    );
void
CloseThreadpoolCleanupGroupMembers(
    PTP_CLEANUP_GROUP ptpcg,
    BOOL fCancelPendingCallbacks,
    PVOID pvCleanupContext
    );
void
CloseThreadpoolCleanupGroup(
    PTP_CLEANUP_GROUP ptpcg
    );
__inline
void
InitializeThreadpoolEnvironment(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}
__inline
void
SetThreadpoolCallbackPool(
    PTP_CALLBACK_ENVIRON pcbe,
    PTP_POOL ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}
__inline
void
SetThreadpoolCallbackCleanupGroup(
    PTP_CALLBACK_ENVIRON pcbe,
    PTP_CLEANUP_GROUP ptpcg,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}
__inline
void
SetThreadpoolCallbackRunsLong(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}
__inline
void
SetThreadpoolCallbackLibrary(
    PTP_CALLBACK_ENVIRON pcbe,
    PVOID mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}
__inline
void
SetThreadpoolCallbackPriority(
    PTP_CALLBACK_ENVIRON pcbe,
    TP_CALLBACK_PRIORITY Priority
    )
{
    TpSetCallbackPriority(pcbe, Priority);
}
__inline
void
SetThreadpoolCallbackPersistent(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}
__inline
void
DestroyThreadpoolEnvironment(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}
void
SetEventWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE evt
    );
void
ReleaseSemaphoreWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE sem,
    DWORD crel
    );
void
ReleaseMutexWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE mut
    );
void
LeaveCriticalSectionWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    PCRITICAL_SECTION pcs
    );
void
FreeLibraryWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HMODULE mod
    );
BOOL
CallbackMayRunLong(
    PTP_CALLBACK_INSTANCE pci
    );
void
DisassociateCurrentThreadFromCallback(
    PTP_CALLBACK_INSTANCE pci
    );
BOOL
TrySubmitThreadpoolCallback(
    PTP_SIMPLE_CALLBACK pfns,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );
PTP_WORK
CreateThreadpoolWork(
    PTP_WORK_CALLBACK pfnwk,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );
void
SubmitThreadpoolWork(
    PTP_WORK pwk
    );
void
WaitForThreadpoolWorkCallbacks(
    PTP_WORK pwk,
    BOOL fCancelPendingCallbacks
    );
void
CloseThreadpoolWork(
    PTP_WORK pwk
    );
PTP_TIMER
CreateThreadpoolTimer(
    PTP_TIMER_CALLBACK pfnti,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );
void
SetThreadpoolTimer(
    PTP_TIMER pti,
    PFILETIME pftDueTime,
    DWORD msPeriod,
    DWORD msWindowLength
    );
BOOL
IsThreadpoolTimerSet(
    PTP_TIMER pti
    );
void
WaitForThreadpoolTimerCallbacks(
    PTP_TIMER pti,
    BOOL fCancelPendingCallbacks
    );
void
CloseThreadpoolTimer(
    PTP_TIMER pti
    );
PTP_WAIT
CreateThreadpoolWait(
    PTP_WAIT_CALLBACK pfnwa,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );
void
SetThreadpoolWait(
    PTP_WAIT pwa,
    HANDLE h,
    PFILETIME pftTimeout
    );
void
WaitForThreadpoolWaitCallbacks(
    PTP_WAIT pwa,
    BOOL fCancelPendingCallbacks
    );
void
CloseThreadpoolWait(
    PTP_WAIT pwa
    );
PTP_IO
CreateThreadpoolIo(
    HANDLE fl,
    PTP_WIN32_IO_CALLBACK pfnio,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );
void
StartThreadpoolIo(
    PTP_IO pio
    );
void
CancelThreadpoolIo(
    PTP_IO pio
    );
void
WaitForThreadpoolIoCallbacks(
    PTP_IO pio,
    BOOL fCancelPendingCallbacks
    );
void
CloseThreadpoolIo(
    PTP_IO pio
    );
//
//  Private Namespaces support
//
HANDLE
CreatePrivateNamespaceA(
    LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    LPVOID lpBoundaryDescriptor,
    LPCSTR lpAliasPrefix
    );
HANDLE
CreatePrivateNamespaceW(
    LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    LPVOID lpBoundaryDescriptor,
    LPCWSTR lpAliasPrefix
    );
static const int CreatePrivateNamespace = CreatePrivateNamespaceA;
HANDLE
OpenPrivateNamespaceA(
    LPVOID lpBoundaryDescriptor,
    LPCSTR lpAliasPrefix
    );
HANDLE
OpenPrivateNamespaceW(
    LPVOID lpBoundaryDescriptor,
    LPCWSTR lpAliasPrefix
    );
static const int OpenPrivateNamespace = OpenPrivateNamespaceA;
static const int PRIVATE_NAMESPACE_FLAG_DESTROY = 0x00000001;
BOOLEAN
ClosePrivateNamespace(
    HANDLE Handle,
    ULONG Flags
    );
//
//  Boundary descriptors support
//
HANDLE
CreateBoundaryDescriptorA(
    LPCSTR Name,
    ULONG Flags
    );
HANDLE
CreateBoundaryDescriptorW(
    LPCWSTR Name,
    ULONG Flags
    );
static const int CreateBoundaryDescriptor = CreateBoundaryDescriptorA;
BOOL
AddSIDToBoundaryDescriptor(
    HANDLE * BoundaryDescriptor,
    PSID RequiredSid
    );
BOOL
AddIntegrityLabelToBoundaryDescriptor(
    HANDLE * BoundaryDescriptor,
    PSID IntegrityLabel
    );
void
DeleteBoundaryDescriptor(
    HANDLE BoundaryDescriptor
    );
# 13571 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
//
// Plug-and-Play API's
//
static const int HW_PROFILE_GUIDLEN = 39;
static const int MAX_PROFILE_LEN = 80;
static const int DOCKINFO_UNDOCKED = (0x1);
static const int DOCKINFO_DOCKED = (0x2);
static const int DOCKINFO_USER_SUPPLIED = (0x4);
static const int DOCKINFO_USER_UNDOCKED = (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED);
static const int DOCKINFO_USER_DOCKED = (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED);
typedef struct tagHW_PROFILE_INFOA {
    DWORD dwDockInfo;
    CHAR szHwProfileGuid[39];
    CHAR szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD dwDockInfo;
    WCHAR szHwProfileGuid[39];
    WCHAR szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;
typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;
BOOL
GetCurrentHwProfileA (
    LPHW_PROFILE_INFOA lpHwProfileInfo
    );
BOOL
GetCurrentHwProfileW (
    LPHW_PROFILE_INFOW lpHwProfileInfo
    );
static const int GetCurrentHwProfile = GetCurrentHwProfileA;
//
// Performance counter API's
//
BOOL
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    );
BOOL
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    );
BOOL
GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    );
BOOL
GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    );
static const int GetVersionEx = GetVersionExA;
BOOL
VerifyVersionInfoA(
    LPOSVERSIONINFOEXA lpVersionInformation,
    DWORD dwTypeMask,
    DWORDLONG dwlConditionMask
    );
BOOL
VerifyVersionInfoW(
    LPOSVERSIONINFOEXW lpVersionInformation,
    DWORD dwTypeMask,
    DWORDLONG dwlConditionMask
    );
static const int VerifyVersionInfo = VerifyVersionInfoA;
BOOL
GetProductInfo(
    DWORD dwOSMajorVersion,
    DWORD dwOSMinorVersion,
    DWORD dwSpMajorVersion,
    DWORD dwSpMinorVersion,
    PDWORD pdwReturnedProductType
    );
// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h" 1
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/
# 10 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
# 26 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
//  Note: There is a slightly modified layout for HRESULT values below,
//        after the heading "COM Error Codes".
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
static const int FACILITY_XPS = 82;
static const int FACILITY_WINRM = 51;
static const int FACILITY_WINDOWSUPDATE = 36;
static const int FACILITY_WINDOWS_DEFENDER = 80;
static const int FACILITY_WINDOWS_CE = 24;
static const int FACILITY_WINDOWS = 8;
static const int FACILITY_USERMODE_VOLMGR = 56;
static const int FACILITY_USERMODE_VIRTUALIZATION = 55;
static const int FACILITY_USERMODE_VHD = 58;
static const int FACILITY_URT = 19;
static const int FACILITY_UMI = 22;
static const int FACILITY_UI = 42;
static const int FACILITY_TPM_SOFTWARE = 41;
static const int FACILITY_TPM_SERVICES = 40;
static const int FACILITY_SXS = 23;
static const int FACILITY_STORAGE = 3;
static const int FACILITY_STATE_MANAGEMENT = 34;
static const int FACILITY_SSPI = 9;
static const int FACILITY_SCARD = 16;
static const int FACILITY_SHELL = 39;
static const int FACILITY_SETUPAPI = 15;
static const int FACILITY_SECURITY = 9;
static const int FACILITY_SDIAG = 60;
static const int FACILITY_RPC = 1;
static const int FACILITY_RAS = 83;
static const int FACILITY_PLA = 48;
static const int FACILITY_OPC = 81;
static const int FACILITY_WIN32 = 7;
static const int FACILITY_CONTROL = 10;
static const int FACILITY_WEBSERVICES = 61;
static const int FACILITY_NULL = 0;
static const int FACILITY_NDIS = 52;
static const int FACILITY_METADIRECTORY = 35;
static const int FACILITY_MSMQ = 14;
static const int FACILITY_MEDIASERVER = 13;
static const int FACILITY_MBN = 84;
static const int FACILITY_INTERNET = 12;
static const int FACILITY_ITF = 4;
static const int FACILITY_USERMODE_HYPERVISOR = 53;
static const int FACILITY_HTTP = 25;
static const int FACILITY_GRAPHICS = 38;
static const int FACILITY_FWP = 50;
static const int FACILITY_FVE = 49;
static const int FACILITY_USERMODE_FILTER_MANAGER = 31;
static const int FACILITY_DPLAY = 21;
static const int FACILITY_DISPATCH = 2;
static const int FACILITY_DIRECTORYSERVICE = 37;
static const int FACILITY_CONFIGURATION = 33;
static const int FACILITY_COMPLUS = 17;
static const int FACILITY_USERMODE_COMMONLOG = 26;
static const int FACILITY_CMI = 54;
static const int FACILITY_CERT = 11;
static const int FACILITY_BCD = 57;
static const int FACILITY_BACKGROUNDCOPY = 32;
static const int FACILITY_ACS = 20;
static const int FACILITY_AAF = 18;
//
// Define the severity codes
//
//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
// The operation completed successfully.
//
static const long ERROR_SUCCESS = 0L;
static const long NO_ERROR = 0L;
static const int SEC_E_OK = ((HRESULT)0x00000000L);
//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
// Incorrect function.
//
static const long ERROR_INVALID_FUNCTION = 1L;
//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.
//
static const long ERROR_FILE_NOT_FOUND = 2L;
//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
// The system cannot find the path specified.
//
static const long ERROR_PATH_NOT_FOUND = 3L;
//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
// The system cannot open the file.
//
static const long ERROR_TOO_MANY_OPEN_FILES = 4L;
//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
static const long ERROR_ACCESS_DENIED = 5L;
//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
// The handle is invalid.
//
static const long ERROR_INVALID_HANDLE = 6L;
//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
// The storage control blocks were destroyed.
//
static const long ERROR_ARENA_TRASHED = 7L;
//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
// Not enough storage is available to process this command.
//
static const long ERROR_NOT_ENOUGH_MEMORY = 8L;
//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
// The storage control block address is invalid.
//
static const long ERROR_INVALID_BLOCK = 9L;
//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
// The environment is incorrect.
//
static const long ERROR_BAD_ENVIRONMENT = 10L;
//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
// An attempt was made to load a program with an incorrect format.
//
static const long ERROR_BAD_FORMAT = 11L;
//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
// The access code is invalid.
//
static const long ERROR_INVALID_ACCESS = 12L;
//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
// The data is invalid.
//
static const long ERROR_INVALID_DATA = 13L;
//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
// Not enough storage is available to complete this operation.
//
static const long ERROR_OUTOFMEMORY = 14L;
//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
// The system cannot find the drive specified.
//
static const long ERROR_INVALID_DRIVE = 15L;
//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
// The directory cannot be removed.
//
static const long ERROR_CURRENT_DIRECTORY = 16L;
//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
// The system cannot move the file to a different disk drive.
//
static const long ERROR_NOT_SAME_DEVICE = 17L;
//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
// There are no more files.
//
static const long ERROR_NO_MORE_FILES = 18L;
//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
// The media is write protected.
//
static const long ERROR_WRITE_PROTECT = 19L;
//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
// The system cannot find the device specified.
//
static const long ERROR_BAD_UNIT = 20L;
//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
// The device is not ready.
//
static const long ERROR_NOT_READY = 21L;
//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
// The device does not recognize the command.
//
static const long ERROR_BAD_COMMAND = 22L;
//
// MessageId: ERROR_CRC
//
// MessageText:
//
// Data error (cyclic redundancy check).
//
static const long ERROR_CRC = 23L;
//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
// The program issued a command but the command length is incorrect.
//
static const long ERROR_BAD_LENGTH = 24L;
//
// MessageId: ERROR_SEEK
//
// MessageText:
//
// The drive cannot locate a specific area or track on the disk.
//
static const long ERROR_SEEK = 25L;
//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
// The specified disk or diskette cannot be accessed.
//
static const long ERROR_NOT_DOS_DISK = 26L;
//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
// The drive cannot find the sector requested.
//
static const long ERROR_SECTOR_NOT_FOUND = 27L;
//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
// The printer is out of paper.
//
static const long ERROR_OUT_OF_PAPER = 28L;
//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
// The system cannot write to the specified device.
//
static const long ERROR_WRITE_FAULT = 29L;
//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
// The system cannot read from the specified device.
//
static const long ERROR_READ_FAULT = 30L;
//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
// A device attached to the system is not functioning.
//
static const long ERROR_GEN_FAILURE = 31L;
//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
// The process cannot access the file because it is being used by another process.
//
static const long ERROR_SHARING_VIOLATION = 32L;
//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
// The process cannot access the file because another process has locked a portion of the file.
//
static const long ERROR_LOCK_VIOLATION = 33L;
//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
// The wrong diskette is in the drive.
// Insert %2 (Volume Serial Number: %3) into drive %1.
//
static const long ERROR_WRONG_DISK = 34L;
//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
// Too many files opened for sharing.
//
static const long ERROR_SHARING_BUFFER_EXCEEDED = 36L;
//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
// Reached the end of the file.
//
static const long ERROR_HANDLE_EOF = 38L;
//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
// The disk is full.
//
static const long ERROR_HANDLE_DISK_FULL = 39L;
//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
// The request is not supported.
//
static const long ERROR_NOT_SUPPORTED = 50L;
//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
// Windows cannot find the network path. Verify that the network path is correct and the destination computer is not busy or turned off. If Windows still cannot find the network path, contact your network administrator.
//
static const long ERROR_REM_NOT_LIST = 51L;
//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
// You were not connected because a duplicate name exists on the network. If joining a domain, go to System in Control Panel to change the computer name and try again. If joining a workgroup, choose another workgroup name.
//
static const long ERROR_DUP_NAME = 52L;
//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
// The network path was not found.
//
static const long ERROR_BAD_NETPATH = 53L;
//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
// The network is busy.
//
static const long ERROR_NETWORK_BUSY = 54L;
//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
// The specified network resource or device is no longer available.
//
static const long ERROR_DEV_NOT_EXIST = 55L;
//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
// The network BIOS command limit has been reached.
//
static const long ERROR_TOO_MANY_CMDS = 56L;
//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
// A network adapter hardware error occurred.
//
static const long ERROR_ADAP_HDW_ERR = 57L;
//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
// The specified server cannot perform the requested operation.
//
static const long ERROR_BAD_NET_RESP = 58L;
//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
// An unexpected network error occurred.
//
static const long ERROR_UNEXP_NET_ERR = 59L;
//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
// The remote adapter is not compatible.
//
static const long ERROR_BAD_REM_ADAP = 60L;
//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
// The printer queue is full.
//
static const long ERROR_PRINTQ_FULL = 61L;
//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
// Space to store the file waiting to be printed is not available on the server.
//
static const long ERROR_NO_SPOOL_SPACE = 62L;
//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
// Your file waiting to be printed was deleted.
//
static const long ERROR_PRINT_CANCELLED = 63L;
//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
// The specified network name is no longer available.
//
static const long ERROR_NETNAME_DELETED = 64L;
//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
// Network access is denied.
//
static const long ERROR_NETWORK_ACCESS_DENIED = 65L;
//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
// The network resource type is not correct.
//
static const long ERROR_BAD_DEV_TYPE = 66L;
//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
// The network name cannot be found.
//
static const long ERROR_BAD_NET_NAME = 67L;
//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
// The name limit for the local computer network adapter card was exceeded.
//
static const long ERROR_TOO_MANY_NAMES = 68L;
//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
// The network BIOS session limit was exceeded.
//
static const long ERROR_TOO_MANY_SESS = 69L;
//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
// The remote server has been paused or is in the process of being started.
//
static const long ERROR_SHARING_PAUSED = 70L;
//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
// No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.
//
static const long ERROR_REQ_NOT_ACCEP = 71L;
//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
// The specified printer or disk device has been paused.
//
static const long ERROR_REDIR_PAUSED = 72L;
//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
// The file exists.
//
static const long ERROR_FILE_EXISTS = 80L;
//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
// The directory or file cannot be created.
//
static const long ERROR_CANNOT_MAKE = 82L;
//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
// Fail on INT 24.
//
static const long ERROR_FAIL_I24 = 83L;
//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
// Storage to process this request is not available.
//
static const long ERROR_OUT_OF_STRUCTURES = 84L;
//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
// The local device name is already in use.
//
static const long ERROR_ALREADY_ASSIGNED = 85L;
//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
// The specified network password is not correct.
//
static const long ERROR_INVALID_PASSWORD = 86L;
//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
static const long ERROR_INVALID_PARAMETER = 87L;
//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
// A write fault occurred on the network.
//
static const long ERROR_NET_WRITE_FAULT = 88L;
//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
// The system cannot start another process at this time.
//
static const long ERROR_NO_PROC_SLOTS = 89L;
//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
// Cannot create another system semaphore.
//
static const long ERROR_TOO_MANY_SEMAPHORES = 100L;
//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
// The exclusive semaphore is owned by another process.
//
static const long ERROR_EXCL_SEM_ALREADY_OWNED = 101L;
//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
// The semaphore is set and cannot be closed.
//
static const long ERROR_SEM_IS_SET = 102L;
//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
// The semaphore cannot be set again.
//
static const long ERROR_TOO_MANY_SEM_REQUESTS = 103L;
//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
// Cannot request exclusive semaphores at interrupt time.
//
static const long ERROR_INVALID_AT_INTERRUPT_TIME = 104L;
//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
// The previous ownership of this semaphore has ended.
//
static const long ERROR_SEM_OWNER_DIED = 105L;
//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
// Insert the diskette for drive %1.
//
static const long ERROR_SEM_USER_LIMIT = 106L;
//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
// The program stopped because an alternate diskette was not inserted.
//
static const long ERROR_DISK_CHANGE = 107L;
//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
// The disk is in use or locked by another process.
//
static const long ERROR_DRIVE_LOCKED = 108L;
//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
// The pipe has been ended.
//
static const long ERROR_BROKEN_PIPE = 109L;
//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
// The system cannot open the device or file specified.
//
static const long ERROR_OPEN_FAILED = 110L;
//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
// The file name is too long.
//
static const long ERROR_BUFFER_OVERFLOW = 111L;
//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
// There is not enough space on the disk.
//
static const long ERROR_DISK_FULL = 112L;
//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
// No more internal file identifiers available.
//
static const long ERROR_NO_MORE_SEARCH_HANDLES = 113L;
//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
// The target internal file identifier is incorrect.
//
static const long ERROR_INVALID_TARGET_HANDLE = 114L;
//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
// The IOCTL call made by the application program is not correct.
//
static const long ERROR_INVALID_CATEGORY = 117L;
//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
// The verify-on-write switch parameter value is not correct.
//
static const long ERROR_INVALID_VERIFY_SWITCH = 118L;
//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
// The system does not support the command requested.
//
static const long ERROR_BAD_DRIVER_LEVEL = 119L;
//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
// This function is not supported on this system.
//
static const long ERROR_CALL_NOT_IMPLEMENTED = 120L;
//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
// The semaphore timeout period has expired.
//
static const long ERROR_SEM_TIMEOUT = 121L;
//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The data area passed to a system call is too small.
//
static const long ERROR_INSUFFICIENT_BUFFER = 122L;
//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
// The filename, directory name, or volume label syntax is incorrect.
//
static const long ERROR_INVALID_NAME = 123L;
//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
// The system call level is not correct.
//
static const long ERROR_INVALID_LEVEL = 124L;
//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
// The disk has no volume label.
//
static const long ERROR_NO_VOLUME_LABEL = 125L;
//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
// The specified module could not be found.
//
static const long ERROR_MOD_NOT_FOUND = 126L;
//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
// The specified procedure could not be found.
//
static const long ERROR_PROC_NOT_FOUND = 127L;
//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
// There are no child processes to wait for.
//
static const long ERROR_WAIT_NO_CHILDREN = 128L;
//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
// The %1 application cannot be run in Win32 mode.
//
static const long ERROR_CHILD_NOT_COMPLETE = 129L;
//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
// Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.
//
static const long ERROR_DIRECT_ACCESS_HANDLE = 130L;
//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
// An attempt was made to move the file pointer before the beginning of the file.
//
static const long ERROR_NEGATIVE_SEEK = 131L;
//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
// The file pointer cannot be set on the specified device or file.
//
static const long ERROR_SEEK_ON_DEVICE = 132L;
//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
// A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.
//
static const long ERROR_IS_JOIN_TARGET = 133L;
//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
// An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.
//
static const long ERROR_IS_JOINED = 134L;
//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
// An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.
//
static const long ERROR_IS_SUBSTED = 135L;
//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
// The system tried to delete the JOIN of a drive that is not joined.
//
static const long ERROR_NOT_JOINED = 136L;
//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
// The system tried to delete the substitution of a drive that is not substituted.
//
static const long ERROR_NOT_SUBSTED = 137L;
//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
// The system tried to join a drive to a directory on a joined drive.
//
static const long ERROR_JOIN_TO_JOIN = 138L;
//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
// The system tried to substitute a drive to a directory on a substituted drive.
//
static const long ERROR_SUBST_TO_SUBST = 139L;
//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
// The system tried to join a drive to a directory on a substituted drive.
//
static const long ERROR_JOIN_TO_SUBST = 140L;
//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
// The system tried to SUBST a drive to a directory on a joined drive.
//
static const long ERROR_SUBST_TO_JOIN = 141L;
//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
// The system cannot perform a JOIN or SUBST at this time.
//
static const long ERROR_BUSY_DRIVE = 142L;
//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
// The system cannot join or substitute a drive to or for a directory on the same drive.
//
static const long ERROR_SAME_DRIVE = 143L;
//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
// The directory is not a subdirectory of the root directory.
//
static const long ERROR_DIR_NOT_ROOT = 144L;
//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
// The directory is not empty.
//
static const long ERROR_DIR_NOT_EMPTY = 145L;
//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
// The path specified is being used in a substitute.
//
static const long ERROR_IS_SUBST_PATH = 146L;
//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
// Not enough resources are available to process this command.
//
static const long ERROR_IS_JOIN_PATH = 147L;
//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
// The path specified cannot be used at this time.
//
static const long ERROR_PATH_BUSY = 148L;
//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
// An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.
//
static const long ERROR_IS_SUBST_TARGET = 149L;
//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
// System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.
//
static const long ERROR_SYSTEM_TRACE = 150L;
//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
// The number of specified semaphore events for DosMuxSemWait is not correct.
//
static const long ERROR_INVALID_EVENT_COUNT = 151L;
//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
// DosMuxSemWait did not execute; too many semaphores are already set.
//
static const long ERROR_TOO_MANY_MUXWAITERS = 152L;
//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
// The DosMuxSemWait list is not correct.
//
static const long ERROR_INVALID_LIST_FORMAT = 153L;
//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
// The volume label you entered exceeds the label character limit of the target file system.
//
static const long ERROR_LABEL_TOO_LONG = 154L;
//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
// Cannot create another thread.
//
static const long ERROR_TOO_MANY_TCBS = 155L;
//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
// The recipient process has refused the signal.
//
static const long ERROR_SIGNAL_REFUSED = 156L;
//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
// The segment is already discarded and cannot be locked.
//
static const long ERROR_DISCARDED = 157L;
//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
// The segment is already unlocked.
//
static const long ERROR_NOT_LOCKED = 158L;
//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
// The address for the thread ID is not correct.
//
static const long ERROR_BAD_THREADID_ADDR = 159L;
//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
// One or more arguments are not correct.
//
static const long ERROR_BAD_ARGUMENTS = 160L;
//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
// The specified path is invalid.
//
static const long ERROR_BAD_PATHNAME = 161L;
//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
// A signal is already pending.
//
static const long ERROR_SIGNAL_PENDING = 162L;
//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
// No more threads can be created in the system.
//
static const long ERROR_MAX_THRDS_REACHED = 164L;
//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
// Unable to lock a region of a file.
//
static const long ERROR_LOCK_FAILED = 167L;
//
// MessageId: ERROR_BUSY
//
// MessageText:
//
// The requested resource is in use.
//
static const long ERROR_BUSY = 170L;
//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
// A lock request was not outstanding for the supplied cancel region.
//
static const long ERROR_CANCEL_VIOLATION = 173L;
//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
// The file system does not support atomic changes to the lock type.
//
static const long ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 174L;
//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
// The system detected a segment number that was not correct.
//
static const long ERROR_INVALID_SEGMENT_NUMBER = 180L;
//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_INVALID_ORDINAL = 182L;
//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
// Cannot create a file when that file already exists.
//
static const long ERROR_ALREADY_EXISTS = 183L;
//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
// The flag passed is not correct.
//
static const long ERROR_INVALID_FLAG_NUMBER = 186L;
//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
// The specified system semaphore name was not found.
//
static const long ERROR_SEM_NOT_FOUND = 187L;
//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_INVALID_STARTING_CODESEG = 188L;
//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_INVALID_STACKSEG = 189L;
//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_INVALID_MODULETYPE = 190L;
//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
// Cannot run %1 in Win32 mode.
//
static const long ERROR_INVALID_EXE_SIGNATURE = 191L;
//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_EXE_MARKED_INVALID = 192L;
//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
// %1 is not a valid Win32 application.
//
static const long ERROR_BAD_EXE_FORMAT = 193L;
//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_ITERATED_DATA_EXCEEDS_64k = 194L;
//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_INVALID_MINALLOCSIZE = 195L;
//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
// The operating system cannot run this application program.
//
static const long ERROR_DYNLINK_FROM_INVALID_RING = 196L;
//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
// The operating system is not presently configured to run this application.
//
static const long ERROR_IOPL_NOT_ENABLED = 197L;
//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_INVALID_SEGDPL = 198L;
//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
// The operating system cannot run this application program.
//
static const long ERROR_AUTODATASEG_EXCEEDS_64k = 199L;
//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
// The code segment cannot be greater than or equal to 64K.
//
static const long ERROR_RING2SEG_MUST_BE_MOVABLE = 200L;
//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 201L;
//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
// The operating system cannot run %1.
//
static const long ERROR_INFLOOP_IN_RELOC_CHAIN = 202L;
//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
// The system could not find the environment option that was entered.
//
static const long ERROR_ENVVAR_NOT_FOUND = 203L;
//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
// No process in the command subtree has a signal handler.
//
static const long ERROR_NO_SIGNAL_SENT = 205L;
//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
// The filename or extension is too long.
//
static const long ERROR_FILENAME_EXCED_RANGE = 206L;
//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
// The ring 2 stack is in use.
//
static const long ERROR_RING2_STACK_IN_USE = 207L;
//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
// The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.
//
static const long ERROR_META_EXPANSION_TOO_LONG = 208L;
//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
// The signal being posted is not correct.
//
static const long ERROR_INVALID_SIGNAL_NUMBER = 209L;
//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
// The signal handler cannot be set.
//
static const long ERROR_THREAD_1_INACTIVE = 210L;
//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
// The segment is locked and cannot be reallocated.
//
static const long ERROR_LOCKED = 212L;
//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
// Too many dynamic-link modules are attached to this program or dynamic-link module.
//
static const long ERROR_TOO_MANY_MODULES = 214L;
//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
// Cannot nest calls to LoadModule.
//
static const long ERROR_NESTING_NOT_ALLOWED = 215L;
//
// MessageId: ERROR_EXE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
// This version of %1 is not compatible with the version of Windows you're running. Check your computer's system information to see whether you need a x86 (32-bit) or x64 (64-bit) version of the program, and then contact the software publisher.
//
static const long ERROR_EXE_MACHINE_TYPE_MISMATCH = 216L;
//
// MessageId: ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY
//
// MessageText:
//
// The image file %1 is signed, unable to modify.
//
static const long ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = 217L;
//
// MessageId: ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY
//
// MessageText:
//
// The image file %1 is strong signed, unable to modify.
//
static const long ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 218L;
//
// MessageId: ERROR_FILE_CHECKED_OUT
//
// MessageText:
//
// This file is checked out or locked for editing by another user.
//
static const long ERROR_FILE_CHECKED_OUT = 220L;
//
// MessageId: ERROR_CHECKOUT_REQUIRED
//
// MessageText:
//
// The file must be checked out before saving changes.
//
static const long ERROR_CHECKOUT_REQUIRED = 221L;
//
// MessageId: ERROR_BAD_FILE_TYPE
//
// MessageText:
//
// The file type being saved or retrieved has been blocked.
//
static const long ERROR_BAD_FILE_TYPE = 222L;
//
// MessageId: ERROR_FILE_TOO_LARGE
//
// MessageText:
//
// The file size exceeds the limit allowed and cannot be saved.
//
static const long ERROR_FILE_TOO_LARGE = 223L;
//
// MessageId: ERROR_FORMS_AUTH_REQUIRED
//
// MessageText:
//
// Access Denied. Before opening files in this location, you must first add the web site to your trusted sites list, browse to the web site, and select the option to login automatically.
//
static const long ERROR_FORMS_AUTH_REQUIRED = 224L;
//
// MessageId: ERROR_VIRUS_INFECTED
//
// MessageText:
//
// Operation did not complete successfully because the file contains a virus.
//
static const long ERROR_VIRUS_INFECTED = 225L;
//
// MessageId: ERROR_VIRUS_DELETED
//
// MessageText:
//
// This file contains a virus and cannot be opened. Due to the nature of this virus, the file has been removed from this location.
//
static const long ERROR_VIRUS_DELETED = 226L;
//
// MessageId: ERROR_PIPE_LOCAL
//
// MessageText:
//
// The pipe is local.
//
static const long ERROR_PIPE_LOCAL = 229L;
//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
// The pipe state is invalid.
//
static const long ERROR_BAD_PIPE = 230L;
//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
// All pipe instances are busy.
//
static const long ERROR_PIPE_BUSY = 231L;
//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
// The pipe is being closed.
//
static const long ERROR_NO_DATA = 232L;
//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
// No process is on the other end of the pipe.
//
static const long ERROR_PIPE_NOT_CONNECTED = 233L;
//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
// More data is available.
//
static const long ERROR_MORE_DATA = 234L;
//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
// The session was canceled.
//
static const long ERROR_VC_DISCONNECTED = 240L;
//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
// The specified extended attribute name was invalid.
//
static const long ERROR_INVALID_EA_NAME = 254L;
//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
// The extended attributes are inconsistent.
//
static const long ERROR_EA_LIST_INCONSISTENT = 255L;
//
// MessageId: WAIT_TIMEOUT
//
// MessageText:
//
// The wait operation timed out.
//
static const long WAIT_TIMEOUT = 258L;
//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
// No more data is available.
//
static const long ERROR_NO_MORE_ITEMS = 259L;
//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
// The copy functions cannot be used.
//
static const long ERROR_CANNOT_COPY = 266L;
//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
// The directory name is invalid.
//
static const long ERROR_DIRECTORY = 267L;
//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
// The extended attributes did not fit in the buffer.
//
static const long ERROR_EAS_DIDNT_FIT = 275L;
//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
// The extended attribute file on the mounted file system is corrupt.
//
static const long ERROR_EA_FILE_CORRUPT = 276L;
//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
// The extended attribute table file is full.
//
static const long ERROR_EA_TABLE_FULL = 277L;
//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
// The specified extended attribute handle is invalid.
//
static const long ERROR_INVALID_EA_HANDLE = 278L;
//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
// The mounted file system does not support extended attributes.
//
static const long ERROR_EAS_NOT_SUPPORTED = 282L;
//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
// Attempt to release mutex not owned by caller.
//
static const long ERROR_NOT_OWNER = 288L;
//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
// Too many posts were made to a semaphore.
//
static const long ERROR_TOO_MANY_POSTS = 298L;
//
// MessageId: ERROR_PARTIAL_COPY
//
// MessageText:
//
// Only part of a ReadProcessMemory or WriteProcessMemory request was completed.
//
static const long ERROR_PARTIAL_COPY = 299L;
//
// MessageId: ERROR_OPLOCK_NOT_GRANTED
//
// MessageText:
//
// The oplock request is denied.
//
static const long ERROR_OPLOCK_NOT_GRANTED = 300L;
//
// MessageId: ERROR_INVALID_OPLOCK_PROTOCOL
//
// MessageText:
//
// An invalid oplock acknowledgment was received by the system.
//
static const long ERROR_INVALID_OPLOCK_PROTOCOL = 301L;
//
// MessageId: ERROR_DISK_TOO_FRAGMENTED
//
// MessageText:
//
// The volume is too fragmented to complete this operation.
//
static const long ERROR_DISK_TOO_FRAGMENTED = 302L;
//
// MessageId: ERROR_DELETE_PENDING
//
// MessageText:
//
// The file cannot be opened because it is in the process of being deleted.
//
static const long ERROR_DELETE_PENDING = 303L;
//
// MessageId: ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING
//
// MessageText:
//
// Short name settings may not be changed on this volume due to the global registry setting.
//
static const long ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 304L;
//
// MessageId: ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME
//
// MessageText:
//
// Short names are not enabled on this volume.
//
static const long ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 305L;
//
// MessageId: ERROR_SECURITY_STREAM_IS_INCONSISTENT
//
// MessageText:
//
// The security stream for the given volume is in an inconsistent state.
// Please run CHKDSK on the volume.
//
static const long ERROR_SECURITY_STREAM_IS_INCONSISTENT = 306L;
//
// MessageId: ERROR_INVALID_LOCK_RANGE
//
// MessageText:
//
// A requested file lock operation cannot be processed due to an invalid byte range.
//
static const long ERROR_INVALID_LOCK_RANGE = 307L;
//
// MessageId: ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT
//
// MessageText:
//
// The subsystem needed to support the image type is not present.
//
static const long ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 308L;
//
// MessageId: ERROR_NOTIFICATION_GUID_ALREADY_DEFINED
//
// MessageText:
//
// The specified file already has a notification GUID associated with it.
//
static const long ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = 309L;
//
// Available SYSTEM error code
//
//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
// The system cannot find message text for message number 0x%1 in the message file for %2.
//
static const long ERROR_MR_MID_NOT_FOUND = 317L;
//
// MessageId: ERROR_SCOPE_NOT_FOUND
//
// MessageText:
//
// The scope specified was not found.
//
static const long ERROR_SCOPE_NOT_FOUND = 318L;
//
// MessageId: ERROR_FAIL_NOACTION_REBOOT
//
// MessageText:
//
// No action was taken as a system reboot is required.
//
static const long ERROR_FAIL_NOACTION_REBOOT = 350L;
//
// MessageId: ERROR_FAIL_SHUTDOWN
//
// MessageText:
//
// The shutdown operation failed.
//
static const long ERROR_FAIL_SHUTDOWN = 351L;
//
// MessageId: ERROR_FAIL_RESTART
//
// MessageText:
//
// The restart operation failed.
//
static const long ERROR_FAIL_RESTART = 352L;
//
// MessageId: ERROR_MAX_SESSIONS_REACHED
//
// MessageText:
//
// The maximum number of sessions has been reached.
//
static const long ERROR_MAX_SESSIONS_REACHED = 353L;
//
// MessageId: ERROR_THREAD_MODE_ALREADY_BACKGROUND
//
// MessageText:
//
// The thread is already in background processing mode.
//
static const long ERROR_THREAD_MODE_ALREADY_BACKGROUND = 400L;
//
// MessageId: ERROR_THREAD_MODE_NOT_BACKGROUND
//
// MessageText:
//
// The thread is not in background processing mode.
//
static const long ERROR_THREAD_MODE_NOT_BACKGROUND = 401L;
//
// MessageId: ERROR_PROCESS_MODE_ALREADY_BACKGROUND
//
// MessageText:
//
// The process is already in background processing mode.
//
static const long ERROR_PROCESS_MODE_ALREADY_BACKGROUND = 402L;
//
// MessageId: ERROR_PROCESS_MODE_NOT_BACKGROUND
//
// MessageText:
//
// The process is not in background processing mode.
//
static const long ERROR_PROCESS_MODE_NOT_BACKGROUND = 403L;
//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
// Attempt to access invalid address.
//
static const long ERROR_INVALID_ADDRESS = 487L;
//
// MessageId: ERROR_USER_PROFILE_LOAD
//
// MessageText:
//
// User profile cannot be loaded.
//
static const long ERROR_USER_PROFILE_LOAD = 500L;
//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
// Arithmetic result exceeded 32 bits.
//
static const long ERROR_ARITHMETIC_OVERFLOW = 534L;
//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
// There is a process on other end of the pipe.
//
static const long ERROR_PIPE_CONNECTED = 535L;
//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
// Waiting for a process to open the other end of the pipe.
//
static const long ERROR_PIPE_LISTENING = 536L;
//
// MessageId: ERROR_VERIFIER_STOP
//
// MessageText:
//
// Application verifier has found an error in the current process.
//
static const long ERROR_VERIFIER_STOP = 537L;
//
// MessageId: ERROR_ABIOS_ERROR
//
// MessageText:
//
// An error occurred in the ABIOS subsystem.
//
static const long ERROR_ABIOS_ERROR = 538L;
//
// MessageId: ERROR_WX86_WARNING
//
// MessageText:
//
// A warning occurred in the WX86 subsystem.
//
static const long ERROR_WX86_WARNING = 539L;
//
// MessageId: ERROR_WX86_ERROR
//
// MessageText:
//
// An error occurred in the WX86 subsystem.
//
static const long ERROR_WX86_ERROR = 540L;
//
// MessageId: ERROR_TIMER_NOT_CANCELED
//
// MessageText:
//
// An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.
//
static const long ERROR_TIMER_NOT_CANCELED = 541L;
//
// MessageId: ERROR_UNWIND
//
// MessageText:
//
// Unwind exception code.
//
static const long ERROR_UNWIND = 542L;
//
// MessageId: ERROR_BAD_STACK
//
// MessageText:
//
// An invalid or unaligned stack was encountered during an unwind operation.
//
static const long ERROR_BAD_STACK = 543L;
//
// MessageId: ERROR_INVALID_UNWIND_TARGET
//
// MessageText:
//
// An invalid unwind target was encountered during an unwind operation.
//
static const long ERROR_INVALID_UNWIND_TARGET = 544L;
//
// MessageId: ERROR_INVALID_PORT_ATTRIBUTES
//
// MessageText:
//
// Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort
//
static const long ERROR_INVALID_PORT_ATTRIBUTES = 545L;
//
// MessageId: ERROR_PORT_MESSAGE_TOO_LONG
//
// MessageText:
//
// Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.
//
static const long ERROR_PORT_MESSAGE_TOO_LONG = 546L;
//
// MessageId: ERROR_INVALID_QUOTA_LOWER
//
// MessageText:
//
// An attempt was made to lower a quota limit below the current usage.
//
static const long ERROR_INVALID_QUOTA_LOWER = 547L;
//
// MessageId: ERROR_DEVICE_ALREADY_ATTACHED
//
// MessageText:
//
// An attempt was made to attach to a device that was already attached to another device.
//
static const long ERROR_DEVICE_ALREADY_ATTACHED = 548L;
//
// MessageId: ERROR_INSTRUCTION_MISALIGNMENT
//
// MessageText:
//
// An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.
//
static const long ERROR_INSTRUCTION_MISALIGNMENT = 549L;
//
// MessageId: ERROR_PROFILING_NOT_STARTED
//
// MessageText:
//
// Profiling not started.
//
static const long ERROR_PROFILING_NOT_STARTED = 550L;
//
// MessageId: ERROR_PROFILING_NOT_STOPPED
//
// MessageText:
//
// Profiling not stopped.
//
static const long ERROR_PROFILING_NOT_STOPPED = 551L;
//
// MessageId: ERROR_COULD_NOT_INTERPRET
//
// MessageText:
//
// The passed ACL did not contain the minimum required information.
//
static const long ERROR_COULD_NOT_INTERPRET = 552L;
//
// MessageId: ERROR_PROFILING_AT_LIMIT
//
// MessageText:
//
// The number of active profiling objects is at the maximum and no more may be started.
//
static const long ERROR_PROFILING_AT_LIMIT = 553L;
//
// MessageId: ERROR_CANT_WAIT
//
// MessageText:
//
// Used to indicate that an operation cannot continue without blocking for I/O.
//
static const long ERROR_CANT_WAIT = 554L;
//
// MessageId: ERROR_CANT_TERMINATE_SELF
//
// MessageText:
//
// Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NULL) and it was the last thread in the current process.
//
static const long ERROR_CANT_TERMINATE_SELF = 555L;
//
// MessageId: ERROR_UNEXPECTED_MM_CREATE_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//
static const long ERROR_UNEXPECTED_MM_CREATE_ERR = 556L;
//
// MessageId: ERROR_UNEXPECTED_MM_MAP_ERROR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//
static const long ERROR_UNEXPECTED_MM_MAP_ERROR = 557L;
//
// MessageId: ERROR_UNEXPECTED_MM_EXTEND_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//
static const long ERROR_UNEXPECTED_MM_EXTEND_ERR = 558L;
//
// MessageId: ERROR_BAD_FUNCTION_TABLE
//
// MessageText:
//
// A malformed function table was encountered during an unwind operation.
//
static const long ERROR_BAD_FUNCTION_TABLE = 559L;
//
// MessageId: ERROR_NO_GUID_TRANSLATION
//
// MessageText:
//
// Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system.
// This causes the protection attempt to fail, which may cause a file creation attempt to fail.
//
static const long ERROR_NO_GUID_TRANSLATION = 560L;
//
// MessageId: ERROR_INVALID_LDT_SIZE
//
// MessageText:
//
// Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.
//
static const long ERROR_INVALID_LDT_SIZE = 561L;
//
// MessageId: ERROR_INVALID_LDT_OFFSET
//
// MessageText:
//
// Indicates that the starting value for the LDT information was not an integral multiple of the selector size.
//
static const long ERROR_INVALID_LDT_OFFSET = 563L;
//
// MessageId: ERROR_INVALID_LDT_DESCRIPTOR
//
// MessageText:
//
// Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.
//
static const long ERROR_INVALID_LDT_DESCRIPTOR = 564L;
//
// MessageId: ERROR_TOO_MANY_THREADS
//
// MessageText:
//
// Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.
//
static const long ERROR_TOO_MANY_THREADS = 565L;
//
// MessageId: ERROR_THREAD_NOT_IN_PROCESS
//
// MessageText:
//
// An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.
//
static const long ERROR_THREAD_NOT_IN_PROCESS = 566L;
//
// MessageId: ERROR_PAGEFILE_QUOTA_EXCEEDED
//
// MessageText:
//
// Page file quota was exceeded.
//
static const long ERROR_PAGEFILE_QUOTA_EXCEEDED = 567L;
//
// MessageId: ERROR_LOGON_SERVER_CONFLICT
//
// MessageText:
//
// The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.
//
static const long ERROR_LOGON_SERVER_CONFLICT = 568L;
//
// MessageId: ERROR_SYNCHRONIZATION_REQUIRED
//
// MessageText:
//
// The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.
//
static const long ERROR_SYNCHRONIZATION_REQUIRED = 569L;
//
// MessageId: ERROR_NET_OPEN_FAILED
//
// MessageText:
//
// The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.
//
static const long ERROR_NET_OPEN_FAILED = 570L;
//
// MessageId: ERROR_IO_PRIVILEGE_FAILED
//
// MessageText:
//
// {Privilege Failed}
// The I/O permissions for the process could not be changed.
//
static const long ERROR_IO_PRIVILEGE_FAILED = 571L;
//
// MessageId: ERROR_CONTROL_C_EXIT
//
// MessageText:
//
// {Application Exit by CTRL+C}
// The application terminated as a result of a CTRL+C.
//
static const long ERROR_CONTROL_C_EXIT = 572L;
//
// MessageId: ERROR_MISSING_SYSTEMFILE
//
// MessageText:
//
// {Missing System File}
// The required system file %hs is bad or missing.
//
static const long ERROR_MISSING_SYSTEMFILE = 573L;
//
// MessageId: ERROR_UNHANDLED_EXCEPTION
//
// MessageText:
//
// {Application Error}
// The exception %s (0x%08lx) occurred in the application at location 0x%08lx.
//
static const long ERROR_UNHANDLED_EXCEPTION = 574L;
//
// MessageId: ERROR_APP_INIT_FAILURE
//
// MessageText:
//
// {Application Error}
// The application was unable to start correctly (0x%lx). Click OK to close the application.
//
static const long ERROR_APP_INIT_FAILURE = 575L;
//
// MessageId: ERROR_PAGEFILE_CREATE_FAILED
//
// MessageText:
//
// {Unable to Create Paging File}
// The creation of the paging file %hs failed (%lx). The requested size was %ld.
//
static const long ERROR_PAGEFILE_CREATE_FAILED = 576L;
//
// MessageId: ERROR_INVALID_IMAGE_HASH
//
// MessageText:
//
// Windows cannot verify the digital signature for this file. A recent hardware or software change might have installed a file that is signed incorrectly or damaged, or that might be malicious software from an unknown source.
//
static const long ERROR_INVALID_IMAGE_HASH = 577L;
//
// MessageId: ERROR_NO_PAGEFILE
//
// MessageText:
//
// {No Paging File Specified}
// No paging file was specified in the system configuration.
//
static const long ERROR_NO_PAGEFILE = 578L;
//
// MessageId: ERROR_ILLEGAL_FLOAT_CONTEXT
//
// MessageText:
//
// {EXCEPTION}
// A real-mode application issued a floating-point instruction and floating-point hardware is not present.
//
static const long ERROR_ILLEGAL_FLOAT_CONTEXT = 579L;
//
// MessageId: ERROR_NO_EVENT_PAIR
//
// MessageText:
//
// An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.
//
static const long ERROR_NO_EVENT_PAIR = 580L;
//
// MessageId: ERROR_DOMAIN_CTRLR_CONFIG_ERROR
//
// MessageText:
//
// A Windows Server has an incorrect configuration.
//
static const long ERROR_DOMAIN_CTRLR_CONFIG_ERROR = 581L;
//
// MessageId: ERROR_ILLEGAL_CHARACTER
//
// MessageText:
//
// An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.
//
static const long ERROR_ILLEGAL_CHARACTER = 582L;
//
// MessageId: ERROR_UNDEFINED_CHARACTER
//
// MessageText:
//
// The Unicode character is not defined in the Unicode character set installed on the system.
//
static const long ERROR_UNDEFINED_CHARACTER = 583L;
//
// MessageId: ERROR_FLOPPY_VOLUME
//
// MessageText:
//
// The paging file cannot be created on a floppy diskette.
//
static const long ERROR_FLOPPY_VOLUME = 584L;
//
// MessageId: ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT
//
// MessageText:
//
// The system BIOS failed to connect a system interrupt to the device or bus for which the device is connected.
//
static const long ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT = 585L;
//
// MessageId: ERROR_BACKUP_CONTROLLER
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//
static const long ERROR_BACKUP_CONTROLLER = 586L;
//
// MessageId: ERROR_MUTANT_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to acquire a mutant such that its maximum count would have been exceeded.
//
static const long ERROR_MUTANT_LIMIT_EXCEEDED = 587L;
//
// MessageId: ERROR_FS_DRIVER_REQUIRED
//
// MessageText:
//
// A volume has been accessed for which a file system driver is required that has not yet been loaded.
//
static const long ERROR_FS_DRIVER_REQUIRED = 588L;
//
// MessageId: ERROR_CANNOT_LOAD_REGISTRY_FILE
//
// MessageText:
//
// {Registry File Failure}
// The registry cannot load the hive (file):
// %hs
// or its log or alternate.
// It is corrupt, absent, or not writable.
//
static const long ERROR_CANNOT_LOAD_REGISTRY_FILE = 589L;
//
// MessageId: ERROR_DEBUG_ATTACH_FAILED
//
// MessageText:
//
// {Unexpected Failure in DebugActiveProcess}
// An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.
//
static const long ERROR_DEBUG_ATTACH_FAILED = 590L;
//
// MessageId: ERROR_SYSTEM_PROCESS_TERMINATED
//
// MessageText:
//
// {Fatal System Error}
// The %hs system process terminated unexpectedly with a status of 0x%08x (0x%08x 0x%08x).
// The system has been shut down.
//
static const long ERROR_SYSTEM_PROCESS_TERMINATED = 591L;
//
// MessageId: ERROR_DATA_NOT_ACCEPTED
//
// MessageText:
//
// {Data Not Accepted}
// The TDI client could not handle the data received during an indication.
//
static const long ERROR_DATA_NOT_ACCEPTED = 592L;
//
// MessageId: ERROR_VDM_HARD_ERROR
//
// MessageText:
//
// NTVDM encountered a hard error.
//
static const long ERROR_VDM_HARD_ERROR = 593L;
//
// MessageId: ERROR_DRIVER_CANCEL_TIMEOUT
//
// MessageText:
//
// {Cancel Timeout}
// The driver %hs failed to complete a cancelled I/O request in the allotted time.
//
static const long ERROR_DRIVER_CANCEL_TIMEOUT = 594L;
//
// MessageId: ERROR_REPLY_MESSAGE_MISMATCH
//
// MessageText:
//
// {Reply Message Mismatch}
// An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.
//
static const long ERROR_REPLY_MESSAGE_MISMATCH = 595L;
//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs. The data has been lost.
// This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
static const long ERROR_LOST_WRITEBEHIND_DATA = 596L;
//
// MessageId: ERROR_CLIENT_SERVER_PARAMETERS_INVALID
//
// MessageText:
//
// The parameter(s) passed to the server in the client/server shared memory window were invalid. Too much data may have been put in the shared memory window.
//
static const long ERROR_CLIENT_SERVER_PARAMETERS_INVALID = 597L;
//
// MessageId: ERROR_NOT_TINY_STREAM
//
// MessageText:
//
// The stream is not a tiny stream.
//
static const long ERROR_NOT_TINY_STREAM = 598L;
//
// MessageId: ERROR_STACK_OVERFLOW_READ
//
// MessageText:
//
// The request must be handled by the stack overflow code.
//
static const long ERROR_STACK_OVERFLOW_READ = 599L;
//
// MessageId: ERROR_CONVERT_TO_LARGE
//
// MessageText:
//
// Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing onode is moved or the extent stream is converted to a large stream.
//
static const long ERROR_CONVERT_TO_LARGE = 600L;
//
// MessageId: ERROR_FOUND_OUT_OF_SCOPE
//
// MessageText:
//
// The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.
//
static const long ERROR_FOUND_OUT_OF_SCOPE = 601L;
//
// MessageId: ERROR_ALLOCATE_BUCKET
//
// MessageText:
//
// The bucket array must be grown. Retry transaction after doing so.
//
static const long ERROR_ALLOCATE_BUCKET = 602L;
//
// MessageId: ERROR_MARSHALL_OVERFLOW
//
// MessageText:
//
// The user/kernel marshalling buffer has overflowed.
//
static const long ERROR_MARSHALL_OVERFLOW = 603L;
//
// MessageId: ERROR_INVALID_VARIANT
//
// MessageText:
//
// The supplied variant structure contains invalid data.
//
static const long ERROR_INVALID_VARIANT = 604L;
//
// MessageId: ERROR_BAD_COMPRESSION_BUFFER
//
// MessageText:
//
// The specified buffer contains ill-formed data.
//
static const long ERROR_BAD_COMPRESSION_BUFFER = 605L;
//
// MessageId: ERROR_AUDIT_FAILED
//
// MessageText:
//
// {Audit Failed}
// An attempt to generate a security audit failed.
//
static const long ERROR_AUDIT_FAILED = 606L;
//
// MessageId: ERROR_TIMER_RESOLUTION_NOT_SET
//
// MessageText:
//
// The timer resolution was not previously set by the current process.
//
static const long ERROR_TIMER_RESOLUTION_NOT_SET = 607L;
//
// MessageId: ERROR_INSUFFICIENT_LOGON_INFO
//
// MessageText:
//
// There is insufficient account information to log you on.
//
static const long ERROR_INSUFFICIENT_LOGON_INFO = 608L;
//
// MessageId: ERROR_BAD_DLL_ENTRYPOINT
//
// MessageText:
//
// {Invalid DLL Entrypoint}
// The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state.
// The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue execution. Selecting NO may cause the application to operate incorrectly.
//
static const long ERROR_BAD_DLL_ENTRYPOINT = 609L;
//
// MessageId: ERROR_BAD_SERVICE_ENTRYPOINT
//
// MessageText:
//
// {Invalid Service Callback Entrypoint}
// The %hs service is not written correctly. The stack pointer has been left in an inconsistent state.
// The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the service to continue operation. However, the service process may operate incorrectly.
//
static const long ERROR_BAD_SERVICE_ENTRYPOINT = 610L;
//
// MessageId: ERROR_IP_ADDRESS_CONFLICT1
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//
static const long ERROR_IP_ADDRESS_CONFLICT1 = 611L;
//
// MessageId: ERROR_IP_ADDRESS_CONFLICT2
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//
static const long ERROR_IP_ADDRESS_CONFLICT2 = 612L;
//
// MessageId: ERROR_REGISTRY_QUOTA_LIMIT
//
// MessageText:
//
// {Low On Registry Space}
// The system has reached the maximum size allowed for the system part of the registry. Additional storage requests will be ignored.
//
static const long ERROR_REGISTRY_QUOTA_LIMIT = 613L;
//
// MessageId: ERROR_NO_CALLBACK_ACTIVE
//
// MessageText:
//
// A callback return system service cannot be executed when no callback is active.
//
static const long ERROR_NO_CALLBACK_ACTIVE = 614L;
//
// MessageId: ERROR_PWD_TOO_SHORT
//
// MessageText:
//
// The password provided is too short to meet the policy of your user account.
// Please choose a longer password.
//
static const long ERROR_PWD_TOO_SHORT = 615L;
//
// MessageId: ERROR_PWD_TOO_RECENT
//
// MessageText:
//
// The policy of your user account does not allow you to change passwords too frequently.
// This is done to prevent users from changing back to a familiar, but potentially discovered, password.
// If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned.
//
static const long ERROR_PWD_TOO_RECENT = 616L;
//
// MessageId: ERROR_PWD_HISTORY_CONFLICT
//
// MessageText:
//
// You have attempted to change your password to one that you have used in the past.
// The policy of your user account does not allow this. Please select a password that you have not previously used.
//
static const long ERROR_PWD_HISTORY_CONFLICT = 617L;
//
// MessageId: ERROR_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
// The specified compression format is unsupported.
//
static const long ERROR_UNSUPPORTED_COMPRESSION = 618L;
//
// MessageId: ERROR_INVALID_HW_PROFILE
//
// MessageText:
//
// The specified hardware profile configuration is invalid.
//
static const long ERROR_INVALID_HW_PROFILE = 619L;
//
// MessageId: ERROR_INVALID_PLUGPLAY_DEVICE_PATH
//
// MessageText:
//
// The specified Plug and Play registry device path is invalid.
//
static const long ERROR_INVALID_PLUGPLAY_DEVICE_PATH = 620L;
//
// MessageId: ERROR_QUOTA_LIST_INCONSISTENT
//
// MessageText:
//
// The specified quota list is internally inconsistent with its descriptor.
//
static const long ERROR_QUOTA_LIST_INCONSISTENT = 621L;
//
// MessageId: ERROR_EVALUATION_EXPIRATION
//
// MessageText:
//
// {Windows Evaluation Notification}
// The evaluation period for this installation of Windows has expired. This system will shutdown in 1 hour. To restore access to this installation of Windows, please upgrade this installation using a licensed distribution of this product.
//
static const long ERROR_EVALUATION_EXPIRATION = 622L;
//
// MessageId: ERROR_ILLEGAL_DLL_RELOCATION
//
// MessageText:
//
// {Illegal System DLL Relocation}
// The system DLL %hs was relocated in memory. The application will not run properly.
// The relocation occurred because the DLL %hs occupied an address range reserved for Windows system DLLs. The vendor supplying the DLL should be contacted for a new DLL.
//
static const long ERROR_ILLEGAL_DLL_RELOCATION = 623L;
//
// MessageId: ERROR_DLL_INIT_FAILED_LOGOFF
//
// MessageText:
//
// {DLL Initialization Failed}
// The application failed to initialize because the window station is shutting down.
//
static const long ERROR_DLL_INIT_FAILED_LOGOFF = 624L;
//
// MessageId: ERROR_VALIDATE_CONTINUE
//
// MessageText:
//
// The validation process needs to continue on to the next step.
//
static const long ERROR_VALIDATE_CONTINUE = 625L;
//
// MessageId: ERROR_NO_MORE_MATCHES
//
// MessageText:
//
// There are no more matches for the current index enumeration.
//
static const long ERROR_NO_MORE_MATCHES = 626L;
//
// MessageId: ERROR_RANGE_LIST_CONFLICT
//
// MessageText:
//
// The range could not be added to the range list because of a conflict.
//
static const long ERROR_RANGE_LIST_CONFLICT = 627L;
//
// MessageId: ERROR_SERVER_SID_MISMATCH
//
// MessageText:
//
// The server process is running under a SID different than that required by client.
//
static const long ERROR_SERVER_SID_MISMATCH = 628L;
//
// MessageId: ERROR_CANT_ENABLE_DENY_ONLY
//
// MessageText:
//
// A group marked use for deny only cannot be enabled.
//
static const long ERROR_CANT_ENABLE_DENY_ONLY = 629L;
//
// MessageId: ERROR_FLOAT_MULTIPLE_FAULTS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point faults.
//
static const long ERROR_FLOAT_MULTIPLE_FAULTS = 630L;
//
// MessageId: ERROR_FLOAT_MULTIPLE_TRAPS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point traps.
//
static const long ERROR_FLOAT_MULTIPLE_TRAPS = 631L;
//
// MessageId: ERROR_NOINTERFACE
//
// MessageText:
//
// The requested interface is not supported.
//
static const long ERROR_NOINTERFACE = 632L;
//
// MessageId: ERROR_DRIVER_FAILED_SLEEP
//
// MessageText:
//
// {System Standby Failed}
// The driver %hs does not support standby mode. Updating this driver may allow the system to go to standby mode.
//
static const long ERROR_DRIVER_FAILED_SLEEP = 633L;
//
// MessageId: ERROR_CORRUPT_SYSTEM_FILE
//
// MessageText:
//
// The system file %1 has become corrupt and has been replaced.
//
static const long ERROR_CORRUPT_SYSTEM_FILE = 634L;
//
// MessageId: ERROR_COMMITMENT_MINIMUM
//
// MessageText:
//
// {Virtual Memory Minimum Too Low}
// Your system is low on virtual memory. Windows is increasing the size of your virtual memory paging file.
// During this process, memory requests for some applications may be denied. For more information, see Help.
//
static const long ERROR_COMMITMENT_MINIMUM = 635L;
//
// MessageId: ERROR_PNP_RESTART_ENUMERATION
//
// MessageText:
//
// A device was removed so enumeration must be restarted.
//
static const long ERROR_PNP_RESTART_ENUMERATION = 636L;
//
// MessageId: ERROR_SYSTEM_IMAGE_BAD_SIGNATURE
//
// MessageText:
//
// {Fatal System Error}
// The system image %s is not properly signed.
// The file has been replaced with the signed file.
// The system has been shut down.
//
static const long ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = 637L;
//
// MessageId: ERROR_PNP_REBOOT_REQUIRED
//
// MessageText:
//
// Device will not start without a reboot.
//
static const long ERROR_PNP_REBOOT_REQUIRED = 638L;
//
// MessageId: ERROR_INSUFFICIENT_POWER
//
// MessageText:
//
// There is not enough power to complete the requested operation.
//
static const long ERROR_INSUFFICIENT_POWER = 639L;
//
// MessageId: ERROR_MULTIPLE_FAULT_VIOLATION
//
// MessageText:
//
//  ERROR_MULTIPLE_FAULT_VIOLATION
//
static const long ERROR_MULTIPLE_FAULT_VIOLATION = 640L;
//
// MessageId: ERROR_SYSTEM_SHUTDOWN
//
// MessageText:
//
// The system is in the process of shutting down.
//
static const long ERROR_SYSTEM_SHUTDOWN = 641L;
//
// MessageId: ERROR_PORT_NOT_SET
//
// MessageText:
//
// An attempt to remove a processes DebugPort was made, but a port was not already associated with the process.
//
static const long ERROR_PORT_NOT_SET = 642L;
//
// MessageId: ERROR_DS_VERSION_CHECK_FAILURE
//
// MessageText:
//
// This version of Windows is not compatible with the behavior version of directory forest, domain or domain controller.
//
static const long ERROR_DS_VERSION_CHECK_FAILURE = 643L;
//
// MessageId: ERROR_RANGE_NOT_FOUND
//
// MessageText:
//
// The specified range could not be found in the range list.
//
static const long ERROR_RANGE_NOT_FOUND = 644L;
//
// MessageId: ERROR_NOT_SAFE_MODE_DRIVER
//
// MessageText:
//
// The driver was not loaded because the system is booting into safe mode.
//
static const long ERROR_NOT_SAFE_MODE_DRIVER = 646L;
//
// MessageId: ERROR_FAILED_DRIVER_ENTRY
//
// MessageText:
//
// The driver was not loaded because it failed it's initialization call.
//
static const long ERROR_FAILED_DRIVER_ENTRY = 647L;
//
// MessageId: ERROR_DEVICE_ENUMERATION_ERROR
//
// MessageText:
//
// The "%hs" encountered an error while applying power or reading the device configuration.
// This may be caused by a failure of your hardware or by a poor connection.
//
static const long ERROR_DEVICE_ENUMERATION_ERROR = 648L;
//
// MessageId: ERROR_MOUNT_POINT_NOT_RESOLVED
//
// MessageText:
//
// The create operation failed because the name contained at least one mount point which resolves to a volume to which the specified device object is not attached.
//
static const long ERROR_MOUNT_POINT_NOT_RESOLVED = 649L;
//
// MessageId: ERROR_INVALID_DEVICE_OBJECT_PARAMETER
//
// MessageText:
//
// The device object parameter is either not a valid device object or is not attached to the volume specified by the file name.
//
static const long ERROR_INVALID_DEVICE_OBJECT_PARAMETER = 650L;
//
// MessageId: ERROR_MCA_OCCURED
//
// MessageText:
//
// A Machine Check Error has occurred. Please check the system eventlog for additional information.
//
static const long ERROR_MCA_OCCURED = 651L;
//
// MessageId: ERROR_DRIVER_DATABASE_ERROR
//
// MessageText:
//
// There was error [%2] processing the driver database.
//
static const long ERROR_DRIVER_DATABASE_ERROR = 652L;
//
// MessageId: ERROR_SYSTEM_HIVE_TOO_LARGE
//
// MessageText:
//
// System hive size has exceeded its limit.
//
static const long ERROR_SYSTEM_HIVE_TOO_LARGE = 653L;
//
// MessageId: ERROR_DRIVER_FAILED_PRIOR_UNLOAD
//
// MessageText:
//
// The driver could not be loaded because a previous version of the driver is still in memory.
//
static const long ERROR_DRIVER_FAILED_PRIOR_UNLOAD = 654L;
//
// MessageId: ERROR_VOLSNAP_PREPARE_HIBERNATE
//
// MessageText:
//
// {Volume Shadow Copy Service}
// Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.
//
static const long ERROR_VOLSNAP_PREPARE_HIBERNATE = 655L;
//
// MessageId: ERROR_HIBERNATION_FAILURE
//
// MessageText:
//
// The system has failed to hibernate (The error code is %hs). Hibernation will be disabled until the system is restarted.
//
static const long ERROR_HIBERNATION_FAILURE = 656L;
//
// MessageId: ERROR_FILE_SYSTEM_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a file system limitation
//
static const long ERROR_FILE_SYSTEM_LIMITATION = 665L;
//
// MessageId: ERROR_ASSERTION_FAILURE
//
// MessageText:
//
// An assertion failure has occurred.
//
static const long ERROR_ASSERTION_FAILURE = 668L;
//
// MessageId: ERROR_ACPI_ERROR
//
// MessageText:
//
// An error occurred in the ACPI subsystem.
//
static const long ERROR_ACPI_ERROR = 669L;
//
// MessageId: ERROR_WOW_ASSERTION
//
// MessageText:
//
// WOW Assertion Error.
//
static const long ERROR_WOW_ASSERTION = 670L;
//
// MessageId: ERROR_PNP_BAD_MPS_TABLE
//
// MessageText:
//
// A device is missing in the system BIOS MPS table. This device will not be used.
// Please contact your system vendor for system BIOS update.
//
static const long ERROR_PNP_BAD_MPS_TABLE = 671L;
//
// MessageId: ERROR_PNP_TRANSLATION_FAILED
//
// MessageText:
//
// A translator failed to translate resources.
//
static const long ERROR_PNP_TRANSLATION_FAILED = 672L;
//
// MessageId: ERROR_PNP_IRQ_TRANSLATION_FAILED
//
// MessageText:
//
// A IRQ translator failed to translate resources.
//
static const long ERROR_PNP_IRQ_TRANSLATION_FAILED = 673L;
//
// MessageId: ERROR_PNP_INVALID_ID
//
// MessageText:
//
// Driver %2 returned invalid ID for a child device (%3).
//
static const long ERROR_PNP_INVALID_ID = 674L;
//
// MessageId: ERROR_WAKE_SYSTEM_DEBUGGER
//
// MessageText:
//
// {Kernel Debugger Awakened}
// the system debugger was awakened by an interrupt.
//
static const long ERROR_WAKE_SYSTEM_DEBUGGER = 675L;
//
// MessageId: ERROR_HANDLES_CLOSED
//
// MessageText:
//
// {Handles Closed}
// Handles to objects have been automatically closed as a result of the requested operation.
//
static const long ERROR_HANDLES_CLOSED = 676L;
//
// MessageId: ERROR_EXTRANEOUS_INFORMATION
//
// MessageText:
//
// {Too Much Information}
// The specified access control list (ACL) contained more information than was expected.
//
static const long ERROR_EXTRANEOUS_INFORMATION = 677L;
//
// MessageId: ERROR_RXACT_COMMIT_NECESSARY
//
// MessageText:
//
// This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
// The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired).
//
static const long ERROR_RXACT_COMMIT_NECESSARY = 678L;
//
// MessageId: ERROR_MEDIA_CHECK
//
// MessageText:
//
// {Media Changed}
// The media may have changed.
//
static const long ERROR_MEDIA_CHECK = 679L;
//
// MessageId: ERROR_GUID_SUBSTITUTION_MADE
//
// MessageText:
//
// {GUID Substitution}
// During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found.
// A substitute prefix was used, which will not compromise system security. However, this may provide a more restrictive access than intended.
//
static const long ERROR_GUID_SUBSTITUTION_MADE = 680L;
//
// MessageId: ERROR_STOPPED_ON_SYMLINK
//
// MessageText:
//
// The create operation stopped after reaching a symbolic link
//
static const long ERROR_STOPPED_ON_SYMLINK = 681L;
//
// MessageId: ERROR_LONGJUMP
//
// MessageText:
//
// A long jump has been executed.
//
static const long ERROR_LONGJUMP = 682L;
//
// MessageId: ERROR_PLUGPLAY_QUERY_VETOED
//
// MessageText:
//
// The Plug and Play query operation was not successful.
//
static const long ERROR_PLUGPLAY_QUERY_VETOED = 683L;
//
// MessageId: ERROR_UNWIND_CONSOLIDATE
//
// MessageText:
//
// A frame consolidation has been executed.
//
static const long ERROR_UNWIND_CONSOLIDATE = 684L;
//
// MessageId: ERROR_REGISTRY_HIVE_RECOVERED
//
// MessageText:
//
// {Registry Hive Recovered}
// Registry hive (file):
// %hs
// was corrupted and it has been recovered. Some data might have been lost.
//
static const long ERROR_REGISTRY_HIVE_RECOVERED = 685L;
//
// MessageId: ERROR_DLL_MIGHT_BE_INSECURE
//
// MessageText:
//
// The application is attempting to run executable code from the module %hs. This may be insecure. An alternative, %hs, is available. Should the application use the secure module %hs?
//
static const long ERROR_DLL_MIGHT_BE_INSECURE = 686L;
//
// MessageId: ERROR_DLL_MIGHT_BE_INCOMPATIBLE
//
// MessageText:
//
// The application is loading executable code from the module %hs. This is secure, but may be incompatible with previous releases of the operating system. An alternative, %hs, is available. Should the application use the secure module %hs?
//
static const long ERROR_DLL_MIGHT_BE_INCOMPATIBLE = 687L;
//
// MessageId: ERROR_DBG_EXCEPTION_NOT_HANDLED
//
// MessageText:
//
// Debugger did not handle the exception.
//
static const long ERROR_DBG_EXCEPTION_NOT_HANDLED = 688L;
//
// MessageId: ERROR_DBG_REPLY_LATER
//
// MessageText:
//
// Debugger will reply later.
//
static const long ERROR_DBG_REPLY_LATER = 689L;
//
// MessageId: ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE
//
// MessageText:
//
// Debugger cannot provide handle.
//
static const long ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = 690L;
//
// MessageId: ERROR_DBG_TERMINATE_THREAD
//
// MessageText:
//
// Debugger terminated thread.
//
static const long ERROR_DBG_TERMINATE_THREAD = 691L;
//
// MessageId: ERROR_DBG_TERMINATE_PROCESS
//
// MessageText:
//
// Debugger terminated process.
//
static const long ERROR_DBG_TERMINATE_PROCESS = 692L;
//
// MessageId: ERROR_DBG_CONTROL_C
//
// MessageText:
//
// Debugger got control C.
//
static const long ERROR_DBG_CONTROL_C = 693L;
//
// MessageId: ERROR_DBG_PRINTEXCEPTION_C
//
// MessageText:
//
// Debugger printed exception on control C.
//
static const long ERROR_DBG_PRINTEXCEPTION_C = 694L;
//
// MessageId: ERROR_DBG_RIPEXCEPTION
//
// MessageText:
//
// Debugger received RIP exception.
//
static const long ERROR_DBG_RIPEXCEPTION = 695L;
//
// MessageId: ERROR_DBG_CONTROL_BREAK
//
// MessageText:
//
// Debugger received control break.
//
static const long ERROR_DBG_CONTROL_BREAK = 696L;
//
// MessageId: ERROR_DBG_COMMAND_EXCEPTION
//
// MessageText:
//
// Debugger command communication exception.
//
static const long ERROR_DBG_COMMAND_EXCEPTION = 697L;
//
// MessageId: ERROR_OBJECT_NAME_EXISTS
//
// MessageText:
//
// {Object Exists}
// An attempt was made to create an object and the object name already existed.
//
static const long ERROR_OBJECT_NAME_EXISTS = 698L;
//
// MessageId: ERROR_THREAD_WAS_SUSPENDED
//
// MessageText:
//
// {Thread Suspended}
// A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.
//
static const long ERROR_THREAD_WAS_SUSPENDED = 699L;
//
// MessageId: ERROR_IMAGE_NOT_AT_BASE
//
// MessageText:
//
// {Image Relocated}
// An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.
//
static const long ERROR_IMAGE_NOT_AT_BASE = 700L;
//
// MessageId: ERROR_RXACT_STATE_CREATED
//
// MessageText:
//
// This informational level status indicates that a specified registry sub-tree transaction state did not yet exist and had to be created.
//
static const long ERROR_RXACT_STATE_CREATED = 701L;
//
// MessageId: ERROR_SEGMENT_NOTIFICATION
//
// MessageText:
//
// {Segment Load}
// A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS or Win16 program segment image.
// An exception is raised so a debugger can load, unload or track symbols and breakpoints within these 16-bit segments.
//
static const long ERROR_SEGMENT_NOTIFICATION = 702L;
//
// MessageId: ERROR_BAD_CURRENT_DIRECTORY
//
// MessageText:
//
// {Invalid Current Directory}
// The process cannot switch to the startup current directory %hs.
// Select OK to set current directory to %hs, or select CANCEL to exit.
//
static const long ERROR_BAD_CURRENT_DIRECTORY = 703L;
//
// MessageId: ERROR_FT_READ_RECOVERY_FROM_BACKUP
//
// MessageText:
//
// {Redundant Read}
// To satisfy a read request, the NT fault-tolerant file system successfully read the requested data from a redundant copy.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was unable to reassign the failing area of the device.
//
static const long ERROR_FT_READ_RECOVERY_FROM_BACKUP = 704L;
//
// MessageId: ERROR_FT_WRITE_RECOVERY
//
// MessageText:
//
// {Redundant Write}
// To satisfy a write request, the NT fault-tolerant file system successfully wrote a redundant copy of the information.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was not able to reassign the failing area of the device.
//
static const long ERROR_FT_WRITE_RECOVERY = 705L;
//
// MessageId: ERROR_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//
static const long ERROR_IMAGE_MACHINE_TYPE_MISMATCH = 706L;
//
// MessageId: ERROR_RECEIVE_PARTIAL
//
// MessageText:
//
// {Partial Data Received}
// The network transport returned partial data to its client. The remaining data will be sent later.
//
static const long ERROR_RECEIVE_PARTIAL = 707L;
//
// MessageId: ERROR_RECEIVE_EXPEDITED
//
// MessageText:
//
// {Expedited Data Received}
// The network transport returned data to its client that was marked as expedited by the remote system.
//
static const long ERROR_RECEIVE_EXPEDITED = 708L;
//
// MessageId: ERROR_RECEIVE_PARTIAL_EXPEDITED
//
// MessageText:
//
// {Partial Expedited Data Received}
// The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.
//
static const long ERROR_RECEIVE_PARTIAL_EXPEDITED = 709L;
//
// MessageId: ERROR_EVENT_DONE
//
// MessageText:
//
// {TDI Event Done}
// The TDI indication has completed successfully.
//
static const long ERROR_EVENT_DONE = 710L;
//
// MessageId: ERROR_EVENT_PENDING
//
// MessageText:
//
// {TDI Event Pending}
// The TDI indication has entered the pending state.
//
static const long ERROR_EVENT_PENDING = 711L;
//
// MessageId: ERROR_CHECKING_FILE_SYSTEM
//
// MessageText:
//
// Checking file system on %wZ
//
static const long ERROR_CHECKING_FILE_SYSTEM = 712L;
//
// MessageId: ERROR_FATAL_APP_EXIT
//
// MessageText:
//
// {Fatal Application Exit}
// %hs
//
static const long ERROR_FATAL_APP_EXIT = 713L;
//
// MessageId: ERROR_PREDEFINED_HANDLE
//
// MessageText:
//
// The specified registry key is referenced by a predefined handle.
//
static const long ERROR_PREDEFINED_HANDLE = 714L;
//
// MessageId: ERROR_WAS_UNLOCKED
//
// MessageText:
//
// {Page Unlocked}
// The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.
//
static const long ERROR_WAS_UNLOCKED = 715L;
//
// MessageId: ERROR_SERVICE_NOTIFICATION
//
// MessageText:
//
// %hs
//
static const long ERROR_SERVICE_NOTIFICATION = 716L;
//
// MessageId: ERROR_WAS_LOCKED
//
// MessageText:
//
// {Page Locked}
// One of the pages to lock was already locked.
//
static const long ERROR_WAS_LOCKED = 717L;
//
// MessageId: ERROR_LOG_HARD_ERROR
//
// MessageText:
//
// Application popup: %1 : %2
//
static const long ERROR_LOG_HARD_ERROR = 718L;
//
// MessageId: ERROR_ALREADY_WIN32
//
// MessageText:
//
//  ERROR_ALREADY_WIN32
//
static const long ERROR_ALREADY_WIN32 = 719L;
//
// MessageId: ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine.
//
static const long ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 720L;
//
// MessageId: ERROR_NO_YIELD_PERFORMED
//
// MessageText:
//
// A yield execution was performed and no thread was available to run.
//
static const long ERROR_NO_YIELD_PERFORMED = 721L;
//
// MessageId: ERROR_TIMER_RESUME_IGNORED
//
// MessageText:
//
// The resumable flag to a timer API was ignored.
//
static const long ERROR_TIMER_RESUME_IGNORED = 722L;
//
// MessageId: ERROR_ARBITRATION_UNHANDLED
//
// MessageText:
//
// The arbiter has deferred arbitration of these resources to its parent
//
static const long ERROR_ARBITRATION_UNHANDLED = 723L;
//
// MessageId: ERROR_CARDBUS_NOT_SUPPORTED
//
// MessageText:
//
// The inserted CardBus device cannot be started because of a configuration error on "%hs".
//
static const long ERROR_CARDBUS_NOT_SUPPORTED = 724L;
//
// MessageId: ERROR_MP_PROCESSOR_MISMATCH
//
// MessageText:
//
// The CPUs in this multiprocessor system are not all the same revision level. To use all processors the operating system restricts itself to the features of the least capable processor in the system. Should problems occur with this system, contact the CPU manufacturer to see if this mix of processors is supported.
//
static const long ERROR_MP_PROCESSOR_MISMATCH = 725L;
//
// MessageId: ERROR_HIBERNATED
//
// MessageText:
//
// The system was put into hibernation.
//
static const long ERROR_HIBERNATED = 726L;
//
// MessageId: ERROR_RESUME_HIBERNATION
//
// MessageText:
//
// The system was resumed from hibernation.
//
static const long ERROR_RESUME_HIBERNATION = 727L;
//
// MessageId: ERROR_FIRMWARE_UPDATED
//
// MessageText:
//
// Windows has detected that the system firmware (BIOS) was updated [previous firmware date = %2, current firmware date %3].
//
static const long ERROR_FIRMWARE_UPDATED = 728L;
//
// MessageId: ERROR_DRIVERS_LEAKING_LOCKED_PAGES
//
// MessageText:
//
// A device driver is leaking locked I/O pages causing system degradation. The system has automatically enabled tracking code in order to try and catch the culprit.
//
static const long ERROR_DRIVERS_LEAKING_LOCKED_PAGES = 729L;
//
// MessageId: ERROR_WAKE_SYSTEM
//
// MessageText:
//
// The system has awoken
//
static const long ERROR_WAKE_SYSTEM = 730L;
//
// MessageId: ERROR_WAIT_1
//
// MessageText:
//
//  ERROR_WAIT_1
//
static const long ERROR_WAIT_1 = 731L;
//
// MessageId: ERROR_WAIT_2
//
// MessageText:
//
//  ERROR_WAIT_2
//
static const long ERROR_WAIT_2 = 732L;
//
// MessageId: ERROR_WAIT_3
//
// MessageText:
//
//  ERROR_WAIT_3
//
static const long ERROR_WAIT_3 = 733L;
//
// MessageId: ERROR_WAIT_63
//
// MessageText:
//
//  ERROR_WAIT_63
//
static const long ERROR_WAIT_63 = 734L;
//
// MessageId: ERROR_ABANDONED_WAIT_0
//
// MessageText:
//
//  ERROR_ABANDONED_WAIT_0
//
static const long ERROR_ABANDONED_WAIT_0 = 735L;
//
// MessageId: ERROR_ABANDONED_WAIT_63
//
// MessageText:
//
//  ERROR_ABANDONED_WAIT_63
//
static const long ERROR_ABANDONED_WAIT_63 = 736L;
//
// MessageId: ERROR_USER_APC
//
// MessageText:
//
//  ERROR_USER_APC
//
static const long ERROR_USER_APC = 737L;
//
// MessageId: ERROR_KERNEL_APC
//
// MessageText:
//
//  ERROR_KERNEL_APC
//
static const long ERROR_KERNEL_APC = 738L;
//
// MessageId: ERROR_ALERTED
//
// MessageText:
//
//  ERROR_ALERTED
//
static const long ERROR_ALERTED = 739L;
//
// MessageId: ERROR_ELEVATION_REQUIRED
//
// MessageText:
//
// The requested operation requires elevation.
//
static const long ERROR_ELEVATION_REQUIRED = 740L;
//
// MessageId: ERROR_REPARSE
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
static const long ERROR_REPARSE = 741L;
//
// MessageId: ERROR_OPLOCK_BREAK_IN_PROGRESS
//
// MessageText:
//
// An open/create operation completed while an oplock break is underway.
//
static const long ERROR_OPLOCK_BREAK_IN_PROGRESS = 742L;
//
// MessageId: ERROR_VOLUME_MOUNTED
//
// MessageText:
//
// A new volume has been mounted by a file system.
//
static const long ERROR_VOLUME_MOUNTED = 743L;
//
// MessageId: ERROR_RXACT_COMMITTED
//
// MessageText:
//
// This success level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
// The commit has now been completed.
//
static const long ERROR_RXACT_COMMITTED = 744L;
//
// MessageId: ERROR_NOTIFY_CLEANUP
//
// MessageText:
//
// This indicates that a notify change request has been completed due to closing the handle which made the notify change request.
//
static const long ERROR_NOTIFY_CLEANUP = 745L;
//
// MessageId: ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
// {Connect Failure on Primary Transport}
// An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed.
// The computer WAS able to connect on a secondary transport.
//
static const long ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = 746L;
//
// MessageId: ERROR_PAGE_FAULT_TRANSITION
//
// MessageText:
//
// Page fault was a transition fault.
//
static const long ERROR_PAGE_FAULT_TRANSITION = 747L;
//
// MessageId: ERROR_PAGE_FAULT_DEMAND_ZERO
//
// MessageText:
//
// Page fault was a demand zero fault.
//
static const long ERROR_PAGE_FAULT_DEMAND_ZERO = 748L;
//
// MessageId: ERROR_PAGE_FAULT_COPY_ON_WRITE
//
// MessageText:
//
// Page fault was a demand zero fault.
//
static const long ERROR_PAGE_FAULT_COPY_ON_WRITE = 749L;
//
// MessageId: ERROR_PAGE_FAULT_GUARD_PAGE
//
// MessageText:
//
// Page fault was a demand zero fault.
//
static const long ERROR_PAGE_FAULT_GUARD_PAGE = 750L;
//
// MessageId: ERROR_PAGE_FAULT_PAGING_FILE
//
// MessageText:
//
// Page fault was satisfied by reading from a secondary storage device.
//
static const long ERROR_PAGE_FAULT_PAGING_FILE = 751L;
//
// MessageId: ERROR_CACHE_PAGE_LOCKED
//
// MessageText:
//
// Cached page was locked during operation.
//
static const long ERROR_CACHE_PAGE_LOCKED = 752L;
//
// MessageId: ERROR_CRASH_DUMP
//
// MessageText:
//
// Crash dump exists in paging file.
//
static const long ERROR_CRASH_DUMP = 753L;
//
// MessageId: ERROR_BUFFER_ALL_ZEROS
//
// MessageText:
//
// Specified buffer contains all zeros.
//
static const long ERROR_BUFFER_ALL_ZEROS = 754L;
//
// MessageId: ERROR_REPARSE_OBJECT
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
static const long ERROR_REPARSE_OBJECT = 755L;
//
// MessageId: ERROR_RESOURCE_REQUIREMENTS_CHANGED
//
// MessageText:
//
// The device has succeeded a query-stop and its resource requirements have changed.
//
static const long ERROR_RESOURCE_REQUIREMENTS_CHANGED = 756L;
//
// MessageId: ERROR_TRANSLATION_COMPLETE
//
// MessageText:
//
// The translator has translated these resources into the global space and no further translations should be performed.
//
static const long ERROR_TRANSLATION_COMPLETE = 757L;
//
// MessageId: ERROR_NOTHING_TO_TERMINATE
//
// MessageText:
//
// A process being terminated has no threads to terminate.
//
static const long ERROR_NOTHING_TO_TERMINATE = 758L;
//
// MessageId: ERROR_PROCESS_NOT_IN_JOB
//
// MessageText:
//
// The specified process is not part of a job.
//
static const long ERROR_PROCESS_NOT_IN_JOB = 759L;
//
// MessageId: ERROR_PROCESS_IN_JOB
//
// MessageText:
//
// The specified process is part of a job.
//
static const long ERROR_PROCESS_IN_JOB = 760L;
//
// MessageId: ERROR_VOLSNAP_HIBERNATE_READY
//
// MessageText:
//
// {Volume Shadow Copy Service}
// The system is now ready for hibernation.
//
static const long ERROR_VOLSNAP_HIBERNATE_READY = 761L;
//
// MessageId: ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY
//
// MessageText:
//
// A file system or file system filter driver has successfully completed an FsFilter operation.
//
static const long ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 762L;
//
// MessageId: ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED
//
// MessageText:
//
// The specified interrupt vector was already connected.
//
static const long ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED = 763L;
//
// MessageId: ERROR_INTERRUPT_STILL_CONNECTED
//
// MessageText:
//
// The specified interrupt vector is still connected.
//
static const long ERROR_INTERRUPT_STILL_CONNECTED = 764L;
//
// MessageId: ERROR_WAIT_FOR_OPLOCK
//
// MessageText:
//
// An operation is blocked waiting for an oplock.
//
static const long ERROR_WAIT_FOR_OPLOCK = 765L;
//
// MessageId: ERROR_DBG_EXCEPTION_HANDLED
//
// MessageText:
//
// Debugger handled exception
//
static const long ERROR_DBG_EXCEPTION_HANDLED = 766L;
//
// MessageId: ERROR_DBG_CONTINUE
//
// MessageText:
//
// Debugger continued
//
static const long ERROR_DBG_CONTINUE = 767L;
//
// MessageId: ERROR_CALLBACK_POP_STACK
//
// MessageText:
//
// An exception occurred in a user mode callback and the kernel callback frame should be removed.
//
static const long ERROR_CALLBACK_POP_STACK = 768L;
//
// MessageId: ERROR_COMPRESSION_DISABLED
//
// MessageText:
//
// Compression is disabled for this volume.
//
static const long ERROR_COMPRESSION_DISABLED = 769L;
//
// MessageId: ERROR_CANTFETCHBACKWARDS
//
// MessageText:
//
// The data provider cannot fetch backwards through a result set.
//
static const long ERROR_CANTFETCHBACKWARDS = 770L;
//
// MessageId: ERROR_CANTSCROLLBACKWARDS
//
// MessageText:
//
// The data provider cannot scroll backwards through a result set.
//
static const long ERROR_CANTSCROLLBACKWARDS = 771L;
//
// MessageId: ERROR_ROWSNOTRELEASED
//
// MessageText:
//
// The data provider requires that previously fetched data is released before asking for more data.
//
static const long ERROR_ROWSNOTRELEASED = 772L;
//
// MessageId: ERROR_BAD_ACCESSOR_FLAGS
//
// MessageText:
//
// The data provider was not able to interpret the flags set for a column binding in an accessor.
//
static const long ERROR_BAD_ACCESSOR_FLAGS = 773L;
//
// MessageId: ERROR_ERRORS_ENCOUNTERED
//
// MessageText:
//
// One or more errors occurred while processing the request.
//
static const long ERROR_ERRORS_ENCOUNTERED = 774L;
//
// MessageId: ERROR_NOT_CAPABLE
//
// MessageText:
//
// The implementation is not capable of performing the request.
//
static const long ERROR_NOT_CAPABLE = 775L;
//
// MessageId: ERROR_REQUEST_OUT_OF_SEQUENCE
//
// MessageText:
//
// The client of a component requested an operation which is not valid given the state of the component instance.
//
static const long ERROR_REQUEST_OUT_OF_SEQUENCE = 776L;
//
// MessageId: ERROR_VERSION_PARSE_ERROR
//
// MessageText:
//
// A version number could not be parsed.
//
static const long ERROR_VERSION_PARSE_ERROR = 777L;
//
// MessageId: ERROR_BADSTARTPOSITION
//
// MessageText:
//
// The iterator's start position is invalid.
//
static const long ERROR_BADSTARTPOSITION = 778L;
//
// MessageId: ERROR_MEMORY_HARDWARE
//
// MessageText:
//
// The hardware has reported an uncorrectable memory error.
//
static const long ERROR_MEMORY_HARDWARE = 779L;
//
// MessageId: ERROR_DISK_REPAIR_DISABLED
//
// MessageText:
//
// The attempted operation required self healing to be enabled.
//
static const long ERROR_DISK_REPAIR_DISABLED = 780L;
//
// MessageId: ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE
//
// MessageText:
//
// The Desktop heap encountered an error while allocating session memory. There is more information in the system event log.
//
static const long ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 781L;
//
// MessageId: ERROR_SYSTEM_POWERSTATE_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3.
//
static const long ERROR_SYSTEM_POWERSTATE_TRANSITION = 782L;
//
// MessageId: ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3 but could enter %4.
//
static const long ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 783L;
//
// MessageId: ERROR_MCA_EXCEPTION
//
// MessageText:
//
// A thread is getting dispatched with MCA EXCEPTION because of MCA.
//
static const long ERROR_MCA_EXCEPTION = 784L;
//
// MessageId: ERROR_ACCESS_AUDIT_BY_POLICY
//
// MessageText:
//
// Access to %1 is monitored by policy rule %2.
//
static const long ERROR_ACCESS_AUDIT_BY_POLICY = 785L;
//
// MessageId: ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by policy rule %2.
//
static const long ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 786L;
//
// MessageId: ERROR_ABANDON_HIBERFILE
//
// MessageText:
//
// A valid hibernation file has been invalidated and should be abandoned.
//
static const long ERROR_ABANDON_HIBERFILE = 787L;
//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error may be caused by network connectivity issues. Please try to save this file elsewhere.
//
static const long ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 788L;
//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error was returned by the server on which the file exists. Please try to save this file elsewhere.
//
static const long ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 789L;
//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error may be caused if the device has been removed or the media is write-protected.
//
static const long ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 790L;
//
// MessageId: ERROR_BAD_MCFG_TABLE
//
// MessageText:
//
// The resources required for this device conflict with the MCFG table.
//
static const long ERROR_BAD_MCFG_TABLE = 791L;
//
// MessageId: ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE
//
// MessageText:
//
// The oplock that was associated with this handle is now associated with a different handle.
//
static const long ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = 800L;
//
// MessageId: ERROR_CANNOT_GRANT_REQUESTED_OPLOCK
//
// MessageText:
//
// An oplock of the requested level cannot be granted.  An oplock of a lower level may be available.
//
static const long ERROR_CANNOT_GRANT_REQUESTED_OPLOCK = 801L;
//
// MessageId: ERROR_CANNOT_BREAK_OPLOCK
//
// MessageText:
//
// The operation did not complete successfully because it would cause an oplock to be broken. The caller has requested that existing oplocks not be broken.
//
static const long ERROR_CANNOT_BREAK_OPLOCK = 802L;
//
// MessageId: ERROR_OPLOCK_HANDLE_CLOSED
//
// MessageText:
//
// The handle with which this oplock was associated has been closed.  The oplock is now broken.
//
static const long ERROR_OPLOCK_HANDLE_CLOSED = 803L;
//
// MessageId: ERROR_NO_ACE_CONDITION
//
// MessageText:
//
// The specified access control entry (ACE) does not contain a condition.
//
static const long ERROR_NO_ACE_CONDITION = 804L;
//
// MessageId: ERROR_INVALID_ACE_CONDITION
//
// MessageText:
//
// The specified access control entry (ACE) contains an invalid condition.
//
static const long ERROR_INVALID_ACE_CONDITION = 805L;
//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
// Access to the extended attribute was denied.
//
static const long ERROR_EA_ACCESS_DENIED = 994L;
//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
// The I/O operation has been aborted because of either a thread exit or an application request.
//
static const long ERROR_OPERATION_ABORTED = 995L;
//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
// Overlapped I/O event is not in a signaled state.
//
static const long ERROR_IO_INCOMPLETE = 996L;
//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
// Overlapped I/O operation is in progress.
//
static const long ERROR_IO_PENDING = 997L;
//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
// Invalid access to memory location.
//
static const long ERROR_NOACCESS = 998L;
//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
// Error performing inpage operation.
//
static const long ERROR_SWAPERROR = 999L;
//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
// Recursion too deep; the stack overflowed.
//
static const long ERROR_STACK_OVERFLOW = 1001L;
//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
// The window cannot act on the sent message.
//
static const long ERROR_INVALID_MESSAGE = 1002L;
//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
// Cannot complete this function.
//
static const long ERROR_CAN_NOT_COMPLETE = 1003L;
//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
// Invalid flags.
//
static const long ERROR_INVALID_FLAGS = 1004L;
//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
// The volume does not contain a recognized file system.
// Please make sure that all required file system drivers are loaded and that the volume is not corrupted.
//
static const long ERROR_UNRECOGNIZED_VOLUME = 1005L;
//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
// The volume for a file has been externally altered so that the opened file is no longer valid.
//
static const long ERROR_FILE_INVALID = 1006L;
//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
// The requested operation cannot be performed in full-screen mode.
//
static const long ERROR_FULLSCREEN_MODE = 1007L;
//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
// An attempt was made to reference a token that does not exist.
//
static const long ERROR_NO_TOKEN = 1008L;
//
// MessageId: ERROR_BADDB
//
// MessageText:
//
// The configuration registry database is corrupt.
//
static const long ERROR_BADDB = 1009L;
//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
// The configuration registry key is invalid.
//
static const long ERROR_BADKEY = 1010L;
//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
// The configuration registry key could not be opened.
//
static const long ERROR_CANTOPEN = 1011L;
//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
// The configuration registry key could not be read.
//
static const long ERROR_CANTREAD = 1012L;
//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
// The configuration registry key could not be written.
//
static const long ERROR_CANTWRITE = 1013L;
//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
// One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.
//
static const long ERROR_REGISTRY_RECOVERED = 1014L;
//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
// The registry is corrupted. The structure of one of the files containing registry data is corrupted, or the system's memory image of the file is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.
//
static const long ERROR_REGISTRY_CORRUPT = 1015L;
//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
// An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.
//
static const long ERROR_REGISTRY_IO_FAILED = 1016L;
//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
// The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.
//
static const long ERROR_NOT_REGISTRY_FILE = 1017L;
//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
// Illegal operation attempted on a registry key that has been marked for deletion.
//
static const long ERROR_KEY_DELETED = 1018L;
//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
// System could not allocate the required space in a registry log.
//
static const long ERROR_NO_LOG_SPACE = 1019L;
//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
// Cannot create a symbolic link in a registry key that already has subkeys or values.
//
static const long ERROR_KEY_HAS_CHILDREN = 1020L;
//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
// Cannot create a stable subkey under a volatile parent key.
//
static const long ERROR_CHILD_MUST_BE_VOLATILE = 1021L;
//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
// A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.
//
static const long ERROR_NOTIFY_ENUM_DIR = 1022L;
//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
// A stop control has been sent to a service that other running services are dependent on.
//
static const long ERROR_DEPENDENT_SERVICES_RUNNING = 1051L;
//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
// The requested control is not valid for this service.
//
static const long ERROR_INVALID_SERVICE_CONTROL = 1052L;
//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
// The service did not respond to the start or control request in a timely fashion.
//
static const long ERROR_SERVICE_REQUEST_TIMEOUT = 1053L;
//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
// A thread could not be created for the service.
//
static const long ERROR_SERVICE_NO_THREAD = 1054L;
//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
// The service database is locked.
//
static const long ERROR_SERVICE_DATABASE_LOCKED = 1055L;
//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
// An instance of the service is already running.
//
static const long ERROR_SERVICE_ALREADY_RUNNING = 1056L;
//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
// The account name is invalid or does not exist, or the password is invalid for the account name specified.
//
static const long ERROR_INVALID_SERVICE_ACCOUNT = 1057L;
//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
// The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.
//
static const long ERROR_SERVICE_DISABLED = 1058L;
//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
// Circular service dependency was specified.
//
static const long ERROR_CIRCULAR_DEPENDENCY = 1059L;
//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
// The specified service does not exist as an installed service.
//
static const long ERROR_SERVICE_DOES_NOT_EXIST = 1060L;
//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
// The service cannot accept control messages at this time.
//
static const long ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 1061L;
//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
// The service has not been started.
//
static const long ERROR_SERVICE_NOT_ACTIVE = 1062L;
//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
// The service process could not connect to the service controller.
//
static const long ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063L;
//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
// An exception occurred in the service when handling the control request.
//
static const long ERROR_EXCEPTION_IN_SERVICE = 1064L;
//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
// The database specified does not exist.
//
static const long ERROR_DATABASE_DOES_NOT_EXIST = 1065L;
//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
// The service has returned a service-specific error code.
//
static const long ERROR_SERVICE_SPECIFIC_ERROR = 1066L;
//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
// The process terminated unexpectedly.
//
static const long ERROR_PROCESS_ABORTED = 1067L;
//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
// The dependency service or group failed to start.
//
static const long ERROR_SERVICE_DEPENDENCY_FAIL = 1068L;
//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
// The service did not start due to a logon failure.
//
static const long ERROR_SERVICE_LOGON_FAILED = 1069L;
//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
// After starting, the service hung in a start-pending state.
//
static const long ERROR_SERVICE_START_HANG = 1070L;
//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
// The specified service database lock is invalid.
//
static const long ERROR_INVALID_SERVICE_LOCK = 1071L;
//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
// The specified service has been marked for deletion.
//
static const long ERROR_SERVICE_MARKED_FOR_DELETE = 1072L;
//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
// The specified service already exists.
//
static const long ERROR_SERVICE_EXISTS = 1073L;
//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
// The system is currently running with the last-known-good configuration.
//
static const long ERROR_ALREADY_RUNNING_LKG = 1074L;
//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
// The dependency service does not exist or has been marked for deletion.
//
static const long ERROR_SERVICE_DEPENDENCY_DELETED = 1075L;
//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
// The current boot has already been accepted for use as the last-known-good control set.
//
static const long ERROR_BOOT_ALREADY_ACCEPTED = 1076L;
//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
// No attempts to start the service have been made since the last boot.
//
static const long ERROR_SERVICE_NEVER_STARTED = 1077L;
//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
// The name is already in use as either a service name or a service display name.
//
static const long ERROR_DUPLICATE_SERVICE_NAME = 1078L;
//
// MessageId: ERROR_DIFFERENT_SERVICE_ACCOUNT
//
// MessageText:
//
// The account specified for this service is different from the account specified for other services running in the same process.
//
static const long ERROR_DIFFERENT_SERVICE_ACCOUNT = 1079L;
//
// MessageId: ERROR_CANNOT_DETECT_DRIVER_FAILURE
//
// MessageText:
//
// Failure actions can only be set for Win32 services, not for drivers.
//
static const long ERROR_CANNOT_DETECT_DRIVER_FAILURE = 1080L;
//
// MessageId: ERROR_CANNOT_DETECT_PROCESS_ABORT
//
// MessageText:
//
// This service runs in the same process as the service control manager.
// Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.
//
static const long ERROR_CANNOT_DETECT_PROCESS_ABORT = 1081L;
//
// MessageId: ERROR_NO_RECOVERY_PROGRAM
//
// MessageText:
//
// No recovery program has been configured for this service.
//
static const long ERROR_NO_RECOVERY_PROGRAM = 1082L;
//
// MessageId: ERROR_SERVICE_NOT_IN_EXE
//
// MessageText:
//
// The executable program that this service is configured to run in does not implement the service.
//
static const long ERROR_SERVICE_NOT_IN_EXE = 1083L;
//
// MessageId: ERROR_NOT_SAFEBOOT_SERVICE
//
// MessageText:
//
// This service cannot be started in Safe Mode
//
static const long ERROR_NOT_SAFEBOOT_SERVICE = 1084L;
//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
// The physical end of the tape has been reached.
//
static const long ERROR_END_OF_MEDIA = 1100L;
//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
// A tape access reached a filemark.
//
static const long ERROR_FILEMARK_DETECTED = 1101L;
//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
// The beginning of the tape or a partition was encountered.
//
static const long ERROR_BEGINNING_OF_MEDIA = 1102L;
//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
// A tape access reached the end of a set of files.
//
static const long ERROR_SETMARK_DETECTED = 1103L;
//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
// No more data is on the tape.
//
static const long ERROR_NO_DATA_DETECTED = 1104L;
//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
// Tape could not be partitioned.
//
static const long ERROR_PARTITION_FAILURE = 1105L;
//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
// When accessing a new tape of a multivolume partition, the current block size is incorrect.
//
static const long ERROR_INVALID_BLOCK_LENGTH = 1106L;
//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
// Tape partition information could not be found when loading a tape.
//
static const long ERROR_DEVICE_NOT_PARTITIONED = 1107L;
//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
// Unable to lock the media eject mechanism.
//
static const long ERROR_UNABLE_TO_LOCK_MEDIA = 1108L;
//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
// Unable to unload the media.
//
static const long ERROR_UNABLE_TO_UNLOAD_MEDIA = 1109L;
//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
// The media in the drive may have changed.
//
static const long ERROR_MEDIA_CHANGED = 1110L;
//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
// The I/O bus was reset.
//
static const long ERROR_BUS_RESET = 1111L;
//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
// No media in drive.
//
static const long ERROR_NO_MEDIA_IN_DRIVE = 1112L;
//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
// No mapping for the Unicode character exists in the target multi-byte code page.
//
static const long ERROR_NO_UNICODE_TRANSLATION = 1113L;
//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
// A dynamic link library (DLL) initialization routine failed.
//
static const long ERROR_DLL_INIT_FAILED = 1114L;
//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//
static const long ERROR_SHUTDOWN_IN_PROGRESS = 1115L;
//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// Unable to abort the system shutdown because no shutdown was in progress.
//
static const long ERROR_NO_SHUTDOWN_IN_PROGRESS = 1116L;
//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
// The request could not be performed because of an I/O device error.
//
static const long ERROR_IO_DEVICE = 1117L;
//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
// No serial device was successfully initialized. The serial driver will unload.
//
static const long ERROR_SERIAL_NO_DEVICE = 1118L;
//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
// Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.
//
static const long ERROR_IRQ_BUSY = 1119L;
//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
// A serial I/O operation was completed by another write to the serial port.
// (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
static const long ERROR_MORE_WRITES = 1120L;
//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
// A serial I/O operation completed because the timeout period expired.
// (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//
static const long ERROR_COUNTER_TIMEOUT = 1121L;
//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
// No ID address mark was found on the floppy disk.
//
static const long ERROR_FLOPPY_ID_MARK_NOT_FOUND = 1122L;
//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
// Mismatch between the floppy disk sector ID field and the floppy disk controller track address.
//
static const long ERROR_FLOPPY_WRONG_CYLINDER = 1123L;
//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
// The floppy disk controller reported an error that is not recognized by the floppy disk driver.
//
static const long ERROR_FLOPPY_UNKNOWN_ERROR = 1124L;
//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
// The floppy disk controller returned inconsistent results in its registers.
//
static const long ERROR_FLOPPY_BAD_REGISTERS = 1125L;
//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
// While accessing the hard disk, a recalibrate operation failed, even after retries.
//
static const long ERROR_DISK_RECALIBRATE_FAILED = 1126L;
//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
// While accessing the hard disk, a disk operation failed even after retries.
//
static const long ERROR_DISK_OPERATION_FAILED = 1127L;
//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
// While accessing the hard disk, a disk controller reset was needed, but even that failed.
//
static const long ERROR_DISK_RESET_FAILED = 1128L;
//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
// Physical end of tape encountered.
//
static const long ERROR_EOM_OVERFLOW = 1129L;
//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
// Not enough server storage is available to process this command.
//
static const long ERROR_NOT_ENOUGH_SERVER_MEMORY = 1130L;
//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
// A potential deadlock condition has been detected.
//
static const long ERROR_POSSIBLE_DEADLOCK = 1131L;
//
// MessageId: ERROR_MAPPED_ALIGNMENT
//
// MessageText:
//
// The base address or the file offset specified does not have the proper alignment.
//
static const long ERROR_MAPPED_ALIGNMENT = 1132L;
//
// MessageId: ERROR_SET_POWER_STATE_VETOED
//
// MessageText:
//
// An attempt to change the system power state was vetoed by another application or driver.
//
static const long ERROR_SET_POWER_STATE_VETOED = 1140L;
//
// MessageId: ERROR_SET_POWER_STATE_FAILED
//
// MessageText:
//
// The system BIOS failed an attempt to change the system power state.
//
static const long ERROR_SET_POWER_STATE_FAILED = 1141L;
//
// MessageId: ERROR_TOO_MANY_LINKS
//
// MessageText:
//
// An attempt was made to create more links on a file than the file system supports.
//
static const long ERROR_TOO_MANY_LINKS = 1142L;
//
// MessageId: ERROR_OLD_WIN_VERSION
//
// MessageText:
//
// The specified program requires a newer version of Windows.
//
static const long ERROR_OLD_WIN_VERSION = 1150L;
//
// MessageId: ERROR_APP_WRONG_OS
//
// MessageText:
//
// The specified program is not a Windows or MS-DOS program.
//
static const long ERROR_APP_WRONG_OS = 1151L;
//
// MessageId: ERROR_SINGLE_INSTANCE_APP
//
// MessageText:
//
// Cannot start more than one instance of the specified program.
//
static const long ERROR_SINGLE_INSTANCE_APP = 1152L;
//
// MessageId: ERROR_RMODE_APP
//
// MessageText:
//
// The specified program was written for an earlier version of Windows.
//
static const long ERROR_RMODE_APP = 1153L;
//
// MessageId: ERROR_INVALID_DLL
//
// MessageText:
//
// One of the library files needed to run this application is damaged.
//
static const long ERROR_INVALID_DLL = 1154L;
//
// MessageId: ERROR_NO_ASSOCIATION
//
// MessageText:
//
// No application is associated with the specified file for this operation.
//
static const long ERROR_NO_ASSOCIATION = 1155L;
//
// MessageId: ERROR_DDE_FAIL
//
// MessageText:
//
// An error occurred in sending the command to the application.
//
static const long ERROR_DDE_FAIL = 1156L;
//
// MessageId: ERROR_DLL_NOT_FOUND
//
// MessageText:
//
// One of the library files needed to run this application cannot be found.
//
static const long ERROR_DLL_NOT_FOUND = 1157L;
//
// MessageId: ERROR_NO_MORE_USER_HANDLES
//
// MessageText:
//
// The current process has used all of its system allowance of handles for Window Manager objects.
//
static const long ERROR_NO_MORE_USER_HANDLES = 1158L;
//
// MessageId: ERROR_MESSAGE_SYNC_ONLY
//
// MessageText:
//
// The message can be used only with synchronous operations.
//
static const long ERROR_MESSAGE_SYNC_ONLY = 1159L;
//
// MessageId: ERROR_SOURCE_ELEMENT_EMPTY
//
// MessageText:
//
// The indicated source element has no media.
//
static const long ERROR_SOURCE_ELEMENT_EMPTY = 1160L;
//
// MessageId: ERROR_DESTINATION_ELEMENT_FULL
//
// MessageText:
//
// The indicated destination element already contains media.
//
static const long ERROR_DESTINATION_ELEMENT_FULL = 1161L;
//
// MessageId: ERROR_ILLEGAL_ELEMENT_ADDRESS
//
// MessageText:
//
// The indicated element does not exist.
//
static const long ERROR_ILLEGAL_ELEMENT_ADDRESS = 1162L;
//
// MessageId: ERROR_MAGAZINE_NOT_PRESENT
//
// MessageText:
//
// The indicated element is part of a magazine that is not present.
//
static const long ERROR_MAGAZINE_NOT_PRESENT = 1163L;
//
// MessageId: ERROR_DEVICE_REINITIALIZATION_NEEDED
//
// MessageText:
//
// The indicated device requires reinitialization due to hardware errors.
//
static const long ERROR_DEVICE_REINITIALIZATION_NEEDED = 1164L;
//
// MessageId: ERROR_DEVICE_REQUIRES_CLEANING
//
// MessageText:
//
// The device has indicated that cleaning is required before further operations are attempted.
//
static const long ERROR_DEVICE_REQUIRES_CLEANING = 1165L;
//
// MessageId: ERROR_DEVICE_DOOR_OPEN
//
// MessageText:
//
// The device has indicated that its door is open.
//
static const long ERROR_DEVICE_DOOR_OPEN = 1166L;
//
// MessageId: ERROR_DEVICE_NOT_CONNECTED
//
// MessageText:
//
// The device is not connected.
//
static const long ERROR_DEVICE_NOT_CONNECTED = 1167L;
//
// MessageId: ERROR_NOT_FOUND
//
// MessageText:
//
// Element not found.
//
static const long ERROR_NOT_FOUND = 1168L;
//
// MessageId: ERROR_NO_MATCH
//
// MessageText:
//
// There was no match for the specified key in the index.
//
static const long ERROR_NO_MATCH = 1169L;
//
// MessageId: ERROR_SET_NOT_FOUND
//
// MessageText:
//
// The property set specified does not exist on the object.
//
static const long ERROR_SET_NOT_FOUND = 1170L;
//
// MessageId: ERROR_POINT_NOT_FOUND
//
// MessageText:
//
// The point passed to GetMouseMovePoints is not in the buffer.
//
static const long ERROR_POINT_NOT_FOUND = 1171L;
//
// MessageId: ERROR_NO_TRACKING_SERVICE
//
// MessageText:
//
// The tracking (workstation) service is not running.
//
static const long ERROR_NO_TRACKING_SERVICE = 1172L;
//
// MessageId: ERROR_NO_VOLUME_ID
//
// MessageText:
//
// The Volume ID could not be found.
//
static const long ERROR_NO_VOLUME_ID = 1173L;
//
// MessageId: ERROR_UNABLE_TO_REMOVE_REPLACED
//
// MessageText:
//
// Unable to remove the file to be replaced.
//
static const long ERROR_UNABLE_TO_REMOVE_REPLACED = 1175L;
//
// MessageId: ERROR_UNABLE_TO_MOVE_REPLACEMENT
//
// MessageText:
//
// Unable to move the replacement file to the file to be replaced. The file to be replaced has retained its original name.
//
static const long ERROR_UNABLE_TO_MOVE_REPLACEMENT = 1176L;
//
// MessageId: ERROR_UNABLE_TO_MOVE_REPLACEMENT_2
//
// MessageText:
//
// Unable to move the replacement file to the file to be replaced. The file to be replaced has been renamed using the backup name.
//
static const long ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = 1177L;
//
// MessageId: ERROR_JOURNAL_DELETE_IN_PROGRESS
//
// MessageText:
//
// The volume change journal is being deleted.
//
static const long ERROR_JOURNAL_DELETE_IN_PROGRESS = 1178L;
//
// MessageId: ERROR_JOURNAL_NOT_ACTIVE
//
// MessageText:
//
// The volume change journal is not active.
//
static const long ERROR_JOURNAL_NOT_ACTIVE = 1179L;
//
// MessageId: ERROR_POTENTIAL_FILE_FOUND
//
// MessageText:
//
// A file was found, but it may not be the correct file.
//
static const long ERROR_POTENTIAL_FILE_FOUND = 1180L;
//
// MessageId: ERROR_JOURNAL_ENTRY_DELETED
//
// MessageText:
//
// The journal entry has been deleted from the journal.
//
static const long ERROR_JOURNAL_ENTRY_DELETED = 1181L;
//
// MessageId: ERROR_SHUTDOWN_IS_SCHEDULED
//
// MessageText:
//
// A system shutdown has already been scheduled.
//
static const long ERROR_SHUTDOWN_IS_SCHEDULED = 1190L;
//
// MessageId: ERROR_SHUTDOWN_USERS_LOGGED_ON
//
// MessageText:
//
// The system shutdown cannot be initiated because there are other users logged on to the computer.
//
static const long ERROR_SHUTDOWN_USERS_LOGGED_ON = 1191L;
//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
// The specified device name is invalid.
//
static const long ERROR_BAD_DEVICE = 1200L;
//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
// The device is not currently connected but it is a remembered connection.
//
static const long ERROR_CONNECTION_UNAVAIL = 1201L;
//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
// The local device name has a remembered connection to another network resource.
//
static const long ERROR_DEVICE_ALREADY_REMEMBERED = 1202L;
//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
// The network path was either typed incorrectly, does not exist, or the network provider is not currently available. Please try retyping the path or contact your network administrator.
//
static const long ERROR_NO_NET_OR_BAD_PATH = 1203L;
//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
// The specified network provider name is invalid.
//
static const long ERROR_BAD_PROVIDER = 1204L;
//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
// Unable to open the network connection profile.
//
static const long ERROR_CANNOT_OPEN_PROFILE = 1205L;
//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
// The network connection profile is corrupted.
//
static const long ERROR_BAD_PROFILE = 1206L;
//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
// Cannot enumerate a noncontainer.
//
static const long ERROR_NOT_CONTAINER = 1207L;
//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
// An extended error has occurred.
//
static const long ERROR_EXTENDED_ERROR = 1208L;
//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
// The format of the specified group name is invalid.
//
static const long ERROR_INVALID_GROUPNAME = 1209L;
//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
// The format of the specified computer name is invalid.
//
static const long ERROR_INVALID_COMPUTERNAME = 1210L;
//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
// The format of the specified event name is invalid.
//
static const long ERROR_INVALID_EVENTNAME = 1211L;
//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
// The format of the specified domain name is invalid.
//
static const long ERROR_INVALID_DOMAINNAME = 1212L;
//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
// The format of the specified service name is invalid.
//
static const long ERROR_INVALID_SERVICENAME = 1213L;
//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
// The format of the specified network name is invalid.
//
static const long ERROR_INVALID_NETNAME = 1214L;
//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
// The format of the specified share name is invalid.
//
static const long ERROR_INVALID_SHARENAME = 1215L;
//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
// The format of the specified password is invalid.
//
static const long ERROR_INVALID_PASSWORDNAME = 1216L;
//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
// The format of the specified message name is invalid.
//
static const long ERROR_INVALID_MESSAGENAME = 1217L;
//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
// The format of the specified message destination is invalid.
//
static const long ERROR_INVALID_MESSAGEDEST = 1218L;
//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
// Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again.
//
static const long ERROR_SESSION_CREDENTIAL_CONFLICT = 1219L;
//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.
//
static const long ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 1220L;
//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
// The workgroup or domain name is already in use by another computer on the network.
//
static const long ERROR_DUP_DOMAINNAME = 1221L;
//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
// The network is not present or not started.
//
static const long ERROR_NO_NETWORK = 1222L;
//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
// The operation was canceled by the user.
//
static const long ERROR_CANCELLED = 1223L;
//
// MessageId: ERROR_USER_MAPPED_FILE
//
// MessageText:
//
// The requested operation cannot be performed on a file with a user-mapped section open.
//
static const long ERROR_USER_MAPPED_FILE = 1224L;
//
// MessageId: ERROR_CONNECTION_REFUSED
//
// MessageText:
//
// The remote computer refused the network connection.
//
static const long ERROR_CONNECTION_REFUSED = 1225L;
//
// MessageId: ERROR_GRACEFUL_DISCONNECT
//
// MessageText:
//
// The network connection was gracefully closed.
//
static const long ERROR_GRACEFUL_DISCONNECT = 1226L;
//
// MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
// The network transport endpoint already has an address associated with it.
//
static const long ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227L;
//
// MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
// An address has not yet been associated with the network endpoint.
//
static const long ERROR_ADDRESS_NOT_ASSOCIATED = 1228L;
//
// MessageId: ERROR_CONNECTION_INVALID
//
// MessageText:
//
// An operation was attempted on a nonexistent network connection.
//
static const long ERROR_CONNECTION_INVALID = 1229L;
//
// MessageId: ERROR_CONNECTION_ACTIVE
//
// MessageText:
//
// An invalid operation was attempted on an active network connection.
//
static const long ERROR_CONNECTION_ACTIVE = 1230L;
//
// MessageId: ERROR_NETWORK_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//
static const long ERROR_NETWORK_UNREACHABLE = 1231L;
//
// MessageId: ERROR_HOST_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//
static const long ERROR_HOST_UNREACHABLE = 1232L;
//
// MessageId: ERROR_PROTOCOL_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//
static const long ERROR_PROTOCOL_UNREACHABLE = 1233L;
//
// MessageId: ERROR_PORT_UNREACHABLE
//
// MessageText:
//
// No service is operating at the destination network endpoint on the remote system.
//
static const long ERROR_PORT_UNREACHABLE = 1234L;
//
// MessageId: ERROR_REQUEST_ABORTED
//
// MessageText:
//
// The request was aborted.
//
static const long ERROR_REQUEST_ABORTED = 1235L;
//
// MessageId: ERROR_CONNECTION_ABORTED
//
// MessageText:
//
// The network connection was aborted by the local system.
//
static const long ERROR_CONNECTION_ABORTED = 1236L;
//
// MessageId: ERROR_RETRY
//
// MessageText:
//
// The operation could not be completed. A retry should be performed.
//
static const long ERROR_RETRY = 1237L;
//
// MessageId: ERROR_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
// A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.
//
static const long ERROR_CONNECTION_COUNT_LIMIT = 1238L;
//
// MessageId: ERROR_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
// Attempting to log in during an unauthorized time of day for this account.
//
static const long ERROR_LOGIN_TIME_RESTRICTION = 1239L;
//
// MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
// The account is not authorized to log in from this station.
//
static const long ERROR_LOGIN_WKSTA_RESTRICTION = 1240L;
//
// MessageId: ERROR_INCORRECT_ADDRESS
//
// MessageText:
//
// The network address could not be used for the operation requested.
//
static const long ERROR_INCORRECT_ADDRESS = 1241L;
//
// MessageId: ERROR_ALREADY_REGISTERED
//
// MessageText:
//
// The service is already registered.
//
static const long ERROR_ALREADY_REGISTERED = 1242L;
//
// MessageId: ERROR_SERVICE_NOT_FOUND
//
// MessageText:
//
// The specified service does not exist.
//
static const long ERROR_SERVICE_NOT_FOUND = 1243L;
//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
// The operation being requested was not performed because the user has not been authenticated.
//
static const long ERROR_NOT_AUTHENTICATED = 1244L;
//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
// The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.
//
static const long ERROR_NOT_LOGGED_ON = 1245L;
//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
// Continue with work in progress.
//
static const long ERROR_CONTINUE = 1246L;
//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
// An attempt was made to perform an initialization operation when initialization has already been completed.
//
static const long ERROR_ALREADY_INITIALIZED = 1247L;
//
// MessageId: ERROR_NO_MORE_DEVICES
//
// MessageText:
//
// No more local devices.
//
static const long ERROR_NO_MORE_DEVICES = 1248L;
//
// MessageId: ERROR_NO_SUCH_SITE
//
// MessageText:
//
// The specified site does not exist.
//
static const long ERROR_NO_SUCH_SITE = 1249L;
//
// MessageId: ERROR_DOMAIN_CONTROLLER_EXISTS
//
// MessageText:
//
// A domain controller with the specified name already exists.
//
static const long ERROR_DOMAIN_CONTROLLER_EXISTS = 1250L;
//
// MessageId: ERROR_ONLY_IF_CONNECTED
//
// MessageText:
//
// This operation is supported only when you are connected to the server.
//
static const long ERROR_ONLY_IF_CONNECTED = 1251L;
//
// MessageId: ERROR_OVERRIDE_NOCHANGES
//
// MessageText:
//
// The group policy framework should call the extension even if there are no changes.
//
static const long ERROR_OVERRIDE_NOCHANGES = 1252L;
//
// MessageId: ERROR_BAD_USER_PROFILE
//
// MessageText:
//
// The specified user does not have a valid profile.
//
static const long ERROR_BAD_USER_PROFILE = 1253L;
//
// MessageId: ERROR_NOT_SUPPORTED_ON_SBS
//
// MessageText:
//
// This operation is not supported on a computer running Windows Server 2003 for Small Business Server
//
static const long ERROR_NOT_SUPPORTED_ON_SBS = 1254L;
//
// MessageId: ERROR_SERVER_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// The server machine is shutting down.
//
static const long ERROR_SERVER_SHUTDOWN_IN_PROGRESS = 1255L;
//
// MessageId: ERROR_HOST_DOWN
//
// MessageText:
//
// The remote system is not available. For information about network troubleshooting, see Windows Help.
//
static const long ERROR_HOST_DOWN = 1256L;
//
// MessageId: ERROR_NON_ACCOUNT_SID
//
// MessageText:
//
// The security identifier provided is not from an account domain.
//
static const long ERROR_NON_ACCOUNT_SID = 1257L;
//
// MessageId: ERROR_NON_DOMAIN_SID
//
// MessageText:
//
// The security identifier provided does not have a domain component.
//
static const long ERROR_NON_DOMAIN_SID = 1258L;
//
// MessageId: ERROR_APPHELP_BLOCK
//
// MessageText:
//
// AppHelp dialog canceled thus preventing the application from starting.
//
static const long ERROR_APPHELP_BLOCK = 1259L;
//
// MessageId: ERROR_ACCESS_DISABLED_BY_POLICY
//
// MessageText:
//
// This program is blocked by group policy. For more information, contact your system administrator.
//
static const long ERROR_ACCESS_DISABLED_BY_POLICY = 1260L;
//
// MessageId: ERROR_REG_NAT_CONSUMPTION
//
// MessageText:
//
// A program attempt to use an invalid register value. Normally caused by an uninitialized register. This error is Itanium specific.
//
static const long ERROR_REG_NAT_CONSUMPTION = 1261L;
//
// MessageId: ERROR_CSCSHARE_OFFLINE
//
// MessageText:
//
// The share is currently offline or does not exist.
//
static const long ERROR_CSCSHARE_OFFLINE = 1262L;
//
// MessageId: ERROR_PKINIT_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while validating the KDC certificate during smartcard logon. There is more information in the system event log.
//
static const long ERROR_PKINIT_FAILURE = 1263L;
//
// MessageId: ERROR_SMARTCARD_SUBSYSTEM_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.
//
static const long ERROR_SMARTCARD_SUBSYSTEM_FAILURE = 1264L;
//
// MessageId: ERROR_DOWNGRADE_DETECTED
//
// MessageText:
//
// The system detected a possible attempt to compromise security. Please ensure that you can contact the server that authenticated you.
//
static const long ERROR_DOWNGRADE_DETECTED = 1265L;
//
// Do not use ID's 1266 - 1270 as the symbolicNames have been moved to SEC_E_*
//
//
// MessageId: ERROR_MACHINE_LOCKED
//
// MessageText:
//
// The machine is locked and cannot be shut down without the force option.
//
static const long ERROR_MACHINE_LOCKED = 1271L;
//
// MessageId: ERROR_CALLBACK_SUPPLIED_INVALID_DATA
//
// MessageText:
//
// An application-defined callback gave invalid data when called.
//
static const long ERROR_CALLBACK_SUPPLIED_INVALID_DATA = 1273L;
//
// MessageId: ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED
//
// MessageText:
//
// The group policy framework should call the extension in the synchronous foreground policy refresh.
//
static const long ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED = 1274L;
//
// MessageId: ERROR_DRIVER_BLOCKED
//
// MessageText:
//
// This driver has been blocked from loading
//
static const long ERROR_DRIVER_BLOCKED = 1275L;
//
// MessageId: ERROR_INVALID_IMPORT_OF_NON_DLL
//
// MessageText:
//
// A dynamic link library (DLL) referenced a module that was neither a DLL nor the process's executable image.
//
static const long ERROR_INVALID_IMPORT_OF_NON_DLL = 1276L;
//
// MessageId: ERROR_ACCESS_DISABLED_WEBBLADE
//
// MessageText:
//
// Windows cannot open this program since it has been disabled.
//
static const long ERROR_ACCESS_DISABLED_WEBBLADE = 1277L;
//
// MessageId: ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER
//
// MessageText:
//
// Windows cannot open this program because the license enforcement system has been tampered with or become corrupted.
//
static const long ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = 1278L;
//
// MessageId: ERROR_RECOVERY_FAILURE
//
// MessageText:
//
// A transaction recover failed.
//
static const long ERROR_RECOVERY_FAILURE = 1279L;
//
// MessageId: ERROR_ALREADY_FIBER
//
// MessageText:
//
// The current thread has already been converted to a fiber.
//
static const long ERROR_ALREADY_FIBER = 1280L;
//
// MessageId: ERROR_ALREADY_THREAD
//
// MessageText:
//
// The current thread has already been converted from a fiber.
//
static const long ERROR_ALREADY_THREAD = 1281L;
//
// MessageId: ERROR_STACK_BUFFER_OVERRUN
//
// MessageText:
//
// The system detected an overrun of a stack-based buffer in this application. This overrun could potentially allow a malicious user to gain control of this application.
//
static const long ERROR_STACK_BUFFER_OVERRUN = 1282L;
//
// MessageId: ERROR_PARAMETER_QUOTA_EXCEEDED
//
// MessageText:
//
// Data present in one of the parameters is more than the function can operate on.
//
static const long ERROR_PARAMETER_QUOTA_EXCEEDED = 1283L;
//
// MessageId: ERROR_DEBUGGER_INACTIVE
//
// MessageText:
//
// An attempt to do an operation on a debug object failed because the object is in the process of being deleted.
//
static const long ERROR_DEBUGGER_INACTIVE = 1284L;
//
// MessageId: ERROR_DELAY_LOAD_FAILED
//
// MessageText:
//
// An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.
//
static const long ERROR_DELAY_LOAD_FAILED = 1285L;
//
// MessageId: ERROR_VDM_DISALLOWED
//
// MessageText:
//
// %1 is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.
//
static const long ERROR_VDM_DISALLOWED = 1286L;
//
// MessageId: ERROR_UNIDENTIFIED_ERROR
//
// MessageText:
//
// Insufficient information exists to identify the cause of failure.
//
static const long ERROR_UNIDENTIFIED_ERROR = 1287L;
//
// MessageId: ERROR_INVALID_CRUNTIME_PARAMETER
//
// MessageText:
//
// The parameter passed to a C runtime function is incorrect.
//
static const long ERROR_INVALID_CRUNTIME_PARAMETER = 1288L;
//
// MessageId: ERROR_BEYOND_VDL
//
// MessageText:
//
// The operation occurred beyond the valid data length of the file.
//
static const long ERROR_BEYOND_VDL = 1289L;
//
// MessageId: ERROR_INCOMPATIBLE_SERVICE_SID_TYPE
//
// MessageText:
//
// The service start failed since one or more services in the same process have an incompatible service SID type setting. A service with restricted service SID type can only coexist in the same process with other services with a restricted SID type. If the service SID type for this service was just configured, the hosting process must be restarted in order to start this service.
//
static const long ERROR_INCOMPATIBLE_SERVICE_SID_TYPE = 1290L;
//
// MessageId: ERROR_DRIVER_PROCESS_TERMINATED
//
// MessageText:
//
// The process hosting the driver for this device has been terminated.
//
static const long ERROR_DRIVER_PROCESS_TERMINATED = 1291L;
//
// MessageId: ERROR_IMPLEMENTATION_LIMIT
//
// MessageText:
//
// An operation attempted to exceed an implementation-defined limit.
//
static const long ERROR_IMPLEMENTATION_LIMIT = 1292L;
//
// MessageId: ERROR_PROCESS_IS_PROTECTED
//
// MessageText:
//
// Either the target process, or the target thread's containing process, is a protected process.
//
static const long ERROR_PROCESS_IS_PROTECTED = 1293L;
//
// MessageId: ERROR_SERVICE_NOTIFY_CLIENT_LAGGING
//
// MessageText:
//
// The service notification client is lagging too far behind the current state of services in the machine.
//
static const long ERROR_SERVICE_NOTIFY_CLIENT_LAGGING = 1294L;
//
// MessageId: ERROR_DISK_QUOTA_EXCEEDED
//
// MessageText:
//
// The requested file operation failed because the storage quota was exceeded.
// To free up disk space, move files to a different location or delete unnecessary files. For more information, contact your system administrator.
//
static const long ERROR_DISK_QUOTA_EXCEEDED = 1295L;
//
// MessageId: ERROR_CONTENT_BLOCKED
//
// MessageText:
//
// The requested file operation failed because the storage policy blocks that type of file. For more information, contact your system administrator.
//
static const long ERROR_CONTENT_BLOCKED = 1296L;
//
// MessageId: ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE
//
// MessageText:
//
// A privilege that the service requires to function properly does not exist in the service account configuration.
// You may use the Services Microsoft Management Console (MMC) snap-in (services.msc) and the Local Security Settings MMC snap-in (secpol.msc) to view the service configuration and the account configuration.
//
static const long ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = 1297L;
//
// MessageId: ERROR_APP_HANG
//
// MessageText:
//
// A thread involved in this operation appears to be unresponsive.
//
static const long ERROR_APP_HANG = 1298L;
///////////////////////////////////////////////////
//                                               //
//             SECURITY Error codes              //
//                                               //
//                 1299 to 1399                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INVALID_LABEL
//
// MessageText:
//
// Indicates a particular Security ID may not be assigned as the label of an object.
//
static const long ERROR_INVALID_LABEL = 1299L;
//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
// Not all privileges or groups referenced are assigned to the caller.
//
static const long ERROR_NOT_ALL_ASSIGNED = 1300L;
//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
// Some mapping between account names and security IDs was not done.
//
static const long ERROR_SOME_NOT_MAPPED = 1301L;
//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
// No system quota limits are specifically set for this account.
//
static const long ERROR_NO_QUOTAS_FOR_ACCOUNT = 1302L;
//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
// No encryption key is available. A well-known encryption key was returned.
//
static const long ERROR_LOCAL_USER_SESSION_KEY = 1303L;
//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
// The password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.
//
static const long ERROR_NULL_LM_PASSWORD = 1304L;
//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
// The revision level is unknown.
//
static const long ERROR_UNKNOWN_REVISION = 1305L;
//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
// Indicates two revision levels are incompatible.
//
static const long ERROR_REVISION_MISMATCH = 1306L;
//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
// This security ID may not be assigned as the owner of this object.
//
static const long ERROR_INVALID_OWNER = 1307L;
//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
// This security ID may not be assigned as the primary group of an object.
//
static const long ERROR_INVALID_PRIMARY_GROUP = 1308L;
//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
// An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.
//
static const long ERROR_NO_IMPERSONATION_TOKEN = 1309L;
//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
// The group may not be disabled.
//
static const long ERROR_CANT_DISABLE_MANDATORY = 1310L;
//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
// There are currently no logon servers available to service the logon request.
//
static const long ERROR_NO_LOGON_SERVERS = 1311L;
//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
// A specified logon session does not exist. It may already have been terminated.
//
static const long ERROR_NO_SUCH_LOGON_SESSION = 1312L;
//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
// A specified privilege does not exist.
//
static const long ERROR_NO_SUCH_PRIVILEGE = 1313L;
//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
// A required privilege is not held by the client.
//
static const long ERROR_PRIVILEGE_NOT_HELD = 1314L;
//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
// The name provided is not a properly formed account name.
//
static const long ERROR_INVALID_ACCOUNT_NAME = 1315L;
//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
// The specified account already exists.
//
static const long ERROR_USER_EXISTS = 1316L;
//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
// The specified account does not exist.
//
static const long ERROR_NO_SUCH_USER = 1317L;
//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
// The specified group already exists.
//
static const long ERROR_GROUP_EXISTS = 1318L;
//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
// The specified group does not exist.
//
static const long ERROR_NO_SUCH_GROUP = 1319L;
//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
// Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.
//
static const long ERROR_MEMBER_IN_GROUP = 1320L;
//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
// The specified user account is not a member of the specified group account.
//
static const long ERROR_MEMBER_NOT_IN_GROUP = 1321L;
//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
// The last remaining administration account cannot be disabled or deleted.
//
static const long ERROR_LAST_ADMIN = 1322L;
//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
// Unable to update the password. The value provided as the current password is incorrect.
//
static const long ERROR_WRONG_PASSWORD = 1323L;
//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
// Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.
//
static const long ERROR_ILL_FORMED_PASSWORD = 1324L;
//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
// Unable to update the password. The value provided for the new password does not meet the length, complexity, or history requirements of the domain.
//
static const long ERROR_PASSWORD_RESTRICTION = 1325L;
//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
// Logon failure: unknown user name or bad password.
//
static const long ERROR_LOGON_FAILURE = 1326L;
//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
// Logon failure: user account restriction. Possible reasons are blank passwords not allowed, logon hour restrictions, or a policy restriction has been enforced.
//
static const long ERROR_ACCOUNT_RESTRICTION = 1327L;
//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
// Logon failure: account logon time restriction violation.
//
static const long ERROR_INVALID_LOGON_HOURS = 1328L;
//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
// Logon failure: user not allowed to log on to this computer.
//
static const long ERROR_INVALID_WORKSTATION = 1329L;
//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
// Logon failure: the specified account password has expired.
//
static const long ERROR_PASSWORD_EXPIRED = 1330L;
//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
// Logon failure: account currently disabled.
//
static const long ERROR_ACCOUNT_DISABLED = 1331L;
//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
// No mapping between account names and security IDs was done.
//
static const long ERROR_NONE_MAPPED = 1332L;
//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
// Too many local user identifiers (LUIDs) were requested at one time.
//
static const long ERROR_TOO_MANY_LUIDS_REQUESTED = 1333L;
//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
// No more local user identifiers (LUIDs) are available.
//
static const long ERROR_LUIDS_EXHAUSTED = 1334L;
//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
// The subauthority part of a security ID is invalid for this particular use.
//
static const long ERROR_INVALID_SUB_AUTHORITY = 1335L;
//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
// The access control list (ACL) structure is invalid.
//
static const long ERROR_INVALID_ACL = 1336L;
//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
// The security ID structure is invalid.
//
static const long ERROR_INVALID_SID = 1337L;
//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
// The security descriptor structure is invalid.
//
static const long ERROR_INVALID_SECURITY_DESCR = 1338L;
//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
// The inherited access control list (ACL) or access control entry (ACE) could not be built.
//
static const long ERROR_BAD_INHERITANCE_ACL = 1340L;
//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
// The server is currently disabled.
//
static const long ERROR_SERVER_DISABLED = 1341L;
//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
// The server is currently enabled.
//
static const long ERROR_SERVER_NOT_DISABLED = 1342L;
//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
// The value provided was an invalid value for an identifier authority.
//
static const long ERROR_INVALID_ID_AUTHORITY = 1343L;
//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
// No more memory is available for security information updates.
//
static const long ERROR_ALLOTTED_SPACE_EXCEEDED = 1344L;
//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
// The specified attributes are invalid, or incompatible with the attributes for the group as a whole.
//
static const long ERROR_INVALID_GROUP_ATTRIBUTES = 1345L;
//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
// Either a required impersonation level was not provided, or the provided impersonation level is invalid.
//
static const long ERROR_BAD_IMPERSONATION_LEVEL = 1346L;
//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
// Cannot open an anonymous level security token.
//
static const long ERROR_CANT_OPEN_ANONYMOUS = 1347L;
//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
// The validation information class requested was invalid.
//
static const long ERROR_BAD_VALIDATION_CLASS = 1348L;
//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
// The type of the token is inappropriate for its attempted use.
//
static const long ERROR_BAD_TOKEN_TYPE = 1349L;
//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
// Unable to perform a security operation on an object that has no associated security.
//
static const long ERROR_NO_SECURITY_ON_OBJECT = 1350L;
//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
// Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.
//
static const long ERROR_CANT_ACCESS_DOMAIN_INFO = 1351L;
//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
// The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.
//
static const long ERROR_INVALID_SERVER_STATE = 1352L;
//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
// The domain was in the wrong state to perform the security operation.
//
static const long ERROR_INVALID_DOMAIN_STATE = 1353L;
//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//
static const long ERROR_INVALID_DOMAIN_ROLE = 1354L;
//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
// The specified domain either does not exist or could not be contacted.
//
static const long ERROR_NO_SUCH_DOMAIN = 1355L;
//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
// The specified domain already exists.
//
static const long ERROR_DOMAIN_EXISTS = 1356L;
//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to exceed the limit on the number of domains per server.
//
static const long ERROR_DOMAIN_LIMIT_EXCEEDED = 1357L;
//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
// Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.
//
static const long ERROR_INTERNAL_DB_CORRUPTION = 1358L;
//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred.
//
static const long ERROR_INTERNAL_ERROR = 1359L;
//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
// Generic access types were contained in an access mask which should already be mapped to nongeneric types.
//
static const long ERROR_GENERIC_NOT_MAPPED = 1360L;
//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
// A security descriptor is not in the right format (absolute or self-relative).
//
static const long ERROR_BAD_DESCRIPTOR_FORMAT = 1361L;
//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
// The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.
//
static const long ERROR_NOT_LOGON_PROCESS = 1362L;
//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
// Cannot start a new logon session with an ID that is already in use.
//
static const long ERROR_LOGON_SESSION_EXISTS = 1363L;
//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
// A specified authentication package is unknown.
//
static const long ERROR_NO_SUCH_PACKAGE = 1364L;
//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
// The logon session is not in a state that is consistent with the requested operation.
//
static const long ERROR_BAD_LOGON_SESSION_STATE = 1365L;
//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
// The logon session ID is already in use.
//
static const long ERROR_LOGON_SESSION_COLLISION = 1366L;
//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
// A logon request contained an invalid logon type value.
//
static const long ERROR_INVALID_LOGON_TYPE = 1367L;
//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
// Unable to impersonate using a named pipe until data has been read from that pipe.
//
static const long ERROR_CANNOT_IMPERSONATE = 1368L;
//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
// The transaction state of a registry subtree is incompatible with the requested operation.
//
static const long ERROR_RXACT_INVALID_STATE = 1369L;
//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
// An internal security database corruption has been encountered.
//
static const long ERROR_RXACT_COMMIT_FAILURE = 1370L;
//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
// Cannot perform this operation on built-in accounts.
//
static const long ERROR_SPECIAL_ACCOUNT = 1371L;
//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
// Cannot perform this operation on this built-in special group.
//
static const long ERROR_SPECIAL_GROUP = 1372L;
//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
// Cannot perform this operation on this built-in special user.
//
static const long ERROR_SPECIAL_USER = 1373L;
//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
// The user cannot be removed from a group because the group is currently the user's primary group.
//
static const long ERROR_MEMBERS_PRIMARY_GROUP = 1374L;
//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
// The token is already in use as a primary token.
//
static const long ERROR_TOKEN_ALREADY_IN_USE = 1375L;
//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
// The specified local group does not exist.
//
static const long ERROR_NO_SUCH_ALIAS = 1376L;
//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
// The specified account name is not a member of the group.
//
static const long ERROR_MEMBER_NOT_IN_ALIAS = 1377L;
//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
// The specified account name is already a member of the group.
//
static const long ERROR_MEMBER_IN_ALIAS = 1378L;
//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
// The specified local group already exists.
//
static const long ERROR_ALIAS_EXISTS = 1379L;
//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
// Logon failure: the user has not been granted the requested logon type at this computer.
//
static const long ERROR_LOGON_NOT_GRANTED = 1380L;
//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
// The maximum number of secrets that may be stored in a single system has been exceeded.
//
static const long ERROR_TOO_MANY_SECRETS = 1381L;
//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
// The length of a secret exceeds the maximum length allowed.
//
static const long ERROR_SECRET_TOO_LONG = 1382L;
//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
// The local security authority database contains an internal inconsistency.
//
static const long ERROR_INTERNAL_DB_ERROR = 1383L;
//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
// During a logon attempt, the user's security context accumulated too many security IDs.
//
static const long ERROR_TOO_MANY_CONTEXT_IDS = 1384L;
//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
// Logon failure: the user has not been granted the requested logon type at this computer.
//
static const long ERROR_LOGON_TYPE_NOT_GRANTED = 1385L;
//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// A cross-encrypted password is necessary to change a user password.
//
static const long ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 1386L;
//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
// A member could not be added to or removed from the local group because the member does not exist.
//
static const long ERROR_NO_SUCH_MEMBER = 1387L;
//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
// A new member could not be added to a local group because the member has the wrong account type.
//
static const long ERROR_INVALID_MEMBER = 1388L;
//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
// Too many security IDs have been specified.
//
static const long ERROR_TOO_MANY_SIDS = 1389L;
//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// A cross-encrypted password is necessary to change this user password.
//
static const long ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 1390L;
//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
// Indicates an ACL contains no inheritable components.
//
static const long ERROR_NO_INHERITANCE = 1391L;
//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
// The file or directory is corrupted and unreadable.
//
static const long ERROR_FILE_CORRUPT = 1392L;
//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
// The disk structure is corrupted and unreadable.
//
static const long ERROR_DISK_CORRUPT = 1393L;
//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
// There is no user session key for the specified logon session.
//
static const long ERROR_NO_USER_SESSION_KEY = 1394L;
//
// MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
// The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.
//
static const long ERROR_LICENSE_QUOTA_EXCEEDED = 1395L;
//
// MessageId: ERROR_WRONG_TARGET_NAME
//
// MessageText:
//
// Logon Failure: The target account name is incorrect.
//
static const long ERROR_WRONG_TARGET_NAME = 1396L;
//
// MessageId: ERROR_MUTUAL_AUTH_FAILED
//
// MessageText:
//
// Mutual Authentication failed. The server's password is out of date at the domain controller.
//
static const long ERROR_MUTUAL_AUTH_FAILED = 1397L;
//
// MessageId: ERROR_TIME_SKEW
//
// MessageText:
//
// There is a time and/or date difference between the client and server.
//
static const long ERROR_TIME_SKEW = 1398L;
//
// MessageId: ERROR_CURRENT_DOMAIN_NOT_ALLOWED
//
// MessageText:
//
// This operation cannot be performed on the current domain.
//
static const long ERROR_CURRENT_DOMAIN_NOT_ALLOWED = 1399L;
///////////////////////////////////////////////////
//                                               //
//              WinUser Error codes              //
//                                               //
//                 1400 to 1499                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
// Invalid window handle.
//
static const long ERROR_INVALID_WINDOW_HANDLE = 1400L;
//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
// Invalid menu handle.
//
static const long ERROR_INVALID_MENU_HANDLE = 1401L;
//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
// Invalid cursor handle.
//
static const long ERROR_INVALID_CURSOR_HANDLE = 1402L;
//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
// Invalid accelerator table handle.
//
static const long ERROR_INVALID_ACCEL_HANDLE = 1403L;
//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
// Invalid hook handle.
//
static const long ERROR_INVALID_HOOK_HANDLE = 1404L;
//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
// Invalid handle to a multiple-window position structure.
//
static const long ERROR_INVALID_DWP_HANDLE = 1405L;
//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
// Cannot create a top-level child window.
//
static const long ERROR_TLW_WITH_WSCHILD = 1406L;
//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
// Cannot find window class.
//
static const long ERROR_CANNOT_FIND_WND_CLASS = 1407L;
//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
// Invalid window; it belongs to other thread.
//
static const long ERROR_WINDOW_OF_OTHER_THREAD = 1408L;
//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
// Hot key is already registered.
//
static const long ERROR_HOTKEY_ALREADY_REGISTERED = 1409L;
//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
// Class already exists.
//
static const long ERROR_CLASS_ALREADY_EXISTS = 1410L;
//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
// Class does not exist.
//
static const long ERROR_CLASS_DOES_NOT_EXIST = 1411L;
//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
// Class still has open windows.
//
static const long ERROR_CLASS_HAS_WINDOWS = 1412L;
//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
// Invalid index.
//
static const long ERROR_INVALID_INDEX = 1413L;
//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
// Invalid icon handle.
//
static const long ERROR_INVALID_ICON_HANDLE = 1414L;
//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
// Using private DIALOG window words.
//
static const long ERROR_PRIVATE_DIALOG_INDEX = 1415L;
//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
// The list box identifier was not found.
//
static const long ERROR_LISTBOX_ID_NOT_FOUND = 1416L;
//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
// No wildcards were found.
//
static const long ERROR_NO_WILDCARD_CHARACTERS = 1417L;
//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
// Thread does not have a clipboard open.
//
static const long ERROR_CLIPBOARD_NOT_OPEN = 1418L;
//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
// Hot key is not registered.
//
static const long ERROR_HOTKEY_NOT_REGISTERED = 1419L;
//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
// The window is not a valid dialog window.
//
static const long ERROR_WINDOW_NOT_DIALOG = 1420L;
//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
// Control ID not found.
//
static const long ERROR_CONTROL_ID_NOT_FOUND = 1421L;
//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
// Invalid message for a combo box because it does not have an edit control.
//
static const long ERROR_INVALID_COMBOBOX_MESSAGE = 1422L;
//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
// The window is not a combo box.
//
static const long ERROR_WINDOW_NOT_COMBOBOX = 1423L;
//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
// Height must be less than 256.
//
static const long ERROR_INVALID_EDIT_HEIGHT = 1424L;
//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
// Invalid device context (DC) handle.
//
static const long ERROR_DC_NOT_FOUND = 1425L;
//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
// Invalid hook procedure type.
//
static const long ERROR_INVALID_HOOK_FILTER = 1426L;
//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
// Invalid hook procedure.
//
static const long ERROR_INVALID_FILTER_PROC = 1427L;
//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
// Cannot set nonlocal hook without a module handle.
//
static const long ERROR_HOOK_NEEDS_HMOD = 1428L;
//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
// This hook procedure can only be set globally.
//
static const long ERROR_GLOBAL_ONLY_HOOK = 1429L;
//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
// The journal hook procedure is already installed.
//
static const long ERROR_JOURNAL_HOOK_SET = 1430L;
//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
// The hook procedure is not installed.
//
static const long ERROR_HOOK_NOT_INSTALLED = 1431L;
//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
// Invalid message for single-selection list box.
//
static const long ERROR_INVALID_LB_MESSAGE = 1432L;
//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
// LB_SETCOUNT sent to non-lazy list box.
//
static const long ERROR_SETCOUNT_ON_BAD_LB = 1433L;
//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
// This list box does not support tab stops.
//
static const long ERROR_LB_WITHOUT_TABSTOPS = 1434L;
//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
// Cannot destroy object created by another thread.
//
static const long ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 1435L;
//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
// Child windows cannot have menus.
//
static const long ERROR_CHILD_WINDOW_MENU = 1436L;
//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
// The window does not have a system menu.
//
static const long ERROR_NO_SYSTEM_MENU = 1437L;
//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
// Invalid message box style.
//
static const long ERROR_INVALID_MSGBOX_STYLE = 1438L;
//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
// Invalid system-wide (SPI_*) parameter.
//
static const long ERROR_INVALID_SPI_VALUE = 1439L;
//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
// Screen already locked.
//
static const long ERROR_SCREEN_ALREADY_LOCKED = 1440L;
//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
// All handles to windows in a multiple-window position structure must have the same parent.
//
static const long ERROR_HWNDS_HAVE_DIFF_PARENT = 1441L;
//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
// The window is not a child window.
//
static const long ERROR_NOT_CHILD_WINDOW = 1442L;
//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
// Invalid GW_* command.
//
static const long ERROR_INVALID_GW_COMMAND = 1443L;
//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
// Invalid thread identifier.
//
static const long ERROR_INVALID_THREAD_ID = 1444L;
//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
// Cannot process a message from a window that is not a multiple document interface (MDI) window.
//
static const long ERROR_NON_MDICHILD_WINDOW = 1445L;
//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
// Popup menu already active.
//
static const long ERROR_POPUP_ALREADY_ACTIVE = 1446L;
//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
// The window does not have scroll bars.
//
static const long ERROR_NO_SCROLLBARS = 1447L;
//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
// Scroll bar range cannot be greater than MAXLONG.
//
static const long ERROR_INVALID_SCROLLBAR_RANGE = 1448L;
//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
// Cannot show or remove the window in the way specified.
//
static const long ERROR_INVALID_SHOWWIN_COMMAND = 1449L;
//
// MessageId: ERROR_NO_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//
static const long ERROR_NO_SYSTEM_RESOURCES = 1450L;
//
// MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//
static const long ERROR_NONPAGED_SYSTEM_RESOURCES = 1451L;
//
// MessageId: ERROR_PAGED_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//
static const long ERROR_PAGED_SYSTEM_RESOURCES = 1452L;
//
// MessageId: ERROR_WORKING_SET_QUOTA
//
// MessageText:
//
// Insufficient quota to complete the requested service.
//
static const long ERROR_WORKING_SET_QUOTA = 1453L;
//
// MessageId: ERROR_PAGEFILE_QUOTA
//
// MessageText:
//
// Insufficient quota to complete the requested service.
//
static const long ERROR_PAGEFILE_QUOTA = 1454L;
//
// MessageId: ERROR_COMMITMENT_LIMIT
//
// MessageText:
//
// The paging file is too small for this operation to complete.
//
static const long ERROR_COMMITMENT_LIMIT = 1455L;
//
// MessageId: ERROR_MENU_ITEM_NOT_FOUND
//
// MessageText:
//
// A menu item was not found.
//
static const long ERROR_MENU_ITEM_NOT_FOUND = 1456L;
//
// MessageId: ERROR_INVALID_KEYBOARD_HANDLE
//
// MessageText:
//
// Invalid keyboard layout handle.
//
static const long ERROR_INVALID_KEYBOARD_HANDLE = 1457L;
//
// MessageId: ERROR_HOOK_TYPE_NOT_ALLOWED
//
// MessageText:
//
// Hook type not allowed.
//
static const long ERROR_HOOK_TYPE_NOT_ALLOWED = 1458L;
//
// MessageId: ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
//
// MessageText:
//
// This operation requires an interactive window station.
//
static const long ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 1459L;
//
// MessageId: ERROR_TIMEOUT
//
// MessageText:
//
// This operation returned because the timeout period expired.
//
static const long ERROR_TIMEOUT = 1460L;
//
// MessageId: ERROR_INVALID_MONITOR_HANDLE
//
// MessageText:
//
// Invalid monitor handle.
//
static const long ERROR_INVALID_MONITOR_HANDLE = 1461L;
//
// MessageId: ERROR_INCORRECT_SIZE
//
// MessageText:
//
// Incorrect size argument.
//
static const long ERROR_INCORRECT_SIZE = 1462L;
//
// MessageId: ERROR_SYMLINK_CLASS_DISABLED
//
// MessageText:
//
// The symbolic link cannot be followed because its type is disabled.
//
static const long ERROR_SYMLINK_CLASS_DISABLED = 1463L;
//
// MessageId: ERROR_SYMLINK_NOT_SUPPORTED
//
// MessageText:
//
// This application does not support the current operation on symbolic links.
//
static const long ERROR_SYMLINK_NOT_SUPPORTED = 1464L;
//
// MessageId: ERROR_XML_PARSE_ERROR
//
// MessageText:
//
// Windows was unable to parse the requested XML data.
//
static const long ERROR_XML_PARSE_ERROR = 1465L;
//
// MessageId: ERROR_XMLDSIG_ERROR
//
// MessageText:
//
// An error was encountered while processing an XML digital signature.
//
static const long ERROR_XMLDSIG_ERROR = 1466L;
//
// MessageId: ERROR_RESTART_APPLICATION
//
// MessageText:
//
// This application must be restarted.
//
static const long ERROR_RESTART_APPLICATION = 1467L;
//
// MessageId: ERROR_WRONG_COMPARTMENT
//
// MessageText:
//
// The caller made the connection request in the wrong routing compartment.
//
static const long ERROR_WRONG_COMPARTMENT = 1468L;
//
// MessageId: ERROR_AUTHIP_FAILURE
//
// MessageText:
//
// There was an AuthIP failure when attempting to connect to the remote host.
//
static const long ERROR_AUTHIP_FAILURE = 1469L;
//
// MessageId: ERROR_NO_NVRAM_RESOURCES
//
// MessageText:
//
// Insufficient NVRAM resources exist to complete the requested service. A reboot might be required.
//
static const long ERROR_NO_NVRAM_RESOURCES = 1470L;
///////////////////////////////////////////////////
//                                               //
//             EventLog Error codes              //
//                                               //
//                 1500 to 1549                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
// The event log file is corrupted.
//
static const long ERROR_EVENTLOG_FILE_CORRUPT = 1500L;
//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
// No event log file could be opened, so the event logging service did not start.
//
static const long ERROR_EVENTLOG_CANT_START = 1501L;
//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
// The event log file is full.
//
static const long ERROR_LOG_FILE_FULL = 1502L;
//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
// The event log file has changed between read operations.
//
static const long ERROR_EVENTLOG_FILE_CHANGED = 1503L;
///////////////////////////////////////////////////
//                                               //
//            Class Scheduler Error codes        //
//                                               //
//                 1550 to 1599                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INVALID_TASK_NAME
//
// MessageText:
//
// The specified task name is invalid.
//
static const long ERROR_INVALID_TASK_NAME = 1550L;
//
// MessageId: ERROR_INVALID_TASK_INDEX
//
// MessageText:
//
// The specified task index is invalid.
//
static const long ERROR_INVALID_TASK_INDEX = 1551L;
//
// MessageId: ERROR_THREAD_ALREADY_IN_TASK
//
// MessageText:
//
// The specified thread is already joining a task.
//
static const long ERROR_THREAD_ALREADY_IN_TASK = 1552L;
///////////////////////////////////////////////////
//                                               //
//                MSI Error codes                //
//                                               //
//                 1600 to 1699                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INSTALL_SERVICE_FAILURE
//
// MessageText:
//
// The Windows Installer Service could not be accessed. This can occur if the Windows Installer is not correctly installed. Contact your support personnel for assistance.
//
static const long ERROR_INSTALL_SERVICE_FAILURE = 1601L;
//
// MessageId: ERROR_INSTALL_USEREXIT
//
// MessageText:
//
// User cancelled installation.
//
static const long ERROR_INSTALL_USEREXIT = 1602L;
//
// MessageId: ERROR_INSTALL_FAILURE
//
// MessageText:
//
// Fatal error during installation.
//
static const long ERROR_INSTALL_FAILURE = 1603L;
//
// MessageId: ERROR_INSTALL_SUSPEND
//
// MessageText:
//
// Installation suspended, incomplete.
//
static const long ERROR_INSTALL_SUSPEND = 1604L;
//
// MessageId: ERROR_UNKNOWN_PRODUCT
//
// MessageText:
//
// This action is only valid for products that are currently installed.
//
static const long ERROR_UNKNOWN_PRODUCT = 1605L;
//
// MessageId: ERROR_UNKNOWN_FEATURE
//
// MessageText:
//
// Feature ID not registered.
//
static const long ERROR_UNKNOWN_FEATURE = 1606L;
//
// MessageId: ERROR_UNKNOWN_COMPONENT
//
// MessageText:
//
// Component ID not registered.
//
static const long ERROR_UNKNOWN_COMPONENT = 1607L;
//
// MessageId: ERROR_UNKNOWN_PROPERTY
//
// MessageText:
//
// Unknown property.
//
static const long ERROR_UNKNOWN_PROPERTY = 1608L;
//
// MessageId: ERROR_INVALID_HANDLE_STATE
//
// MessageText:
//
// Handle is in an invalid state.
//
static const long ERROR_INVALID_HANDLE_STATE = 1609L;
//
// MessageId: ERROR_BAD_CONFIGURATION
//
// MessageText:
//
// The configuration data for this product is corrupt. Contact your support personnel.
//
static const long ERROR_BAD_CONFIGURATION = 1610L;
//
// MessageId: ERROR_INDEX_ABSENT
//
// MessageText:
//
// Component qualifier not present.
//
static const long ERROR_INDEX_ABSENT = 1611L;
//
// MessageId: ERROR_INSTALL_SOURCE_ABSENT
//
// MessageText:
//
// The installation source for this product is not available. Verify that the source exists and that you can access it.
//
static const long ERROR_INSTALL_SOURCE_ABSENT = 1612L;
//
// MessageId: ERROR_INSTALL_PACKAGE_VERSION
//
// MessageText:
//
// This installation package cannot be installed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
//
static const long ERROR_INSTALL_PACKAGE_VERSION = 1613L;
//
// MessageId: ERROR_PRODUCT_UNINSTALLED
//
// MessageText:
//
// Product is uninstalled.
//
static const long ERROR_PRODUCT_UNINSTALLED = 1614L;
//
// MessageId: ERROR_BAD_QUERY_SYNTAX
//
// MessageText:
//
// SQL query syntax invalid or unsupported.
//
static const long ERROR_BAD_QUERY_SYNTAX = 1615L;
//
// MessageId: ERROR_INVALID_FIELD
//
// MessageText:
//
// Record field does not exist.
//
static const long ERROR_INVALID_FIELD = 1616L;
//
// MessageId: ERROR_DEVICE_REMOVED
//
// MessageText:
//
// The device has been removed.
//
static const long ERROR_DEVICE_REMOVED = 1617L;
//
// MessageId: ERROR_INSTALL_ALREADY_RUNNING
//
// MessageText:
//
// Another installation is already in progress. Complete that installation before proceeding with this install.
//
static const long ERROR_INSTALL_ALREADY_RUNNING = 1618L;
//
// MessageId: ERROR_INSTALL_PACKAGE_OPEN_FAILED
//
// MessageText:
//
// This installation package could not be opened. Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.
//
static const long ERROR_INSTALL_PACKAGE_OPEN_FAILED = 1619L;
//
// MessageId: ERROR_INSTALL_PACKAGE_INVALID
//
// MessageText:
//
// This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer package.
//
static const long ERROR_INSTALL_PACKAGE_INVALID = 1620L;
//
// MessageId: ERROR_INSTALL_UI_FAILURE
//
// MessageText:
//
// There was an error starting the Windows Installer service user interface. Contact your support personnel.
//
static const long ERROR_INSTALL_UI_FAILURE = 1621L;
//
// MessageId: ERROR_INSTALL_LOG_FAILURE
//
// MessageText:
//
// Error opening installation log file. Verify that the specified log file location exists and that you can write to it.
//
static const long ERROR_INSTALL_LOG_FAILURE = 1622L;
//
// MessageId: ERROR_INSTALL_LANGUAGE_UNSUPPORTED
//
// MessageText:
//
// The language of this installation package is not supported by your system.
//
static const long ERROR_INSTALL_LANGUAGE_UNSUPPORTED = 1623L;
//
// MessageId: ERROR_INSTALL_TRANSFORM_FAILURE
//
// MessageText:
//
// Error applying transforms. Verify that the specified transform paths are valid.
//
static const long ERROR_INSTALL_TRANSFORM_FAILURE = 1624L;
//
// MessageId: ERROR_INSTALL_PACKAGE_REJECTED
//
// MessageText:
//
// This installation is forbidden by system policy. Contact your system administrator.
//
static const long ERROR_INSTALL_PACKAGE_REJECTED = 1625L;
//
// MessageId: ERROR_FUNCTION_NOT_CALLED
//
// MessageText:
//
// Function could not be executed.
//
static const long ERROR_FUNCTION_NOT_CALLED = 1626L;
//
// MessageId: ERROR_FUNCTION_FAILED
//
// MessageText:
//
// Function failed during execution.
//
static const long ERROR_FUNCTION_FAILED = 1627L;
//
// MessageId: ERROR_INVALID_TABLE
//
// MessageText:
//
// Invalid or unknown table specified.
//
static const long ERROR_INVALID_TABLE = 1628L;
//
// MessageId: ERROR_DATATYPE_MISMATCH
//
// MessageText:
//
// Data supplied is of wrong type.
//
static const long ERROR_DATATYPE_MISMATCH = 1629L;
//
// MessageId: ERROR_UNSUPPORTED_TYPE
//
// MessageText:
//
// Data of this type is not supported.
//
static const long ERROR_UNSUPPORTED_TYPE = 1630L;
//
// MessageId: ERROR_CREATE_FAILED
//
// MessageText:
//
// The Windows Installer service failed to start. Contact your support personnel.
//
static const long ERROR_CREATE_FAILED = 1631L;
//
// MessageId: ERROR_INSTALL_TEMP_UNWRITABLE
//
// MessageText:
//
// The Temp folder is on a drive that is full or is inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.
//
static const long ERROR_INSTALL_TEMP_UNWRITABLE = 1632L;
//
// MessageId: ERROR_INSTALL_PLATFORM_UNSUPPORTED
//
// MessageText:
//
// This installation package is not supported by this processor type. Contact your product vendor.
//
static const long ERROR_INSTALL_PLATFORM_UNSUPPORTED = 1633L;
//
// MessageId: ERROR_INSTALL_NOTUSED
//
// MessageText:
//
// Component not used on this computer.
//
static const long ERROR_INSTALL_NOTUSED = 1634L;
//
// MessageId: ERROR_PATCH_PACKAGE_OPEN_FAILED
//
// MessageText:
//
// This update package could not be opened. Verify that the update package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer update package.
//
static const long ERROR_PATCH_PACKAGE_OPEN_FAILED = 1635L;
//
// MessageId: ERROR_PATCH_PACKAGE_INVALID
//
// MessageText:
//
// This update package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer update package.
//
static const long ERROR_PATCH_PACKAGE_INVALID = 1636L;
//
// MessageId: ERROR_PATCH_PACKAGE_UNSUPPORTED
//
// MessageText:
//
// This update package cannot be processed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
//
static const long ERROR_PATCH_PACKAGE_UNSUPPORTED = 1637L;
//
// MessageId: ERROR_PRODUCT_VERSION
//
// MessageText:
//
// Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.
//
static const long ERROR_PRODUCT_VERSION = 1638L;
//
// MessageId: ERROR_INVALID_COMMAND_LINE
//
// MessageText:
//
// Invalid command line argument. Consult the Windows Installer SDK for detailed command line help.
//
static const long ERROR_INVALID_COMMAND_LINE = 1639L;
//
// MessageId: ERROR_INSTALL_REMOTE_DISALLOWED
//
// MessageText:
//
// Only administrators have permission to add, remove, or configure server software during a Terminal services remote session. If you want to install or configure software on the server, contact your network administrator.
//
static const long ERROR_INSTALL_REMOTE_DISALLOWED = 1640L;
//
// MessageId: ERROR_SUCCESS_REBOOT_INITIATED
//
// MessageText:
//
// The requested operation completed successfully. The system will be restarted so the changes can take effect.
//
static const long ERROR_SUCCESS_REBOOT_INITIATED = 1641L;
//
// MessageId: ERROR_PATCH_TARGET_NOT_FOUND
//
// MessageText:
//
// The upgrade cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade.
//
static const long ERROR_PATCH_TARGET_NOT_FOUND = 1642L;
//
// MessageId: ERROR_PATCH_PACKAGE_REJECTED
//
// MessageText:
//
// The update package is not permitted by software restriction policy.
//
static const long ERROR_PATCH_PACKAGE_REJECTED = 1643L;
//
// MessageId: ERROR_INSTALL_TRANSFORM_REJECTED
//
// MessageText:
//
// One or more customizations are not permitted by software restriction policy.
//
static const long ERROR_INSTALL_TRANSFORM_REJECTED = 1644L;
//
// MessageId: ERROR_INSTALL_REMOTE_PROHIBITED
//
// MessageText:
//
// The Windows Installer does not permit installation from a Remote Desktop Connection.
//
static const long ERROR_INSTALL_REMOTE_PROHIBITED = 1645L;
//
// MessageId: ERROR_PATCH_REMOVAL_UNSUPPORTED
//
// MessageText:
//
// Uninstallation of the update package is not supported.
//
static const long ERROR_PATCH_REMOVAL_UNSUPPORTED = 1646L;
//
// MessageId: ERROR_UNKNOWN_PATCH
//
// MessageText:
//
// The update is not applied to this product.
//
static const long ERROR_UNKNOWN_PATCH = 1647L;
//
// MessageId: ERROR_PATCH_NO_SEQUENCE
//
// MessageText:
//
// No valid sequence could be found for the set of updates.
//
static const long ERROR_PATCH_NO_SEQUENCE = 1648L;
//
// MessageId: ERROR_PATCH_REMOVAL_DISALLOWED
//
// MessageText:
//
// Update removal was disallowed by policy.
//
static const long ERROR_PATCH_REMOVAL_DISALLOWED = 1649L;
//
// MessageId: ERROR_INVALID_PATCH_XML
//
// MessageText:
//
// The XML update data is invalid.
//
static const long ERROR_INVALID_PATCH_XML = 1650L;
//
// MessageId: ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT
//
// MessageText:
//
// Windows Installer does not permit updating of managed advertised products. At least one feature of the product must be installed before applying the update.
//
static const long ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = 1651L;
//
// MessageId: ERROR_INSTALL_SERVICE_SAFEBOOT
//
// MessageText:
//
// The Windows Installer service is not accessible in Safe Mode. Please try again when your computer is not in Safe Mode or you can use System Restore to return your machine to a previous good state.
//
static const long ERROR_INSTALL_SERVICE_SAFEBOOT = 1652L;
//
// MessageId: ERROR_FAIL_FAST_EXCEPTION
//
// MessageText:
//
// A fail fast exception occurred. Exception handlers will not be invoked and the process will be terminated immediately.
//
static const long ERROR_FAIL_FAST_EXCEPTION = 1653L;
///////////////////////////////////////////////////
//                                               //
//               RPC Error codes                 //
//                                               //
//                 1700 to 1999                  //
///////////////////////////////////////////////////
//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
// The string binding is invalid.
//
static const long RPC_S_INVALID_STRING_BINDING = 1700L;
//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
// The binding handle is not the correct type.
//
static const long RPC_S_WRONG_KIND_OF_BINDING = 1701L;
//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
// The binding handle is invalid.
//
static const long RPC_S_INVALID_BINDING = 1702L;
//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
// The RPC protocol sequence is not supported.
//
static const long RPC_S_PROTSEQ_NOT_SUPPORTED = 1703L;
//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
// The RPC protocol sequence is invalid.
//
static const long RPC_S_INVALID_RPC_PROTSEQ = 1704L;
//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
// The string universal unique identifier (UUID) is invalid.
//
static const long RPC_S_INVALID_STRING_UUID = 1705L;
//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
// The endpoint format is invalid.
//
static const long RPC_S_INVALID_ENDPOINT_FORMAT = 1706L;
//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
// The network address is invalid.
//
static const long RPC_S_INVALID_NET_ADDR = 1707L;
//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
// No endpoint was found.
//
static const long RPC_S_NO_ENDPOINT_FOUND = 1708L;
//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
// The timeout value is invalid.
//
static const long RPC_S_INVALID_TIMEOUT = 1709L;
//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object universal unique identifier (UUID) was not found.
//
static const long RPC_S_OBJECT_NOT_FOUND = 1710L;
//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
// The object universal unique identifier (UUID) has already been registered.
//
static const long RPC_S_ALREADY_REGISTERED = 1711L;
//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
// The type universal unique identifier (UUID) has already been registered.
//
static const long RPC_S_TYPE_ALREADY_REGISTERED = 1712L;
//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
// The RPC server is already listening.
//
static const long RPC_S_ALREADY_LISTENING = 1713L;
//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
// No protocol sequences have been registered.
//
static const long RPC_S_NO_PROTSEQS_REGISTERED = 1714L;
//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
// The RPC server is not listening.
//
static const long RPC_S_NOT_LISTENING = 1715L;
//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
// The manager type is unknown.
//
static const long RPC_S_UNKNOWN_MGR_TYPE = 1716L;
//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
// The interface is unknown.
//
static const long RPC_S_UNKNOWN_IF = 1717L;
//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
// There are no bindings.
//
static const long RPC_S_NO_BINDINGS = 1718L;
//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
// There are no protocol sequences.
//
static const long RPC_S_NO_PROTSEQS = 1719L;
//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
// The endpoint cannot be created.
//
static const long RPC_S_CANT_CREATE_ENDPOINT = 1720L;
//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
// Not enough resources are available to complete this operation.
//
static const long RPC_S_OUT_OF_RESOURCES = 1721L;
//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
// The RPC server is unavailable.
//
static const long RPC_S_SERVER_UNAVAILABLE = 1722L;
//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
// The RPC server is too busy to complete this operation.
//
static const long RPC_S_SERVER_TOO_BUSY = 1723L;
//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
// The network options are invalid.
//
static const long RPC_S_INVALID_NETWORK_OPTIONS = 1724L;
//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
// There are no remote procedure calls active on this thread.
//
static const long RPC_S_NO_CALL_ACTIVE = 1725L;
//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
// The remote procedure call failed.
//
static const long RPC_S_CALL_FAILED = 1726L;
//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
// The remote procedure call failed and did not execute.
//
static const long RPC_S_CALL_FAILED_DNE = 1727L;
//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
// A remote procedure call (RPC) protocol error occurred.
//
static const long RPC_S_PROTOCOL_ERROR = 1728L;
//
// MessageId: RPC_S_PROXY_ACCESS_DENIED
//
// MessageText:
//
// Access to the HTTP proxy is denied.
//
static const long RPC_S_PROXY_ACCESS_DENIED = 1729L;
//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
// The transfer syntax is not supported by the RPC server.
//
static const long RPC_S_UNSUPPORTED_TRANS_SYN = 1730L;
//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
// The universal unique identifier (UUID) type is not supported.
//
static const long RPC_S_UNSUPPORTED_TYPE = 1732L;
//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
// The tag is invalid.
//
static const long RPC_S_INVALID_TAG = 1733L;
//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
// The array bounds are invalid.
//
static const long RPC_S_INVALID_BOUND = 1734L;
//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
// The binding does not contain an entry name.
//
static const long RPC_S_NO_ENTRY_NAME = 1735L;
//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is invalid.
//
static const long RPC_S_INVALID_NAME_SYNTAX = 1736L;
//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is not supported.
//
static const long RPC_S_UNSUPPORTED_NAME_SYNTAX = 1737L;
//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
// No network address is available to use to construct a universal unique identifier (UUID).
//
static const long RPC_S_UUID_NO_ADDRESS = 1739L;
//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
// The endpoint is a duplicate.
//
static const long RPC_S_DUPLICATE_ENDPOINT = 1740L;
//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
// The authentication type is unknown.
//
static const long RPC_S_UNKNOWN_AUTHN_TYPE = 1741L;
//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
// The maximum number of calls is too small.
//
static const long RPC_S_MAX_CALLS_TOO_SMALL = 1742L;
//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
// The string is too long.
//
static const long RPC_S_STRING_TOO_LONG = 1743L;
//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
// The RPC protocol sequence was not found.
//
static const long RPC_S_PROTSEQ_NOT_FOUND = 1744L;
//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
// The procedure number is out of range.
//
static const long RPC_S_PROCNUM_OUT_OF_RANGE = 1745L;
//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
// The binding does not contain any authentication information.
//
static const long RPC_S_BINDING_HAS_NO_AUTH = 1746L;
//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
// The authentication service is unknown.
//
static const long RPC_S_UNKNOWN_AUTHN_SERVICE = 1747L;
//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
// The authentication level is unknown.
//
static const long RPC_S_UNKNOWN_AUTHN_LEVEL = 1748L;
//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
// The security context is invalid.
//
static const long RPC_S_INVALID_AUTH_IDENTITY = 1749L;
//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
// The authorization service is unknown.
//
static const long RPC_S_UNKNOWN_AUTHZ_SERVICE = 1750L;
//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
// The entry is invalid.
//
static const long EPT_S_INVALID_ENTRY = 1751L;
//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
// The server endpoint cannot perform the operation.
//
static const long EPT_S_CANT_PERFORM_OP = 1752L;
//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
// There are no more endpoints available from the endpoint mapper.
//
static const long EPT_S_NOT_REGISTERED = 1753L;
//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
// No interfaces have been exported.
//
static const long RPC_S_NOTHING_TO_EXPORT = 1754L;
//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
// The entry name is incomplete.
//
static const long RPC_S_INCOMPLETE_NAME = 1755L;
//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
// The version option is invalid.
//
static const long RPC_S_INVALID_VERS_OPTION = 1756L;
//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
// There are no more members.
//
static const long RPC_S_NO_MORE_MEMBERS = 1757L;
//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
// There is nothing to unexport.
//
static const long RPC_S_NOT_ALL_OBJS_UNEXPORTED = 1758L;
//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
// The interface was not found.
//
static const long RPC_S_INTERFACE_NOT_FOUND = 1759L;
//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
// The entry already exists.
//
static const long RPC_S_ENTRY_ALREADY_EXISTS = 1760L;
//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
// The entry is not found.
//
static const long RPC_S_ENTRY_NOT_FOUND = 1761L;
//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The name service is unavailable.
//
static const long RPC_S_NAME_SERVICE_UNAVAILABLE = 1762L;
//
// MessageId: RPC_S_INVALID_NAF_ID
//
// MessageText:
//
// The network address family is invalid.
//
static const long RPC_S_INVALID_NAF_ID = 1763L;
//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
// The requested operation is not supported.
//
static const long RPC_S_CANNOT_SUPPORT = 1764L;
//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
// No security context is available to allow impersonation.
//
static const long RPC_S_NO_CONTEXT_AVAILABLE = 1765L;
//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred in a remote procedure call (RPC).
//
static const long RPC_S_INTERNAL_ERROR = 1766L;
//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
// The RPC server attempted an integer division by zero.
//
static const long RPC_S_ZERO_DIVIDE = 1767L;
//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
// An addressing error occurred in the RPC server.
//
static const long RPC_S_ADDRESS_ERROR = 1768L;
//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
// A floating-point operation at the RPC server caused a division by zero.
//
static const long RPC_S_FP_DIV_ZERO = 1769L;
//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
// A floating-point underflow occurred at the RPC server.
//
static const long RPC_S_FP_UNDERFLOW = 1770L;
//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
// A floating-point overflow occurred at the RPC server.
//
static const long RPC_S_FP_OVERFLOW = 1771L;
//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
// The list of RPC servers available for the binding of auto handles has been exhausted.
//
static const long RPC_X_NO_MORE_ENTRIES = 1772L;
//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
// Unable to open the character translation table file.
//
static const long RPC_X_SS_CHAR_TRANS_OPEN_FAIL = 1773L;
//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
// The file containing the character translation table has fewer than 512 bytes.
//
static const long RPC_X_SS_CHAR_TRANS_SHORT_FILE = 1774L;
//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
// A null context handle was passed from the client to the host during a remote procedure call.
//
static const long RPC_X_SS_IN_NULL_CONTEXT = 1775L;
//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
// The context handle changed during a remote procedure call.
//
static const long RPC_X_SS_CONTEXT_DAMAGED = 1777L;
//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
// The binding handles passed to a remote procedure call do not match.
//
static const long RPC_X_SS_HANDLES_MISMATCH = 1778L;
//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
// The stub is unable to get the remote procedure call handle.
//
static const long RPC_X_SS_CANNOT_GET_CALL_HANDLE = 1779L;
//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
// A null reference pointer was passed to the stub.
//
static const long RPC_X_NULL_REF_POINTER = 1780L;
//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The enumeration value is out of range.
//
static const long RPC_X_ENUM_VALUE_OUT_OF_RANGE = 1781L;
//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
// The byte count is too small.
//
static const long RPC_X_BYTE_COUNT_TOO_SMALL = 1782L;
//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
// The stub received bad data.
//
static const long RPC_X_BAD_STUB_DATA = 1783L;
//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
// The supplied user buffer is not valid for the requested operation.
//
static const long ERROR_INVALID_USER_BUFFER = 1784L;
//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
// The disk media is not recognized. It may not be formatted.
//
static const long ERROR_UNRECOGNIZED_MEDIA = 1785L;
//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
// The workstation does not have a trust secret.
//
static const long ERROR_NO_TRUST_LSA_SECRET = 1786L;
//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
// The security database on the server does not have a computer account for this workstation trust relationship.
//
static const long ERROR_NO_TRUST_SAM_ACCOUNT = 1787L;
//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
// The trust relationship between the primary domain and the trusted domain failed.
//
static const long ERROR_TRUSTED_DOMAIN_FAILURE = 1788L;
//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
// The trust relationship between this workstation and the primary domain failed.
//
static const long ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789L;
//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
// The network logon failed.
//
static const long ERROR_TRUST_FAILURE = 1790L;
//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
// A remote procedure call is already in progress for this thread.
//
static const long RPC_S_CALL_IN_PROGRESS = 1791L;
//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
// An attempt was made to logon, but the network logon service was not started.
//
static const long ERROR_NETLOGON_NOT_STARTED = 1792L;
//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
// The user's account has expired.
//
static const long ERROR_ACCOUNT_EXPIRED = 1793L;
//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
// The redirector is in use and cannot be unloaded.
//
static const long ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 1794L;
//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
// The specified printer driver is already installed.
//
static const long ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 1795L;
//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
// The specified port is unknown.
//
static const long ERROR_UNKNOWN_PORT = 1796L;
//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
// The printer driver is unknown.
//
static const long ERROR_UNKNOWN_PRINTER_DRIVER = 1797L;
//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
// The print processor is unknown.
//
static const long ERROR_UNKNOWN_PRINTPROCESSOR = 1798L;
//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
// The specified separator file is invalid.
//
static const long ERROR_INVALID_SEPARATOR_FILE = 1799L;
//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
// The specified priority is invalid.
//
static const long ERROR_INVALID_PRIORITY = 1800L;
//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
// The printer name is invalid.
//
static const long ERROR_INVALID_PRINTER_NAME = 1801L;
//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
// The printer already exists.
//
static const long ERROR_PRINTER_ALREADY_EXISTS = 1802L;
//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
// The printer command is invalid.
//
static const long ERROR_INVALID_PRINTER_COMMAND = 1803L;
//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
// The specified datatype is invalid.
//
static const long ERROR_INVALID_DATATYPE = 1804L;
//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
// The environment specified is invalid.
//
static const long ERROR_INVALID_ENVIRONMENT = 1805L;
//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
// There are no more bindings.
//
static const long RPC_S_NO_MORE_BINDINGS = 1806L;
//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is an interdomain trust account. Use your global user account or local user account to access this server.
//
static const long ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 1807L;
//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is a computer account. Use your global user account or local user account to access this server.
//
static const long ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 1808L;
//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is a server trust account. Use your global user account or local user account to access this server.
//
static const long ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 1809L;
//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
// The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.
//
static const long ERROR_DOMAIN_TRUST_INCONSISTENT = 1810L;
//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
// The server is in use and cannot be unloaded.
//
static const long ERROR_SERVER_HAS_OPEN_HANDLES = 1811L;
//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
// The specified image file did not contain a resource section.
//
static const long ERROR_RESOURCE_DATA_NOT_FOUND = 1812L;
//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
// The specified resource type cannot be found in the image file.
//
static const long ERROR_RESOURCE_TYPE_NOT_FOUND = 1813L;
//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
// The specified resource name cannot be found in the image file.
//
static const long ERROR_RESOURCE_NAME_NOT_FOUND = 1814L;
//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
// The specified resource language ID cannot be found in the image file.
//
static const long ERROR_RESOURCE_LANG_NOT_FOUND = 1815L;
//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
// Not enough quota is available to process this command.
//
static const long ERROR_NOT_ENOUGH_QUOTA = 1816L;
//
// MessageId: RPC_S_NO_INTERFACES
//
// MessageText:
//
// No interfaces have been registered.
//
static const long RPC_S_NO_INTERFACES = 1817L;
//
// MessageId: RPC_S_CALL_CANCELLED
//
// MessageText:
//
// The remote procedure call was cancelled.
//
static const long RPC_S_CALL_CANCELLED = 1818L;
//
// MessageId: RPC_S_BINDING_INCOMPLETE
//
// MessageText:
//
// The binding handle does not contain all required information.
//
static const long RPC_S_BINDING_INCOMPLETE = 1819L;
//
// MessageId: RPC_S_COMM_FAILURE
//
// MessageText:
//
// A communications failure occurred during a remote procedure call.
//
static const long RPC_S_COMM_FAILURE = 1820L;
//
// MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
// The requested authentication level is not supported.
//
static const long RPC_S_UNSUPPORTED_AUTHN_LEVEL = 1821L;
//
// MessageId: RPC_S_NO_PRINC_NAME
//
// MessageText:
//
// No principal name registered.
//
static const long RPC_S_NO_PRINC_NAME = 1822L;
//
// MessageId: RPC_S_NOT_RPC_ERROR
//
// MessageText:
//
// The error specified is not a valid Windows RPC error code.
//
static const long RPC_S_NOT_RPC_ERROR = 1823L;
//
// MessageId: RPC_S_UUID_LOCAL_ONLY
//
// MessageText:
//
// A UUID that is valid only on this computer has been allocated.
//
static const long RPC_S_UUID_LOCAL_ONLY = 1824L;
//
// MessageId: RPC_S_SEC_PKG_ERROR
//
// MessageText:
//
// A security package specific error occurred.
//
static const long RPC_S_SEC_PKG_ERROR = 1825L;
//
// MessageId: RPC_S_NOT_CANCELLED
//
// MessageText:
//
// Thread is not canceled.
//
static const long RPC_S_NOT_CANCELLED = 1826L;
//
// MessageId: RPC_X_INVALID_ES_ACTION
//
// MessageText:
//
// Invalid operation on the encoding/decoding handle.
//
static const long RPC_X_INVALID_ES_ACTION = 1827L;
//
// MessageId: RPC_X_WRONG_ES_VERSION
//
// MessageText:
//
// Incompatible version of the serializing package.
//
static const long RPC_X_WRONG_ES_VERSION = 1828L;
//
// MessageId: RPC_X_WRONG_STUB_VERSION
//
// MessageText:
//
// Incompatible version of the RPC stub.
//
static const long RPC_X_WRONG_STUB_VERSION = 1829L;
//
// MessageId: RPC_X_INVALID_PIPE_OBJECT
//
// MessageText:
//
// The RPC pipe object is invalid or corrupted.
//
static const long RPC_X_INVALID_PIPE_OBJECT = 1830L;
//
// MessageId: RPC_X_WRONG_PIPE_ORDER
//
// MessageText:
//
// An invalid operation was attempted on an RPC pipe object.
//
static const long RPC_X_WRONG_PIPE_ORDER = 1831L;
//
// MessageId: RPC_X_WRONG_PIPE_VERSION
//
// MessageText:
//
// Unsupported RPC pipe version.
//
static const long RPC_X_WRONG_PIPE_VERSION = 1832L;
//
// MessageId: RPC_S_COOKIE_AUTH_FAILED
//
// MessageText:
//
// HTTP proxy server rejected the connection because the cookie authentication failed.
//
static const long RPC_S_COOKIE_AUTH_FAILED = 1833L;
//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
// The group member was not found.
//
static const long RPC_S_GROUP_MEMBER_NOT_FOUND = 1898L;
//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
// The endpoint mapper database entry could not be created.
//
static const long EPT_S_CANT_CREATE = 1899L;
//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
// The object universal unique identifier (UUID) is the nil UUID.
//
static const long RPC_S_INVALID_OBJECT = 1900L;
//
// MessageId: ERROR_INVALID_TIME
//
// MessageText:
//
// The specified time is invalid.
//
static const long ERROR_INVALID_TIME = 1901L;
//
// MessageId: ERROR_INVALID_FORM_NAME
//
// MessageText:
//
// The specified form name is invalid.
//
static const long ERROR_INVALID_FORM_NAME = 1902L;
//
// MessageId: ERROR_INVALID_FORM_SIZE
//
// MessageText:
//
// The specified form size is invalid.
//
static const long ERROR_INVALID_FORM_SIZE = 1903L;
//
// MessageId: ERROR_ALREADY_WAITING
//
// MessageText:
//
// The specified printer handle is already being waited on
//
static const long ERROR_ALREADY_WAITING = 1904L;
//
// MessageId: ERROR_PRINTER_DELETED
//
// MessageText:
//
// The specified printer has been deleted.
//
static const long ERROR_PRINTER_DELETED = 1905L;
//
// MessageId: ERROR_INVALID_PRINTER_STATE
//
// MessageText:
//
// The state of the printer is invalid.
//
static const long ERROR_INVALID_PRINTER_STATE = 1906L;
//
// MessageId: ERROR_PASSWORD_MUST_CHANGE
//
// MessageText:
//
// The user's password must be changed before logging on the first time.
//
static const long ERROR_PASSWORD_MUST_CHANGE = 1907L;
//
// MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
// Could not find the domain controller for this domain.
//
static const long ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 1908L;
//
// MessageId: ERROR_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
// The referenced account is currently locked out and may not be logged on to.
//
static const long ERROR_ACCOUNT_LOCKED_OUT = 1909L;
//
// MessageId: OR_INVALID_OXID
//
// MessageText:
//
// The object exporter specified was not found.
//
static const long OR_INVALID_OXID = 1910L;
//
// MessageId: OR_INVALID_OID
//
// MessageText:
//
// The object specified was not found.
//
static const long OR_INVALID_OID = 1911L;
//
// MessageId: OR_INVALID_SET
//
// MessageText:
//
// The object resolver set specified was not found.
//
static const long OR_INVALID_SET = 1912L;
//
// MessageId: RPC_S_SEND_INCOMPLETE
//
// MessageText:
//
// Some data remains to be sent in the request buffer.
//
static const long RPC_S_SEND_INCOMPLETE = 1913L;
//
// MessageId: RPC_S_INVALID_ASYNC_HANDLE
//
// MessageText:
//
// Invalid asynchronous remote procedure call handle.
//
static const long RPC_S_INVALID_ASYNC_HANDLE = 1914L;
//
// MessageId: RPC_S_INVALID_ASYNC_CALL
//
// MessageText:
//
// Invalid asynchronous RPC call handle for this operation.
//
static const long RPC_S_INVALID_ASYNC_CALL = 1915L;
//
// MessageId: RPC_X_PIPE_CLOSED
//
// MessageText:
//
// The RPC pipe object has already been closed.
//
static const long RPC_X_PIPE_CLOSED = 1916L;
//
// MessageId: RPC_X_PIPE_DISCIPLINE_ERROR
//
// MessageText:
//
// The RPC call completed before all pipes were processed.
//
static const long RPC_X_PIPE_DISCIPLINE_ERROR = 1917L;
//
// MessageId: RPC_X_PIPE_EMPTY
//
// MessageText:
//
// No more data is available from the RPC pipe.
//
static const long RPC_X_PIPE_EMPTY = 1918L;
//
// MessageId: ERROR_NO_SITENAME
//
// MessageText:
//
// No site name is available for this machine.
//
static const long ERROR_NO_SITENAME = 1919L;
//
// MessageId: ERROR_CANT_ACCESS_FILE
//
// MessageText:
//
// The file cannot be accessed by the system.
//
static const long ERROR_CANT_ACCESS_FILE = 1920L;
//
// MessageId: ERROR_CANT_RESOLVE_FILENAME
//
// MessageText:
//
// The name of the file cannot be resolved by the system.
//
static const long ERROR_CANT_RESOLVE_FILENAME = 1921L;
//
// MessageId: RPC_S_ENTRY_TYPE_MISMATCH
//
// MessageText:
//
// The entry is not of the expected type.
//
static const long RPC_S_ENTRY_TYPE_MISMATCH = 1922L;
//
// MessageId: RPC_S_NOT_ALL_OBJS_EXPORTED
//
// MessageText:
//
// Not all object UUIDs could be exported to the specified entry.
//
static const long RPC_S_NOT_ALL_OBJS_EXPORTED = 1923L;
//
// MessageId: RPC_S_INTERFACE_NOT_EXPORTED
//
// MessageText:
//
// Interface could not be exported to the specified entry.
//
static const long RPC_S_INTERFACE_NOT_EXPORTED = 1924L;
//
// MessageId: RPC_S_PROFILE_NOT_ADDED
//
// MessageText:
//
// The specified profile entry could not be added.
//
static const long RPC_S_PROFILE_NOT_ADDED = 1925L;
//
// MessageId: RPC_S_PRF_ELT_NOT_ADDED
//
// MessageText:
//
// The specified profile element could not be added.
//
static const long RPC_S_PRF_ELT_NOT_ADDED = 1926L;
//
// MessageId: RPC_S_PRF_ELT_NOT_REMOVED
//
// MessageText:
//
// The specified profile element could not be removed.
//
static const long RPC_S_PRF_ELT_NOT_REMOVED = 1927L;
//
// MessageId: RPC_S_GRP_ELT_NOT_ADDED
//
// MessageText:
//
// The group element could not be added.
//
static const long RPC_S_GRP_ELT_NOT_ADDED = 1928L;
//
// MessageId: RPC_S_GRP_ELT_NOT_REMOVED
//
// MessageText:
//
// The group element could not be removed.
//
static const long RPC_S_GRP_ELT_NOT_REMOVED = 1929L;
//
// MessageId: ERROR_KM_DRIVER_BLOCKED
//
// MessageText:
//
// The printer driver is not compatible with a policy enabled on your computer that blocks NT 4.0 drivers.
//
static const long ERROR_KM_DRIVER_BLOCKED = 1930L;
//
// MessageId: ERROR_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//
static const long ERROR_CONTEXT_EXPIRED = 1931L;
//
// MessageId: ERROR_PER_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust creation quota has been exceeded.
//
static const long ERROR_PER_USER_TRUST_QUOTA_EXCEEDED = 1932L;
//
// MessageId: ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The total delegated trust creation quota has been exceeded.
//
static const long ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = 1933L;
//
// MessageId: ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust deletion quota has been exceeded.
//
static const long ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED = 1934L;
//
// MessageId: ERROR_AUTHENTICATION_FIREWALL_FAILED
//
// MessageText:
//
// Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine.
//
static const long ERROR_AUTHENTICATION_FIREWALL_FAILED = 1935L;
//
// MessageId: ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED
//
// MessageText:
//
// Remote connections to the Print Spooler are blocked by a policy set on your machine.
//
static const long ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED = 1936L;
//
// MessageId: ERROR_NTLM_BLOCKED
//
// MessageText:
//
// Logon Failure: Authentication failed because NTLM authentication has been disabled.
//
static const long ERROR_NTLM_BLOCKED = 1937L;
///////////////////////////////////////////////////
//                                               //
//              OpenGL Error codes               //
//                                               //
//                 2000 to 2009                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INVALID_PIXEL_FORMAT
//
// MessageText:
//
// The pixel format is invalid.
//
static const long ERROR_INVALID_PIXEL_FORMAT = 2000L;
//
// MessageId: ERROR_BAD_DRIVER
//
// MessageText:
//
// The specified driver is invalid.
//
static const long ERROR_BAD_DRIVER = 2001L;
//
// MessageId: ERROR_INVALID_WINDOW_STYLE
//
// MessageText:
//
// The window style or class attribute is invalid for this operation.
//
static const long ERROR_INVALID_WINDOW_STYLE = 2002L;
//
// MessageId: ERROR_METAFILE_NOT_SUPPORTED
//
// MessageText:
//
// The requested metafile operation is not supported.
//
static const long ERROR_METAFILE_NOT_SUPPORTED = 2003L;
//
// MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
//
// MessageText:
//
// The requested transformation operation is not supported.
//
static const long ERROR_TRANSFORM_NOT_SUPPORTED = 2004L;
//
// MessageId: ERROR_CLIPPING_NOT_SUPPORTED
//
// MessageText:
//
// The requested clipping operation is not supported.
//
static const long ERROR_CLIPPING_NOT_SUPPORTED = 2005L;
///////////////////////////////////////////////////
//                                               //
//       Image Color Management Error codes      //
//                                               //
//                 2010 to 2049                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INVALID_CMM
//
// MessageText:
//
// The specified color management module is invalid.
//
static const long ERROR_INVALID_CMM = 2010L;
//
// MessageId: ERROR_INVALID_PROFILE
//
// MessageText:
//
// The specified color profile is invalid.
//
static const long ERROR_INVALID_PROFILE = 2011L;
//
// MessageId: ERROR_TAG_NOT_FOUND
//
// MessageText:
//
// The specified tag was not found.
//
static const long ERROR_TAG_NOT_FOUND = 2012L;
//
// MessageId: ERROR_TAG_NOT_PRESENT
//
// MessageText:
//
// A required tag is not present.
//
static const long ERROR_TAG_NOT_PRESENT = 2013L;
//
// MessageId: ERROR_DUPLICATE_TAG
//
// MessageText:
//
// The specified tag is already present.
//
static const long ERROR_DUPLICATE_TAG = 2014L;
//
// MessageId: ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
//
// MessageText:
//
// The specified color profile is not associated with the specified device.
//
static const long ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = 2015L;
//
// MessageId: ERROR_PROFILE_NOT_FOUND
//
// MessageText:
//
// The specified color profile was not found.
//
static const long ERROR_PROFILE_NOT_FOUND = 2016L;
//
// MessageId: ERROR_INVALID_COLORSPACE
//
// MessageText:
//
// The specified color space is invalid.
//
static const long ERROR_INVALID_COLORSPACE = 2017L;
//
// MessageId: ERROR_ICM_NOT_ENABLED
//
// MessageText:
//
// Image Color Management is not enabled.
//
static const long ERROR_ICM_NOT_ENABLED = 2018L;
//
// MessageId: ERROR_DELETING_ICM_XFORM
//
// MessageText:
//
// There was an error while deleting the color transform.
//
static const long ERROR_DELETING_ICM_XFORM = 2019L;
//
// MessageId: ERROR_INVALID_TRANSFORM
//
// MessageText:
//
// The specified color transform is invalid.
//
static const long ERROR_INVALID_TRANSFORM = 2020L;
//
// MessageId: ERROR_COLORSPACE_MISMATCH
//
// MessageText:
//
// The specified transform does not match the bitmap's color space.
//
static const long ERROR_COLORSPACE_MISMATCH = 2021L;
//
// MessageId: ERROR_INVALID_COLORINDEX
//
// MessageText:
//
// The specified named color index is not present in the profile.
//
static const long ERROR_INVALID_COLORINDEX = 2022L;
//
// MessageId: ERROR_PROFILE_DOES_NOT_MATCH_DEVICE
//
// MessageText:
//
// The specified profile is intended for a device of a different type than the specified device.
//
static const long ERROR_PROFILE_DOES_NOT_MATCH_DEVICE = 2023L;
///////////////////////////////////////////////////
//                                               //
//             Winnet32 Error codes              //
//                                               //
//                 2100 to 2999                  //
//                                               //
// The range 2100 through 2999 is reserved for   //
// network status codes. See lmerr.h for a       //
// complete listing                              //
///////////////////////////////////////////////////
//
// MessageId: ERROR_CONNECTED_OTHER_PASSWORD
//
// MessageText:
//
// The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.
//
static const long ERROR_CONNECTED_OTHER_PASSWORD = 2108L;
//
// MessageId: ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT
//
// MessageText:
//
// The network connection was made successfully using default credentials.
//
static const long ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = 2109L;
//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
// The specified username is invalid.
//
static const long ERROR_BAD_USERNAME = 2202L;
//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
// This network connection does not exist.
//
static const long ERROR_NOT_CONNECTED = 2250L;
//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
// This network connection has files open or requests pending.
//
static const long ERROR_OPEN_FILES = 2401L;
//
// MessageId: ERROR_ACTIVE_CONNECTIONS
//
// MessageText:
//
// Active connections still exist.
//
static const long ERROR_ACTIVE_CONNECTIONS = 2402L;
//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
// The device is in use by an active process and cannot be disconnected.
//
static const long ERROR_DEVICE_IN_USE = 2404L;
///////////////////////////////////////////////////
//                                               //
//           Win32 Spooler Error codes           //
//                                               //
//                 3000 to 3049                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_UNKNOWN_PRINT_MONITOR
//
// MessageText:
//
// The specified print monitor is unknown.
//
static const long ERROR_UNKNOWN_PRINT_MONITOR = 3000L;
//
// MessageId: ERROR_PRINTER_DRIVER_IN_USE
//
// MessageText:
//
// The specified printer driver is currently in use.
//
static const long ERROR_PRINTER_DRIVER_IN_USE = 3001L;
//
// MessageId: ERROR_SPOOL_FILE_NOT_FOUND
//
// MessageText:
//
// The spool file was not found.
//
static const long ERROR_SPOOL_FILE_NOT_FOUND = 3002L;
//
// MessageId: ERROR_SPL_NO_STARTDOC
//
// MessageText:
//
// A StartDocPrinter call was not issued.
//
static const long ERROR_SPL_NO_STARTDOC = 3003L;
//
// MessageId: ERROR_SPL_NO_ADDJOB
//
// MessageText:
//
// An AddJob call was not issued.
//
static const long ERROR_SPL_NO_ADDJOB = 3004L;
//
// MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
//
// MessageText:
//
// The specified print processor has already been installed.
//
static const long ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 3005L;
//
// MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
//
// MessageText:
//
// The specified print monitor has already been installed.
//
static const long ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 3006L;
//
// MessageId: ERROR_INVALID_PRINT_MONITOR
//
// MessageText:
//
// The specified print monitor does not have the required functions.
//
static const long ERROR_INVALID_PRINT_MONITOR = 3007L;
//
// MessageId: ERROR_PRINT_MONITOR_IN_USE
//
// MessageText:
//
// The specified print monitor is currently in use.
//
static const long ERROR_PRINT_MONITOR_IN_USE = 3008L;
//
// MessageId: ERROR_PRINTER_HAS_JOBS_QUEUED
//
// MessageText:
//
// The requested operation is not allowed when there are jobs queued to the printer.
//
static const long ERROR_PRINTER_HAS_JOBS_QUEUED = 3009L;
//
// MessageId: ERROR_SUCCESS_REBOOT_REQUIRED
//
// MessageText:
//
// The requested operation is successful. Changes will not be effective until the system is rebooted.
//
static const long ERROR_SUCCESS_REBOOT_REQUIRED = 3010L;
//
// MessageId: ERROR_SUCCESS_RESTART_REQUIRED
//
// MessageText:
//
// The requested operation is successful. Changes will not be effective until the service is restarted.
//
static const long ERROR_SUCCESS_RESTART_REQUIRED = 3011L;
//
// MessageId: ERROR_PRINTER_NOT_FOUND
//
// MessageText:
//
// No printers were found.
//
static const long ERROR_PRINTER_NOT_FOUND = 3012L;
//
// MessageId: ERROR_PRINTER_DRIVER_WARNED
//
// MessageText:
//
// The printer driver is known to be unreliable.
//
static const long ERROR_PRINTER_DRIVER_WARNED = 3013L;
//
// MessageId: ERROR_PRINTER_DRIVER_BLOCKED
//
// MessageText:
//
// The printer driver is known to harm the system.
//
static const long ERROR_PRINTER_DRIVER_BLOCKED = 3014L;
//
// MessageId: ERROR_PRINTER_DRIVER_PACKAGE_IN_USE
//
// MessageText:
//
// The specified printer driver package is currently in use.
//
static const long ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = 3015L;
//
// MessageId: ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND
//
// MessageText:
//
// Unable to find a core driver package that is required by the printer driver package.
//
static const long ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND = 3016L;
//
// MessageId: ERROR_FAIL_REBOOT_REQUIRED
//
// MessageText:
//
// The requested operation failed. A system reboot is required to roll back changes made.
//
static const long ERROR_FAIL_REBOOT_REQUIRED = 3017L;
//
// MessageId: ERROR_FAIL_REBOOT_INITIATED
//
// MessageText:
//
// The requested operation failed. A system reboot has been initiated to roll back changes made.
//
static const long ERROR_FAIL_REBOOT_INITIATED = 3018L;
//
// MessageId: ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED
//
// MessageText:
//
// The specified printer driver was not found on the system and needs to be downloaded.
//
static const long ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED = 3019L;
//
// MessageId: ERROR_PRINT_JOB_RESTART_REQUIRED
//
// MessageText:
//
// The requested print job has failed to print. A print system update requires the job to be resubmitted.
//
static const long ERROR_PRINT_JOB_RESTART_REQUIRED = 3020L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 3050 to 3199                  //
///////////////////////////////////////////////////
//
//               the message range
//                 3200 to 3299
//      is reserved and used in isolation lib
// 
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 3300 to 3899                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//                IO Error Codes                 //
//                                               //
//                 3900 to 3999                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_IO_REISSUE_AS_CACHED
//
// MessageText:
//
// Reissue the given operation as a cached IO operation
//
static const long ERROR_IO_REISSUE_AS_CACHED = 3950L;
///////////////////////////////////////////////////
//                                               //
//                Wins Error codes               //
//                                               //
//                 4000 to 4049                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_WINS_INTERNAL
//
// MessageText:
//
// WINS encountered an error while processing the command.
//
static const long ERROR_WINS_INTERNAL = 4000L;
//
// MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
//
// MessageText:
//
// The local WINS cannot be deleted.
//
static const long ERROR_CAN_NOT_DEL_LOCAL_WINS = 4001L;
//
// MessageId: ERROR_STATIC_INIT
//
// MessageText:
//
// The importation from the file failed.
//
static const long ERROR_STATIC_INIT = 4002L;
//
// MessageId: ERROR_INC_BACKUP
//
// MessageText:
//
// The backup failed. Was a full backup done before?
//
static const long ERROR_INC_BACKUP = 4003L;
//
// MessageId: ERROR_FULL_BACKUP
//
// MessageText:
//
// The backup failed. Check the directory to which you are backing the database.
//
static const long ERROR_FULL_BACKUP = 4004L;
//
// MessageId: ERROR_REC_NON_EXISTENT
//
// MessageText:
//
// The name does not exist in the WINS database.
//
static const long ERROR_REC_NON_EXISTENT = 4005L;
//
// MessageId: ERROR_RPL_NOT_ALLOWED
//
// MessageText:
//
// Replication with a nonconfigured partner is not allowed.
//
static const long ERROR_RPL_NOT_ALLOWED = 4006L;
///////////////////////////////////////////////////
//                                               //
//              PeerDist Error codes             //
//                                               //
//                 4050 to 4099                  //
///////////////////////////////////////////////////
//
// MessageId: PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED
//
// MessageText:
//
// The version of the supplied content information is not supported.
//
static const long PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED = 4050L;
//
// MessageId: PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO
//
// MessageText:
//
// The supplied content information is malformed.
//
static const long PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO = 4051L;
//
// MessageId: PEERDIST_ERROR_MISSING_DATA
//
// MessageText:
//
// The requested data cannot be found in local or peer caches.
//
static const long PEERDIST_ERROR_MISSING_DATA = 4052L;
//
// MessageId: PEERDIST_ERROR_NO_MORE
//
// MessageText:
//
// No more data is available or required.
//
static const long PEERDIST_ERROR_NO_MORE = 4053L;
//
// MessageId: PEERDIST_ERROR_NOT_INITIALIZED
//
// MessageText:
//
// The supplied object has not been initialized.
//
static const long PEERDIST_ERROR_NOT_INITIALIZED = 4054L;
//
// MessageId: PEERDIST_ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
// The supplied object has already been initialized.
//
static const long PEERDIST_ERROR_ALREADY_INITIALIZED = 4055L;
//
// MessageId: PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A shutdown operation is already in progress.
//
static const long PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS = 4056L;
//
// MessageId: PEERDIST_ERROR_INVALIDATED
//
// MessageText:
//
// The supplied object has already been invalidated.
//
static const long PEERDIST_ERROR_INVALIDATED = 4057L;
//
// MessageId: PEERDIST_ERROR_ALREADY_EXISTS
//
// MessageText:
//
// An element already exists and was not replaced.
//
static const long PEERDIST_ERROR_ALREADY_EXISTS = 4058L;
//
// MessageId: PEERDIST_ERROR_OPERATION_NOTFOUND
//
// MessageText:
//
// Can not cancel the requested operation as it has already been completed.
//
static const long PEERDIST_ERROR_OPERATION_NOTFOUND = 4059L;
//
// MessageId: PEERDIST_ERROR_ALREADY_COMPLETED
//
// MessageText:
//
// Can not perform the reqested operation because it has already been carried out.
//
static const long PEERDIST_ERROR_ALREADY_COMPLETED = 4060L;
//
// MessageId: PEERDIST_ERROR_OUT_OF_BOUNDS
//
// MessageText:
//
// An operation accessed data beyond the bounds of valid data.
//
static const long PEERDIST_ERROR_OUT_OF_BOUNDS = 4061L;
//
// MessageId: PEERDIST_ERROR_VERSION_UNSUPPORTED
//
// MessageText:
//
// The requested version is not supported.
//
static const long PEERDIST_ERROR_VERSION_UNSUPPORTED = 4062L;
//
// MessageId: PEERDIST_ERROR_INVALID_CONFIGURATION
//
// MessageText:
//
// A configuration value is invalid.
//
static const long PEERDIST_ERROR_INVALID_CONFIGURATION = 4063L;
//
// MessageId: PEERDIST_ERROR_NOT_LICENSED
//
// MessageText:
//
// The SKU is not licensed.
//
static const long PEERDIST_ERROR_NOT_LICENSED = 4064L;
//
// MessageId: PEERDIST_ERROR_SERVICE_UNAVAILABLE
//
// MessageText:
//
// PeerDist Service is still initializing and will be available shortly.
//
static const long PEERDIST_ERROR_SERVICE_UNAVAILABLE = 4065L;
///////////////////////////////////////////////////
//                                               //
//               DHCP Error codes                //
//                                               //
//                 4100 to 4149                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_DHCP_ADDRESS_CONFLICT
//
// MessageText:
//
// The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.
//
static const long ERROR_DHCP_ADDRESS_CONFLICT = 4100L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4150 to 4199                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//               WMI Error codes                 //
//                                               //
//                 4200 to 4249                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_WMI_GUID_NOT_FOUND
//
// MessageText:
//
// The GUID passed was not recognized as valid by a WMI data provider.
//
static const long ERROR_WMI_GUID_NOT_FOUND = 4200L;
//
// MessageId: ERROR_WMI_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The instance name passed was not recognized as valid by a WMI data provider.
//
static const long ERROR_WMI_INSTANCE_NOT_FOUND = 4201L;
//
// MessageId: ERROR_WMI_ITEMID_NOT_FOUND
//
// MessageText:
//
// The data item ID passed was not recognized as valid by a WMI data provider.
//
static const long ERROR_WMI_ITEMID_NOT_FOUND = 4202L;
//
// MessageId: ERROR_WMI_TRY_AGAIN
//
// MessageText:
//
// The WMI request could not be completed and should be retried.
//
static const long ERROR_WMI_TRY_AGAIN = 4203L;
//
// MessageId: ERROR_WMI_DP_NOT_FOUND
//
// MessageText:
//
// The WMI data provider could not be located.
//
static const long ERROR_WMI_DP_NOT_FOUND = 4204L;
//
// MessageId: ERROR_WMI_UNRESOLVED_INSTANCE_REF
//
// MessageText:
//
// The WMI data provider references an instance set that has not been registered.
//
static const long ERROR_WMI_UNRESOLVED_INSTANCE_REF = 4205L;
//
// MessageId: ERROR_WMI_ALREADY_ENABLED
//
// MessageText:
//
// The WMI data block or event notification has already been enabled.
//
static const long ERROR_WMI_ALREADY_ENABLED = 4206L;
//
// MessageId: ERROR_WMI_GUID_DISCONNECTED
//
// MessageText:
//
// The WMI data block is no longer available.
//
static const long ERROR_WMI_GUID_DISCONNECTED = 4207L;
//
// MessageId: ERROR_WMI_SERVER_UNAVAILABLE
//
// MessageText:
//
// The WMI data service is not available.
//
static const long ERROR_WMI_SERVER_UNAVAILABLE = 4208L;
//
// MessageId: ERROR_WMI_DP_FAILED
//
// MessageText:
//
// The WMI data provider failed to carry out the request.
//
static const long ERROR_WMI_DP_FAILED = 4209L;
//
// MessageId: ERROR_WMI_INVALID_MOF
//
// MessageText:
//
// The WMI MOF information is not valid.
//
static const long ERROR_WMI_INVALID_MOF = 4210L;
//
// MessageId: ERROR_WMI_INVALID_REGINFO
//
// MessageText:
//
// The WMI registration information is not valid.
//
static const long ERROR_WMI_INVALID_REGINFO = 4211L;
//
// MessageId: ERROR_WMI_ALREADY_DISABLED
//
// MessageText:
//
// The WMI data block or event notification has already been disabled.
//
static const long ERROR_WMI_ALREADY_DISABLED = 4212L;
//
// MessageId: ERROR_WMI_READ_ONLY
//
// MessageText:
//
// The WMI data item or data block is read only.
//
static const long ERROR_WMI_READ_ONLY = 4213L;
//
// MessageId: ERROR_WMI_SET_FAILURE
//
// MessageText:
//
// The WMI data item or data block could not be changed.
//
static const long ERROR_WMI_SET_FAILURE = 4214L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4250 to 4299                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//        RSM (Media Services) Error codes       //
//                                               //
//                 4300 to 4349                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INVALID_MEDIA
//
// MessageText:
//
// The media identifier does not represent a valid medium.
//
static const long ERROR_INVALID_MEDIA = 4300L;
//
// MessageId: ERROR_INVALID_LIBRARY
//
// MessageText:
//
// The library identifier does not represent a valid library.
//
static const long ERROR_INVALID_LIBRARY = 4301L;
//
// MessageId: ERROR_INVALID_MEDIA_POOL
//
// MessageText:
//
// The media pool identifier does not represent a valid media pool.
//
static const long ERROR_INVALID_MEDIA_POOL = 4302L;
//
// MessageId: ERROR_DRIVE_MEDIA_MISMATCH
//
// MessageText:
//
// The drive and medium are not compatible or exist in different libraries.
//
static const long ERROR_DRIVE_MEDIA_MISMATCH = 4303L;
//
// MessageId: ERROR_MEDIA_OFFLINE
//
// MessageText:
//
// The medium currently exists in an offline library and must be online to perform this operation.
//
static const long ERROR_MEDIA_OFFLINE = 4304L;
//
// MessageId: ERROR_LIBRARY_OFFLINE
//
// MessageText:
//
// The operation cannot be performed on an offline library.
//
static const long ERROR_LIBRARY_OFFLINE = 4305L;
//
// MessageId: ERROR_EMPTY
//
// MessageText:
//
// The library, drive, or media pool is empty.
//
static const long ERROR_EMPTY = 4306L;
//
// MessageId: ERROR_NOT_EMPTY
//
// MessageText:
//
// The library, drive, or media pool must be empty to perform this operation.
//
static const long ERROR_NOT_EMPTY = 4307L;
//
// MessageId: ERROR_MEDIA_UNAVAILABLE
//
// MessageText:
//
// No media is currently available in this media pool or library.
//
static const long ERROR_MEDIA_UNAVAILABLE = 4308L;
//
// MessageId: ERROR_RESOURCE_DISABLED
//
// MessageText:
//
// A resource required for this operation is disabled.
//
static const long ERROR_RESOURCE_DISABLED = 4309L;
//
// MessageId: ERROR_INVALID_CLEANER
//
// MessageText:
//
// The media identifier does not represent a valid cleaner.
//
static const long ERROR_INVALID_CLEANER = 4310L;
//
// MessageId: ERROR_UNABLE_TO_CLEAN
//
// MessageText:
//
// The drive cannot be cleaned or does not support cleaning.
//
static const long ERROR_UNABLE_TO_CLEAN = 4311L;
//
// MessageId: ERROR_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object identifier does not represent a valid object.
//
static const long ERROR_OBJECT_NOT_FOUND = 4312L;
//
// MessageId: ERROR_DATABASE_FAILURE
//
// MessageText:
//
// Unable to read from or write to the database.
//
static const long ERROR_DATABASE_FAILURE = 4313L;
//
// MessageId: ERROR_DATABASE_FULL
//
// MessageText:
//
// The database is full.
//
static const long ERROR_DATABASE_FULL = 4314L;
//
// MessageId: ERROR_MEDIA_INCOMPATIBLE
//
// MessageText:
//
// The medium is not compatible with the device or media pool.
//
static const long ERROR_MEDIA_INCOMPATIBLE = 4315L;
//
// MessageId: ERROR_RESOURCE_NOT_PRESENT
//
// MessageText:
//
// The resource required for this operation does not exist.
//
static const long ERROR_RESOURCE_NOT_PRESENT = 4316L;
//
// MessageId: ERROR_INVALID_OPERATION
//
// MessageText:
//
// The operation identifier is not valid.
//
static const long ERROR_INVALID_OPERATION = 4317L;
//
// MessageId: ERROR_MEDIA_NOT_AVAILABLE
//
// MessageText:
//
// The media is not mounted or ready for use.
//
static const long ERROR_MEDIA_NOT_AVAILABLE = 4318L;
//
// MessageId: ERROR_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
// The device is not ready for use.
//
static const long ERROR_DEVICE_NOT_AVAILABLE = 4319L;
//
// MessageId: ERROR_REQUEST_REFUSED
//
// MessageText:
//
// The operator or administrator has refused the request.
//
static const long ERROR_REQUEST_REFUSED = 4320L;
//
// MessageId: ERROR_INVALID_DRIVE_OBJECT
//
// MessageText:
//
// The drive identifier does not represent a valid drive.
//
static const long ERROR_INVALID_DRIVE_OBJECT = 4321L;
//
// MessageId: ERROR_LIBRARY_FULL
//
// MessageText:
//
// Library is full. No slot is available for use.
//
static const long ERROR_LIBRARY_FULL = 4322L;
//
// MessageId: ERROR_MEDIUM_NOT_ACCESSIBLE
//
// MessageText:
//
// The transport cannot access the medium.
//
static const long ERROR_MEDIUM_NOT_ACCESSIBLE = 4323L;
//
// MessageId: ERROR_UNABLE_TO_LOAD_MEDIUM
//
// MessageText:
//
// Unable to load the medium into the drive.
//
static const long ERROR_UNABLE_TO_LOAD_MEDIUM = 4324L;
//
// MessageId: ERROR_UNABLE_TO_INVENTORY_DRIVE
//
// MessageText:
//
// Unable to retrieve the drive status.
//
static const long ERROR_UNABLE_TO_INVENTORY_DRIVE = 4325L;
//
// MessageId: ERROR_UNABLE_TO_INVENTORY_SLOT
//
// MessageText:
//
// Unable to retrieve the slot status.
//
static const long ERROR_UNABLE_TO_INVENTORY_SLOT = 4326L;
//
// MessageId: ERROR_UNABLE_TO_INVENTORY_TRANSPORT
//
// MessageText:
//
// Unable to retrieve status about the transport.
//
static const long ERROR_UNABLE_TO_INVENTORY_TRANSPORT = 4327L;
//
// MessageId: ERROR_TRANSPORT_FULL
//
// MessageText:
//
// Cannot use the transport because it is already in use.
//
static const long ERROR_TRANSPORT_FULL = 4328L;
//
// MessageId: ERROR_CONTROLLING_IEPORT
//
// MessageText:
//
// Unable to open or close the inject/eject port.
//
static const long ERROR_CONTROLLING_IEPORT = 4329L;
//
// MessageId: ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA
//
// MessageText:
//
// Unable to eject the medium because it is in a drive.
//
static const long ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA = 4330L;
//
// MessageId: ERROR_CLEANER_SLOT_SET
//
// MessageText:
//
// A cleaner slot is already reserved.
//
static const long ERROR_CLEANER_SLOT_SET = 4331L;
//
// MessageId: ERROR_CLEANER_SLOT_NOT_SET
//
// MessageText:
//
// A cleaner slot is not reserved.
//
static const long ERROR_CLEANER_SLOT_NOT_SET = 4332L;
//
// MessageId: ERROR_CLEANER_CARTRIDGE_SPENT
//
// MessageText:
//
// The cleaner cartridge has performed the maximum number of drive cleanings.
//
static const long ERROR_CLEANER_CARTRIDGE_SPENT = 4333L;
//
// MessageId: ERROR_UNEXPECTED_OMID
//
// MessageText:
//
// Unexpected on-medium identifier.
//
static const long ERROR_UNEXPECTED_OMID = 4334L;
//
// MessageId: ERROR_CANT_DELETE_LAST_ITEM
//
// MessageText:
//
// The last remaining item in this group or resource cannot be deleted.
//
static const long ERROR_CANT_DELETE_LAST_ITEM = 4335L;
//
// MessageId: ERROR_MESSAGE_EXCEEDS_MAX_SIZE
//
// MessageText:
//
// The message provided exceeds the maximum size allowed for this parameter.
//
static const long ERROR_MESSAGE_EXCEEDS_MAX_SIZE = 4336L;
//
// MessageId: ERROR_VOLUME_CONTAINS_SYS_FILES
//
// MessageText:
//
// The volume contains system or paging files.
//
static const long ERROR_VOLUME_CONTAINS_SYS_FILES = 4337L;
//
// MessageId: ERROR_INDIGENOUS_TYPE
//
// MessageText:
//
// The media type cannot be removed from this library since at least one drive in the library reports it can support this media type.
//
static const long ERROR_INDIGENOUS_TYPE = 4338L;
//
// MessageId: ERROR_NO_SUPPORTING_DRIVES
//
// MessageText:
//
// This offline media cannot be mounted on this system since no enabled drives are present which can be used.
//
static const long ERROR_NO_SUPPORTING_DRIVES = 4339L;
//
// MessageId: ERROR_CLEANER_CARTRIDGE_INSTALLED
//
// MessageText:
//
// A cleaner cartridge is present in the tape library.
//
static const long ERROR_CLEANER_CARTRIDGE_INSTALLED = 4340L;
//
// MessageId: ERROR_IEPORT_FULL
//
// MessageText:
//
// Cannot use the inject/eject port because it is not empty.
//
static const long ERROR_IEPORT_FULL = 4341L;
///////////////////////////////////////////////////
//                                               //
//       Remote Storage Service Error codes      //
//                                               //
//                 4350 to 4389                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_FILE_OFFLINE
//
// MessageText:
//
// This file is currently not available for use on this computer.
//
static const long ERROR_FILE_OFFLINE = 4350L;
//
// MessageId: ERROR_REMOTE_STORAGE_NOT_ACTIVE
//
// MessageText:
//
// The remote storage service is not operational at this time.
//
static const long ERROR_REMOTE_STORAGE_NOT_ACTIVE = 4351L;
//
// MessageId: ERROR_REMOTE_STORAGE_MEDIA_ERROR
//
// MessageText:
//
// The remote storage service encountered a media error.
//
static const long ERROR_REMOTE_STORAGE_MEDIA_ERROR = 4352L;
///////////////////////////////////////////////////
//                                               //
//           Reparse Point Error codes           //
//                                               //
//                 4390 to 4399                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_NOT_A_REPARSE_POINT
//
// MessageText:
//
// The file or directory is not a reparse point.
//
static const long ERROR_NOT_A_REPARSE_POINT = 4390L;
//
// MessageId: ERROR_REPARSE_ATTRIBUTE_CONFLICT
//
// MessageText:
//
// The reparse point attribute cannot be set because it conflicts with an existing attribute.
//
static const long ERROR_REPARSE_ATTRIBUTE_CONFLICT = 4391L;
//
// MessageId: ERROR_INVALID_REPARSE_DATA
//
// MessageText:
//
// The data present in the reparse point buffer is invalid.
//
static const long ERROR_INVALID_REPARSE_DATA = 4392L;
//
// MessageId: ERROR_REPARSE_TAG_INVALID
//
// MessageText:
//
// The tag present in the reparse point buffer is invalid.
//
static const long ERROR_REPARSE_TAG_INVALID = 4393L;
//
// MessageId: ERROR_REPARSE_TAG_MISMATCH
//
// MessageText:
//
// There is a mismatch between the tag specified in the request and the tag present in the reparse point.
// 
//
static const long ERROR_REPARSE_TAG_MISMATCH = 4394L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4400 to 4499                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//    Single Instance Store (SIS) Error codes    //
//                                               //
//                 4500 to 4549                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_VOLUME_NOT_SIS_ENABLED
//
// MessageText:
//
// Single Instance Storage is not available on this volume.
//
static const long ERROR_VOLUME_NOT_SIS_ENABLED = 4500L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4550 to 4599                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//             Cluster Error codes               //
//                                               //
//                 5000 to 5999                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_DEPENDENT_RESOURCE_EXISTS
//
// MessageText:
//
// The operation cannot be completed because other resources are dependent on this resource.
//
static const long ERROR_DEPENDENT_RESOURCE_EXISTS = 5001L;
//
// MessageId: ERROR_DEPENDENCY_NOT_FOUND
//
// MessageText:
//
// The cluster resource dependency cannot be found.
//
static const long ERROR_DEPENDENCY_NOT_FOUND = 5002L;
//
// MessageId: ERROR_DEPENDENCY_ALREADY_EXISTS
//
// MessageText:
//
// The cluster resource cannot be made dependent on the specified resource because it is already dependent.
//
static const long ERROR_DEPENDENCY_ALREADY_EXISTS = 5003L;
//
// MessageId: ERROR_RESOURCE_NOT_ONLINE
//
// MessageText:
//
// The cluster resource is not online.
//
static const long ERROR_RESOURCE_NOT_ONLINE = 5004L;
//
// MessageId: ERROR_HOST_NODE_NOT_AVAILABLE
//
// MessageText:
//
// A cluster node is not available for this operation.
//
static const long ERROR_HOST_NODE_NOT_AVAILABLE = 5005L;
//
// MessageId: ERROR_RESOURCE_NOT_AVAILABLE
//
// MessageText:
//
// The cluster resource is not available.
//
static const long ERROR_RESOURCE_NOT_AVAILABLE = 5006L;
//
// MessageId: ERROR_RESOURCE_NOT_FOUND
//
// MessageText:
//
// The cluster resource could not be found.
//
static const long ERROR_RESOURCE_NOT_FOUND = 5007L;
//
// MessageId: ERROR_SHUTDOWN_CLUSTER
//
// MessageText:
//
// The cluster is being shut down.
//
static const long ERROR_SHUTDOWN_CLUSTER = 5008L;
//
// MessageId: ERROR_CANT_EVICT_ACTIVE_NODE
//
// MessageText:
//
// A cluster node cannot be evicted from the cluster unless the node is down or it is the last node.
//
static const long ERROR_CANT_EVICT_ACTIVE_NODE = 5009L;
//
// MessageId: ERROR_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
// The object already exists.
//
static const long ERROR_OBJECT_ALREADY_EXISTS = 5010L;
//
// MessageId: ERROR_OBJECT_IN_LIST
//
// MessageText:
//
// The object is already in the list.
//
static const long ERROR_OBJECT_IN_LIST = 5011L;
//
// MessageId: ERROR_GROUP_NOT_AVAILABLE
//
// MessageText:
//
// The cluster group is not available for any new requests.
//
static const long ERROR_GROUP_NOT_AVAILABLE = 5012L;
//
// MessageId: ERROR_GROUP_NOT_FOUND
//
// MessageText:
//
// The cluster group could not be found.
//
static const long ERROR_GROUP_NOT_FOUND = 5013L;
//
// MessageId: ERROR_GROUP_NOT_ONLINE
//
// MessageText:
//
// The operation could not be completed because the cluster group is not online.
//
static const long ERROR_GROUP_NOT_ONLINE = 5014L;
//
// MessageId: ERROR_HOST_NODE_NOT_RESOURCE_OWNER
//
// MessageText:
//
// The operation failed because either the specified cluster node is not the owner of the resource, or the node is not a possible owner of the resource.
//
static const long ERROR_HOST_NODE_NOT_RESOURCE_OWNER = 5015L;
//
// MessageId: ERROR_HOST_NODE_NOT_GROUP_OWNER
//
// MessageText:
//
// The operation failed because either the specified cluster node is not the owner of the group, or the node is not a possible owner of the group.
//
static const long ERROR_HOST_NODE_NOT_GROUP_OWNER = 5016L;
//
// MessageId: ERROR_RESMON_CREATE_FAILED
//
// MessageText:
//
// The cluster resource could not be created in the specified resource monitor.
//
static const long ERROR_RESMON_CREATE_FAILED = 5017L;
//
// MessageId: ERROR_RESMON_ONLINE_FAILED
//
// MessageText:
//
// The cluster resource could not be brought online by the resource monitor.
//
static const long ERROR_RESMON_ONLINE_FAILED = 5018L;
//
// MessageId: ERROR_RESOURCE_ONLINE
//
// MessageText:
//
// The operation could not be completed because the cluster resource is online.
//
static const long ERROR_RESOURCE_ONLINE = 5019L;
//
// MessageId: ERROR_QUORUM_RESOURCE
//
// MessageText:
//
// The cluster resource could not be deleted or brought offline because it is the quorum resource.
//
static const long ERROR_QUORUM_RESOURCE = 5020L;
//
// MessageId: ERROR_NOT_QUORUM_CAPABLE
//
// MessageText:
//
// The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.
//
static const long ERROR_NOT_QUORUM_CAPABLE = 5021L;
//
// MessageId: ERROR_CLUSTER_SHUTTING_DOWN
//
// MessageText:
//
// The cluster software is shutting down.
//
static const long ERROR_CLUSTER_SHUTTING_DOWN = 5022L;
//
// MessageId: ERROR_INVALID_STATE
//
// MessageText:
//
// The group or resource is not in the correct state to perform the requested operation.
//
static const long ERROR_INVALID_STATE = 5023L;
//
// MessageId: ERROR_RESOURCE_PROPERTIES_STORED
//
// MessageText:
//
// The properties were stored but not all changes will take effect until the next time the resource is brought online.
//
static const long ERROR_RESOURCE_PROPERTIES_STORED = 5024L;
//
// MessageId: ERROR_NOT_QUORUM_CLASS
//
// MessageText:
//
// The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.
//
static const long ERROR_NOT_QUORUM_CLASS = 5025L;
//
// MessageId: ERROR_CORE_RESOURCE
//
// MessageText:
//
// The cluster resource could not be deleted since it is a core resource.
//
static const long ERROR_CORE_RESOURCE = 5026L;
//
// MessageId: ERROR_QUORUM_RESOURCE_ONLINE_FAILED
//
// MessageText:
//
// The quorum resource failed to come online.
//
static const long ERROR_QUORUM_RESOURCE_ONLINE_FAILED = 5027L;
//
// MessageId: ERROR_QUORUMLOG_OPEN_FAILED
//
// MessageText:
//
// The quorum log could not be created or mounted successfully.
//
static const long ERROR_QUORUMLOG_OPEN_FAILED = 5028L;
//
// MessageId: ERROR_CLUSTERLOG_CORRUPT
//
// MessageText:
//
// The cluster log is corrupt.
//
static const long ERROR_CLUSTERLOG_CORRUPT = 5029L;
//
// MessageId: ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
//
// MessageText:
//
// The record could not be written to the cluster log since it exceeds the maximum size.
//
static const long ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = 5030L;
//
// MessageId: ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
//
// MessageText:
//
// The cluster log exceeds its maximum size.
//
static const long ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = 5031L;
//
// MessageId: ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
//
// MessageText:
//
// No checkpoint record was found in the cluster log.
//
static const long ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = 5032L;
//
// MessageId: ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
//
// MessageText:
//
// The minimum required disk space needed for logging is not available.
//
static const long ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = 5033L;
//
// MessageId: ERROR_QUORUM_OWNER_ALIVE
//
// MessageText:
//
// The cluster node failed to take control of the quorum resource because the resource is owned by another active node.
//
static const long ERROR_QUORUM_OWNER_ALIVE = 5034L;
//
// MessageId: ERROR_NETWORK_NOT_AVAILABLE
//
// MessageText:
//
// A cluster network is not available for this operation.
//
static const long ERROR_NETWORK_NOT_AVAILABLE = 5035L;
//
// MessageId: ERROR_NODE_NOT_AVAILABLE
//
// MessageText:
//
// A cluster node is not available for this operation.
//
static const long ERROR_NODE_NOT_AVAILABLE = 5036L;
//
// MessageId: ERROR_ALL_NODES_NOT_AVAILABLE
//
// MessageText:
//
// All cluster nodes must be running to perform this operation.
//
static const long ERROR_ALL_NODES_NOT_AVAILABLE = 5037L;
//
// MessageId: ERROR_RESOURCE_FAILED
//
// MessageText:
//
// A cluster resource failed.
//
static const long ERROR_RESOURCE_FAILED = 5038L;
//
// MessageId: ERROR_CLUSTER_INVALID_NODE
//
// MessageText:
//
// The cluster node is not valid.
//
static const long ERROR_CLUSTER_INVALID_NODE = 5039L;
//
// MessageId: ERROR_CLUSTER_NODE_EXISTS
//
// MessageText:
//
// The cluster node already exists.
//
static const long ERROR_CLUSTER_NODE_EXISTS = 5040L;
//
// MessageId: ERROR_CLUSTER_JOIN_IN_PROGRESS
//
// MessageText:
//
// A node is in the process of joining the cluster.
//
static const long ERROR_CLUSTER_JOIN_IN_PROGRESS = 5041L;
//
// MessageId: ERROR_CLUSTER_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster node was not found.
//
static const long ERROR_CLUSTER_NODE_NOT_FOUND = 5042L;
//
// MessageId: ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster local node information was not found.
//
static const long ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND = 5043L;
//
// MessageId: ERROR_CLUSTER_NETWORK_EXISTS
//
// MessageText:
//
// The cluster network already exists.
//
static const long ERROR_CLUSTER_NETWORK_EXISTS = 5044L;
//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_FOUND
//
// MessageText:
//
// The cluster network was not found.
//
static const long ERROR_CLUSTER_NETWORK_NOT_FOUND = 5045L;
//
// MessageId: ERROR_CLUSTER_NETINTERFACE_EXISTS
//
// MessageText:
//
// The cluster network interface already exists.
//
static const long ERROR_CLUSTER_NETINTERFACE_EXISTS = 5046L;
//
// MessageId: ERROR_CLUSTER_NETINTERFACE_NOT_FOUND
//
// MessageText:
//
// The cluster network interface was not found.
//
static const long ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = 5047L;
//
// MessageId: ERROR_CLUSTER_INVALID_REQUEST
//
// MessageText:
//
// The cluster request is not valid for this object.
//
static const long ERROR_CLUSTER_INVALID_REQUEST = 5048L;
//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK_PROVIDER
//
// MessageText:
//
// The cluster network provider is not valid.
//
static const long ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = 5049L;
//
// MessageId: ERROR_CLUSTER_NODE_DOWN
//
// MessageText:
//
// The cluster node is down.
//
static const long ERROR_CLUSTER_NODE_DOWN = 5050L;
//
// MessageId: ERROR_CLUSTER_NODE_UNREACHABLE
//
// MessageText:
//
// The cluster node is not reachable.
//
static const long ERROR_CLUSTER_NODE_UNREACHABLE = 5051L;
//
// MessageId: ERROR_CLUSTER_NODE_NOT_MEMBER
//
// MessageText:
//
// The cluster node is not a member of the cluster.
//
static const long ERROR_CLUSTER_NODE_NOT_MEMBER = 5052L;
//
// MessageId: ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS
//
// MessageText:
//
// A cluster join operation is not in progress.
//
static const long ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS = 5053L;
//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK
//
// MessageText:
//
// The cluster network is not valid.
//
static const long ERROR_CLUSTER_INVALID_NETWORK = 5054L;
//
// MessageId: ERROR_CLUSTER_NODE_UP
//
// MessageText:
//
// The cluster node is up.
//
static const long ERROR_CLUSTER_NODE_UP = 5056L;
//
// MessageId: ERROR_CLUSTER_IPADDR_IN_USE
//
// MessageText:
//
// The cluster IP address is already in use.
//
static const long ERROR_CLUSTER_IPADDR_IN_USE = 5057L;
//
// MessageId: ERROR_CLUSTER_NODE_NOT_PAUSED
//
// MessageText:
//
// The cluster node is not paused.
//
static const long ERROR_CLUSTER_NODE_NOT_PAUSED = 5058L;
//
// MessageId: ERROR_CLUSTER_NO_SECURITY_CONTEXT
//
// MessageText:
//
// No cluster security context is available.
//
static const long ERROR_CLUSTER_NO_SECURITY_CONTEXT = 5059L;
//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_INTERNAL
//
// MessageText:
//
// The cluster network is not configured for internal cluster communication.
//
static const long ERROR_CLUSTER_NETWORK_NOT_INTERNAL = 5060L;
//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_UP
//
// MessageText:
//
// The cluster node is already up.
//
static const long ERROR_CLUSTER_NODE_ALREADY_UP = 5061L;
//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_DOWN
//
// MessageText:
//
// The cluster node is already down.
//
static const long ERROR_CLUSTER_NODE_ALREADY_DOWN = 5062L;
//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_ONLINE
//
// MessageText:
//
// The cluster network is already online.
//
static const long ERROR_CLUSTER_NETWORK_ALREADY_ONLINE = 5063L;
//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE
//
// MessageText:
//
// The cluster network is already offline.
//
static const long ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = 5064L;
//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_MEMBER
//
// MessageText:
//
// The cluster node is already a member of the cluster.
//
static const long ERROR_CLUSTER_NODE_ALREADY_MEMBER = 5065L;
//
// MessageId: ERROR_CLUSTER_LAST_INTERNAL_NETWORK
//
// MessageText:
//
// The cluster network is the only one configured for internal cluster communication between two or more active cluster nodes. The internal communication capability cannot be removed from the network.
//
static const long ERROR_CLUSTER_LAST_INTERNAL_NETWORK = 5066L;
//
// MessageId: ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS
//
// MessageText:
//
// One or more cluster resources depend on the network to provide service to clients. The client access capability cannot be removed from the network.
//
static const long ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS = 5067L;
//
// MessageId: ERROR_INVALID_OPERATION_ON_QUORUM
//
// MessageText:
//
// This operation cannot be performed on the cluster resource as it the quorum resource. You may not bring the quorum resource offline or modify its possible owners list.
//
static const long ERROR_INVALID_OPERATION_ON_QUORUM = 5068L;
//
// MessageId: ERROR_DEPENDENCY_NOT_ALLOWED
//
// MessageText:
//
// The cluster quorum resource is not allowed to have any dependencies.
//
static const long ERROR_DEPENDENCY_NOT_ALLOWED = 5069L;
//
// MessageId: ERROR_CLUSTER_NODE_PAUSED
//
// MessageText:
//
// The cluster node is paused.
//
static const long ERROR_CLUSTER_NODE_PAUSED = 5070L;
//
// MessageId: ERROR_NODE_CANT_HOST_RESOURCE
//
// MessageText:
//
// The cluster resource cannot be brought online. The owner node cannot run this resource.
//
static const long ERROR_NODE_CANT_HOST_RESOURCE = 5071L;
//
// MessageId: ERROR_CLUSTER_NODE_NOT_READY
//
// MessageText:
//
// The cluster node is not ready to perform the requested operation.
//
static const long ERROR_CLUSTER_NODE_NOT_READY = 5072L;
//
// MessageId: ERROR_CLUSTER_NODE_SHUTTING_DOWN
//
// MessageText:
//
// The cluster node is shutting down.
//
static const long ERROR_CLUSTER_NODE_SHUTTING_DOWN = 5073L;
//
// MessageId: ERROR_CLUSTER_JOIN_ABORTED
//
// MessageText:
//
// The cluster join operation was aborted.
//
static const long ERROR_CLUSTER_JOIN_ABORTED = 5074L;
//
// MessageId: ERROR_CLUSTER_INCOMPATIBLE_VERSIONS
//
// MessageText:
//
// The cluster join operation failed due to incompatible software versions between the joining node and its sponsor.
//
static const long ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = 5075L;
//
// MessageId: ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED
//
// MessageText:
//
// This resource cannot be created because the cluster has reached the limit on the number of resources it can monitor.
//
static const long ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED = 5076L;
//
// MessageId: ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED
//
// MessageText:
//
// The system configuration changed during the cluster join or form operation. The join or form operation was aborted.
//
static const long ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = 5077L;
//
// MessageId: ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
// The specified resource type was not found.
//
static const long ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND = 5078L;
//
// MessageId: ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED
//
// MessageText:
//
// The specified node does not support a resource of this type. This may be due to version inconsistencies or due to the absence of the resource DLL on this node.
//
static const long ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED = 5079L;
//
// MessageId: ERROR_CLUSTER_RESNAME_NOT_FOUND
//
// MessageText:
//
// The specified resource name is not supported by this resource DLL. This may be due to a bad (or changed) name supplied to the resource DLL.
//
static const long ERROR_CLUSTER_RESNAME_NOT_FOUND = 5080L;
//
// MessageId: ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED
//
// MessageText:
//
// No authentication package could be registered with the RPC server.
//
static const long ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = 5081L;
//
// MessageId: ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST
//
// MessageText:
//
// You cannot bring the group online because the owner of the group is not in the preferred list for the group. To change the owner node for the group, move the group.
//
static const long ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST = 5082L;
//
// MessageId: ERROR_CLUSTER_DATABASE_SEQMISMATCH
//
// MessageText:
//
// The join operation failed because the cluster database sequence number has changed or is incompatible with the locker node. This may happen during a join operation if the cluster database was changing during the join.
//
static const long ERROR_CLUSTER_DATABASE_SEQMISMATCH = 5083L;
//
// MessageId: ERROR_RESMON_INVALID_STATE
//
// MessageText:
//
// The resource monitor will not allow the fail operation to be performed while the resource is in its current state. This may happen if the resource is in a pending state.
//
static const long ERROR_RESMON_INVALID_STATE = 5084L;
//
// MessageId: ERROR_CLUSTER_GUM_NOT_LOCKER
//
// MessageText:
//
// A non locker code got a request to reserve the lock for making global updates.
//
static const long ERROR_CLUSTER_GUM_NOT_LOCKER = 5085L;
//
// MessageId: ERROR_QUORUM_DISK_NOT_FOUND
//
// MessageText:
//
// The quorum disk could not be located by the cluster service.
//
static const long ERROR_QUORUM_DISK_NOT_FOUND = 5086L;
//
// MessageId: ERROR_DATABASE_BACKUP_CORRUPT
//
// MessageText:
//
// The backed up cluster database is possibly corrupt.
//
static const long ERROR_DATABASE_BACKUP_CORRUPT = 5087L;
//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT
//
// MessageText:
//
// A DFS root already exists in this cluster node.
//
static const long ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT = 5088L;
//
// MessageId: ERROR_RESOURCE_PROPERTY_UNCHANGEABLE
//
// MessageText:
//
// An attempt to modify a resource property failed because it conflicts with another existing property.
//
static const long ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = 5089L;
/*
 Codes from 4300 through 5889 overlap with codes in ds\published\inc\apperr2.w.
 Do not add any more error codes in that range.
*/
# 12363 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
// MessageId: ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE
//
// MessageText:
//
// An operation was attempted that is incompatible with the current membership state of the node.
//
static const long ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = 5890L;
//
// MessageId: ERROR_CLUSTER_QUORUMLOG_NOT_FOUND
//
// MessageText:
//
// The quorum resource does not contain the quorum log.
//
static const long ERROR_CLUSTER_QUORUMLOG_NOT_FOUND = 5891L;
//
// MessageId: ERROR_CLUSTER_MEMBERSHIP_HALT
//
// MessageText:
//
// The membership engine requested shutdown of the cluster service on this node.
//
static const long ERROR_CLUSTER_MEMBERSHIP_HALT = 5892L;
//
// MessageId: ERROR_CLUSTER_INSTANCE_ID_MISMATCH
//
// MessageText:
//
// The join operation failed because the cluster instance ID of the joining node does not match the cluster instance ID of the sponsor node.
//
static const long ERROR_CLUSTER_INSTANCE_ID_MISMATCH = 5893L;
//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP
//
// MessageText:
//
// A matching cluster network for the specified IP address could not be found.
//
static const long ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = 5894L;
//
// MessageId: ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH
//
// MessageText:
//
// The actual data type of the property did not match the expected data type of the property.
//
static const long ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH = 5895L;
//
// MessageId: ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP
//
// MessageText:
//
// The cluster node was evicted from the cluster successfully, but the node was not cleaned up. To determine what cleanup steps failed and how to recover, see the Failover Clustering application event log using Event Viewer.
//
static const long ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = 5896L;
//
// MessageId: ERROR_CLUSTER_PARAMETER_MISMATCH
//
// MessageText:
//
// Two or more parameter values specified for a resource's properties are in conflict.
//
static const long ERROR_CLUSTER_PARAMETER_MISMATCH = 5897L;
//
// MessageId: ERROR_NODE_CANNOT_BE_CLUSTERED
//
// MessageText:
//
// This computer cannot be made a member of a cluster.
//
static const long ERROR_NODE_CANNOT_BE_CLUSTERED = 5898L;
//
// MessageId: ERROR_CLUSTER_WRONG_OS_VERSION
//
// MessageText:
//
// This computer cannot be made a member of a cluster because it does not have the correct version of Windows installed.
//
static const long ERROR_CLUSTER_WRONG_OS_VERSION = 5899L;
//
// MessageId: ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME
//
// MessageText:
//
// A cluster cannot be created with the specified cluster name because that cluster name is already in use. Specify a different name for the cluster.
//
static const long ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = 5900L;
//
// MessageId: ERROR_CLUSCFG_ALREADY_COMMITTED
//
// MessageText:
//
// The cluster configuration action has already been committed.
//
static const long ERROR_CLUSCFG_ALREADY_COMMITTED = 5901L;
//
// MessageId: ERROR_CLUSCFG_ROLLBACK_FAILED
//
// MessageText:
//
// The cluster configuration action could not be rolled back.
//
static const long ERROR_CLUSCFG_ROLLBACK_FAILED = 5902L;
//
// MessageId: ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT
//
// MessageText:
//
// The drive letter assigned to a system disk on one node conflicted with the drive letter assigned to a disk on another node.
//
static const long ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = 5903L;
//
// MessageId: ERROR_CLUSTER_OLD_VERSION
//
// MessageText:
//
// One or more nodes in the cluster are running a version of Windows that does not support this operation.
//
static const long ERROR_CLUSTER_OLD_VERSION = 5904L;
//
// MessageId: ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME
//
// MessageText:
//
// The name of the corresponding computer account doesn't match the Network Name for this resource.
//
static const long ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = 5905L;
//
// MessageId: ERROR_CLUSTER_NO_NET_ADAPTERS
//
// MessageText:
//
// No network adapters are available.
//
static const long ERROR_CLUSTER_NO_NET_ADAPTERS = 5906L;
//
// MessageId: ERROR_CLUSTER_POISONED
//
// MessageText:
//
// The cluster node has been poisoned.
//
static const long ERROR_CLUSTER_POISONED = 5907L;
//
// MessageId: ERROR_CLUSTER_GROUP_MOVING
//
// MessageText:
//
// The group is unable to accept the request since it is moving to another node.
//
static const long ERROR_CLUSTER_GROUP_MOVING = 5908L;
//
// MessageId: ERROR_CLUSTER_RESOURCE_TYPE_BUSY
//
// MessageText:
//
// The resource type cannot accept the request since is too busy performing another operation.
//
static const long ERROR_CLUSTER_RESOURCE_TYPE_BUSY = 5909L;
//
// MessageId: ERROR_RESOURCE_CALL_TIMED_OUT
//
// MessageText:
//
// The call to the cluster resource DLL timed out.
//
static const long ERROR_RESOURCE_CALL_TIMED_OUT = 5910L;
//
// MessageId: ERROR_INVALID_CLUSTER_IPV6_ADDRESS
//
// MessageText:
//
// The address is not valid for an IPv6 Address resource. A global IPv6 address is required, and it must match a cluster network. Compatibility addresses are not permitted.
//
static const long ERROR_INVALID_CLUSTER_IPV6_ADDRESS = 5911L;
//
// MessageId: ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION
//
// MessageText:
//
// An internal cluster error occurred. A call to an invalid function was attempted.
//
static const long ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION = 5912L;
//
// MessageId: ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS
//
// MessageText:
//
// A parameter value is out of acceptable range.
//
static const long ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS = 5913L;
//
// MessageId: ERROR_CLUSTER_PARTIAL_SEND
//
// MessageText:
//
// A network error occurred while sending data to another node in the cluster. The number of bytes transmitted was less than required.
//
static const long ERROR_CLUSTER_PARTIAL_SEND = 5914L;
//
// MessageId: ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION
//
// MessageText:
//
// An invalid cluster registry operation was attempted.
//
static const long ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = 5915L;
//
// MessageId: ERROR_CLUSTER_INVALID_STRING_TERMINATION
//
// MessageText:
//
// An input string of characters is not properly terminated.
//
static const long ERROR_CLUSTER_INVALID_STRING_TERMINATION = 5916L;
//
// MessageId: ERROR_CLUSTER_INVALID_STRING_FORMAT
//
// MessageText:
//
// An input string of characters is not in a valid format for the data it represents.
//
static const long ERROR_CLUSTER_INVALID_STRING_FORMAT = 5917L;
//
// MessageId: ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// An internal cluster error occurred. A cluster database transaction was attempted while a transaction was already in progress.
//
static const long ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS = 5918L;
//
// MessageId: ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS
//
// MessageText:
//
// An internal cluster error occurred. There was an attempt to commit a cluster database transaction while no transaction was in progress.
//
static const long ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = 5919L;
//
// MessageId: ERROR_CLUSTER_NULL_DATA
//
// MessageText:
//
// An internal cluster error occurred. Data was not properly initialized.
//
static const long ERROR_CLUSTER_NULL_DATA = 5920L;
//
// MessageId: ERROR_CLUSTER_PARTIAL_READ
//
// MessageText:
//
// An error occurred while reading from a stream of data. An unexpected number of bytes was returned.
//
static const long ERROR_CLUSTER_PARTIAL_READ = 5921L;
//
// MessageId: ERROR_CLUSTER_PARTIAL_WRITE
//
// MessageText:
//
// An error occurred while writing to a stream of data. The required number of bytes could not be written.
//
static const long ERROR_CLUSTER_PARTIAL_WRITE = 5922L;
//
// MessageId: ERROR_CLUSTER_CANT_DESERIALIZE_DATA
//
// MessageText:
//
// An error occurred while deserializing a stream of cluster data.
//
static const long ERROR_CLUSTER_CANT_DESERIALIZE_DATA = 5923L;
//
// MessageId: ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT
//
// MessageText:
//
// One or more property values for this resource are in conflict with one or more property values associated with its dependent resource(s).
//
static const long ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT = 5924L;
//
// MessageId: ERROR_CLUSTER_NO_QUORUM
//
// MessageText:
//
// A quorum of cluster nodes was not present to form a cluster.
//
static const long ERROR_CLUSTER_NO_QUORUM = 5925L;
//
// MessageId: ERROR_CLUSTER_INVALID_IPV6_NETWORK
//
// MessageText:
//
// The cluster network is not valid for an IPv6 Address resource, or it does not match the configured address.
//
static const long ERROR_CLUSTER_INVALID_IPV6_NETWORK = 5926L;
//
// MessageId: ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK
//
// MessageText:
//
// The cluster network is not valid for an IPv6 Tunnel resource. Check the configuration of the IP Address resource on which the IPv6 Tunnel resource depends.
//
static const long ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = 5927L;
//
// MessageId: ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP
//
// MessageText:
//
// Quorum resource cannot reside in the Available Storage group.
//
static const long ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP = 5928L;
//
// MessageId: ERROR_DEPENDENCY_TREE_TOO_COMPLEX
//
// MessageText:
//
// The dependencies for this resource are nested too deeply.
//
static const long ERROR_DEPENDENCY_TREE_TOO_COMPLEX = 5929L;
//
// MessageId: ERROR_EXCEPTION_IN_RESOURCE_CALL
//
// MessageText:
//
// The call into the resource DLL raised an unhandled exception.
//
static const long ERROR_EXCEPTION_IN_RESOURCE_CALL = 5930L;
//
// MessageId: ERROR_CLUSTER_RHS_FAILED_INITIALIZATION
//
// MessageText:
//
// The RHS process failed to initialize.
//
static const long ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = 5931L;
//
// MessageId: ERROR_CLUSTER_NOT_INSTALLED
//
// MessageText:
//
// The Failover Clustering feature is not installed on this node.
//
static const long ERROR_CLUSTER_NOT_INSTALLED = 5932L;
//
// MessageId: ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE
//
// MessageText:
//
// The resources must be online on the same node for this operation
//
static const long ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = 5933L;
//
// MessageId: ERROR_CLUSTER_MAX_NODES_IN_CLUSTER
//
// MessageText:
//
// A new node can not be added since this cluster is already at its maximum number of nodes.
//
static const long ERROR_CLUSTER_MAX_NODES_IN_CLUSTER = 5934L;
//
// MessageId: ERROR_CLUSTER_TOO_MANY_NODES
//
// MessageText:
//
// This cluster can not be created since the specified number of nodes exceeds the maximum allowed limit.
//
static const long ERROR_CLUSTER_TOO_MANY_NODES = 5935L;
//
// MessageId: ERROR_CLUSTER_OBJECT_ALREADY_USED
//
// MessageText:
//
// An attempt to use the specified cluster name failed because an enabled computer object with the given name already exists in the domain.
//
static const long ERROR_CLUSTER_OBJECT_ALREADY_USED = 5936L;
//
// MessageId: ERROR_NONCORE_GROUPS_FOUND
//
// MessageText:
//
// This cluster cannot be destroyed. It has non-core application groups which must be deleted before the cluster can be destroyed.
//
static const long ERROR_NONCORE_GROUPS_FOUND = 5937L;
//
// MessageId: ERROR_FILE_SHARE_RESOURCE_CONFLICT
//
// MessageText:
//
// File share associated with file share witness resource cannot be hosted by this cluster or any of its nodes.
//
static const long ERROR_FILE_SHARE_RESOURCE_CONFLICT = 5938L;
//
// MessageId: ERROR_CLUSTER_EVICT_INVALID_REQUEST
//
// MessageText:
//
// Eviction of this node is invalid at this time. Due to quorum requirements node eviction will result in cluster shutdown.
// If it is the last node in the cluster, destroy cluster command should be used.
//
static const long ERROR_CLUSTER_EVICT_INVALID_REQUEST = 5939L;
//
// MessageId: ERROR_CLUSTER_SINGLETON_RESOURCE
//
// MessageText:
//
// Only one instance of this resource type is allowed in the cluster.
//
static const long ERROR_CLUSTER_SINGLETON_RESOURCE = 5940L;
//
// MessageId: ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE
//
// MessageText:
//
// Only one instance of this resource type is allowed per resource group.
//
static const long ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = 5941L;
//
// MessageId: ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED
//
// MessageText:
//
// The resource failed to come online due to the failure of one or more provider resources.
//
static const long ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED = 5942L;
//
// MessageId: ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR
//
// MessageText:
//
// The resource has indicated that it cannot come online on any node.
//
static const long ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = 5943L;
//
// MessageId: ERROR_CLUSTER_GROUP_BUSY
//
// MessageText:
//
// The current operation cannot be performed on this group at this time.
//
static const long ERROR_CLUSTER_GROUP_BUSY = 5944L;
//
// MessageId: ERROR_CLUSTER_NOT_SHARED_VOLUME
//
// MessageText:
//
// The directory or file is not located on a cluster shared volume.
//
static const long ERROR_CLUSTER_NOT_SHARED_VOLUME = 5945L;
//
// MessageId: ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR
//
// MessageText:
//
// The Security Descriptor does not meet the requirements for a cluster.
//
static const long ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = 5946L;
//
// MessageId: ERROR_CLUSTER_SHARED_VOLUMES_IN_USE
//
// MessageText:
//
// There is one or more shared volumes resources configured in the cluster.
// Those resources must be moved to available storage in order for operation to succeed.
//
static const long ERROR_CLUSTER_SHARED_VOLUMES_IN_USE = 5947L;
//
// MessageId: ERROR_CLUSTER_USE_SHARED_VOLUMES_API
//
// MessageText:
//
// This group or resource cannot be directly manipulated.
// Use shared volume APIs to perform desired operation.
//
static const long ERROR_CLUSTER_USE_SHARED_VOLUMES_API = 5948L;
//
// MessageId: ERROR_CLUSTER_BACKUP_IN_PROGRESS
//
// MessageText:
//
// Back up is in progress. Please wait for backup completion before trying this operation again.
//
static const long ERROR_CLUSTER_BACKUP_IN_PROGRESS = 5949L;
//
// MessageId: ERROR_NON_CSV_PATH
//
// MessageText:
//
// The path does not belong to a cluster shared volume.
//
static const long ERROR_NON_CSV_PATH = 5950L;
//
// MessageId: ERROR_CSV_VOLUME_NOT_LOCAL
//
// MessageText:
//
// The cluster shared volume is not locally mounted on this node.
//
static const long ERROR_CSV_VOLUME_NOT_LOCAL = 5951L;
//
// MessageId: ERROR_CLUSTER_WATCHDOG_TERMINATING
//
// MessageText:
//
// The cluster watchdog is terminating.
//
static const long ERROR_CLUSTER_WATCHDOG_TERMINATING = 5952L;
///////////////////////////////////////////////////
//                                               //
//               EFS Error codes                 //
//                                               //
//                 6000 to 6099                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_ENCRYPTION_FAILED
//
// MessageText:
//
// The specified file could not be encrypted.
//
static const long ERROR_ENCRYPTION_FAILED = 6000L;
//
// MessageId: ERROR_DECRYPTION_FAILED
//
// MessageText:
//
// The specified file could not be decrypted.
//
static const long ERROR_DECRYPTION_FAILED = 6001L;
//
// MessageId: ERROR_FILE_ENCRYPTED
//
// MessageText:
//
// The specified file is encrypted and the user does not have the ability to decrypt it.
//
static const long ERROR_FILE_ENCRYPTED = 6002L;
//
// MessageId: ERROR_NO_RECOVERY_POLICY
//
// MessageText:
//
// There is no valid encryption recovery policy configured for this system.
//
static const long ERROR_NO_RECOVERY_POLICY = 6003L;
//
// MessageId: ERROR_NO_EFS
//
// MessageText:
//
// The required encryption driver is not loaded for this system.
//
static const long ERROR_NO_EFS = 6004L;
//
// MessageId: ERROR_WRONG_EFS
//
// MessageText:
//
// The file was encrypted with a different encryption driver than is currently loaded.
//
static const long ERROR_WRONG_EFS = 6005L;
//
// MessageId: ERROR_NO_USER_KEYS
//
// MessageText:
//
// There are no EFS keys defined for the user.
//
static const long ERROR_NO_USER_KEYS = 6006L;
//
// MessageId: ERROR_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// The specified file is not encrypted.
//
static const long ERROR_FILE_NOT_ENCRYPTED = 6007L;
//
// MessageId: ERROR_NOT_EXPORT_FORMAT
//
// MessageText:
//
// The specified file is not in the defined EFS export format.
//
static const long ERROR_NOT_EXPORT_FORMAT = 6008L;
//
// MessageId: ERROR_FILE_READ_ONLY
//
// MessageText:
//
// The specified file is read only.
//
static const long ERROR_FILE_READ_ONLY = 6009L;
//
// MessageId: ERROR_DIR_EFS_DISALLOWED
//
// MessageText:
//
// The directory has been disabled for encryption.
//
static const long ERROR_DIR_EFS_DISALLOWED = 6010L;
//
// MessageId: ERROR_EFS_SERVER_NOT_TRUSTED
//
// MessageText:
//
// The server is not trusted for remote encryption operation.
//
static const long ERROR_EFS_SERVER_NOT_TRUSTED = 6011L;
//
// MessageId: ERROR_BAD_RECOVERY_POLICY
//
// MessageText:
//
// Recovery policy configured for this system contains invalid recovery certificate.
//
static const long ERROR_BAD_RECOVERY_POLICY = 6012L;
//
// MessageId: ERROR_EFS_ALG_BLOB_TOO_BIG
//
// MessageText:
//
// The encryption algorithm used on the source file needs a bigger key buffer than the one on the destination file.
//
static const long ERROR_EFS_ALG_BLOB_TOO_BIG = 6013L;
//
// MessageId: ERROR_VOLUME_NOT_SUPPORT_EFS
//
// MessageText:
//
// The disk partition does not support file encryption.
//
static const long ERROR_VOLUME_NOT_SUPPORT_EFS = 6014L;
//
// MessageId: ERROR_EFS_DISABLED
//
// MessageText:
//
// This machine is disabled for file encryption.
//
static const long ERROR_EFS_DISABLED = 6015L;
//
// MessageId: ERROR_EFS_VERSION_NOT_SUPPORT
//
// MessageText:
//
// A newer system is required to decrypt this encrypted file.
//
static const long ERROR_EFS_VERSION_NOT_SUPPORT = 6016L;
//
// MessageId: ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The remote server sent an invalid response for a file being opened with Client Side Encryption.
//
static const long ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 6017L;
//
// MessageId: ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER
//
// MessageText:
//
// Client Side Encryption is not supported by the remote server even though it claims to support it.
//
static const long ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER = 6018L;
//
// MessageId: ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE
//
// MessageText:
//
// File is encrypted and should be opened in Client Side Encryption mode.
//
static const long ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 6019L;
//
// MessageId: ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE
//
// MessageText:
//
// A new encrypted file is being created and a $EFS needs to be provided.
//
static const long ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 6020L;
//
// MessageId: ERROR_CS_ENCRYPTION_FILE_NOT_CSE
//
// MessageText:
//
// The SMB client requested a CSE FSCTL on a non-CSE file.
//
static const long ERROR_CS_ENCRYPTION_FILE_NOT_CSE = 6021L;
//
// MessageId: ERROR_ENCRYPTION_POLICY_DENIES_OPERATION
//
// MessageText:
//
// The requested operation was blocked by policy. For more information, contact your system administrator.
//
static const long ERROR_ENCRYPTION_POLICY_DENIES_OPERATION = 6022L;
///////////////////////////////////////////////////
//                                               //
//              BROWSER Error codes              //
//                                               //
//                 6100 to 6199                  //
///////////////////////////////////////////////////
// This message number is for historical purposes and cannot be changed or re-used.
//
// MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
// The list of servers for this workgroup is not currently available
//
static const long ERROR_NO_BROWSER_SERVERS_FOUND = 6118L;
///////////////////////////////////////////////////
//                                               //
//            Task Scheduler Error codes         //
//            NET START must understand          //
//                                               //
//                 6200 to 6249                  //
///////////////////////////////////////////////////
//
// MessageId: SCHED_E_SERVICE_NOT_LOCALSYSTEM
//
// MessageText:
//
// The Task Scheduler service must be configured to run in the System account to function properly. Individual tasks may be configured to run in other accounts.
//
static const long SCHED_E_SERVICE_NOT_LOCALSYSTEM = 6200L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 6250 to 6599                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//         Common Log (CLFS) Error codes         //
//                                               //
//                 6600 to 6699                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_LOG_SECTOR_INVALID
//
// MessageText:
//
// Log service encountered an invalid log sector.
//
static const long ERROR_LOG_SECTOR_INVALID = 6600L;
//
// MessageId: ERROR_LOG_SECTOR_PARITY_INVALID
//
// MessageText:
//
// Log service encountered a log sector with invalid block parity.
//
static const long ERROR_LOG_SECTOR_PARITY_INVALID = 6601L;
//
// MessageId: ERROR_LOG_SECTOR_REMAPPED
//
// MessageText:
//
// Log service encountered a remapped log sector.
//
static const long ERROR_LOG_SECTOR_REMAPPED = 6602L;
//
// MessageId: ERROR_LOG_BLOCK_INCOMPLETE
//
// MessageText:
//
// Log service encountered a partial or incomplete log block.
//
static const long ERROR_LOG_BLOCK_INCOMPLETE = 6603L;
//
// MessageId: ERROR_LOG_INVALID_RANGE
//
// MessageText:
//
// Log service encountered an attempt access data outside the active log range.
//
static const long ERROR_LOG_INVALID_RANGE = 6604L;
//
// MessageId: ERROR_LOG_BLOCKS_EXHAUSTED
//
// MessageText:
//
// Log service user marshalling buffers are exhausted.
//
static const long ERROR_LOG_BLOCKS_EXHAUSTED = 6605L;
//
// MessageId: ERROR_LOG_READ_CONTEXT_INVALID
//
// MessageText:
//
// Log service encountered an attempt read from a marshalling area with an invalid read context.
//
static const long ERROR_LOG_READ_CONTEXT_INVALID = 6606L;
//
// MessageId: ERROR_LOG_RESTART_INVALID
//
// MessageText:
//
// Log service encountered an invalid log restart area.
//
static const long ERROR_LOG_RESTART_INVALID = 6607L;
//
// MessageId: ERROR_LOG_BLOCK_VERSION
//
// MessageText:
//
// Log service encountered an invalid log block version.
//
static const long ERROR_LOG_BLOCK_VERSION = 6608L;
//
// MessageId: ERROR_LOG_BLOCK_INVALID
//
// MessageText:
//
// Log service encountered an invalid log block.
//
static const long ERROR_LOG_BLOCK_INVALID = 6609L;
//
// MessageId: ERROR_LOG_READ_MODE_INVALID
//
// MessageText:
//
// Log service encountered an attempt to read the log with an invalid read mode.
//
static const long ERROR_LOG_READ_MODE_INVALID = 6610L;
//
// MessageId: ERROR_LOG_NO_RESTART
//
// MessageText:
//
// Log service encountered a log stream with no restart area.
//
static const long ERROR_LOG_NO_RESTART = 6611L;
//
// MessageId: ERROR_LOG_METADATA_CORRUPT
//
// MessageText:
//
// Log service encountered a corrupted metadata file.
//
static const long ERROR_LOG_METADATA_CORRUPT = 6612L;
//
// MessageId: ERROR_LOG_METADATA_INVALID
//
// MessageText:
//
// Log service encountered a metadata file that could not be created by the log file system.
//
static const long ERROR_LOG_METADATA_INVALID = 6613L;
//
// MessageId: ERROR_LOG_METADATA_INCONSISTENT
//
// MessageText:
//
// Log service encountered a metadata file with inconsistent data.
//
static const long ERROR_LOG_METADATA_INCONSISTENT = 6614L;
//
// MessageId: ERROR_LOG_RESERVATION_INVALID
//
// MessageText:
//
// Log service encountered an attempt to erroneous allocate or dispose reservation space.
//
static const long ERROR_LOG_RESERVATION_INVALID = 6615L;
//
// MessageId: ERROR_LOG_CANT_DELETE
//
// MessageText:
//
// Log service cannot delete log file or file system container.
//
static const long ERROR_LOG_CANT_DELETE = 6616L;
//
// MessageId: ERROR_LOG_CONTAINER_LIMIT_EXCEEDED
//
// MessageText:
//
// Log service has reached the maximum allowable containers allocated to a log file.
//
static const long ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = 6617L;
//
// MessageId: ERROR_LOG_START_OF_LOG
//
// MessageText:
//
// Log service has attempted to read or write backward past the start of the log.
//
static const long ERROR_LOG_START_OF_LOG = 6618L;
//
// MessageId: ERROR_LOG_POLICY_ALREADY_INSTALLED
//
// MessageText:
//
// Log policy could not be installed because a policy of the same type is already present.
//
static const long ERROR_LOG_POLICY_ALREADY_INSTALLED = 6619L;
//
// MessageId: ERROR_LOG_POLICY_NOT_INSTALLED
//
// MessageText:
//
// Log policy in question was not installed at the time of the request.
//
static const long ERROR_LOG_POLICY_NOT_INSTALLED = 6620L;
//
// MessageId: ERROR_LOG_POLICY_INVALID
//
// MessageText:
//
// The installed set of policies on the log is invalid.
//
static const long ERROR_LOG_POLICY_INVALID = 6621L;
//
// MessageId: ERROR_LOG_POLICY_CONFLICT
//
// MessageText:
//
// A policy on the log in question prevented the operation from completing.
//
static const long ERROR_LOG_POLICY_CONFLICT = 6622L;
//
// MessageId: ERROR_LOG_PINNED_ARCHIVE_TAIL
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned by the archive tail.
//
static const long ERROR_LOG_PINNED_ARCHIVE_TAIL = 6623L;
//
// MessageId: ERROR_LOG_RECORD_NONEXISTENT
//
// MessageText:
//
// Log record is not a record in the log file.
//
static const long ERROR_LOG_RECORD_NONEXISTENT = 6624L;
//
// MessageId: ERROR_LOG_RECORDS_RESERVED_INVALID
//
// MessageText:
//
// Number of reserved log records or the adjustment of the number of reserved log records is invalid.
//
static const long ERROR_LOG_RECORDS_RESERVED_INVALID = 6625L;
//
// MessageId: ERROR_LOG_SPACE_RESERVED_INVALID
//
// MessageText:
//
// Reserved log space or the adjustment of the log space is invalid.
//
static const long ERROR_LOG_SPACE_RESERVED_INVALID = 6626L;
//
// MessageId: ERROR_LOG_TAIL_INVALID
//
// MessageText:
//
// An new or existing archive tail or base of the active log is invalid.
//
static const long ERROR_LOG_TAIL_INVALID = 6627L;
//
// MessageId: ERROR_LOG_FULL
//
// MessageText:
//
// Log space is exhausted.
//
static const long ERROR_LOG_FULL = 6628L;
//
// MessageId: ERROR_COULD_NOT_RESIZE_LOG
//
// MessageText:
//
// The log could not be set to the requested size.
//
static const long ERROR_COULD_NOT_RESIZE_LOG = 6629L;
//
// MessageId: ERROR_LOG_MULTIPLEXED
//
// MessageText:
//
// Log is multiplexed, no direct writes to the physical log is allowed.
//
static const long ERROR_LOG_MULTIPLEXED = 6630L;
//
// MessageId: ERROR_LOG_DEDICATED
//
// MessageText:
//
// The operation failed because the log is a dedicated log.
//
static const long ERROR_LOG_DEDICATED = 6631L;
//
// MessageId: ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS
//
// MessageText:
//
// The operation requires an archive context.
//
static const long ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = 6632L;
//
// MessageId: ERROR_LOG_ARCHIVE_IN_PROGRESS
//
// MessageText:
//
// Log archival is in progress.
//
static const long ERROR_LOG_ARCHIVE_IN_PROGRESS = 6633L;
//
// MessageId: ERROR_LOG_EPHEMERAL
//
// MessageText:
//
// The operation requires a non-ephemeral log, but the log is ephemeral.
//
static const long ERROR_LOG_EPHEMERAL = 6634L;
//
// MessageId: ERROR_LOG_NOT_ENOUGH_CONTAINERS
//
// MessageText:
//
// The log must have at least two containers before it can be read from or written to.
//
static const long ERROR_LOG_NOT_ENOUGH_CONTAINERS = 6635L;
//
// MessageId: ERROR_LOG_CLIENT_ALREADY_REGISTERED
//
// MessageText:
//
// A log client has already registered on the stream.
//
static const long ERROR_LOG_CLIENT_ALREADY_REGISTERED = 6636L;
//
// MessageId: ERROR_LOG_CLIENT_NOT_REGISTERED
//
// MessageText:
//
// A log client has not been registered on the stream.
//
static const long ERROR_LOG_CLIENT_NOT_REGISTERED = 6637L;
//
// MessageId: ERROR_LOG_FULL_HANDLER_IN_PROGRESS
//
// MessageText:
//
// A request has already been made to handle the log full condition.
//
static const long ERROR_LOG_FULL_HANDLER_IN_PROGRESS = 6638L;
//
// MessageId: ERROR_LOG_CONTAINER_READ_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to read from a log container.
//
static const long ERROR_LOG_CONTAINER_READ_FAILED = 6639L;
//
// MessageId: ERROR_LOG_CONTAINER_WRITE_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to write to a log container.
//
static const long ERROR_LOG_CONTAINER_WRITE_FAILED = 6640L;
//
// MessageId: ERROR_LOG_CONTAINER_OPEN_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting open a log container.
//
static const long ERROR_LOG_CONTAINER_OPEN_FAILED = 6641L;
//
// MessageId: ERROR_LOG_CONTAINER_STATE_INVALID
//
// MessageText:
//
// Log service encountered an invalid container state when attempting a requested action.
//
static const long ERROR_LOG_CONTAINER_STATE_INVALID = 6642L;
//
// MessageId: ERROR_LOG_STATE_INVALID
//
// MessageText:
//
// Log service is not in the correct state to perform a requested action.
//
static const long ERROR_LOG_STATE_INVALID = 6643L;
//
// MessageId: ERROR_LOG_PINNED
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned.
//
static const long ERROR_LOG_PINNED = 6644L;
//
// MessageId: ERROR_LOG_METADATA_FLUSH_FAILED
//
// MessageText:
//
// Log metadata flush failed.
//
static const long ERROR_LOG_METADATA_FLUSH_FAILED = 6645L;
//
// MessageId: ERROR_LOG_INCONSISTENT_SECURITY
//
// MessageText:
//
// Security on the log and its containers is inconsistent.
//
static const long ERROR_LOG_INCONSISTENT_SECURITY = 6646L;
//
// MessageId: ERROR_LOG_APPENDED_FLUSH_FAILED
//
// MessageText:
//
// Records were appended to the log or reservation changes were made, but the log could not be flushed.
//
static const long ERROR_LOG_APPENDED_FLUSH_FAILED = 6647L;
//
// MessageId: ERROR_LOG_PINNED_RESERVATION
//
// MessageText:
//
// The log is pinned due to reservation consuming most of the log space. Free some reserved records to make space available.
//
static const long ERROR_LOG_PINNED_RESERVATION = 6648L;
///////////////////////////////////////////////////
//                                               //
//           Transaction (KTM) Error codes       //
//                                               //
//                 6700 to 6799                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_INVALID_TRANSACTION
//
// MessageText:
//
// The transaction handle associated with this operation is not valid.
//
static const long ERROR_INVALID_TRANSACTION = 6700L;
//
// MessageId: ERROR_TRANSACTION_NOT_ACTIVE
//
// MessageText:
//
// The requested operation was made in the context of a transaction that is no longer active.
//
static const long ERROR_TRANSACTION_NOT_ACTIVE = 6701L;
//
// MessageId: ERROR_TRANSACTION_REQUEST_NOT_VALID
//
// MessageText:
//
// The requested operation is not valid on the Transaction object in its current state.
//
static const long ERROR_TRANSACTION_REQUEST_NOT_VALID = 6702L;
//
// MessageId: ERROR_TRANSACTION_NOT_REQUESTED
//
// MessageText:
//
// The caller has called a response API, but the response is not expected because the TM did not issue the corresponding request to the caller.
//
static const long ERROR_TRANSACTION_NOT_REQUESTED = 6703L;
//
// MessageId: ERROR_TRANSACTION_ALREADY_ABORTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been aborted.
//
static const long ERROR_TRANSACTION_ALREADY_ABORTED = 6704L;
//
// MessageId: ERROR_TRANSACTION_ALREADY_COMMITTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been committed.
//
static const long ERROR_TRANSACTION_ALREADY_COMMITTED = 6705L;
//
// MessageId: ERROR_TM_INITIALIZATION_FAILED
//
// MessageText:
//
// The Transaction Manager was unable to be successfully initialized. Transacted operations are not supported.
//
static const long ERROR_TM_INITIALIZATION_FAILED = 6706L;
//
// MessageId: ERROR_RESOURCEMANAGER_READ_ONLY
//
// MessageText:
//
// The specified ResourceManager made no changes or updates to the resource under this transaction.
//
static const long ERROR_RESOURCEMANAGER_READ_ONLY = 6707L;
//
// MessageId: ERROR_TRANSACTION_NOT_JOINED
//
// MessageText:
//
// The resource manager has attempted to prepare a transaction that it has not successfully joined.
//
static const long ERROR_TRANSACTION_NOT_JOINED = 6708L;
//
// MessageId: ERROR_TRANSACTION_SUPERIOR_EXISTS
//
// MessageText:
//
// The Transaction object already has a superior enlistment, and the caller attempted an operation that would have created a new superior. Only a single superior enlistment is allow.
//
static const long ERROR_TRANSACTION_SUPERIOR_EXISTS = 6709L;
//
// MessageId: ERROR_CRM_PROTOCOL_ALREADY_EXISTS
//
// MessageText:
//
// The RM tried to register a protocol that already exists.
//
static const long ERROR_CRM_PROTOCOL_ALREADY_EXISTS = 6710L;
//
// MessageId: ERROR_TRANSACTION_PROPAGATION_FAILED
//
// MessageText:
//
// The attempt to propagate the Transaction failed.
//
static const long ERROR_TRANSACTION_PROPAGATION_FAILED = 6711L;
//
// MessageId: ERROR_CRM_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// The requested propagation protocol was not registered as a CRM.
//
static const long ERROR_CRM_PROTOCOL_NOT_FOUND = 6712L;
//
// MessageId: ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER
//
// MessageText:
//
// The buffer passed in to PushTransaction or PullTransaction is not in a valid format.
//
static const long ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = 6713L;
//
// MessageId: ERROR_CURRENT_TRANSACTION_NOT_VALID
//
// MessageText:
//
// The current transaction context associated with the thread is not a valid handle to a transaction object.
//
static const long ERROR_CURRENT_TRANSACTION_NOT_VALID = 6714L;
//
// MessageId: ERROR_TRANSACTION_NOT_FOUND
//
// MessageText:
//
// The specified Transaction object could not be opened, because it was not found.
//
static const long ERROR_TRANSACTION_NOT_FOUND = 6715L;
//
// MessageId: ERROR_RESOURCEMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified ResourceManager object could not be opened, because it was not found.
//
static const long ERROR_RESOURCEMANAGER_NOT_FOUND = 6716L;
//
// MessageId: ERROR_ENLISTMENT_NOT_FOUND
//
// MessageText:
//
// The specified Enlistment object could not be opened, because it was not found.
//
static const long ERROR_ENLISTMENT_NOT_FOUND = 6717L;
//
// MessageId: ERROR_TRANSACTIONMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified TransactionManager object could not be opened, because it was not found.
//
static const long ERROR_TRANSACTIONMANAGER_NOT_FOUND = 6718L;
//
// MessageId: ERROR_TRANSACTIONMANAGER_NOT_ONLINE
//
// MessageText:
//
// The object specified could not be created or opened, because its associated TransactionManager is not online.  The TransactionManager must be brought fully Online by calling RecoverTransactionManager to recover to the end of its LogFile before objects in its Transaction or ResourceManager namespaces can be opened.  In addition, errors in writing records to its LogFile can cause a TransactionManager to go offline.
//
static const long ERROR_TRANSACTIONMANAGER_NOT_ONLINE = 6719L;
//
// MessageId: ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION
//
// MessageText:
//
// The specified TransactionManager was unable to create the objects contained in its logfile in the Ob namespace. Therefore, the TransactionManager was unable to recover.
//
static const long ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 6720L;
//
// MessageId: ERROR_TRANSACTION_NOT_ROOT
//
// MessageText:
//
// The call to create a superior Enlistment on this Transaction object could not be completed, because the Transaction object specified for the enlistment is a subordinate branch of the Transaction. Only the root of the Transaction can be enlisted on as a superior.
//
static const long ERROR_TRANSACTION_NOT_ROOT = 6721L;
//
// MessageId: ERROR_TRANSACTION_OBJECT_EXPIRED
//
// MessageText:
//
// Because the associated transaction manager or resource manager has been closed, the handle is no longer valid.
//
static const long ERROR_TRANSACTION_OBJECT_EXPIRED = 6722L;
//
// MessageId: ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed on this Superior enlistment, because the enlistment was not created with the corresponding completion response in the NotificationMask.
//
static const long ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = 6723L;
//
// MessageId: ERROR_TRANSACTION_RECORD_TOO_LONG
//
// MessageText:
//
// The specified operation could not be performed, because the record that would be logged was too long. This can occur because of two conditions: either there are too many Enlistments on this Transaction, or the combined RecoveryInformation being logged on behalf of those Enlistments is too long.
//
static const long ERROR_TRANSACTION_RECORD_TOO_LONG = 6724L;
//
// MessageId: ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED
//
// MessageText:
//
// Implicit transaction are not supported.
//
static const long ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED = 6725L;
//
// MessageId: ERROR_TRANSACTION_INTEGRITY_VIOLATED
//
// MessageText:
//
// The kernel transaction manager had to abort or forget the transaction because it blocked forward progress.
//
static const long ERROR_TRANSACTION_INTEGRITY_VIOLATED = 6726L;
//
// MessageId: ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH
//
// MessageText:
//
// The TransactionManager identity that was supplied did not match the one recorded in the TransactionManager's log file.
//
static const long ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 6727L;
//
// MessageId: ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT
//
// MessageText:
//
// This snapshot operation cannot continue because a transactional resource manager cannot be frozen in its current state.  Please try again.
//
static const long ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 6728L;
//
// MessageId: ERROR_TRANSACTION_MUST_WRITETHROUGH
//
// MessageText:
//
// The transaction cannot be enlisted on with the specified EnlistmentMask, because the transaction has already completed the PrePrepare phase.  In order to ensure correctness, the ResourceManager must switch to a write-through mode and cease caching data within this transaction.  Enlisting for only subsequent transaction phases may still succeed.
//
static const long ERROR_TRANSACTION_MUST_WRITETHROUGH = 6729L;
//
// MessageId: ERROR_TRANSACTION_NO_SUPERIOR
//
// MessageText:
//
// The transaction does not have a superior enlistment.
//
static const long ERROR_TRANSACTION_NO_SUPERIOR = 6730L;
//
// MessageId: ERROR_HEURISTIC_DAMAGE_POSSIBLE
//
// MessageText:
//
// The attempt to commit the Transaction completed, but it is possible that some portion of the transaction tree did not commit successfully due to heuristics.  Therefore it is possible that some data modified in the transaction may not have committed, resulting in transactional inconsistency.  If possible, check the consistency of the associated data.
//
static const long ERROR_HEURISTIC_DAMAGE_POSSIBLE = 6731L;
///////////////////////////////////////////////////
//                                               //
//        Transactional File Services (TxF)      //
//                  Error codes                  //
//                                               //
//                 6800 to 6899                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_TRANSACTIONAL_CONFLICT
//
// MessageText:
//
// The function attempted to use a name that is reserved for use by another transaction.
//
static const long ERROR_TRANSACTIONAL_CONFLICT = 6800L;
//
// MessageId: ERROR_RM_NOT_ACTIVE
//
// MessageText:
//
// Transaction support within the specified resource manager is not started or was shut down due to an error.
//
static const long ERROR_RM_NOT_ACTIVE = 6801L;
//
// MessageId: ERROR_RM_METADATA_CORRUPT
//
// MessageText:
//
// The metadata of the RM has been corrupted. The RM will not function.
//
static const long ERROR_RM_METADATA_CORRUPT = 6802L;
//
// MessageId: ERROR_DIRECTORY_NOT_RM
//
// MessageText:
//
// The specified directory does not contain a resource manager.
//
static const long ERROR_DIRECTORY_NOT_RM = 6803L;
//
// MessageId: ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE
//
// MessageText:
//
// The remote server or share does not support transacted file operations.
//
static const long ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = 6805L;
//
// MessageId: ERROR_LOG_RESIZE_INVALID_SIZE
//
// MessageText:
//
// The requested log size is invalid.
//
static const long ERROR_LOG_RESIZE_INVALID_SIZE = 6806L;
//
// MessageId: ERROR_OBJECT_NO_LONGER_EXISTS
//
// MessageText:
//
// The object (file, stream, link) corresponding to the handle has been deleted by a Transaction Savepoint Rollback.
//
static const long ERROR_OBJECT_NO_LONGER_EXISTS = 6807L;
//
// MessageId: ERROR_STREAM_MINIVERSION_NOT_FOUND
//
// MessageText:
//
// The specified file miniversion was not found for this transacted file open.
//
static const long ERROR_STREAM_MINIVERSION_NOT_FOUND = 6808L;
//
// MessageId: ERROR_STREAM_MINIVERSION_NOT_VALID
//
// MessageText:
//
// The specified file miniversion was found but has been invalidated. Most likely cause is a transaction savepoint rollback.
//
static const long ERROR_STREAM_MINIVERSION_NOT_VALID = 6809L;
//
// MessageId: ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION
//
// MessageText:
//
// A miniversion may only be opened in the context of the transaction that created it.
//
static const long ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 6810L;
//
// MessageId: ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT
//
// MessageText:
//
// It is not possible to open a miniversion with modify access.
//
static const long ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 6811L;
//
// MessageId: ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS
//
// MessageText:
//
// It is not possible to create any more miniversions for this stream.
//
static const long ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 6812L;
//
// MessageId: ERROR_REMOTE_FILE_VERSION_MISMATCH
//
// MessageText:
//
// The remote server sent mismatching version number or Fid for a file opened with transactions.
//
static const long ERROR_REMOTE_FILE_VERSION_MISMATCH = 6814L;
//
// MessageId: ERROR_HANDLE_NO_LONGER_VALID
//
// MessageText:
//
// The handle has been invalidated by a transaction. The most likely cause is the presence of memory mapping on a file or an open handle when the transaction ended or rolled back to savepoint.
//
static const long ERROR_HANDLE_NO_LONGER_VALID = 6815L;
//
// MessageId: ERROR_NO_TXF_METADATA
//
// MessageText:
//
// There is no transaction metadata on the file.
//
static const long ERROR_NO_TXF_METADATA = 6816L;
//
// MessageId: ERROR_LOG_CORRUPTION_DETECTED
//
// MessageText:
//
// The log data is corrupt.
//
static const long ERROR_LOG_CORRUPTION_DETECTED = 6817L;
//
// MessageId: ERROR_CANT_RECOVER_WITH_HANDLE_OPEN
//
// MessageText:
//
// The file can't be recovered because there is a handle still open on it.
//
static const long ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = 6818L;
//
// MessageId: ERROR_RM_DISCONNECTED
//
// MessageText:
//
// The transaction outcome is unavailable because the resource manager responsible for it has disconnected.
//
static const long ERROR_RM_DISCONNECTED = 6819L;
//
// MessageId: ERROR_ENLISTMENT_NOT_SUPERIOR
//
// MessageText:
//
// The request was rejected because the enlistment in question is not a superior enlistment.
//
static const long ERROR_ENLISTMENT_NOT_SUPERIOR = 6820L;
//
// MessageId: ERROR_RECOVERY_NOT_NEEDED
//
// MessageText:
//
// The transactional resource manager is already consistent. Recovery is not needed.
//
static const long ERROR_RECOVERY_NOT_NEEDED = 6821L;
//
// MessageId: ERROR_RM_ALREADY_STARTED
//
// MessageText:
//
// The transactional resource manager has already been started.
//
static const long ERROR_RM_ALREADY_STARTED = 6822L;
//
// MessageId: ERROR_FILE_IDENTITY_NOT_PERSISTENT
//
// MessageText:
//
// The file cannot be opened transactionally, because its identity depends on the outcome of an unresolved transaction.
//
static const long ERROR_FILE_IDENTITY_NOT_PERSISTENT = 6823L;
//
// MessageId: ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY
//
// MessageText:
//
// The operation cannot be performed because another transaction is depending on the fact that this property will not change.
//
static const long ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 6824L;
//
// MessageId: ERROR_CANT_CROSS_RM_BOUNDARY
//
// MessageText:
//
// The operation would involve a single file with two transactional resource managers and is therefore not allowed.
//
static const long ERROR_CANT_CROSS_RM_BOUNDARY = 6825L;
//
// MessageId: ERROR_TXF_DIR_NOT_EMPTY
//
// MessageText:
//
// The $Txf directory must be empty for this operation to succeed.
//
static const long ERROR_TXF_DIR_NOT_EMPTY = 6826L;
//
// MessageId: ERROR_INDOUBT_TRANSACTIONS_EXIST
//
// MessageText:
//
// The operation would leave a transactional resource manager in an inconsistent state and is therefore not allowed.
//
static const long ERROR_INDOUBT_TRANSACTIONS_EXIST = 6827L;
//
// MessageId: ERROR_TM_VOLATILE
//
// MessageText:
//
// The operation could not be completed because the transaction manager does not have a log.
//
static const long ERROR_TM_VOLATILE = 6828L;
//
// MessageId: ERROR_ROLLBACK_TIMER_EXPIRED
//
// MessageText:
//
// A rollback could not be scheduled because a previously scheduled rollback has already executed or been queued for execution.
//
static const long ERROR_ROLLBACK_TIMER_EXPIRED = 6829L;
//
// MessageId: ERROR_TXF_ATTRIBUTE_CORRUPT
//
// MessageText:
//
// The transactional metadata attribute on the file or directory is corrupt and unreadable.
//
static const long ERROR_TXF_ATTRIBUTE_CORRUPT = 6830L;
//
// MessageId: ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The encryption operation could not be completed because a transaction is active.
//
static const long ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION = 6831L;
//
// MessageId: ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED
//
// MessageText:
//
// This object is not allowed to be opened in a transaction.
//
static const long ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = 6832L;
//
// MessageId: ERROR_LOG_GROWTH_FAILED
//
// MessageText:
//
// An attempt to create space in the transactional resource manager's log failed. The failure status has been recorded in the event log.
//
static const long ERROR_LOG_GROWTH_FAILED = 6833L;
//
// MessageId: ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE
//
// MessageText:
//
// Memory mapping (creating a mapped section) a remote file under a transaction is not supported.
//
static const long ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 6834L;
//
// MessageId: ERROR_TXF_METADATA_ALREADY_PRESENT
//
// MessageText:
//
// Transaction metadata is already present on this file and cannot be superseded.
//
static const long ERROR_TXF_METADATA_ALREADY_PRESENT = 6835L;
//
// MessageId: ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET
//
// MessageText:
//
// A transaction scope could not be entered because the scope handler has not been initialized.
//
static const long ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = 6836L;
//
// MessageId: ERROR_TRANSACTION_REQUIRED_PROMOTION
//
// MessageText:
//
// Promotion was required in order to allow the resource manager to enlist, but the transaction was set to disallow it.
//
static const long ERROR_TRANSACTION_REQUIRED_PROMOTION = 6837L;
//
// MessageId: ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION
//
// MessageText:
//
// This file is open for modification in an unresolved transaction and may be opened for execute only by a transacted reader.
//
static const long ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 6838L;
//
// MessageId: ERROR_TRANSACTIONS_NOT_FROZEN
//
// MessageText:
//
// The request to thaw frozen transactions was ignored because transactions had not previously been frozen.
//
static const long ERROR_TRANSACTIONS_NOT_FROZEN = 6839L;
//
// MessageId: ERROR_TRANSACTION_FREEZE_IN_PROGRESS
//
// MessageText:
//
// Transactions cannot be frozen because a freeze is already in progress.
//
static const long ERROR_TRANSACTION_FREEZE_IN_PROGRESS = 6840L;
//
// MessageId: ERROR_NOT_SNAPSHOT_VOLUME
//
// MessageText:
//
// The target volume is not a snapshot volume. This operation is only valid on a volume mounted as a snapshot.
//
static const long ERROR_NOT_SNAPSHOT_VOLUME = 6841L;
//
// MessageId: ERROR_NO_SAVEPOINT_WITH_OPEN_FILES
//
// MessageText:
//
// The savepoint operation failed because files are open on the transaction. This is not permitted.
//
static const long ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = 6842L;
//
// MessageId: ERROR_DATA_LOST_REPAIR
//
// MessageText:
//
// Windows has discovered corruption in a file, and that file has since been repaired. Data loss may have occurred.
//
static const long ERROR_DATA_LOST_REPAIR = 6843L;
//
// MessageId: ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The sparse operation could not be completed because a transaction is active on the file.
//
static const long ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 6844L;
//
// MessageId: ERROR_TM_IDENTITY_MISMATCH
//
// MessageText:
//
// The call to create a TransactionManager object failed because the Tm Identity stored in the logfile does not match the Tm Identity that was passed in as an argument.
//
static const long ERROR_TM_IDENTITY_MISMATCH = 6845L;
//
// MessageId: ERROR_FLOATED_SECTION
//
// MessageText:
//
// I/O was attempted on a section object that has been floated as a result of a transaction ending. There is no valid data.
//
static const long ERROR_FLOATED_SECTION = 6846L;
//
// MessageId: ERROR_CANNOT_ACCEPT_TRANSACTED_WORK
//
// MessageText:
//
// The transactional resource manager cannot currently accept transacted work due to a transient condition such as low resources.
//
static const long ERROR_CANNOT_ACCEPT_TRANSACTED_WORK = 6847L;
//
// MessageId: ERROR_CANNOT_ABORT_TRANSACTIONS
//
// MessageText:
//
// The transactional resource manager had too many tranactions outstanding that could not be aborted. The transactional resource manger has been shut down.
//
static const long ERROR_CANNOT_ABORT_TRANSACTIONS = 6848L;
//
// MessageId: ERROR_BAD_CLUSTERS
//
// MessageText:
//
// The operation could not be completed due to bad clusters on disk.
//
static const long ERROR_BAD_CLUSTERS = 6849L;
//
// MessageId: ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The compression operation could not be completed because a transaction is active on the file.
//
static const long ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 6850L;
//
// MessageId: ERROR_VOLUME_DIRTY
//
// MessageText:
//
// The operation could not be completed because the volume is dirty. Please run chkdsk and try again.
//
static const long ERROR_VOLUME_DIRTY = 6851L;
//
// MessageId: ERROR_NO_LINK_TRACKING_IN_TRANSACTION
//
// MessageText:
//
// The link tracking operation could not be completed because a transaction is active.
//
static const long ERROR_NO_LINK_TRACKING_IN_TRANSACTION = 6852L;
//
// MessageId: ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION
//
// MessageText:
//
// This operation cannot be performed in a transaction.
//
static const long ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 6853L;
//
// MessageId: ERROR_EXPIRED_HANDLE
//
// MessageText:
//
// The handle is no longer properly associated with its transaction.  It may have been opened in a transactional resource manager that was subsequently forced to restart.  Please close the handle and open a new one.
//
static const long ERROR_EXPIRED_HANDLE = 6854L;
//
// MessageId: ERROR_TRANSACTION_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed because the resource manager is not enlisted in the transaction.
//
static const long ERROR_TRANSACTION_NOT_ENLISTED = 6855L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 6900 to 6999                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//          Terminal Server Error codes          //
//                                               //
//                 7000 to 7099                  //
///////////////////////////////////////////////////
//
// MessageId: ERROR_CTX_WINSTATION_NAME_INVALID
//
// MessageText:
//
// The specified session name is invalid.
//
static const long ERROR_CTX_WINSTATION_NAME_INVALID = 7001L;
//
// MessageId: ERROR_CTX_INVALID_PD
//
// MessageText:
//
// The specified protocol driver is invalid.
//
static const long ERROR_CTX_INVALID_PD = 7002L;
//
// MessageId: ERROR_CTX_PD_NOT_FOUND
//
// MessageText:
//
// The specified protocol driver was not found in the system path.
//
static const long ERROR_CTX_PD_NOT_FOUND = 7003L;
//
// MessageId: ERROR_CTX_WD_NOT_FOUND
//
// MessageText:
//
// The specified terminal connection driver was not found in the system path.
//
static const long ERROR_CTX_WD_NOT_FOUND = 7004L;
//
// MessageId: ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY
//
// MessageText:
//
// A registry key for event logging could not be created for this session.
//
static const long ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = 7005L;
//
// MessageId: ERROR_CTX_SERVICE_NAME_COLLISION
//
// MessageText:
//
// A service with the same name already exists on the system.
//
static const long ERROR_CTX_SERVICE_NAME_COLLISION = 7006L;
//
// MessageId: ERROR_CTX_CLOSE_PENDING
//
// MessageText:
//
// A close operation is pending on the session.
//
static const long ERROR_CTX_CLOSE_PENDING = 7007L;
//
// MessageId: ERROR_CTX_NO_OUTBUF
//
// MessageText:
//
// There are no free output buffers available.
//
static const long ERROR_CTX_NO_OUTBUF = 7008L;
//
// MessageId: ERROR_CTX_MODEM_INF_NOT_FOUND
//
// MessageText:
//
// The MODEM.INF file was not found.
//
static const long ERROR_CTX_MODEM_INF_NOT_FOUND = 7009L;
//
// MessageId: ERROR_CTX_INVALID_MODEMNAME
//
// MessageText:
//
// The modem name was not found in MODEM.INF.
//
static const long ERROR_CTX_INVALID_MODEMNAME = 7010L;
//
// MessageId: ERROR_CTX_MODEM_RESPONSE_ERROR
//
// MessageText:
//
// The modem did not accept the command sent to it. Verify that the configured modem name matches the attached modem.
//
static const long ERROR_CTX_MODEM_RESPONSE_ERROR = 7011L;
//
// MessageId: ERROR_CTX_MODEM_RESPONSE_TIMEOUT
//
// MessageText:
//
// The modem did not respond to the command sent to it. Verify that the modem is properly cabled and powered on.
//
static const long ERROR_CTX_MODEM_RESPONSE_TIMEOUT = 7012L;
//
// MessageId: ERROR_CTX_MODEM_RESPONSE_NO_CARRIER
//
// MessageText:
//
// Carrier detect has failed or carrier has been dropped due to disconnect.
//
static const long ERROR_CTX_MODEM_RESPONSE_NO_CARRIER = 7013L;
//
// MessageId: ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE
//
// MessageText:
//
// Dial tone not detected within the required time. Verify that the phone cable is properly attached and functional.
//
static const long ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = 7014L;
//
// MessageId: ERROR_CTX_MODEM_RESPONSE_BUSY
//
// MessageText:
//
// Busy signal detected at remote site on callback.
//
static const long ERROR_CTX_MODEM_RESPONSE_BUSY = 7015L;
//
// MessageId: ERROR_CTX_MODEM_RESPONSE_VOICE
//
// MessageText:
//
// Voice detected at remote site on callback.
//
static const long ERROR_CTX_MODEM_RESPONSE_VOICE = 7016L;
//
// MessageId: ERROR_CTX_TD_ERROR
//
// MessageText:
//
// Transport driver error
//
static const long ERROR_CTX_TD_ERROR = 7017L;
//
// MessageId: ERROR_CTX_WINSTATION_NOT_FOUND
//
// MessageText:
//
// The specified session cannot be found.
//
static const long ERROR_CTX_WINSTATION_NOT_FOUND = 7022L;
//
// MessageId: ERROR_CTX_WINSTATION_ALREADY_EXISTS
//
// MessageText:
//
// The specified session name is already in use.
//
static const long ERROR_CTX_WINSTATION_ALREADY_EXISTS = 7023L;
//
// MessageId: ERROR_CTX_WINSTATION_BUSY
//
// MessageText:
//
// The task you are trying to do can't be completed because Remote Desktop Services is currently busy. Please try again in a few minutes. Other users should still be able to log on.
//
static const long ERROR_CTX_WINSTATION_BUSY = 7024L;
//
// MessageId: ERROR_CTX_BAD_VIDEO_MODE
//
// MessageText:
//
// An attempt has been made to connect to a session whose video mode is not supported by the current client.
//
static const long ERROR_CTX_BAD_VIDEO_MODE = 7025L;
//
// MessageId: ERROR_CTX_GRAPHICS_INVALID
//
// MessageText:
//
// The application attempted to enable DOS graphics mode. DOS graphics mode is not supported.
//
static const long ERROR_CTX_GRAPHICS_INVALID = 7035L;
//
// MessageId: ERROR_CTX_LOGON_DISABLED
//
// MessageText:
//
// Your interactive logon privilege has been disabled. Please contact your administrator.
//
static const long ERROR_CTX_LOGON_DISABLED = 7037L;
//
// MessageId: ERROR_CTX_NOT_CONSOLE
//
// MessageText:
//
// The requested operation can be performed only on the system console. This is most often the result of a driver or system DLL requiring direct console access.
//
static const long ERROR_CTX_NOT_CONSOLE = 7038L;
//
// MessageId: ERROR_CTX_CLIENT_QUERY_TIMEOUT
//
// MessageText:
//
// The client failed to respond to the server connect message.
//
static const long ERROR_CTX_CLIENT_QUERY_TIMEOUT = 7040L;
//
// MessageId: ERROR_CTX_CONSOLE_DISCONNECT
//
// MessageText:
//
// Disconnecting the console session is not supported.
//
static const long ERROR_CTX_CONSOLE_DISCONNECT = 7041L;
//
// MessageId: ERROR_CTX_CONSOLE_CONNECT
//
// MessageText:
//
// Reconnecting a disconnected session to the console is not supported.
//
static const long ERROR_CTX_CONSOLE_CONNECT = 7042L;
//
// MessageId: ERROR_CTX_SHADOW_DENIED
//
// MessageText:
//
// The request to control another session remotely was denied.
//
static const long ERROR_CTX_SHADOW_DENIED = 7044L;
//
// MessageId: ERROR_CTX_WINSTATION_ACCESS_DENIED
//
// MessageText:
//
// The requested session access is denied.
//
static const long ERROR_CTX_WINSTATION_ACCESS_DENIED = 7045L;
//
// MessageId: ERROR_CTX_INVALID_WD
//
// MessageText:
//
// The specified terminal connection driver is invalid.
//
static const long ERROR_CTX_INVALID_WD = 7049L;
//
// MessageId: ERROR_CTX_SHADOW_INVALID
//
// MessageText:
//
// The requested session cannot be controlled remotely.
// This may be because the session is disconnected or does not currently have a user logged on.
//
static const long ERROR_CTX_SHADOW_INVALID = 7050L;
//
// MessageId: ERROR_CTX_SHADOW_DISABLED
//
// MessageText:
//
// The requested session is not configured to allow remote control.
//
static const long ERROR_CTX_SHADOW_DISABLED = 7051L;
//
// MessageId: ERROR_CTX_CLIENT_LICENSE_IN_USE
//
// MessageText:
//
// Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number is currently being used by another user. Please call your system administrator to obtain a unique license number.
//
static const long ERROR_CTX_CLIENT_LICENSE_IN_USE = 7052L;
//
// MessageId: ERROR_CTX_CLIENT_LICENSE_NOT_SET
//
// MessageText:
//
// Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number has not been entered for this copy of the Terminal Server client. Please contact your system administrator.
//
static const long ERROR_CTX_CLIENT_LICENSE_NOT_SET = 7053L;
//
// MessageId: ERROR_CTX_LICENSE_NOT_AVAILABLE
//
// MessageText:
//
// The number of connections to this computer is limited and all connections are in use right now. Try connecting later or contact your system administrator.
//
static const long ERROR_CTX_LICENSE_NOT_AVAILABLE = 7054L;
//
// MessageId: ERROR_CTX_LICENSE_CLIENT_INVALID
//
// MessageText:
//
// The client you are using is not licensed to use this system. Your logon request is denied.
//
static const long ERROR_CTX_LICENSE_CLIENT_INVALID = 7055L;
//
// MessageId: ERROR_CTX_LICENSE_EXPIRED
//
// MessageText:
//
// The system license has expired. Your logon request is denied.
//
static const long ERROR_CTX_LICENSE_EXPIRED = 7056L;
//
// MessageId: ERROR_CTX_SHADOW_NOT_RUNNING
//
// MessageText:
//
// Remote control could not be terminated because the specified session is not currently being remotely controlled.
//
static const long ERROR_CTX_SHADOW_NOT_RUNNING = 7057L;
//
// MessageId: ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE
//
// MessageText:
//
// The remote control of the console was terminated because the display mode was changed. Changing the display mode in a remote control session is not supported.
//
static const long ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 7058L;
//
// MessageId: ERROR_ACTIVATION_COUNT_EXCEEDED
//
// MessageText:
//
// Activation has already been reset the maximum number of times for this installation. Your activation timer will not be cleared.
//
static const long ERROR_ACTIVATION_COUNT_EXCEEDED = 7059L;
//
// MessageId: ERROR_CTX_WINSTATIONS_DISABLED
//
// MessageText:
//
// Remote logins are currently disabled.
//
static const long ERROR_CTX_WINSTATIONS_DISABLED = 7060L;
//
// MessageId: ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED
//
// MessageText:
//
// You do not have the proper encryption level to access this Session.
//
static const long ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED = 7061L;
//
// MessageId: ERROR_CTX_SESSION_IN_USE
//
// MessageText:
//
// The user %s\\%s is currently logged on to this computer. Only the current user or an administrator can log on to this computer.
//
static const long ERROR_CTX_SESSION_IN_USE = 7062L;
//
// MessageId: ERROR_CTX_NO_FORCE_LOGOFF
//
// MessageText:
//
// The user %s\\%s is already logged on to the console of this computer. You do not have permission to log in at this time. To resolve this issue, contact %s\\%s and have them log off.
//
static const long ERROR_CTX_NO_FORCE_LOGOFF = 7063L;
//
// MessageId: ERROR_CTX_ACCOUNT_RESTRICTION
//
// MessageText:
//
// Unable to log you on because of an account restriction.
//
static const long ERROR_CTX_ACCOUNT_RESTRICTION = 7064L;
//
// MessageId: ERROR_RDP_PROTOCOL_ERROR
//
// MessageText:
//
// The RDP protocol component %2 detected an error in the protocol stream and has disconnected the client.
//
static const long ERROR_RDP_PROTOCOL_ERROR = 7065L;
//
// MessageId: ERROR_CTX_CDM_CONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Connected on Terminal Connection.
//
static const long ERROR_CTX_CDM_CONNECT = 7066L;
//
// MessageId: ERROR_CTX_CDM_DISCONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Disconnected on Terminal Connection.
//
static const long ERROR_CTX_CDM_DISCONNECT = 7067L;
//
// MessageId: ERROR_CTX_SECURITY_LAYER_ERROR
//
// MessageText:
//
// The Terminal Server security layer detected an error in the protocol stream and has disconnected the client.
//
static const long ERROR_CTX_SECURITY_LAYER_ERROR = 7068L;
//
// MessageId: ERROR_TS_INCOMPATIBLE_SESSIONS
//
// MessageText:
//
// The target session is incompatible with the current session.
//
static const long ERROR_TS_INCOMPATIBLE_SESSIONS = 7069L;
//
// MessageId: ERROR_TS_VIDEO_SUBSYSTEM_ERROR
//
// MessageText:
//
// Windows can't connect to your session because a problem occurred in the Windows video subsystem. Try connecting again later, or contact the server administrator for assistance.
//
static const long ERROR_TS_VIDEO_SUBSYSTEM_ERROR = 7070L;
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 7100 to 7499                  //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                                /
//           Traffic Control Error Codes          /
//                                                /
//                  7500 to 7999                  /
//                                                /
//            defined in: tcerror.h               /
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//           Active Directory Error codes        //
//                                               //
//                 8000 to 8999                  //
///////////////////////////////////////////////////
// *****************
// FACILITY_FILE_REPLICATION_SERVICE
// *****************
//
// MessageId: FRS_ERR_INVALID_API_SEQUENCE
//
// MessageText:
//
// The file replication service API was called incorrectly.
//
static const long FRS_ERR_INVALID_API_SEQUENCE = 8001L;
//
// MessageId: FRS_ERR_STARTING_SERVICE
//
// MessageText:
//
// The file replication service cannot be started.
//
static const long FRS_ERR_STARTING_SERVICE = 8002L;
//
// MessageId: FRS_ERR_STOPPING_SERVICE
//
// MessageText:
//
// The file replication service cannot be stopped.
//
static const long FRS_ERR_STOPPING_SERVICE = 8003L;
//
// MessageId: FRS_ERR_INTERNAL_API
//
// MessageText:
//
// The file replication service API terminated the request. The event log may have more information.
//
static const long FRS_ERR_INTERNAL_API = 8004L;
//
// MessageId: FRS_ERR_INTERNAL
//
// MessageText:
//
// The file replication service terminated the request. The event log may have more information.
//
static const long FRS_ERR_INTERNAL = 8005L;
//
// MessageId: FRS_ERR_SERVICE_COMM
//
// MessageText:
//
// The file replication service cannot be contacted. The event log may have more information.
//
static const long FRS_ERR_SERVICE_COMM = 8006L;
//
// MessageId: FRS_ERR_INSUFFICIENT_PRIV
//
// MessageText:
//
// The file replication service cannot satisfy the request because the user has insufficient privileges. The event log may have more information.
//
static const long FRS_ERR_INSUFFICIENT_PRIV = 8007L;
//
// MessageId: FRS_ERR_AUTHENTICATION
//
// MessageText:
//
// The file replication service cannot satisfy the request because authenticated RPC is not available. The event log may have more information.
//
static const long FRS_ERR_AUTHENTICATION = 8008L;
//
// MessageId: FRS_ERR_PARENT_INSUFFICIENT_PRIV
//
// MessageText:
//
// The file replication service cannot satisfy the request because the user has insufficient privileges on the domain controller. The event log may have more information.
//
static const long FRS_ERR_PARENT_INSUFFICIENT_PRIV = 8009L;
//
// MessageId: FRS_ERR_PARENT_AUTHENTICATION
//
// MessageText:
//
// The file replication service cannot satisfy the request because authenticated RPC is not available on the domain controller. The event log may have more information.
//
static const long FRS_ERR_PARENT_AUTHENTICATION = 8010L;
//
// MessageId: FRS_ERR_CHILD_TO_PARENT_COMM
//
// MessageText:
//
// The file replication service cannot communicate with the file replication service on the domain controller. The event log may have more information.
//
static const long FRS_ERR_CHILD_TO_PARENT_COMM = 8011L;
//
// MessageId: FRS_ERR_PARENT_TO_CHILD_COMM
//
// MessageText:
//
// The file replication service on the domain controller cannot communicate with the file replication service on this computer. The event log may have more information.
//
static const long FRS_ERR_PARENT_TO_CHILD_COMM = 8012L;
//
// MessageId: FRS_ERR_SYSVOL_POPULATE
//
// MessageText:
//
// The file replication service cannot populate the system volume because of an internal error. The event log may have more information.
//
static const long FRS_ERR_SYSVOL_POPULATE = 8013L;
//
// MessageId: FRS_ERR_SYSVOL_POPULATE_TIMEOUT
//
// MessageText:
//
// The file replication service cannot populate the system volume because of an internal timeout. The event log may have more information.
//
static const long FRS_ERR_SYSVOL_POPULATE_TIMEOUT = 8014L;
//
// MessageId: FRS_ERR_SYSVOL_IS_BUSY
//
// MessageText:
//
// The file replication service cannot process the request. The system volume is busy with a previous request.
//
static const long FRS_ERR_SYSVOL_IS_BUSY = 8015L;
//
// MessageId: FRS_ERR_SYSVOL_DEMOTE
//
// MessageText:
//
// The file replication service cannot stop replicating the system volume because of an internal error. The event log may have more information.
//
static const long FRS_ERR_SYSVOL_DEMOTE = 8016L;
//
// MessageId: FRS_ERR_INVALID_SERVICE_PARAMETER
//
// MessageText:
//
// The file replication service detected an invalid parameter.
//
static const long FRS_ERR_INVALID_SERVICE_PARAMETER = 8017L;
// *****************
// FACILITY DIRECTORY SERVICE
// *****************
static const int DS_S_SUCCESS = NO_ERROR;
//
// MessageId: ERROR_DS_NOT_INSTALLED
//
// MessageText:
//
// An error occurred while installing the directory service. For more information, see the event log.
//
static const long ERROR_DS_NOT_INSTALLED = 8200L;
//
// MessageId: ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
//
// MessageText:
//
// The directory service evaluated group memberships locally.
//
static const long ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = 8201L;
//
// MessageId: ERROR_DS_NO_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
// The specified directory service attribute or value does not exist.
//
static const long ERROR_DS_NO_ATTRIBUTE_OR_VALUE = 8202L;
//
// MessageId: ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
//
// MessageText:
//
// The attribute syntax specified to the directory service is invalid.
//
static const long ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = 8203L;
//
// MessageId: ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
//
// MessageText:
//
// The attribute type specified to the directory service is not defined.
//
static const long ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = 8204L;
//
// MessageId: ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
// The specified directory service attribute or value already exists.
//
static const long ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = 8205L;
//
// MessageId: ERROR_DS_BUSY
//
// MessageText:
//
// The directory service is busy.
//
static const long ERROR_DS_BUSY = 8206L;
//
// MessageId: ERROR_DS_UNAVAILABLE
//
// MessageText:
//
// The directory service is unavailable.
//
static const long ERROR_DS_UNAVAILABLE = 8207L;
//
// MessageId: ERROR_DS_NO_RIDS_ALLOCATED
//
// MessageText:
//
// The directory service was unable to allocate a relative identifier.
//
static const long ERROR_DS_NO_RIDS_ALLOCATED = 8208L;
//
// MessageId: ERROR_DS_NO_MORE_RIDS
//
// MessageText:
//
// The directory service has exhausted the pool of relative identifiers.
//
static const long ERROR_DS_NO_MORE_RIDS = 8209L;
//
// MessageId: ERROR_DS_INCORRECT_ROLE_OWNER
//
// MessageText:
//
// The requested operation could not be performed because the directory service is not the master for that type of operation.
//
static const long ERROR_DS_INCORRECT_ROLE_OWNER = 8210L;
//
// MessageId: ERROR_DS_RIDMGR_INIT_ERROR
//
// MessageText:
//
// The directory service was unable to initialize the subsystem that allocates relative identifiers.
//
static const long ERROR_DS_RIDMGR_INIT_ERROR = 8211L;
//
// MessageId: ERROR_DS_OBJ_CLASS_VIOLATION
//
// MessageText:
//
// The requested operation did not satisfy one or more constraints associated with the class of the object.
//
static const long ERROR_DS_OBJ_CLASS_VIOLATION = 8212L;
//
// MessageId: ERROR_DS_CANT_ON_NON_LEAF
//
// MessageText:
//
// The directory service can perform the requested operation only on a leaf object.
//
static const long ERROR_DS_CANT_ON_NON_LEAF = 8213L;
//
// MessageId: ERROR_DS_CANT_ON_RDN
//
// MessageText:
//
// The directory service cannot perform the requested operation on the RDN attribute of an object.
//
static const long ERROR_DS_CANT_ON_RDN = 8214L;
//
// MessageId: ERROR_DS_CANT_MOD_OBJ_CLASS
//
// MessageText:
//
// The directory service detected an attempt to modify the object class of an object.
//
static const long ERROR_DS_CANT_MOD_OBJ_CLASS = 8215L;
//
// MessageId: ERROR_DS_CROSS_DOM_MOVE_ERROR
//
// MessageText:
//
// The requested cross-domain move operation could not be performed.
//
static const long ERROR_DS_CROSS_DOM_MOVE_ERROR = 8216L;
//
// MessageId: ERROR_DS_GC_NOT_AVAILABLE
//
// MessageText:
//
// Unable to contact the global catalog server.
//
static const long ERROR_DS_GC_NOT_AVAILABLE = 8217L;
//
// MessageId: ERROR_SHARED_POLICY
//
// MessageText:
//
// The policy object is shared and can only be modified at the root.
//
static const long ERROR_SHARED_POLICY = 8218L;
//
// MessageId: ERROR_POLICY_OBJECT_NOT_FOUND
//
// MessageText:
//
// The policy object does not exist.
//
static const long ERROR_POLICY_OBJECT_NOT_FOUND = 8219L;
//
// MessageId: ERROR_POLICY_ONLY_IN_DS
//
// MessageText:
//
// The requested policy information is only in the directory service.
//
static const long ERROR_POLICY_ONLY_IN_DS = 8220L;
//
// MessageId: ERROR_PROMOTION_ACTIVE
//
// MessageText:
//
// A domain controller promotion is currently active.
//
static const long ERROR_PROMOTION_ACTIVE = 8221L;
//
// MessageId: ERROR_NO_PROMOTION_ACTIVE
//
// MessageText:
//
// A domain controller promotion is not currently active
//
static const long ERROR_NO_PROMOTION_ACTIVE = 8222L;
// 8223 unused
//
// MessageId: ERROR_DS_OPERATIONS_ERROR
//
// MessageText:
//
// An operations error occurred.
//
static const long ERROR_DS_OPERATIONS_ERROR = 8224L;
//
// MessageId: ERROR_DS_PROTOCOL_ERROR
//
// MessageText:
//
// A protocol error occurred.
//
static const long ERROR_DS_PROTOCOL_ERROR = 8225L;
//
// MessageId: ERROR_DS_TIMELIMIT_EXCEEDED
//
// MessageText:
//
// The time limit for this request was exceeded.
//
static const long ERROR_DS_TIMELIMIT_EXCEEDED = 8226L;
//
// MessageId: ERROR_DS_SIZELIMIT_EXCEEDED
//
// MessageText:
//
// The size limit for this request was exceeded.
//
static const long ERROR_DS_SIZELIMIT_EXCEEDED = 8227L;
//
// MessageId: ERROR_DS_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
// The administrative limit for this request was exceeded.
//
static const long ERROR_DS_ADMIN_LIMIT_EXCEEDED = 8228L;
//
// MessageId: ERROR_DS_COMPARE_FALSE
//
// MessageText:
//
// The compare response was false.
//
static const long ERROR_DS_COMPARE_FALSE = 8229L;
//
// MessageId: ERROR_DS_COMPARE_TRUE
//
// MessageText:
//
// The compare response was true.
//
static const long ERROR_DS_COMPARE_TRUE = 8230L;
//
// MessageId: ERROR_DS_AUTH_METHOD_NOT_SUPPORTED
//
// MessageText:
//
// The requested authentication method is not supported by the server.
//
static const long ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = 8231L;
//
// MessageId: ERROR_DS_STRONG_AUTH_REQUIRED
//
// MessageText:
//
// A more secure authentication method is required for this server.
//
static const long ERROR_DS_STRONG_AUTH_REQUIRED = 8232L;
//
// MessageId: ERROR_DS_INAPPROPRIATE_AUTH
//
// MessageText:
//
// Inappropriate authentication.
//
static const long ERROR_DS_INAPPROPRIATE_AUTH = 8233L;
//
// MessageId: ERROR_DS_AUTH_UNKNOWN
//
// MessageText:
//
// The authentication mechanism is unknown.
//
static const long ERROR_DS_AUTH_UNKNOWN = 8234L;
//
// MessageId: ERROR_DS_REFERRAL
//
// MessageText:
//
// A referral was returned from the server.
//
static const long ERROR_DS_REFERRAL = 8235L;
//
// MessageId: ERROR_DS_UNAVAILABLE_CRIT_EXTENSION
//
// MessageText:
//
// The server does not support the requested critical extension.
//
static const long ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = 8236L;
//
// MessageId: ERROR_DS_CONFIDENTIALITY_REQUIRED
//
// MessageText:
//
// This request requires a secure connection.
//
static const long ERROR_DS_CONFIDENTIALITY_REQUIRED = 8237L;
//
// MessageId: ERROR_DS_INAPPROPRIATE_MATCHING
//
// MessageText:
//
// Inappropriate matching.
//
static const long ERROR_DS_INAPPROPRIATE_MATCHING = 8238L;
//
// MessageId: ERROR_DS_CONSTRAINT_VIOLATION
//
// MessageText:
//
// A constraint violation occurred.
//
static const long ERROR_DS_CONSTRAINT_VIOLATION = 8239L;
//
// MessageId: ERROR_DS_NO_SUCH_OBJECT
//
// MessageText:
//
// There is no such object on the server.
//
static const long ERROR_DS_NO_SUCH_OBJECT = 8240L;
//
// MessageId: ERROR_DS_ALIAS_PROBLEM
//
// MessageText:
//
// There is an alias problem.
//
static const long ERROR_DS_ALIAS_PROBLEM = 8241L;
//
// MessageId: ERROR_DS_INVALID_DN_SYNTAX
//
// MessageText:
//
// An invalid dn syntax has been specified.
//
static const long ERROR_DS_INVALID_DN_SYNTAX = 8242L;
//
// MessageId: ERROR_DS_IS_LEAF
//
// MessageText:
//
// The object is a leaf object.
//
static const long ERROR_DS_IS_LEAF = 8243L;
//
// MessageId: ERROR_DS_ALIAS_DEREF_PROBLEM
//
// MessageText:
//
// There is an alias dereferencing problem.
//
static const long ERROR_DS_ALIAS_DEREF_PROBLEM = 8244L;
//
// MessageId: ERROR_DS_UNWILLING_TO_PERFORM
//
// MessageText:
//
// The server is unwilling to process the request.
//
static const long ERROR_DS_UNWILLING_TO_PERFORM = 8245L;
//
// MessageId: ERROR_DS_LOOP_DETECT
//
// MessageText:
//
// A loop has been detected.
//
static const long ERROR_DS_LOOP_DETECT = 8246L;
//
// MessageId: ERROR_DS_NAMING_VIOLATION
//
// MessageText:
//
// There is a naming violation.
//
static const long ERROR_DS_NAMING_VIOLATION = 8247L;
//
// MessageId: ERROR_DS_OBJECT_RESULTS_TOO_LARGE
//
// MessageText:
//
// The result set is too large.
//
static const long ERROR_DS_OBJECT_RESULTS_TOO_LARGE = 8248L;
//
// MessageId: ERROR_DS_AFFECTS_MULTIPLE_DSAS
//
// MessageText:
//
// The operation affects multiple DSAs
//
static const long ERROR_DS_AFFECTS_MULTIPLE_DSAS = 8249L;
//
// MessageId: ERROR_DS_SERVER_DOWN
//
// MessageText:
//
// The server is not operational.
//
static const long ERROR_DS_SERVER_DOWN = 8250L;
//
// MessageId: ERROR_DS_LOCAL_ERROR
//
// MessageText:
//
// A local error has occurred.
//
static const long ERROR_DS_LOCAL_ERROR = 8251L;
//
// MessageId: ERROR_DS_ENCODING_ERROR
//
// MessageText:
//
// An encoding error has occurred.
//
static const long ERROR_DS_ENCODING_ERROR = 8252L;
//
// MessageId: ERROR_DS_DECODING_ERROR
//
// MessageText:
//
// A decoding error has occurred.
//
static const long ERROR_DS_DECODING_ERROR = 8253L;
//
// MessageId: ERROR_DS_FILTER_UNKNOWN
//
// MessageText:
//
// The search filter cannot be recognized.
//
static const long ERROR_DS_FILTER_UNKNOWN = 8254L;
//
// MessageId: ERROR_DS_PARAM_ERROR
//
// MessageText:
//
// One or more parameters are illegal.
//
static const long ERROR_DS_PARAM_ERROR = 8255L;
//
// MessageId: ERROR_DS_NOT_SUPPORTED
//
// MessageText:
//
// The specified method is not supported.
//
static const long ERROR_DS_NOT_SUPPORTED = 8256L;
//
// MessageId: ERROR_DS_NO_RESULTS_RETURNED
//
// MessageText:
//
// No results were returned.
//
static const long ERROR_DS_NO_RESULTS_RETURNED = 8257L;
//
// MessageId: ERROR_DS_CONTROL_NOT_FOUND
//
// MessageText:
//
// The specified control is not supported by the server.
//
static const long ERROR_DS_CONTROL_NOT_FOUND = 8258L;
//
// MessageId: ERROR_DS_CLIENT_LOOP
//
// MessageText:
//
// A referral loop was detected by the client.
//
static const long ERROR_DS_CLIENT_LOOP = 8259L;
//
// MessageId: ERROR_DS_REFERRAL_LIMIT_EXCEEDED
//
// MessageText:
//
// The preset referral limit was exceeded.
//
static const long ERROR_DS_REFERRAL_LIMIT_EXCEEDED = 8260L;
//
// MessageId: ERROR_DS_SORT_CONTROL_MISSING
//
// MessageText:
//
// The search requires a SORT control.
//
static const long ERROR_DS_SORT_CONTROL_MISSING = 8261L;
//
// MessageId: ERROR_DS_OFFSET_RANGE_ERROR
//
// MessageText:
//
// The search results exceed the offset range specified.
//
static const long ERROR_DS_OFFSET_RANGE_ERROR = 8262L;
//
// MessageId: ERROR_DS_ROOT_MUST_BE_NC
//
// MessageText:
//
// The root object must be the head of a naming context. The root object cannot have an instantiated parent.
//
static const long ERROR_DS_ROOT_MUST_BE_NC = 8301L;
//
// MessageId: ERROR_DS_ADD_REPLICA_INHIBITED
//
// MessageText:
//
// The add replica operation cannot be performed. The naming context must be writeable in order to create the replica.
//
static const long ERROR_DS_ADD_REPLICA_INHIBITED = 8302L;
//
// MessageId: ERROR_DS_ATT_NOT_DEF_IN_SCHEMA
//
// MessageText:
//
// A reference to an attribute that is not defined in the schema occurred.
//
static const long ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = 8303L;
//
// MessageId: ERROR_DS_MAX_OBJ_SIZE_EXCEEDED
//
// MessageText:
//
// The maximum size of an object has been exceeded.
//
static const long ERROR_DS_MAX_OBJ_SIZE_EXCEEDED = 8304L;
//
// MessageId: ERROR_DS_OBJ_STRING_NAME_EXISTS
//
// MessageText:
//
// An attempt was made to add an object to the directory with a name that is already in use.
//
static const long ERROR_DS_OBJ_STRING_NAME_EXISTS = 8305L;
//
// MessageId: ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA
//
// MessageText:
//
// An attempt was made to add an object of a class that does not have an RDN defined in the schema.
//
static const long ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA = 8306L;
//
// MessageId: ERROR_DS_RDN_DOESNT_MATCH_SCHEMA
//
// MessageText:
//
// An attempt was made to add an object using an RDN that is not the RDN defined in the schema.
//
static const long ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = 8307L;
//
// MessageId: ERROR_DS_NO_REQUESTED_ATTS_FOUND
//
// MessageText:
//
// None of the requested attributes were found on the objects.
//
static const long ERROR_DS_NO_REQUESTED_ATTS_FOUND = 8308L;
//
// MessageId: ERROR_DS_USER_BUFFER_TO_SMALL
//
// MessageText:
//
// The user buffer is too small.
//
static const long ERROR_DS_USER_BUFFER_TO_SMALL = 8309L;
//
// MessageId: ERROR_DS_ATT_IS_NOT_ON_OBJ
//
// MessageText:
//
// The attribute specified in the operation is not present on the object.
//
static const long ERROR_DS_ATT_IS_NOT_ON_OBJ = 8310L;
//
// MessageId: ERROR_DS_ILLEGAL_MOD_OPERATION
//
// MessageText:
//
// Illegal modify operation. Some aspect of the modification is not permitted.
//
static const long ERROR_DS_ILLEGAL_MOD_OPERATION = 8311L;
//
// MessageId: ERROR_DS_OBJ_TOO_LARGE
//
// MessageText:
//
// The specified object is too large.
//
static const long ERROR_DS_OBJ_TOO_LARGE = 8312L;
//
// MessageId: ERROR_DS_BAD_INSTANCE_TYPE
//
// MessageText:
//
// The specified instance type is not valid.
//
static const long ERROR_DS_BAD_INSTANCE_TYPE = 8313L;
//
// MessageId: ERROR_DS_MASTERDSA_REQUIRED
//
// MessageText:
//
// The operation must be performed at a master DSA.
//
static const long ERROR_DS_MASTERDSA_REQUIRED = 8314L;
//
// MessageId: ERROR_DS_OBJECT_CLASS_REQUIRED
//
// MessageText:
//
// The object class attribute must be specified.
//
static const long ERROR_DS_OBJECT_CLASS_REQUIRED = 8315L;
//
// MessageId: ERROR_DS_MISSING_REQUIRED_ATT
//
// MessageText:
//
// A required attribute is missing.
//
static const long ERROR_DS_MISSING_REQUIRED_ATT = 8316L;
//
// MessageId: ERROR_DS_ATT_NOT_DEF_FOR_CLASS
//
// MessageText:
//
// An attempt was made to modify an object to include an attribute that is not legal for its class.
//
static const long ERROR_DS_ATT_NOT_DEF_FOR_CLASS = 8317L;
//
// MessageId: ERROR_DS_ATT_ALREADY_EXISTS
//
// MessageText:
//
// The specified attribute is already present on the object.
//
static const long ERROR_DS_ATT_ALREADY_EXISTS = 8318L;
// 8319 unused
//
// MessageId: ERROR_DS_CANT_ADD_ATT_VALUES
//
// MessageText:
//
// The specified attribute is not present, or has no values.
//
static const long ERROR_DS_CANT_ADD_ATT_VALUES = 8320L;
//
// MessageId: ERROR_DS_SINGLE_VALUE_CONSTRAINT
//
// MessageText:
//
// Multiple values were specified for an attribute that can have only one value.
//
static const long ERROR_DS_SINGLE_VALUE_CONSTRAINT = 8321L;
//
// MessageId: ERROR_DS_RANGE_CONSTRAINT
//
// MessageText:
//
// A value for the attribute was not in the acceptable range of values.
//
static const long ERROR_DS_RANGE_CONSTRAINT = 8322L;
//
// MessageId: ERROR_DS_ATT_VAL_ALREADY_EXISTS
//
// MessageText:
//
// The specified value already exists.
//
static const long ERROR_DS_ATT_VAL_ALREADY_EXISTS = 8323L;
//
// MessageId: ERROR_DS_CANT_REM_MISSING_ATT
//
// MessageText:
//
// The attribute cannot be removed because it is not present on the object.
//
static const long ERROR_DS_CANT_REM_MISSING_ATT = 8324L;
//
// MessageId: ERROR_DS_CANT_REM_MISSING_ATT_VAL
//
// MessageText:
//
// The attribute value cannot be removed because it is not present on the object.
//
static const long ERROR_DS_CANT_REM_MISSING_ATT_VAL = 8325L;
//
// MessageId: ERROR_DS_ROOT_CANT_BE_SUBREF
//
// MessageText:
//
// The specified root object cannot be a subref.
//
static const long ERROR_DS_ROOT_CANT_BE_SUBREF = 8326L;
//
// MessageId: ERROR_DS_NO_CHAINING
//
// MessageText:
//
// Chaining is not permitted.
//
static const long ERROR_DS_NO_CHAINING = 8327L;
//
// MessageId: ERROR_DS_NO_CHAINED_EVAL
//
// MessageText:
//
// Chained evaluation is not permitted.
//
static const long ERROR_DS_NO_CHAINED_EVAL = 8328L;
//
// MessageId: ERROR_DS_NO_PARENT_OBJECT
//
// MessageText:
//
// The operation could not be performed because the object's parent is either uninstantiated or deleted.
//
static const long ERROR_DS_NO_PARENT_OBJECT = 8329L;
//
// MessageId: ERROR_DS_PARENT_IS_AN_ALIAS
//
// MessageText:
//
// Having a parent that is an alias is not permitted. Aliases are leaf objects.
//
static const long ERROR_DS_PARENT_IS_AN_ALIAS = 8330L;
//
// MessageId: ERROR_DS_CANT_MIX_MASTER_AND_REPS
//
// MessageText:
//
// The object and parent must be of the same type, either both masters or both replicas.
//
static const long ERROR_DS_CANT_MIX_MASTER_AND_REPS = 8331L;
//
// MessageId: ERROR_DS_CHILDREN_EXIST
//
// MessageText:
//
// The operation cannot be performed because child objects exist. This operation can only be performed on a leaf object.
//
static const long ERROR_DS_CHILDREN_EXIST = 8332L;
//
// MessageId: ERROR_DS_OBJ_NOT_FOUND
//
// MessageText:
//
// Directory object not found.
//
static const long ERROR_DS_OBJ_NOT_FOUND = 8333L;
//
// MessageId: ERROR_DS_ALIASED_OBJ_MISSING
//
// MessageText:
//
// The aliased object is missing.
//
static const long ERROR_DS_ALIASED_OBJ_MISSING = 8334L;
//
// MessageId: ERROR_DS_BAD_NAME_SYNTAX
//
// MessageText:
//
// The object name has bad syntax.
//
static const long ERROR_DS_BAD_NAME_SYNTAX = 8335L;
//
// MessageId: ERROR_DS_ALIAS_POINTS_TO_ALIAS
//
// MessageText:
//
// It is not permitted for an alias to refer to another alias.
//
static const long ERROR_DS_ALIAS_POINTS_TO_ALIAS = 8336L;
//
// MessageId: ERROR_DS_CANT_DEREF_ALIAS
//
// MessageText:
//
// The alias cannot be dereferenced.
//
static const long ERROR_DS_CANT_DEREF_ALIAS = 8337L;
//
// MessageId: ERROR_DS_OUT_OF_SCOPE
//
// MessageText:
//
// The operation is out of scope.
//
static const long ERROR_DS_OUT_OF_SCOPE = 8338L;
//
// MessageId: ERROR_DS_OBJECT_BEING_REMOVED
//
// MessageText:
//
// The operation cannot continue because the object is in the process of being removed.
//
static const long ERROR_DS_OBJECT_BEING_REMOVED = 8339L;
//
// MessageId: ERROR_DS_CANT_DELETE_DSA_OBJ
//
// MessageText:
//
// The DSA object cannot be deleted.
//
static const long ERROR_DS_CANT_DELETE_DSA_OBJ = 8340L;
//
// MessageId: ERROR_DS_GENERIC_ERROR
//
// MessageText:
//
// A directory service error has occurred.
//
static const long ERROR_DS_GENERIC_ERROR = 8341L;
//
// MessageId: ERROR_DS_DSA_MUST_BE_INT_MASTER
//
// MessageText:
//
// The operation can only be performed on an internal master DSA object.
//
static const long ERROR_DS_DSA_MUST_BE_INT_MASTER = 8342L;
//
// MessageId: ERROR_DS_CLASS_NOT_DSA
//
// MessageText:
//
// The object must be of class DSA.
//
static const long ERROR_DS_CLASS_NOT_DSA = 8343L;
//
// MessageId: ERROR_DS_INSUFF_ACCESS_RIGHTS
//
// MessageText:
//
// Insufficient access rights to perform the operation.
//
static const long ERROR_DS_INSUFF_ACCESS_RIGHTS = 8344L;
//
// MessageId: ERROR_DS_ILLEGAL_SUPERIOR
//
// MessageText:
//
// The object cannot be added because the parent is not on the list of possible superiors.
//
static const long ERROR_DS_ILLEGAL_SUPERIOR = 8345L;
//
// MessageId: ERROR_DS_ATTRIBUTE_OWNED_BY_SAM
//
// MessageText:
//
// Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM).
//
static const long ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = 8346L;
//
// MessageId: ERROR_DS_NAME_TOO_MANY_PARTS
//
// MessageText:
//
// The name has too many parts.
//
static const long ERROR_DS_NAME_TOO_MANY_PARTS = 8347L;
//
// MessageId: ERROR_DS_NAME_TOO_LONG
//
// MessageText:
//
// The name is too long.
//
static const long ERROR_DS_NAME_TOO_LONG = 8348L;
//
// MessageId: ERROR_DS_NAME_VALUE_TOO_LONG
//
// MessageText:
//
// The name value is too long.
//
static const long ERROR_DS_NAME_VALUE_TOO_LONG = 8349L;
//
// MessageId: ERROR_DS_NAME_UNPARSEABLE
//
// MessageText:
//
// The directory service encountered an error parsing a name.
//
static const long ERROR_DS_NAME_UNPARSEABLE = 8350L;
//
// MessageId: ERROR_DS_NAME_TYPE_UNKNOWN
//
// MessageText:
//
// The directory service cannot get the attribute type for a name.
//
static const long ERROR_DS_NAME_TYPE_UNKNOWN = 8351L;
//
// MessageId: ERROR_DS_NOT_AN_OBJECT
//
// MessageText:
//
// The name does not identify an object; the name identifies a phantom.
//
static const long ERROR_DS_NOT_AN_OBJECT = 8352L;
//
// MessageId: ERROR_DS_SEC_DESC_TOO_SHORT
//
// MessageText:
//
// The security descriptor is too short.
//
static const long ERROR_DS_SEC_DESC_TOO_SHORT = 8353L;
//
// MessageId: ERROR_DS_SEC_DESC_INVALID
//
// MessageText:
//
// The security descriptor is invalid.
//
static const long ERROR_DS_SEC_DESC_INVALID = 8354L;
//
// MessageId: ERROR_DS_NO_DELETED_NAME
//
// MessageText:
//
// Failed to create name for deleted object.
//
static const long ERROR_DS_NO_DELETED_NAME = 8355L;
//
// MessageId: ERROR_DS_SUBREF_MUST_HAVE_PARENT
//
// MessageText:
//
// The parent of a new subref must exist.
//
static const long ERROR_DS_SUBREF_MUST_HAVE_PARENT = 8356L;
//
// MessageId: ERROR_DS_NCNAME_MUST_BE_NC
//
// MessageText:
//
// The object must be a naming context.
//
static const long ERROR_DS_NCNAME_MUST_BE_NC = 8357L;
//
// MessageId: ERROR_DS_CANT_ADD_SYSTEM_ONLY
//
// MessageText:
//
// It is not permitted to add an attribute which is owned by the system.
//
static const long ERROR_DS_CANT_ADD_SYSTEM_ONLY = 8358L;
//
// MessageId: ERROR_DS_CLASS_MUST_BE_CONCRETE
//
// MessageText:
//
// The class of the object must be structural; you cannot instantiate an abstract class.
//
static const long ERROR_DS_CLASS_MUST_BE_CONCRETE = 8359L;
//
// MessageId: ERROR_DS_INVALID_DMD
//
// MessageText:
//
// The schema object could not be found.
//
static const long ERROR_DS_INVALID_DMD = 8360L;
//
// MessageId: ERROR_DS_OBJ_GUID_EXISTS
//
// MessageText:
//
// A local object with this GUID (dead or alive) already exists.
//
static const long ERROR_DS_OBJ_GUID_EXISTS = 8361L;
//
// MessageId: ERROR_DS_NOT_ON_BACKLINK
//
// MessageText:
//
// The operation cannot be performed on a back link.
//
static const long ERROR_DS_NOT_ON_BACKLINK = 8362L;
//
// MessageId: ERROR_DS_NO_CROSSREF_FOR_NC
//
// MessageText:
//
// The cross reference for the specified naming context could not be found.
//
static const long ERROR_DS_NO_CROSSREF_FOR_NC = 8363L;
//
// MessageId: ERROR_DS_SHUTTING_DOWN
//
// MessageText:
//
// The operation could not be performed because the directory service is shutting down.
//
static const long ERROR_DS_SHUTTING_DOWN = 8364L;
//
// MessageId: ERROR_DS_UNKNOWN_OPERATION
//
// MessageText:
//
// The directory service request is invalid.
//
static const long ERROR_DS_UNKNOWN_OPERATION = 8365L;
//
// MessageId: ERROR_DS_INVALID_ROLE_OWNER
//
// MessageText:
//
// The role owner attribute could not be read.
//
static const long ERROR_DS_INVALID_ROLE_OWNER = 8366L;
//
// MessageId: ERROR_DS_COULDNT_CONTACT_FSMO
//
// MessageText:
//
// The requested FSMO operation failed. The current FSMO holder could not be contacted.
//
static const long ERROR_DS_COULDNT_CONTACT_FSMO = 8367L;
//
// MessageId: ERROR_DS_CROSS_NC_DN_RENAME
//
// MessageText:
//
// Modification of a DN across a naming context is not permitted.
//
static const long ERROR_DS_CROSS_NC_DN_RENAME = 8368L;
//
// MessageId: ERROR_DS_CANT_MOD_SYSTEM_ONLY
//
// MessageText:
//
// The attribute cannot be modified because it is owned by the system.
//
static const long ERROR_DS_CANT_MOD_SYSTEM_ONLY = 8369L;
//
// MessageId: ERROR_DS_REPLICATOR_ONLY
//
// MessageText:
//
// Only the replicator can perform this function.
//
static const long ERROR_DS_REPLICATOR_ONLY = 8370L;
//
// MessageId: ERROR_DS_OBJ_CLASS_NOT_DEFINED
//
// MessageText:
//
// The specified class is not defined.
//
static const long ERROR_DS_OBJ_CLASS_NOT_DEFINED = 8371L;
//
// MessageId: ERROR_DS_OBJ_CLASS_NOT_SUBCLASS
//
// MessageText:
//
// The specified class is not a subclass.
//
static const long ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = 8372L;
//
// MessageId: ERROR_DS_NAME_REFERENCE_INVALID
//
// MessageText:
//
// The name reference is invalid.
//
static const long ERROR_DS_NAME_REFERENCE_INVALID = 8373L;
//
// MessageId: ERROR_DS_CROSS_REF_EXISTS
//
// MessageText:
//
// A cross reference already exists.
//
static const long ERROR_DS_CROSS_REF_EXISTS = 8374L;
//
// MessageId: ERROR_DS_CANT_DEL_MASTER_CROSSREF
//
// MessageText:
//
// It is not permitted to delete a master cross reference.
//
static const long ERROR_DS_CANT_DEL_MASTER_CROSSREF = 8375L;
//
// MessageId: ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD
//
// MessageText:
//
// Subtree notifications are only supported on NC heads.
//
static const long ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = 8376L;
//
// MessageId: ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX
//
// MessageText:
//
// Notification filter is too complex.
//
static const long ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX = 8377L;
//
// MessageId: ERROR_DS_DUP_RDN
//
// MessageText:
//
// Schema update failed: duplicate RDN.
//
static const long ERROR_DS_DUP_RDN = 8378L;
//
// MessageId: ERROR_DS_DUP_OID
//
// MessageText:
//
// Schema update failed: duplicate OID.
//
static const long ERROR_DS_DUP_OID = 8379L;
//
// MessageId: ERROR_DS_DUP_MAPI_ID
//
// MessageText:
//
// Schema update failed: duplicate MAPI identifier.
//
static const long ERROR_DS_DUP_MAPI_ID = 8380L;
//
// MessageId: ERROR_DS_DUP_SCHEMA_ID_GUID
//
// MessageText:
//
// Schema update failed: duplicate schema-id GUID.
//
static const long ERROR_DS_DUP_SCHEMA_ID_GUID = 8381L;
//
// MessageId: ERROR_DS_DUP_LDAP_DISPLAY_NAME
//
// MessageText:
//
// Schema update failed: duplicate LDAP display name.
//
static const long ERROR_DS_DUP_LDAP_DISPLAY_NAME = 8382L;
//
// MessageId: ERROR_DS_SEMANTIC_ATT_TEST
//
// MessageText:
//
// Schema update failed: range-lower less than range upper.
//
static const long ERROR_DS_SEMANTIC_ATT_TEST = 8383L;
//
// MessageId: ERROR_DS_SYNTAX_MISMATCH
//
// MessageText:
//
// Schema update failed: syntax mismatch.
//
static const long ERROR_DS_SYNTAX_MISMATCH = 8384L;
//
// MessageId: ERROR_DS_EXISTS_IN_MUST_HAVE
//
// MessageText:
//
// Schema deletion failed: attribute is used in must-contain.
//
static const long ERROR_DS_EXISTS_IN_MUST_HAVE = 8385L;
//
// MessageId: ERROR_DS_EXISTS_IN_MAY_HAVE
//
// MessageText:
//
// Schema deletion failed: attribute is used in may-contain.
//
static const long ERROR_DS_EXISTS_IN_MAY_HAVE = 8386L;
//
// MessageId: ERROR_DS_NONEXISTENT_MAY_HAVE
//
// MessageText:
//
// Schema update failed: attribute in may-contain does not exist.
//
static const long ERROR_DS_NONEXISTENT_MAY_HAVE = 8387L;
//
// MessageId: ERROR_DS_NONEXISTENT_MUST_HAVE
//
// MessageText:
//
// Schema update failed: attribute in must-contain does not exist.
//
static const long ERROR_DS_NONEXISTENT_MUST_HAVE = 8388L;
//
// MessageId: ERROR_DS_AUX_CLS_TEST_FAIL
//
// MessageText:
//
// Schema update failed: class in aux-class list does not exist or is not an auxiliary class.
//
static const long ERROR_DS_AUX_CLS_TEST_FAIL = 8389L;
//
// MessageId: ERROR_DS_NONEXISTENT_POSS_SUP
//
// MessageText:
//
// Schema update failed: class in poss-superiors does not exist.
//
static const long ERROR_DS_NONEXISTENT_POSS_SUP = 8390L;
//
// MessageId: ERROR_DS_SUB_CLS_TEST_FAIL
//
// MessageText:
//
// Schema update failed: class in subclassof list does not exist or does not satisfy hierarchy rules.
//
static const long ERROR_DS_SUB_CLS_TEST_FAIL = 8391L;
//
// MessageId: ERROR_DS_BAD_RDN_ATT_ID_SYNTAX
//
// MessageText:
//
// Schema update failed: Rdn-Att-Id has wrong syntax.
//
static const long ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = 8392L;
//
// MessageId: ERROR_DS_EXISTS_IN_AUX_CLS
//
// MessageText:
//
// Schema deletion failed: class is used as auxiliary class.
//
static const long ERROR_DS_EXISTS_IN_AUX_CLS = 8393L;
//
// MessageId: ERROR_DS_EXISTS_IN_SUB_CLS
//
// MessageText:
//
// Schema deletion failed: class is used as sub class.
//
static const long ERROR_DS_EXISTS_IN_SUB_CLS = 8394L;
//
// MessageId: ERROR_DS_EXISTS_IN_POSS_SUP
//
// MessageText:
//
// Schema deletion failed: class is used as poss superior.
//
static const long ERROR_DS_EXISTS_IN_POSS_SUP = 8395L;
//
// MessageId: ERROR_DS_RECALCSCHEMA_FAILED
//
// MessageText:
//
// Schema update failed in recalculating validation cache.
//
static const long ERROR_DS_RECALCSCHEMA_FAILED = 8396L;
//
// MessageId: ERROR_DS_TREE_DELETE_NOT_FINISHED
//
// MessageText:
//
// The tree deletion is not finished. The request must be made again to continue deleting the tree.
//
static const long ERROR_DS_TREE_DELETE_NOT_FINISHED = 8397L;
//
// MessageId: ERROR_DS_CANT_DELETE
//
// MessageText:
//
// The requested delete operation could not be performed.
//
static const long ERROR_DS_CANT_DELETE = 8398L;
//
// MessageId: ERROR_DS_ATT_SCHEMA_REQ_ID
//
// MessageText:
//
// Cannot read the governs class identifier for the schema record.
//
static const long ERROR_DS_ATT_SCHEMA_REQ_ID = 8399L;
//
// MessageId: ERROR_DS_BAD_ATT_SCHEMA_SYNTAX
//
// MessageText:
//
// The attribute schema has bad syntax.
//
static const long ERROR_DS_BAD_ATT_SCHEMA_SYNTAX = 8400L;
//
// MessageId: ERROR_DS_CANT_CACHE_ATT
//
// MessageText:
//
// The attribute could not be cached.
//
static const long ERROR_DS_CANT_CACHE_ATT = 8401L;
//
// MessageId: ERROR_DS_CANT_CACHE_CLASS
//
// MessageText:
//
// The class could not be cached.
//
static const long ERROR_DS_CANT_CACHE_CLASS = 8402L;
//
// MessageId: ERROR_DS_CANT_REMOVE_ATT_CACHE
//
// MessageText:
//
// The attribute could not be removed from the cache.
//
static const long ERROR_DS_CANT_REMOVE_ATT_CACHE = 8403L;
//
// MessageId: ERROR_DS_CANT_REMOVE_CLASS_CACHE
//
// MessageText:
//
// The class could not be removed from the cache.
//
static const long ERROR_DS_CANT_REMOVE_CLASS_CACHE = 8404L;
//
// MessageId: ERROR_DS_CANT_RETRIEVE_DN
//
// MessageText:
//
// The distinguished name attribute could not be read.
//
static const long ERROR_DS_CANT_RETRIEVE_DN = 8405L;
//
// MessageId: ERROR_DS_MISSING_SUPREF
//
// MessageText:
//
// No superior reference has been configured for the directory service. The directory service is therefore unable to issue referrals to objects outside this forest.
//
static const long ERROR_DS_MISSING_SUPREF = 8406L;
//
// MessageId: ERROR_DS_CANT_RETRIEVE_INSTANCE
//
// MessageText:
//
// The instance type attribute could not be retrieved.
//
static const long ERROR_DS_CANT_RETRIEVE_INSTANCE = 8407L;
//
// MessageId: ERROR_DS_CODE_INCONSISTENCY
//
// MessageText:
//
// An internal error has occurred.
//
static const long ERROR_DS_CODE_INCONSISTENCY = 8408L;
//
// MessageId: ERROR_DS_DATABASE_ERROR
//
// MessageText:
//
// A database error has occurred.
//
static const long ERROR_DS_DATABASE_ERROR = 8409L;
//
// MessageId: ERROR_DS_GOVERNSID_MISSING
//
// MessageText:
//
// The attribute GOVERNSID is missing.
//
static const long ERROR_DS_GOVERNSID_MISSING = 8410L;
//
// MessageId: ERROR_DS_MISSING_EXPECTED_ATT
//
// MessageText:
//
// An expected attribute is missing.
//
static const long ERROR_DS_MISSING_EXPECTED_ATT = 8411L;
//
// MessageId: ERROR_DS_NCNAME_MISSING_CR_REF
//
// MessageText:
//
// The specified naming context is missing a cross reference.
//
static const long ERROR_DS_NCNAME_MISSING_CR_REF = 8412L;
//
// MessageId: ERROR_DS_SECURITY_CHECKING_ERROR
//
// MessageText:
//
// A security checking error has occurred.
//
static const long ERROR_DS_SECURITY_CHECKING_ERROR = 8413L;
//
// MessageId: ERROR_DS_SCHEMA_NOT_LOADED
//
// MessageText:
//
// The schema is not loaded.
//
static const long ERROR_DS_SCHEMA_NOT_LOADED = 8414L;
//
// MessageId: ERROR_DS_SCHEMA_ALLOC_FAILED
//
// MessageText:
//
// Schema allocation failed. Please check if the machine is running low on memory.
//
static const long ERROR_DS_SCHEMA_ALLOC_FAILED = 8415L;
//
// MessageId: ERROR_DS_ATT_SCHEMA_REQ_SYNTAX
//
// MessageText:
//
// Failed to obtain the required syntax for the attribute schema.
//
static const long ERROR_DS_ATT_SCHEMA_REQ_SYNTAX = 8416L;
//
// MessageId: ERROR_DS_GCVERIFY_ERROR
//
// MessageText:
//
// The global catalog verification failed. The global catalog is not available or does not support the operation. Some part of the directory is currently not available.
//
static const long ERROR_DS_GCVERIFY_ERROR = 8417L;
//
// MessageId: ERROR_DS_DRA_SCHEMA_MISMATCH
//
// MessageText:
//
// The replication operation failed because of a schema mismatch between the servers involved.
//
static const long ERROR_DS_DRA_SCHEMA_MISMATCH = 8418L;
//
// MessageId: ERROR_DS_CANT_FIND_DSA_OBJ
//
// MessageText:
//
// The DSA object could not be found.
//
static const long ERROR_DS_CANT_FIND_DSA_OBJ = 8419L;
//
// MessageId: ERROR_DS_CANT_FIND_EXPECTED_NC
//
// MessageText:
//
// The naming context could not be found.
//
static const long ERROR_DS_CANT_FIND_EXPECTED_NC = 8420L;
//
// MessageId: ERROR_DS_CANT_FIND_NC_IN_CACHE
//
// MessageText:
//
// The naming context could not be found in the cache.
//
static const long ERROR_DS_CANT_FIND_NC_IN_CACHE = 8421L;
//
// MessageId: ERROR_DS_CANT_RETRIEVE_CHILD
//
// MessageText:
//
// The child object could not be retrieved.
//
static const long ERROR_DS_CANT_RETRIEVE_CHILD = 8422L;
//
// MessageId: ERROR_DS_SECURITY_ILLEGAL_MODIFY
//
// MessageText:
//
// The modification was not permitted for security reasons.
//
static const long ERROR_DS_SECURITY_ILLEGAL_MODIFY = 8423L;
//
// MessageId: ERROR_DS_CANT_REPLACE_HIDDEN_REC
//
// MessageText:
//
// The operation cannot replace the hidden record.
//
static const long ERROR_DS_CANT_REPLACE_HIDDEN_REC = 8424L;
//
// MessageId: ERROR_DS_BAD_HIERARCHY_FILE
//
// MessageText:
//
// The hierarchy file is invalid.
//
static const long ERROR_DS_BAD_HIERARCHY_FILE = 8425L;
//
// MessageId: ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED
//
// MessageText:
//
// The attempt to build the hierarchy table failed.
//
static const long ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = 8426L;
//
// MessageId: ERROR_DS_CONFIG_PARAM_MISSING
//
// MessageText:
//
// The directory configuration parameter is missing from the registry.
//
static const long ERROR_DS_CONFIG_PARAM_MISSING = 8427L;
//
// MessageId: ERROR_DS_COUNTING_AB_INDICES_FAILED
//
// MessageText:
//
// The attempt to count the address book indices failed.
//
static const long ERROR_DS_COUNTING_AB_INDICES_FAILED = 8428L;
//
// MessageId: ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED
//
// MessageText:
//
// The allocation of the hierarchy table failed.
//
static const long ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED = 8429L;
//
// MessageId: ERROR_DS_INTERNAL_FAILURE
//
// MessageText:
//
// The directory service encountered an internal failure.
//
static const long ERROR_DS_INTERNAL_FAILURE = 8430L;
//
// MessageId: ERROR_DS_UNKNOWN_ERROR
//
// MessageText:
//
// The directory service encountered an unknown failure.
//
static const long ERROR_DS_UNKNOWN_ERROR = 8431L;
//
// MessageId: ERROR_DS_ROOT_REQUIRES_CLASS_TOP
//
// MessageText:
//
// A root object requires a class of 'top'.
//
static const long ERROR_DS_ROOT_REQUIRES_CLASS_TOP = 8432L;
//
// MessageId: ERROR_DS_REFUSING_FSMO_ROLES
//
// MessageText:
//
// This directory server is shutting down, and cannot take ownership of new floating single-master operation roles.
//
static const long ERROR_DS_REFUSING_FSMO_ROLES = 8433L;
//
// MessageId: ERROR_DS_MISSING_FSMO_SETTINGS
//
// MessageText:
//
// The directory service is missing mandatory configuration information, and is unable to determine the ownership of floating single-master operation roles.
//
static const long ERROR_DS_MISSING_FSMO_SETTINGS = 8434L;
//
// MessageId: ERROR_DS_UNABLE_TO_SURRENDER_ROLES
//
// MessageText:
//
// The directory service was unable to transfer ownership of one or more floating single-master operation roles to other servers.
//
static const long ERROR_DS_UNABLE_TO_SURRENDER_ROLES = 8435L;
//
// MessageId: ERROR_DS_DRA_GENERIC
//
// MessageText:
//
// The replication operation failed.
//
static const long ERROR_DS_DRA_GENERIC = 8436L;
//
// MessageId: ERROR_DS_DRA_INVALID_PARAMETER
//
// MessageText:
//
// An invalid parameter was specified for this replication operation.
//
static const long ERROR_DS_DRA_INVALID_PARAMETER = 8437L;
//
// MessageId: ERROR_DS_DRA_BUSY
//
// MessageText:
//
// The directory service is too busy to complete the replication operation at this time.
//
static const long ERROR_DS_DRA_BUSY = 8438L;
//
// MessageId: ERROR_DS_DRA_BAD_DN
//
// MessageText:
//
// The distinguished name specified for this replication operation is invalid.
//
static const long ERROR_DS_DRA_BAD_DN = 8439L;
//
// MessageId: ERROR_DS_DRA_BAD_NC
//
// MessageText:
//
// The naming context specified for this replication operation is invalid.
//
static const long ERROR_DS_DRA_BAD_NC = 8440L;
//
// MessageId: ERROR_DS_DRA_DN_EXISTS
//
// MessageText:
//
// The distinguished name specified for this replication operation already exists.
//
static const long ERROR_DS_DRA_DN_EXISTS = 8441L;
//
// MessageId: ERROR_DS_DRA_INTERNAL_ERROR
//
// MessageText:
//
// The replication system encountered an internal error.
//
static const long ERROR_DS_DRA_INTERNAL_ERROR = 8442L;
//
// MessageId: ERROR_DS_DRA_INCONSISTENT_DIT
//
// MessageText:
//
// The replication operation encountered a database inconsistency.
//
static const long ERROR_DS_DRA_INCONSISTENT_DIT = 8443L;
//
// MessageId: ERROR_DS_DRA_CONNECTION_FAILED
//
// MessageText:
//
// The server specified for this replication operation could not be contacted.
//
static const long ERROR_DS_DRA_CONNECTION_FAILED = 8444L;
//
// MessageId: ERROR_DS_DRA_BAD_INSTANCE_TYPE
//
// MessageText:
//
// The replication operation encountered an object with an invalid instance type.
//
static const long ERROR_DS_DRA_BAD_INSTANCE_TYPE = 8445L;
//
// MessageId: ERROR_DS_DRA_OUT_OF_MEM
//
// MessageText:
//
// The replication operation failed to allocate memory.
//
static const long ERROR_DS_DRA_OUT_OF_MEM = 8446L;
//
// MessageId: ERROR_DS_DRA_MAIL_PROBLEM
//
// MessageText:
//
// The replication operation encountered an error with the mail system.
//
static const long ERROR_DS_DRA_MAIL_PROBLEM = 8447L;
//
// MessageId: ERROR_DS_DRA_REF_ALREADY_EXISTS
//
// MessageText:
//
// The replication reference information for the target server already exists.
//
static const long ERROR_DS_DRA_REF_ALREADY_EXISTS = 8448L;
//
// MessageId: ERROR_DS_DRA_REF_NOT_FOUND
//
// MessageText:
//
// The replication reference information for the target server does not exist.
//
static const long ERROR_DS_DRA_REF_NOT_FOUND = 8449L;
//
// MessageId: ERROR_DS_DRA_OBJ_IS_REP_SOURCE
//
// MessageText:
//
// The naming context cannot be removed because it is replicated to another server.
//
static const long ERROR_DS_DRA_OBJ_IS_REP_SOURCE = 8450L;
//
// MessageId: ERROR_DS_DRA_DB_ERROR
//
// MessageText:
//
// The replication operation encountered a database error.
//
static const long ERROR_DS_DRA_DB_ERROR = 8451L;
//
// MessageId: ERROR_DS_DRA_NO_REPLICA
//
// MessageText:
//
// The naming context is in the process of being removed or is not replicated from the specified server.
//
static const long ERROR_DS_DRA_NO_REPLICA = 8452L;
//
// MessageId: ERROR_DS_DRA_ACCESS_DENIED
//
// MessageText:
//
// Replication access was denied.
//
static const long ERROR_DS_DRA_ACCESS_DENIED = 8453L;
//
// MessageId: ERROR_DS_DRA_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported by this version of the directory service.
//
static const long ERROR_DS_DRA_NOT_SUPPORTED = 8454L;
//
// MessageId: ERROR_DS_DRA_RPC_CANCELLED
//
// MessageText:
//
// The replication remote procedure call was cancelled.
//
static const long ERROR_DS_DRA_RPC_CANCELLED = 8455L;
//
// MessageId: ERROR_DS_DRA_SOURCE_DISABLED
//
// MessageText:
//
// The source server is currently rejecting replication requests.
//
static const long ERROR_DS_DRA_SOURCE_DISABLED = 8456L;
//
// MessageId: ERROR_DS_DRA_SINK_DISABLED
//
// MessageText:
//
// The destination server is currently rejecting replication requests.
//
static const long ERROR_DS_DRA_SINK_DISABLED = 8457L;
//
// MessageId: ERROR_DS_DRA_NAME_COLLISION
//
// MessageText:
//
// The replication operation failed due to a collision of object names.
//
static const long ERROR_DS_DRA_NAME_COLLISION = 8458L;
//
// MessageId: ERROR_DS_DRA_SOURCE_REINSTALLED
//
// MessageText:
//
// The replication source has been reinstalled.
//
static const long ERROR_DS_DRA_SOURCE_REINSTALLED = 8459L;
//
// MessageId: ERROR_DS_DRA_MISSING_PARENT
//
// MessageText:
//
// The replication operation failed because a required parent object is missing.
//
static const long ERROR_DS_DRA_MISSING_PARENT = 8460L;
//
// MessageId: ERROR_DS_DRA_PREEMPTED
//
// MessageText:
//
// The replication operation was preempted.
//
static const long ERROR_DS_DRA_PREEMPTED = 8461L;
//
// MessageId: ERROR_DS_DRA_ABANDON_SYNC
//
// MessageText:
//
// The replication synchronization attempt was abandoned because of a lack of updates.
//
static const long ERROR_DS_DRA_ABANDON_SYNC = 8462L;
//
// MessageId: ERROR_DS_DRA_SHUTDOWN
//
// MessageText:
//
// The replication operation was terminated because the system is shutting down.
//
static const long ERROR_DS_DRA_SHUTDOWN = 8463L;
//
// MessageId: ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET
//
// MessageText:
//
// Synchronization attempt failed because the destination DC is currently waiting to synchronize new partial attributes from source. This condition is normal if a recent schema change modified the partial attribute set. The destination partial attribute set is not a subset of source partial attribute set.
//
static const long ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = 8464L;
//
// MessageId: ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA
//
// MessageText:
//
// The replication synchronization attempt failed because a master replica attempted to sync from a partial replica.
//
static const long ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA = 8465L;
//
// MessageId: ERROR_DS_DRA_EXTN_CONNECTION_FAILED
//
// MessageText:
//
// The server specified for this replication operation was contacted, but that server was unable to contact an additional server needed to complete the operation.
//
static const long ERROR_DS_DRA_EXTN_CONNECTION_FAILED = 8466L;
//
// MessageId: ERROR_DS_INSTALL_SCHEMA_MISMATCH
//
// MessageText:
//
// The version of the directory service schema of the source forest is not compatible with the version of directory service on this computer.
//
static const long ERROR_DS_INSTALL_SCHEMA_MISMATCH = 8467L;
//
// MessageId: ERROR_DS_DUP_LINK_ID
//
// MessageText:
//
// Schema update failed: An attribute with the same link identifier already exists.
//
static const long ERROR_DS_DUP_LINK_ID = 8468L;
//
// MessageId: ERROR_DS_NAME_ERROR_RESOLVING
//
// MessageText:
//
// Name translation: Generic processing error.
//
static const long ERROR_DS_NAME_ERROR_RESOLVING = 8469L;
//
// MessageId: ERROR_DS_NAME_ERROR_NOT_FOUND
//
// MessageText:
//
// Name translation: Could not find the name or insufficient right to see name.
//
static const long ERROR_DS_NAME_ERROR_NOT_FOUND = 8470L;
//
// MessageId: ERROR_DS_NAME_ERROR_NOT_UNIQUE
//
// MessageText:
//
// Name translation: Input name mapped to more than one output name.
//
static const long ERROR_DS_NAME_ERROR_NOT_UNIQUE = 8471L;
//
// MessageId: ERROR_DS_NAME_ERROR_NO_MAPPING
//
// MessageText:
//
// Name translation: Input name found, but not the associated output format.
//
static const long ERROR_DS_NAME_ERROR_NO_MAPPING = 8472L;
//
// MessageId: ERROR_DS_NAME_ERROR_DOMAIN_ONLY
//
// MessageText:
//
// Name translation: Unable to resolve completely, only the domain was found.
//
static const long ERROR_DS_NAME_ERROR_DOMAIN_ONLY = 8473L;
//
// MessageId: ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
//
// MessageText:
//
// Name translation: Unable to perform purely syntactical mapping at the client without going out to the wire.
//
static const long ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 8474L;
//
// MessageId: ERROR_DS_CONSTRUCTED_ATT_MOD
//
// MessageText:
//
// Modification of a constructed attribute is not allowed.
//
static const long ERROR_DS_CONSTRUCTED_ATT_MOD = 8475L;
//
// MessageId: ERROR_DS_WRONG_OM_OBJ_CLASS
//
// MessageText:
//
// The OM-Object-Class specified is incorrect for an attribute with the specified syntax.
//
static const long ERROR_DS_WRONG_OM_OBJ_CLASS = 8476L;
//
// MessageId: ERROR_DS_DRA_REPL_PENDING
//
// MessageText:
//
// The replication request has been posted; waiting for reply.
//
static const long ERROR_DS_DRA_REPL_PENDING = 8477L;
//
// MessageId: ERROR_DS_DS_REQUIRED
//
// MessageText:
//
// The requested operation requires a directory service, and none was available.
//
static const long ERROR_DS_DS_REQUIRED = 8478L;
//
// MessageId: ERROR_DS_INVALID_LDAP_DISPLAY_NAME
//
// MessageText:
//
// The LDAP display name of the class or attribute contains non-ASCII characters.
//
static const long ERROR_DS_INVALID_LDAP_DISPLAY_NAME = 8479L;
//
// MessageId: ERROR_DS_NON_BASE_SEARCH
//
// MessageText:
//
// The requested search operation is only supported for base searches.
//
static const long ERROR_DS_NON_BASE_SEARCH = 8480L;
//
// MessageId: ERROR_DS_CANT_RETRIEVE_ATTS
//
// MessageText:
//
// The search failed to retrieve attributes from the database.
//
static const long ERROR_DS_CANT_RETRIEVE_ATTS = 8481L;
//
// MessageId: ERROR_DS_BACKLINK_WITHOUT_LINK
//
// MessageText:
//
// The schema update operation tried to add a backward link attribute that has no corresponding forward link.
//
static const long ERROR_DS_BACKLINK_WITHOUT_LINK = 8482L;
//
// MessageId: ERROR_DS_EPOCH_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the object's epoch number. Either source or destination does not have the latest version of the object.
//
static const long ERROR_DS_EPOCH_MISMATCH = 8483L;
//
// MessageId: ERROR_DS_SRC_NAME_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the object's current name. Either source or destination does not have the latest version of the object.
//
static const long ERROR_DS_SRC_NAME_MISMATCH = 8484L;
//
// MessageId: ERROR_DS_SRC_AND_DST_NC_IDENTICAL
//
// MessageText:
//
// Source and destination for the cross-domain move operation are identical. Caller should use local move operation instead of cross-domain move operation.
//
static const long ERROR_DS_SRC_AND_DST_NC_IDENTICAL = 8485L;
//
// MessageId: ERROR_DS_DST_NC_MISMATCH
//
// MessageText:
//
// Source and destination for a cross-domain move are not in agreement on the naming contexts in the forest. Either source or destination does not have the latest version of the Partitions container.
//
static const long ERROR_DS_DST_NC_MISMATCH = 8486L;
//
// MessageId: ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC
//
// MessageText:
//
// Destination of a cross-domain move is not authoritative for the destination naming context.
//
static const long ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = 8487L;
//
// MessageId: ERROR_DS_SRC_GUID_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the identity of the source object. Either source or destination does not have the latest version of the source object.
//
static const long ERROR_DS_SRC_GUID_MISMATCH = 8488L;
//
// MessageId: ERROR_DS_CANT_MOVE_DELETED_OBJECT
//
// MessageText:
//
// Object being moved across-domains is already known to be deleted by the destination server. The source server does not have the latest version of the source object.
//
static const long ERROR_DS_CANT_MOVE_DELETED_OBJECT = 8489L;
//
// MessageId: ERROR_DS_PDC_OPERATION_IN_PROGRESS
//
// MessageText:
//
// Another operation which requires exclusive access to the PDC FSMO is already in progress.
//
static const long ERROR_DS_PDC_OPERATION_IN_PROGRESS = 8490L;
//
// MessageId: ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD
//
// MessageText:
//
// A cross-domain move operation failed such that two versions of the moved object exist - one each in the source and destination domains. The destination object needs to be removed to restore the system to a consistent state.
//
static const long ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = 8491L;
//
// MessageId: ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION
//
// MessageText:
//
// This object may not be moved across domain boundaries either because cross-domain moves for this class are disallowed, or the object has some special characteristics, e.g.: trust account or restricted RID, which prevent its move.
//
static const long ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION = 8492L;
//
// MessageId: ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS
//
// MessageText:
//
// Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group. Remove the object from any account group memberships and retry.
//
static const long ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = 8493L;
//
// MessageId: ERROR_DS_NC_MUST_HAVE_NC_PARENT
//
// MessageText:
//
// A naming context head must be the immediate child of another naming context head, not of an interior node.
//
static const long ERROR_DS_NC_MUST_HAVE_NC_PARENT = 8494L;
//
// MessageId: ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE
//
// MessageText:
//
// The directory cannot validate the proposed naming context name because it does not hold a replica of the naming context above the proposed naming context. Please ensure that the domain naming master role is held by a server that is configured as a global catalog server, and that the server is up to date with its replication partners. (Applies only to Windows 2000 Domain Naming masters)
//
static const long ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = 8495L;
//
// MessageId: ERROR_DS_DST_DOMAIN_NOT_NATIVE
//
// MessageText:
//
// Destination domain must be in native mode.
//
static const long ERROR_DS_DST_DOMAIN_NOT_NATIVE = 8496L;
//
// MessageId: ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER
//
// MessageText:
//
// The operation cannot be performed because the server does not have an infrastructure container in the domain of interest.
//
static const long ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = 8497L;
//
// MessageId: ERROR_DS_CANT_MOVE_ACCOUNT_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty account groups is not allowed.
//
static const long ERROR_DS_CANT_MOVE_ACCOUNT_GROUP = 8498L;
//
// MessageId: ERROR_DS_CANT_MOVE_RESOURCE_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty resource groups is not allowed.
//
static const long ERROR_DS_CANT_MOVE_RESOURCE_GROUP = 8499L;
//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG
//
// MessageText:
//
// The search flags for the attribute are invalid. The ANR bit is valid only on attributes of Unicode or Teletex strings.
//
static const long ERROR_DS_INVALID_SEARCH_FLAG = 8500L;
//
// MessageId: ERROR_DS_NO_TREE_DELETE_ABOVE_NC
//
// MessageText:
//
// Tree deletions starting at an object which has an NC head as a descendant are not allowed.
//
static const long ERROR_DS_NO_TREE_DELETE_ABOVE_NC = 8501L;
//
// MessageId: ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE
//
// MessageText:
//
// The directory service failed to lock a tree in preparation for a tree deletion because the tree was in use.
//
static const long ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE = 8502L;
//
// MessageId: ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE
//
// MessageText:
//
// The directory service failed to identify the list of objects to delete while attempting a tree deletion.
//
static const long ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = 8503L;
//
// MessageId: ERROR_DS_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Please shutdown this system and reboot into Directory Services Restore Mode, check the event log for more detailed information.
//
static const long ERROR_DS_SAM_INIT_FAILURE = 8504L;
//
// MessageId: ERROR_DS_SENSITIVE_GROUP_VIOLATION
//
// MessageText:
//
// Only an administrator can modify the membership list of an administrative group.
//
static const long ERROR_DS_SENSITIVE_GROUP_VIOLATION = 8505L;
//
// MessageId: ERROR_DS_CANT_MOD_PRIMARYGROUPID
//
// MessageText:
//
// Cannot change the primary group ID of a domain controller account.
//
static const long ERROR_DS_CANT_MOD_PRIMARYGROUPID = 8506L;
//
// MessageId: ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD
//
// MessageText:
//
// An attempt is made to modify the base schema.
//
static const long ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = 8507L;
//
// MessageId: ERROR_DS_NONSAFE_SCHEMA_CHANGE
//
// MessageText:
//
// Adding a new mandatory attribute to an existing class, deleting a mandatory attribute from an existing class, or adding an optional attribute to the special class Top that is not a backlink attribute (directly or through inheritance, for example, by adding or deleting an auxiliary class) is not allowed.
//
static const long ERROR_DS_NONSAFE_SCHEMA_CHANGE = 8508L;
//
// MessageId: ERROR_DS_SCHEMA_UPDATE_DISALLOWED
//
// MessageText:
//
// Schema update is not allowed on this DC because the DC is not the schema FSMO Role Owner.
//
static const long ERROR_DS_SCHEMA_UPDATE_DISALLOWED = 8509L;
//
// MessageId: ERROR_DS_CANT_CREATE_UNDER_SCHEMA
//
// MessageText:
//
// An object of this class cannot be created under the schema container. You can only create attribute-schema and class-schema objects under the schema container.
//
static const long ERROR_DS_CANT_CREATE_UNDER_SCHEMA = 8510L;
//
// MessageId: ERROR_DS_INSTALL_NO_SRC_SCH_VERSION
//
// MessageText:
//
// The replica/child install failed to get the objectVersion attribute on the schema container on the source DC. Either the attribute is missing on the schema container or the credentials supplied do not have permission to read it.
//
static const long ERROR_DS_INSTALL_NO_SRC_SCH_VERSION = 8511L;
//
// MessageId: ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE
//
// MessageText:
//
// The replica/child install failed to read the objectVersion attribute in the SCHEMA section of the file schema.ini in the system32 directory.
//
static const long ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = 8512L;
//
// MessageId: ERROR_DS_INVALID_GROUP_TYPE
//
// MessageText:
//
// The specified group type is invalid.
//
static const long ERROR_DS_INVALID_GROUP_TYPE = 8513L;
//
// MessageId: ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// You cannot nest global groups in a mixed domain if the group is security-enabled.
//
static const long ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 8514L;
//
// MessageId: ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// You cannot nest local groups in a mixed domain if the group is security-enabled.
//
static const long ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 8515L;
//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A global group cannot have a local group as a member.
//
static const long ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 8516L;
//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// A global group cannot have a universal group as a member.
//
static const long ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 8517L;
//
// MessageId: ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A universal group cannot have a local group as a member.
//
static const long ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 8518L;
//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER
//
// MessageText:
//
// A global group cannot have a cross-domain member.
//
static const long ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 8519L;
//
// MessageId: ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER
//
// MessageText:
//
// A local group cannot have another cross domain local group as a member.
//
static const long ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 8520L;
//
// MessageId: ERROR_DS_HAVE_PRIMARY_MEMBERS
//
// MessageText:
//
// A group with primary members cannot change to a security-disabled group.
//
static const long ERROR_DS_HAVE_PRIMARY_MEMBERS = 8521L;
//
// MessageId: ERROR_DS_STRING_SD_CONVERSION_FAILED
//
// MessageText:
//
// The schema cache load failed to convert the string default SD on a class-schema object.
//
static const long ERROR_DS_STRING_SD_CONVERSION_FAILED = 8522L;
//
// MessageId: ERROR_DS_NAMING_MASTER_GC
//
// MessageText:
//
// Only DSAs configured to be Global Catalog servers should be allowed to hold the Domain Naming Master FSMO role. (Applies only to Windows 2000 servers)
//
static const long ERROR_DS_NAMING_MASTER_GC = 8523L;
//
// MessageId: ERROR_DS_DNS_LOOKUP_FAILURE
//
// MessageText:
//
// The DSA operation is unable to proceed because of a DNS lookup failure.
//
static const long ERROR_DS_DNS_LOOKUP_FAILURE = 8524L;
//
// MessageId: ERROR_DS_COULDNT_UPDATE_SPNS
//
// MessageText:
//
// While processing a change to the DNS Host Name for an object, the Service Principal Name values could not be kept in sync.
//
static const long ERROR_DS_COULDNT_UPDATE_SPNS = 8525L;
//
// MessageId: ERROR_DS_CANT_RETRIEVE_SD
//
// MessageText:
//
// The Security Descriptor attribute could not be read.
//
static const long ERROR_DS_CANT_RETRIEVE_SD = 8526L;
//
// MessageId: ERROR_DS_KEY_NOT_UNIQUE
//
// MessageText:
//
// The object requested was not found, but an object with that key was found.
//
static const long ERROR_DS_KEY_NOT_UNIQUE = 8527L;
//
// MessageId: ERROR_DS_WRONG_LINKED_ATT_SYNTAX
//
// MessageText:
//
// The syntax of the linked attribute being added is incorrect. Forward links can only have syntax 2.5.5.1, 2.5.5.7, and 2.5.5.14, and backlinks can only have syntax 2.5.5.1
//
static const long ERROR_DS_WRONG_LINKED_ATT_SYNTAX = 8528L;
//
// MessageId: ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD
//
// MessageText:
//
// Security Account Manager needs to get the boot password.
//
static const long ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = 8529L;
//
// MessageId: ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY
//
// MessageText:
//
// Security Account Manager needs to get the boot key from floppy disk.
//
static const long ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY = 8530L;
//
// MessageId: ERROR_DS_CANT_START
//
// MessageText:
//
// Directory Service cannot start.
//
static const long ERROR_DS_CANT_START = 8531L;
//
// MessageId: ERROR_DS_INIT_FAILURE
//
// MessageText:
//
// Directory Services could not start.
//
static const long ERROR_DS_INIT_FAILURE = 8532L;
//
// MessageId: ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION
//
// MessageText:
//
// The connection between client and server requires packet privacy or better.
//
static const long ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = 8533L;
//
// MessageId: ERROR_DS_SOURCE_DOMAIN_IN_FOREST
//
// MessageText:
//
// The source domain may not be in the same forest as destination.
//
static const long ERROR_DS_SOURCE_DOMAIN_IN_FOREST = 8534L;
//
// MessageId: ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST
//
// MessageText:
//
// The destination domain must be in the forest.
//
static const long ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = 8535L;
//
// MessageId: ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED
//
// MessageText:
//
// The operation requires that destination domain auditing be enabled.
//
static const long ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = 8536L;
//
// MessageId: ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN
//
// MessageText:
//
// The operation couldn't locate a DC for the source domain.
//
static const long ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN = 8537L;
//
// MessageId: ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER
//
// MessageText:
//
// The source object must be a group or user.
//
static const long ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = 8538L;
//
// MessageId: ERROR_DS_SRC_SID_EXISTS_IN_FOREST
//
// MessageText:
//
// The source object's SID already exists in destination forest.
//
static const long ERROR_DS_SRC_SID_EXISTS_IN_FOREST = 8539L;
//
// MessageId: ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH
//
// MessageText:
//
// The source and destination object must be of the same type.
//
static const long ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = 8540L;
//
// MessageId: ERROR_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Click OK to shut down the system and reboot into Safe Mode. Check the event log for detailed information.
//
static const long ERROR_SAM_INIT_FAILURE = 8541L;
//
// MessageId: ERROR_DS_DRA_SCHEMA_INFO_SHIP
//
// MessageText:
//
// Schema information could not be included in the replication request.
//
static const long ERROR_DS_DRA_SCHEMA_INFO_SHIP = 8542L;
//
// MessageId: ERROR_DS_DRA_SCHEMA_CONFLICT
//
// MessageText:
//
// The replication operation could not be completed due to a schema incompatibility.
//
static const long ERROR_DS_DRA_SCHEMA_CONFLICT = 8543L;
//
// MessageId: ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT
//
// MessageText:
//
// The replication operation could not be completed due to a previous schema incompatibility.
//
static const long ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = 8544L;
//
// MessageId: ERROR_DS_DRA_OBJ_NC_MISMATCH
//
// MessageText:
//
// The replication update could not be applied because either the source or the destination has not yet received information regarding a recent cross-domain move operation.
//
static const long ERROR_DS_DRA_OBJ_NC_MISMATCH = 8545L;
//
// MessageId: ERROR_DS_NC_STILL_HAS_DSAS
//
// MessageText:
//
// The requested domain could not be deleted because there exist domain controllers that still host this domain.
//
static const long ERROR_DS_NC_STILL_HAS_DSAS = 8546L;
//
// MessageId: ERROR_DS_GC_REQUIRED
//
// MessageText:
//
// The requested operation can be performed only on a global catalog server.
//
static const long ERROR_DS_GC_REQUIRED = 8547L;
//
// MessageId: ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY
//
// MessageText:
//
// A local group can only be a member of other local groups in the same domain.
//
static const long ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 8548L;
//
// MessageId: ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS
//
// MessageText:
//
// Foreign security principals cannot be members of universal groups.
//
static const long ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 8549L;
//
// MessageId: ERROR_DS_CANT_ADD_TO_GC
//
// MessageText:
//
// The attribute is not allowed to be replicated to the GC because of security reasons.
//
static const long ERROR_DS_CANT_ADD_TO_GC = 8550L;
//
// MessageId: ERROR_DS_NO_CHECKPOINT_WITH_PDC
//
// MessageText:
//
// The checkpoint with the PDC could not be taken because there too many modifications being processed currently.
//
static const long ERROR_DS_NO_CHECKPOINT_WITH_PDC = 8551L;
//
// MessageId: ERROR_DS_SOURCE_AUDITING_NOT_ENABLED
//
// MessageText:
//
// The operation requires that source domain auditing be enabled.
//
static const long ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = 8552L;
//
// MessageId: ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC
//
// MessageText:
//
// Security principal objects can only be created inside domain naming contexts.
//
static const long ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC = 8553L;
//
// MessageId: ERROR_DS_INVALID_NAME_FOR_SPN
//
// MessageText:
//
// A Service Principal Name (SPN) could not be constructed because the provided hostname is not in the necessary format.
//
static const long ERROR_DS_INVALID_NAME_FOR_SPN = 8554L;
//
// MessageId: ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS
//
// MessageText:
//
// A Filter was passed that uses constructed attributes.
//
static const long ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS = 8555L;
//
// MessageId: ERROR_DS_UNICODEPWD_NOT_IN_QUOTES
//
// MessageText:
//
// The unicodePwd attribute value must be enclosed in double quotes.
//
static const long ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = 8556L;
//
// MessageId: ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED
//
// MessageText:
//
// Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.
//
static const long ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 8557L;
//
// MessageId: ERROR_DS_MUST_BE_RUN_ON_DST_DC
//
// MessageText:
//
// For security reasons, the operation must be run on the destination DC.
//
static const long ERROR_DS_MUST_BE_RUN_ON_DST_DC = 8558L;
//
// MessageId: ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER
//
// MessageText:
//
// For security reasons, the source DC must be NT4SP4 or greater.
//
static const long ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER = 8559L;
//
// MessageId: ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ
//
// MessageText:
//
// Critical Directory Service System objects cannot be deleted during tree delete operations. The tree delete may have been partially performed.
//
static const long ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = 8560L;
//
// MessageId: ERROR_DS_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Directory Services could not start because of the following error: %1.
// Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//
static const long ERROR_DS_INIT_FAILURE_CONSOLE = 8561L;
//
// MessageId: ERROR_DS_SAM_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//
static const long ERROR_DS_SAM_INIT_FAILURE_CONSOLE = 8562L;
//
// MessageId: ERROR_DS_FOREST_VERSION_TOO_HIGH
//
// MessageText:
//
// The version of the operating system is incompatible with the current AD DS forest functional level or AD LDS Configuration Set functional level. You must upgrade to a new version of the operating system before this server can become an AD DS Domain Controller or add an AD LDS Instance in this AD DS Forest or AD LDS Configuration Set.
//
static const long ERROR_DS_FOREST_VERSION_TOO_HIGH = 8563L;
//
// MessageId: ERROR_DS_DOMAIN_VERSION_TOO_HIGH
//
// MessageText:
//
// The version of the operating system installed is incompatible with the current domain functional level. You must upgrade to a new version of the operating system before this server can become a domain controller in this domain.
//
static const long ERROR_DS_DOMAIN_VERSION_TOO_HIGH = 8564L;
//
// MessageId: ERROR_DS_FOREST_VERSION_TOO_LOW
//
// MessageText:
//
// The version of the operating system installed on this server no longer supports the current AD DS Forest functional level or AD LDS Configuration Set functional level. You must raise the AD DS Forest functional level or AD LDS Configuration Set functional level before this server can become an AD DS Domain Controller or an AD LDS Instance in this Forest or Configuration Set.
//
static const long ERROR_DS_FOREST_VERSION_TOO_LOW = 8565L;
//
// MessageId: ERROR_DS_DOMAIN_VERSION_TOO_LOW
//
// MessageText:
//
// The version of the operating system installed on this server no longer supports the current domain functional level. You must raise the domain functional level before this server can become a domain controller in this domain.
//
static const long ERROR_DS_DOMAIN_VERSION_TOO_LOW = 8566L;
//
// MessageId: ERROR_DS_INCOMPATIBLE_VERSION
//
// MessageText:
//
// The version of the operating system installed on this server is incompatible with the functional level of the domain or forest.
//
static const long ERROR_DS_INCOMPATIBLE_VERSION = 8567L;
//
// MessageId: ERROR_DS_LOW_DSA_VERSION
//
// MessageText:
//
// The functional level of the domain (or forest) cannot be raised to the requested value, because there exist one or more domain controllers in the domain (or forest) that are at a lower incompatible functional level.
//
static const long ERROR_DS_LOW_DSA_VERSION = 8568L;
//
// MessageId: ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN
//
// MessageText:
//
// The forest functional level cannot be raised to the requested value since one or more domains are still in mixed domain mode. All domains in the forest must be in native mode, for you to raise the forest functional level.
//
static const long ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN = 8569L;
//
// MessageId: ERROR_DS_NOT_SUPPORTED_SORT_ORDER
//
// MessageText:
//
// The sort order requested is not supported.
//
static const long ERROR_DS_NOT_SUPPORTED_SORT_ORDER = 8570L;
//
// MessageId: ERROR_DS_NAME_NOT_UNIQUE
//
// MessageText:
//
// The requested name already exists as a unique identifier.
//
static const long ERROR_DS_NAME_NOT_UNIQUE = 8571L;
//
// MessageId: ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4
//
// MessageText:
//
// The machine account was created pre-NT4. The account needs to be recreated.
//
static const long ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = 8572L;
//
// MessageId: ERROR_DS_OUT_OF_VERSION_STORE
//
// MessageText:
//
// The database is out of version store.
//
static const long ERROR_DS_OUT_OF_VERSION_STORE = 8573L;
//
// MessageId: ERROR_DS_INCOMPATIBLE_CONTROLS_USED
//
// MessageText:
//
// Unable to continue operation because multiple conflicting controls were used.
//
static const long ERROR_DS_INCOMPATIBLE_CONTROLS_USED = 8574L;
//
// MessageId: ERROR_DS_NO_REF_DOMAIN
//
// MessageText:
//
// Unable to find a valid security descriptor reference domain for this partition.
//
static const long ERROR_DS_NO_REF_DOMAIN = 8575L;
//
// MessageId: ERROR_DS_RESERVED_LINK_ID
//
// MessageText:
//
// Schema update failed: The link identifier is reserved.
//
static const long ERROR_DS_RESERVED_LINK_ID = 8576L;
//
// MessageId: ERROR_DS_LINK_ID_NOT_AVAILABLE
//
// MessageText:
//
// Schema update failed: There are no link identifiers available.
//
static const long ERROR_DS_LINK_ID_NOT_AVAILABLE = 8577L;
//
// MessageId: ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// An account group cannot have a universal group as a member.
//
static const long ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 8578L;
//
// MessageId: ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE
//
// MessageText:
//
// Rename or move operations on naming context heads or read-only objects are not allowed.
//
static const long ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE = 8579L;
//
// MessageId: ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC
//
// MessageText:
//
// Move operations on objects in the schema naming context are not allowed.
//
static const long ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = 8580L;
//
// MessageId: ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG
//
// MessageText:
//
// A system flag has been set on the object and does not allow the object to be moved or renamed.
//
static const long ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG = 8581L;
//
// MessageId: ERROR_DS_MODIFYDN_WRONG_GRANDPARENT
//
// MessageText:
//
// This object is not allowed to change its grandparent container. Moves are not forbidden on this object, but are restricted to sibling containers.
//
static const long ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = 8582L;
//
// MessageId: ERROR_DS_NAME_ERROR_TRUST_REFERRAL
//
// MessageText:
//
// Unable to resolve completely, a referral to another forest is generated.
//
static const long ERROR_DS_NAME_ERROR_TRUST_REFERRAL = 8583L;
//
// MessageId: ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER
//
// MessageText:
//
// The requested action is not supported on standard server.
//
static const long ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = 8584L;
//
// MessageId: ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD
//
// MessageText:
//
// Could not access a partition of the directory service located on a remote server. Make sure at least one server is running for the partition in question.
//
static const long ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD = 8585L;
//
// MessageId: ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2
//
// MessageText:
//
// The directory cannot validate the proposed naming context (or partition) name because it does not hold a replica nor can it contact a replica of the naming context above the proposed naming context. Please ensure that the parent naming context is properly registered in DNS, and at least one replica of this naming context is reachable by the Domain Naming master.
//
static const long ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = 8586L;
//
// MessageId: ERROR_DS_THREAD_LIMIT_EXCEEDED
//
// MessageText:
//
// The thread limit for this request was exceeded.
//
static const long ERROR_DS_THREAD_LIMIT_EXCEEDED = 8587L;
//
// MessageId: ERROR_DS_NOT_CLOSEST
//
// MessageText:
//
// The Global catalog server is not in the closest site.
//
static const long ERROR_DS_NOT_CLOSEST = 8588L;
//
// MessageId: ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF
//
// MessageText:
//
// The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the corresponding server object in the local DS database has no serverReference attribute.
//
static const long ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = 8589L;
//
// MessageId: ERROR_DS_SINGLE_USER_MODE_FAILED
//
// MessageText:
//
// The Directory Service failed to enter single user mode.
//
static const long ERROR_DS_SINGLE_USER_MODE_FAILED = 8590L;
//
// MessageId: ERROR_DS_NTDSCRIPT_SYNTAX_ERROR
//
// MessageText:
//
// The Directory Service cannot parse the script because of a syntax error.
//
static const long ERROR_DS_NTDSCRIPT_SYNTAX_ERROR = 8591L;
//
// MessageId: ERROR_DS_NTDSCRIPT_PROCESS_ERROR
//
// MessageText:
//
// The Directory Service cannot process the script because of an error.
//
static const long ERROR_DS_NTDSCRIPT_PROCESS_ERROR = 8592L;
//
// MessageId: ERROR_DS_DIFFERENT_REPL_EPOCHS
//
// MessageText:
//
// The directory service cannot perform the requested operation because the servers involved are of different replication epochs (which is usually related to a domain rename that is in progress).
//
static const long ERROR_DS_DIFFERENT_REPL_EPOCHS = 8593L;
//
// MessageId: ERROR_DS_DRS_EXTENSIONS_CHANGED
//
// MessageText:
//
// The directory service binding must be renegotiated due to a change in the server extensions information.
//
static const long ERROR_DS_DRS_EXTENSIONS_CHANGED = 8594L;
//
// MessageId: ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR
//
// MessageText:
//
// Operation not allowed on a disabled cross ref.
//
static const long ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR = 8595L;
//
// MessageId: ERROR_DS_NO_MSDS_INTID
//
// MessageText:
//
// Schema update failed: No values for msDS-IntId are available.
//
static const long ERROR_DS_NO_MSDS_INTID = 8596L;
//
// MessageId: ERROR_DS_DUP_MSDS_INTID
//
// MessageText:
//
// Schema update failed: Duplicate msDS-INtId. Retry the operation.
//
static const long ERROR_DS_DUP_MSDS_INTID = 8597L;
//
// MessageId: ERROR_DS_EXISTS_IN_RDNATTID
//
// MessageText:
//
// Schema deletion failed: attribute is used in rDNAttID.
//
static const long ERROR_DS_EXISTS_IN_RDNATTID = 8598L;
//
// MessageId: ERROR_DS_AUTHORIZATION_FAILED
//
// MessageText:
//
// The directory service failed to authorize the request.
//
static const long ERROR_DS_AUTHORIZATION_FAILED = 8599L;
//
// MessageId: ERROR_DS_INVALID_SCRIPT
//
// MessageText:
//
// The Directory Service cannot process the script because it is invalid.
//
static const long ERROR_DS_INVALID_SCRIPT = 8600L;
//
// MessageId: ERROR_DS_REMOTE_CROSSREF_OP_FAILED
//
// MessageText:
//
// The remote create cross reference operation failed on the Domain Naming Master FSMO. The operation's error is in the extended data.
//
static const long ERROR_DS_REMOTE_CROSSREF_OP_FAILED = 8601L;
//
// MessageId: ERROR_DS_CROSS_REF_BUSY
//
// MessageText:
//
// A cross reference is in use locally with the same name.
//
static const long ERROR_DS_CROSS_REF_BUSY = 8602L;
//
// MessageId: ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN
//
// MessageText:
//
// The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the server's domain has been deleted from the forest.
//
static const long ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = 8603L;
//
// MessageId: ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC
//
// MessageText:
//
// Writeable NCs prevent this DC from demoting.
//
static const long ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC = 8604L;
//
// MessageId: ERROR_DS_DUPLICATE_ID_FOUND
//
// MessageText:
//
// The requested object has a non-unique identifier and cannot be retrieved.
//
static const long ERROR_DS_DUPLICATE_ID_FOUND = 8605L;
//
// MessageId: ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT
//
// MessageText:
//
// Insufficient attributes were given to create an object. This object may not exist because it may have been deleted and already garbage collected.
//
static const long ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT = 8606L;
//
// MessageId: ERROR_DS_GROUP_CONVERSION_ERROR
//
// MessageText:
//
// The group cannot be converted due to attribute restrictions on the requested group type.
//
static const long ERROR_DS_GROUP_CONVERSION_ERROR = 8607L;
//
// MessageId: ERROR_DS_CANT_MOVE_APP_BASIC_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty basic application groups is not allowed.
//
static const long ERROR_DS_CANT_MOVE_APP_BASIC_GROUP = 8608L;
//
// MessageId: ERROR_DS_CANT_MOVE_APP_QUERY_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty query based application groups is not allowed.
//
static const long ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = 8609L;
//
// MessageId: ERROR_DS_ROLE_NOT_VERIFIED
//
// MessageText:
//
// The FSMO role ownership could not be verified because its directory partition has not replicated successfully with at least one replication partner.
//
static const long ERROR_DS_ROLE_NOT_VERIFIED = 8610L;
//
// MessageId: ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL
//
// MessageText:
//
// The target container for a redirection of a well known object container cannot already be a special container.
//
static const long ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = 8611L;
//
// MessageId: ERROR_DS_DOMAIN_RENAME_IN_PROGRESS
//
// MessageText:
//
// The Directory Service cannot perform the requested operation because a domain rename operation is in progress.
//
static const long ERROR_DS_DOMAIN_RENAME_IN_PROGRESS = 8612L;
//
// MessageId: ERROR_DS_EXISTING_AD_CHILD_NC
//
// MessageText:
//
// The directory service detected a child partition below the requested partition name. The partition hierarchy must be created in a top down method.
//
static const long ERROR_DS_EXISTING_AD_CHILD_NC = 8613L;
//
// MessageId: ERROR_DS_REPL_LIFETIME_EXCEEDED
//
// MessageText:
//
// The directory service cannot replicate with this server because the time since the last replication with this server has exceeded the tombstone lifetime.
//
static const long ERROR_DS_REPL_LIFETIME_EXCEEDED = 8614L;
//
// MessageId: ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER
//
// MessageText:
//
// The requested operation is not allowed on an object under the system container.
//
static const long ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = 8615L;
//
// MessageId: ERROR_DS_LDAP_SEND_QUEUE_FULL
//
// MessageText:
//
// The LDAP servers network send queue has filled up because the client is not processing the results of it's requests fast enough. No more requests will be processed until the client catches up. If the client does not catch up then it will be disconnected.
//
static const long ERROR_DS_LDAP_SEND_QUEUE_FULL = 8616L;
//
// MessageId: ERROR_DS_DRA_OUT_SCHEDULE_WINDOW
//
// MessageText:
//
// The scheduled replication did not take place because the system was too busy to execute the request within the schedule window. The replication queue is overloaded. Consider reducing the number of partners or decreasing the scheduled replication frequency.
//
static const long ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = 8617L;
//
// MessageId: ERROR_DS_POLICY_NOT_KNOWN
//
// MessageText:
//
// At this time, it cannot be determined if the branch replication policy is available on the hub domain controller. Please retry at a later time to account for replication latencies.
//
static const long ERROR_DS_POLICY_NOT_KNOWN = 8618L;
//
// MessageId: ERROR_NO_SITE_SETTINGS_OBJECT
//
// MessageText:
//
// The site settings object for the specified site does not exist.
//
static const long ERROR_NO_SITE_SETTINGS_OBJECT = 8619L;
//
// MessageId: ERROR_NO_SECRETS
//
// MessageText:
//
// The local account store does not contain secret material for the specified account.
//
static const long ERROR_NO_SECRETS = 8620L;
//
// MessageId: ERROR_NO_WRITABLE_DC_FOUND
//
// MessageText:
//
// Could not find a writable domain controller in the domain.
//
static const long ERROR_NO_WRITABLE_DC_FOUND = 8621L;
//
// MessageId: ERROR_DS_NO_SERVER_OBJECT
//
// MessageText:
//
// The server object for the domain controller does not exist.
//
static const long ERROR_DS_NO_SERVER_OBJECT = 8622L;
//
// MessageId: ERROR_DS_NO_NTDSA_OBJECT
//
// MessageText:
//
// The NTDS Settings object for the domain controller does not exist.
//
static const long ERROR_DS_NO_NTDSA_OBJECT = 8623L;
//
// MessageId: ERROR_DS_NON_ASQ_SEARCH
//
// MessageText:
//
// The requested search operation is not supported for ASQ searches.
//
static const long ERROR_DS_NON_ASQ_SEARCH = 8624L;
//
// MessageId: ERROR_DS_AUDIT_FAILURE
//
// MessageText:
//
// A required audit event could not be generated for the operation.
//
static const long ERROR_DS_AUDIT_FAILURE = 8625L;
//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE
//
// MessageText:
//
// The search flags for the attribute are invalid. The subtree index bit is valid only on single valued attributes.
//
static const long ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = 8626L;
//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG_TUPLE
//
// MessageText:
//
// The search flags for the attribute are invalid. The tuple index bit is valid only on attributes of Unicode strings.
//
static const long ERROR_DS_INVALID_SEARCH_FLAG_TUPLE = 8627L;
//
// MessageId: ERROR_DS_HIERARCHY_TABLE_TOO_DEEP
//
// MessageText:
//
// The address books are nested too deeply. Failed to build the hierarchy table.
//
static const long ERROR_DS_HIERARCHY_TABLE_TOO_DEEP = 8628L;
//
// MessageId: ERROR_DS_DRA_CORRUPT_UTD_VECTOR
//
// MessageText:
//
// The specified up-to-date-ness vector is corrupt.
//
static const long ERROR_DS_DRA_CORRUPT_UTD_VECTOR = 8629L;
//
// MessageId: ERROR_DS_DRA_SECRETS_DENIED
//
// MessageText:
//
// The request to replicate secrets is denied.
//
static const long ERROR_DS_DRA_SECRETS_DENIED = 8630L;
//
// MessageId: ERROR_DS_RESERVED_MAPI_ID
//
// MessageText:
//
// Schema update failed: The MAPI identifier is reserved.
//
static const long ERROR_DS_RESERVED_MAPI_ID = 8631L;
//
// MessageId: ERROR_DS_MAPI_ID_NOT_AVAILABLE
//
// MessageText:
//
// Schema update failed: There are no MAPI identifiers available.
//
static const long ERROR_DS_MAPI_ID_NOT_AVAILABLE = 8632L;
//
// MessageId: ERROR_DS_DRA_MISSING_KRBTGT_SECRET
//
// MessageText:
//
// The replication operation failed because the required attributes of the local krbtgt object are missing.
//
static const long ERROR_DS_DRA_MISSING_KRBTGT_SECRET = 8633L;
//
// MessageId: ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The domain name of the trusted domain already exists in the forest.
//
static const long ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 8634L;
//
// MessageId: ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The flat name of the trusted domain already exists in the forest.
//
static const long ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST = 8635L;
//
// MessageId: ERROR_INVALID_USER_PRINCIPAL_NAME
//
// MessageText:
//
// The User Principal Name (UPN) is invalid.
//
static const long ERROR_INVALID_USER_PRINCIPAL_NAME = 8636L;
//
// MessageId: ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS
//
// MessageText:
//
// OID mapped groups cannot have members.
//
static const long ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 8637L;
//
// MessageId: ERROR_DS_OID_NOT_FOUND
//
// MessageText:
//
// The specified OID cannot be found.
//
static const long ERROR_DS_OID_NOT_FOUND = 8638L;
//
// MessageId: ERROR_DS_DRA_RECYCLED_TARGET
//
// MessageText:
//
// The replication operation failed because the target object referred by a link value is recycled.
//
static const long ERROR_DS_DRA_RECYCLED_TARGET = 8639L;
///////////////////////////////////////////////////
//                                                /
//        End of Active Directory Error Codes     /
//                                                /
//                  8000 to  8999                 /
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//               DNS Error codes                 //
//                                               //
//                 9000 to 9999                  //
///////////////////////////////////////////////////
// =============================
// Facility DNS Error Messages
// =============================
//
//  DNS response codes.
//
static const int DNS_ERROR_RESPONSE_CODES_BASE = 9000;
static const int DNS_ERROR_RCODE_NO_ERROR = NO_ERROR;
static const int DNS_ERROR_MASK = 0x00002328;
// DNS_ERROR_RCODE_FORMAT_ERROR          0x00002329
//
// MessageId: DNS_ERROR_RCODE_FORMAT_ERROR
//
// MessageText:
//
// DNS server unable to interpret format.
//
static const long DNS_ERROR_RCODE_FORMAT_ERROR = 9001L;
// DNS_ERROR_RCODE_SERVER_FAILURE        0x0000232a
//
// MessageId: DNS_ERROR_RCODE_SERVER_FAILURE
//
// MessageText:
//
// DNS server failure.
//
static const long DNS_ERROR_RCODE_SERVER_FAILURE = 9002L;
// DNS_ERROR_RCODE_NAME_ERROR            0x0000232b
//
// MessageId: DNS_ERROR_RCODE_NAME_ERROR
//
// MessageText:
//
// DNS name does not exist.
//
static const long DNS_ERROR_RCODE_NAME_ERROR = 9003L;
// DNS_ERROR_RCODE_NOT_IMPLEMENTED       0x0000232c
//
// MessageId: DNS_ERROR_RCODE_NOT_IMPLEMENTED
//
// MessageText:
//
// DNS request not supported by name server.
//
static const long DNS_ERROR_RCODE_NOT_IMPLEMENTED = 9004L;
// DNS_ERROR_RCODE_REFUSED               0x0000232d
//
// MessageId: DNS_ERROR_RCODE_REFUSED
//
// MessageText:
//
// DNS operation refused.
//
static const long DNS_ERROR_RCODE_REFUSED = 9005L;
// DNS_ERROR_RCODE_YXDOMAIN              0x0000232e
//
// MessageId: DNS_ERROR_RCODE_YXDOMAIN
//
// MessageText:
//
// DNS name that ought not exist, does exist.
//
static const long DNS_ERROR_RCODE_YXDOMAIN = 9006L;
// DNS_ERROR_RCODE_YXRRSET               0x0000232f
//
// MessageId: DNS_ERROR_RCODE_YXRRSET
//
// MessageText:
//
// DNS RR set that ought not exist, does exist.
//
static const long DNS_ERROR_RCODE_YXRRSET = 9007L;
// DNS_ERROR_RCODE_NXRRSET               0x00002330
//
// MessageId: DNS_ERROR_RCODE_NXRRSET
//
// MessageText:
//
// DNS RR set that ought to exist, does not exist.
//
static const long DNS_ERROR_RCODE_NXRRSET = 9008L;
// DNS_ERROR_RCODE_NOTAUTH               0x00002331
//
// MessageId: DNS_ERROR_RCODE_NOTAUTH
//
// MessageText:
//
// DNS server not authoritative for zone.
//
static const long DNS_ERROR_RCODE_NOTAUTH = 9009L;
// DNS_ERROR_RCODE_NOTZONE               0x00002332
//
// MessageId: DNS_ERROR_RCODE_NOTZONE
//
// MessageText:
//
// DNS name in update or prereq is not in zone.
//
static const long DNS_ERROR_RCODE_NOTZONE = 9010L;
// DNS_ERROR_RCODE_BADSIG                0x00002338
//
// MessageId: DNS_ERROR_RCODE_BADSIG
//
// MessageText:
//
// DNS signature failed to verify.
//
static const long DNS_ERROR_RCODE_BADSIG = 9016L;
// DNS_ERROR_RCODE_BADKEY                0x00002339
//
// MessageId: DNS_ERROR_RCODE_BADKEY
//
// MessageText:
//
// DNS bad key.
//
static const long DNS_ERROR_RCODE_BADKEY = 9017L;
// DNS_ERROR_RCODE_BADTIME               0x0000233a
//
// MessageId: DNS_ERROR_RCODE_BADTIME
//
// MessageText:
//
// DNS signature validity expired.
//
static const long DNS_ERROR_RCODE_BADTIME = 9018L;
static const int DNS_ERROR_RCODE_LAST = DNS_ERROR_RCODE_BADTIME;
//
// Packet format
//
static const int DNS_ERROR_PACKET_FMT_BASE = 9500;
// DNS_INFO_NO_RECORDS                   0x0000251d
//
// MessageId: DNS_INFO_NO_RECORDS
//
// MessageText:
//
// No records found for given DNS query.
//
static const long DNS_INFO_NO_RECORDS = 9501L;
// DNS_ERROR_BAD_PACKET                  0x0000251e
//
// MessageId: DNS_ERROR_BAD_PACKET
//
// MessageText:
//
// Bad DNS packet.
//
static const long DNS_ERROR_BAD_PACKET = 9502L;
// DNS_ERROR_NO_PACKET                   0x0000251f
//
// MessageId: DNS_ERROR_NO_PACKET
//
// MessageText:
//
// No DNS packet.
//
static const long DNS_ERROR_NO_PACKET = 9503L;
// DNS_ERROR_RCODE                       0x00002520
//
// MessageId: DNS_ERROR_RCODE
//
// MessageText:
//
// DNS error, check rcode.
//
static const long DNS_ERROR_RCODE = 9504L;
// DNS_ERROR_UNSECURE_PACKET             0x00002521
//
// MessageId: DNS_ERROR_UNSECURE_PACKET
//
// MessageText:
//
// Unsecured DNS packet.
//
static const long DNS_ERROR_UNSECURE_PACKET = 9505L;
static const int DNS_STATUS_PACKET_UNSECURE = DNS_ERROR_UNSECURE_PACKET;
//
// General API errors
//
static const int DNS_ERROR_NO_MEMORY = ERROR_OUTOFMEMORY;
static const int DNS_ERROR_INVALID_NAME = ERROR_INVALID_NAME;
static const int DNS_ERROR_INVALID_DATA = ERROR_INVALID_DATA;
static const int DNS_ERROR_GENERAL_API_BASE = 9550;
// DNS_ERROR_INVALID_TYPE                0x0000254f
//
// MessageId: DNS_ERROR_INVALID_TYPE
//
// MessageText:
//
// Invalid DNS type.
//
static const long DNS_ERROR_INVALID_TYPE = 9551L;
// DNS_ERROR_INVALID_IP_ADDRESS          0x00002550
//
// MessageId: DNS_ERROR_INVALID_IP_ADDRESS
//
// MessageText:
//
// Invalid IP address.
//
static const long DNS_ERROR_INVALID_IP_ADDRESS = 9552L;
// DNS_ERROR_INVALID_PROPERTY            0x00002551
//
// MessageId: DNS_ERROR_INVALID_PROPERTY
//
// MessageText:
//
// Invalid property.
//
static const long DNS_ERROR_INVALID_PROPERTY = 9553L;
// DNS_ERROR_TRY_AGAIN_LATER             0x00002552
//
// MessageId: DNS_ERROR_TRY_AGAIN_LATER
//
// MessageText:
//
// Try DNS operation again later.
//
static const long DNS_ERROR_TRY_AGAIN_LATER = 9554L;
// DNS_ERROR_NOT_UNIQUE                  0x00002553
//
// MessageId: DNS_ERROR_NOT_UNIQUE
//
// MessageText:
//
// Record for given name and type is not unique.
//
static const long DNS_ERROR_NOT_UNIQUE = 9555L;
// DNS_ERROR_NON_RFC_NAME                0x00002554
//
// MessageId: DNS_ERROR_NON_RFC_NAME
//
// MessageText:
//
// DNS name does not comply with RFC specifications.
//
static const long DNS_ERROR_NON_RFC_NAME = 9556L;
// DNS_STATUS_FQDN                       0x00002555
//
// MessageId: DNS_STATUS_FQDN
//
// MessageText:
//
// DNS name is a fully-qualified DNS name.
//
static const long DNS_STATUS_FQDN = 9557L;
// DNS_STATUS_DOTTED_NAME                0x00002556
//
// MessageId: DNS_STATUS_DOTTED_NAME
//
// MessageText:
//
// DNS name is dotted (multi-label).
//
static const long DNS_STATUS_DOTTED_NAME = 9558L;
// DNS_STATUS_SINGLE_PART_NAME           0x00002557
//
// MessageId: DNS_STATUS_SINGLE_PART_NAME
//
// MessageText:
//
// DNS name is a single-part name.
//
static const long DNS_STATUS_SINGLE_PART_NAME = 9559L;
// DNS_ERROR_INVALID_NAME_CHAR           0x00002558
//
// MessageId: DNS_ERROR_INVALID_NAME_CHAR
//
// MessageText:
//
// DNS name contains an invalid character.
//
static const long DNS_ERROR_INVALID_NAME_CHAR = 9560L;
// DNS_ERROR_NUMERIC_NAME                0x00002559
//
// MessageId: DNS_ERROR_NUMERIC_NAME
//
// MessageText:
//
// DNS name is entirely numeric.
//
static const long DNS_ERROR_NUMERIC_NAME = 9561L;
// DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER  0x0000255A
//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER
//
// MessageText:
//
// The operation requested is not permitted on a DNS root server.
//
static const long DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER = 9562L;
// DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION  0x0000255B
//
// MessageId: DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION
//
// MessageText:
//
// The record could not be created because this part of the DNS namespace has been delegated to another server.
//
static const long DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = 9563L;
// DNS_ERROR_CANNOT_FIND_ROOT_HINTS  0x0000255C
//
// MessageId: DNS_ERROR_CANNOT_FIND_ROOT_HINTS
//
// MessageText:
//
// The DNS server could not find a set of root hints.
//
static const long DNS_ERROR_CANNOT_FIND_ROOT_HINTS = 9564L;
// DNS_ERROR_INCONSISTENT_ROOT_HINTS  0x0000255D
//
// MessageId: DNS_ERROR_INCONSISTENT_ROOT_HINTS
//
// MessageText:
//
// The DNS server found root hints but they were not consistent across all adapters.
//
static const long DNS_ERROR_INCONSISTENT_ROOT_HINTS = 9565L;
// DNS_ERROR_DWORD_VALUE_TOO_SMALL    0x0000255E
//
// MessageId: DNS_ERROR_DWORD_VALUE_TOO_SMALL
//
// MessageText:
//
// The specified value is too small for this parameter.
//
static const long DNS_ERROR_DWORD_VALUE_TOO_SMALL = 9566L;
// DNS_ERROR_DWORD_VALUE_TOO_LARGE    0x0000255F
//
// MessageId: DNS_ERROR_DWORD_VALUE_TOO_LARGE
//
// MessageText:
//
// The specified value is too large for this parameter.
//
static const long DNS_ERROR_DWORD_VALUE_TOO_LARGE = 9567L;
// DNS_ERROR_BACKGROUND_LOADING       0x00002560
//
// MessageId: DNS_ERROR_BACKGROUND_LOADING
//
// MessageText:
//
// This operation is not allowed while the DNS server is loading zones in the background. Please try again later.
//
static const long DNS_ERROR_BACKGROUND_LOADING = 9568L;
// DNS_ERROR_NOT_ALLOWED_ON_RODC      0x00002561
//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_RODC
//
// MessageText:
//
// The operation requested is not permitted on against a DNS server running on a read-only DC.
//
static const long DNS_ERROR_NOT_ALLOWED_ON_RODC = 9569L;
// DNS_ERROR_NOT_ALLOWED_UNDER_DNAME   0x00002562
//
// MessageId: DNS_ERROR_NOT_ALLOWED_UNDER_DNAME
//
// MessageText:
//
// No data is allowed to exist underneath a DNAME record.
//
static const long DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = 9570L;
// DNS_ERROR_DELEGATION_REQUIRED       0x00002563
//
// MessageId: DNS_ERROR_DELEGATION_REQUIRED
//
// MessageText:
//
// This operation requires credentials delegation.
//
static const long DNS_ERROR_DELEGATION_REQUIRED = 9571L;
// DNS_ERROR_INVALID_POLICY_TABLE        0x00002564
//
// MessageId: DNS_ERROR_INVALID_POLICY_TABLE
//
// MessageText:
//
// Name resolution policy table has been corrupted. DNS resolution will fail until it is fixed. Contact your network administrator.
//
static const long DNS_ERROR_INVALID_POLICY_TABLE = 9572L;
//
// Zone errors
//
static const int DNS_ERROR_ZONE_BASE = 9600;
// DNS_ERROR_ZONE_DOES_NOT_EXIST         0x00002581
//
// MessageId: DNS_ERROR_ZONE_DOES_NOT_EXIST
//
// MessageText:
//
// DNS zone does not exist.
//
static const long DNS_ERROR_ZONE_DOES_NOT_EXIST = 9601L;
// DNS_ERROR_NO_ZONE_INFO                0x00002582
//
// MessageId: DNS_ERROR_NO_ZONE_INFO
//
// MessageText:
//
// DNS zone information not available.
//
static const long DNS_ERROR_NO_ZONE_INFO = 9602L;
// DNS_ERROR_INVALID_ZONE_OPERATION      0x00002583
//
// MessageId: DNS_ERROR_INVALID_ZONE_OPERATION
//
// MessageText:
//
// Invalid operation for DNS zone.
//
static const long DNS_ERROR_INVALID_ZONE_OPERATION = 9603L;
// DNS_ERROR_ZONE_CONFIGURATION_ERROR    0x00002584
//
// MessageId: DNS_ERROR_ZONE_CONFIGURATION_ERROR
//
// MessageText:
//
// Invalid DNS zone configuration.
//
static const long DNS_ERROR_ZONE_CONFIGURATION_ERROR = 9604L;
// DNS_ERROR_ZONE_HAS_NO_SOA_RECORD      0x00002585
//
// MessageId: DNS_ERROR_ZONE_HAS_NO_SOA_RECORD
//
// MessageText:
//
// DNS zone has no start of authority (SOA) record.
//
static const long DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = 9605L;
// DNS_ERROR_ZONE_HAS_NO_NS_RECORDS      0x00002586
//
// MessageId: DNS_ERROR_ZONE_HAS_NO_NS_RECORDS
//
// MessageText:
//
// DNS zone has no Name Server (NS) record.
//
static const long DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = 9606L;
// DNS_ERROR_ZONE_LOCKED                 0x00002587
//
// MessageId: DNS_ERROR_ZONE_LOCKED
//
// MessageText:
//
// DNS zone is locked.
//
static const long DNS_ERROR_ZONE_LOCKED = 9607L;
// DNS_ERROR_ZONE_CREATION_FAILED        0x00002588
//
// MessageId: DNS_ERROR_ZONE_CREATION_FAILED
//
// MessageText:
//
// DNS zone creation failed.
//
static const long DNS_ERROR_ZONE_CREATION_FAILED = 9608L;
// DNS_ERROR_ZONE_ALREADY_EXISTS         0x00002589
//
// MessageId: DNS_ERROR_ZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS zone already exists.
//
static const long DNS_ERROR_ZONE_ALREADY_EXISTS = 9609L;
// DNS_ERROR_AUTOZONE_ALREADY_EXISTS     0x0000258a
//
// MessageId: DNS_ERROR_AUTOZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS automatic zone already exists.
//
static const long DNS_ERROR_AUTOZONE_ALREADY_EXISTS = 9610L;
// DNS_ERROR_INVALID_ZONE_TYPE           0x0000258b
//
// MessageId: DNS_ERROR_INVALID_ZONE_TYPE
//
// MessageText:
//
// Invalid DNS zone type.
//
static const long DNS_ERROR_INVALID_ZONE_TYPE = 9611L;
// DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP 0x0000258c
//
// MessageId: DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP
//
// MessageText:
//
// Secondary DNS zone requires master IP address.
//
static const long DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP = 9612L;
// DNS_ERROR_ZONE_NOT_SECONDARY          0x0000258d
//
// MessageId: DNS_ERROR_ZONE_NOT_SECONDARY
//
// MessageText:
//
// DNS zone not secondary.
//
static const long DNS_ERROR_ZONE_NOT_SECONDARY = 9613L;
// DNS_ERROR_NEED_SECONDARY_ADDRESSES    0x0000258e
//
// MessageId: DNS_ERROR_NEED_SECONDARY_ADDRESSES
//
// MessageText:
//
// Need secondary IP address.
//
static const long DNS_ERROR_NEED_SECONDARY_ADDRESSES = 9614L;
// DNS_ERROR_WINS_INIT_FAILED            0x0000258f
//
// MessageId: DNS_ERROR_WINS_INIT_FAILED
//
// MessageText:
//
// WINS initialization failed.
//
static const long DNS_ERROR_WINS_INIT_FAILED = 9615L;
// DNS_ERROR_NEED_WINS_SERVERS           0x00002590
//
// MessageId: DNS_ERROR_NEED_WINS_SERVERS
//
// MessageText:
//
// Need WINS servers.
//
static const long DNS_ERROR_NEED_WINS_SERVERS = 9616L;
// DNS_ERROR_NBSTAT_INIT_FAILED          0x00002591
//
// MessageId: DNS_ERROR_NBSTAT_INIT_FAILED
//
// MessageText:
//
// NBTSTAT initialization call failed.
//
static const long DNS_ERROR_NBSTAT_INIT_FAILED = 9617L;
// DNS_ERROR_SOA_DELETE_INVALID          0x00002592
//
// MessageId: DNS_ERROR_SOA_DELETE_INVALID
//
// MessageText:
//
// Invalid delete of start of authority (SOA)
//
static const long DNS_ERROR_SOA_DELETE_INVALID = 9618L;
// DNS_ERROR_FORWARDER_ALREADY_EXISTS    0x00002593
//
// MessageId: DNS_ERROR_FORWARDER_ALREADY_EXISTS
//
// MessageText:
//
// A conditional forwarding zone already exists for that name.
//
static const long DNS_ERROR_FORWARDER_ALREADY_EXISTS = 9619L;
// DNS_ERROR_ZONE_REQUIRES_MASTER_IP     0x00002594
//
// MessageId: DNS_ERROR_ZONE_REQUIRES_MASTER_IP
//
// MessageText:
//
// This zone must be configured with one or more master DNS server IP addresses.
//
static const long DNS_ERROR_ZONE_REQUIRES_MASTER_IP = 9620L;
// DNS_ERROR_ZONE_IS_SHUTDOWN            0x00002595
//
// MessageId: DNS_ERROR_ZONE_IS_SHUTDOWN
//
// MessageText:
//
// The operation cannot be performed because this zone is shutdown.
//
static const long DNS_ERROR_ZONE_IS_SHUTDOWN = 9621L;
//
// Datafile errors
//
static const int DNS_ERROR_DATAFILE_BASE = 9650;
// DNS                                   0x000025b3
//
// MessageId: DNS_ERROR_PRIMARY_REQUIRES_DATAFILE
//
// MessageText:
//
// Primary DNS zone requires datafile.
//
static const long DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = 9651L;
// DNS                                   0x000025b4
//
// MessageId: DNS_ERROR_INVALID_DATAFILE_NAME
//
// MessageText:
//
// Invalid datafile name for DNS zone.
//
static const long DNS_ERROR_INVALID_DATAFILE_NAME = 9652L;
// DNS                                   0x000025b5
//
// MessageId: DNS_ERROR_DATAFILE_OPEN_FAILURE
//
// MessageText:
//
// Failed to open datafile for DNS zone.
//
static const long DNS_ERROR_DATAFILE_OPEN_FAILURE = 9653L;
// DNS                                   0x000025b6
//
// MessageId: DNS_ERROR_FILE_WRITEBACK_FAILED
//
// MessageText:
//
// Failed to write datafile for DNS zone.
//
static const long DNS_ERROR_FILE_WRITEBACK_FAILED = 9654L;
// DNS                                   0x000025b7
//
// MessageId: DNS_ERROR_DATAFILE_PARSING
//
// MessageText:
//
// Failure while reading datafile for DNS zone.
//
static const long DNS_ERROR_DATAFILE_PARSING = 9655L;
//
// Database errors
//
static const int DNS_ERROR_DATABASE_BASE = 9700;
// DNS_ERROR_RECORD_DOES_NOT_EXIST       0x000025e5
//
// MessageId: DNS_ERROR_RECORD_DOES_NOT_EXIST
//
// MessageText:
//
// DNS record does not exist.
//
static const long DNS_ERROR_RECORD_DOES_NOT_EXIST = 9701L;
// DNS_ERROR_RECORD_FORMAT               0x000025e6
//
// MessageId: DNS_ERROR_RECORD_FORMAT
//
// MessageText:
//
// DNS record format error.
//
static const long DNS_ERROR_RECORD_FORMAT = 9702L;
// DNS_ERROR_NODE_CREATION_FAILED        0x000025e7
//
// MessageId: DNS_ERROR_NODE_CREATION_FAILED
//
// MessageText:
//
// Node creation failure in DNS.
//
static const long DNS_ERROR_NODE_CREATION_FAILED = 9703L;
// DNS_ERROR_UNKNOWN_RECORD_TYPE         0x000025e8
//
// MessageId: DNS_ERROR_UNKNOWN_RECORD_TYPE
//
// MessageText:
//
// Unknown DNS record type.
//
static const long DNS_ERROR_UNKNOWN_RECORD_TYPE = 9704L;
// DNS_ERROR_RECORD_TIMED_OUT            0x000025e9
//
// MessageId: DNS_ERROR_RECORD_TIMED_OUT
//
// MessageText:
//
// DNS record timed out.
//
static const long DNS_ERROR_RECORD_TIMED_OUT = 9705L;
// DNS_ERROR_NAME_NOT_IN_ZONE            0x000025ea
//
// MessageId: DNS_ERROR_NAME_NOT_IN_ZONE
//
// MessageText:
//
// Name not in DNS zone.
//
static const long DNS_ERROR_NAME_NOT_IN_ZONE = 9706L;
// DNS_ERROR_CNAME_LOOP                  0x000025eb
//
// MessageId: DNS_ERROR_CNAME_LOOP
//
// MessageText:
//
// CNAME loop detected.
//
static const long DNS_ERROR_CNAME_LOOP = 9707L;
// DNS_ERROR_NODE_IS_CNAME               0x000025ec
//
// MessageId: DNS_ERROR_NODE_IS_CNAME
//
// MessageText:
//
// Node is a CNAME DNS record.
//
static const long DNS_ERROR_NODE_IS_CNAME = 9708L;
// DNS_ERROR_CNAME_COLLISION             0x000025ed
//
// MessageId: DNS_ERROR_CNAME_COLLISION
//
// MessageText:
//
// A CNAME record already exists for given name.
//
static const long DNS_ERROR_CNAME_COLLISION = 9709L;
// DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT    0x000025ee
//
// MessageId: DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT
//
// MessageText:
//
// Record only at DNS zone root.
//
static const long DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT = 9710L;
// DNS_ERROR_RECORD_ALREADY_EXISTS       0x000025ef
//
// MessageId: DNS_ERROR_RECORD_ALREADY_EXISTS
//
// MessageText:
//
// DNS record already exists.
//
static const long DNS_ERROR_RECORD_ALREADY_EXISTS = 9711L;
// DNS_ERROR_SECONDARY_DATA              0x000025f0
//
// MessageId: DNS_ERROR_SECONDARY_DATA
//
// MessageText:
//
// Secondary DNS zone data error.
//
static const long DNS_ERROR_SECONDARY_DATA = 9712L;
// DNS_ERROR_NO_CREATE_CACHE_DATA        0x000025f1
//
// MessageId: DNS_ERROR_NO_CREATE_CACHE_DATA
//
// MessageText:
//
// Could not create DNS cache data.
//
static const long DNS_ERROR_NO_CREATE_CACHE_DATA = 9713L;
// DNS_ERROR_NAME_DOES_NOT_EXIST         0x000025f2
//
// MessageId: DNS_ERROR_NAME_DOES_NOT_EXIST
//
// MessageText:
//
// DNS name does not exist.
//
static const long DNS_ERROR_NAME_DOES_NOT_EXIST = 9714L;
// DNS_WARNING_PTR_CREATE_FAILED         0x000025f3
//
// MessageId: DNS_WARNING_PTR_CREATE_FAILED
//
// MessageText:
//
// Could not create pointer (PTR) record.
//
static const long DNS_WARNING_PTR_CREATE_FAILED = 9715L;
// DNS_WARNING_DOMAIN_UNDELETED          0x000025f4
//
// MessageId: DNS_WARNING_DOMAIN_UNDELETED
//
// MessageText:
//
// DNS domain was undeleted.
//
static const long DNS_WARNING_DOMAIN_UNDELETED = 9716L;
// DNS_ERROR_DS_UNAVAILABLE              0x000025f5
//
// MessageId: DNS_ERROR_DS_UNAVAILABLE
//
// MessageText:
//
// The directory service is unavailable.
//
static const long DNS_ERROR_DS_UNAVAILABLE = 9717L;
// DNS_ERROR_DS_ZONE_ALREADY_EXISTS      0x000025f6
//
// MessageId: DNS_ERROR_DS_ZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS zone already exists in the directory service.
//
static const long DNS_ERROR_DS_ZONE_ALREADY_EXISTS = 9718L;
// DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE      0x000025f7
//
// MessageId: DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE
//
// MessageText:
//
// DNS server not creating or reading the boot file for the directory service integrated DNS zone.
//
static const long DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE = 9719L;
// DNS_ERROR_NODE_IS_DNAME               0x000025f8
//
// MessageId: DNS_ERROR_NODE_IS_DNAME
//
// MessageText:
//
// Node is a DNAME DNS record.
//
static const long DNS_ERROR_NODE_IS_DNAME = 9720L;
// DNS_ERROR_DNAME_COLLISION             0x000025f9
//
// MessageId: DNS_ERROR_DNAME_COLLISION
//
// MessageText:
//
// A DNAME record already exists for given name.
//
static const long DNS_ERROR_DNAME_COLLISION = 9721L;
// DNS_ERROR_ALIAS_LOOP                  0x000025fa
//
// MessageId: DNS_ERROR_ALIAS_LOOP
//
// MessageText:
//
// An alias loop has been detected with either CNAME or DNAME records.
//
static const long DNS_ERROR_ALIAS_LOOP = 9722L;
//
// Operation errors
//
static const int DNS_ERROR_OPERATION_BASE = 9750;
// DNS_INFO_AXFR_COMPLETE                0x00002617
//
// MessageId: DNS_INFO_AXFR_COMPLETE
//
// MessageText:
//
// DNS AXFR (zone transfer) complete.
//
static const long DNS_INFO_AXFR_COMPLETE = 9751L;
// DNS_ERROR_AXFR                        0x00002618
//
// MessageId: DNS_ERROR_AXFR
//
// MessageText:
//
// DNS zone transfer failed.
//
static const long DNS_ERROR_AXFR = 9752L;
// DNS_INFO_ADDED_LOCAL_WINS             0x00002619
//
// MessageId: DNS_INFO_ADDED_LOCAL_WINS
//
// MessageText:
//
// Added local WINS server.
//
static const long DNS_INFO_ADDED_LOCAL_WINS = 9753L;
//
// Secure update
//
static const int DNS_ERROR_SECURE_BASE = 9800;
// DNS_STATUS_CONTINUE_NEEDED            0x00002649
//
// MessageId: DNS_STATUS_CONTINUE_NEEDED
//
// MessageText:
//
// Secure update call needs to continue update request.
//
static const long DNS_STATUS_CONTINUE_NEEDED = 9801L;
//
// Setup errors
//
static const int DNS_ERROR_SETUP_BASE = 9850;
// DNS_ERROR_NO_TCPIP                    0x0000267b
//
// MessageId: DNS_ERROR_NO_TCPIP
//
// MessageText:
//
// TCP/IP network protocol not installed.
//
static const long DNS_ERROR_NO_TCPIP = 9851L;
// DNS_ERROR_NO_DNS_SERVERS              0x0000267c
//
// MessageId: DNS_ERROR_NO_DNS_SERVERS
//
// MessageText:
//
// No DNS servers configured for local system.
//
static const long DNS_ERROR_NO_DNS_SERVERS = 9852L;
//
// Directory partition (DP) errors
//
static const int DNS_ERROR_DP_BASE = 9900;
// DNS_ERROR_DP_DOES_NOT_EXIST           0x000026ad
//
// MessageId: DNS_ERROR_DP_DOES_NOT_EXIST
//
// MessageText:
//
// The specified directory partition does not exist.
//
static const long DNS_ERROR_DP_DOES_NOT_EXIST = 9901L;
// DNS_ERROR_DP_ALREADY_EXISTS           0x000026ae
//
// MessageId: DNS_ERROR_DP_ALREADY_EXISTS
//
// MessageText:
//
// The specified directory partition already exists.
//
static const long DNS_ERROR_DP_ALREADY_EXISTS = 9902L;
// DNS_ERROR_DP_NOT_ENLISTED             0x000026af
//
// MessageId: DNS_ERROR_DP_NOT_ENLISTED
//
// MessageText:
//
// This DNS server is not enlisted in the specified directory partition.
//
static const long DNS_ERROR_DP_NOT_ENLISTED = 9903L;
// DNS_ERROR_DP_ALREADY_ENLISTED         0x000026b0
//
// MessageId: DNS_ERROR_DP_ALREADY_ENLISTED
//
// MessageText:
//
// This DNS server is already enlisted in the specified directory partition.
//
static const long DNS_ERROR_DP_ALREADY_ENLISTED = 9904L;
// DNS_ERROR_DP_NOT_AVAILABLE            0x000026b1
//
// MessageId: DNS_ERROR_DP_NOT_AVAILABLE
//
// MessageText:
//
// The directory partition is not available at this time. Please wait a few minutes and try again.
//
static const long DNS_ERROR_DP_NOT_AVAILABLE = 9905L;
// DNS_ERROR_DP_FSMO_ERROR               0x000026b2
//
// MessageId: DNS_ERROR_DP_FSMO_ERROR
//
// MessageText:
//
// The application directory partition operation failed. The domain controller holding the domain naming master role is down or unable to service the request or is not running Windows Server 2003.
//
static const long DNS_ERROR_DP_FSMO_ERROR = 9906L;
///////////////////////////////////////////////////
//                                               //
//             End of DNS Error Codes            //
//                                               //
//                  9000 to 9999                 //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//               WinSock Error Codes             //
//                                               //
//                 10000 to 11999                //
///////////////////////////////////////////////////
//
// WinSock error codes are also defined in WinSock.h
// and WinSock2.h, hence the IFDEF
//
static const int WSABASEERR = 10000;
//
// MessageId: WSAEINTR
//
// MessageText:
//
// A blocking operation was interrupted by a call to WSACancelBlockingCall.
//
static const long WSAEINTR = 10004L;
//
// MessageId: WSAEBADF
//
// MessageText:
//
// The file handle supplied is not valid.
//
static const long WSAEBADF = 10009L;
//
// MessageId: WSAEACCES
//
// MessageText:
//
// An attempt was made to access a socket in a way forbidden by its access permissions.
//
static const long WSAEACCES = 10013L;
//
// MessageId: WSAEFAULT
//
// MessageText:
//
// The system detected an invalid pointer address in attempting to use a pointer argument in a call.
//
static const long WSAEFAULT = 10014L;
//
// MessageId: WSAEINVAL
//
// MessageText:
//
// An invalid argument was supplied.
//
static const long WSAEINVAL = 10022L;
//
// MessageId: WSAEMFILE
//
// MessageText:
//
// Too many open sockets.
//
static const long WSAEMFILE = 10024L;
//
// MessageId: WSAEWOULDBLOCK
//
// MessageText:
//
// A non-blocking socket operation could not be completed immediately.
//
static const long WSAEWOULDBLOCK = 10035L;
//
// MessageId: WSAEINPROGRESS
//
// MessageText:
//
// A blocking operation is currently executing.
//
static const long WSAEINPROGRESS = 10036L;
//
// MessageId: WSAEALREADY
//
// MessageText:
//
// An operation was attempted on a non-blocking socket that already had an operation in progress.
//
static const long WSAEALREADY = 10037L;
//
// MessageId: WSAENOTSOCK
//
// MessageText:
//
// An operation was attempted on something that is not a socket.
//
static const long WSAENOTSOCK = 10038L;
//
// MessageId: WSAEDESTADDRREQ
//
// MessageText:
//
// A required address was omitted from an operation on a socket.
//
static const long WSAEDESTADDRREQ = 10039L;
//
// MessageId: WSAEMSGSIZE
//
// MessageText:
//
// A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself.
//
static const long WSAEMSGSIZE = 10040L;
//
// MessageId: WSAEPROTOTYPE
//
// MessageText:
//
// A protocol was specified in the socket function call that does not support the semantics of the socket type requested.
//
static const long WSAEPROTOTYPE = 10041L;
//
// MessageId: WSAENOPROTOOPT
//
// MessageText:
//
// An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.
//
static const long WSAENOPROTOOPT = 10042L;
//
// MessageId: WSAEPROTONOSUPPORT
//
// MessageText:
//
// The requested protocol has not been configured into the system, or no implementation for it exists.
//
static const long WSAEPROTONOSUPPORT = 10043L;
//
// MessageId: WSAESOCKTNOSUPPORT
//
// MessageText:
//
// The support for the specified socket type does not exist in this address family.
//
static const long WSAESOCKTNOSUPPORT = 10044L;
//
// MessageId: WSAEOPNOTSUPP
//
// MessageText:
//
// The attempted operation is not supported for the type of object referenced.
//
static const long WSAEOPNOTSUPP = 10045L;
//
// MessageId: WSAEPFNOSUPPORT
//
// MessageText:
//
// The protocol family has not been configured into the system or no implementation for it exists.
//
static const long WSAEPFNOSUPPORT = 10046L;
//
// MessageId: WSAEAFNOSUPPORT
//
// MessageText:
//
// An address incompatible with the requested protocol was used.
//
static const long WSAEAFNOSUPPORT = 10047L;
//
// MessageId: WSAEADDRINUSE
//
// MessageText:
//
// Only one usage of each socket address (protocol/network address/port) is normally permitted.
//
static const long WSAEADDRINUSE = 10048L;
//
// MessageId: WSAEADDRNOTAVAIL
//
// MessageText:
//
// The requested address is not valid in its context.
//
static const long WSAEADDRNOTAVAIL = 10049L;
//
// MessageId: WSAENETDOWN
//
// MessageText:
//
// A socket operation encountered a dead network.
//
static const long WSAENETDOWN = 10050L;
//
// MessageId: WSAENETUNREACH
//
// MessageText:
//
// A socket operation was attempted to an unreachable network.
//
static const long WSAENETUNREACH = 10051L;
//
// MessageId: WSAENETRESET
//
// MessageText:
//
// The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.
//
static const long WSAENETRESET = 10052L;
//
// MessageId: WSAECONNABORTED
//
// MessageText:
//
// An established connection was aborted by the software in your host machine.
//
static const long WSAECONNABORTED = 10053L;
//
// MessageId: WSAECONNRESET
//
// MessageText:
//
// An existing connection was forcibly closed by the remote host.
//
static const long WSAECONNRESET = 10054L;
//
// MessageId: WSAENOBUFS
//
// MessageText:
//
// An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.
//
static const long WSAENOBUFS = 10055L;
//
// MessageId: WSAEISCONN
//
// MessageText:
//
// A connect request was made on an already connected socket.
//
static const long WSAEISCONN = 10056L;
//
// MessageId: WSAENOTCONN
//
// MessageText:
//
// A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.
//
static const long WSAENOTCONN = 10057L;
//
// MessageId: WSAESHUTDOWN
//
// MessageText:
//
// A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call.
//
static const long WSAESHUTDOWN = 10058L;
//
// MessageId: WSAETOOMANYREFS
//
// MessageText:
//
// Too many references to some kernel object.
//
static const long WSAETOOMANYREFS = 10059L;
//
// MessageId: WSAETIMEDOUT
//
// MessageText:
//
// A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.
//
static const long WSAETIMEDOUT = 10060L;
//
// MessageId: WSAECONNREFUSED
//
// MessageText:
//
// No connection could be made because the target machine actively refused it.
//
static const long WSAECONNREFUSED = 10061L;
//
// MessageId: WSAELOOP
//
// MessageText:
//
// Cannot translate name.
//
static const long WSAELOOP = 10062L;
//
// MessageId: WSAENAMETOOLONG
//
// MessageText:
//
// Name component or name was too long.
//
static const long WSAENAMETOOLONG = 10063L;
//
// MessageId: WSAEHOSTDOWN
//
// MessageText:
//
// A socket operation failed because the destination host was down.
//
static const long WSAEHOSTDOWN = 10064L;
//
// MessageId: WSAEHOSTUNREACH
//
// MessageText:
//
// A socket operation was attempted to an unreachable host.
//
static const long WSAEHOSTUNREACH = 10065L;
//
// MessageId: WSAENOTEMPTY
//
// MessageText:
//
// Cannot remove a directory that is not empty.
//
static const long WSAENOTEMPTY = 10066L;
//
// MessageId: WSAEPROCLIM
//
// MessageText:
//
// A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.
//
static const long WSAEPROCLIM = 10067L;
//
// MessageId: WSAEUSERS
//
// MessageText:
//
// Ran out of quota.
//
static const long WSAEUSERS = 10068L;
//
// MessageId: WSAEDQUOT
//
// MessageText:
//
// Ran out of disk quota.
//
static const long WSAEDQUOT = 10069L;
//
// MessageId: WSAESTALE
//
// MessageText:
//
// File handle reference is no longer available.
//
static const long WSAESTALE = 10070L;
//
// MessageId: WSAEREMOTE
//
// MessageText:
//
// Item is not available locally.
//
static const long WSAEREMOTE = 10071L;
//
// MessageId: WSASYSNOTREADY
//
// MessageText:
//
// WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.
//
static const long WSASYSNOTREADY = 10091L;
//
// MessageId: WSAVERNOTSUPPORTED
//
// MessageText:
//
// The Windows Sockets version requested is not supported.
//
static const long WSAVERNOTSUPPORTED = 10092L;
//
// MessageId: WSANOTINITIALISED
//
// MessageText:
//
// Either the application has not called WSAStartup, or WSAStartup failed.
//
static const long WSANOTINITIALISED = 10093L;
//
// MessageId: WSAEDISCON
//
// MessageText:
//
// Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence.
//
static const long WSAEDISCON = 10101L;
//
// MessageId: WSAENOMORE
//
// MessageText:
//
// No more results can be returned by WSALookupServiceNext.
//
static const long WSAENOMORE = 10102L;
//
// MessageId: WSAECANCELLED
//
// MessageText:
//
// A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
//
static const long WSAECANCELLED = 10103L;
//
// MessageId: WSAEINVALIDPROCTABLE
//
// MessageText:
//
// The procedure call table is invalid.
//
static const long WSAEINVALIDPROCTABLE = 10104L;
//
// MessageId: WSAEINVALIDPROVIDER
//
// MessageText:
//
// The requested service provider is invalid.
//
static const long WSAEINVALIDPROVIDER = 10105L;
//
// MessageId: WSAEPROVIDERFAILEDINIT
//
// MessageText:
//
// The requested service provider could not be loaded or initialized.
//
static const long WSAEPROVIDERFAILEDINIT = 10106L;
//
// MessageId: WSASYSCALLFAILURE
//
// MessageText:
//
// A system call has failed.
//
static const long WSASYSCALLFAILURE = 10107L;
//
// MessageId: WSASERVICE_NOT_FOUND
//
// MessageText:
//
// No such service is known. The service cannot be found in the specified name space.
//
static const long WSASERVICE_NOT_FOUND = 10108L;
//
// MessageId: WSATYPE_NOT_FOUND
//
// MessageText:
//
// The specified class was not found.
//
static const long WSATYPE_NOT_FOUND = 10109L;
//
// MessageId: WSA_E_NO_MORE
//
// MessageText:
//
// No more results can be returned by WSALookupServiceNext.
//
static const long WSA_E_NO_MORE = 10110L;
//
// MessageId: WSA_E_CANCELLED
//
// MessageText:
//
// A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
//
static const long WSA_E_CANCELLED = 10111L;
//
// MessageId: WSAEREFUSED
//
// MessageText:
//
// A database query failed because it was actively refused.
//
static const long WSAEREFUSED = 10112L;
//
// MessageId: WSAHOST_NOT_FOUND
//
// MessageText:
//
// No such host is known.
//
static const long WSAHOST_NOT_FOUND = 11001L;
//
// MessageId: WSATRY_AGAIN
//
// MessageText:
//
// This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.
//
static const long WSATRY_AGAIN = 11002L;
//
// MessageId: WSANO_RECOVERY
//
// MessageText:
//
// A non-recoverable error occurred during a database lookup.
//
static const long WSANO_RECOVERY = 11003L;
//
// MessageId: WSANO_DATA
//
// MessageText:
//
// The requested name is valid, but no data of the requested type was found.
//
static const long WSANO_DATA = 11004L;
//
// MessageId: WSA_QOS_RECEIVERS
//
// MessageText:
//
// At least one reserve has arrived.
//
static const long WSA_QOS_RECEIVERS = 11005L;
//
// MessageId: WSA_QOS_SENDERS
//
// MessageText:
//
// At least one path has arrived.
//
static const long WSA_QOS_SENDERS = 11006L;
//
// MessageId: WSA_QOS_NO_SENDERS
//
// MessageText:
//
// There are no senders.
//
static const long WSA_QOS_NO_SENDERS = 11007L;
//
// MessageId: WSA_QOS_NO_RECEIVERS
//
// MessageText:
//
// There are no receivers.
//
static const long WSA_QOS_NO_RECEIVERS = 11008L;
//
// MessageId: WSA_QOS_REQUEST_CONFIRMED
//
// MessageText:
//
// Reserve has been confirmed.
//
static const long WSA_QOS_REQUEST_CONFIRMED = 11009L;
//
// MessageId: WSA_QOS_ADMISSION_FAILURE
//
// MessageText:
//
// Error due to lack of resources.
//
static const long WSA_QOS_ADMISSION_FAILURE = 11010L;
//
// MessageId: WSA_QOS_POLICY_FAILURE
//
// MessageText:
//
// Rejected for administrative reasons - bad credentials.
//
static const long WSA_QOS_POLICY_FAILURE = 11011L;
//
// MessageId: WSA_QOS_BAD_STYLE
//
// MessageText:
//
// Unknown or conflicting style.
//
static const long WSA_QOS_BAD_STYLE = 11012L;
//
// MessageId: WSA_QOS_BAD_OBJECT
//
// MessageText:
//
// Problem with some part of the filterspec or providerspecific buffer in general.
//
static const long WSA_QOS_BAD_OBJECT = 11013L;
//
// MessageId: WSA_QOS_TRAFFIC_CTRL_ERROR
//
// MessageText:
//
// Problem with some part of the flowspec.
//
static const long WSA_QOS_TRAFFIC_CTRL_ERROR = 11014L;
//
// MessageId: WSA_QOS_GENERIC_ERROR
//
// MessageText:
//
// General QOS error.
//
static const long WSA_QOS_GENERIC_ERROR = 11015L;
//
// MessageId: WSA_QOS_ESERVICETYPE
//
// MessageText:
//
// An invalid or unrecognized service type was found in the flowspec.
//
static const long WSA_QOS_ESERVICETYPE = 11016L;
//
// MessageId: WSA_QOS_EFLOWSPEC
//
// MessageText:
//
// An invalid or inconsistent flowspec was found in the QOS structure.
//
static const long WSA_QOS_EFLOWSPEC = 11017L;
//
// MessageId: WSA_QOS_EPROVSPECBUF
//
// MessageText:
//
// Invalid QOS provider-specific buffer.
//
static const long WSA_QOS_EPROVSPECBUF = 11018L;
//
// MessageId: WSA_QOS_EFILTERSTYLE
//
// MessageText:
//
// An invalid QOS filter style was used.
//
static const long WSA_QOS_EFILTERSTYLE = 11019L;
//
// MessageId: WSA_QOS_EFILTERTYPE
//
// MessageText:
//
// An invalid QOS filter type was used.
//
static const long WSA_QOS_EFILTERTYPE = 11020L;
//
// MessageId: WSA_QOS_EFILTERCOUNT
//
// MessageText:
//
// An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR.
//
static const long WSA_QOS_EFILTERCOUNT = 11021L;
//
// MessageId: WSA_QOS_EOBJLENGTH
//
// MessageText:
//
// An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer.
//
static const long WSA_QOS_EOBJLENGTH = 11022L;
//
// MessageId: WSA_QOS_EFLOWCOUNT
//
// MessageText:
//
// An incorrect number of flow descriptors was specified in the QOS structure.
//
static const long WSA_QOS_EFLOWCOUNT = 11023L;
//
// MessageId: WSA_QOS_EUNKOWNPSOBJ
//
// MessageText:
//
// An unrecognized object was found in the QOS provider-specific buffer.
//
static const long WSA_QOS_EUNKOWNPSOBJ = 11024L;
//
// MessageId: WSA_QOS_EPOLICYOBJ
//
// MessageText:
//
// An invalid policy object was found in the QOS provider-specific buffer.
//
static const long WSA_QOS_EPOLICYOBJ = 11025L;
//
// MessageId: WSA_QOS_EFLOWDESC
//
// MessageText:
//
// An invalid QOS flow descriptor was found in the flow descriptor list.
//
static const long WSA_QOS_EFLOWDESC = 11026L;
//
// MessageId: WSA_QOS_EPSFLOWSPEC
//
// MessageText:
//
// An invalid or inconsistent flowspec was found in the QOS provider specific buffer.
//
static const long WSA_QOS_EPSFLOWSPEC = 11027L;
//
// MessageId: WSA_QOS_EPSFILTERSPEC
//
// MessageText:
//
// An invalid FILTERSPEC was found in the QOS provider-specific buffer.
//
static const long WSA_QOS_EPSFILTERSPEC = 11028L;
//
// MessageId: WSA_QOS_ESDMODEOBJ
//
// MessageText:
//
// An invalid shape discard mode object was found in the QOS provider specific buffer.
//
static const long WSA_QOS_ESDMODEOBJ = 11029L;
//
// MessageId: WSA_QOS_ESHAPERATEOBJ
//
// MessageText:
//
// An invalid shaping rate object was found in the QOS provider-specific buffer.
//
static const long WSA_QOS_ESHAPERATEOBJ = 11030L;
//
// MessageId: WSA_QOS_RESERVED_PETYPE
//
// MessageText:
//
// A reserved policy element was found in the QOS provider-specific buffer.
//
static const long WSA_QOS_RESERVED_PETYPE = 11031L;
//
// MessageId: WSA_SECURE_HOST_NOT_FOUND
//
// MessageText:
//
// No such host is known securely.
//
static const long WSA_SECURE_HOST_NOT_FOUND = 11032L;
//
// MessageId: WSA_IPSEC_NAME_POLICY_ERROR
//
// MessageText:
//
// Name based IPSEC policy could not be added.
//
static const long WSA_IPSEC_NAME_POLICY_ERROR = 11033L;
///////////////////////////////////////////////////
//                                               //
//           End of WinSock Error Codes          //
//                                               //
//                 10000 to 11999                //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 12000 to 12999                //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//           Start of IPSec Error codes          //
//                                               //
//                 13000 to 13999                //
///////////////////////////////////////////////////
//
// MessageId: ERROR_IPSEC_QM_POLICY_EXISTS
//
// MessageText:
//
// The specified quick mode policy already exists.
//
static const long ERROR_IPSEC_QM_POLICY_EXISTS = 13000L;
//
// MessageId: ERROR_IPSEC_QM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified quick mode policy was not found.
//
static const long ERROR_IPSEC_QM_POLICY_NOT_FOUND = 13001L;
//
// MessageId: ERROR_IPSEC_QM_POLICY_IN_USE
//
// MessageText:
//
// The specified quick mode policy is being used.
//
static const long ERROR_IPSEC_QM_POLICY_IN_USE = 13002L;
//
// MessageId: ERROR_IPSEC_MM_POLICY_EXISTS
//
// MessageText:
//
// The specified main mode policy already exists.
//
static const long ERROR_IPSEC_MM_POLICY_EXISTS = 13003L;
//
// MessageId: ERROR_IPSEC_MM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified main mode policy was not found
//
static const long ERROR_IPSEC_MM_POLICY_NOT_FOUND = 13004L;
//
// MessageId: ERROR_IPSEC_MM_POLICY_IN_USE
//
// MessageText:
//
// The specified main mode policy is being used.
//
static const long ERROR_IPSEC_MM_POLICY_IN_USE = 13005L;
//
// MessageId: ERROR_IPSEC_MM_FILTER_EXISTS
//
// MessageText:
//
// The specified main mode filter already exists.
//
static const long ERROR_IPSEC_MM_FILTER_EXISTS = 13006L;
//
// MessageId: ERROR_IPSEC_MM_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified main mode filter was not found.
//
static const long ERROR_IPSEC_MM_FILTER_NOT_FOUND = 13007L;
//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_EXISTS
//
// MessageText:
//
// The specified transport mode filter already exists.
//
static const long ERROR_IPSEC_TRANSPORT_FILTER_EXISTS = 13008L;
//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified transport mode filter does not exist.
//
static const long ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = 13009L;
//
// MessageId: ERROR_IPSEC_MM_AUTH_EXISTS
//
// MessageText:
//
// The specified main mode authentication list exists.
//
static const long ERROR_IPSEC_MM_AUTH_EXISTS = 13010L;
//
// MessageId: ERROR_IPSEC_MM_AUTH_NOT_FOUND
//
// MessageText:
//
// The specified main mode authentication list was not found.
//
static const long ERROR_IPSEC_MM_AUTH_NOT_FOUND = 13011L;
//
// MessageId: ERROR_IPSEC_MM_AUTH_IN_USE
//
// MessageText:
//
// The specified main mode authentication list is being used.
//
static const long ERROR_IPSEC_MM_AUTH_IN_USE = 13012L;
//
// MessageId: ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified default main mode policy was not found.
//
static const long ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = 13013L;
//
// MessageId: ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND
//
// MessageText:
//
// The specified default main mode authentication list was not found.
//
static const long ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND = 13014L;
//
// MessageId: ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified default quick mode policy was not found.
//
static const long ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = 13015L;
//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_EXISTS
//
// MessageText:
//
// The specified tunnel mode filter exists.
//
static const long ERROR_IPSEC_TUNNEL_FILTER_EXISTS = 13016L;
//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified tunnel mode filter was not found.
//
static const long ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = 13017L;
//
// MessageId: ERROR_IPSEC_MM_FILTER_PENDING_DELETION
//
// MessageText:
//
// The Main Mode filter is pending deletion.
//
static const long ERROR_IPSEC_MM_FILTER_PENDING_DELETION = 13018L;
//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION
//
// MessageText:
//
// The transport filter is pending deletion.
//
static const long ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = 13019L;
//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION
//
// MessageText:
//
// The tunnel filter is pending deletion.
//
static const long ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION = 13020L;
//
// MessageId: ERROR_IPSEC_MM_POLICY_PENDING_DELETION
//
// MessageText:
//
// The Main Mode policy is pending deletion.
//
static const long ERROR_IPSEC_MM_POLICY_PENDING_DELETION = 13021L;
//
// MessageId: ERROR_IPSEC_MM_AUTH_PENDING_DELETION
//
// MessageText:
//
// The Main Mode authentication bundle is pending deletion.
//
static const long ERROR_IPSEC_MM_AUTH_PENDING_DELETION = 13022L;
//
// MessageId: ERROR_IPSEC_QM_POLICY_PENDING_DELETION
//
// MessageText:
//
// The Quick Mode policy is pending deletion.
//
static const long ERROR_IPSEC_QM_POLICY_PENDING_DELETION = 13023L;
//
// MessageId: WARNING_IPSEC_MM_POLICY_PRUNED
//
// MessageText:
//
// The Main Mode policy was successfully added, but some of the requested offers are not supported.
//
static const long WARNING_IPSEC_MM_POLICY_PRUNED = 13024L;
//
// MessageId: WARNING_IPSEC_QM_POLICY_PRUNED
//
// MessageText:
//
// The Quick Mode policy was successfully added, but some of the requested offers are not supported.
//
static const long WARNING_IPSEC_QM_POLICY_PRUNED = 13025L;
//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_BEGIN
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_BEGIN
//
static const long ERROR_IPSEC_IKE_NEG_STATUS_BEGIN = 13800L;
//
// MessageId: ERROR_IPSEC_IKE_AUTH_FAIL
//
// MessageText:
//
// IKE authentication credentials are unacceptable
//
static const long ERROR_IPSEC_IKE_AUTH_FAIL = 13801L;
//
// MessageId: ERROR_IPSEC_IKE_ATTRIB_FAIL
//
// MessageText:
//
// IKE security attributes are unacceptable
//
static const long ERROR_IPSEC_IKE_ATTRIB_FAIL = 13802L;
//
// MessageId: ERROR_IPSEC_IKE_NEGOTIATION_PENDING
//
// MessageText:
//
// IKE Negotiation in progress
//
static const long ERROR_IPSEC_IKE_NEGOTIATION_PENDING = 13803L;
//
// MessageId: ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR
//
// MessageText:
//
// General processing error
//
static const long ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = 13804L;
//
// MessageId: ERROR_IPSEC_IKE_TIMED_OUT
//
// MessageText:
//
// Negotiation timed out
//
static const long ERROR_IPSEC_IKE_TIMED_OUT = 13805L;
//
// MessageId: ERROR_IPSEC_IKE_NO_CERT
//
// MessageText:
//
// IKE failed to find valid machine certificate. Contact your Network Security Administrator about installing a valid certificate in the appropriate Certificate Store.
//
static const long ERROR_IPSEC_IKE_NO_CERT = 13806L;
//
// MessageId: ERROR_IPSEC_IKE_SA_DELETED
//
// MessageText:
//
// IKE SA deleted by peer before establishment completed
//
static const long ERROR_IPSEC_IKE_SA_DELETED = 13807L;
//
// MessageId: ERROR_IPSEC_IKE_SA_REAPED
//
// MessageText:
//
// IKE SA deleted before establishment completed
//
static const long ERROR_IPSEC_IKE_SA_REAPED = 13808L;
//
// MessageId: ERROR_IPSEC_IKE_MM_ACQUIRE_DROP
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
static const long ERROR_IPSEC_IKE_MM_ACQUIRE_DROP = 13809L;
//
// MessageId: ERROR_IPSEC_IKE_QM_ACQUIRE_DROP
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
static const long ERROR_IPSEC_IKE_QM_ACQUIRE_DROP = 13810L;
//
// MessageId: ERROR_IPSEC_IKE_QUEUE_DROP_MM
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
static const long ERROR_IPSEC_IKE_QUEUE_DROP_MM = 13811L;
//
// MessageId: ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
static const long ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM = 13812L;
//
// MessageId: ERROR_IPSEC_IKE_DROP_NO_RESPONSE
//
// MessageText:
//
// No response from peer
//
static const long ERROR_IPSEC_IKE_DROP_NO_RESPONSE = 13813L;
//
// MessageId: ERROR_IPSEC_IKE_MM_DELAY_DROP
//
// MessageText:
//
// Negotiation took too long
//
static const long ERROR_IPSEC_IKE_MM_DELAY_DROP = 13814L;
//
// MessageId: ERROR_IPSEC_IKE_QM_DELAY_DROP
//
// MessageText:
//
// Negotiation took too long
//
static const long ERROR_IPSEC_IKE_QM_DELAY_DROP = 13815L;
//
// MessageId: ERROR_IPSEC_IKE_ERROR
//
// MessageText:
//
// Unknown error occurred
//
static const long ERROR_IPSEC_IKE_ERROR = 13816L;
//
// MessageId: ERROR_IPSEC_IKE_CRL_FAILED
//
// MessageText:
//
// Certificate Revocation Check failed
//
static const long ERROR_IPSEC_IKE_CRL_FAILED = 13817L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_KEY_USAGE
//
// MessageText:
//
// Invalid certificate key usage
//
static const long ERROR_IPSEC_IKE_INVALID_KEY_USAGE = 13818L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_CERT_TYPE
//
// MessageText:
//
// Invalid certificate type
//
static const long ERROR_IPSEC_IKE_INVALID_CERT_TYPE = 13819L;
//
// MessageId: ERROR_IPSEC_IKE_NO_PRIVATE_KEY
//
// MessageText:
//
// IKE negotiation failed because the machine certificate used does not have a private key. IPsec certificates require a private key. Contact your Network Security administrator about replacing with a certificate that has a private key.
//
static const long ERROR_IPSEC_IKE_NO_PRIVATE_KEY = 13820L;
//
// MessageId: ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY
//
// MessageText:
//
// Simultaneous rekeys were detected.
//
static const long ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY = 13821L;
//
// MessageId: ERROR_IPSEC_IKE_DH_FAIL
//
// MessageText:
//
// Failure in Diffie-Hellman computation
//
static const long ERROR_IPSEC_IKE_DH_FAIL = 13822L;
//
// MessageId: ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED
//
// MessageText:
//
// Don't know how to process critical payload
//
static const long ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = 13823L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_HEADER
//
// MessageText:
//
// Invalid header
//
static const long ERROR_IPSEC_IKE_INVALID_HEADER = 13824L;
//
// MessageId: ERROR_IPSEC_IKE_NO_POLICY
//
// MessageText:
//
// No policy configured
//
static const long ERROR_IPSEC_IKE_NO_POLICY = 13825L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_SIGNATURE
//
// MessageText:
//
// Failed to verify signature
//
static const long ERROR_IPSEC_IKE_INVALID_SIGNATURE = 13826L;
//
// MessageId: ERROR_IPSEC_IKE_KERBEROS_ERROR
//
// MessageText:
//
// Failed to authenticate using Kerberos
//
static const long ERROR_IPSEC_IKE_KERBEROS_ERROR = 13827L;
//
// MessageId: ERROR_IPSEC_IKE_NO_PUBLIC_KEY
//
// MessageText:
//
// Peer's certificate did not have a public key
//
static const long ERROR_IPSEC_IKE_NO_PUBLIC_KEY = 13828L;
// These must stay as a unit.
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR
//
// MessageText:
//
// Error processing error payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR = 13829L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_SA
//
// MessageText:
//
// Error processing SA payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_SA = 13830L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_PROP
//
// MessageText:
//
// Error processing Proposal payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_PROP = 13831L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_TRANS
//
// MessageText:
//
// Error processing Transform payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_TRANS = 13832L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_KE
//
// MessageText:
//
// Error processing KE payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_KE = 13833L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_ID
//
// MessageText:
//
// Error processing ID payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_ID = 13834L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_CERT
//
// MessageText:
//
// Error processing Cert payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_CERT = 13835L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ
//
// MessageText:
//
// Error processing Certificate Request payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ = 13836L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_HASH
//
// MessageText:
//
// Error processing Hash payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_HASH = 13837L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_SIG
//
// MessageText:
//
// Error processing Signature payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_SIG = 13838L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NONCE
//
// MessageText:
//
// Error processing Nonce payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_NONCE = 13839L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY
//
// MessageText:
//
// Error processing Notify payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY = 13840L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_DELETE
//
// MessageText:
//
// Error processing Delete Payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_DELETE = 13841L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR
//
// MessageText:
//
// Error processing VendorId payload
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR = 13842L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_PAYLOAD
//
// MessageText:
//
// Invalid payload received
//
static const long ERROR_IPSEC_IKE_INVALID_PAYLOAD = 13843L;
//
// MessageId: ERROR_IPSEC_IKE_LOAD_SOFT_SA
//
// MessageText:
//
// Soft SA loaded
//
static const long ERROR_IPSEC_IKE_LOAD_SOFT_SA = 13844L;
//
// MessageId: ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN
//
// MessageText:
//
// Soft SA torn down
//
static const long ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN = 13845L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_COOKIE
//
// MessageText:
//
// Invalid cookie received.
//
static const long ERROR_IPSEC_IKE_INVALID_COOKIE = 13846L;
//
// MessageId: ERROR_IPSEC_IKE_NO_PEER_CERT
//
// MessageText:
//
// Peer failed to send valid machine certificate
//
static const long ERROR_IPSEC_IKE_NO_PEER_CERT = 13847L;
//
// MessageId: ERROR_IPSEC_IKE_PEER_CRL_FAILED
//
// MessageText:
//
// Certification Revocation check of peer's certificate failed
//
static const long ERROR_IPSEC_IKE_PEER_CRL_FAILED = 13848L;
//
// MessageId: ERROR_IPSEC_IKE_POLICY_CHANGE
//
// MessageText:
//
// New policy invalidated SAs formed with old policy
//
static const long ERROR_IPSEC_IKE_POLICY_CHANGE = 13849L;
//
// MessageId: ERROR_IPSEC_IKE_NO_MM_POLICY
//
// MessageText:
//
// There is no available Main Mode IKE policy.
//
static const long ERROR_IPSEC_IKE_NO_MM_POLICY = 13850L;
//
// MessageId: ERROR_IPSEC_IKE_NOTCBPRIV
//
// MessageText:
//
// Failed to enabled TCB privilege.
//
static const long ERROR_IPSEC_IKE_NOTCBPRIV = 13851L;
//
// MessageId: ERROR_IPSEC_IKE_SECLOADFAIL
//
// MessageText:
//
// Failed to load SECURITY.DLL.
//
static const long ERROR_IPSEC_IKE_SECLOADFAIL = 13852L;
//
// MessageId: ERROR_IPSEC_IKE_FAILSSPINIT
//
// MessageText:
//
// Failed to obtain security function table dispatch address from SSPI.
//
static const long ERROR_IPSEC_IKE_FAILSSPINIT = 13853L;
//
// MessageId: ERROR_IPSEC_IKE_FAILQUERYSSP
//
// MessageText:
//
// Failed to query Kerberos package to obtain max token size.
//
static const long ERROR_IPSEC_IKE_FAILQUERYSSP = 13854L;
//
// MessageId: ERROR_IPSEC_IKE_SRVACQFAIL
//
// MessageText:
//
// Failed to obtain Kerberos server credentials for ISAKMP/ERROR_IPSEC_IKE service. Kerberos authentication will not function. The most likely reason for this is lack of domain membership. This is normal if your computer is a member of a workgroup.
//
static const long ERROR_IPSEC_IKE_SRVACQFAIL = 13855L;
//
// MessageId: ERROR_IPSEC_IKE_SRVQUERYCRED
//
// MessageText:
//
// Failed to determine SSPI principal name for ISAKMP/ERROR_IPSEC_IKE service (QueryCredentialsAttributes).
//
static const long ERROR_IPSEC_IKE_SRVQUERYCRED = 13856L;
//
// MessageId: ERROR_IPSEC_IKE_GETSPIFAIL
//
// MessageText:
//
// Failed to obtain new SPI for the inbound SA from Ipsec driver. The most common cause for this is that the driver does not have the correct filter. Check your policy to verify the filters.
//
static const long ERROR_IPSEC_IKE_GETSPIFAIL = 13857L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_FILTER
//
// MessageText:
//
// Given filter is invalid
//
static const long ERROR_IPSEC_IKE_INVALID_FILTER = 13858L;
//
// MessageId: ERROR_IPSEC_IKE_OUT_OF_MEMORY
//
// MessageText:
//
// Memory allocation failed.
//
static const long ERROR_IPSEC_IKE_OUT_OF_MEMORY = 13859L;
//
// MessageId: ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED
//
// MessageText:
//
// Failed to add Security Association to IPSec Driver. The most common cause for this is if the IKE negotiation took too long to complete. If the problem persists, reduce the load on the faulting machine.
//
static const long ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED = 13860L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_POLICY
//
// MessageText:
//
// Invalid policy
//
static const long ERROR_IPSEC_IKE_INVALID_POLICY = 13861L;
//
// MessageId: ERROR_IPSEC_IKE_UNKNOWN_DOI
//
// MessageText:
//
// Invalid DOI
//
static const long ERROR_IPSEC_IKE_UNKNOWN_DOI = 13862L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_SITUATION
//
// MessageText:
//
// Invalid situation
//
static const long ERROR_IPSEC_IKE_INVALID_SITUATION = 13863L;
//
// MessageId: ERROR_IPSEC_IKE_DH_FAILURE
//
// MessageText:
//
// Diffie-Hellman failure
//
static const long ERROR_IPSEC_IKE_DH_FAILURE = 13864L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_GROUP
//
// MessageText:
//
// Invalid Diffie-Hellman group
//
static const long ERROR_IPSEC_IKE_INVALID_GROUP = 13865L;
//
// MessageId: ERROR_IPSEC_IKE_ENCRYPT
//
// MessageText:
//
// Error encrypting payload
//
static const long ERROR_IPSEC_IKE_ENCRYPT = 13866L;
//
// MessageId: ERROR_IPSEC_IKE_DECRYPT
//
// MessageText:
//
// Error decrypting payload
//
static const long ERROR_IPSEC_IKE_DECRYPT = 13867L;
//
// MessageId: ERROR_IPSEC_IKE_POLICY_MATCH
//
// MessageText:
//
// Policy match error
//
static const long ERROR_IPSEC_IKE_POLICY_MATCH = 13868L;
//
// MessageId: ERROR_IPSEC_IKE_UNSUPPORTED_ID
//
// MessageText:
//
// Unsupported ID
//
static const long ERROR_IPSEC_IKE_UNSUPPORTED_ID = 13869L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH
//
// MessageText:
//
// Hash verification failed
//
static const long ERROR_IPSEC_IKE_INVALID_HASH = 13870L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH_ALG
//
// MessageText:
//
// Invalid hash algorithm
//
static const long ERROR_IPSEC_IKE_INVALID_HASH_ALG = 13871L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH_SIZE
//
// MessageText:
//
// Invalid hash size
//
static const long ERROR_IPSEC_IKE_INVALID_HASH_SIZE = 13872L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG
//
// MessageText:
//
// Invalid encryption algorithm
//
static const long ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG = 13873L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_AUTH_ALG
//
// MessageText:
//
// Invalid authentication algorithm
//
static const long ERROR_IPSEC_IKE_INVALID_AUTH_ALG = 13874L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_SIG
//
// MessageText:
//
// Invalid certificate signature
//
static const long ERROR_IPSEC_IKE_INVALID_SIG = 13875L;
//
// MessageId: ERROR_IPSEC_IKE_LOAD_FAILED
//
// MessageText:
//
// Load failed
//
static const long ERROR_IPSEC_IKE_LOAD_FAILED = 13876L;
//
// MessageId: ERROR_IPSEC_IKE_RPC_DELETE
//
// MessageText:
//
// Deleted via RPC call
//
static const long ERROR_IPSEC_IKE_RPC_DELETE = 13877L;
//
// MessageId: ERROR_IPSEC_IKE_BENIGN_REINIT
//
// MessageText:
//
// Temporary state created to perform reinit. This is not a real failure.
//
static const long ERROR_IPSEC_IKE_BENIGN_REINIT = 13878L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY
//
// MessageText:
//
// The lifetime value received in the Responder Lifetime Notify is below the Windows 2000 configured minimum value. Please fix the policy on the peer machine.
//
static const long ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = 13879L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION
//
// MessageText:
//
// The recipient cannot handle version of IKE specified in the header.
//
static const long ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION = 13880L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN
//
// MessageText:
//
// Key length in certificate is too small for configured security requirements.
//
static const long ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN = 13881L;
//
// MessageId: ERROR_IPSEC_IKE_MM_LIMIT
//
// MessageText:
//
// Max number of established MM SAs to peer exceeded.
//
static const long ERROR_IPSEC_IKE_MM_LIMIT = 13882L;
//
// MessageId: ERROR_IPSEC_IKE_NEGOTIATION_DISABLED
//
// MessageText:
//
// IKE received a policy that disables negotiation.
//
static const long ERROR_IPSEC_IKE_NEGOTIATION_DISABLED = 13883L;
//
// MessageId: ERROR_IPSEC_IKE_QM_LIMIT
//
// MessageText:
//
// Reached maximum quick mode limit for the main mode. New main mode will be started.
//
static const long ERROR_IPSEC_IKE_QM_LIMIT = 13884L;
//
// MessageId: ERROR_IPSEC_IKE_MM_EXPIRED
//
// MessageText:
//
// Main mode SA lifetime expired or peer sent a main mode delete.
//
static const long ERROR_IPSEC_IKE_MM_EXPIRED = 13885L;
//
// MessageId: ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID
//
// MessageText:
//
// Main mode SA assumed to be invalid because peer stopped responding.
//
static const long ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID = 13886L;
//
// MessageId: ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH
//
// MessageText:
//
// Certificate doesn't chain to a trusted root in IPsec policy.
//
static const long ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH = 13887L;
//
// MessageId: ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID
//
// MessageText:
//
// Received unexpected message ID.
//
static const long ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID = 13888L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD
//
// MessageText:
//
// Received invalid authentication offers.
//
static const long ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD = 13889L;
//
// MessageId: ERROR_IPSEC_IKE_DOS_COOKIE_SENT
//
// MessageText:
//
// Sent DoS cookie notify to initiator.
//
static const long ERROR_IPSEC_IKE_DOS_COOKIE_SENT = 13890L;
//
// MessageId: ERROR_IPSEC_IKE_SHUTTING_DOWN
//
// MessageText:
//
// IKE service is shutting down.
//
static const long ERROR_IPSEC_IKE_SHUTTING_DOWN = 13891L;
//
// MessageId: ERROR_IPSEC_IKE_CGA_AUTH_FAILED
//
// MessageText:
//
// Could not verify binding between CGA address and certificate.
//
static const long ERROR_IPSEC_IKE_CGA_AUTH_FAILED = 13892L;
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NATOA
//
// MessageText:
//
// Error processing NatOA payload.
//
static const long ERROR_IPSEC_IKE_PROCESS_ERR_NATOA = 13893L;
//
// MessageId: ERROR_IPSEC_IKE_INVALID_MM_FOR_QM
//
// MessageText:
//
// Parameters of the main mode are invalid for this quick mode.
//
static const long ERROR_IPSEC_IKE_INVALID_MM_FOR_QM = 13894L;
//
// MessageId: ERROR_IPSEC_IKE_QM_EXPIRED
//
// MessageText:
//
// Quick mode SA was expired by IPsec driver.
//
static const long ERROR_IPSEC_IKE_QM_EXPIRED = 13895L;
//
// MessageId: ERROR_IPSEC_IKE_TOO_MANY_FILTERS
//
// MessageText:
//
// Too many dynamically added IKEEXT filters were detected.
//
static const long ERROR_IPSEC_IKE_TOO_MANY_FILTERS = 13896L;
// Do NOT change this final value.  It is used in a public API structure
//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_END
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_END
//
static const long ERROR_IPSEC_IKE_NEG_STATUS_END = 13897L;
//
// MessageId: ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL
//
// MessageText:
//
// NAP reauth succeeded and must delete the dummy NAP IkeV2 tunnel.
//
static const long ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL = 13898L;
//
// MessageId: ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE
//
// MessageText:
//
// Error in assigning inner IP address to intiator in tunnel mode.
//
static const long ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = 13899L;
//
// MessageId: ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING
//
// MessageText:
//
// Require configuration payload missing.
//
static const long ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING = 13900L;
//
// MessageId: ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING
//
// MessageText:
//
// A negotiation running as the security principle who issued the connection is in progress
//
static const long ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = 13901L;
//
// MessageId: ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS
//
// MessageText:
//
// SA was deleted due to IKEv1/AuthIP co-existence suppress check.
//
static const long ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS = 13902L;
//
// MessageId: ERROR_IPSEC_IKE_RATELIMIT_DROP
//
// MessageText:
//
// Incoming SA request was dropped due to peer IP address rate limiting.
//
static const long ERROR_IPSEC_IKE_RATELIMIT_DROP = 13903L;
//
// MessageId: ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE
//
// MessageText:
//
// Peer does not support MOBIKE.
//
static const long ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = 13904L;
//
// MessageId: ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE
//
// MessageText:
//
// SA establishment is not authorized.
//
static const long ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE = 13905L;
//
// MessageId: ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE
//
// MessageText:
//
// SA establishment is not authorized because there is not a sufficiently strong PKINIT-based credential.
//
static const long ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE = 13906L;
//
// MessageId: ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY
//
// MessageText:
//
// SA establishment is not authorized.  You may need to enter updated or different credentials such as a smartcard.
//
static const long ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY = 13907L;
//
// MessageId: ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE
//
// MessageText:
//
// SA establishment is not authorized because there is not a sufficiently strong PKINIT-based credential. This might be related to certificate-to-account mapping failure for the SA.
//
static const long ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE = 13908L;
// Extended upper bound for IKE errors to accomodate new errors
//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END
//
static const long ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END = 13909L;
//
// Following error codes are returned by IPsec kernel.
//
//
// MessageId: ERROR_IPSEC_BAD_SPI
//
// MessageText:
//
// The SPI in the packet does not match a valid IPsec SA.
//
static const long ERROR_IPSEC_BAD_SPI = 13910L;
//
// MessageId: ERROR_IPSEC_SA_LIFETIME_EXPIRED
//
// MessageText:
//
// Packet was received on an IPsec SA whose lifetime has expired.
//
static const long ERROR_IPSEC_SA_LIFETIME_EXPIRED = 13911L;
//
// MessageId: ERROR_IPSEC_WRONG_SA
//
// MessageText:
//
// Packet was received on an IPsec SA that does not match the packet characteristics.
//
static const long ERROR_IPSEC_WRONG_SA = 13912L;
//
// MessageId: ERROR_IPSEC_REPLAY_CHECK_FAILED
//
// MessageText:
//
// Packet sequence number replay check failed.
//
static const long ERROR_IPSEC_REPLAY_CHECK_FAILED = 13913L;
//
// MessageId: ERROR_IPSEC_INVALID_PACKET
//
// MessageText:
//
// IPsec header and/or trailer in the packet is invalid.
//
static const long ERROR_IPSEC_INVALID_PACKET = 13914L;
//
// MessageId: ERROR_IPSEC_INTEGRITY_CHECK_FAILED
//
// MessageText:
//
// IPsec integrity check failed.
//
static const long ERROR_IPSEC_INTEGRITY_CHECK_FAILED = 13915L;
//
// MessageId: ERROR_IPSEC_CLEAR_TEXT_DROP
//
// MessageText:
//
// IPsec dropped a clear text packet.
//
static const long ERROR_IPSEC_CLEAR_TEXT_DROP = 13916L;
//
// MessageId: ERROR_IPSEC_AUTH_FIREWALL_DROP
//
// MessageText:
//
// IPsec dropped an incoming ESP packet in authenticated firewall mode. This drop is benign.
//
static const long ERROR_IPSEC_AUTH_FIREWALL_DROP = 13917L;
//
// MessageId: ERROR_IPSEC_THROTTLE_DROP
//
// MessageText:
//
// IPsec dropped a packet due to DoS throttling.
//
static const long ERROR_IPSEC_THROTTLE_DROP = 13918L;
//
// MessageId: ERROR_IPSEC_DOSP_BLOCK
//
// MessageText:
//
// IPsec DoS Protection matched an explicit block rule.
//
static const long ERROR_IPSEC_DOSP_BLOCK = 13925L;
//
// MessageId: ERROR_IPSEC_DOSP_RECEIVED_MULTICAST
//
// MessageText:
//
// IPsec DoS Protection received an IPsec specific multicast packet which is not allowed.
//
static const long ERROR_IPSEC_DOSP_RECEIVED_MULTICAST = 13926L;
//
// MessageId: ERROR_IPSEC_DOSP_INVALID_PACKET
//
// MessageText:
//
// IPsec DoS Protection received an incorrectly formatted packet.
//
static const long ERROR_IPSEC_DOSP_INVALID_PACKET = 13927L;
//
// MessageId: ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED
//
// MessageText:
//
// IPsec DoS Protection failed to look up state.
//
static const long ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED = 13928L;
//
// MessageId: ERROR_IPSEC_DOSP_MAX_ENTRIES
//
// MessageText:
//
// IPsec DoS Protection failed to create state because the maximum number of entries allowed by policy has been reached.
//
static const long ERROR_IPSEC_DOSP_MAX_ENTRIES = 13929L;
//
// MessageId: ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED
//
// MessageText:
//
// IPsec DoS Protection received an IPsec negotiation packet for a keying module which is not allowed by policy.
//
static const long ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 13930L;
//
// MessageId: ERROR_IPSEC_DOSP_NOT_INSTALLED
//
// MessageText:
//
// IPsec DoS Protection has not been enabled.
//
static const long ERROR_IPSEC_DOSP_NOT_INSTALLED = 13931L;
//
// MessageId: ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES
//
// MessageText:
//
// IPsec DoS Protection failed to create a per internal IP rate limit queue because the maximum number of queues allowed by policy has been reached.
//
static const long ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 13932L;
///////////////////////////////////////////////////
//                                               //
//           End of IPSec Error codes            //
//                                               //
//                 13000 to 13999                //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//         Start of Side By Side Error Codes     //
//                                               //
//                 14000 to 14999                //
///////////////////////////////////////////////////
//
// MessageId: ERROR_SXS_SECTION_NOT_FOUND
//
// MessageText:
//
// The requested section was not present in the activation context.
//
static const long ERROR_SXS_SECTION_NOT_FOUND = 14000L;
//
// MessageId: ERROR_SXS_CANT_GEN_ACTCTX
//
// MessageText:
//
// The application has failed to start because its side-by-side configuration is incorrect. Please see the application event log or use the command-line sxstrace.exe tool for more detail.
//
static const long ERROR_SXS_CANT_GEN_ACTCTX = 14001L;
//
// MessageId: ERROR_SXS_INVALID_ACTCTXDATA_FORMAT
//
// MessageText:
//
// The application binding data format is invalid.
//
static const long ERROR_SXS_INVALID_ACTCTXDATA_FORMAT = 14002L;
//
// MessageId: ERROR_SXS_ASSEMBLY_NOT_FOUND
//
// MessageText:
//
// The referenced assembly is not installed on your system.
//
static const long ERROR_SXS_ASSEMBLY_NOT_FOUND = 14003L;
//
// MessageId: ERROR_SXS_MANIFEST_FORMAT_ERROR
//
// MessageText:
//
// The manifest file does not begin with the required tag and format information.
//
static const long ERROR_SXS_MANIFEST_FORMAT_ERROR = 14004L;
//
// MessageId: ERROR_SXS_MANIFEST_PARSE_ERROR
//
// MessageText:
//
// The manifest file contains one or more syntax errors.
//
static const long ERROR_SXS_MANIFEST_PARSE_ERROR = 14005L;
//
// MessageId: ERROR_SXS_ACTIVATION_CONTEXT_DISABLED
//
// MessageText:
//
// The application attempted to activate a disabled activation context.
//
static const long ERROR_SXS_ACTIVATION_CONTEXT_DISABLED = 14006L;
//
// MessageId: ERROR_SXS_KEY_NOT_FOUND
//
// MessageText:
//
// The requested lookup key was not found in any active activation context.
//
static const long ERROR_SXS_KEY_NOT_FOUND = 14007L;
//
// MessageId: ERROR_SXS_VERSION_CONFLICT
//
// MessageText:
//
// A component version required by the application conflicts with another component version already active.
//
static const long ERROR_SXS_VERSION_CONFLICT = 14008L;
//
// MessageId: ERROR_SXS_WRONG_SECTION_TYPE
//
// MessageText:
//
// The type requested activation context section does not match the query API used.
//
static const long ERROR_SXS_WRONG_SECTION_TYPE = 14009L;
//
// MessageId: ERROR_SXS_THREAD_QUERIES_DISABLED
//
// MessageText:
//
// Lack of system resources has required isolated activation to be disabled for the current thread of execution.
//
static const long ERROR_SXS_THREAD_QUERIES_DISABLED = 14010L;
//
// MessageId: ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET
//
// MessageText:
//
// An attempt to set the process default activation context failed because the process default activation context was already set.
//
static const long ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET = 14011L;
//
// MessageId: ERROR_SXS_UNKNOWN_ENCODING_GROUP
//
// MessageText:
//
// The encoding group identifier specified is not recognized.
//
static const long ERROR_SXS_UNKNOWN_ENCODING_GROUP = 14012L;
//
// MessageId: ERROR_SXS_UNKNOWN_ENCODING
//
// MessageText:
//
// The encoding requested is not recognized.
//
static const long ERROR_SXS_UNKNOWN_ENCODING = 14013L;
//
// MessageId: ERROR_SXS_INVALID_XML_NAMESPACE_URI
//
// MessageText:
//
// The manifest contains a reference to an invalid URI.
//
static const long ERROR_SXS_INVALID_XML_NAMESPACE_URI = 14014L;
//
// MessageId: ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED
//
// MessageText:
//
// The application manifest contains a reference to a dependent assembly which is not installed
//
static const long ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14015L;
//
// MessageId: ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED
//
// MessageText:
//
// The manifest for an assembly used by the application has a reference to a dependent assembly which is not installed
//
static const long ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14016L;
//
// MessageId: ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE
//
// MessageText:
//
// The manifest contains an attribute for the assembly identity which is not valid.
//
static const long ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = 14017L;
//
// MessageId: ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE
//
// MessageText:
//
// The manifest is missing the required default namespace specification on the assembly element.
//
static const long ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE = 14018L;
//
// MessageId: ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE
//
// MessageText:
//
// The manifest has a default namespace specified on the assembly element but its value is not "urn:schemas-microsoft-com:asm.v1".
//
static const long ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = 14019L;
//
// MessageId: ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT
//
// MessageText:
//
// The private manifest probed has crossed a path with an unsupported reparse point.
//
static const long ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT = 14020L;
//
// MessageId: ERROR_SXS_DUPLICATE_DLL_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have files by the same name.
//
static const long ERROR_SXS_DUPLICATE_DLL_NAME = 14021L;
//
// MessageId: ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have window classes with the same name.
//
static const long ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = 14022L;
//
// MessageId: ERROR_SXS_DUPLICATE_CLSID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM server CLSIDs.
//
static const long ERROR_SXS_DUPLICATE_CLSID = 14023L;
//
// MessageId: ERROR_SXS_DUPLICATE_IID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have proxies for the same COM interface IIDs.
//
static const long ERROR_SXS_DUPLICATE_IID = 14024L;
//
// MessageId: ERROR_SXS_DUPLICATE_TLBID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM type library TLBIDs.
//
static const long ERROR_SXS_DUPLICATE_TLBID = 14025L;
//
// MessageId: ERROR_SXS_DUPLICATE_PROGID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM ProgIDs.
//
static const long ERROR_SXS_DUPLICATE_PROGID = 14026L;
//
// MessageId: ERROR_SXS_DUPLICATE_ASSEMBLY_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest are different versions of the same component which is not permitted.
//
static const long ERROR_SXS_DUPLICATE_ASSEMBLY_NAME = 14027L;
//
// MessageId: ERROR_SXS_FILE_HASH_MISMATCH
//
// MessageText:
//
// A component's file does not match the verification information present in the component manifest.
//
static const long ERROR_SXS_FILE_HASH_MISMATCH = 14028L;
//
// MessageId: ERROR_SXS_POLICY_PARSE_ERROR
//
// MessageText:
//
// The policy manifest contains one or more syntax errors.
//
static const long ERROR_SXS_POLICY_PARSE_ERROR = 14029L;
//
// MessageId: ERROR_SXS_XML_E_MISSINGQUOTE
//
// MessageText:
//
// Manifest Parse Error : A string literal was expected, but no opening quote character was found.
//
static const long ERROR_SXS_XML_E_MISSINGQUOTE = 14030L;
//
// MessageId: ERROR_SXS_XML_E_COMMENTSYNTAX
//
// MessageText:
//
// Manifest Parse Error : Incorrect syntax was used in a comment.
//
static const long ERROR_SXS_XML_E_COMMENTSYNTAX = 14031L;
//
// MessageId: ERROR_SXS_XML_E_BADSTARTNAMECHAR
//
// MessageText:
//
// Manifest Parse Error : A name was started with an invalid character.
//
static const long ERROR_SXS_XML_E_BADSTARTNAMECHAR = 14032L;
//
// MessageId: ERROR_SXS_XML_E_BADNAMECHAR
//
// MessageText:
//
// Manifest Parse Error : A name contained an invalid character.
//
static const long ERROR_SXS_XML_E_BADNAMECHAR = 14033L;
//
// MessageId: ERROR_SXS_XML_E_BADCHARINSTRING
//
// MessageText:
//
// Manifest Parse Error : A string literal contained an invalid character.
//
static const long ERROR_SXS_XML_E_BADCHARINSTRING = 14034L;
//
// MessageId: ERROR_SXS_XML_E_XMLDECLSYNTAX
//
// MessageText:
//
// Manifest Parse Error : Invalid syntax for an xml declaration.
//
static const long ERROR_SXS_XML_E_XMLDECLSYNTAX = 14035L;
//
// MessageId: ERROR_SXS_XML_E_BADCHARDATA
//
// MessageText:
//
// Manifest Parse Error : An Invalid character was found in text content.
//
static const long ERROR_SXS_XML_E_BADCHARDATA = 14036L;
//
// MessageId: ERROR_SXS_XML_E_MISSINGWHITESPACE
//
// MessageText:
//
// Manifest Parse Error : Required white space was missing.
//
static const long ERROR_SXS_XML_E_MISSINGWHITESPACE = 14037L;
//
// MessageId: ERROR_SXS_XML_E_EXPECTINGTAGEND
//
// MessageText:
//
// Manifest Parse Error : The character '>' was expected.
//
static const long ERROR_SXS_XML_E_EXPECTINGTAGEND = 14038L;
//
// MessageId: ERROR_SXS_XML_E_MISSINGSEMICOLON
//
// MessageText:
//
// Manifest Parse Error : A semi colon character was expected.
//
static const long ERROR_SXS_XML_E_MISSINGSEMICOLON = 14039L;
//
// MessageId: ERROR_SXS_XML_E_UNBALANCEDPAREN
//
// MessageText:
//
// Manifest Parse Error : Unbalanced parentheses.
//
static const long ERROR_SXS_XML_E_UNBALANCEDPAREN = 14040L;
//
// MessageId: ERROR_SXS_XML_E_INTERNALERROR
//
// MessageText:
//
// Manifest Parse Error : Internal error.
//
static const long ERROR_SXS_XML_E_INTERNALERROR = 14041L;
//
// MessageId: ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE
//
// MessageText:
//
// Manifest Parse Error : Whitespace is not allowed at this location.
//
static const long ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE = 14042L;
//
// MessageId: ERROR_SXS_XML_E_INCOMPLETE_ENCODING
//
// MessageText:
//
// Manifest Parse Error : End of file reached in invalid state for current encoding.
//
static const long ERROR_SXS_XML_E_INCOMPLETE_ENCODING = 14043L;
//
// MessageId: ERROR_SXS_XML_E_MISSING_PAREN
//
// MessageText:
//
// Manifest Parse Error : Missing parenthesis.
//
static const long ERROR_SXS_XML_E_MISSING_PAREN = 14044L;
//
// MessageId: ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE
//
// MessageText:
//
// Manifest Parse Error : A single or double closing quote character (\' or \") is missing.
//
static const long ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE = 14045L;
//
// MessageId: ERROR_SXS_XML_E_MULTIPLE_COLONS
//
// MessageText:
//
// Manifest Parse Error : Multiple colons are not allowed in a name.
//
static const long ERROR_SXS_XML_E_MULTIPLE_COLONS = 14046L;
//
// MessageId: ERROR_SXS_XML_E_INVALID_DECIMAL
//
// MessageText:
//
// Manifest Parse Error : Invalid character for decimal digit.
//
static const long ERROR_SXS_XML_E_INVALID_DECIMAL = 14047L;
//
// MessageId: ERROR_SXS_XML_E_INVALID_HEXIDECIMAL
//
// MessageText:
//
// Manifest Parse Error : Invalid character for hexadecimal digit.
//
static const long ERROR_SXS_XML_E_INVALID_HEXIDECIMAL = 14048L;
//
// MessageId: ERROR_SXS_XML_E_INVALID_UNICODE
//
// MessageText:
//
// Manifest Parse Error : Invalid unicode character value for this platform.
//
static const long ERROR_SXS_XML_E_INVALID_UNICODE = 14049L;
//
// MessageId: ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK
//
// MessageText:
//
// Manifest Parse Error : Expecting whitespace or '?'.
//
static const long ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = 14050L;
//
// MessageId: ERROR_SXS_XML_E_UNEXPECTEDENDTAG
//
// MessageText:
//
// Manifest Parse Error : End tag was not expected at this location.
//
static const long ERROR_SXS_XML_E_UNEXPECTEDENDTAG = 14051L;
//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDTAG
//
// MessageText:
//
// Manifest Parse Error : The following tags were not closed: %1.
//
static const long ERROR_SXS_XML_E_UNCLOSEDTAG = 14052L;
//
// MessageId: ERROR_SXS_XML_E_DUPLICATEATTRIBUTE
//
// MessageText:
//
// Manifest Parse Error : Duplicate attribute.
//
static const long ERROR_SXS_XML_E_DUPLICATEATTRIBUTE = 14053L;
//
// MessageId: ERROR_SXS_XML_E_MULTIPLEROOTS
//
// MessageText:
//
// Manifest Parse Error : Only one top level element is allowed in an XML document.
//
static const long ERROR_SXS_XML_E_MULTIPLEROOTS = 14054L;
//
// MessageId: ERROR_SXS_XML_E_INVALIDATROOTLEVEL
//
// MessageText:
//
// Manifest Parse Error : Invalid at the top level of the document.
//
static const long ERROR_SXS_XML_E_INVALIDATROOTLEVEL = 14055L;
//
// MessageId: ERROR_SXS_XML_E_BADXMLDECL
//
// MessageText:
//
// Manifest Parse Error : Invalid xml declaration.
//
static const long ERROR_SXS_XML_E_BADXMLDECL = 14056L;
//
// MessageId: ERROR_SXS_XML_E_MISSINGROOT
//
// MessageText:
//
// Manifest Parse Error : XML document must have a top level element.
//
static const long ERROR_SXS_XML_E_MISSINGROOT = 14057L;
//
// MessageId: ERROR_SXS_XML_E_UNEXPECTEDEOF
//
// MessageText:
//
// Manifest Parse Error : Unexpected end of file.
//
static const long ERROR_SXS_XML_E_UNEXPECTEDEOF = 14058L;
//
// MessageId: ERROR_SXS_XML_E_BADPEREFINSUBSET
//
// MessageText:
//
// Manifest Parse Error : Parameter entities cannot be used inside markup declarations in an internal subset.
//
static const long ERROR_SXS_XML_E_BADPEREFINSUBSET = 14059L;
//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDSTARTTAG
//
// MessageText:
//
// Manifest Parse Error : Element was not closed.
//
static const long ERROR_SXS_XML_E_UNCLOSEDSTARTTAG = 14060L;
//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDENDTAG
//
// MessageText:
//
// Manifest Parse Error : End element was missing the character '>'.
//
static const long ERROR_SXS_XML_E_UNCLOSEDENDTAG = 14061L;
//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDSTRING
//
// MessageText:
//
// Manifest Parse Error : A string literal was not closed.
//
static const long ERROR_SXS_XML_E_UNCLOSEDSTRING = 14062L;
//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDCOMMENT
//
// MessageText:
//
// Manifest Parse Error : A comment was not closed.
//
static const long ERROR_SXS_XML_E_UNCLOSEDCOMMENT = 14063L;
//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDDECL
//
// MessageText:
//
// Manifest Parse Error : A declaration was not closed.
//
static const long ERROR_SXS_XML_E_UNCLOSEDDECL = 14064L;
//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDCDATA
//
// MessageText:
//
// Manifest Parse Error : A CDATA section was not closed.
//
static const long ERROR_SXS_XML_E_UNCLOSEDCDATA = 14065L;
//
// MessageId: ERROR_SXS_XML_E_RESERVEDNAMESPACE
//
// MessageText:
//
// Manifest Parse Error : The namespace prefix is not allowed to start with the reserved string "xml".
//
static const long ERROR_SXS_XML_E_RESERVEDNAMESPACE = 14066L;
//
// MessageId: ERROR_SXS_XML_E_INVALIDENCODING
//
// MessageText:
//
// Manifest Parse Error : System does not support the specified encoding.
//
static const long ERROR_SXS_XML_E_INVALIDENCODING = 14067L;
//
// MessageId: ERROR_SXS_XML_E_INVALIDSWITCH
//
// MessageText:
//
// Manifest Parse Error : Switch from current encoding to specified encoding not supported.
//
static const long ERROR_SXS_XML_E_INVALIDSWITCH = 14068L;
//
// MessageId: ERROR_SXS_XML_E_BADXMLCASE
//
// MessageText:
//
// Manifest Parse Error : The name 'xml' is reserved and must be lower case.
//
static const long ERROR_SXS_XML_E_BADXMLCASE = 14069L;
//
// MessageId: ERROR_SXS_XML_E_INVALID_STANDALONE
//
// MessageText:
//
// Manifest Parse Error : The standalone attribute must have the value 'yes' or 'no'.
//
static const long ERROR_SXS_XML_E_INVALID_STANDALONE = 14070L;
//
// MessageId: ERROR_SXS_XML_E_UNEXPECTED_STANDALONE
//
// MessageText:
//
// Manifest Parse Error : The standalone attribute cannot be used in external entities.
//
static const long ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = 14071L;
//
// MessageId: ERROR_SXS_XML_E_INVALID_VERSION
//
// MessageText:
//
// Manifest Parse Error : Invalid version number.
//
static const long ERROR_SXS_XML_E_INVALID_VERSION = 14072L;
//
// MessageId: ERROR_SXS_XML_E_MISSINGEQUALS
//
// MessageText:
//
// Manifest Parse Error : Missing equals sign between attribute and attribute value.
//
static const long ERROR_SXS_XML_E_MISSINGEQUALS = 14073L;
//
// MessageId: ERROR_SXS_PROTECTION_RECOVERY_FAILED
//
// MessageText:
//
// Assembly Protection Error : Unable to recover the specified assembly.
//
static const long ERROR_SXS_PROTECTION_RECOVERY_FAILED = 14074L;
//
// MessageId: ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT
//
// MessageText:
//
// Assembly Protection Error : The public key for an assembly was too short to be allowed.
//
static const long ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = 14075L;
//
// MessageId: ERROR_SXS_PROTECTION_CATALOG_NOT_VALID
//
// MessageText:
//
// Assembly Protection Error : The catalog for an assembly is not valid, or does not match the assembly's manifest.
//
static const long ERROR_SXS_PROTECTION_CATALOG_NOT_VALID = 14076L;
//
// MessageId: ERROR_SXS_UNTRANSLATABLE_HRESULT
//
// MessageText:
//
// An HRESULT could not be translated to a corresponding Win32 error code.
//
static const long ERROR_SXS_UNTRANSLATABLE_HRESULT = 14077L;
//
// MessageId: ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING
//
// MessageText:
//
// Assembly Protection Error : The catalog for an assembly is missing.
//
static const long ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = 14078L;
//
// MessageId: ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE
//
// MessageText:
//
// The supplied assembly identity is missing one or more attributes which must be present in this context.
//
static const long ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE = 14079L;
//
// MessageId: ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME
//
// MessageText:
//
// The supplied assembly identity has one or more attribute names that contain characters not permitted in XML names.
//
static const long ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = 14080L;
//
// MessageId: ERROR_SXS_ASSEMBLY_MISSING
//
// MessageText:
//
// The referenced assembly could not be found.
//
static const long ERROR_SXS_ASSEMBLY_MISSING = 14081L;
//
// MessageId: ERROR_SXS_CORRUPT_ACTIVATION_STACK
//
// MessageText:
//
// The activation context activation stack for the running thread of execution is corrupt.
//
static const long ERROR_SXS_CORRUPT_ACTIVATION_STACK = 14082L;
//
// MessageId: ERROR_SXS_CORRUPTION
//
// MessageText:
//
// The application isolation metadata for this process or thread has become corrupt.
//
static const long ERROR_SXS_CORRUPTION = 14083L;
//
// MessageId: ERROR_SXS_EARLY_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not the most recently activated one.
//
static const long ERROR_SXS_EARLY_DEACTIVATION = 14084L;
//
// MessageId: ERROR_SXS_INVALID_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not active for the current thread of execution.
//
static const long ERROR_SXS_INVALID_DEACTIVATION = 14085L;
//
// MessageId: ERROR_SXS_MULTIPLE_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated has already been deactivated.
//
static const long ERROR_SXS_MULTIPLE_DEACTIVATION = 14086L;
//
// MessageId: ERROR_SXS_PROCESS_TERMINATION_REQUESTED
//
// MessageText:
//
// A component used by the isolation facility has requested to terminate the process.
//
static const long ERROR_SXS_PROCESS_TERMINATION_REQUESTED = 14087L;
//
// MessageId: ERROR_SXS_RELEASE_ACTIVATION_CONTEXT
//
// MessageText:
//
// A kernel mode component is releasing a reference on an activation context.
//
static const long ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = 14088L;
//
// MessageId: ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY
//
// MessageText:
//
// The activation context of system default assembly could not be generated.
//
static const long ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 14089L;
//
// MessageId: ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE
//
// MessageText:
//
// The value of an attribute in an identity is not within the legal range.
//
static const long ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 14090L;
//
// MessageId: ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME
//
// MessageText:
//
// The name of an attribute in an identity is not within the legal range.
//
static const long ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 14091L;
//
// MessageId: ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE
//
// MessageText:
//
// An identity contains two definitions for the same attribute.
//
static const long ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 14092L;
//
// MessageId: ERROR_SXS_IDENTITY_PARSE_ERROR
//
// MessageText:
//
// The identity string is malformed. This may be due to a trailing comma, more than two unnamed attributes, missing attribute name or missing attribute value.
//
static const long ERROR_SXS_IDENTITY_PARSE_ERROR = 14093L;
//
// MessageId: ERROR_MALFORMED_SUBSTITUTION_STRING
//
// MessageText:
//
// A string containing localized substitutable content was malformed. Either a dollar sign ($) was followed by something other than a left parenthesis or another dollar sign or an substitution's right parenthesis was not found.
//
static const long ERROR_MALFORMED_SUBSTITUTION_STRING = 14094L;
//
// MessageId: ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN
//
// MessageText:
//
// The public key token does not correspond to the public key specified.
//
static const long ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = 14095L;
//
// MessageId: ERROR_UNMAPPED_SUBSTITUTION_STRING
//
// MessageText:
//
// A substitution string had no mapping.
//
static const long ERROR_UNMAPPED_SUBSTITUTION_STRING = 14096L;
//
// MessageId: ERROR_SXS_ASSEMBLY_NOT_LOCKED
//
// MessageText:
//
// The component must be locked before making the request.
//
static const long ERROR_SXS_ASSEMBLY_NOT_LOCKED = 14097L;
//
// MessageId: ERROR_SXS_COMPONENT_STORE_CORRUPT
//
// MessageText:
//
// The component store has been corrupted.
//
static const long ERROR_SXS_COMPONENT_STORE_CORRUPT = 14098L;
//
// MessageId: ERROR_ADVANCED_INSTALLER_FAILED
//
// MessageText:
//
// An advanced installer failed during setup or servicing.
//
static const long ERROR_ADVANCED_INSTALLER_FAILED = 14099L;
//
// MessageId: ERROR_XML_ENCODING_MISMATCH
//
// MessageText:
//
// The character encoding in the XML declaration did not match the encoding used in the document.
//
static const long ERROR_XML_ENCODING_MISMATCH = 14100L;
//
// MessageId: ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT
//
// MessageText:
//
// The identities of the manifests are identical but their contents are different.
//
static const long ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 14101L;
//
// MessageId: ERROR_SXS_IDENTITIES_DIFFERENT
//
// MessageText:
//
// The component identities are different.
//
static const long ERROR_SXS_IDENTITIES_DIFFERENT = 14102L;
//
// MessageId: ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT
//
// MessageText:
//
// The assembly is not a deployment.
//
static const long ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 14103L;
//
// MessageId: ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY
//
// MessageText:
//
// The file is not a part of the assembly.
//
static const long ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY = 14104L;
//
// MessageId: ERROR_SXS_MANIFEST_TOO_BIG
//
// MessageText:
//
// The size of the manifest exceeds the maximum allowed.
//
static const long ERROR_SXS_MANIFEST_TOO_BIG = 14105L;
//
// MessageId: ERROR_SXS_SETTING_NOT_REGISTERED
//
// MessageText:
//
// The setting is not registered.
//
static const long ERROR_SXS_SETTING_NOT_REGISTERED = 14106L;
//
// MessageId: ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE
//
// MessageText:
//
// One or more required members of the transaction are not present.
//
static const long ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 14107L;
//
// MessageId: ERROR_SMI_PRIMITIVE_INSTALLER_FAILED
//
// MessageText:
//
// The SMI primitive installer failed during setup or servicing.
//
static const long ERROR_SMI_PRIMITIVE_INSTALLER_FAILED = 14108L;
//
// MessageId: ERROR_GENERIC_COMMAND_FAILED
//
// MessageText:
//
// A generic command executable returned a result that indicates failure.
//
static const long ERROR_GENERIC_COMMAND_FAILED = 14109L;
//
// MessageId: ERROR_SXS_FILE_HASH_MISSING
//
// MessageText:
//
// A component is missing file verification information in its manifest.
//
static const long ERROR_SXS_FILE_HASH_MISSING = 14110L;
///////////////////////////////////////////////////
//                                               //
//           End of Side By Side Error Codes     //
//                                               //
//                 14000 to 14999                //
///////////////////////////////////////////////////
///////////////////////////////////////////////////
//                                               //
//           Start of WinEvt Error codes         //
//                                               //
//                 15000 to 15079                //
///////////////////////////////////////////////////
//
// MessageId: ERROR_EVT_INVALID_CHANNEL_PATH
//
// MessageText:
//
// The specified channel path is invalid.
//
static const long ERROR_EVT_INVALID_CHANNEL_PATH = 15000L;
//
// MessageId: ERROR_EVT_INVALID_QUERY
//
// MessageText:
//
// The specified query is invalid.
//
static const long ERROR_EVT_INVALID_QUERY = 15001L;
//
// MessageId: ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND
//
// MessageText:
//
// The publisher metadata cannot be found in the resource.
//
static const long ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = 15002L;
//
// MessageId: ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND
//
// MessageText:
//
// The template for an event definition cannot be found in the resource (error = %1).
//
static const long ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND = 15003L;
//
// MessageId: ERROR_EVT_INVALID_PUBLISHER_NAME
//
// MessageText:
//
// The specified publisher name is invalid.
//
static const long ERROR_EVT_INVALID_PUBLISHER_NAME = 15004L;
//
// MessageId: ERROR_EVT_INVALID_EVENT_DATA
//
// MessageText:
//
// The event data raised by the publisher is not compatible with the event template definition in the publisher's manifest
//
static const long ERROR_EVT_INVALID_EVENT_DATA = 15005L;
//
// MessageId: ERROR_EVT_CHANNEL_NOT_FOUND
//
// MessageText:
//
// The specified channel could not be found. Check channel configuration.
//
static const long ERROR_EVT_CHANNEL_NOT_FOUND = 15007L;
//
// MessageId: ERROR_EVT_MALFORMED_XML_TEXT
//
// MessageText:
//
// The specified xml text was not well-formed. See Extended Error for more details.
//
static const long ERROR_EVT_MALFORMED_XML_TEXT = 15008L;
//
// MessageId: ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL
//
// MessageText:
//
// The caller is trying to subscribe to a direct channel which is not allowed. The events for a direct channel go directly to a logfile and cannot be subscribed to.
//
static const long ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL = 15009L;
//
// MessageId: ERROR_EVT_CONFIGURATION_ERROR
//
// MessageText:
//
// Configuration error.
//
static const long ERROR_EVT_CONFIGURATION_ERROR = 15010L;
//
// MessageId: ERROR_EVT_QUERY_RESULT_STALE
//
// MessageText:
//
// The query result is stale / invalid. This may be due to the log being cleared or rolling over after the query result was created. Users should handle this code by releasing the query result object and reissuing the query.
//
static const long ERROR_EVT_QUERY_RESULT_STALE = 15011L;
//
// MessageId: ERROR_EVT_QUERY_RESULT_INVALID_POSITION
//
// MessageText:
//
// Query result is currently at an invalid position.
//
static const long ERROR_EVT_QUERY_RESULT_INVALID_POSITION = 15012L;
//
// MessageId: ERROR_EVT_NON_VALIDATING_MSXML
//
// MessageText:
//
// Registered MSXML doesn't support validation.
//
static const long ERROR_EVT_NON_VALIDATING_MSXML = 15013L;
//
// MessageId: ERROR_EVT_FILTER_ALREADYSCOPED
//
// MessageText:
//
// An expression can only be followed by a change of scope operation if it itself evaluates to a node set and is not already part of some other change of scope operation.
//
static const long ERROR_EVT_FILTER_ALREADYSCOPED = 15014L;
//
// MessageId: ERROR_EVT_FILTER_NOTELTSET
//
// MessageText:
//
// Can't perform a step operation from a term that does not represent an element set.
//
static const long ERROR_EVT_FILTER_NOTELTSET = 15015L;
//
// MessageId: ERROR_EVT_FILTER_INVARG
//
// MessageText:
//
// Left hand side arguments to binary operators must be either attributes, nodes or variables and right hand side arguments must be constants.
//
static const long ERROR_EVT_FILTER_INVARG = 15016L;
//
// MessageId: ERROR_EVT_FILTER_INVTEST
//
// MessageText:
//
// A step operation must involve either a node test or, in the case of a predicate, an algebraic expression against which to test each node in the node set identified by the preceeding node set can be evaluated.
//
static const long ERROR_EVT_FILTER_INVTEST = 15017L;
//
// MessageId: ERROR_EVT_FILTER_INVTYPE
//
// MessageText:
//
// This data type is currently unsupported.
//
static const long ERROR_EVT_FILTER_INVTYPE = 15018L;
//
// MessageId: ERROR_EVT_FILTER_PARSEERR
//
// MessageText:
//
// A syntax error occurred at position %1!d!
//
static const long ERROR_EVT_FILTER_PARSEERR = 15019L;
//
// MessageId: ERROR_EVT_FILTER_UNSUPPORTEDOP
//
// MessageText:
//
// This operator is unsupported by this implementation of the filter.
//
static const long ERROR_EVT_FILTER_UNSUPPORTEDOP = 15020L;
//
// MessageId: ERROR_EVT_FILTER_UNEXPECTEDTOKEN
//
// MessageText:
//
// The token encountered was unexpected.
//
static const long ERROR_EVT_FILTER_UNEXPECTEDTOKEN = 15021L;
//
// MessageId: ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL
//
// MessageText:
//
// The requested operation cannot be performed over an enabled direct channel. The channel must first be disabled before performing the requested operation.
//
static const long ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL = 15022L;
//
// MessageId: ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE
//
// MessageText:
//
// Channel property %1!s! contains invalid value. The value has invalid type, is outside of valid range, can't be updated or is not supported by this type of channel.
//
static const long ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE = 15023L;
//
// MessageId: ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE
//
// MessageText:
//
// Publisher property %1!s! contains invalid value. The value has invalid type, is outside of valid range, can't be updated or is not supported by this type of publisher.
//
static const long ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = 15024L;
//
// MessageId: ERROR_EVT_CHANNEL_CANNOT_ACTIVATE
//
// MessageText:
//
// The channel fails to activate.
//
static const long ERROR_EVT_CHANNEL_CANNOT_ACTIVATE = 15025L;
//
// MessageId: ERROR_EVT_FILTER_TOO_COMPLEX
//
// MessageText:
//
// The xpath expression exceeded supported complexity. Please symplify it or split it into two or more simple expressions.
//
static const long ERROR_EVT_FILTER_TOO_COMPLEX = 15026L;
//
// MessageId: ERROR_EVT_MESSAGE_NOT_FOUND
//
// MessageText:
//
// the message resource is present but the message is not found in the string/message table
//
static const long ERROR_EVT_MESSAGE_NOT_FOUND = 15027L;
//
// MessageId: ERROR_EVT_MESSAGE_ID_NOT_FOUND
//
// MessageText:
//
// The message id for the desired message could not be found.
//
static const long ERROR_EVT_MESSAGE_ID_NOT_FOUND = 15028L;
//
// MessageId: ERROR_EVT_UNRESOLVED_VALUE_INSERT
//
// MessageText:
//
// The substitution string for insert index (%1) could not be found.
//
static const long ERROR_EVT_UNRESOLVED_VALUE_INSERT = 15029L;
//
// MessageId: ERROR_EVT_UNRESOLVED_PARAMETER_INSERT
//
// MessageText:
//
// The description string for parameter reference (%1) could not be found.
//
static const long ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = 15030L;
//
// MessageId: ERROR_EVT_MAX_INSERTS_REACHED
//
// MessageText:
//
// The maximum number of replacements has been reached.
//
static const long ERROR_EVT_MAX_INSERTS_REACHED = 15031L;
//
// MessageId: ERROR_EVT_EVENT_DEFINITION_NOT_FOUND
//
// MessageText:
//
// The event definition could not be found for event id (%1).
//
static const long ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = 15032L;
//
// MessageId: ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND
//
// MessageText:
//
// The locale specific resource for the desired message is not present.
//
static const long ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = 15033L;
//
// MessageId: ERROR_EVT_VERSION_TOO_OLD
//
// MessageText:
//
// The resource is too old to be compatible.
//
static const long ERROR_EVT_VERSION_TOO_OLD = 15034L;
//
// MessageId: ERROR_EVT_VERSION_TOO_NEW
//
// MessageText:
//
// The resource is too new to be compatible.
//
static const long ERROR_EVT_VERSION_TOO_NEW = 15035L;
//
// MessageId: ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY
//
// MessageText:
//
// The channel at index %1!d! of the query can't be opened.
//
static const long ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY = 15036L;
//
// MessageId: ERROR_EVT_PUBLISHER_DISABLED
//
// MessageText:
//
// The publisher has been disabled and its resource is not avaiable. This usually occurs when the publisher is in the process of being uninstalled or upgraded.
//
static const long ERROR_EVT_PUBLISHER_DISABLED = 15037L;
//
// MessageId: ERROR_EVT_FILTER_OUT_OF_RANGE
//
// MessageText:
//
// Attempted to create a numeric type that is outside of its valid range.
//
static const long ERROR_EVT_FILTER_OUT_OF_RANGE = 15038L;
///////////////////////////////////////////////////
//                                               //
//           Start of Wecsvc Error codes         //
//                                               //
//                 15080 to 15099                //
///////////////////////////////////////////////////
//
// MessageId: ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE
//
// MessageText:
//
// The subscription fails to activate.
//
static const long ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = 15080L;
//
// MessageId: ERROR_EC_LOG_DISABLED
//
// MessageText:
//
// The log of the subscription is in disabled state, and can not be used to forward events to. The log must first be enabled before the subscription can be activated.
//
static const long ERROR_EC_LOG_DISABLED = 15081L;
//
// MessageId: ERROR_EC_CIRCULAR_FORWARDING
//
// MessageText:
//
// When forwarding events from local machine to itself, the query of the subscription can't contain target log of the subscription.
//
static const long ERROR_EC_CIRCULAR_FORWARDING = 15082L;
//
// MessageId: ERROR_EC_CREDSTORE_FULL
//
// MessageText:
//
// The credential store that is used to save credentials is full.
//
static const long ERROR_EC_CREDSTORE_FULL = 15083L;
//
// MessageId: ERROR_EC_CRED_NOT_FOUND
//
// MessageText:
//
// The credential used by this subscription can't be found in credential store.
//
static const long ERROR_EC_CRED_NOT_FOUND = 15084L;
//
// MessageId: ERROR_EC_NO_ACTIVE_CHANNEL
//
// MessageText:
//
// No active channel is found for the query.
//
static const long ERROR_EC_NO_ACTIVE_CHANNEL = 15085L;
///////////////////////////////////////////////////
//                                               //
//           Start of MUI Error codes            //
//                                               //
//                 15100 to 15199                //
///////////////////////////////////////////////////
//
// MessageId: ERROR_MUI_FILE_NOT_FOUND
//
// MessageText:
//
// The resource loader failed to find MUI file.
//
static const long ERROR_MUI_FILE_NOT_FOUND = 15100L;
//
// MessageId: ERROR_MUI_INVALID_FILE
//
// MessageText:
//
// The resource loader failed to load MUI file because the file fail to pass validation.
//
static const long ERROR_MUI_INVALID_FILE = 15101L;
//
// MessageId: ERROR_MUI_INVALID_RC_CONFIG
//
// MessageText:
//
// The RC Manifest is corrupted with garbage data or unsupported version or missing required item.
//
static const long ERROR_MUI_INVALID_RC_CONFIG = 15102L;
//
// MessageId: ERROR_MUI_INVALID_LOCALE_NAME
//
// MessageText:
//
// The RC Manifest has invalid culture name.
//
static const long ERROR_MUI_INVALID_LOCALE_NAME = 15103L;
//
// MessageId: ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME
//
// MessageText:
//
// The RC Manifest has invalid ultimatefallback name.
//
static const long ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = 15104L;
//
// MessageId: ERROR_MUI_FILE_NOT_LOADED
//
// MessageText:
//
// The resource loader cache doesn't have loaded MUI entry.
//
static const long ERROR_MUI_FILE_NOT_LOADED = 15105L;
//
// MessageId: ERROR_RESOURCE_ENUM_USER_STOP
//
// MessageText:
//
// User stopped resource enumeration.
//
static const long ERROR_RESOURCE_ENUM_USER_STOP = 15106L;
//
// MessageId: ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED
//
// MessageText:
//
// UI language installation failed.
//
static const long ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED = 15107L;
//
// MessageId: ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME
//
// MessageText:
//
// Locale installation failed.
//
static const long ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = 15108L;
///////////////////////////////////////////////////
//                                               //
// Start of Monitor Configuration API error codes//
//                                               //
//                 15200 to 15249                //
///////////////////////////////////////////////////
//
// MessageId: ERROR_MCA_INVALID_CAPABILITIES_STRING
//
// MessageText:
//
// The monitor returned a DDC/CI capabilities string that did not comply with the ACCESS.bus 3.0, DDC/CI 1.1 or MCCS 2 Revision 1 specification.
//
static const long ERROR_MCA_INVALID_CAPABILITIES_STRING = 15200L;
//
// MessageId: ERROR_MCA_INVALID_VCP_VERSION
//
// MessageText:
//
// The monitor's VCP Version (0xDF) VCP code returned an invalid version value.
//
static const long ERROR_MCA_INVALID_VCP_VERSION = 15201L;
//
// MessageId: ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION
//
// MessageText:
//
// The monitor does not comply with the MCCS specification it claims to support.
//
static const long ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = 15202L;
//
// MessageId: ERROR_MCA_MCCS_VERSION_MISMATCH
//
// MessageText:
//
// The MCCS version in a monitor's mccs_ver capability does not match the MCCS version the monitor reports when the VCP Version (0xDF) VCP code is used.
//
static const long ERROR_MCA_MCCS_VERSION_MISMATCH = 15203L;
//
// MessageId: ERROR_MCA_UNSUPPORTED_MCCS_VERSION
//
// MessageText:
//
// The Monitor Configuration API only works with monitors that support the MCCS 1.0 specification, MCCS 2.0 specification or the MCCS 2.0 Revision 1 specification.
//
static const long ERROR_MCA_UNSUPPORTED_MCCS_VERSION = 15204L;
//
// MessageId: ERROR_MCA_INTERNAL_ERROR
//
// MessageText:
//
// An internal Monitor Configuration API error occurred.
//
static const long ERROR_MCA_INTERNAL_ERROR = 15205L;
//
// MessageId: ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED
//
// MessageText:
//
// The monitor returned an invalid monitor technology type. CRT, Plasma and LCD (TFT) are examples of monitor technology types. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
static const long ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = 15206L;
//
// MessageId: ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE
//
// MessageText:
//
// The caller of SetMonitorColorTemperature specified a color temperature that the current monitor did not support. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
static const long ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE = 15207L;
//////////////////////////////////////////////////
//                                              //
// End of Monitor Configuration API error codes //
//                                              //
//                15200 to 15249                //
//                                              //
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//                                              //
//         Start of Syspart error codes         //
//                15250 - 15299                 //
//                                              //
//////////////////////////////////////////////////
//
// MessageId: ERROR_AMBIGUOUS_SYSTEM_DEVICE
//
// MessageText:
//
// The requested system device cannot be identified due to multiple indistinguishable devices potentially matching the identification criteria.
//
static const long ERROR_AMBIGUOUS_SYSTEM_DEVICE = 15250L;
//
// MessageId: ERROR_SYSTEM_DEVICE_NOT_FOUND
//
// MessageText:
//
// The requested system device cannot be found.
//
static const long ERROR_SYSTEM_DEVICE_NOT_FOUND = 15299L;
//////////////////////////////////////////////////
//                                              //
//         Start of Vortex error codes          //
//                15300 - 15320                 //
//                                              //
//////////////////////////////////////////////////
//
// MessageId: ERROR_HASH_NOT_SUPPORTED
//
// MessageText:
//
// Hash generation for the specified hash version and hash type is not enabled on the server.
//
static const long ERROR_HASH_NOT_SUPPORTED = 15300L;
//
// MessageId: ERROR_HASH_NOT_PRESENT
//
// MessageText:
//
// The hash requested from the server is not available or no longer valid.
//
static const long ERROR_HASH_NOT_PRESENT = 15301L;
////////////////////////////////////
//                                //
//     COM Error Codes            //
//                                //
////////////////////////////////////
//
// The return value of COM functions and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value. The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs. SCODEs are no longer used. The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//
//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Severity values
//
static const int SEVERITY_SUCCESS = 0;
static const int SEVERITY_ERROR = 1;
//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//
static const int SUCCEEDED(hr) = (((HRESULT)(hr)) >= 0);
//
// and the inverse
//
static const int FAILED(hr) = (((HRESULT)(hr)) < 0);
//
// Generic test for error on any status value.
//
static const int IS_ERROR(Status) = (((unsigned long)(Status)) >> 31 == SEVERITY_ERROR);
//
// Return the code
//
static const int HRESULT_CODE(hr) = ((hr) & 0xFFFF);
static const int SCODE_CODE(sc) = ((sc) & 0xFFFF);
//
//  Return the facility
//
static const int HRESULT_FACILITY(hr) = (((hr) >> 16) & 0x1fff);
static const int SCODE_FACILITY(sc) = (((sc) >> 16) & 0x1fff);
//
//  Return the severity
//
static const int HRESULT_SEVERITY(hr) = (((hr) >> 31) & 0x1);
static const int SCODE_SEVERITY(sc) = (((sc) >> 31) & 0x1);
//
// Create an HRESULT value from component pieces
//
static const int MAKE_HRESULT(sev,fac,code) = ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) );
static const int MAKE_SCODE(sev,fac,code) = ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) );
//
// Map a WIN32 error value into a HRESULT
// Note: This assumes that WIN32 errors fall in the range -32k to 32k.
//
// Define bits here so macros are guaranteed to work
static const int FACILITY_NT_BIT = 0x10000000;
//
// HRESULT_FROM_WIN32(x) used to be a macro, however we now run it as an inline function
// to prevent double evaluation of 'x'. If you still need the macro, you can use __HRESULT_FROM_WIN32(x)
//
static const int __HRESULT_FROM_WIN32(x) = ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)));
__inline HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (7 << 16) | 0x80000000);}
//
// Map an NT status value into a HRESULT
//
static const int HRESULT_FROM_NT(x) = ((HRESULT) ((x) | FACILITY_NT_BIT));
// ****** OBSOLETE functions
// HRESULT functions
// As noted above, these functions are obsolete and should not be used.
// Extract the SCODE from a HRESULT
static const int GetScode(hr) = ((SCODE) (hr));
// Convert an SCODE into an HRESULT.
static const int ResultFromScode(sc) = ((HRESULT) (sc));
// PropagateResult is a noop
static const int PropagateResult(hrPrevious,scBase) = ((HRESULT) scBase);
// ****** End of OBSOLETE functions.
static const int E_NOT_SET = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
static const int E_NOT_VALID_STATE = HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
static const int E_NOT_SUFFICIENT_BUFFER = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
// ---------------------- HRESULT value definitions -----------------
//
// HRESULT definitions
//
static const int _HRESULT_TYPEDEF_(_sc) = ((HRESULT)_sc);
static const int NOERROR = 0;
//
// Error definitions follow
//
//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
// Catastrophic failure
//
static const int E_UNEXPECTED = _HRESULT_TYPEDEF_(0x8000FFFFL);
//
// MessageId: E_NOTIMPL
//
// MessageText:
//
// Not implemented
//
static const int E_NOTIMPL = _HRESULT_TYPEDEF_(0x80004001L);
//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
// Ran out of memory
//
static const int E_OUTOFMEMORY = _HRESULT_TYPEDEF_(0x8007000EL);
//
// MessageId: E_INVALIDARG
//
// MessageText:
//
// One or more arguments are invalid
//
static const int E_INVALIDARG = _HRESULT_TYPEDEF_(0x80070057L);
//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
// No such interface supported
//
static const int E_NOINTERFACE = _HRESULT_TYPEDEF_(0x80004002L);
//
// MessageId: E_POINTER
//
// MessageText:
//
// Invalid pointer
//
static const int E_POINTER = _HRESULT_TYPEDEF_(0x80004003L);
//
// MessageId: E_HANDLE
//
// MessageText:
//
// Invalid handle
//
static const int E_HANDLE = _HRESULT_TYPEDEF_(0x80070006L);
//
// MessageId: E_ABORT
//
// MessageText:
//
// Operation aborted
//
static const int E_ABORT = _HRESULT_TYPEDEF_(0x80004004L);
//
// MessageId: E_FAIL
//
// MessageText:
//
// Unspecified error
//
static const int E_FAIL = _HRESULT_TYPEDEF_(0x80004005L);
//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
// General access denied error
//
static const int E_ACCESSDENIED = _HRESULT_TYPEDEF_(0x80070005L);
# 24075 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
// MessageId: E_PENDING
//
// MessageText:
//
// The data necessary to complete this operation is not yet available.
//
static const int E_PENDING = _HRESULT_TYPEDEF_(0x8000000AL);
//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
// Thread local storage failure
//
static const int CO_E_INIT_TLS = _HRESULT_TYPEDEF_(0x80004006L);
//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
// Get shared memory allocator failure
//
static const int CO_E_INIT_SHARED_ALLOCATOR = _HRESULT_TYPEDEF_(0x80004007L);
//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
// Get memory allocator failure
//
static const int CO_E_INIT_MEMORY_ALLOCATOR = _HRESULT_TYPEDEF_(0x80004008L);
//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
// Unable to initialize class cache
//
static const int CO_E_INIT_CLASS_CACHE = _HRESULT_TYPEDEF_(0x80004009L);
//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
// Unable to initialize RPC services
//
static const int CO_E_INIT_RPC_CHANNEL = _HRESULT_TYPEDEF_(0x8000400AL);
//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
// Cannot set thread local storage channel control
//
static const int CO_E_INIT_TLS_SET_CHANNEL_CONTROL = _HRESULT_TYPEDEF_(0x8000400BL);
//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
// Could not allocate thread local storage channel control
//
static const int CO_E_INIT_TLS_CHANNEL_CONTROL = _HRESULT_TYPEDEF_(0x8000400CL);
//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
// The user supplied memory allocator is unacceptable
//
static const int CO_E_INIT_UNACCEPTED_USER_ALLOCATOR = _HRESULT_TYPEDEF_(0x8000400DL);
//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
// The OLE service mutex already exists
//
static const int CO_E_INIT_SCM_MUTEX_EXISTS = _HRESULT_TYPEDEF_(0x8000400EL);
//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
// The OLE service file mapping already exists
//
static const int CO_E_INIT_SCM_FILE_MAPPING_EXISTS = _HRESULT_TYPEDEF_(0x8000400FL);
//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
// Unable to map view of file for OLE service
//
static const int CO_E_INIT_SCM_MAP_VIEW_OF_FILE = _HRESULT_TYPEDEF_(0x80004010L);
//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
// Failure attempting to launch OLE service
//
static const int CO_E_INIT_SCM_EXEC_FAILURE = _HRESULT_TYPEDEF_(0x80004011L);
//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
// There was an attempt to call CoInitialize a second time while single threaded
//
static const int CO_E_INIT_ONLY_SINGLE_THREADED = _HRESULT_TYPEDEF_(0x80004012L);
//
// MessageId: CO_E_CANT_REMOTE
//
// MessageText:
//
// A Remote activation was necessary but was not allowed
//
static const int CO_E_CANT_REMOTE = _HRESULT_TYPEDEF_(0x80004013L);
//
// MessageId: CO_E_BAD_SERVER_NAME
//
// MessageText:
//
// A Remote activation was necessary but the server name provided was invalid
//
static const int CO_E_BAD_SERVER_NAME = _HRESULT_TYPEDEF_(0x80004014L);
//
// MessageId: CO_E_WRONG_SERVER_IDENTITY
//
// MessageText:
//
// The class is configured to run as a security id different from the caller
//
static const int CO_E_WRONG_SERVER_IDENTITY = _HRESULT_TYPEDEF_(0x80004015L);
//
// MessageId: CO_E_OLE1DDE_DISABLED
//
// MessageText:
//
// Use of Ole1 services requiring DDE windows is disabled
//
static const int CO_E_OLE1DDE_DISABLED = _HRESULT_TYPEDEF_(0x80004016L);
//
// MessageId: CO_E_RUNAS_SYNTAX
//
// MessageText:
//
// A RunAs specification must be <domain name>\<user name> or simply <user name>
//
static const int CO_E_RUNAS_SYNTAX = _HRESULT_TYPEDEF_(0x80004017L);
//
// MessageId: CO_E_CREATEPROCESS_FAILURE
//
// MessageText:
//
// The server process could not be started. The pathname may be incorrect.
//
static const int CO_E_CREATEPROCESS_FAILURE = _HRESULT_TYPEDEF_(0x80004018L);
//
// MessageId: CO_E_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
// The server process could not be started as the configured identity. The pathname may be incorrect or unavailable.
//
static const int CO_E_RUNAS_CREATEPROCESS_FAILURE = _HRESULT_TYPEDEF_(0x80004019L);
//
// MessageId: CO_E_RUNAS_LOGON_FAILURE
//
// MessageText:
//
// The server process could not be started because the configured identity is incorrect. Check the username and password.
//
static const int CO_E_RUNAS_LOGON_FAILURE = _HRESULT_TYPEDEF_(0x8000401AL);
//
// MessageId: CO_E_LAUNCH_PERMSSION_DENIED
//
// MessageText:
//
// The client is not allowed to launch this server.
//
static const int CO_E_LAUNCH_PERMSSION_DENIED = _HRESULT_TYPEDEF_(0x8000401BL);
//
// MessageId: CO_E_START_SERVICE_FAILURE
//
// MessageText:
//
// The service providing this server could not be started.
//
static const int CO_E_START_SERVICE_FAILURE = _HRESULT_TYPEDEF_(0x8000401CL);
//
// MessageId: CO_E_REMOTE_COMMUNICATION_FAILURE
//
// MessageText:
//
// This computer was unable to communicate with the computer providing the server.
//
static const int CO_E_REMOTE_COMMUNICATION_FAILURE = _HRESULT_TYPEDEF_(0x8000401DL);
//
// MessageId: CO_E_SERVER_START_TIMEOUT
//
// MessageText:
//
// The server did not respond after being launched.
//
static const int CO_E_SERVER_START_TIMEOUT = _HRESULT_TYPEDEF_(0x8000401EL);
//
// MessageId: CO_E_CLSREG_INCONSISTENT
//
// MessageText:
//
// The registration information for this server is inconsistent or incomplete.
//
static const int CO_E_CLSREG_INCONSISTENT = _HRESULT_TYPEDEF_(0x8000401FL);
//
// MessageId: CO_E_IIDREG_INCONSISTENT
//
// MessageText:
//
// The registration information for this interface is inconsistent or incomplete.
//
static const int CO_E_IIDREG_INCONSISTENT = _HRESULT_TYPEDEF_(0x80004020L);
//
// MessageId: CO_E_NOT_SUPPORTED
//
// MessageText:
//
// The operation attempted is not supported.
//
static const int CO_E_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80004021L);
//
// MessageId: CO_E_RELOAD_DLL
//
// MessageText:
//
// A dll must be loaded.
//
static const int CO_E_RELOAD_DLL = _HRESULT_TYPEDEF_(0x80004022L);
//
// MessageId: CO_E_MSI_ERROR
//
// MessageText:
//
// A Microsoft Software Installer error was encountered.
//
static const int CO_E_MSI_ERROR = _HRESULT_TYPEDEF_(0x80004023L);
//
// MessageId: CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT
//
// MessageText:
//
// The specified activation could not occur in the client context as specified.
//
static const int CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT = _HRESULT_TYPEDEF_(0x80004024L);
//
// MessageId: CO_E_SERVER_PAUSED
//
// MessageText:
//
// Activations on the server are paused.
//
static const int CO_E_SERVER_PAUSED = _HRESULT_TYPEDEF_(0x80004025L);
//
// MessageId: CO_E_SERVER_NOT_PAUSED
//
// MessageText:
//
// Activations on the server are not paused.
//
static const int CO_E_SERVER_NOT_PAUSED = _HRESULT_TYPEDEF_(0x80004026L);
//
// MessageId: CO_E_CLASS_DISABLED
//
// MessageText:
//
// The component or application containing the component has been disabled.
//
static const int CO_E_CLASS_DISABLED = _HRESULT_TYPEDEF_(0x80004027L);
//
// MessageId: CO_E_CLRNOTAVAILABLE
//
// MessageText:
//
// The common language runtime is not available
//
static const int CO_E_CLRNOTAVAILABLE = _HRESULT_TYPEDEF_(0x80004028L);
//
// MessageId: CO_E_ASYNC_WORK_REJECTED
//
// MessageText:
//
// The thread-pool rejected the submitted asynchronous work.
//
static const int CO_E_ASYNC_WORK_REJECTED = _HRESULT_TYPEDEF_(0x80004029L);
//
// MessageId: CO_E_SERVER_INIT_TIMEOUT
//
// MessageText:
//
// The server started, but did not finish initializing in a timely fashion.
//
static const int CO_E_SERVER_INIT_TIMEOUT = _HRESULT_TYPEDEF_(0x8000402AL);
//
// MessageId: CO_E_NO_SECCTX_IN_ACTIVATE
//
// MessageText:
//
// Unable to complete the call since there is no COM+ security context inside IObjectControl.Activate.
//
static const int CO_E_NO_SECCTX_IN_ACTIVATE = _HRESULT_TYPEDEF_(0x8000402BL);
//
// MessageId: CO_E_TRACKER_CONFIG
//
// MessageText:
//
// The provided tracker configuration is invalid
//
static const int CO_E_TRACKER_CONFIG = _HRESULT_TYPEDEF_(0x80004030L);
//
// MessageId: CO_E_THREADPOOL_CONFIG
//
// MessageText:
//
// The provided thread pool configuration is invalid
//
static const int CO_E_THREADPOOL_CONFIG = _HRESULT_TYPEDEF_(0x80004031L);
//
// MessageId: CO_E_SXS_CONFIG
//
// MessageText:
//
// The provided side-by-side configuration is invalid
//
static const int CO_E_SXS_CONFIG = _HRESULT_TYPEDEF_(0x80004032L);
//
// MessageId: CO_E_MALFORMED_SPN
//
// MessageText:
//
// The server principal name (SPN) obtained during security negotiation is malformed.
//
static const int CO_E_MALFORMED_SPN = _HRESULT_TYPEDEF_(0x80004033L);
//
// Success codes
//
static const int S_OK = ((HRESULT)0L);
static const int S_FALSE = ((HRESULT)1L);
// ******************
// FACILITY_ITF
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// Generic OLE errors that may be returned by many inerfaces
//
static const int OLE_E_FIRST = ((HRESULT)0x80040000L);
static const int OLE_E_LAST = ((HRESULT)0x800400FFL);
static const int OLE_S_FIRST = ((HRESULT)0x00040000L);
static const int OLE_S_LAST = ((HRESULT)0x000400FFL);
//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
// Invalid OLEVERB structure
//
static const int OLE_E_OLEVERB = _HRESULT_TYPEDEF_(0x80040000L);
//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
// Invalid advise flags
//
static const int OLE_E_ADVF = _HRESULT_TYPEDEF_(0x80040001L);
//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
// Can't enumerate any more, because the associated data is missing
//
static const int OLE_E_ENUM_NOMORE = _HRESULT_TYPEDEF_(0x80040002L);
//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
// This implementation doesn't take advises
//
static const int OLE_E_ADVISENOTSUPPORTED = _HRESULT_TYPEDEF_(0x80040003L);
//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
// There is no connection for this connection ID
//
static const int OLE_E_NOCONNECTION = _HRESULT_TYPEDEF_(0x80040004L);
//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
// Need to run the object to perform this operation
//
static const int OLE_E_NOTRUNNING = _HRESULT_TYPEDEF_(0x80040005L);
//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
// There is no cache to operate on
//
static const int OLE_E_NOCACHE = _HRESULT_TYPEDEF_(0x80040006L);
//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
// Uninitialized object
//
static const int OLE_E_BLANK = _HRESULT_TYPEDEF_(0x80040007L);
//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
// Linked object's source class has changed
//
static const int OLE_E_CLASSDIFF = _HRESULT_TYPEDEF_(0x80040008L);
//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
// Not able to get the moniker of the object
//
static const int OLE_E_CANT_GETMONIKER = _HRESULT_TYPEDEF_(0x80040009L);
//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
// Not able to bind to the source
//
static const int OLE_E_CANT_BINDTOSOURCE = _HRESULT_TYPEDEF_(0x8004000AL);
//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
// Object is static; operation not allowed
//
static const int OLE_E_STATIC = _HRESULT_TYPEDEF_(0x8004000BL);
//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
// User canceled out of save dialog
//
static const int OLE_E_PROMPTSAVECANCELLED = _HRESULT_TYPEDEF_(0x8004000CL);
//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
// Invalid rectangle
//
static const int OLE_E_INVALIDRECT = _HRESULT_TYPEDEF_(0x8004000DL);
//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
// compobj.dll is too old for the ole2.dll initialized
//
static const int OLE_E_WRONGCOMPOBJ = _HRESULT_TYPEDEF_(0x8004000EL);
//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
// Invalid window handle
//
static const int OLE_E_INVALIDHWND = _HRESULT_TYPEDEF_(0x8004000FL);
//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
// Object is not in any of the inplace active states
//
static const int OLE_E_NOT_INPLACEACTIVE = _HRESULT_TYPEDEF_(0x80040010L);
//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
// Not able to convert object
//
static const int OLE_E_CANTCONVERT = _HRESULT_TYPEDEF_(0x80040011L);
//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
// Not able to perform the operation because object is not given storage yet
//
static const int OLE_E_NOSTORAGE = _HRESULT_TYPEDEF_(0x80040012L);
//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
// Invalid FORMATETC structure
//
static const int DV_E_FORMATETC = _HRESULT_TYPEDEF_(0x80040064L);
//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
// Invalid DVTARGETDEVICE structure
//
static const int DV_E_DVTARGETDEVICE = _HRESULT_TYPEDEF_(0x80040065L);
//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
// Invalid STDGMEDIUM structure
//
static const int DV_E_STGMEDIUM = _HRESULT_TYPEDEF_(0x80040066L);
//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
// Invalid STATDATA structure
//
static const int DV_E_STATDATA = _HRESULT_TYPEDEF_(0x80040067L);
//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
// Invalid lindex
//
static const int DV_E_LINDEX = _HRESULT_TYPEDEF_(0x80040068L);
//
// MessageId: DV_E_TYMED
//
// MessageText:
//
// Invalid tymed
//
static const int DV_E_TYMED = _HRESULT_TYPEDEF_(0x80040069L);
//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
// Invalid clipboard format
//
static const int DV_E_CLIPFORMAT = _HRESULT_TYPEDEF_(0x8004006AL);
//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
// Invalid aspect(s)
//
static const int DV_E_DVASPECT = _HRESULT_TYPEDEF_(0x8004006BL);
//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
// tdSize parameter of the DVTARGETDEVICE structure is invalid
//
static const int DV_E_DVTARGETDEVICE_SIZE = _HRESULT_TYPEDEF_(0x8004006CL);
//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
// Object doesn't support IViewObject interface
//
static const int DV_E_NOIVIEWOBJECT = _HRESULT_TYPEDEF_(0x8004006DL);
static const long DRAGDROP_E_FIRST = 0x80040100L;
static const int DRAGDROP_E_LAST = 0x8004010FL;
static const long DRAGDROP_S_FIRST = 0x00040100L;
static const int DRAGDROP_S_LAST = 0x0004010FL;
//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
// Trying to revoke a drop target that has not been registered
//
static const int DRAGDROP_E_NOTREGISTERED = _HRESULT_TYPEDEF_(0x80040100L);
//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
// This window has already been registered as a drop target
//
static const int DRAGDROP_E_ALREADYREGISTERED = _HRESULT_TYPEDEF_(0x80040101L);
//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
// Invalid window handle
//
static const int DRAGDROP_E_INVALIDHWND = _HRESULT_TYPEDEF_(0x80040102L);
static const long CLASSFACTORY_E_FIRST = 0x80040110L;
static const int CLASSFACTORY_E_LAST = 0x8004011FL;
static const long CLASSFACTORY_S_FIRST = 0x00040110L;
static const int CLASSFACTORY_S_LAST = 0x0004011FL;
//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
// Class does not support aggregation (or class object is remote)
//
static const int CLASS_E_NOAGGREGATION = _HRESULT_TYPEDEF_(0x80040110L);
//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
// ClassFactory cannot supply requested class
//
static const int CLASS_E_CLASSNOTAVAILABLE = _HRESULT_TYPEDEF_(0x80040111L);
//
// MessageId: CLASS_E_NOTLICENSED
//
// MessageText:
//
// Class is not licensed for use
//
static const int CLASS_E_NOTLICENSED = _HRESULT_TYPEDEF_(0x80040112L);
static const long MARSHAL_E_FIRST = 0x80040120L;
static const int MARSHAL_E_LAST = 0x8004012FL;
static const long MARSHAL_S_FIRST = 0x00040120L;
static const int MARSHAL_S_LAST = 0x0004012FL;
static const long DATA_E_FIRST = 0x80040130L;
static const int DATA_E_LAST = 0x8004013FL;
static const long DATA_S_FIRST = 0x00040130L;
static const int DATA_S_LAST = 0x0004013FL;
static const long VIEW_E_FIRST = 0x80040140L;
static const int VIEW_E_LAST = 0x8004014FL;
static const long VIEW_S_FIRST = 0x00040140L;
static const int VIEW_S_LAST = 0x0004014FL;
//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
// Error drawing view
//
static const int VIEW_E_DRAW = _HRESULT_TYPEDEF_(0x80040140L);
static const long REGDB_E_FIRST = 0x80040150L;
static const int REGDB_E_LAST = 0x8004015FL;
static const long REGDB_S_FIRST = 0x00040150L;
static const int REGDB_S_LAST = 0x0004015FL;
//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
// Could not read key from registry
//
static const int REGDB_E_READREGDB = _HRESULT_TYPEDEF_(0x80040150L);
//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
// Could not write key to registry
//
static const int REGDB_E_WRITEREGDB = _HRESULT_TYPEDEF_(0x80040151L);
//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
// Could not find the key in the registry
//
static const int REGDB_E_KEYMISSING = _HRESULT_TYPEDEF_(0x80040152L);
//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
// Invalid value for registry
//
static const int REGDB_E_INVALIDVALUE = _HRESULT_TYPEDEF_(0x80040153L);
//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
// Class not registered
//
static const int REGDB_E_CLASSNOTREG = _HRESULT_TYPEDEF_(0x80040154L);
//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
// Interface not registered
//
static const int REGDB_E_IIDNOTREG = _HRESULT_TYPEDEF_(0x80040155L);
//
// MessageId: REGDB_E_BADTHREADINGMODEL
//
// MessageText:
//
// Threading model entry is not valid
//
static const int REGDB_E_BADTHREADINGMODEL = _HRESULT_TYPEDEF_(0x80040156L);
static const long CAT_E_FIRST = 0x80040160L;
static const long CAT_E_LAST = 0x80040161L;
//
// MessageId: CAT_E_CATIDNOEXIST
//
// MessageText:
//
// CATID does not exist
//
static const int CAT_E_CATIDNOEXIST = _HRESULT_TYPEDEF_(0x80040160L);
//
// MessageId: CAT_E_NODESCRIPTION
//
// MessageText:
//
// Description not found
//
static const int CAT_E_NODESCRIPTION = _HRESULT_TYPEDEF_(0x80040161L);
////////////////////////////////////
//                                //
//     Class Store Error Codes    //
//                                //
////////////////////////////////////
static const long CS_E_FIRST = 0x80040164L;
static const int CS_E_LAST = 0x8004016FL;
//
// MessageId: CS_E_PACKAGE_NOTFOUND
//
// MessageText:
//
// No package in the software installation data in the Active Directory meets this criteria.
//
static const int CS_E_PACKAGE_NOTFOUND = _HRESULT_TYPEDEF_(0x80040164L);
//
// MessageId: CS_E_NOT_DELETABLE
//
// MessageText:
//
// Deleting this will break the referential integrity of the software installation data in the Active Directory.
//
static const int CS_E_NOT_DELETABLE = _HRESULT_TYPEDEF_(0x80040165L);
//
// MessageId: CS_E_CLASS_NOTFOUND
//
// MessageText:
//
// The CLSID was not found in the software installation data in the Active Directory.
//
static const int CS_E_CLASS_NOTFOUND = _HRESULT_TYPEDEF_(0x80040166L);
//
// MessageId: CS_E_INVALID_VERSION
//
// MessageText:
//
// The software installation data in the Active Directory is corrupt.
//
static const int CS_E_INVALID_VERSION = _HRESULT_TYPEDEF_(0x80040167L);
//
// MessageId: CS_E_NO_CLASSSTORE
//
// MessageText:
//
// There is no software installation data in the Active Directory.
//
static const int CS_E_NO_CLASSSTORE = _HRESULT_TYPEDEF_(0x80040168L);
//
// MessageId: CS_E_OBJECT_NOTFOUND
//
// MessageText:
//
// There is no software installation data object in the Active Directory.
//
static const int CS_E_OBJECT_NOTFOUND = _HRESULT_TYPEDEF_(0x80040169L);
//
// MessageId: CS_E_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
// The software installation data object in the Active Directory already exists.
//
static const int CS_E_OBJECT_ALREADY_EXISTS = _HRESULT_TYPEDEF_(0x8004016AL);
//
// MessageId: CS_E_INVALID_PATH
//
// MessageText:
//
// The path to the software installation data in the Active Directory is not correct.
//
static const int CS_E_INVALID_PATH = _HRESULT_TYPEDEF_(0x8004016BL);
//
// MessageId: CS_E_NETWORK_ERROR
//
// MessageText:
//
// A network error interrupted the operation.
//
static const int CS_E_NETWORK_ERROR = _HRESULT_TYPEDEF_(0x8004016CL);
//
// MessageId: CS_E_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
// The size of this object exceeds the maximum size set by the Administrator.
//
static const int CS_E_ADMIN_LIMIT_EXCEEDED = _HRESULT_TYPEDEF_(0x8004016DL);
//
// MessageId: CS_E_SCHEMA_MISMATCH
//
// MessageText:
//
// The schema for the software installation data in the Active Directory does not match the required schema.
//
static const int CS_E_SCHEMA_MISMATCH = _HRESULT_TYPEDEF_(0x8004016EL);
//
// MessageId: CS_E_INTERNAL_ERROR
//
// MessageText:
//
// An error occurred in the software installation data in the Active Directory.
//
static const int CS_E_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0x8004016FL);
static const long CACHE_E_FIRST = 0x80040170L;
static const int CACHE_E_LAST = 0x8004017FL;
static const long CACHE_S_FIRST = 0x00040170L;
static const int CACHE_S_LAST = 0x0004017FL;
//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
// Cache not updated
//
static const int CACHE_E_NOCACHE_UPDATED = _HRESULT_TYPEDEF_(0x80040170L);
static const long OLEOBJ_E_FIRST = 0x80040180L;
static const int OLEOBJ_E_LAST = 0x8004018FL;
static const long OLEOBJ_S_FIRST = 0x00040180L;
static const int OLEOBJ_S_LAST = 0x0004018FL;
//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
// No verbs for OLE object
//
static const int OLEOBJ_E_NOVERBS = _HRESULT_TYPEDEF_(0x80040180L);
//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
// Invalid verb for OLE object
//
static const int OLEOBJ_E_INVALIDVERB = _HRESULT_TYPEDEF_(0x80040181L);
static const long CLIENTSITE_E_FIRST = 0x80040190L;
static const int CLIENTSITE_E_LAST = 0x8004019FL;
static const long CLIENTSITE_S_FIRST = 0x00040190L;
static const int CLIENTSITE_S_LAST = 0x0004019FL;
//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
// Undo is not available
//
static const int INPLACE_E_NOTUNDOABLE = _HRESULT_TYPEDEF_(0x800401A0L);
//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
// Space for tools is not available
//
static const int INPLACE_E_NOTOOLSPACE = _HRESULT_TYPEDEF_(0x800401A1L);
static const long INPLACE_E_FIRST = 0x800401A0L;
static const int INPLACE_E_LAST = 0x800401AFL;
static const long INPLACE_S_FIRST = 0x000401A0L;
static const int INPLACE_S_LAST = 0x000401AFL;
static const long ENUM_E_FIRST = 0x800401B0L;
static const int ENUM_E_LAST = 0x800401BFL;
static const long ENUM_S_FIRST = 0x000401B0L;
static const int ENUM_S_LAST = 0x000401BFL;
static const long CONVERT10_E_FIRST = 0x800401C0L;
static const int CONVERT10_E_LAST = 0x800401CFL;
static const long CONVERT10_S_FIRST = 0x000401C0L;
static const int CONVERT10_S_LAST = 0x000401CFL;
//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
// OLESTREAM Get method failed
//
static const int CONVERT10_E_OLESTREAM_GET = _HRESULT_TYPEDEF_(0x800401C0L);
//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
// OLESTREAM Put method failed
//
static const int CONVERT10_E_OLESTREAM_PUT = _HRESULT_TYPEDEF_(0x800401C1L);
//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
// Contents of the OLESTREAM not in correct format
//
static const int CONVERT10_E_OLESTREAM_FMT = _HRESULT_TYPEDEF_(0x800401C2L);
//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
// There was an error in a Windows GDI call while converting the bitmap to a DIB
//
static const int CONVERT10_E_OLESTREAM_BITMAP_TO_DIB = _HRESULT_TYPEDEF_(0x800401C3L);
//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
// Contents of the IStorage not in correct format
//
static const int CONVERT10_E_STG_FMT = _HRESULT_TYPEDEF_(0x800401C4L);
//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
// Contents of IStorage is missing one of the standard streams
//
static const int CONVERT10_E_STG_NO_STD_STREAM = _HRESULT_TYPEDEF_(0x800401C5L);
//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
// There was an error in a Windows GDI call while converting the DIB to a bitmap.
//
static const int CONVERT10_E_STG_DIB_TO_BITMAP = _HRESULT_TYPEDEF_(0x800401C6L);
static const long CLIPBRD_E_FIRST = 0x800401D0L;
static const int CLIPBRD_E_LAST = 0x800401DFL;
static const long CLIPBRD_S_FIRST = 0x000401D0L;
static const int CLIPBRD_S_LAST = 0x000401DFL;
//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
// OpenClipboard Failed
//
static const int CLIPBRD_E_CANT_OPEN = _HRESULT_TYPEDEF_(0x800401D0L);
//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
// EmptyClipboard Failed
//
static const int CLIPBRD_E_CANT_EMPTY = _HRESULT_TYPEDEF_(0x800401D1L);
//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
// SetClipboard Failed
//
static const int CLIPBRD_E_CANT_SET = _HRESULT_TYPEDEF_(0x800401D2L);
//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
// Data on clipboard is invalid
//
static const int CLIPBRD_E_BAD_DATA = _HRESULT_TYPEDEF_(0x800401D3L);
//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
// CloseClipboard Failed
//
static const int CLIPBRD_E_CANT_CLOSE = _HRESULT_TYPEDEF_(0x800401D4L);
static const long MK_E_FIRST = 0x800401E0L;
static const int MK_E_LAST = 0x800401EFL;
static const long MK_S_FIRST = 0x000401E0L;
static const int MK_S_LAST = 0x000401EFL;
//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
// Moniker needs to be connected manually
//
static const int MK_E_CONNECTMANUALLY = _HRESULT_TYPEDEF_(0x800401E0L);
//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
// Operation exceeded deadline
//
static const int MK_E_EXCEEDEDDEADLINE = _HRESULT_TYPEDEF_(0x800401E1L);
//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
// Moniker needs to be generic
//
static const int MK_E_NEEDGENERIC = _HRESULT_TYPEDEF_(0x800401E2L);
//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
// Operation unavailable
//
static const int MK_E_UNAVAILABLE = _HRESULT_TYPEDEF_(0x800401E3L);
//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
// Invalid syntax
//
static const int MK_E_SYNTAX = _HRESULT_TYPEDEF_(0x800401E4L);
//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
// No object for moniker
//
static const int MK_E_NOOBJECT = _HRESULT_TYPEDEF_(0x800401E5L);
//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
// Bad extension for file
//
static const int MK_E_INVALIDEXTENSION = _HRESULT_TYPEDEF_(0x800401E6L);
//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
// Intermediate operation failed
//
static const int MK_E_INTERMEDIATEINTERFACENOTSUPPORTED = _HRESULT_TYPEDEF_(0x800401E7L);
//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
// Moniker is not bindable
//
static const int MK_E_NOTBINDABLE = _HRESULT_TYPEDEF_(0x800401E8L);
//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
// Moniker is not bound
//
static const int MK_E_NOTBOUND = _HRESULT_TYPEDEF_(0x800401E9L);
//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
// Moniker cannot open file
//
static const int MK_E_CANTOPENFILE = _HRESULT_TYPEDEF_(0x800401EAL);
//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
// User input required for operation to succeed
//
static const int MK_E_MUSTBOTHERUSER = _HRESULT_TYPEDEF_(0x800401EBL);
//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
// Moniker class has no inverse
//
static const int MK_E_NOINVERSE = _HRESULT_TYPEDEF_(0x800401ECL);
//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
// Moniker does not refer to storage
//
static const int MK_E_NOSTORAGE = _HRESULT_TYPEDEF_(0x800401EDL);
//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
// No common prefix
//
static const int MK_E_NOPREFIX = _HRESULT_TYPEDEF_(0x800401EEL);
//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
// Moniker could not be enumerated
//
static const int MK_E_ENUMERATION_FAILED = _HRESULT_TYPEDEF_(0x800401EFL);
static const long CO_E_FIRST = 0x800401F0L;
static const int CO_E_LAST = 0x800401FFL;
static const long CO_S_FIRST = 0x000401F0L;
static const int CO_S_LAST = 0x000401FFL;
//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
// CoInitialize has not been called.
//
static const int CO_E_NOTINITIALIZED = _HRESULT_TYPEDEF_(0x800401F0L);
//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
// CoInitialize has already been called.
//
static const int CO_E_ALREADYINITIALIZED = _HRESULT_TYPEDEF_(0x800401F1L);
//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
// Class of object cannot be determined
//
static const int CO_E_CANTDETERMINECLASS = _HRESULT_TYPEDEF_(0x800401F2L);
//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
// Invalid class string
//
static const int CO_E_CLASSSTRING = _HRESULT_TYPEDEF_(0x800401F3L);
//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
// Invalid interface string
//
static const int CO_E_IIDSTRING = _HRESULT_TYPEDEF_(0x800401F4L);
//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
// Application not found
//
static const int CO_E_APPNOTFOUND = _HRESULT_TYPEDEF_(0x800401F5L);
//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
// Application cannot be run more than once
//
static const int CO_E_APPSINGLEUSE = _HRESULT_TYPEDEF_(0x800401F6L);
//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
// Some error in application program
//
static const int CO_E_ERRORINAPP = _HRESULT_TYPEDEF_(0x800401F7L);
//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
// DLL for class not found
//
static const int CO_E_DLLNOTFOUND = _HRESULT_TYPEDEF_(0x800401F8L);
//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
// Error in the DLL
//
static const int CO_E_ERRORINDLL = _HRESULT_TYPEDEF_(0x800401F9L);
//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
// Wrong OS or OS version for application
//
static const int CO_E_WRONGOSFORAPP = _HRESULT_TYPEDEF_(0x800401FAL);
//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
// Object is not registered
//
static const int CO_E_OBJNOTREG = _HRESULT_TYPEDEF_(0x800401FBL);
//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
// Object is already registered
//
static const int CO_E_OBJISREG = _HRESULT_TYPEDEF_(0x800401FCL);
//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
// Object is not connected to server
//
static const int CO_E_OBJNOTCONNECTED = _HRESULT_TYPEDEF_(0x800401FDL);
//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
// Application was launched but it didn't register a class factory
//
static const int CO_E_APPDIDNTREG = _HRESULT_TYPEDEF_(0x800401FEL);
//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
// Object has been released
//
static const int CO_E_RELEASED = _HRESULT_TYPEDEF_(0x800401FFL);
static const long EVENT_E_FIRST = 0x80040200L;
static const int EVENT_E_LAST = 0x8004021FL;
static const long EVENT_S_FIRST = 0x00040200L;
static const int EVENT_S_LAST = 0x0004021FL;
//
// MessageId: EVENT_S_SOME_SUBSCRIBERS_FAILED
//
// MessageText:
//
// An event was able to invoke some but not all of the subscribers
//
static const int EVENT_S_SOME_SUBSCRIBERS_FAILED = _HRESULT_TYPEDEF_(0x00040200L);
//
// MessageId: EVENT_E_ALL_SUBSCRIBERS_FAILED
//
// MessageText:
//
// An event was unable to invoke any of the subscribers
//
static const int EVENT_E_ALL_SUBSCRIBERS_FAILED = _HRESULT_TYPEDEF_(0x80040201L);
//
// MessageId: EVENT_S_NOSUBSCRIBERS
//
// MessageText:
//
// An event was delivered but there were no subscribers
//
static const int EVENT_S_NOSUBSCRIBERS = _HRESULT_TYPEDEF_(0x00040202L);
//
// MessageId: EVENT_E_QUERYSYNTAX
//
// MessageText:
//
// A syntax error occurred trying to evaluate a query string
//
static const int EVENT_E_QUERYSYNTAX = _HRESULT_TYPEDEF_(0x80040203L);
//
// MessageId: EVENT_E_QUERYFIELD
//
// MessageText:
//
// An invalid field name was used in a query string
//
static const int EVENT_E_QUERYFIELD = _HRESULT_TYPEDEF_(0x80040204L);
//
// MessageId: EVENT_E_INTERNALEXCEPTION
//
// MessageText:
//
// An unexpected exception was raised
//
static const int EVENT_E_INTERNALEXCEPTION = _HRESULT_TYPEDEF_(0x80040205L);
//
// MessageId: EVENT_E_INTERNALERROR
//
// MessageText:
//
// An unexpected internal error was detected
//
static const int EVENT_E_INTERNALERROR = _HRESULT_TYPEDEF_(0x80040206L);
//
// MessageId: EVENT_E_INVALID_PER_USER_SID
//
// MessageText:
//
// The owner SID on a per-user subscription doesn't exist
//
static const int EVENT_E_INVALID_PER_USER_SID = _HRESULT_TYPEDEF_(0x80040207L);
//
// MessageId: EVENT_E_USER_EXCEPTION
//
// MessageText:
//
// A user-supplied component or subscriber raised an exception
//
static const int EVENT_E_USER_EXCEPTION = _HRESULT_TYPEDEF_(0x80040208L);
//
// MessageId: EVENT_E_TOO_MANY_METHODS
//
// MessageText:
//
// An interface has too many methods to fire events from
//
static const int EVENT_E_TOO_MANY_METHODS = _HRESULT_TYPEDEF_(0x80040209L);
//
// MessageId: EVENT_E_MISSING_EVENTCLASS
//
// MessageText:
//
// A subscription cannot be stored unless its event class already exists
//
static const int EVENT_E_MISSING_EVENTCLASS = _HRESULT_TYPEDEF_(0x8004020AL);
//
// MessageId: EVENT_E_NOT_ALL_REMOVED
//
// MessageText:
//
// Not all the objects requested could be removed
//
static const int EVENT_E_NOT_ALL_REMOVED = _HRESULT_TYPEDEF_(0x8004020BL);
//
// MessageId: EVENT_E_COMPLUS_NOT_INSTALLED
//
// MessageText:
//
// COM+ is required for this operation, but is not installed
//
static const int EVENT_E_COMPLUS_NOT_INSTALLED = _HRESULT_TYPEDEF_(0x8004020CL);
//
// MessageId: EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT
//
// MessageText:
//
// Cannot modify or delete an object that was not added using the COM+ Admin SDK
//
static const int EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT = _HRESULT_TYPEDEF_(0x8004020DL);
//
// MessageId: EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT
//
// MessageText:
//
// Cannot modify or delete an object that was added using the COM+ Admin SDK
//
static const int EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT = _HRESULT_TYPEDEF_(0x8004020EL);
//
// MessageId: EVENT_E_INVALID_EVENT_CLASS_PARTITION
//
// MessageText:
//
// The event class for this subscription is in an invalid partition
//
static const int EVENT_E_INVALID_EVENT_CLASS_PARTITION = _HRESULT_TYPEDEF_(0x8004020FL);
//
// MessageId: EVENT_E_PER_USER_SID_NOT_LOGGED_ON
//
// MessageText:
//
// The owner of the PerUser subscription is not logged on to the system specified
//
static const int EVENT_E_PER_USER_SID_NOT_LOGGED_ON = _HRESULT_TYPEDEF_(0x80040210L);
static const int XACT_E_FIRST = 0x8004D000;
static const int XACT_E_LAST = 0x8004D02B;
static const int XACT_S_FIRST = 0x0004D000;
static const int XACT_S_LAST = 0x0004D010;
//
// MessageId: XACT_E_ALREADYOTHERSINGLEPHASE
//
// MessageText:
//
// Another single phase resource manager has already been enlisted in this transaction.
//
static const int XACT_E_ALREADYOTHERSINGLEPHASE = _HRESULT_TYPEDEF_(0x8004D000L);
//
// MessageId: XACT_E_CANTRETAIN
//
// MessageText:
//
// A retaining commit or abort is not supported
//
static const int XACT_E_CANTRETAIN = _HRESULT_TYPEDEF_(0x8004D001L);
//
// MessageId: XACT_E_COMMITFAILED
//
// MessageText:
//
// The transaction failed to commit for an unknown reason. The transaction was aborted.
//
static const int XACT_E_COMMITFAILED = _HRESULT_TYPEDEF_(0x8004D002L);
//
// MessageId: XACT_E_COMMITPREVENTED
//
// MessageText:
//
// Cannot call commit on this transaction object because the calling application did not initiate the transaction.
//
static const int XACT_E_COMMITPREVENTED = _HRESULT_TYPEDEF_(0x8004D003L);
//
// MessageId: XACT_E_HEURISTICABORT
//
// MessageText:
//
// Instead of committing, the resource heuristically aborted.
//
static const int XACT_E_HEURISTICABORT = _HRESULT_TYPEDEF_(0x8004D004L);
//
// MessageId: XACT_E_HEURISTICCOMMIT
//
// MessageText:
//
// Instead of aborting, the resource heuristically committed.
//
static const int XACT_E_HEURISTICCOMMIT = _HRESULT_TYPEDEF_(0x8004D005L);
//
// MessageId: XACT_E_HEURISTICDAMAGE
//
// MessageText:
//
// Some of the states of the resource were committed while others were aborted, likely because of heuristic decisions.
//
static const int XACT_E_HEURISTICDAMAGE = _HRESULT_TYPEDEF_(0x8004D006L);
//
// MessageId: XACT_E_HEURISTICDANGER
//
// MessageText:
//
// Some of the states of the resource may have been committed while others may have been aborted, likely because of heuristic decisions.
//
static const int XACT_E_HEURISTICDANGER = _HRESULT_TYPEDEF_(0x8004D007L);
//
// MessageId: XACT_E_ISOLATIONLEVEL
//
// MessageText:
//
// The requested isolation level is not valid or supported.
//
static const int XACT_E_ISOLATIONLEVEL = _HRESULT_TYPEDEF_(0x8004D008L);
//
// MessageId: XACT_E_NOASYNC
//
// MessageText:
//
// The transaction manager doesn't support an asynchronous operation for this method.
//
static const int XACT_E_NOASYNC = _HRESULT_TYPEDEF_(0x8004D009L);
//
// MessageId: XACT_E_NOENLIST
//
// MessageText:
//
// Unable to enlist in the transaction.
//
static const int XACT_E_NOENLIST = _HRESULT_TYPEDEF_(0x8004D00AL);
//
// MessageId: XACT_E_NOISORETAIN
//
// MessageText:
//
// The requested semantics of retention of isolation across retaining commit and abort boundaries cannot be supported by this transaction implementation, or isoFlags was not equal to zero.
//
static const int XACT_E_NOISORETAIN = _HRESULT_TYPEDEF_(0x8004D00BL);
//
// MessageId: XACT_E_NORESOURCE
//
// MessageText:
//
// There is no resource presently associated with this enlistment
//
static const int XACT_E_NORESOURCE = _HRESULT_TYPEDEF_(0x8004D00CL);
//
// MessageId: XACT_E_NOTCURRENT
//
// MessageText:
//
// The transaction failed to commit due to the failure of optimistic concurrency control in at least one of the resource managers.
//
static const int XACT_E_NOTCURRENT = _HRESULT_TYPEDEF_(0x8004D00DL);
//
// MessageId: XACT_E_NOTRANSACTION
//
// MessageText:
//
// The transaction has already been implicitly or explicitly committed or aborted
//
static const int XACT_E_NOTRANSACTION = _HRESULT_TYPEDEF_(0x8004D00EL);
//
// MessageId: XACT_E_NOTSUPPORTED
//
// MessageText:
//
// An invalid combination of flags was specified
//
static const int XACT_E_NOTSUPPORTED = _HRESULT_TYPEDEF_(0x8004D00FL);
//
// MessageId: XACT_E_UNKNOWNRMGRID
//
// MessageText:
//
// The resource manager id is not associated with this transaction or the transaction manager.
//
static const int XACT_E_UNKNOWNRMGRID = _HRESULT_TYPEDEF_(0x8004D010L);
//
// MessageId: XACT_E_WRONGSTATE
//
// MessageText:
//
// This method was called in the wrong state
//
static const int XACT_E_WRONGSTATE = _HRESULT_TYPEDEF_(0x8004D011L);
//
// MessageId: XACT_E_WRONGUOW
//
// MessageText:
//
// The indicated unit of work does not match the unit of work expected by the resource manager.
//
static const int XACT_E_WRONGUOW = _HRESULT_TYPEDEF_(0x8004D012L);
//
// MessageId: XACT_E_XTIONEXISTS
//
// MessageText:
//
// An enlistment in a transaction already exists.
//
static const int XACT_E_XTIONEXISTS = _HRESULT_TYPEDEF_(0x8004D013L);
//
// MessageId: XACT_E_NOIMPORTOBJECT
//
// MessageText:
//
// An import object for the transaction could not be found.
//
static const int XACT_E_NOIMPORTOBJECT = _HRESULT_TYPEDEF_(0x8004D014L);
//
// MessageId: XACT_E_INVALIDCOOKIE
//
// MessageText:
//
// The transaction cookie is invalid.
//
static const int XACT_E_INVALIDCOOKIE = _HRESULT_TYPEDEF_(0x8004D015L);
//
// MessageId: XACT_E_INDOUBT
//
// MessageText:
//
// The transaction status is in doubt. A communication failure occurred, or a transaction manager or resource manager has failed
//
static const int XACT_E_INDOUBT = _HRESULT_TYPEDEF_(0x8004D016L);
//
// MessageId: XACT_E_NOTIMEOUT
//
// MessageText:
//
// A time-out was specified, but time-outs are not supported.
//
static const int XACT_E_NOTIMEOUT = _HRESULT_TYPEDEF_(0x8004D017L);
//
// MessageId: XACT_E_ALREADYINPROGRESS
//
// MessageText:
//
// The requested operation is already in progress for the transaction.
//
static const int XACT_E_ALREADYINPROGRESS = _HRESULT_TYPEDEF_(0x8004D018L);
//
// MessageId: XACT_E_ABORTED
//
// MessageText:
//
// The transaction has already been aborted.
//
static const int XACT_E_ABORTED = _HRESULT_TYPEDEF_(0x8004D019L);
//
// MessageId: XACT_E_LOGFULL
//
// MessageText:
//
// The Transaction Manager returned a log full error.
//
static const int XACT_E_LOGFULL = _HRESULT_TYPEDEF_(0x8004D01AL);
//
// MessageId: XACT_E_TMNOTAVAILABLE
//
// MessageText:
//
// The Transaction Manager is not available.
//
static const int XACT_E_TMNOTAVAILABLE = _HRESULT_TYPEDEF_(0x8004D01BL);
//
// MessageId: XACT_E_CONNECTION_DOWN
//
// MessageText:
//
// A connection with the transaction manager was lost.
//
static const int XACT_E_CONNECTION_DOWN = _HRESULT_TYPEDEF_(0x8004D01CL);
//
// MessageId: XACT_E_CONNECTION_DENIED
//
// MessageText:
//
// A request to establish a connection with the transaction manager was denied.
//
static const int XACT_E_CONNECTION_DENIED = _HRESULT_TYPEDEF_(0x8004D01DL);
//
// MessageId: XACT_E_REENLISTTIMEOUT
//
// MessageText:
//
// Resource manager reenlistment to determine transaction status timed out.
//
static const int XACT_E_REENLISTTIMEOUT = _HRESULT_TYPEDEF_(0x8004D01EL);
//
// MessageId: XACT_E_TIP_CONNECT_FAILED
//
// MessageText:
//
// This transaction manager failed to establish a connection with another TIP transaction manager.
//
static const int XACT_E_TIP_CONNECT_FAILED = _HRESULT_TYPEDEF_(0x8004D01FL);
//
// MessageId: XACT_E_TIP_PROTOCOL_ERROR
//
// MessageText:
//
// This transaction manager encountered a protocol error with another TIP transaction manager.
//
static const int XACT_E_TIP_PROTOCOL_ERROR = _HRESULT_TYPEDEF_(0x8004D020L);
//
// MessageId: XACT_E_TIP_PULL_FAILED
//
// MessageText:
//
// This transaction manager could not propagate a transaction from another TIP transaction manager.
//
static const int XACT_E_TIP_PULL_FAILED = _HRESULT_TYPEDEF_(0x8004D021L);
//
// MessageId: XACT_E_DEST_TMNOTAVAILABLE
//
// MessageText:
//
// The Transaction Manager on the destination machine is not available.
//
static const int XACT_E_DEST_TMNOTAVAILABLE = _HRESULT_TYPEDEF_(0x8004D022L);
//
// MessageId: XACT_E_TIP_DISABLED
//
// MessageText:
//
// The Transaction Manager has disabled its support for TIP.
//
static const int XACT_E_TIP_DISABLED = _HRESULT_TYPEDEF_(0x8004D023L);
//
// MessageId: XACT_E_NETWORK_TX_DISABLED
//
// MessageText:
//
// The transaction manager has disabled its support for remote/network transactions.
//
static const int XACT_E_NETWORK_TX_DISABLED = _HRESULT_TYPEDEF_(0x8004D024L);
//
// MessageId: XACT_E_PARTNER_NETWORK_TX_DISABLED
//
// MessageText:
//
// The partner transaction manager has disabled its support for remote/network transactions.
//
static const int XACT_E_PARTNER_NETWORK_TX_DISABLED = _HRESULT_TYPEDEF_(0x8004D025L);
//
// MessageId: XACT_E_XA_TX_DISABLED
//
// MessageText:
//
// The transaction manager has disabled its support for XA transactions.
//
static const int XACT_E_XA_TX_DISABLED = _HRESULT_TYPEDEF_(0x8004D026L);
//
// MessageId: XACT_E_UNABLE_TO_READ_DTC_CONFIG
//
// MessageText:
//
// MSDTC was unable to read its configuration information.
//
static const int XACT_E_UNABLE_TO_READ_DTC_CONFIG = _HRESULT_TYPEDEF_(0x8004D027L);
//
// MessageId: XACT_E_UNABLE_TO_LOAD_DTC_PROXY
//
// MessageText:
//
// MSDTC was unable to load the dtc proxy dll.
//
static const int XACT_E_UNABLE_TO_LOAD_DTC_PROXY = _HRESULT_TYPEDEF_(0x8004D028L);
//
// MessageId: XACT_E_ABORTING
//
// MessageText:
//
// The local transaction has aborted.
//
static const int XACT_E_ABORTING = _HRESULT_TYPEDEF_(0x8004D029L);
//
// MessageId: XACT_E_PUSH_COMM_FAILURE
//
// MessageText:
//
// The MSDTC transaction manager was unable to push the transaction to the destination transaction manager due to communication problems. Possible causes are: a firewall is present and it doesn't have an exception for the MSDTC process, the two machines cannot find each other by their NetBIOS names, or the support for network transactions is not enabled for one of the two transaction managers.
//
static const int XACT_E_PUSH_COMM_FAILURE = _HRESULT_TYPEDEF_(0x8004D02AL);
//
// MessageId: XACT_E_PULL_COMM_FAILURE
//
// MessageText:
//
// The MSDTC transaction manager was unable to pull the transaction from the source transaction manager due to communication problems. Possible causes are: a firewall is present and it doesn't have an exception for the MSDTC process, the two machines cannot find each other by their NetBIOS names, or the support for network transactions is not enabled for one of the two transaction managers.
//
static const int XACT_E_PULL_COMM_FAILURE = _HRESULT_TYPEDEF_(0x8004D02BL);
//
// MessageId: XACT_E_LU_TX_DISABLED
//
// MessageText:
//
// The MSDTC transaction manager has disabled its support for SNA LU 6.2 transactions.
//
static const int XACT_E_LU_TX_DISABLED = _HRESULT_TYPEDEF_(0x8004D02CL);
//
// TXF & CRM errors start 4d080.
//
// MessageId: XACT_E_CLERKNOTFOUND
//
// MessageText:
//
//  XACT_E_CLERKNOTFOUND
//
static const int XACT_E_CLERKNOTFOUND = _HRESULT_TYPEDEF_(0x8004D080L);
//
// MessageId: XACT_E_CLERKEXISTS
//
// MessageText:
//
//  XACT_E_CLERKEXISTS
//
static const int XACT_E_CLERKEXISTS = _HRESULT_TYPEDEF_(0x8004D081L);
//
// MessageId: XACT_E_RECOVERYINPROGRESS
//
// MessageText:
//
//  XACT_E_RECOVERYINPROGRESS
//
static const int XACT_E_RECOVERYINPROGRESS = _HRESULT_TYPEDEF_(0x8004D082L);
//
// MessageId: XACT_E_TRANSACTIONCLOSED
//
// MessageText:
//
//  XACT_E_TRANSACTIONCLOSED
//
static const int XACT_E_TRANSACTIONCLOSED = _HRESULT_TYPEDEF_(0x8004D083L);
//
// MessageId: XACT_E_INVALIDLSN
//
// MessageText:
//
//  XACT_E_INVALIDLSN
//
static const int XACT_E_INVALIDLSN = _HRESULT_TYPEDEF_(0x8004D084L);
//
// MessageId: XACT_E_REPLAYREQUEST
//
// MessageText:
//
//  XACT_E_REPLAYREQUEST
//
static const int XACT_E_REPLAYREQUEST = _HRESULT_TYPEDEF_(0x8004D085L);
// Begin XACT_DTC_CONSTANTS enumerated values defined in txdtc.h
// SymbolicName=XACT_E_CONNECTION_REQUEST_DENIED
//
// MessageId: 0x8004D100L (No symbolic name defined)
//
// MessageText:
//
// The request to connect to the specified transaction coordinator was denied.
//
// SymbolicName=XACT_E_TOOMANY_ENLISTMENTS
//
// MessageId: 0x8004D101L (No symbolic name defined)
//
// MessageText:
//
// The maximum number of enlistments for the specified transaction has been reached.
//
// SymbolicName=XACT_E_DUPLICATE_GUID
//
// MessageId: 0x8004D102L (No symbolic name defined)
//
// MessageText:
//
// A resource manager with the same identifier is already registered with the specified transaction coordinator.
//
// SymbolicName=XACT_E_NOTSINGLEPHASE
//
// MessageId: 0x8004D103L (No symbolic name defined)
//
// MessageText:
//
// The prepare request given was not eligible for single phase optimizations.
//
// SymbolicName=XACT_E_RECOVERYALREADYDONE
//
// MessageId: 0x8004D104L (No symbolic name defined)
//
// MessageText:
//
// RecoveryComplete has already been called for the given resource manager.
//
// SymbolicName=XACT_E_PROTOCOL
//
// MessageId: 0x8004D105L (No symbolic name defined)
//
// MessageText:
//
// The interface call made was incorrect for the current state of the protocol.
//
// SymbolicName=XACT_E_RM_FAILURE
//
// MessageId: 0x8004D106L (No symbolic name defined)
//
// MessageText:
//
// xa_open call failed for the XA resource.
//
// SymbolicName=XACT_E_RECOVERY_FAILED
//
// MessageId: 0x8004D107L (No symbolic name defined)
//
// MessageText:
//
// xa_recover call failed for the XA resource.
//
// SymbolicName=XACT_E_LU_NOT_FOUND
//
// MessageId: 0x8004D108L (No symbolic name defined)
//
// MessageText:
//
// The Logical Unit of Work specified cannot be found.
//
// SymbolicName=XACT_E_DUPLICATE_LU
//
// MessageId: 0x8004D109L (No symbolic name defined)
//
// MessageText:
//
// The specified Logical Unit of Work already exists.
//
// SymbolicName=XACT_E_LU_NOT_CONNECTED
//
// MessageId: 0x8004D10AL (No symbolic name defined)
//
// MessageText:
//
// Subordinate creation failed. The specified Logical Unit of Work was not connected.
//
// SymbolicName=XACT_E_DUPLICATE_TRANSID
//
// MessageId: 0x8004D10BL (No symbolic name defined)
//
// MessageText:
//
// A transaction with the given identifier already exists.
//
// SymbolicName=XACT_E_LU_BUSY
//
// MessageId: 0x8004D10CL (No symbolic name defined)
//
// MessageText:
//
// The resource is in use.
//
// SymbolicName=XACT_E_LU_NO_RECOVERY_PROCESS
//
// MessageId: 0x8004D10DL (No symbolic name defined)
//
// MessageText:
//
// The LU Recovery process is down.
//
// SymbolicName=XACT_E_LU_DOWN
//
// MessageId: 0x8004D10EL (No symbolic name defined)
//
// MessageText:
//
// The remote session was lost.
//
// SymbolicName=XACT_E_LU_RECOVERING
//
// MessageId: 0x8004D10FL (No symbolic name defined)
//
// MessageText:
//
// The resource is currently recovering.
//
// SymbolicName=XACT_E_LU_RECOVERY_MISMATCH
//
// MessageId: 0x8004D110L (No symbolic name defined)
//
// MessageText:
//
// There was a mismatch in driving recovery.
//
// SymbolicName=XACT_E_RM_UNAVAILABLE
//
// MessageId: 0x8004D111L (No symbolic name defined)
//
// MessageText:
//
// An error occurred with the XA resource.
//
// End XACT_DTC_CONSTANTS enumerated values defined in txdtc.h
//
// OleTx Success codes.
//
//
// MessageId: XACT_S_ASYNC
//
// MessageText:
//
// An asynchronous operation was specified. The operation has begun, but its outcome is not known yet.
//
static const int XACT_S_ASYNC = _HRESULT_TYPEDEF_(0x0004D000L);
//
// MessageId: XACT_S_DEFECT
//
// MessageText:
//
//  XACT_S_DEFECT
//
static const int XACT_S_DEFECT = _HRESULT_TYPEDEF_(0x0004D001L);
//
// MessageId: XACT_S_READONLY
//
// MessageText:
//
// The method call succeeded because the transaction was read-only.
//
static const int XACT_S_READONLY = _HRESULT_TYPEDEF_(0x0004D002L);
//
// MessageId: XACT_S_SOMENORETAIN
//
// MessageText:
//
// The transaction was successfully aborted. However, this is a coordinated transaction, and some number of enlisted resources were aborted outright because they could not support abort-retaining semantics
//
static const int XACT_S_SOMENORETAIN = _HRESULT_TYPEDEF_(0x0004D003L);
//
// MessageId: XACT_S_OKINFORM
//
// MessageText:
//
// No changes were made during this call, but the sink wants another chance to look if any other sinks make further changes.
//
static const int XACT_S_OKINFORM = _HRESULT_TYPEDEF_(0x0004D004L);
//
// MessageId: XACT_S_MADECHANGESCONTENT
//
// MessageText:
//
// The sink is content and wishes the transaction to proceed. Changes were made to one or more resources during this call.
//
static const int XACT_S_MADECHANGESCONTENT = _HRESULT_TYPEDEF_(0x0004D005L);
//
// MessageId: XACT_S_MADECHANGESINFORM
//
// MessageText:
//
// The sink is for the moment and wishes the transaction to proceed, but if other changes are made following this return by other event sinks then this sink wants another chance to look
//
static const int XACT_S_MADECHANGESINFORM = _HRESULT_TYPEDEF_(0x0004D006L);
//
// MessageId: XACT_S_ALLNORETAIN
//
// MessageText:
//
// The transaction was successfully aborted. However, the abort was non-retaining.
//
static const int XACT_S_ALLNORETAIN = _HRESULT_TYPEDEF_(0x0004D007L);
//
// MessageId: XACT_S_ABORTING
//
// MessageText:
//
// An abort operation was already in progress.
//
static const int XACT_S_ABORTING = _HRESULT_TYPEDEF_(0x0004D008L);
//
// MessageId: XACT_S_SINGLEPHASE
//
// MessageText:
//
// The resource manager has performed a single-phase commit of the transaction.
//
static const int XACT_S_SINGLEPHASE = _HRESULT_TYPEDEF_(0x0004D009L);
//
// MessageId: XACT_S_LOCALLY_OK
//
// MessageText:
//
// The local transaction has not aborted.
//
static const int XACT_S_LOCALLY_OK = _HRESULT_TYPEDEF_(0x0004D00AL);
//
// MessageId: XACT_S_LASTRESOURCEMANAGER
//
// MessageText:
//
// The resource manager has requested to be the coordinator (last resource manager) for the transaction.
//
static const int XACT_S_LASTRESOURCEMANAGER = _HRESULT_TYPEDEF_(0x0004D010L);
static const long CONTEXT_E_FIRST = 0x8004E000L;
static const int CONTEXT_E_LAST = 0x8004E02FL;
static const long CONTEXT_S_FIRST = 0x0004E000L;
static const int CONTEXT_S_LAST = 0x0004E02FL;
//
// MessageId: CONTEXT_E_ABORTED
//
// MessageText:
//
// The root transaction wanted to commit, but transaction aborted
//
static const int CONTEXT_E_ABORTED = _HRESULT_TYPEDEF_(0x8004E002L);
//
// MessageId: CONTEXT_E_ABORTING
//
// MessageText:
//
// You made a method call on a COM+ component that has a transaction that has already aborted or in the process of aborting.
//
static const int CONTEXT_E_ABORTING = _HRESULT_TYPEDEF_(0x8004E003L);
//
// MessageId: CONTEXT_E_NOCONTEXT
//
// MessageText:
//
// There is no MTS object context
//
static const int CONTEXT_E_NOCONTEXT = _HRESULT_TYPEDEF_(0x8004E004L);
//
// MessageId: CONTEXT_E_WOULD_DEADLOCK
//
// MessageText:
//
// The component is configured to use synchronization and this method call would cause a deadlock to occur.
//
static const int CONTEXT_E_WOULD_DEADLOCK = _HRESULT_TYPEDEF_(0x8004E005L);
//
// MessageId: CONTEXT_E_SYNCH_TIMEOUT
//
// MessageText:
//
// The component is configured to use synchronization and a thread has timed out waiting to enter the context.
//
static const int CONTEXT_E_SYNCH_TIMEOUT = _HRESULT_TYPEDEF_(0x8004E006L);
//
// MessageId: CONTEXT_E_OLDREF
//
// MessageText:
//
// You made a method call on a COM+ component that has a transaction that has already committed or aborted.
//
static const int CONTEXT_E_OLDREF = _HRESULT_TYPEDEF_(0x8004E007L);
//
// MessageId: CONTEXT_E_ROLENOTFOUND
//
// MessageText:
//
// The specified role was not configured for the application
//
static const int CONTEXT_E_ROLENOTFOUND = _HRESULT_TYPEDEF_(0x8004E00CL);
//
// MessageId: CONTEXT_E_TMNOTAVAILABLE
//
// MessageText:
//
// COM+ was unable to talk to the Microsoft Distributed Transaction Coordinator
//
static const int CONTEXT_E_TMNOTAVAILABLE = _HRESULT_TYPEDEF_(0x8004E00FL);
//
// MessageId: CO_E_ACTIVATIONFAILED
//
// MessageText:
//
// An unexpected error occurred during COM+ Activation.
//
static const int CO_E_ACTIVATIONFAILED = _HRESULT_TYPEDEF_(0x8004E021L);
//
// MessageId: CO_E_ACTIVATIONFAILED_EVENTLOGGED
//
// MessageText:
//
// COM+ Activation failed. Check the event log for more information
//
static const int CO_E_ACTIVATIONFAILED_EVENTLOGGED = _HRESULT_TYPEDEF_(0x8004E022L);
//
// MessageId: CO_E_ACTIVATIONFAILED_CATALOGERROR
//
// MessageText:
//
// COM+ Activation failed due to a catalog or configuration error.
//
static const int CO_E_ACTIVATIONFAILED_CATALOGERROR = _HRESULT_TYPEDEF_(0x8004E023L);
//
// MessageId: CO_E_ACTIVATIONFAILED_TIMEOUT
//
// MessageText:
//
// COM+ activation failed because the activation could not be completed in the specified amount of time.
//
static const int CO_E_ACTIVATIONFAILED_TIMEOUT = _HRESULT_TYPEDEF_(0x8004E024L);
//
// MessageId: CO_E_INITIALIZATIONFAILED
//
// MessageText:
//
// COM+ Activation failed because an initialization function failed. Check the event log for more information.
//
static const int CO_E_INITIALIZATIONFAILED = _HRESULT_TYPEDEF_(0x8004E025L);
//
// MessageId: CONTEXT_E_NOJIT
//
// MessageText:
//
// The requested operation requires that JIT be in the current context and it is not
//
static const int CONTEXT_E_NOJIT = _HRESULT_TYPEDEF_(0x8004E026L);
//
// MessageId: CONTEXT_E_NOTRANSACTION
//
// MessageText:
//
// The requested operation requires that the current context have a Transaction, and it does not
//
static const int CONTEXT_E_NOTRANSACTION = _HRESULT_TYPEDEF_(0x8004E027L);
//
// MessageId: CO_E_THREADINGMODEL_CHANGED
//
// MessageText:
//
// The components threading model has changed after install into a COM+ Application. Please re-install component.
//
static const int CO_E_THREADINGMODEL_CHANGED = _HRESULT_TYPEDEF_(0x8004E028L);
//
// MessageId: CO_E_NOIISINTRINSICS
//
// MessageText:
//
// IIS intrinsics not available. Start your work with IIS.
//
static const int CO_E_NOIISINTRINSICS = _HRESULT_TYPEDEF_(0x8004E029L);
//
// MessageId: CO_E_NOCOOKIES
//
// MessageText:
//
// An attempt to write a cookie failed.
//
static const int CO_E_NOCOOKIES = _HRESULT_TYPEDEF_(0x8004E02AL);
//
// MessageId: CO_E_DBERROR
//
// MessageText:
//
// An attempt to use a database generated a database specific error.
//
static const int CO_E_DBERROR = _HRESULT_TYPEDEF_(0x8004E02BL);
//
// MessageId: CO_E_NOTPOOLED
//
// MessageText:
//
// The COM+ component you created must use object pooling to work.
//
static const int CO_E_NOTPOOLED = _HRESULT_TYPEDEF_(0x8004E02CL);
//
// MessageId: CO_E_NOTCONSTRUCTED
//
// MessageText:
//
// The COM+ component you created must use object construction to work correctly.
//
static const int CO_E_NOTCONSTRUCTED = _HRESULT_TYPEDEF_(0x8004E02DL);
//
// MessageId: CO_E_NOSYNCHRONIZATION
//
// MessageText:
//
// The COM+ component requires synchronization, and it is not configured for it.
//
static const int CO_E_NOSYNCHRONIZATION = _HRESULT_TYPEDEF_(0x8004E02EL);
//
// MessageId: CO_E_ISOLEVELMISMATCH
//
// MessageText:
//
// The TxIsolation Level property for the COM+ component being created is stronger than the TxIsolationLevel for the "root" component for the transaction. The creation failed.
//
static const int CO_E_ISOLEVELMISMATCH = _HRESULT_TYPEDEF_(0x8004E02FL);
//
// MessageId: CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED
//
// MessageText:
//
// The component attempted to make a cross-context call between invocations of EnterTransactionScopeand ExitTransactionScope. This is not allowed. Cross-context calls cannot be made while inside of a transaction scope.
//
static const int CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x8004E030L);
//
// MessageId: CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED
//
// MessageText:
//
// The component made a call to EnterTransactionScope, but did not make a corresponding call to ExitTransactionScope before returning.
//
static const int CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED = _HRESULT_TYPEDEF_(0x8004E031L);
//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
// Use the registry database to provide the requested information
//
static const int OLE_S_USEREG = _HRESULT_TYPEDEF_(0x00040000L);
//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
// Success, but static
//
static const int OLE_S_STATIC = _HRESULT_TYPEDEF_(0x00040001L);
//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
// Macintosh clipboard format
//
static const int OLE_S_MAC_CLIPFORMAT = _HRESULT_TYPEDEF_(0x00040002L);
//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
// Successful drop took place
//
static const int DRAGDROP_S_DROP = _HRESULT_TYPEDEF_(0x00040100L);
//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
// Drag-drop operation canceled
//
static const int DRAGDROP_S_CANCEL = _HRESULT_TYPEDEF_(0x00040101L);
//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
// Use the default cursor
//
static const int DRAGDROP_S_USEDEFAULTCURSORS = _HRESULT_TYPEDEF_(0x00040102L);
//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
// Data has same FORMATETC
//
static const int DATA_S_SAMEFORMATETC = _HRESULT_TYPEDEF_(0x00040130L);
//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
// View is already frozen
//
static const int VIEW_S_ALREADY_FROZEN = _HRESULT_TYPEDEF_(0x00040140L);
//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
// FORMATETC not supported
//
static const int CACHE_S_FORMATETC_NOTSUPPORTED = _HRESULT_TYPEDEF_(0x00040170L);
//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
// Same cache
//
static const int CACHE_S_SAMECACHE = _HRESULT_TYPEDEF_(0x00040171L);
//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
// Some cache(s) not updated
//
static const int CACHE_S_SOMECACHES_NOTUPDATED = _HRESULT_TYPEDEF_(0x00040172L);
//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
// Invalid verb for OLE object
//
static const int OLEOBJ_S_INVALIDVERB = _HRESULT_TYPEDEF_(0x00040180L);
//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
// Verb number is valid but verb cannot be done now
//
static const int OLEOBJ_S_CANNOT_DOVERB_NOW = _HRESULT_TYPEDEF_(0x00040181L);
//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
// Invalid window handle passed
//
static const int OLEOBJ_S_INVALIDHWND = _HRESULT_TYPEDEF_(0x00040182L);
//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
// Message is too long; some of it had to be truncated before displaying
//
static const int INPLACE_S_TRUNCATED = _HRESULT_TYPEDEF_(0x000401A0L);
//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
// Unable to convert OLESTREAM to IStorage
//
static const int CONVERT10_S_NO_PRESENTATION = _HRESULT_TYPEDEF_(0x000401C0L);
//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
// Moniker reduced to itself
//
static const int MK_S_REDUCED_TO_SELF = _HRESULT_TYPEDEF_(0x000401E2L);
//
// MessageId: MK_S_ME
//
// MessageText:
//
// Common prefix is this moniker
//
static const int MK_S_ME = _HRESULT_TYPEDEF_(0x000401E4L);
//
// MessageId: MK_S_HIM
//
// MessageText:
//
// Common prefix is input moniker
//
static const int MK_S_HIM = _HRESULT_TYPEDEF_(0x000401E5L);
//
// MessageId: MK_S_US
//
// MessageText:
//
// Common prefix is both monikers
//
static const int MK_S_US = _HRESULT_TYPEDEF_(0x000401E6L);
//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
// Moniker is already registered in running object table
//
static const int MK_S_MONIKERALREADYREGISTERED = _HRESULT_TYPEDEF_(0x000401E7L);
//
// Task Scheduler errors
//
//
// MessageId: SCHED_S_TASK_READY
//
// MessageText:
//
// The task is ready to run at its next scheduled time.
//
static const int SCHED_S_TASK_READY = _HRESULT_TYPEDEF_(0x00041300L);
//
// MessageId: SCHED_S_TASK_RUNNING
//
// MessageText:
//
// The task is currently running.
//
static const int SCHED_S_TASK_RUNNING = _HRESULT_TYPEDEF_(0x00041301L);
//
// MessageId: SCHED_S_TASK_DISABLED
//
// MessageText:
//
// The task will not run at the scheduled times because it has been disabled.
//
static const int SCHED_S_TASK_DISABLED = _HRESULT_TYPEDEF_(0x00041302L);
//
// MessageId: SCHED_S_TASK_HAS_NOT_RUN
//
// MessageText:
//
// The task has not yet run.
//
static const int SCHED_S_TASK_HAS_NOT_RUN = _HRESULT_TYPEDEF_(0x00041303L);
//
// MessageId: SCHED_S_TASK_NO_MORE_RUNS
//
// MessageText:
//
// There are no more runs scheduled for this task.
//
static const int SCHED_S_TASK_NO_MORE_RUNS = _HRESULT_TYPEDEF_(0x00041304L);
//
// MessageId: SCHED_S_TASK_NOT_SCHEDULED
//
// MessageText:
//
// One or more of the properties that are needed to run this task on a schedule have not been set.
//
static const int SCHED_S_TASK_NOT_SCHEDULED = _HRESULT_TYPEDEF_(0x00041305L);
//
// MessageId: SCHED_S_TASK_TERMINATED
//
// MessageText:
//
// The last run of the task was terminated by the user.
//
static const int SCHED_S_TASK_TERMINATED = _HRESULT_TYPEDEF_(0x00041306L);
//
// MessageId: SCHED_S_TASK_NO_VALID_TRIGGERS
//
// MessageText:
//
// Either the task has no triggers or the existing triggers are disabled or not set.
//
static const int SCHED_S_TASK_NO_VALID_TRIGGERS = _HRESULT_TYPEDEF_(0x00041307L);
//
// MessageId: SCHED_S_EVENT_TRIGGER
//
// MessageText:
//
// Event triggers don't have set run times.
//
static const int SCHED_S_EVENT_TRIGGER = _HRESULT_TYPEDEF_(0x00041308L);
//
// MessageId: SCHED_E_TRIGGER_NOT_FOUND
//
// MessageText:
//
// Trigger not found.
//
static const int SCHED_E_TRIGGER_NOT_FOUND = _HRESULT_TYPEDEF_(0x80041309L);
//
// MessageId: SCHED_E_TASK_NOT_READY
//
// MessageText:
//
// One or more of the properties that are needed to run this task have not been set.
//
static const int SCHED_E_TASK_NOT_READY = _HRESULT_TYPEDEF_(0x8004130AL);
//
// MessageId: SCHED_E_TASK_NOT_RUNNING
//
// MessageText:
//
// There is no running instance of the task.
//
static const int SCHED_E_TASK_NOT_RUNNING = _HRESULT_TYPEDEF_(0x8004130BL);
//
// MessageId: SCHED_E_SERVICE_NOT_INSTALLED
//
// MessageText:
//
// The Task Scheduler Service is not installed on this computer.
//
static const int SCHED_E_SERVICE_NOT_INSTALLED = _HRESULT_TYPEDEF_(0x8004130CL);
//
// MessageId: SCHED_E_CANNOT_OPEN_TASK
//
// MessageText:
//
// The task object could not be opened.
//
static const int SCHED_E_CANNOT_OPEN_TASK = _HRESULT_TYPEDEF_(0x8004130DL);
//
// MessageId: SCHED_E_INVALID_TASK
//
// MessageText:
//
// The object is either an invalid task object or is not a task object.
//
static const int SCHED_E_INVALID_TASK = _HRESULT_TYPEDEF_(0x8004130EL);
//
// MessageId: SCHED_E_ACCOUNT_INFORMATION_NOT_SET
//
// MessageText:
//
// No account information could be found in the Task Scheduler security database for the task indicated.
//
static const int SCHED_E_ACCOUNT_INFORMATION_NOT_SET = _HRESULT_TYPEDEF_(0x8004130FL);
//
// MessageId: SCHED_E_ACCOUNT_NAME_NOT_FOUND
//
// MessageText:
//
// Unable to establish existence of the account specified.
//
static const int SCHED_E_ACCOUNT_NAME_NOT_FOUND = _HRESULT_TYPEDEF_(0x80041310L);
//
// MessageId: SCHED_E_ACCOUNT_DBASE_CORRUPT
//
// MessageText:
//
// Corruption was detected in the Task Scheduler security database; the database has been reset.
//
static const int SCHED_E_ACCOUNT_DBASE_CORRUPT = _HRESULT_TYPEDEF_(0x80041311L);
//
// MessageId: SCHED_E_NO_SECURITY_SERVICES
//
// MessageText:
//
// Task Scheduler security services are available only on Windows NT.
//
static const int SCHED_E_NO_SECURITY_SERVICES = _HRESULT_TYPEDEF_(0x80041312L);
//
// MessageId: SCHED_E_UNKNOWN_OBJECT_VERSION
//
// MessageText:
//
// The task object version is either unsupported or invalid.
//
static const int SCHED_E_UNKNOWN_OBJECT_VERSION = _HRESULT_TYPEDEF_(0x80041313L);
//
// MessageId: SCHED_E_UNSUPPORTED_ACCOUNT_OPTION
//
// MessageText:
//
// The task has been configured with an unsupported combination of account settings and run time options.
//
static const int SCHED_E_UNSUPPORTED_ACCOUNT_OPTION = _HRESULT_TYPEDEF_(0x80041314L);
//
// MessageId: SCHED_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The Task Scheduler Service is not running.
//
static const int SCHED_E_SERVICE_NOT_RUNNING = _HRESULT_TYPEDEF_(0x80041315L);
//
// MessageId: SCHED_E_UNEXPECTEDNODE
//
// MessageText:
//
// The task XML contains an unexpected node.
//
static const int SCHED_E_UNEXPECTEDNODE = _HRESULT_TYPEDEF_(0x80041316L);
//
// MessageId: SCHED_E_NAMESPACE
//
// MessageText:
//
// The task XML contains an element or attribute from an unexpected namespace.
//
static const int SCHED_E_NAMESPACE = _HRESULT_TYPEDEF_(0x80041317L);
//
// MessageId: SCHED_E_INVALIDVALUE
//
// MessageText:
//
// The task XML contains a value which is incorrectly formatted or out of range.
//
static const int SCHED_E_INVALIDVALUE = _HRESULT_TYPEDEF_(0x80041318L);
//
// MessageId: SCHED_E_MISSINGNODE
//
// MessageText:
//
// The task XML is missing a required element or attribute.
//
static const int SCHED_E_MISSINGNODE = _HRESULT_TYPEDEF_(0x80041319L);
//
// MessageId: SCHED_E_MALFORMEDXML
//
// MessageText:
//
// The task XML is malformed.
//
static const int SCHED_E_MALFORMEDXML = _HRESULT_TYPEDEF_(0x8004131AL);
//
// MessageId: SCHED_S_SOME_TRIGGERS_FAILED
//
// MessageText:
//
// The task is registered, but not all specified triggers will start the task.
//
static const int SCHED_S_SOME_TRIGGERS_FAILED = _HRESULT_TYPEDEF_(0x0004131BL);
//
// MessageId: SCHED_S_BATCH_LOGON_PROBLEM
//
// MessageText:
//
// The task is registered, but may fail to start. Batch logon privilege needs to be enabled for the task principal.
//
static const int SCHED_S_BATCH_LOGON_PROBLEM = _HRESULT_TYPEDEF_(0x0004131CL);
//
// MessageId: SCHED_E_TOO_MANY_NODES
//
// MessageText:
//
// The task XML contains too many nodes of the same type.
//
static const int SCHED_E_TOO_MANY_NODES = _HRESULT_TYPEDEF_(0x8004131DL);
//
// MessageId: SCHED_E_PAST_END_BOUNDARY
//
// MessageText:
//
// The task cannot be started after the trigger's end boundary.
//
static const int SCHED_E_PAST_END_BOUNDARY = _HRESULT_TYPEDEF_(0x8004131EL);
//
// MessageId: SCHED_E_ALREADY_RUNNING
//
// MessageText:
//
// An instance of this task is already running.
//
static const int SCHED_E_ALREADY_RUNNING = _HRESULT_TYPEDEF_(0x8004131FL);
//
// MessageId: SCHED_E_USER_NOT_LOGGED_ON
//
// MessageText:
//
// The task will not run because the user is not logged on.
//
static const int SCHED_E_USER_NOT_LOGGED_ON = _HRESULT_TYPEDEF_(0x80041320L);
//
// MessageId: SCHED_E_INVALID_TASK_HASH
//
// MessageText:
//
// The task image is corrupt or has been tampered with.
//
static const int SCHED_E_INVALID_TASK_HASH = _HRESULT_TYPEDEF_(0x80041321L);
//
// MessageId: SCHED_E_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// The Task Scheduler service is not available.
//
static const int SCHED_E_SERVICE_NOT_AVAILABLE = _HRESULT_TYPEDEF_(0x80041322L);
//
// MessageId: SCHED_E_SERVICE_TOO_BUSY
//
// MessageText:
//
// The Task Scheduler service is too busy to handle your request. Please try again later.
//
static const int SCHED_E_SERVICE_TOO_BUSY = _HRESULT_TYPEDEF_(0x80041323L);
//
// MessageId: SCHED_E_TASK_ATTEMPTED
//
// MessageText:
//
// The Task Scheduler service attempted to run the task, but the task did not run due to one of the constraints in the task definition.
//
static const int SCHED_E_TASK_ATTEMPTED = _HRESULT_TYPEDEF_(0x80041324L);
//
// MessageId: SCHED_S_TASK_QUEUED
//
// MessageText:
//
// The Task Scheduler service has asked the task to run.
//
static const int SCHED_S_TASK_QUEUED = _HRESULT_TYPEDEF_(0x00041325L);
//
// MessageId: SCHED_E_TASK_DISABLED
//
// MessageText:
//
// The task is disabled.
//
static const int SCHED_E_TASK_DISABLED = _HRESULT_TYPEDEF_(0x80041326L);
//
// MessageId: SCHED_E_TASK_NOT_V1_COMPAT
//
// MessageText:
//
// The task has properties that are not compatible with previous versions of Windows.
//
static const int SCHED_E_TASK_NOT_V1_COMPAT = _HRESULT_TYPEDEF_(0x80041327L);
//
// MessageId: SCHED_E_START_ON_DEMAND
//
// MessageText:
//
// The task settings do not allow the task to start on demand.
//
static const int SCHED_E_START_ON_DEMAND = _HRESULT_TYPEDEF_(0x80041328L);
// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
// Attempt to create a class object failed
//
static const int CO_E_CLASS_CREATE_FAILED = _HRESULT_TYPEDEF_(0x80080001L);
//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
// OLE service could not bind object
//
static const int CO_E_SCM_ERROR = _HRESULT_TYPEDEF_(0x80080002L);
//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
// RPC communication failed with OLE service
//
static const int CO_E_SCM_RPC_FAILURE = _HRESULT_TYPEDEF_(0x80080003L);
//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
// Bad path to object
//
static const int CO_E_BAD_PATH = _HRESULT_TYPEDEF_(0x80080004L);
//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
// Server execution failed
//
static const int CO_E_SERVER_EXEC_FAILURE = _HRESULT_TYPEDEF_(0x80080005L);
//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
// OLE service could not communicate with the object server
//
static const int CO_E_OBJSRV_RPC_FAILURE = _HRESULT_TYPEDEF_(0x80080006L);
//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
// Moniker path could not be normalized
//
static const int MK_E_NO_NORMALIZED = _HRESULT_TYPEDEF_(0x80080007L);
//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
// Object server is stopping when OLE service contacts it
//
static const int CO_E_SERVER_STOPPING = _HRESULT_TYPEDEF_(0x80080008L);
//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
// An invalid root block pointer was specified
//
static const int MEM_E_INVALID_ROOT = _HRESULT_TYPEDEF_(0x80080009L);
//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
// An allocation chain contained an invalid link pointer
//
static const int MEM_E_INVALID_LINK = _HRESULT_TYPEDEF_(0x80080010L);
//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
// The requested allocation size was too large
//
static const int MEM_E_INVALID_SIZE = _HRESULT_TYPEDEF_(0x80080011L);
//
// MessageId: CO_S_NOTALLINTERFACES
//
// MessageText:
//
// Not all the requested interfaces were available
//
static const int CO_S_NOTALLINTERFACES = _HRESULT_TYPEDEF_(0x00080012L);
//
// MessageId: CO_S_MACHINENAMENOTFOUND
//
// MessageText:
//
// The specified machine name was not found in the cache.
//
static const int CO_S_MACHINENAMENOTFOUND = _HRESULT_TYPEDEF_(0x00080013L);
//
// MessageId: CO_E_MISSING_DISPLAYNAME
//
// MessageText:
//
// The activation requires a display name to be present under the CLSID key.
//
static const int CO_E_MISSING_DISPLAYNAME = _HRESULT_TYPEDEF_(0x80080015L);
//
// MessageId: CO_E_RUNAS_VALUE_MUST_BE_AAA
//
// MessageText:
//
// The activation requires that the RunAs value for the application is Activate As Activator.
//
static const int CO_E_RUNAS_VALUE_MUST_BE_AAA = _HRESULT_TYPEDEF_(0x80080016L);
//
// MessageId: CO_E_ELEVATION_DISABLED
//
// MessageText:
//
// The class is not configured to support Elevated activation.
//
static const int CO_E_ELEVATION_DISABLED = _HRESULT_TYPEDEF_(0x80080017L);
// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
// Unknown interface.
//
static const int DISP_E_UNKNOWNINTERFACE = _HRESULT_TYPEDEF_(0x80020001L);
//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
// Member not found.
//
static const int DISP_E_MEMBERNOTFOUND = _HRESULT_TYPEDEF_(0x80020003L);
//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
// Parameter not found.
//
static const int DISP_E_PARAMNOTFOUND = _HRESULT_TYPEDEF_(0x80020004L);
//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
// Type mismatch.
//
static const int DISP_E_TYPEMISMATCH = _HRESULT_TYPEDEF_(0x80020005L);
//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
// Unknown name.
//
static const int DISP_E_UNKNOWNNAME = _HRESULT_TYPEDEF_(0x80020006L);
//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
// No named arguments.
//
static const int DISP_E_NONAMEDARGS = _HRESULT_TYPEDEF_(0x80020007L);
//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
// Bad variable type.
//
static const int DISP_E_BADVARTYPE = _HRESULT_TYPEDEF_(0x80020008L);
//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
// Exception occurred.
//
static const int DISP_E_EXCEPTION = _HRESULT_TYPEDEF_(0x80020009L);
//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
// Out of present range.
//
static const int DISP_E_OVERFLOW = _HRESULT_TYPEDEF_(0x8002000AL);
//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
// Invalid index.
//
static const int DISP_E_BADINDEX = _HRESULT_TYPEDEF_(0x8002000BL);
//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
// Unknown language.
//
static const int DISP_E_UNKNOWNLCID = _HRESULT_TYPEDEF_(0x8002000CL);
//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
// Memory is locked.
//
static const int DISP_E_ARRAYISLOCKED = _HRESULT_TYPEDEF_(0x8002000DL);
//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
// Invalid number of parameters.
//
static const int DISP_E_BADPARAMCOUNT = _HRESULT_TYPEDEF_(0x8002000EL);
//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
// Parameter not optional.
//
static const int DISP_E_PARAMNOTOPTIONAL = _HRESULT_TYPEDEF_(0x8002000FL);
//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
// Invalid callee.
//
static const int DISP_E_BADCALLEE = _HRESULT_TYPEDEF_(0x80020010L);
//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
// Does not support a collection.
//
static const int DISP_E_NOTACOLLECTION = _HRESULT_TYPEDEF_(0x80020011L);
//
// MessageId: DISP_E_DIVBYZERO
//
// MessageText:
//
// Division by zero.
//
static const int DISP_E_DIVBYZERO = _HRESULT_TYPEDEF_(0x80020012L);
//
// MessageId: DISP_E_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer too small
//
static const int DISP_E_BUFFERTOOSMALL = _HRESULT_TYPEDEF_(0x80020013L);
//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer too small.
//
static const int TYPE_E_BUFFERTOOSMALL = _HRESULT_TYPEDEF_(0x80028016L);
//
// MessageId: TYPE_E_FIELDNOTFOUND
//
// MessageText:
//
// Field name not defined in the record.
//
static const int TYPE_E_FIELDNOTFOUND = _HRESULT_TYPEDEF_(0x80028017L);
//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
// Old format or invalid type library.
//
static const int TYPE_E_INVDATAREAD = _HRESULT_TYPEDEF_(0x80028018L);
//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
// Old format or invalid type library.
//
static const int TYPE_E_UNSUPFORMAT = _HRESULT_TYPEDEF_(0x80028019L);
//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
// Error accessing the OLE registry.
//
static const int TYPE_E_REGISTRYACCESS = _HRESULT_TYPEDEF_(0x8002801CL);
//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
// Library not registered.
//
static const int TYPE_E_LIBNOTREGISTERED = _HRESULT_TYPEDEF_(0x8002801DL);
//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
// Bound to unknown type.
//
static const int TYPE_E_UNDEFINEDTYPE = _HRESULT_TYPEDEF_(0x80028027L);
//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
// Qualified name disallowed.
//
static const int TYPE_E_QUALIFIEDNAMEDISALLOWED = _HRESULT_TYPEDEF_(0x80028028L);
//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
// Invalid forward reference, or reference to uncompiled type.
//
static const int TYPE_E_INVALIDSTATE = _HRESULT_TYPEDEF_(0x80028029L);
//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
// Type mismatch.
//
static const int TYPE_E_WRONGTYPEKIND = _HRESULT_TYPEDEF_(0x8002802AL);
//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
// Element not found.
//
static const int TYPE_E_ELEMENTNOTFOUND = _HRESULT_TYPEDEF_(0x8002802BL);
//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
// Ambiguous name.
//
static const int TYPE_E_AMBIGUOUSNAME = _HRESULT_TYPEDEF_(0x8002802CL);
//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
// Name already exists in the library.
//
static const int TYPE_E_NAMECONFLICT = _HRESULT_TYPEDEF_(0x8002802DL);
//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
// Unknown LCID.
//
static const int TYPE_E_UNKNOWNLCID = _HRESULT_TYPEDEF_(0x8002802EL);
//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
// Function not defined in specified DLL.
//
static const int TYPE_E_DLLFUNCTIONNOTFOUND = _HRESULT_TYPEDEF_(0x8002802FL);
//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
// Wrong module kind for the operation.
//
static const int TYPE_E_BADMODULEKIND = _HRESULT_TYPEDEF_(0x800288BDL);
//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
// Size may not exceed 64K.
//
static const int TYPE_E_SIZETOOBIG = _HRESULT_TYPEDEF_(0x800288C5L);
//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
// Duplicate ID in inheritance hierarchy.
//
static const int TYPE_E_DUPLICATEID = _HRESULT_TYPEDEF_(0x800288C6L);
//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
// Incorrect inheritance depth in standard OLE hmember.
//
static const int TYPE_E_INVALIDID = _HRESULT_TYPEDEF_(0x800288CFL);
//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
// Type mismatch.
//
static const int TYPE_E_TYPEMISMATCH = _HRESULT_TYPEDEF_(0x80028CA0L);
//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
// Invalid number of arguments.
//
static const int TYPE_E_OUTOFBOUNDS = _HRESULT_TYPEDEF_(0x80028CA1L);
//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
// I/O Error.
//
static const int TYPE_E_IOERROR = _HRESULT_TYPEDEF_(0x80028CA2L);
//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
// Error creating unique tmp file.
//
static const int TYPE_E_CANTCREATETMPFILE = _HRESULT_TYPEDEF_(0x80028CA3L);
//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
// Error loading type library/DLL.
//
static const int TYPE_E_CANTLOADLIBRARY = _HRESULT_TYPEDEF_(0x80029C4AL);
//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
// Inconsistent property functions.
//
static const int TYPE_E_INCONSISTENTPROPFUNCS = _HRESULT_TYPEDEF_(0x80029C83L);
//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
// Circular dependency between types/modules.
//
static const int TYPE_E_CIRCULARTYPE = _HRESULT_TYPEDEF_(0x80029C84L);
// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
// Unable to perform requested operation.
//
static const int STG_E_INVALIDFUNCTION = _HRESULT_TYPEDEF_(0x80030001L);
//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
// %1 could not be found.
//
static const int STG_E_FILENOTFOUND = _HRESULT_TYPEDEF_(0x80030002L);
//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
// The path %1 could not be found.
//
static const int STG_E_PATHNOTFOUND = _HRESULT_TYPEDEF_(0x80030003L);
//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
// There are insufficient resources to open another file.
//
static const int STG_E_TOOMANYOPENFILES = _HRESULT_TYPEDEF_(0x80030004L);
//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
// Access Denied.
//
static const int STG_E_ACCESSDENIED = _HRESULT_TYPEDEF_(0x80030005L);
//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
// Attempted an operation on an invalid object.
//
static const int STG_E_INVALIDHANDLE = _HRESULT_TYPEDEF_(0x80030006L);
//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
// There is insufficient memory available to complete operation.
//
static const int STG_E_INSUFFICIENTMEMORY = _HRESULT_TYPEDEF_(0x80030008L);
//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
// Invalid pointer error.
//
static const int STG_E_INVALIDPOINTER = _HRESULT_TYPEDEF_(0x80030009L);
//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
// There are no more entries to return.
//
static const int STG_E_NOMOREFILES = _HRESULT_TYPEDEF_(0x80030012L);
//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
// Disk is write-protected.
//
static const int STG_E_DISKISWRITEPROTECTED = _HRESULT_TYPEDEF_(0x80030013L);
//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
// An error occurred during a seek operation.
//
static const int STG_E_SEEKERROR = _HRESULT_TYPEDEF_(0x80030019L);
//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
// A disk error occurred during a write operation.
//
static const int STG_E_WRITEFAULT = _HRESULT_TYPEDEF_(0x8003001DL);
//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
// A disk error occurred during a read operation.
//
static const int STG_E_READFAULT = _HRESULT_TYPEDEF_(0x8003001EL);
//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
// A share violation has occurred.
//
static const int STG_E_SHAREVIOLATION = _HRESULT_TYPEDEF_(0x80030020L);
//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
// A lock violation has occurred.
//
static const int STG_E_LOCKVIOLATION = _HRESULT_TYPEDEF_(0x80030021L);
//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
// %1 already exists.
//
static const int STG_E_FILEALREADYEXISTS = _HRESULT_TYPEDEF_(0x80030050L);
//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
// Invalid parameter error.
//
static const int STG_E_INVALIDPARAMETER = _HRESULT_TYPEDEF_(0x80030057L);
//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
// There is insufficient disk space to complete operation.
//
static const int STG_E_MEDIUMFULL = _HRESULT_TYPEDEF_(0x80030070L);
//
// MessageId: STG_E_PROPSETMISMATCHED
//
// MessageText:
//
// Illegal write of non-simple property to simple property set.
//
static const int STG_E_PROPSETMISMATCHED = _HRESULT_TYPEDEF_(0x800300F0L);
//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
// An API call exited abnormally.
//
static const int STG_E_ABNORMALAPIEXIT = _HRESULT_TYPEDEF_(0x800300FAL);
//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
// The file %1 is not a valid compound file.
//
static const int STG_E_INVALIDHEADER = _HRESULT_TYPEDEF_(0x800300FBL);
//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
// The name %1 is not valid.
//
static const int STG_E_INVALIDNAME = _HRESULT_TYPEDEF_(0x800300FCL);
//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
// An unexpected error occurred.
//
static const int STG_E_UNKNOWN = _HRESULT_TYPEDEF_(0x800300FDL);
//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
// That function is not implemented.
//
static const int STG_E_UNIMPLEMENTEDFUNCTION = _HRESULT_TYPEDEF_(0x800300FEL);
//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
// Invalid flag error.
//
static const int STG_E_INVALIDFLAG = _HRESULT_TYPEDEF_(0x800300FFL);
//
// MessageId: STG_E_INUSE
//
// MessageText:
//
// Attempted to use an object that is busy.
//
static const int STG_E_INUSE = _HRESULT_TYPEDEF_(0x80030100L);
//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
// The storage has been changed since the last commit.
//
static const int STG_E_NOTCURRENT = _HRESULT_TYPEDEF_(0x80030101L);
//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
// Attempted to use an object that has ceased to exist.
//
static const int STG_E_REVERTED = _HRESULT_TYPEDEF_(0x80030102L);
//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
// Can't save.
//
static const int STG_E_CANTSAVE = _HRESULT_TYPEDEF_(0x80030103L);
//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
// The compound file %1 was produced with an incompatible version of storage.
//
static const int STG_E_OLDFORMAT = _HRESULT_TYPEDEF_(0x80030104L);
//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
// The compound file %1 was produced with a newer version of storage.
//
static const int STG_E_OLDDLL = _HRESULT_TYPEDEF_(0x80030105L);
//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
// Share.exe or equivalent is required for operation.
//
static const int STG_E_SHAREREQUIRED = _HRESULT_TYPEDEF_(0x80030106L);
//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
// Illegal operation called on non-file based storage.
//
static const int STG_E_NOTFILEBASEDSTORAGE = _HRESULT_TYPEDEF_(0x80030107L);
//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
// Illegal operation called on object with extant marshallings.
//
static const int STG_E_EXTANTMARSHALLINGS = _HRESULT_TYPEDEF_(0x80030108L);
//
// MessageId: STG_E_DOCFILECORRUPT
//
// MessageText:
//
// The docfile has been corrupted.
//
static const int STG_E_DOCFILECORRUPT = _HRESULT_TYPEDEF_(0x80030109L);
//
// MessageId: STG_E_BADBASEADDRESS
//
// MessageText:
//
// OLE32.DLL has been loaded at the wrong address.
//
static const int STG_E_BADBASEADDRESS = _HRESULT_TYPEDEF_(0x80030110L);
//
// MessageId: STG_E_DOCFILETOOLARGE
//
// MessageText:
//
// The compound file is too large for the current implementation
//
static const int STG_E_DOCFILETOOLARGE = _HRESULT_TYPEDEF_(0x80030111L);
//
// MessageId: STG_E_NOTSIMPLEFORMAT
//
// MessageText:
//
// The compound file was not created with the STGM_SIMPLE flag
//
static const int STG_E_NOTSIMPLEFORMAT = _HRESULT_TYPEDEF_(0x80030112L);
//
// MessageId: STG_E_INCOMPLETE
//
// MessageText:
//
// The file download was aborted abnormally. The file is incomplete.
//
static const int STG_E_INCOMPLETE = _HRESULT_TYPEDEF_(0x80030201L);
//
// MessageId: STG_E_TERMINATED
//
// MessageText:
//
// The file download has been terminated.
//
static const int STG_E_TERMINATED = _HRESULT_TYPEDEF_(0x80030202L);
//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
// The underlying file was converted to compound file format.
//
static const int STG_S_CONVERTED = _HRESULT_TYPEDEF_(0x00030200L);
//
// MessageId: STG_S_BLOCK
//
// MessageText:
//
// The storage operation should block until more data is available.
//
static const int STG_S_BLOCK = _HRESULT_TYPEDEF_(0x00030201L);
//
// MessageId: STG_S_RETRYNOW
//
// MessageText:
//
// The storage operation should retry immediately.
//
static const int STG_S_RETRYNOW = _HRESULT_TYPEDEF_(0x00030202L);
//
// MessageId: STG_S_MONITORING
//
// MessageText:
//
// The notified event sink will not influence the storage operation.
//
static const int STG_S_MONITORING = _HRESULT_TYPEDEF_(0x00030203L);
//
// MessageId: STG_S_MULTIPLEOPENS
//
// MessageText:
//
// Multiple opens prevent consolidated. (commit succeeded).
//
static const int STG_S_MULTIPLEOPENS = _HRESULT_TYPEDEF_(0x00030204L);
//
// MessageId: STG_S_CONSOLIDATIONFAILED
//
// MessageText:
//
// Consolidation of the storage file failed. (commit succeeded).
//
static const int STG_S_CONSOLIDATIONFAILED = _HRESULT_TYPEDEF_(0x00030205L);
//
// MessageId: STG_S_CANNOTCONSOLIDATE
//
// MessageText:
//
// Consolidation of the storage file is inappropriate. (commit succeeded).
//
static const int STG_S_CANNOTCONSOLIDATE = _HRESULT_TYPEDEF_(0x00030206L);
/*++
 MessageId's 0x0305 - 0x031f (inclusive) are reserved for **STORAGE**
 copy protection errors.
--*/
# 28206 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
// MessageId: STG_E_STATUS_COPY_PROTECTION_FAILURE
//
// MessageText:
//
// Generic Copy Protection Error.
//
static const int STG_E_STATUS_COPY_PROTECTION_FAILURE = _HRESULT_TYPEDEF_(0x80030305L);
//
// MessageId: STG_E_CSS_AUTHENTICATION_FAILURE
//
// MessageText:
//
// Copy Protection Error - DVD CSS Authentication failed.
//
static const int STG_E_CSS_AUTHENTICATION_FAILURE = _HRESULT_TYPEDEF_(0x80030306L);
//
// MessageId: STG_E_CSS_KEY_NOT_PRESENT
//
// MessageText:
//
// Copy Protection Error - The given sector does not have a valid CSS key.
//
static const int STG_E_CSS_KEY_NOT_PRESENT = _HRESULT_TYPEDEF_(0x80030307L);
//
// MessageId: STG_E_CSS_KEY_NOT_ESTABLISHED
//
// MessageText:
//
// Copy Protection Error - DVD session key not established.
//
static const int STG_E_CSS_KEY_NOT_ESTABLISHED = _HRESULT_TYPEDEF_(0x80030308L);
//
// MessageId: STG_E_CSS_SCRAMBLED_SECTOR
//
// MessageText:
//
// Copy Protection Error - The read failed because the sector is encrypted.
//
static const int STG_E_CSS_SCRAMBLED_SECTOR = _HRESULT_TYPEDEF_(0x80030309L);
//
// MessageId: STG_E_CSS_REGION_MISMATCH
//
// MessageText:
//
// Copy Protection Error - The current DVD's region does not correspond to the region setting of the drive.
//
static const int STG_E_CSS_REGION_MISMATCH = _HRESULT_TYPEDEF_(0x8003030AL);
//
// MessageId: STG_E_RESETS_EXHAUSTED
//
// MessageText:
//
// Copy Protection Error - The drive's region setting may be permanent or the number of user resets has been exhausted.
//
static const int STG_E_RESETS_EXHAUSTED = _HRESULT_TYPEDEF_(0x8003030BL);
/*++
 MessageId's 0x0305 - 0x031f (inclusive) are reserved for **STORAGE**
 copy protection errors.
--*/
# 28275 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propagated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
// Call was rejected by callee.
//
static const int RPC_E_CALL_REJECTED = _HRESULT_TYPEDEF_(0x80010001L);
//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
// Call was canceled by the message filter.
//
static const int RPC_E_CALL_CANCELED = _HRESULT_TYPEDEF_(0x80010002L);
//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
// The caller is dispatching an intertask SendMessage call and cannot call out via PostMessage.
//
static const int RPC_E_CANTPOST_INSENDCALL = _HRESULT_TYPEDEF_(0x80010003L);
//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
// The caller is dispatching an asynchronous call and cannot make an outgoing call on behalf of this call.
//
static const int RPC_E_CANTCALLOUT_INASYNCCALL = _HRESULT_TYPEDEF_(0x80010004L);
//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
// It is illegal to call out while inside message filter.
//
static const int RPC_E_CANTCALLOUT_INEXTERNALCALL = _HRESULT_TYPEDEF_(0x80010005L);
//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
// The connection terminated or is in a bogus state and cannot be used any more. Other connections are still valid.
//
static const int RPC_E_CONNECTION_TERMINATED = _HRESULT_TYPEDEF_(0x80010006L);
//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
// The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call may have executed.
//
static const int RPC_E_SERVER_DIED = _HRESULT_TYPEDEF_(0x80010007L);
//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
// The caller (client) disappeared while the callee (server) was processing a call.
//
static const int RPC_E_CLIENT_DIED = _HRESULT_TYPEDEF_(0x80010008L);
//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
// The data packet with the marshalled parameter data is incorrect.
//
static const int RPC_E_INVALID_DATAPACKET = _HRESULT_TYPEDEF_(0x80010009L);
//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
// The call was not transmitted properly; the message queue was full and was not emptied after yielding.
//
static const int RPC_E_CANTTRANSMIT_CALL = _HRESULT_TYPEDEF_(0x8001000AL);
//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
// The client (caller) cannot marshall the parameter data - low memory, etc.
//
static const int RPC_E_CLIENT_CANTMARSHAL_DATA = _HRESULT_TYPEDEF_(0x8001000BL);
//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
// The client (caller) cannot unmarshall the return data - low memory, etc.
//
static const int RPC_E_CLIENT_CANTUNMARSHAL_DATA = _HRESULT_TYPEDEF_(0x8001000CL);
//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
// The server (callee) cannot marshall the return data - low memory, etc.
//
static const int RPC_E_SERVER_CANTMARSHAL_DATA = _HRESULT_TYPEDEF_(0x8001000DL);
//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
// The server (callee) cannot unmarshall the parameter data - low memory, etc.
//
static const int RPC_E_SERVER_CANTUNMARSHAL_DATA = _HRESULT_TYPEDEF_(0x8001000EL);
//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
// Received data is invalid; could be server or client data.
//
static const int RPC_E_INVALID_DATA = _HRESULT_TYPEDEF_(0x8001000FL);
//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
// A particular parameter is invalid and cannot be (un)marshalled.
//
static const int RPC_E_INVALID_PARAMETER = _HRESULT_TYPEDEF_(0x80010010L);
//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
// There is no second outgoing call on same channel in DDE conversation.
//
static const int RPC_E_CANTCALLOUT_AGAIN = _HRESULT_TYPEDEF_(0x80010011L);
//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
// The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call did not execute.
//
static const int RPC_E_SERVER_DIED_DNE = _HRESULT_TYPEDEF_(0x80010012L);
//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
// System call failed.
//
static const int RPC_E_SYS_CALL_FAILED = _HRESULT_TYPEDEF_(0x80010100L);
//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
// Could not allocate some required resource (memory, events, ...)
//
static const int RPC_E_OUT_OF_RESOURCES = _HRESULT_TYPEDEF_(0x80010101L);
//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
// Attempted to make calls on more than one thread in single threaded mode.
//
static const int RPC_E_ATTEMPTED_MULTITHREAD = _HRESULT_TYPEDEF_(0x80010102L);
//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
// The requested interface is not registered on the server object.
//
static const int RPC_E_NOT_REGISTERED = _HRESULT_TYPEDEF_(0x80010103L);
//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
// RPC could not call the server or could not return the results of calling the server.
//
static const int RPC_E_FAULT = _HRESULT_TYPEDEF_(0x80010104L);
//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
// The server threw an exception.
//
static const int RPC_E_SERVERFAULT = _HRESULT_TYPEDEF_(0x80010105L);
//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
// Cannot change thread mode after it is set.
//
static const int RPC_E_CHANGED_MODE = _HRESULT_TYPEDEF_(0x80010106L);
//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
// The method called does not exist on the server.
//
static const int RPC_E_INVALIDMETHOD = _HRESULT_TYPEDEF_(0x80010107L);
//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
// The object invoked has disconnected from its clients.
//
static const int RPC_E_DISCONNECTED = _HRESULT_TYPEDEF_(0x80010108L);
//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
// The object invoked chose not to process the call now. Try again later.
//
static const int RPC_E_RETRY = _HRESULT_TYPEDEF_(0x80010109L);
//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
// The message filter indicated that the application is busy.
//
static const int RPC_E_SERVERCALL_RETRYLATER = _HRESULT_TYPEDEF_(0x8001010AL);
//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
// The message filter rejected the call.
//
static const int RPC_E_SERVERCALL_REJECTED = _HRESULT_TYPEDEF_(0x8001010BL);
//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
// A call control interfaces was called with invalid data.
//
static const int RPC_E_INVALID_CALLDATA = _HRESULT_TYPEDEF_(0x8001010CL);
//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
// An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//
static const int RPC_E_CANTCALLOUT_ININPUTSYNCCALL = _HRESULT_TYPEDEF_(0x8001010DL);
//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
// The application called an interface that was marshalled for a different thread.
//
static const int RPC_E_WRONG_THREAD = _HRESULT_TYPEDEF_(0x8001010EL);
//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
// CoInitialize has not been called on the current thread.
//
static const int RPC_E_THREAD_NOT_INIT = _HRESULT_TYPEDEF_(0x8001010FL);
//
// MessageId: RPC_E_VERSION_MISMATCH
//
// MessageText:
//
// The version of OLE on the client and server machines does not match.
//
static const int RPC_E_VERSION_MISMATCH = _HRESULT_TYPEDEF_(0x80010110L);
//
// MessageId: RPC_E_INVALID_HEADER
//
// MessageText:
//
// OLE received a packet with an invalid header.
//
static const int RPC_E_INVALID_HEADER = _HRESULT_TYPEDEF_(0x80010111L);
//
// MessageId: RPC_E_INVALID_EXTENSION
//
// MessageText:
//
// OLE received a packet with an invalid extension.
//
static const int RPC_E_INVALID_EXTENSION = _HRESULT_TYPEDEF_(0x80010112L);
//
// MessageId: RPC_E_INVALID_IPID
//
// MessageText:
//
// The requested object or interface does not exist.
//
static const int RPC_E_INVALID_IPID = _HRESULT_TYPEDEF_(0x80010113L);
//
// MessageId: RPC_E_INVALID_OBJECT
//
// MessageText:
//
// The requested object does not exist.
//
static const int RPC_E_INVALID_OBJECT = _HRESULT_TYPEDEF_(0x80010114L);
//
// MessageId: RPC_S_CALLPENDING
//
// MessageText:
//
// OLE has sent a request and is waiting for a reply.
//
static const int RPC_S_CALLPENDING = _HRESULT_TYPEDEF_(0x80010115L);
//
// MessageId: RPC_S_WAITONTIMER
//
// MessageText:
//
// OLE is waiting before retrying a request.
//
static const int RPC_S_WAITONTIMER = _HRESULT_TYPEDEF_(0x80010116L);
//
// MessageId: RPC_E_CALL_COMPLETE
//
// MessageText:
//
// Call context cannot be accessed after call completed.
//
static const int RPC_E_CALL_COMPLETE = _HRESULT_TYPEDEF_(0x80010117L);
//
// MessageId: RPC_E_UNSECURE_CALL
//
// MessageText:
//
// Impersonate on unsecure calls is not supported.
//
static const int RPC_E_UNSECURE_CALL = _HRESULT_TYPEDEF_(0x80010118L);
//
// MessageId: RPC_E_TOO_LATE
//
// MessageText:
//
// Security must be initialized before any interfaces are marshalled or unmarshalled. It cannot be changed once initialized.
//
static const int RPC_E_TOO_LATE = _HRESULT_TYPEDEF_(0x80010119L);
//
// MessageId: RPC_E_NO_GOOD_SECURITY_PACKAGES
//
// MessageText:
//
// No security packages are installed on this machine or the user is not logged on or there are no compatible security packages between the client and server.
//
static const int RPC_E_NO_GOOD_SECURITY_PACKAGES = _HRESULT_TYPEDEF_(0x8001011AL);
//
// MessageId: RPC_E_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
static const int RPC_E_ACCESS_DENIED = _HRESULT_TYPEDEF_(0x8001011BL);
//
// MessageId: RPC_E_REMOTE_DISABLED
//
// MessageText:
//
// Remote calls are not allowed for this process.
//
static const int RPC_E_REMOTE_DISABLED = _HRESULT_TYPEDEF_(0x8001011CL);
//
// MessageId: RPC_E_INVALID_OBJREF
//
// MessageText:
//
// The marshaled interface data packet (OBJREF) has an invalid or unknown format.
//
static const int RPC_E_INVALID_OBJREF = _HRESULT_TYPEDEF_(0x8001011DL);
//
// MessageId: RPC_E_NO_CONTEXT
//
// MessageText:
//
// No context is associated with this call. This happens for some custom marshalled calls and on the client side of the call.
//
static const int RPC_E_NO_CONTEXT = _HRESULT_TYPEDEF_(0x8001011EL);
//
// MessageId: RPC_E_TIMEOUT
//
// MessageText:
//
// This operation returned because the timeout period expired.
//
static const int RPC_E_TIMEOUT = _HRESULT_TYPEDEF_(0x8001011FL);
//
// MessageId: RPC_E_NO_SYNC
//
// MessageText:
//
// There are no synchronize objects to wait on.
//
static const int RPC_E_NO_SYNC = _HRESULT_TYPEDEF_(0x80010120L);
//
// MessageId: RPC_E_FULLSIC_REQUIRED
//
// MessageText:
//
// Full subject issuer chain SSL principal name expected from the server.
//
static const int RPC_E_FULLSIC_REQUIRED = _HRESULT_TYPEDEF_(0x80010121L);
//
// MessageId: RPC_E_INVALID_STD_NAME
//
// MessageText:
//
// Principal name is not a valid MSSTD name.
//
static const int RPC_E_INVALID_STD_NAME = _HRESULT_TYPEDEF_(0x80010122L);
//
// MessageId: CO_E_FAILEDTOIMPERSONATE
//
// MessageText:
//
// Unable to impersonate DCOM client
//
static const int CO_E_FAILEDTOIMPERSONATE = _HRESULT_TYPEDEF_(0x80010123L);
//
// MessageId: CO_E_FAILEDTOGETSECCTX
//
// MessageText:
//
// Unable to obtain server's security context
//
static const int CO_E_FAILEDTOGETSECCTX = _HRESULT_TYPEDEF_(0x80010124L);
//
// MessageId: CO_E_FAILEDTOOPENTHREADTOKEN
//
// MessageText:
//
// Unable to open the access token of the current thread
//
static const int CO_E_FAILEDTOOPENTHREADTOKEN = _HRESULT_TYPEDEF_(0x80010125L);
//
// MessageId: CO_E_FAILEDTOGETTOKENINFO
//
// MessageText:
//
// Unable to obtain user info from an access token
//
static const int CO_E_FAILEDTOGETTOKENINFO = _HRESULT_TYPEDEF_(0x80010126L);
//
// MessageId: CO_E_TRUSTEEDOESNTMATCHCLIENT
//
// MessageText:
//
// The client who called IAccessControl::IsAccessPermitted was not the trustee provided to the method
//
static const int CO_E_TRUSTEEDOESNTMATCHCLIENT = _HRESULT_TYPEDEF_(0x80010127L);
//
// MessageId: CO_E_FAILEDTOQUERYCLIENTBLANKET
//
// MessageText:
//
// Unable to obtain the client's security blanket
//
static const int CO_E_FAILEDTOQUERYCLIENTBLANKET = _HRESULT_TYPEDEF_(0x80010128L);
//
// MessageId: CO_E_FAILEDTOSETDACL
//
// MessageText:
//
// Unable to set a discretionary ACL into a security descriptor
//
static const int CO_E_FAILEDTOSETDACL = _HRESULT_TYPEDEF_(0x80010129L);
//
// MessageId: CO_E_ACCESSCHECKFAILED
//
// MessageText:
//
// The system function, AccessCheck, returned false
//
static const int CO_E_ACCESSCHECKFAILED = _HRESULT_TYPEDEF_(0x8001012AL);
//
// MessageId: CO_E_NETACCESSAPIFAILED
//
// MessageText:
//
// Either NetAccessDel or NetAccessAdd returned an error code.
//
static const int CO_E_NETACCESSAPIFAILED = _HRESULT_TYPEDEF_(0x8001012BL);
//
// MessageId: CO_E_WRONGTRUSTEENAMESYNTAX
//
// MessageText:
//
// One of the trustee strings provided by the user did not conform to the <Domain>\<Name> syntax and it was not the "*" string
//
static const int CO_E_WRONGTRUSTEENAMESYNTAX = _HRESULT_TYPEDEF_(0x8001012CL);
//
// MessageId: CO_E_INVALIDSID
//
// MessageText:
//
// One of the security identifiers provided by the user was invalid
//
static const int CO_E_INVALIDSID = _HRESULT_TYPEDEF_(0x8001012DL);
//
// MessageId: CO_E_CONVERSIONFAILED
//
// MessageText:
//
// Unable to convert a wide character trustee string to a multibyte trustee string
//
static const int CO_E_CONVERSIONFAILED = _HRESULT_TYPEDEF_(0x8001012EL);
//
// MessageId: CO_E_NOMATCHINGSIDFOUND
//
// MessageText:
//
// Unable to find a security identifier that corresponds to a trustee string provided by the user
//
static const int CO_E_NOMATCHINGSIDFOUND = _HRESULT_TYPEDEF_(0x8001012FL);
//
// MessageId: CO_E_LOOKUPACCSIDFAILED
//
// MessageText:
//
// The system function, LookupAccountSID, failed
//
static const int CO_E_LOOKUPACCSIDFAILED = _HRESULT_TYPEDEF_(0x80010130L);
//
// MessageId: CO_E_NOMATCHINGNAMEFOUND
//
// MessageText:
//
// Unable to find a trustee name that corresponds to a security identifier provided by the user
//
static const int CO_E_NOMATCHINGNAMEFOUND = _HRESULT_TYPEDEF_(0x80010131L);
//
// MessageId: CO_E_LOOKUPACCNAMEFAILED
//
// MessageText:
//
// The system function, LookupAccountName, failed
//
static const int CO_E_LOOKUPACCNAMEFAILED = _HRESULT_TYPEDEF_(0x80010132L);
//
// MessageId: CO_E_SETSERLHNDLFAILED
//
// MessageText:
//
// Unable to set or reset a serialization handle
//
static const int CO_E_SETSERLHNDLFAILED = _HRESULT_TYPEDEF_(0x80010133L);
//
// MessageId: CO_E_FAILEDTOGETWINDIR
//
// MessageText:
//
// Unable to obtain the Windows directory
//
static const int CO_E_FAILEDTOGETWINDIR = _HRESULT_TYPEDEF_(0x80010134L);
//
// MessageId: CO_E_PATHTOOLONG
//
// MessageText:
//
// Path too long
//
static const int CO_E_PATHTOOLONG = _HRESULT_TYPEDEF_(0x80010135L);
//
// MessageId: CO_E_FAILEDTOGENUUID
//
// MessageText:
//
// Unable to generate a uuid.
//
static const int CO_E_FAILEDTOGENUUID = _HRESULT_TYPEDEF_(0x80010136L);
//
// MessageId: CO_E_FAILEDTOCREATEFILE
//
// MessageText:
//
// Unable to create file
//
static const int CO_E_FAILEDTOCREATEFILE = _HRESULT_TYPEDEF_(0x80010137L);
//
// MessageId: CO_E_FAILEDTOCLOSEHANDLE
//
// MessageText:
//
// Unable to close a serialization handle or a file handle.
//
static const int CO_E_FAILEDTOCLOSEHANDLE = _HRESULT_TYPEDEF_(0x80010138L);
//
// MessageId: CO_E_EXCEEDSYSACLLIMIT
//
// MessageText:
//
// The number of ACEs in an ACL exceeds the system limit.
//
static const int CO_E_EXCEEDSYSACLLIMIT = _HRESULT_TYPEDEF_(0x80010139L);
//
// MessageId: CO_E_ACESINWRONGORDER
//
// MessageText:
//
// Not all the DENY_ACCESS ACEs are arranged in front of the GRANT_ACCESS ACEs in the stream.
//
static const int CO_E_ACESINWRONGORDER = _HRESULT_TYPEDEF_(0x8001013AL);
//
// MessageId: CO_E_INCOMPATIBLESTREAMVERSION
//
// MessageText:
//
// The version of ACL format in the stream is not supported by this implementation of IAccessControl
//
static const int CO_E_INCOMPATIBLESTREAMVERSION = _HRESULT_TYPEDEF_(0x8001013BL);
//
// MessageId: CO_E_FAILEDTOOPENPROCESSTOKEN
//
// MessageText:
//
// Unable to open the access token of the server process
//
static const int CO_E_FAILEDTOOPENPROCESSTOKEN = _HRESULT_TYPEDEF_(0x8001013CL);
//
// MessageId: CO_E_DECODEFAILED
//
// MessageText:
//
// Unable to decode the ACL in the stream provided by the user
//
static const int CO_E_DECODEFAILED = _HRESULT_TYPEDEF_(0x8001013DL);
//
// MessageId: CO_E_ACNOTINITIALIZED
//
// MessageText:
//
// The COM IAccessControl object is not initialized
//
static const int CO_E_ACNOTINITIALIZED = _HRESULT_TYPEDEF_(0x8001013FL);
//
// MessageId: CO_E_CANCEL_DISABLED
//
// MessageText:
//
// Call Cancellation is disabled
//
static const int CO_E_CANCEL_DISABLED = _HRESULT_TYPEDEF_(0x80010140L);
//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
// An internal error occurred.
//
static const int RPC_E_UNEXPECTED = _HRESULT_TYPEDEF_(0x8001FFFFL);
//////////////////////////////////////
//                                  //
// Additional Security Status Codes //
//                                  //
// Facility=Security                //
//                                  //
//////////////////////////////////////
//
// MessageId: ERROR_AUDITING_DISABLED
//
// MessageText:
//
// The specified event is currently not being audited.
//
static const int ERROR_AUDITING_DISABLED = _HRESULT_TYPEDEF_(0xC0090001L);
//
// MessageId: ERROR_ALL_SIDS_FILTERED
//
// MessageText:
//
// The SID filtering operation removed all SIDs.
//
static const int ERROR_ALL_SIDS_FILTERED = _HRESULT_TYPEDEF_(0xC0090002L);
//
// MessageId: ERROR_BIZRULES_NOT_ENABLED
//
// MessageText:
//
// Business rule scripts are disabled for the calling application.
//
static const int ERROR_BIZRULES_NOT_ENABLED = _HRESULT_TYPEDEF_(0xC0090003L);
/////////////////////////////////////////////
//                                         //
// end of Additional Security Status Codes //
//                                         //
/////////////////////////////////////////////
 /////////////////
 //
 //  FACILITY_SSPI
 //
 /////////////////
//
// MessageId: NTE_BAD_UID
//
// MessageText:
//
// Bad UID.
//
static const int NTE_BAD_UID = _HRESULT_TYPEDEF_(0x80090001L);
//
// MessageId: NTE_BAD_HASH
//
// MessageText:
//
// Bad Hash.
//
static const int NTE_BAD_HASH = _HRESULT_TYPEDEF_(0x80090002L);
//
// MessageId: NTE_BAD_KEY
//
// MessageText:
//
// Bad Key.
//
static const int NTE_BAD_KEY = _HRESULT_TYPEDEF_(0x80090003L);
//
// MessageId: NTE_BAD_LEN
//
// MessageText:
//
// Bad Length.
//
static const int NTE_BAD_LEN = _HRESULT_TYPEDEF_(0x80090004L);
//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
// Bad Data.
//
static const int NTE_BAD_DATA = _HRESULT_TYPEDEF_(0x80090005L);
//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
// Invalid Signature.
//
static const int NTE_BAD_SIGNATURE = _HRESULT_TYPEDEF_(0x80090006L);
//
// MessageId: NTE_BAD_VER
//
// MessageText:
//
// Bad Version of provider.
//
static const int NTE_BAD_VER = _HRESULT_TYPEDEF_(0x80090007L);
//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
// Invalid algorithm specified.
//
static const int NTE_BAD_ALGID = _HRESULT_TYPEDEF_(0x80090008L);
//
// MessageId: NTE_BAD_FLAGS
//
// MessageText:
//
// Invalid flags specified.
//
static const int NTE_BAD_FLAGS = _HRESULT_TYPEDEF_(0x80090009L);
//
// MessageId: NTE_BAD_TYPE
//
// MessageText:
//
// Invalid type specified.
//
static const int NTE_BAD_TYPE = _HRESULT_TYPEDEF_(0x8009000AL);
//
// MessageId: NTE_BAD_KEY_STATE
//
// MessageText:
//
// Key not valid for use in specified state.
//
static const int NTE_BAD_KEY_STATE = _HRESULT_TYPEDEF_(0x8009000BL);
//
// MessageId: NTE_BAD_HASH_STATE
//
// MessageText:
//
// Hash not valid for use in specified state.
//
static const int NTE_BAD_HASH_STATE = _HRESULT_TYPEDEF_(0x8009000CL);
//
// MessageId: NTE_NO_KEY
//
// MessageText:
//
// Key does not exist.
//
static const int NTE_NO_KEY = _HRESULT_TYPEDEF_(0x8009000DL);
//
// MessageId: NTE_NO_MEMORY
//
// MessageText:
//
// Insufficient memory available for the operation.
//
static const int NTE_NO_MEMORY = _HRESULT_TYPEDEF_(0x8009000EL);
//
// MessageId: NTE_EXISTS
//
// MessageText:
//
// Object already exists.
//
static const int NTE_EXISTS = _HRESULT_TYPEDEF_(0x8009000FL);
//
// MessageId: NTE_PERM
//
// MessageText:
//
// Access denied.
//
static const int NTE_PERM = _HRESULT_TYPEDEF_(0x80090010L);
//
// MessageId: NTE_NOT_FOUND
//
// MessageText:
//
// Object was not found.
//
static const int NTE_NOT_FOUND = _HRESULT_TYPEDEF_(0x80090011L);
//
// MessageId: NTE_DOUBLE_ENCRYPT
//
// MessageText:
//
// Data already encrypted.
//
static const int NTE_DOUBLE_ENCRYPT = _HRESULT_TYPEDEF_(0x80090012L);
//
// MessageId: NTE_BAD_PROVIDER
//
// MessageText:
//
// Invalid provider specified.
//
static const int NTE_BAD_PROVIDER = _HRESULT_TYPEDEF_(0x80090013L);
//
// MessageId: NTE_BAD_PROV_TYPE
//
// MessageText:
//
// Invalid provider type specified.
//
static const int NTE_BAD_PROV_TYPE = _HRESULT_TYPEDEF_(0x80090014L);
//
// MessageId: NTE_BAD_PUBLIC_KEY
//
// MessageText:
//
// Provider's public key is invalid.
//
static const int NTE_BAD_PUBLIC_KEY = _HRESULT_TYPEDEF_(0x80090015L);
//
// MessageId: NTE_BAD_KEYSET
//
// MessageText:
//
// Keyset does not exist
//
static const int NTE_BAD_KEYSET = _HRESULT_TYPEDEF_(0x80090016L);
//
// MessageId: NTE_PROV_TYPE_NOT_DEF
//
// MessageText:
//
// Provider type not defined.
//
static const int NTE_PROV_TYPE_NOT_DEF = _HRESULT_TYPEDEF_(0x80090017L);
//
// MessageId: NTE_PROV_TYPE_ENTRY_BAD
//
// MessageText:
//
// Provider type as registered is invalid.
//
static const int NTE_PROV_TYPE_ENTRY_BAD = _HRESULT_TYPEDEF_(0x80090018L);
//
// MessageId: NTE_KEYSET_NOT_DEF
//
// MessageText:
//
// The keyset is not defined.
//
static const int NTE_KEYSET_NOT_DEF = _HRESULT_TYPEDEF_(0x80090019L);
//
// MessageId: NTE_KEYSET_ENTRY_BAD
//
// MessageText:
//
// Keyset as registered is invalid.
//
static const int NTE_KEYSET_ENTRY_BAD = _HRESULT_TYPEDEF_(0x8009001AL);
//
// MessageId: NTE_PROV_TYPE_NO_MATCH
//
// MessageText:
//
// Provider type does not match registered value.
//
static const int NTE_PROV_TYPE_NO_MATCH = _HRESULT_TYPEDEF_(0x8009001BL);
//
// MessageId: NTE_SIGNATURE_FILE_BAD
//
// MessageText:
//
// The digital signature file is corrupt.
//
static const int NTE_SIGNATURE_FILE_BAD = _HRESULT_TYPEDEF_(0x8009001CL);
//
// MessageId: NTE_PROVIDER_DLL_FAIL
//
// MessageText:
//
// Provider DLL failed to initialize correctly.
//
static const int NTE_PROVIDER_DLL_FAIL = _HRESULT_TYPEDEF_(0x8009001DL);
//
// MessageId: NTE_PROV_DLL_NOT_FOUND
//
// MessageText:
//
// Provider DLL could not be found.
//
static const int NTE_PROV_DLL_NOT_FOUND = _HRESULT_TYPEDEF_(0x8009001EL);
//
// MessageId: NTE_BAD_KEYSET_PARAM
//
// MessageText:
//
// The Keyset parameter is invalid.
//
static const int NTE_BAD_KEYSET_PARAM = _HRESULT_TYPEDEF_(0x8009001FL);
//
// MessageId: NTE_FAIL
//
// MessageText:
//
// An internal error occurred.
//
static const int NTE_FAIL = _HRESULT_TYPEDEF_(0x80090020L);
//
// MessageId: NTE_SYS_ERR
//
// MessageText:
//
// A base error occurred.
//
static const int NTE_SYS_ERR = _HRESULT_TYPEDEF_(0x80090021L);
//
// MessageId: NTE_SILENT_CONTEXT
//
// MessageText:
//
// Provider could not perform the action since the context was acquired as silent.
//
static const int NTE_SILENT_CONTEXT = _HRESULT_TYPEDEF_(0x80090022L);
//
// MessageId: NTE_TOKEN_KEYSET_STORAGE_FULL
//
// MessageText:
//
// The security token does not have storage space available for an additional container.
//
static const int NTE_TOKEN_KEYSET_STORAGE_FULL = _HRESULT_TYPEDEF_(0x80090023L);
//
// MessageId: NTE_TEMPORARY_PROFILE
//
// MessageText:
//
// The profile for the user is a temporary profile.
//
static const int NTE_TEMPORARY_PROFILE = _HRESULT_TYPEDEF_(0x80090024L);
//
// MessageId: NTE_FIXEDPARAMETER
//
// MessageText:
//
// The key parameters could not be set because the CSP uses fixed parameters.
//
static const int NTE_FIXEDPARAMETER = _HRESULT_TYPEDEF_(0x80090025L);
//
// MessageId: NTE_INVALID_HANDLE
//
// MessageText:
//
// The supplied handle is invalid.
//
static const int NTE_INVALID_HANDLE = _HRESULT_TYPEDEF_(0x80090026L);
//
// MessageId: NTE_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
static const int NTE_INVALID_PARAMETER = _HRESULT_TYPEDEF_(0x80090027L);
//
// MessageId: NTE_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied to a function was too small.
//
static const int NTE_BUFFER_TOO_SMALL = _HRESULT_TYPEDEF_(0x80090028L);
//
// MessageId: NTE_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported.
//
static const int NTE_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80090029L);
//
// MessageId: NTE_NO_MORE_ITEMS
//
// MessageText:
//
// No more data is available.
//
static const int NTE_NO_MORE_ITEMS = _HRESULT_TYPEDEF_(0x8009002AL);
//
// MessageId: NTE_BUFFERS_OVERLAP
//
// MessageText:
//
// The supplied buffers overlap incorrectly.
//
static const int NTE_BUFFERS_OVERLAP = _HRESULT_TYPEDEF_(0x8009002BL);
//
// MessageId: NTE_DECRYPTION_FAILURE
//
// MessageText:
//
// The specified data could not be decrypted.
//
static const int NTE_DECRYPTION_FAILURE = _HRESULT_TYPEDEF_(0x8009002CL);
//
// MessageId: NTE_INTERNAL_ERROR
//
// MessageText:
//
// An internal consistency check failed.
//
static const int NTE_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0x8009002DL);
//
// MessageId: NTE_UI_REQUIRED
//
// MessageText:
//
// This operation requires input from the user.
//
static const int NTE_UI_REQUIRED = _HRESULT_TYPEDEF_(0x8009002EL);
//
// MessageId: NTE_HMAC_NOT_SUPPORTED
//
// MessageText:
//
// The cryptographic provider does not support HMAC.
//
static const int NTE_HMAC_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8009002FL);
//
// MessageId: SEC_E_INSUFFICIENT_MEMORY
//
// MessageText:
//
// Not enough memory is available to complete this request
//
static const int SEC_E_INSUFFICIENT_MEMORY = _HRESULT_TYPEDEF_(0x80090300L);
//
// MessageId: SEC_E_INVALID_HANDLE
//
// MessageText:
//
// The handle specified is invalid
//
static const int SEC_E_INVALID_HANDLE = _HRESULT_TYPEDEF_(0x80090301L);
//
// MessageId: SEC_E_UNSUPPORTED_FUNCTION
//
// MessageText:
//
// The function requested is not supported
//
static const int SEC_E_UNSUPPORTED_FUNCTION = _HRESULT_TYPEDEF_(0x80090302L);
//
// MessageId: SEC_E_TARGET_UNKNOWN
//
// MessageText:
//
// The specified target is unknown or unreachable
//
static const int SEC_E_TARGET_UNKNOWN = _HRESULT_TYPEDEF_(0x80090303L);
//
// MessageId: SEC_E_INTERNAL_ERROR
//
// MessageText:
//
// The Local Security Authority cannot be contacted
//
static const int SEC_E_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0x80090304L);
//
// MessageId: SEC_E_SECPKG_NOT_FOUND
//
// MessageText:
//
// The requested security package does not exist
//
static const int SEC_E_SECPKG_NOT_FOUND = _HRESULT_TYPEDEF_(0x80090305L);
//
// MessageId: SEC_E_NOT_OWNER
//
// MessageText:
//
// The caller is not the owner of the desired credentials
//
static const int SEC_E_NOT_OWNER = _HRESULT_TYPEDEF_(0x80090306L);
//
// MessageId: SEC_E_CANNOT_INSTALL
//
// MessageText:
//
// The security package failed to initialize, and cannot be installed
//
static const int SEC_E_CANNOT_INSTALL = _HRESULT_TYPEDEF_(0x80090307L);
//
// MessageId: SEC_E_INVALID_TOKEN
//
// MessageText:
//
// The token supplied to the function is invalid
//
static const int SEC_E_INVALID_TOKEN = _HRESULT_TYPEDEF_(0x80090308L);
//
// MessageId: SEC_E_CANNOT_PACK
//
// MessageText:
//
// The security package is not able to marshall the logon buffer, so the logon attempt has failed
//
static const int SEC_E_CANNOT_PACK = _HRESULT_TYPEDEF_(0x80090309L);
//
// MessageId: SEC_E_QOP_NOT_SUPPORTED
//
// MessageText:
//
// The per-message Quality of Protection is not supported by the security package
//
static const int SEC_E_QOP_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8009030AL);
//
// MessageId: SEC_E_NO_IMPERSONATION
//
// MessageText:
//
// The security context does not allow impersonation of the client
//
static const int SEC_E_NO_IMPERSONATION = _HRESULT_TYPEDEF_(0x8009030BL);
//
// MessageId: SEC_E_LOGON_DENIED
//
// MessageText:
//
// The logon attempt failed
//
static const int SEC_E_LOGON_DENIED = _HRESULT_TYPEDEF_(0x8009030CL);
//
// MessageId: SEC_E_UNKNOWN_CREDENTIALS
//
// MessageText:
//
// The credentials supplied to the package were not recognized
//
static const int SEC_E_UNKNOWN_CREDENTIALS = _HRESULT_TYPEDEF_(0x8009030DL);
//
// MessageId: SEC_E_NO_CREDENTIALS
//
// MessageText:
//
// No credentials are available in the security package
//
static const int SEC_E_NO_CREDENTIALS = _HRESULT_TYPEDEF_(0x8009030EL);
//
// MessageId: SEC_E_MESSAGE_ALTERED
//
// MessageText:
//
// The message or signature supplied for verification has been altered
//
static const int SEC_E_MESSAGE_ALTERED = _HRESULT_TYPEDEF_(0x8009030FL);
//
// MessageId: SEC_E_OUT_OF_SEQUENCE
//
// MessageText:
//
// The message supplied for verification is out of sequence
//
static const int SEC_E_OUT_OF_SEQUENCE = _HRESULT_TYPEDEF_(0x80090310L);
//
// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
//
// MessageText:
//
// No authority could be contacted for authentication.
//
static const int SEC_E_NO_AUTHENTICATING_AUTHORITY = _HRESULT_TYPEDEF_(0x80090311L);
//
// MessageId: SEC_I_CONTINUE_NEEDED
//
// MessageText:
//
// The function completed successfully, but must be called again to complete the context
//
static const int SEC_I_CONTINUE_NEEDED = _HRESULT_TYPEDEF_(0x00090312L);
//
// MessageId: SEC_I_COMPLETE_NEEDED
//
// MessageText:
//
// The function completed successfully, but CompleteToken must be called
//
static const int SEC_I_COMPLETE_NEEDED = _HRESULT_TYPEDEF_(0x00090313L);
//
// MessageId: SEC_I_COMPLETE_AND_CONTINUE
//
// MessageText:
//
// The function completed successfully, but both CompleteToken and this function must be called to complete the context
//
static const int SEC_I_COMPLETE_AND_CONTINUE = _HRESULT_TYPEDEF_(0x00090314L);
//
// MessageId: SEC_I_LOCAL_LOGON
//
// MessageText:
//
// The logon was completed, but no network authority was available. The logon was made using locally known information
//
static const int SEC_I_LOCAL_LOGON = _HRESULT_TYPEDEF_(0x00090315L);
//
// MessageId: SEC_E_BAD_PKGID
//
// MessageText:
//
// The requested security package does not exist
//
static const int SEC_E_BAD_PKGID = _HRESULT_TYPEDEF_(0x80090316L);
//
// MessageId: SEC_E_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//
static const int SEC_E_CONTEXT_EXPIRED = _HRESULT_TYPEDEF_(0x80090317L);
//
// MessageId: SEC_I_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//
static const int SEC_I_CONTEXT_EXPIRED = _HRESULT_TYPEDEF_(0x00090317L);
//
// MessageId: SEC_E_INCOMPLETE_MESSAGE
//
// MessageText:
//
// The supplied message is incomplete. The signature was not verified.
//
static const int SEC_E_INCOMPLETE_MESSAGE = _HRESULT_TYPEDEF_(0x80090318L);
//
// MessageId: SEC_E_INCOMPLETE_CREDENTIALS
//
// MessageText:
//
// The credentials supplied were not complete, and could not be verified. The context could not be initialized.
//
static const int SEC_E_INCOMPLETE_CREDENTIALS = _HRESULT_TYPEDEF_(0x80090320L);
//
// MessageId: SEC_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffers supplied to a function was too small.
//
static const int SEC_E_BUFFER_TOO_SMALL = _HRESULT_TYPEDEF_(0x80090321L);
//
// MessageId: SEC_I_INCOMPLETE_CREDENTIALS
//
// MessageText:
//
// The credentials supplied were not complete, and could not be verified. Additional information can be returned from the context.
//
static const int SEC_I_INCOMPLETE_CREDENTIALS = _HRESULT_TYPEDEF_(0x00090320L);
//
// MessageId: SEC_I_RENEGOTIATE
//
// MessageText:
//
// The context data must be renegotiated with the peer.
//
static const int SEC_I_RENEGOTIATE = _HRESULT_TYPEDEF_(0x00090321L);
//
// MessageId: SEC_E_WRONG_PRINCIPAL
//
// MessageText:
//
// The target principal name is incorrect.
//
static const int SEC_E_WRONG_PRINCIPAL = _HRESULT_TYPEDEF_(0x80090322L);
//
// MessageId: SEC_I_NO_LSA_CONTEXT
//
// MessageText:
//
// There is no LSA mode context associated with this context.
//
static const int SEC_I_NO_LSA_CONTEXT = _HRESULT_TYPEDEF_(0x00090323L);
//
// MessageId: SEC_E_TIME_SKEW
//
// MessageText:
//
// The clocks on the client and server machines are skewed.
//
static const int SEC_E_TIME_SKEW = _HRESULT_TYPEDEF_(0x80090324L);
//
// MessageId: SEC_E_UNTRUSTED_ROOT
//
// MessageText:
//
// The certificate chain was issued by an authority that is not trusted.
//
static const int SEC_E_UNTRUSTED_ROOT = _HRESULT_TYPEDEF_(0x80090325L);
//
// MessageId: SEC_E_ILLEGAL_MESSAGE
//
// MessageText:
//
// The message received was unexpected or badly formatted.
//
static const int SEC_E_ILLEGAL_MESSAGE = _HRESULT_TYPEDEF_(0x80090326L);
//
// MessageId: SEC_E_CERT_UNKNOWN
//
// MessageText:
//
// An unknown error occurred while processing the certificate.
//
static const int SEC_E_CERT_UNKNOWN = _HRESULT_TYPEDEF_(0x80090327L);
//
// MessageId: SEC_E_CERT_EXPIRED
//
// MessageText:
//
// The received certificate has expired.
//
static const int SEC_E_CERT_EXPIRED = _HRESULT_TYPEDEF_(0x80090328L);
//
// MessageId: SEC_E_ENCRYPT_FAILURE
//
// MessageText:
//
// The specified data could not be encrypted.
//
static const int SEC_E_ENCRYPT_FAILURE = _HRESULT_TYPEDEF_(0x80090329L);
//
// MessageId: SEC_E_DECRYPT_FAILURE
//
// MessageText:
//
// The specified data could not be decrypted.
// 
//
static const int SEC_E_DECRYPT_FAILURE = _HRESULT_TYPEDEF_(0x80090330L);
//
// MessageId: SEC_E_ALGORITHM_MISMATCH
//
// MessageText:
//
// The client and server cannot communicate, because they do not possess a common algorithm.
//
static const int SEC_E_ALGORITHM_MISMATCH = _HRESULT_TYPEDEF_(0x80090331L);
//
// MessageId: SEC_E_SECURITY_QOS_FAILED
//
// MessageText:
//
// The security context could not be established due to a failure in the requested quality of service (e.g. mutual authentication or delegation).
//
static const int SEC_E_SECURITY_QOS_FAILED = _HRESULT_TYPEDEF_(0x80090332L);
//
// MessageId: SEC_E_UNFINISHED_CONTEXT_DELETED
//
// MessageText:
//
// A security context was deleted before the context was completed. This is considered a logon failure.
//
static const int SEC_E_UNFINISHED_CONTEXT_DELETED = _HRESULT_TYPEDEF_(0x80090333L);
//
// MessageId: SEC_E_NO_TGT_REPLY
//
// MessageText:
//
// The client is trying to negotiate a context and the server requires user-to-user but didn't send a TGT reply.
//
static const int SEC_E_NO_TGT_REPLY = _HRESULT_TYPEDEF_(0x80090334L);
//
// MessageId: SEC_E_NO_IP_ADDRESSES
//
// MessageText:
//
// Unable to accomplish the requested task because the local machine does not have any IP addresses.
//
static const int SEC_E_NO_IP_ADDRESSES = _HRESULT_TYPEDEF_(0x80090335L);
//
// MessageId: SEC_E_WRONG_CREDENTIAL_HANDLE
//
// MessageText:
//
// The supplied credential handle does not match the credential associated with the security context.
//
static const int SEC_E_WRONG_CREDENTIAL_HANDLE = _HRESULT_TYPEDEF_(0x80090336L);
//
// MessageId: SEC_E_CRYPTO_SYSTEM_INVALID
//
// MessageText:
//
// The crypto system or checksum function is invalid because a required function is unavailable.
//
static const int SEC_E_CRYPTO_SYSTEM_INVALID = _HRESULT_TYPEDEF_(0x80090337L);
//
// MessageId: SEC_E_MAX_REFERRALS_EXCEEDED
//
// MessageText:
//
// The number of maximum ticket referrals has been exceeded.
//
static const int SEC_E_MAX_REFERRALS_EXCEEDED = _HRESULT_TYPEDEF_(0x80090338L);
//
// MessageId: SEC_E_MUST_BE_KDC
//
// MessageText:
//
// The local machine must be a Kerberos KDC (domain controller) and it is not.
//
static const int SEC_E_MUST_BE_KDC = _HRESULT_TYPEDEF_(0x80090339L);
//
// MessageId: SEC_E_STRONG_CRYPTO_NOT_SUPPORTED
//
// MessageText:
//
// The other end of the security negotiation is requires strong crypto but it is not supported on the local machine.
//
static const int SEC_E_STRONG_CRYPTO_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8009033AL);
//
// MessageId: SEC_E_TOO_MANY_PRINCIPALS
//
// MessageText:
//
// The KDC reply contained more than one principal name.
//
static const int SEC_E_TOO_MANY_PRINCIPALS = _HRESULT_TYPEDEF_(0x8009033BL);
//
// MessageId: SEC_E_NO_PA_DATA
//
// MessageText:
//
// Expected to find PA data for a hint of what etype to use, but it was not found.
//
static const int SEC_E_NO_PA_DATA = _HRESULT_TYPEDEF_(0x8009033CL);
//
// MessageId: SEC_E_PKINIT_NAME_MISMATCH
//
// MessageText:
//
// The client certificate does not contain a valid UPN, or does not match the client name in the logon request. Please contact your administrator.
//
static const int SEC_E_PKINIT_NAME_MISMATCH = _HRESULT_TYPEDEF_(0x8009033DL);
//
// MessageId: SEC_E_SMARTCARD_LOGON_REQUIRED
//
// MessageText:
//
// Smartcard logon is required and was not used.
//
static const int SEC_E_SMARTCARD_LOGON_REQUIRED = _HRESULT_TYPEDEF_(0x8009033EL);
//
// MessageId: SEC_E_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//
static const int SEC_E_SHUTDOWN_IN_PROGRESS = _HRESULT_TYPEDEF_(0x8009033FL);
//
// MessageId: SEC_E_KDC_INVALID_REQUEST
//
// MessageText:
//
// An invalid request was sent to the KDC.
//
static const int SEC_E_KDC_INVALID_REQUEST = _HRESULT_TYPEDEF_(0x80090340L);
//
// MessageId: SEC_E_KDC_UNABLE_TO_REFER
//
// MessageText:
//
// The KDC was unable to generate a referral for the service requested.
//
static const int SEC_E_KDC_UNABLE_TO_REFER = _HRESULT_TYPEDEF_(0x80090341L);
//
// MessageId: SEC_E_KDC_UNKNOWN_ETYPE
//
// MessageText:
//
// The encryption type requested is not supported by the KDC.
//
static const int SEC_E_KDC_UNKNOWN_ETYPE = _HRESULT_TYPEDEF_(0x80090342L);
//
// MessageId: SEC_E_UNSUPPORTED_PREAUTH
//
// MessageText:
//
// An unsupported preauthentication mechanism was presented to the Kerberos package.
//
static const int SEC_E_UNSUPPORTED_PREAUTH = _HRESULT_TYPEDEF_(0x80090343L);
//
// MessageId: SEC_E_DELEGATION_REQUIRED
//
// MessageText:
//
// The requested operation cannot be completed. The computer must be trusted for delegation and the current user account must be configured to allow delegation.
//
static const int SEC_E_DELEGATION_REQUIRED = _HRESULT_TYPEDEF_(0x80090345L);
//
// MessageId: SEC_E_BAD_BINDINGS
//
// MessageText:
//
// Client's supplied SSPI channel bindings were incorrect.
//
static const int SEC_E_BAD_BINDINGS = _HRESULT_TYPEDEF_(0x80090346L);
//
// MessageId: SEC_E_MULTIPLE_ACCOUNTS
//
// MessageText:
//
// The received certificate was mapped to multiple accounts.
//
static const int SEC_E_MULTIPLE_ACCOUNTS = _HRESULT_TYPEDEF_(0x80090347L);
//
// MessageId: SEC_E_NO_KERB_KEY
//
// MessageText:
//
//  SEC_E_NO_KERB_KEY
//
static const int SEC_E_NO_KERB_KEY = _HRESULT_TYPEDEF_(0x80090348L);
//
// MessageId: SEC_E_CERT_WRONG_USAGE
//
// MessageText:
//
// The certificate is not valid for the requested usage.
//
static const int SEC_E_CERT_WRONG_USAGE = _HRESULT_TYPEDEF_(0x80090349L);
//
// MessageId: SEC_E_DOWNGRADE_DETECTED
//
// MessageText:
//
// The system detected a possible attempt to compromise security. Please ensure that you can contact the server that authenticated you.
//
static const int SEC_E_DOWNGRADE_DETECTED = _HRESULT_TYPEDEF_(0x80090350L);
//
// MessageId: SEC_E_SMARTCARD_CERT_REVOKED
//
// MessageText:
//
// The smartcard certificate used for authentication has been revoked. Please contact your system administrator. There may be additional information in the event log.
//
static const int SEC_E_SMARTCARD_CERT_REVOKED = _HRESULT_TYPEDEF_(0x80090351L);
//
// MessageId: SEC_E_ISSUING_CA_UNTRUSTED
//
// MessageText:
//
// An untrusted certificate authority was detected While processing the smartcard certificate used for authentication. Please contact your system administrator.
//
static const int SEC_E_ISSUING_CA_UNTRUSTED = _HRESULT_TYPEDEF_(0x80090352L);
//
// MessageId: SEC_E_REVOCATION_OFFLINE_C
//
// MessageText:
//
// The revocation status of the smartcard certificate used for authentication could not be determined. Please contact your system administrator.
//
static const int SEC_E_REVOCATION_OFFLINE_C = _HRESULT_TYPEDEF_(0x80090353L);
//
// MessageId: SEC_E_PKINIT_CLIENT_FAILURE
//
// MessageText:
//
// The smartcard certificate used for authentication was not trusted. Please contact your system administrator.
//
static const int SEC_E_PKINIT_CLIENT_FAILURE = _HRESULT_TYPEDEF_(0x80090354L);
//
// MessageId: SEC_E_SMARTCARD_CERT_EXPIRED
//
// MessageText:
//
// The smartcard certificate used for authentication has expired. Please contact your system administrator.
//
static const int SEC_E_SMARTCARD_CERT_EXPIRED = _HRESULT_TYPEDEF_(0x80090355L);
//
// MessageId: SEC_E_NO_S4U_PROT_SUPPORT
//
// MessageText:
//
// The Kerberos subsystem encountered an error. A service for user protocol request was made against a domain controller which does not support service for user.
//
static const int SEC_E_NO_S4U_PROT_SUPPORT = _HRESULT_TYPEDEF_(0x80090356L);
//
// MessageId: SEC_E_CROSSREALM_DELEGATION_FAILURE
//
// MessageText:
//
// An attempt was made by this server to make a Kerberos constrained delegation request for a target outside of the server's realm. This is not supported, and indicates a misconfiguration on this server's allowed to delegate to list. Please contact your administrator.
//
static const int SEC_E_CROSSREALM_DELEGATION_FAILURE = _HRESULT_TYPEDEF_(0x80090357L);
//
// MessageId: SEC_E_REVOCATION_OFFLINE_KDC
//
// MessageText:
//
// The revocation status of the domain controller certificate used for smartcard authentication could not be determined. There is additional information in the system event log. Please contact your system administrator.
//
static const int SEC_E_REVOCATION_OFFLINE_KDC = _HRESULT_TYPEDEF_(0x80090358L);
//
// MessageId: SEC_E_ISSUING_CA_UNTRUSTED_KDC
//
// MessageText:
//
// An untrusted certificate authority was detected while processing the domain controller certificate used for authentication. There is additional information in the system event log. Please contact your system administrator.
//
static const int SEC_E_ISSUING_CA_UNTRUSTED_KDC = _HRESULT_TYPEDEF_(0x80090359L);
//
// MessageId: SEC_E_KDC_CERT_EXPIRED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has expired. Please contact your system administrator with the contents of your system event log.
//
static const int SEC_E_KDC_CERT_EXPIRED = _HRESULT_TYPEDEF_(0x8009035AL);
//
// MessageId: SEC_E_KDC_CERT_REVOKED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has been revoked. Please contact your system administrator with the contents of your system event log.
//
static const int SEC_E_KDC_CERT_REVOKED = _HRESULT_TYPEDEF_(0x8009035BL);
//
// MessageId: SEC_I_SIGNATURE_NEEDED
//
// MessageText:
//
// A signature operation must be performed before the user can authenticate.
//
static const int SEC_I_SIGNATURE_NEEDED = _HRESULT_TYPEDEF_(0x0009035CL);
//
// MessageId: SEC_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more of the parameters passed to the function was invalid.
//
static const int SEC_E_INVALID_PARAMETER = _HRESULT_TYPEDEF_(0x8009035DL);
//
// MessageId: SEC_E_DELEGATION_POLICY
//
// MessageText:
//
// Client policy does not allow credential delegation to target server.
//
static const int SEC_E_DELEGATION_POLICY = _HRESULT_TYPEDEF_(0x8009035EL);
//
// MessageId: SEC_E_POLICY_NLTM_ONLY
//
// MessageText:
//
// Client policy does not allow credential delegation to target server with NLTM only authentication.
//
static const int SEC_E_POLICY_NLTM_ONLY = _HRESULT_TYPEDEF_(0x8009035FL);
//
// MessageId: SEC_I_NO_RENEGOTIATION
//
// MessageText:
//
// The recipient rejected the renegotiation request.
//
static const int SEC_I_NO_RENEGOTIATION = _HRESULT_TYPEDEF_(0x00090360L);
//
// MessageId: SEC_E_NO_CONTEXT
//
// MessageText:
//
// The required security context does not exist.
//
static const int SEC_E_NO_CONTEXT = _HRESULT_TYPEDEF_(0x80090361L);
//
// MessageId: SEC_E_PKU2U_CERT_FAILURE
//
// MessageText:
//
// The PKU2U protocol encountered an error while attempting to utilize the associated certificates.
//
static const int SEC_E_PKU2U_CERT_FAILURE = _HRESULT_TYPEDEF_(0x80090362L);
//
// MessageId: SEC_E_MUTUAL_AUTH_FAILED
//
// MessageText:
//
// The identity of the server computer could not be verified.
//
static const int SEC_E_MUTUAL_AUTH_FAILED = _HRESULT_TYPEDEF_(0x80090363L);
//
// Provided for backwards compatibility
//
static const int SEC_E_NO_SPM = SEC_E_INTERNAL_ERROR;
static const int SEC_E_NOT_SUPPORTED = SEC_E_UNSUPPORTED_FUNCTION;
//
// MessageId: CRYPT_E_MSG_ERROR
//
// MessageText:
//
// An error occurred while performing an operation on a cryptographic message.
//
static const int CRYPT_E_MSG_ERROR = _HRESULT_TYPEDEF_(0x80091001L);
//
// MessageId: CRYPT_E_UNKNOWN_ALGO
//
// MessageText:
//
// Unknown cryptographic algorithm.
//
static const int CRYPT_E_UNKNOWN_ALGO = _HRESULT_TYPEDEF_(0x80091002L);
//
// MessageId: CRYPT_E_OID_FORMAT
//
// MessageText:
//
// The object identifier is poorly formatted.
//
static const int CRYPT_E_OID_FORMAT = _HRESULT_TYPEDEF_(0x80091003L);
//
// MessageId: CRYPT_E_INVALID_MSG_TYPE
//
// MessageText:
//
// Invalid cryptographic message type.
//
static const int CRYPT_E_INVALID_MSG_TYPE = _HRESULT_TYPEDEF_(0x80091004L);
//
// MessageId: CRYPT_E_UNEXPECTED_ENCODING
//
// MessageText:
//
// Unexpected cryptographic message encoding.
//
static const int CRYPT_E_UNEXPECTED_ENCODING = _HRESULT_TYPEDEF_(0x80091005L);
//
// MessageId: CRYPT_E_AUTH_ATTR_MISSING
//
// MessageText:
//
// The cryptographic message does not contain an expected authenticated attribute.
//
static const int CRYPT_E_AUTH_ATTR_MISSING = _HRESULT_TYPEDEF_(0x80091006L);
//
// MessageId: CRYPT_E_HASH_VALUE
//
// MessageText:
//
// The hash value is not correct.
//
static const int CRYPT_E_HASH_VALUE = _HRESULT_TYPEDEF_(0x80091007L);
//
// MessageId: CRYPT_E_INVALID_INDEX
//
// MessageText:
//
// The index value is not valid.
//
static const int CRYPT_E_INVALID_INDEX = _HRESULT_TYPEDEF_(0x80091008L);
//
// MessageId: CRYPT_E_ALREADY_DECRYPTED
//
// MessageText:
//
// The content of the cryptographic message has already been decrypted.
//
static const int CRYPT_E_ALREADY_DECRYPTED = _HRESULT_TYPEDEF_(0x80091009L);
//
// MessageId: CRYPT_E_NOT_DECRYPTED
//
// MessageText:
//
// The content of the cryptographic message has not been decrypted yet.
//
static const int CRYPT_E_NOT_DECRYPTED = _HRESULT_TYPEDEF_(0x8009100AL);
//
// MessageId: CRYPT_E_RECIPIENT_NOT_FOUND
//
// MessageText:
//
// The enveloped-data message does not contain the specified recipient.
//
static const int CRYPT_E_RECIPIENT_NOT_FOUND = _HRESULT_TYPEDEF_(0x8009100BL);
//
// MessageId: CRYPT_E_CONTROL_TYPE
//
// MessageText:
//
// Invalid control type.
//
static const int CRYPT_E_CONTROL_TYPE = _HRESULT_TYPEDEF_(0x8009100CL);
//
// MessageId: CRYPT_E_ISSUER_SERIALNUMBER
//
// MessageText:
//
// Invalid issuer and/or serial number.
//
static const int CRYPT_E_ISSUER_SERIALNUMBER = _HRESULT_TYPEDEF_(0x8009100DL);
//
// MessageId: CRYPT_E_SIGNER_NOT_FOUND
//
// MessageText:
//
// Cannot find the original signer.
//
static const int CRYPT_E_SIGNER_NOT_FOUND = _HRESULT_TYPEDEF_(0x8009100EL);
//
// MessageId: CRYPT_E_ATTRIBUTES_MISSING
//
// MessageText:
//
// The cryptographic message does not contain all of the requested attributes.
//
static const int CRYPT_E_ATTRIBUTES_MISSING = _HRESULT_TYPEDEF_(0x8009100FL);
//
// MessageId: CRYPT_E_STREAM_MSG_NOT_READY
//
// MessageText:
//
// The streamed cryptographic message is not ready to return data.
//
static const int CRYPT_E_STREAM_MSG_NOT_READY = _HRESULT_TYPEDEF_(0x80091010L);
//
// MessageId: CRYPT_E_STREAM_INSUFFICIENT_DATA
//
// MessageText:
//
// The streamed cryptographic message requires more data to complete the decode operation.
//
static const int CRYPT_E_STREAM_INSUFFICIENT_DATA = _HRESULT_TYPEDEF_(0x80091011L);
//
// MessageId: CRYPT_I_NEW_PROTECTION_REQUIRED
//
// MessageText:
//
// The protected data needs to be re-protected.
//
static const int CRYPT_I_NEW_PROTECTION_REQUIRED = _HRESULT_TYPEDEF_(0x00091012L);
//
// MessageId: CRYPT_E_BAD_LEN
//
// MessageText:
//
// The length specified for the output data was insufficient.
//
static const int CRYPT_E_BAD_LEN = _HRESULT_TYPEDEF_(0x80092001L);
//
// MessageId: CRYPT_E_BAD_ENCODE
//
// MessageText:
//
// An error occurred during encode or decode operation.
//
static const int CRYPT_E_BAD_ENCODE = _HRESULT_TYPEDEF_(0x80092002L);
//
// MessageId: CRYPT_E_FILE_ERROR
//
// MessageText:
//
// An error occurred while reading or writing to a file.
//
static const int CRYPT_E_FILE_ERROR = _HRESULT_TYPEDEF_(0x80092003L);
//
// MessageId: CRYPT_E_NOT_FOUND
//
// MessageText:
//
// Cannot find object or property.
//
static const int CRYPT_E_NOT_FOUND = _HRESULT_TYPEDEF_(0x80092004L);
//
// MessageId: CRYPT_E_EXISTS
//
// MessageText:
//
// The object or property already exists.
//
static const int CRYPT_E_EXISTS = _HRESULT_TYPEDEF_(0x80092005L);
//
// MessageId: CRYPT_E_NO_PROVIDER
//
// MessageText:
//
// No provider was specified for the store or object.
//
static const int CRYPT_E_NO_PROVIDER = _HRESULT_TYPEDEF_(0x80092006L);
//
// MessageId: CRYPT_E_SELF_SIGNED
//
// MessageText:
//
// The specified certificate is self signed.
//
static const int CRYPT_E_SELF_SIGNED = _HRESULT_TYPEDEF_(0x80092007L);
//
// MessageId: CRYPT_E_DELETED_PREV
//
// MessageText:
//
// The previous certificate or CRL context was deleted.
//
static const int CRYPT_E_DELETED_PREV = _HRESULT_TYPEDEF_(0x80092008L);
//
// MessageId: CRYPT_E_NO_MATCH
//
// MessageText:
//
// Cannot find the requested object.
//
static const int CRYPT_E_NO_MATCH = _HRESULT_TYPEDEF_(0x80092009L);
//
// MessageId: CRYPT_E_UNEXPECTED_MSG_TYPE
//
// MessageText:
//
// The certificate does not have a property that references a private key.
//
static const int CRYPT_E_UNEXPECTED_MSG_TYPE = _HRESULT_TYPEDEF_(0x8009200AL);
//
// MessageId: CRYPT_E_NO_KEY_PROPERTY
//
// MessageText:
//
// Cannot find the certificate and private key for decryption.
//
static const int CRYPT_E_NO_KEY_PROPERTY = _HRESULT_TYPEDEF_(0x8009200BL);
//
// MessageId: CRYPT_E_NO_DECRYPT_CERT
//
// MessageText:
//
// Cannot find the certificate and private key to use for decryption.
//
static const int CRYPT_E_NO_DECRYPT_CERT = _HRESULT_TYPEDEF_(0x8009200CL);
//
// MessageId: CRYPT_E_BAD_MSG
//
// MessageText:
//
// Not a cryptographic message or the cryptographic message is not formatted correctly.
//
static const int CRYPT_E_BAD_MSG = _HRESULT_TYPEDEF_(0x8009200DL);
//
// MessageId: CRYPT_E_NO_SIGNER
//
// MessageText:
//
// The signed cryptographic message does not have a signer for the specified signer index.
//
static const int CRYPT_E_NO_SIGNER = _HRESULT_TYPEDEF_(0x8009200EL);
//
// MessageId: CRYPT_E_PENDING_CLOSE
//
// MessageText:
//
// Final closure is pending until additional frees or closes.
//
static const int CRYPT_E_PENDING_CLOSE = _HRESULT_TYPEDEF_(0x8009200FL);
//
// MessageId: CRYPT_E_REVOKED
//
// MessageText:
//
// The certificate is revoked.
//
static const int CRYPT_E_REVOKED = _HRESULT_TYPEDEF_(0x80092010L);
//
// MessageId: CRYPT_E_NO_REVOCATION_DLL
//
// MessageText:
//
// No Dll or exported function was found to verify revocation.
//
static const int CRYPT_E_NO_REVOCATION_DLL = _HRESULT_TYPEDEF_(0x80092011L);
//
// MessageId: CRYPT_E_NO_REVOCATION_CHECK
//
// MessageText:
//
// The revocation function was unable to check revocation for the certificate.
//
static const int CRYPT_E_NO_REVOCATION_CHECK = _HRESULT_TYPEDEF_(0x80092012L);
//
// MessageId: CRYPT_E_REVOCATION_OFFLINE
//
// MessageText:
//
// The revocation function was unable to check revocation because the revocation server was offline.
//
static const int CRYPT_E_REVOCATION_OFFLINE = _HRESULT_TYPEDEF_(0x80092013L);
//
// MessageId: CRYPT_E_NOT_IN_REVOCATION_DATABASE
//
// MessageText:
//
// The certificate is not in the revocation server's database.
//
static const int CRYPT_E_NOT_IN_REVOCATION_DATABASE = _HRESULT_TYPEDEF_(0x80092014L);
//
// MessageId: CRYPT_E_INVALID_NUMERIC_STRING
//
// MessageText:
//
// The string contains a non-numeric character.
//
static const int CRYPT_E_INVALID_NUMERIC_STRING = _HRESULT_TYPEDEF_(0x80092020L);
//
// MessageId: CRYPT_E_INVALID_PRINTABLE_STRING
//
// MessageText:
//
// The string contains a non-printable character.
//
static const int CRYPT_E_INVALID_PRINTABLE_STRING = _HRESULT_TYPEDEF_(0x80092021L);
//
// MessageId: CRYPT_E_INVALID_IA5_STRING
//
// MessageText:
//
// The string contains a character not in the 7 bit ASCII character set.
//
static const int CRYPT_E_INVALID_IA5_STRING = _HRESULT_TYPEDEF_(0x80092022L);
//
// MessageId: CRYPT_E_INVALID_X500_STRING
//
// MessageText:
//
// The string contains an invalid X500 name attribute key, oid, value or delimiter.
//
static const int CRYPT_E_INVALID_X500_STRING = _HRESULT_TYPEDEF_(0x80092023L);
//
// MessageId: CRYPT_E_NOT_CHAR_STRING
//
// MessageText:
//
// The dwValueType for the CERT_NAME_VALUE is not one of the character strings. Most likely it is either a CERT_RDN_ENCODED_BLOB or CERT_TDN_OCTED_STRING.
//
static const int CRYPT_E_NOT_CHAR_STRING = _HRESULT_TYPEDEF_(0x80092024L);
//
// MessageId: CRYPT_E_FILERESIZED
//
// MessageText:
//
// The Put operation cannot continue. The file needs to be resized. However, there is already a signature present. A complete signing operation must be done.
//
static const int CRYPT_E_FILERESIZED = _HRESULT_TYPEDEF_(0x80092025L);
//
// MessageId: CRYPT_E_SECURITY_SETTINGS
//
// MessageText:
//
// The cryptographic operation failed due to a local security option setting.
//
static const int CRYPT_E_SECURITY_SETTINGS = _HRESULT_TYPEDEF_(0x80092026L);
//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_DLL
//
// MessageText:
//
// No DLL or exported function was found to verify subject usage.
//
static const int CRYPT_E_NO_VERIFY_USAGE_DLL = _HRESULT_TYPEDEF_(0x80092027L);
//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_CHECK
//
// MessageText:
//
// The called function was unable to do a usage check on the subject.
//
static const int CRYPT_E_NO_VERIFY_USAGE_CHECK = _HRESULT_TYPEDEF_(0x80092028L);
//
// MessageId: CRYPT_E_VERIFY_USAGE_OFFLINE
//
// MessageText:
//
// Since the server was offline, the called function was unable to complete the usage check.
//
static const int CRYPT_E_VERIFY_USAGE_OFFLINE = _HRESULT_TYPEDEF_(0x80092029L);
//
// MessageId: CRYPT_E_NOT_IN_CTL
//
// MessageText:
//
// The subject was not found in a Certificate Trust List (CTL).
//
static const int CRYPT_E_NOT_IN_CTL = _HRESULT_TYPEDEF_(0x8009202AL);
//
// MessageId: CRYPT_E_NO_TRUSTED_SIGNER
//
// MessageText:
//
// None of the signers of the cryptographic message or certificate trust list is trusted.
//
static const int CRYPT_E_NO_TRUSTED_SIGNER = _HRESULT_TYPEDEF_(0x8009202BL);
//
// MessageId: CRYPT_E_MISSING_PUBKEY_PARA
//
// MessageText:
//
// The public key's algorithm parameters are missing.
//
static const int CRYPT_E_MISSING_PUBKEY_PARA = _HRESULT_TYPEDEF_(0x8009202CL);
//
// MessageId: CRYPT_E_OSS_ERROR
//
// MessageText:
//
// OSS Certificate encode/decode error code base
// 
// See asn1code.h for a definition of the OSS runtime errors. The OSS error values are offset by CRYPT_E_OSS_ERROR.
//
static const int CRYPT_E_OSS_ERROR = _HRESULT_TYPEDEF_(0x80093000L);
//
// MessageId: OSS_MORE_BUF
//
// MessageText:
//
// OSS ASN.1 Error: Output Buffer is too small.
//
static const int OSS_MORE_BUF = _HRESULT_TYPEDEF_(0x80093001L);
//
// MessageId: OSS_NEGATIVE_UINTEGER
//
// MessageText:
//
// OSS ASN.1 Error: Signed integer is encoded as a unsigned integer.
//
static const int OSS_NEGATIVE_UINTEGER = _HRESULT_TYPEDEF_(0x80093002L);
//
// MessageId: OSS_PDU_RANGE
//
// MessageText:
//
// OSS ASN.1 Error: Unknown ASN.1 data type.
//
static const int OSS_PDU_RANGE = _HRESULT_TYPEDEF_(0x80093003L);
//
// MessageId: OSS_MORE_INPUT
//
// MessageText:
//
// OSS ASN.1 Error: Output buffer is too small, the decoded data has been truncated.
//
static const int OSS_MORE_INPUT = _HRESULT_TYPEDEF_(0x80093004L);
//
// MessageId: OSS_DATA_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_DATA_ERROR = _HRESULT_TYPEDEF_(0x80093005L);
//
// MessageId: OSS_BAD_ARG
//
// MessageText:
//
// OSS ASN.1 Error: Invalid argument.
//
static const int OSS_BAD_ARG = _HRESULT_TYPEDEF_(0x80093006L);
//
// MessageId: OSS_BAD_VERSION
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode version mismatch.
//
static const int OSS_BAD_VERSION = _HRESULT_TYPEDEF_(0x80093007L);
//
// MessageId: OSS_OUT_MEMORY
//
// MessageText:
//
// OSS ASN.1 Error: Out of memory.
//
static const int OSS_OUT_MEMORY = _HRESULT_TYPEDEF_(0x80093008L);
//
// MessageId: OSS_PDU_MISMATCH
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode Error.
//
static const int OSS_PDU_MISMATCH = _HRESULT_TYPEDEF_(0x80093009L);
//
// MessageId: OSS_LIMITED
//
// MessageText:
//
// OSS ASN.1 Error: Internal Error.
//
static const int OSS_LIMITED = _HRESULT_TYPEDEF_(0x8009300AL);
//
// MessageId: OSS_BAD_PTR
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_BAD_PTR = _HRESULT_TYPEDEF_(0x8009300BL);
//
// MessageId: OSS_BAD_TIME
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_BAD_TIME = _HRESULT_TYPEDEF_(0x8009300CL);
//
// MessageId: OSS_INDEFINITE_NOT_SUPPORTED
//
// MessageText:
//
// OSS ASN.1 Error: Unsupported BER indefinite-length encoding.
//
static const int OSS_INDEFINITE_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8009300DL);
//
// MessageId: OSS_MEM_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Access violation.
//
static const int OSS_MEM_ERROR = _HRESULT_TYPEDEF_(0x8009300EL);
//
// MessageId: OSS_BAD_TABLE
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_BAD_TABLE = _HRESULT_TYPEDEF_(0x8009300FL);
//
// MessageId: OSS_TOO_LONG
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_TOO_LONG = _HRESULT_TYPEDEF_(0x80093010L);
//
// MessageId: OSS_CONSTRAINT_VIOLATED
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_CONSTRAINT_VIOLATED = _HRESULT_TYPEDEF_(0x80093011L);
//
// MessageId: OSS_FATAL_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Internal Error.
//
static const int OSS_FATAL_ERROR = _HRESULT_TYPEDEF_(0x80093012L);
//
// MessageId: OSS_ACCESS_SERIALIZATION_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Multi-threading conflict.
//
static const int OSS_ACCESS_SERIALIZATION_ERROR = _HRESULT_TYPEDEF_(0x80093013L);
//
// MessageId: OSS_NULL_TBL
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_NULL_TBL = _HRESULT_TYPEDEF_(0x80093014L);
//
// MessageId: OSS_NULL_FCN
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_NULL_FCN = _HRESULT_TYPEDEF_(0x80093015L);
//
// MessageId: OSS_BAD_ENCRULES
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_BAD_ENCRULES = _HRESULT_TYPEDEF_(0x80093016L);
//
// MessageId: OSS_UNAVAIL_ENCRULES
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode function not implemented.
//
static const int OSS_UNAVAIL_ENCRULES = _HRESULT_TYPEDEF_(0x80093017L);
//
// MessageId: OSS_CANT_OPEN_TRACE_WINDOW
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
static const int OSS_CANT_OPEN_TRACE_WINDOW = _HRESULT_TYPEDEF_(0x80093018L);
//
// MessageId: OSS_UNIMPLEMENTED
//
// MessageText:
//
// OSS ASN.1 Error: Function not implemented.
//
static const int OSS_UNIMPLEMENTED = _HRESULT_TYPEDEF_(0x80093019L);
//
// MessageId: OSS_OID_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_OID_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x8009301AL);
//
// MessageId: OSS_CANT_OPEN_TRACE_FILE
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
static const int OSS_CANT_OPEN_TRACE_FILE = _HRESULT_TYPEDEF_(0x8009301BL);
//
// MessageId: OSS_TRACE_FILE_ALREADY_OPEN
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
static const int OSS_TRACE_FILE_ALREADY_OPEN = _HRESULT_TYPEDEF_(0x8009301CL);
//
// MessageId: OSS_TABLE_MISMATCH
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_TABLE_MISMATCH = _HRESULT_TYPEDEF_(0x8009301DL);
//
// MessageId: OSS_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
static const int OSS_TYPE_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8009301EL);
//
// MessageId: OSS_REAL_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_REAL_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x8009301FL);
//
// MessageId: OSS_REAL_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_REAL_CODE_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093020L);
//
// MessageId: OSS_OUT_OF_RANGE
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_OUT_OF_RANGE = _HRESULT_TYPEDEF_(0x80093021L);
//
// MessageId: OSS_COPIER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_COPIER_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093022L);
//
// MessageId: OSS_CONSTRAINT_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_CONSTRAINT_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093023L);
//
// MessageId: OSS_COMPARATOR_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_COMPARATOR_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093024L);
//
// MessageId: OSS_COMPARATOR_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_COMPARATOR_CODE_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093025L);
//
// MessageId: OSS_MEM_MGR_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_MEM_MGR_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093026L);
//
// MessageId: OSS_PDV_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_PDV_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093027L);
//
// MessageId: OSS_PDV_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_PDV_CODE_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093028L);
//
// MessageId: OSS_API_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_API_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x80093029L);
//
// MessageId: OSS_BERDER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_BERDER_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x8009302AL);
//
// MessageId: OSS_PER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_PER_DLL_NOT_LINKED = _HRESULT_TYPEDEF_(0x8009302BL);
//
// MessageId: OSS_OPEN_TYPE_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
static const int OSS_OPEN_TYPE_ERROR = _HRESULT_TYPEDEF_(0x8009302CL);
//
// MessageId: OSS_MUTEX_NOT_CREATED
//
// MessageText:
//
// OSS ASN.1 Error: System resource error.
//
static const int OSS_MUTEX_NOT_CREATED = _HRESULT_TYPEDEF_(0x8009302DL);
//
// MessageId: OSS_CANT_CLOSE_TRACE_FILE
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
static const int OSS_CANT_CLOSE_TRACE_FILE = _HRESULT_TYPEDEF_(0x8009302EL);
//
// MessageId: CRYPT_E_ASN1_ERROR
//
// MessageText:
//
// ASN1 Certificate encode/decode error code base. The ASN1 error values are offset by CRYPT_E_ASN1_ERROR.
//
static const int CRYPT_E_ASN1_ERROR = _HRESULT_TYPEDEF_(0x80093100L);
//
// MessageId: CRYPT_E_ASN1_INTERNAL
//
// MessageText:
//
// ASN1 internal encode or decode error.
//
static const int CRYPT_E_ASN1_INTERNAL = _HRESULT_TYPEDEF_(0x80093101L);
//
// MessageId: CRYPT_E_ASN1_EOD
//
// MessageText:
//
// ASN1 unexpected end of data.
//
static const int CRYPT_E_ASN1_EOD = _HRESULT_TYPEDEF_(0x80093102L);
//
// MessageId: CRYPT_E_ASN1_CORRUPT
//
// MessageText:
//
// ASN1 corrupted data.
//
static const int CRYPT_E_ASN1_CORRUPT = _HRESULT_TYPEDEF_(0x80093103L);
//
// MessageId: CRYPT_E_ASN1_LARGE
//
// MessageText:
//
// ASN1 value too large.
//
static const int CRYPT_E_ASN1_LARGE = _HRESULT_TYPEDEF_(0x80093104L);
//
// MessageId: CRYPT_E_ASN1_CONSTRAINT
//
// MessageText:
//
// ASN1 constraint violated.
//
static const int CRYPT_E_ASN1_CONSTRAINT = _HRESULT_TYPEDEF_(0x80093105L);
//
// MessageId: CRYPT_E_ASN1_MEMORY
//
// MessageText:
//
// ASN1 out of memory.
//
static const int CRYPT_E_ASN1_MEMORY = _HRESULT_TYPEDEF_(0x80093106L);
//
// MessageId: CRYPT_E_ASN1_OVERFLOW
//
// MessageText:
//
// ASN1 buffer overflow.
//
static const int CRYPT_E_ASN1_OVERFLOW = _HRESULT_TYPEDEF_(0x80093107L);
//
// MessageId: CRYPT_E_ASN1_BADPDU
//
// MessageText:
//
// ASN1 function not supported for this PDU.
//
static const int CRYPT_E_ASN1_BADPDU = _HRESULT_TYPEDEF_(0x80093108L);
//
// MessageId: CRYPT_E_ASN1_BADARGS
//
// MessageText:
//
// ASN1 bad arguments to function call.
//
static const int CRYPT_E_ASN1_BADARGS = _HRESULT_TYPEDEF_(0x80093109L);
//
// MessageId: CRYPT_E_ASN1_BADREAL
//
// MessageText:
//
// ASN1 bad real value.
//
static const int CRYPT_E_ASN1_BADREAL = _HRESULT_TYPEDEF_(0x8009310AL);
//
// MessageId: CRYPT_E_ASN1_BADTAG
//
// MessageText:
//
// ASN1 bad tag value met.
//
static const int CRYPT_E_ASN1_BADTAG = _HRESULT_TYPEDEF_(0x8009310BL);
//
// MessageId: CRYPT_E_ASN1_CHOICE
//
// MessageText:
//
// ASN1 bad choice value.
//
static const int CRYPT_E_ASN1_CHOICE = _HRESULT_TYPEDEF_(0x8009310CL);
//
// MessageId: CRYPT_E_ASN1_RULE
//
// MessageText:
//
// ASN1 bad encoding rule.
//
static const int CRYPT_E_ASN1_RULE = _HRESULT_TYPEDEF_(0x8009310DL);
//
// MessageId: CRYPT_E_ASN1_UTF8
//
// MessageText:
//
// ASN1 bad unicode (UTF8).
//
static const int CRYPT_E_ASN1_UTF8 = _HRESULT_TYPEDEF_(0x8009310EL);
//
// MessageId: CRYPT_E_ASN1_PDU_TYPE
//
// MessageText:
//
// ASN1 bad PDU type.
//
static const int CRYPT_E_ASN1_PDU_TYPE = _HRESULT_TYPEDEF_(0x80093133L);
//
// MessageId: CRYPT_E_ASN1_NYI
//
// MessageText:
//
// ASN1 not yet implemented.
//
static const int CRYPT_E_ASN1_NYI = _HRESULT_TYPEDEF_(0x80093134L);
//
// MessageId: CRYPT_E_ASN1_EXTENDED
//
// MessageText:
//
// ASN1 skipped unknown extension(s).
//
static const int CRYPT_E_ASN1_EXTENDED = _HRESULT_TYPEDEF_(0x80093201L);
//
// MessageId: CRYPT_E_ASN1_NOEOD
//
// MessageText:
//
// ASN1 end of data expected
//
static const int CRYPT_E_ASN1_NOEOD = _HRESULT_TYPEDEF_(0x80093202L);
//
// MessageId: CERTSRV_E_BAD_REQUESTSUBJECT
//
// MessageText:
//
// The request subject name is invalid or too long.
//
static const int CERTSRV_E_BAD_REQUESTSUBJECT = _HRESULT_TYPEDEF_(0x80094001L);
//
// MessageId: CERTSRV_E_NO_REQUEST
//
// MessageText:
//
// The request does not exist.
//
static const int CERTSRV_E_NO_REQUEST = _HRESULT_TYPEDEF_(0x80094002L);
//
// MessageId: CERTSRV_E_BAD_REQUESTSTATUS
//
// MessageText:
//
// The request's current status does not allow this operation.
//
static const int CERTSRV_E_BAD_REQUESTSTATUS = _HRESULT_TYPEDEF_(0x80094003L);
//
// MessageId: CERTSRV_E_PROPERTY_EMPTY
//
// MessageText:
//
// The requested property value is empty.
//
static const int CERTSRV_E_PROPERTY_EMPTY = _HRESULT_TYPEDEF_(0x80094004L);
//
// MessageId: CERTSRV_E_INVALID_CA_CERTIFICATE
//
// MessageText:
//
// The certification authority's certificate contains invalid data.
//
static const int CERTSRV_E_INVALID_CA_CERTIFICATE = _HRESULT_TYPEDEF_(0x80094005L);
//
// MessageId: CERTSRV_E_SERVER_SUSPENDED
//
// MessageText:
//
// Certificate service has been suspended for a database restore operation.
//
static const int CERTSRV_E_SERVER_SUSPENDED = _HRESULT_TYPEDEF_(0x80094006L);
//
// MessageId: CERTSRV_E_ENCODING_LENGTH
//
// MessageText:
//
// The certificate contains an encoded length that is potentially incompatible with older enrollment software.
//
static const int CERTSRV_E_ENCODING_LENGTH = _HRESULT_TYPEDEF_(0x80094007L);
//
// MessageId: CERTSRV_E_ROLECONFLICT
//
// MessageText:
//
// The operation is denied. The user has multiple roles assigned and the certification authority is configured to enforce role separation.
//
static const int CERTSRV_E_ROLECONFLICT = _HRESULT_TYPEDEF_(0x80094008L);
//
// MessageId: CERTSRV_E_RESTRICTEDOFFICER
//
// MessageText:
//
// The operation is denied. It can only be performed by a certificate manager that is allowed to manage certificates for the current requester.
//
static const int CERTSRV_E_RESTRICTEDOFFICER = _HRESULT_TYPEDEF_(0x80094009L);
//
// MessageId: CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED
//
// MessageText:
//
// Cannot archive private key. The certification authority is not configured for key archival.
//
static const int CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED = _HRESULT_TYPEDEF_(0x8009400AL);
//
// MessageId: CERTSRV_E_NO_VALID_KRA
//
// MessageText:
//
// Cannot archive private key. The certification authority could not verify one or more key recovery certificates.
//
static const int CERTSRV_E_NO_VALID_KRA = _HRESULT_TYPEDEF_(0x8009400BL);
//
// MessageId: CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL
//
// MessageText:
//
// The request is incorrectly formatted. The encrypted private key must be in an unauthenticated attribute in an outermost signature.
//
static const int CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL = _HRESULT_TYPEDEF_(0x8009400CL);
//
// MessageId: CERTSRV_E_NO_CAADMIN_DEFINED
//
// MessageText:
//
// At least one security principal must have the permission to manage this CA.
//
static const int CERTSRV_E_NO_CAADMIN_DEFINED = _HRESULT_TYPEDEF_(0x8009400DL);
//
// MessageId: CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE
//
// MessageText:
//
// The request contains an invalid renewal certificate attribute.
//
static const int CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE = _HRESULT_TYPEDEF_(0x8009400EL);
//
// MessageId: CERTSRV_E_NO_DB_SESSIONS
//
// MessageText:
//
// An attempt was made to open a Certification Authority database session, but there are already too many active sessions. The server may need to be configured to allow additional sessions.
//
static const int CERTSRV_E_NO_DB_SESSIONS = _HRESULT_TYPEDEF_(0x8009400FL);
//
// MessageId: CERTSRV_E_ALIGNMENT_FAULT
//
// MessageText:
//
// A memory reference caused a data alignment fault.
//
static const int CERTSRV_E_ALIGNMENT_FAULT = _HRESULT_TYPEDEF_(0x80094010L);
//
// MessageId: CERTSRV_E_ENROLL_DENIED
//
// MessageText:
//
// The permissions on this certification authority do not allow the current user to enroll for certificates.
//
static const int CERTSRV_E_ENROLL_DENIED = _HRESULT_TYPEDEF_(0x80094011L);
//
// MessageId: CERTSRV_E_TEMPLATE_DENIED
//
// MessageText:
//
// The permissions on the certificate template do not allow the current user to enroll for this type of certificate.
//
static const int CERTSRV_E_TEMPLATE_DENIED = _HRESULT_TYPEDEF_(0x80094012L);
//
// MessageId: CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE
//
// MessageText:
//
// The contacted domain controller cannot support signed LDAP traffic. Update the domain controller or configure Certificate Services to use SSL for Active Directory access.
//
static const int CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE = _HRESULT_TYPEDEF_(0x80094013L);
//
// MessageId: CERTSRV_E_ADMIN_DENIED_REQUEST
//
// MessageText:
//
// The request was denied by a certificate manager or CA administrator.
//
static const int CERTSRV_E_ADMIN_DENIED_REQUEST = _HRESULT_TYPEDEF_(0x80094014L);
//
// MessageId: CERTSRV_E_NO_POLICY_SERVER
//
// MessageText:
//
// An enrollment policy server cannot be located.
//
static const int CERTSRV_E_NO_POLICY_SERVER = _HRESULT_TYPEDEF_(0x80094015L);
//
// MessageId: CERTSRV_E_UNSUPPORTED_CERT_TYPE
//
// MessageText:
//
// The requested certificate template is not supported by this CA.
//
static const int CERTSRV_E_UNSUPPORTED_CERT_TYPE = _HRESULT_TYPEDEF_(0x80094800L);
//
// MessageId: CERTSRV_E_NO_CERT_TYPE
//
// MessageText:
//
// The request contains no certificate template information.
//
static const int CERTSRV_E_NO_CERT_TYPE = _HRESULT_TYPEDEF_(0x80094801L);
//
// MessageId: CERTSRV_E_TEMPLATE_CONFLICT
//
// MessageText:
//
// The request contains conflicting template information.
//
static const int CERTSRV_E_TEMPLATE_CONFLICT = _HRESULT_TYPEDEF_(0x80094802L);
//
// MessageId: CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED
//
// MessageText:
//
// The request is missing a required Subject Alternate name extension.
//
static const int CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED = _HRESULT_TYPEDEF_(0x80094803L);
//
// MessageId: CERTSRV_E_ARCHIVED_KEY_REQUIRED
//
// MessageText:
//
// The request is missing a required private key for archival by the server.
//
static const int CERTSRV_E_ARCHIVED_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x80094804L);
//
// MessageId: CERTSRV_E_SMIME_REQUIRED
//
// MessageText:
//
// The request is missing a required SMIME capabilities extension.
//
static const int CERTSRV_E_SMIME_REQUIRED = _HRESULT_TYPEDEF_(0x80094805L);
//
// MessageId: CERTSRV_E_BAD_RENEWAL_SUBJECT
//
// MessageText:
//
// The request was made on behalf of a subject other than the caller. The certificate template must be configured to require at least one signature to authorize the request.
//
static const int CERTSRV_E_BAD_RENEWAL_SUBJECT = _HRESULT_TYPEDEF_(0x80094806L);
//
// MessageId: CERTSRV_E_BAD_TEMPLATE_VERSION
//
// MessageText:
//
// The request template version is newer than the supported template version.
//
static const int CERTSRV_E_BAD_TEMPLATE_VERSION = _HRESULT_TYPEDEF_(0x80094807L);
//
// MessageId: CERTSRV_E_TEMPLATE_POLICY_REQUIRED
//
// MessageText:
//
// The template is missing a required signature policy attribute.
//
static const int CERTSRV_E_TEMPLATE_POLICY_REQUIRED = _HRESULT_TYPEDEF_(0x80094808L);
//
// MessageId: CERTSRV_E_SIGNATURE_POLICY_REQUIRED
//
// MessageText:
//
// The request is missing required signature policy information.
//
static const int CERTSRV_E_SIGNATURE_POLICY_REQUIRED = _HRESULT_TYPEDEF_(0x80094809L);
//
// MessageId: CERTSRV_E_SIGNATURE_COUNT
//
// MessageText:
//
// The request is missing one or more required signatures.
//
static const int CERTSRV_E_SIGNATURE_COUNT = _HRESULT_TYPEDEF_(0x8009480AL);
//
// MessageId: CERTSRV_E_SIGNATURE_REJECTED
//
// MessageText:
//
// One or more signatures did not include the required application or issuance policies. The request is missing one or more required valid signatures.
//
static const int CERTSRV_E_SIGNATURE_REJECTED = _HRESULT_TYPEDEF_(0x8009480BL);
//
// MessageId: CERTSRV_E_ISSUANCE_POLICY_REQUIRED
//
// MessageText:
//
// The request is missing one or more required signature issuance policies.
//
static const int CERTSRV_E_ISSUANCE_POLICY_REQUIRED = _HRESULT_TYPEDEF_(0x8009480CL);
//
// MessageId: CERTSRV_E_SUBJECT_UPN_REQUIRED
//
// MessageText:
//
// The UPN is unavailable and cannot be added to the Subject Alternate name.
//
static const int CERTSRV_E_SUBJECT_UPN_REQUIRED = _HRESULT_TYPEDEF_(0x8009480DL);
//
// MessageId: CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED
//
// MessageText:
//
// The Active Directory GUID is unavailable and cannot be added to the Subject Alternate name.
//
static const int CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED = _HRESULT_TYPEDEF_(0x8009480EL);
//
// MessageId: CERTSRV_E_SUBJECT_DNS_REQUIRED
//
// MessageText:
//
// The DNS name is unavailable and cannot be added to the Subject Alternate name.
//
static const int CERTSRV_E_SUBJECT_DNS_REQUIRED = _HRESULT_TYPEDEF_(0x8009480FL);
//
// MessageId: CERTSRV_E_ARCHIVED_KEY_UNEXPECTED
//
// MessageText:
//
// The request includes a private key for archival by the server, but key archival is not enabled for the specified certificate template.
//
static const int CERTSRV_E_ARCHIVED_KEY_UNEXPECTED = _HRESULT_TYPEDEF_(0x80094810L);
//
// MessageId: CERTSRV_E_KEY_LENGTH
//
// MessageText:
//
// The public key does not meet the minimum size required by the specified certificate template.
//
static const int CERTSRV_E_KEY_LENGTH = _HRESULT_TYPEDEF_(0x80094811L);
//
// MessageId: CERTSRV_E_SUBJECT_EMAIL_REQUIRED
//
// MessageText:
//
// The EMail name is unavailable and cannot be added to the Subject or Subject Alternate name.
//
static const int CERTSRV_E_SUBJECT_EMAIL_REQUIRED = _HRESULT_TYPEDEF_(0x80094812L);
//
// MessageId: CERTSRV_E_UNKNOWN_CERT_TYPE
//
// MessageText:
//
// One or more certificate templates to be enabled on this certification authority could not be found.
//
static const int CERTSRV_E_UNKNOWN_CERT_TYPE = _HRESULT_TYPEDEF_(0x80094813L);
//
// MessageId: CERTSRV_E_CERT_TYPE_OVERLAP
//
// MessageText:
//
// The certificate template renewal period is longer than the certificate validity period. The template should be reconfigured or the CA certificate renewed.
//
static const int CERTSRV_E_CERT_TYPE_OVERLAP = _HRESULT_TYPEDEF_(0x80094814L);
//
// MessageId: CERTSRV_E_TOO_MANY_SIGNATURES
//
// MessageText:
//
// The certificate template requires too many RA signatures. Only one RA signature is allowed.
//
static const int CERTSRV_E_TOO_MANY_SIGNATURES = _HRESULT_TYPEDEF_(0x80094815L);
//
// The range 0x5000-0x51ff is reserved for XENROLL errors.
//
//
// MessageId: XENROLL_E_KEY_NOT_EXPORTABLE
//
// MessageText:
//
// The key is not exportable.
//
static const int XENROLL_E_KEY_NOT_EXPORTABLE = _HRESULT_TYPEDEF_(0x80095000L);
//
// MessageId: XENROLL_E_CANNOT_ADD_ROOT_CERT
//
// MessageText:
//
// You cannot add the root CA certificate into your local store.
//
static const int XENROLL_E_CANNOT_ADD_ROOT_CERT = _HRESULT_TYPEDEF_(0x80095001L);
//
// MessageId: XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND
//
// MessageText:
//
// The key archival hash attribute was not found in the response.
//
static const int XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND = _HRESULT_TYPEDEF_(0x80095002L);
//
// MessageId: XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH
//
// MessageText:
//
// An unexpected key archival hash attribute was found in the response.
//
static const int XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH = _HRESULT_TYPEDEF_(0x80095003L);
//
// MessageId: XENROLL_E_RESPONSE_KA_HASH_MISMATCH
//
// MessageText:
//
// There is a key archival hash mismatch between the request and the response.
//
static const int XENROLL_E_RESPONSE_KA_HASH_MISMATCH = _HRESULT_TYPEDEF_(0x80095004L);
//
// MessageId: XENROLL_E_KEYSPEC_SMIME_MISMATCH
//
// MessageText:
//
// Signing certificate cannot include SMIME extension.
//
static const int XENROLL_E_KEYSPEC_SMIME_MISMATCH = _HRESULT_TYPEDEF_(0x80095005L);
//
// MessageId: TRUST_E_SYSTEM_ERROR
//
// MessageText:
//
// A system-level error occurred while verifying trust.
//
static const int TRUST_E_SYSTEM_ERROR = _HRESULT_TYPEDEF_(0x80096001L);
//
// MessageId: TRUST_E_NO_SIGNER_CERT
//
// MessageText:
//
// The certificate for the signer of the message is invalid or not found.
//
static const int TRUST_E_NO_SIGNER_CERT = _HRESULT_TYPEDEF_(0x80096002L);
//
// MessageId: TRUST_E_COUNTER_SIGNER
//
// MessageText:
//
// One of the counter signatures was invalid.
//
static const int TRUST_E_COUNTER_SIGNER = _HRESULT_TYPEDEF_(0x80096003L);
//
// MessageId: TRUST_E_CERT_SIGNATURE
//
// MessageText:
//
// The signature of the certificate cannot be verified.
//
static const int TRUST_E_CERT_SIGNATURE = _HRESULT_TYPEDEF_(0x80096004L);
//
// MessageId: TRUST_E_TIME_STAMP
//
// MessageText:
//
// The timestamp signature and/or certificate could not be verified or is malformed.
//
static const int TRUST_E_TIME_STAMP = _HRESULT_TYPEDEF_(0x80096005L);
//
// MessageId: TRUST_E_BAD_DIGEST
//
// MessageText:
//
// The digital signature of the object did not verify.
//
static const int TRUST_E_BAD_DIGEST = _HRESULT_TYPEDEF_(0x80096010L);
//
// MessageId: TRUST_E_BASIC_CONSTRAINTS
//
// MessageText:
//
// A certificate's basic constraint extension has not been observed.
//
static const int TRUST_E_BASIC_CONSTRAINTS = _HRESULT_TYPEDEF_(0x80096019L);
//
// MessageId: TRUST_E_FINANCIAL_CRITERIA
//
// MessageText:
//
// The certificate does not meet or contain the Authenticode(tm) financial extensions.
//
static const int TRUST_E_FINANCIAL_CRITERIA = _HRESULT_TYPEDEF_(0x8009601EL);
//
// Error codes for mssipotf.dll
// Most of the error codes can only occur when an error occurs
//    during font file signing
//
//
//
// MessageId: MSSIPOTF_E_OUTOFMEMRANGE
//
// MessageText:
//
// Tried to reference a part of the file outside the proper range.
//
static const int MSSIPOTF_E_OUTOFMEMRANGE = _HRESULT_TYPEDEF_(0x80097001L);
//
// MessageId: MSSIPOTF_E_CANTGETOBJECT
//
// MessageText:
//
// Could not retrieve an object from the file.
//
static const int MSSIPOTF_E_CANTGETOBJECT = _HRESULT_TYPEDEF_(0x80097002L);
//
// MessageId: MSSIPOTF_E_NOHEADTABLE
//
// MessageText:
//
// Could not find the head table in the file.
//
static const int MSSIPOTF_E_NOHEADTABLE = _HRESULT_TYPEDEF_(0x80097003L);
//
// MessageId: MSSIPOTF_E_BAD_MAGICNUMBER
//
// MessageText:
//
// The magic number in the head table is incorrect.
//
static const int MSSIPOTF_E_BAD_MAGICNUMBER = _HRESULT_TYPEDEF_(0x80097004L);
//
// MessageId: MSSIPOTF_E_BAD_OFFSET_TABLE
//
// MessageText:
//
// The offset table has incorrect values.
//
static const int MSSIPOTF_E_BAD_OFFSET_TABLE = _HRESULT_TYPEDEF_(0x80097005L);
//
// MessageId: MSSIPOTF_E_TABLE_TAGORDER
//
// MessageText:
//
// Duplicate table tags or tags out of alphabetical order.
//
static const int MSSIPOTF_E_TABLE_TAGORDER = _HRESULT_TYPEDEF_(0x80097006L);
//
// MessageId: MSSIPOTF_E_TABLE_LONGWORD
//
// MessageText:
//
// A table does not start on a long word boundary.
//
static const int MSSIPOTF_E_TABLE_LONGWORD = _HRESULT_TYPEDEF_(0x80097007L);
//
// MessageId: MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT
//
// MessageText:
//
// First table does not appear after header information.
//
static const int MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT = _HRESULT_TYPEDEF_(0x80097008L);
//
// MessageId: MSSIPOTF_E_TABLES_OVERLAP
//
// MessageText:
//
// Two or more tables overlap.
//
static const int MSSIPOTF_E_TABLES_OVERLAP = _HRESULT_TYPEDEF_(0x80097009L);
//
// MessageId: MSSIPOTF_E_TABLE_PADBYTES
//
// MessageText:
//
// Too many pad bytes between tables or pad bytes are not 0.
//
static const int MSSIPOTF_E_TABLE_PADBYTES = _HRESULT_TYPEDEF_(0x8009700AL);
//
// MessageId: MSSIPOTF_E_FILETOOSMALL
//
// MessageText:
//
// File is too small to contain the last table.
//
static const int MSSIPOTF_E_FILETOOSMALL = _HRESULT_TYPEDEF_(0x8009700BL);
//
// MessageId: MSSIPOTF_E_TABLE_CHECKSUM
//
// MessageText:
//
// A table checksum is incorrect.
//
static const int MSSIPOTF_E_TABLE_CHECKSUM = _HRESULT_TYPEDEF_(0x8009700CL);
//
// MessageId: MSSIPOTF_E_FILE_CHECKSUM
//
// MessageText:
//
// The file checksum is incorrect.
//
static const int MSSIPOTF_E_FILE_CHECKSUM = _HRESULT_TYPEDEF_(0x8009700DL);
//
// MessageId: MSSIPOTF_E_FAILED_POLICY
//
// MessageText:
//
// The signature does not have the correct attributes for the policy.
//
static const int MSSIPOTF_E_FAILED_POLICY = _HRESULT_TYPEDEF_(0x80097010L);
//
// MessageId: MSSIPOTF_E_FAILED_HINTS_CHECK
//
// MessageText:
//
// The file did not pass the hints check.
//
static const int MSSIPOTF_E_FAILED_HINTS_CHECK = _HRESULT_TYPEDEF_(0x80097011L);
//
// MessageId: MSSIPOTF_E_NOT_OPENTYPE
//
// MessageText:
//
// The file is not an OpenType file.
//
static const int MSSIPOTF_E_NOT_OPENTYPE = _HRESULT_TYPEDEF_(0x80097012L);
//
// MessageId: MSSIPOTF_E_FILE
//
// MessageText:
//
// Failed on a file operation (open, map, read, write).
//
static const int MSSIPOTF_E_FILE = _HRESULT_TYPEDEF_(0x80097013L);
//
// MessageId: MSSIPOTF_E_CRYPT
//
// MessageText:
//
// A call to a CryptoAPI function failed.
//
static const int MSSIPOTF_E_CRYPT = _HRESULT_TYPEDEF_(0x80097014L);
//
// MessageId: MSSIPOTF_E_BADVERSION
//
// MessageText:
//
// There is a bad version number in the file.
//
static const int MSSIPOTF_E_BADVERSION = _HRESULT_TYPEDEF_(0x80097015L);
//
// MessageId: MSSIPOTF_E_DSIG_STRUCTURE
//
// MessageText:
//
// The structure of the DSIG table is incorrect.
//
static const int MSSIPOTF_E_DSIG_STRUCTURE = _HRESULT_TYPEDEF_(0x80097016L);
//
// MessageId: MSSIPOTF_E_PCONST_CHECK
//
// MessageText:
//
// A check failed in a partially constant table.
//
static const int MSSIPOTF_E_PCONST_CHECK = _HRESULT_TYPEDEF_(0x80097017L);
//
// MessageId: MSSIPOTF_E_STRUCTURE
//
// MessageText:
//
// Some kind of structural error.
//
static const int MSSIPOTF_E_STRUCTURE = _HRESULT_TYPEDEF_(0x80097018L);
//
// MessageId: ERROR_CRED_REQUIRES_CONFIRMATION
//
// MessageText:
//
// The requested credential requires confirmation.
//
static const int ERROR_CRED_REQUIRES_CONFIRMATION = _HRESULT_TYPEDEF_(0x80097019L);
static const int NTE_OP_OK = 0;
//
// Note that additional FACILITY_SSPI errors are in issperr.h
//
// ******************
// FACILITY_CERT
// ******************
//
// MessageId: TRUST_E_PROVIDER_UNKNOWN
//
// MessageText:
//
// Unknown trust provider.
//
static const int TRUST_E_PROVIDER_UNKNOWN = _HRESULT_TYPEDEF_(0x800B0001L);
//
// MessageId: TRUST_E_ACTION_UNKNOWN
//
// MessageText:
//
// The trust verification action specified is not supported by the specified trust provider.
//
static const int TRUST_E_ACTION_UNKNOWN = _HRESULT_TYPEDEF_(0x800B0002L);
//
// MessageId: TRUST_E_SUBJECT_FORM_UNKNOWN
//
// MessageText:
//
// The form specified for the subject is not one supported or known by the specified trust provider.
//
static const int TRUST_E_SUBJECT_FORM_UNKNOWN = _HRESULT_TYPEDEF_(0x800B0003L);
//
// MessageId: TRUST_E_SUBJECT_NOT_TRUSTED
//
// MessageText:
//
// The subject is not trusted for the specified action.
//
static const int TRUST_E_SUBJECT_NOT_TRUSTED = _HRESULT_TYPEDEF_(0x800B0004L);
//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
// Error due to problem in ASN.1 encoding process.
//
static const int DIGSIG_E_ENCODE = _HRESULT_TYPEDEF_(0x800B0005L);
//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
// Error due to problem in ASN.1 decoding process.
//
static const int DIGSIG_E_DECODE = _HRESULT_TYPEDEF_(0x800B0006L);
//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
// Reading / writing Extensions where Attributes are appropriate, and visa versa.
//
static const int DIGSIG_E_EXTENSIBILITY = _HRESULT_TYPEDEF_(0x800B0007L);
//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
// Unspecified cryptographic failure.
//
static const int DIGSIG_E_CRYPTO = _HRESULT_TYPEDEF_(0x800B0008L);
//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
// The size of the data could not be determined.
//
static const int PERSIST_E_SIZEDEFINITE = _HRESULT_TYPEDEF_(0x800B0009L);
//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
// The size of the indefinite-sized data could not be determined.
//
static const int PERSIST_E_SIZEINDEFINITE = _HRESULT_TYPEDEF_(0x800B000AL);
//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
// This object does not read and write self-sizing data.
//
static const int PERSIST_E_NOTSELFSIZING = _HRESULT_TYPEDEF_(0x800B000BL);
//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
// No signature was present in the subject.
//
static const int TRUST_E_NOSIGNATURE = _HRESULT_TYPEDEF_(0x800B0100L);
//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
// A required certificate is not within its validity period when verifying against the current system clock or the timestamp in the signed file.
//
static const int CERT_E_EXPIRED = _HRESULT_TYPEDEF_(0x800B0101L);
//
// MessageId: CERT_E_VALIDITYPERIODNESTING
//
// MessageText:
//
// The validity periods of the certification chain do not nest correctly.
//
static const int CERT_E_VALIDITYPERIODNESTING = _HRESULT_TYPEDEF_(0x800B0102L);
//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
// A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
static const int CERT_E_ROLE = _HRESULT_TYPEDEF_(0x800B0103L);
//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
// A path length constraint in the certification chain has been violated.
//
static const int CERT_E_PATHLENCONST = _HRESULT_TYPEDEF_(0x800B0104L);
//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
// A certificate contains an unknown extension that is marked 'critical'.
//
static const int CERT_E_CRITICAL = _HRESULT_TYPEDEF_(0x800B0105L);
//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
// A certificate being used for a purpose other than the ones specified by its CA.
//
static const int CERT_E_PURPOSE = _HRESULT_TYPEDEF_(0x800B0106L);
//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
// A parent of a given certificate in fact did not issue that child certificate.
//
static const int CERT_E_ISSUERCHAINING = _HRESULT_TYPEDEF_(0x800B0107L);
//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
// A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
static const int CERT_E_MALFORMED = _HRESULT_TYPEDEF_(0x800B0108L);
//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
// A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.
//
static const int CERT_E_UNTRUSTEDROOT = _HRESULT_TYPEDEF_(0x800B0109L);
//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
// A certificate chain could not be built to a trusted root authority.
//
static const int CERT_E_CHAINING = _HRESULT_TYPEDEF_(0x800B010AL);
//
// MessageId: TRUST_E_FAIL
//
// MessageText:
//
// Generic trust failure.
//
static const int TRUST_E_FAIL = _HRESULT_TYPEDEF_(0x800B010BL);
//
// MessageId: CERT_E_REVOKED
//
// MessageText:
//
// A certificate was explicitly revoked by its issuer.
//
static const int CERT_E_REVOKED = _HRESULT_TYPEDEF_(0x800B010CL);
//
// MessageId: CERT_E_UNTRUSTEDTESTROOT
//
// MessageText:
//
// The certification path terminates with the test root which is not trusted with the current policy settings.
//
static const int CERT_E_UNTRUSTEDTESTROOT = _HRESULT_TYPEDEF_(0x800B010DL);
//
// MessageId: CERT_E_REVOCATION_FAILURE
//
// MessageText:
//
// The revocation process could not continue - the certificate(s) could not be checked.
//
static const int CERT_E_REVOCATION_FAILURE = _HRESULT_TYPEDEF_(0x800B010EL);
//
// MessageId: CERT_E_CN_NO_MATCH
//
// MessageText:
//
// The certificate's CN name does not match the passed value.
//
static const int CERT_E_CN_NO_MATCH = _HRESULT_TYPEDEF_(0x800B010FL);
//
// MessageId: CERT_E_WRONG_USAGE
//
// MessageText:
//
// The certificate is not valid for the requested usage.
//
static const int CERT_E_WRONG_USAGE = _HRESULT_TYPEDEF_(0x800B0110L);
//
// MessageId: TRUST_E_EXPLICIT_DISTRUST
//
// MessageText:
//
// The certificate was explicitly marked as untrusted by the user.
//
static const int TRUST_E_EXPLICIT_DISTRUST = _HRESULT_TYPEDEF_(0x800B0111L);
//
// MessageId: CERT_E_UNTRUSTEDCA
//
// MessageText:
//
// A certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider.
//
static const int CERT_E_UNTRUSTEDCA = _HRESULT_TYPEDEF_(0x800B0112L);
//
// MessageId: CERT_E_INVALID_POLICY
//
// MessageText:
//
// The certificate has invalid policy.
//
static const int CERT_E_INVALID_POLICY = _HRESULT_TYPEDEF_(0x800B0113L);
//
// MessageId: CERT_E_INVALID_NAME
//
// MessageText:
//
// The certificate has an invalid name. The name is not included in the permitted list or is explicitly excluded.
//
static const int CERT_E_INVALID_NAME = _HRESULT_TYPEDEF_(0x800B0114L);
// *****************
// FACILITY_SETUPAPI
// *****************
//
// Since these error codes aren't in the standard Win32 range (i.e., 0-64K), define a
// macro to map either Win32 or SetupAPI error codes into an HRESULT.
//
static const int HRESULT_FROM_SETUPAPI(x) = ((((x) & (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR)) == (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR)) ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_SETUPAPI << 16) | 0x80000000)) : HRESULT_FROM_WIN32(x));
//
// MessageId: SPAPI_E_EXPECTED_SECTION_NAME
//
// MessageText:
//
// A non-empty line was encountered in the INF before the start of a section.
//
static const int SPAPI_E_EXPECTED_SECTION_NAME = _HRESULT_TYPEDEF_(0x800F0000L);
//
// MessageId: SPAPI_E_BAD_SECTION_NAME_LINE
//
// MessageText:
//
// A section name marker in the INF is not complete, or does not exist on a line by itself.
//
static const int SPAPI_E_BAD_SECTION_NAME_LINE = _HRESULT_TYPEDEF_(0x800F0001L);
//
// MessageId: SPAPI_E_SECTION_NAME_TOO_LONG
//
// MessageText:
//
// An INF section was encountered whose name exceeds the maximum section name length.
//
static const int SPAPI_E_SECTION_NAME_TOO_LONG = _HRESULT_TYPEDEF_(0x800F0002L);
//
// MessageId: SPAPI_E_GENERAL_SYNTAX
//
// MessageText:
//
// The syntax of the INF is invalid.
//
static const int SPAPI_E_GENERAL_SYNTAX = _HRESULT_TYPEDEF_(0x800F0003L);
//
// MessageId: SPAPI_E_WRONG_INF_STYLE
//
// MessageText:
//
// The style of the INF is different than what was requested.
//
static const int SPAPI_E_WRONG_INF_STYLE = _HRESULT_TYPEDEF_(0x800F0100L);
//
// MessageId: SPAPI_E_SECTION_NOT_FOUND
//
// MessageText:
//
// The required section was not found in the INF.
//
static const int SPAPI_E_SECTION_NOT_FOUND = _HRESULT_TYPEDEF_(0x800F0101L);
//
// MessageId: SPAPI_E_LINE_NOT_FOUND
//
// MessageText:
//
// The required line was not found in the INF.
//
static const int SPAPI_E_LINE_NOT_FOUND = _HRESULT_TYPEDEF_(0x800F0102L);
//
// MessageId: SPAPI_E_NO_BACKUP
//
// MessageText:
//
// The files affected by the installation of this file queue have not been backed up for uninstall.
//
static const int SPAPI_E_NO_BACKUP = _HRESULT_TYPEDEF_(0x800F0103L);
//
// MessageId: SPAPI_E_NO_ASSOCIATED_CLASS
//
// MessageText:
//
// The INF or the device information set or element does not have an associated install class.
//
static const int SPAPI_E_NO_ASSOCIATED_CLASS = _HRESULT_TYPEDEF_(0x800F0200L);
//
// MessageId: SPAPI_E_CLASS_MISMATCH
//
// MessageText:
//
// The INF or the device information set or element does not match the specified install class.
//
static const int SPAPI_E_CLASS_MISMATCH = _HRESULT_TYPEDEF_(0x800F0201L);
//
// MessageId: SPAPI_E_DUPLICATE_FOUND
//
// MessageText:
//
// An existing device was found that is a duplicate of the device being manually installed.
//
static const int SPAPI_E_DUPLICATE_FOUND = _HRESULT_TYPEDEF_(0x800F0202L);
//
// MessageId: SPAPI_E_NO_DRIVER_SELECTED
//
// MessageText:
//
// There is no driver selected for the device information set or element.
//
static const int SPAPI_E_NO_DRIVER_SELECTED = _HRESULT_TYPEDEF_(0x800F0203L);
//
// MessageId: SPAPI_E_KEY_DOES_NOT_EXIST
//
// MessageText:
//
// The requested device registry key does not exist.
//
static const int SPAPI_E_KEY_DOES_NOT_EXIST = _HRESULT_TYPEDEF_(0x800F0204L);
//
// MessageId: SPAPI_E_INVALID_DEVINST_NAME
//
// MessageText:
//
// The device instance name is invalid.
//
static const int SPAPI_E_INVALID_DEVINST_NAME = _HRESULT_TYPEDEF_(0x800F0205L);
//
// MessageId: SPAPI_E_INVALID_CLASS
//
// MessageText:
//
// The install class is not present or is invalid.
//
static const int SPAPI_E_INVALID_CLASS = _HRESULT_TYPEDEF_(0x800F0206L);
//
// MessageId: SPAPI_E_DEVINST_ALREADY_EXISTS
//
// MessageText:
//
// The device instance cannot be created because it already exists.
//
static const int SPAPI_E_DEVINST_ALREADY_EXISTS = _HRESULT_TYPEDEF_(0x800F0207L);
//
// MessageId: SPAPI_E_DEVINFO_NOT_REGISTERED
//
// MessageText:
//
// The operation cannot be performed on a device information element that has not been registered.
//
static const int SPAPI_E_DEVINFO_NOT_REGISTERED = _HRESULT_TYPEDEF_(0x800F0208L);
//
// MessageId: SPAPI_E_INVALID_REG_PROPERTY
//
// MessageText:
//
// The device property code is invalid.
//
static const int SPAPI_E_INVALID_REG_PROPERTY = _HRESULT_TYPEDEF_(0x800F0209L);
//
// MessageId: SPAPI_E_NO_INF
//
// MessageText:
//
// The INF from which a driver list is to be built does not exist.
//
static const int SPAPI_E_NO_INF = _HRESULT_TYPEDEF_(0x800F020AL);
//
// MessageId: SPAPI_E_NO_SUCH_DEVINST
//
// MessageText:
//
// The device instance does not exist in the hardware tree.
//
static const int SPAPI_E_NO_SUCH_DEVINST = _HRESULT_TYPEDEF_(0x800F020BL);
//
// MessageId: SPAPI_E_CANT_LOAD_CLASS_ICON
//
// MessageText:
//
// The icon representing this install class cannot be loaded.
//
static const int SPAPI_E_CANT_LOAD_CLASS_ICON = _HRESULT_TYPEDEF_(0x800F020CL);
//
// MessageId: SPAPI_E_INVALID_CLASS_INSTALLER
//
// MessageText:
//
// The class installer registry entry is invalid.
//
static const int SPAPI_E_INVALID_CLASS_INSTALLER = _HRESULT_TYPEDEF_(0x800F020DL);
//
// MessageId: SPAPI_E_DI_DO_DEFAULT
//
// MessageText:
//
// The class installer has indicated that the default action should be performed for this installation request.
//
static const int SPAPI_E_DI_DO_DEFAULT = _HRESULT_TYPEDEF_(0x800F020EL);
//
// MessageId: SPAPI_E_DI_NOFILECOPY
//
// MessageText:
//
// The operation does not require any files to be copied.
//
static const int SPAPI_E_DI_NOFILECOPY = _HRESULT_TYPEDEF_(0x800F020FL);
//
// MessageId: SPAPI_E_INVALID_HWPROFILE
//
// MessageText:
//
// The specified hardware profile does not exist.
//
static const int SPAPI_E_INVALID_HWPROFILE = _HRESULT_TYPEDEF_(0x800F0210L);
//
// MessageId: SPAPI_E_NO_DEVICE_SELECTED
//
// MessageText:
//
// There is no device information element currently selected for this device information set.
//
static const int SPAPI_E_NO_DEVICE_SELECTED = _HRESULT_TYPEDEF_(0x800F0211L);
//
// MessageId: SPAPI_E_DEVINFO_LIST_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the device information set is locked.
//
static const int SPAPI_E_DEVINFO_LIST_LOCKED = _HRESULT_TYPEDEF_(0x800F0212L);
//
// MessageId: SPAPI_E_DEVINFO_DATA_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the device information element is locked.
//
static const int SPAPI_E_DEVINFO_DATA_LOCKED = _HRESULT_TYPEDEF_(0x800F0213L);
//
// MessageId: SPAPI_E_DI_BAD_PATH
//
// MessageText:
//
// The specified path does not contain any applicable device INFs.
//
static const int SPAPI_E_DI_BAD_PATH = _HRESULT_TYPEDEF_(0x800F0214L);
//
// MessageId: SPAPI_E_NO_CLASSINSTALL_PARAMS
//
// MessageText:
//
// No class installer parameters have been set for the device information set or element.
//
static const int SPAPI_E_NO_CLASSINSTALL_PARAMS = _HRESULT_TYPEDEF_(0x800F0215L);
//
// MessageId: SPAPI_E_FILEQUEUE_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the file queue is locked.
//
static const int SPAPI_E_FILEQUEUE_LOCKED = _HRESULT_TYPEDEF_(0x800F0216L);
//
// MessageId: SPAPI_E_BAD_SERVICE_INSTALLSECT
//
// MessageText:
//
// A service installation section in this INF is invalid.
//
static const int SPAPI_E_BAD_SERVICE_INSTALLSECT = _HRESULT_TYPEDEF_(0x800F0217L);
//
// MessageId: SPAPI_E_NO_CLASS_DRIVER_LIST
//
// MessageText:
//
// There is no class driver list for the device information element.
//
static const int SPAPI_E_NO_CLASS_DRIVER_LIST = _HRESULT_TYPEDEF_(0x800F0218L);
//
// MessageId: SPAPI_E_NO_ASSOCIATED_SERVICE
//
// MessageText:
//
// The installation failed because a function driver was not specified for this device instance.
//
static const int SPAPI_E_NO_ASSOCIATED_SERVICE = _HRESULT_TYPEDEF_(0x800F0219L);
//
// MessageId: SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE
//
// MessageText:
//
// There is presently no default device interface designated for this interface class.
//
static const int SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE = _HRESULT_TYPEDEF_(0x800F021AL);
//
// MessageId: SPAPI_E_DEVICE_INTERFACE_ACTIVE
//
// MessageText:
//
// The operation cannot be performed because the device interface is currently active.
//
static const int SPAPI_E_DEVICE_INTERFACE_ACTIVE = _HRESULT_TYPEDEF_(0x800F021BL);
//
// MessageId: SPAPI_E_DEVICE_INTERFACE_REMOVED
//
// MessageText:
//
// The operation cannot be performed because the device interface has been removed from the system.
//
static const int SPAPI_E_DEVICE_INTERFACE_REMOVED = _HRESULT_TYPEDEF_(0x800F021CL);
//
// MessageId: SPAPI_E_BAD_INTERFACE_INSTALLSECT
//
// MessageText:
//
// An interface installation section in this INF is invalid.
//
static const int SPAPI_E_BAD_INTERFACE_INSTALLSECT = _HRESULT_TYPEDEF_(0x800F021DL);
//
// MessageId: SPAPI_E_NO_SUCH_INTERFACE_CLASS
//
// MessageText:
//
// This interface class does not exist in the system.
//
static const int SPAPI_E_NO_SUCH_INTERFACE_CLASS = _HRESULT_TYPEDEF_(0x800F021EL);
//
// MessageId: SPAPI_E_INVALID_REFERENCE_STRING
//
// MessageText:
//
// The reference string supplied for this interface device is invalid.
//
static const int SPAPI_E_INVALID_REFERENCE_STRING = _HRESULT_TYPEDEF_(0x800F021FL);
//
// MessageId: SPAPI_E_INVALID_MACHINENAME
//
// MessageText:
//
// The specified machine name does not conform to UNC naming conventions.
//
static const int SPAPI_E_INVALID_MACHINENAME = _HRESULT_TYPEDEF_(0x800F0220L);
//
// MessageId: SPAPI_E_REMOTE_COMM_FAILURE
//
// MessageText:
//
// A general remote communication error occurred.
//
static const int SPAPI_E_REMOTE_COMM_FAILURE = _HRESULT_TYPEDEF_(0x800F0221L);
//
// MessageId: SPAPI_E_MACHINE_UNAVAILABLE
//
// MessageText:
//
// The machine selected for remote communication is not available at this time.
//
static const int SPAPI_E_MACHINE_UNAVAILABLE = _HRESULT_TYPEDEF_(0x800F0222L);
//
// MessageId: SPAPI_E_NO_CONFIGMGR_SERVICES
//
// MessageText:
//
// The Plug and Play service is not available on the remote machine.
//
static const int SPAPI_E_NO_CONFIGMGR_SERVICES = _HRESULT_TYPEDEF_(0x800F0223L);
//
// MessageId: SPAPI_E_INVALID_PROPPAGE_PROVIDER
//
// MessageText:
//
// The property page provider registry entry is invalid.
//
static const int SPAPI_E_INVALID_PROPPAGE_PROVIDER = _HRESULT_TYPEDEF_(0x800F0224L);
//
// MessageId: SPAPI_E_NO_SUCH_DEVICE_INTERFACE
//
// MessageText:
//
// The requested device interface is not present in the system.
//
static const int SPAPI_E_NO_SUCH_DEVICE_INTERFACE = _HRESULT_TYPEDEF_(0x800F0225L);
//
// MessageId: SPAPI_E_DI_POSTPROCESSING_REQUIRED
//
// MessageText:
//
// The device's co-installer has additional work to perform after installation is complete.
//
static const int SPAPI_E_DI_POSTPROCESSING_REQUIRED = _HRESULT_TYPEDEF_(0x800F0226L);
//
// MessageId: SPAPI_E_INVALID_COINSTALLER
//
// MessageText:
//
// The device's co-installer is invalid.
//
static const int SPAPI_E_INVALID_COINSTALLER = _HRESULT_TYPEDEF_(0x800F0227L);
//
// MessageId: SPAPI_E_NO_COMPAT_DRIVERS
//
// MessageText:
//
// There are no compatible drivers for this device.
//
static const int SPAPI_E_NO_COMPAT_DRIVERS = _HRESULT_TYPEDEF_(0x800F0228L);
//
// MessageId: SPAPI_E_NO_DEVICE_ICON
//
// MessageText:
//
// There is no icon that represents this device or device type.
//
static const int SPAPI_E_NO_DEVICE_ICON = _HRESULT_TYPEDEF_(0x800F0229L);
//
// MessageId: SPAPI_E_INVALID_INF_LOGCONFIG
//
// MessageText:
//
// A logical configuration specified in this INF is invalid.
//
static const int SPAPI_E_INVALID_INF_LOGCONFIG = _HRESULT_TYPEDEF_(0x800F022AL);
//
// MessageId: SPAPI_E_DI_DONT_INSTALL
//
// MessageText:
//
// The class installer has denied the request to install or upgrade this device.
//
static const int SPAPI_E_DI_DONT_INSTALL = _HRESULT_TYPEDEF_(0x800F022BL);
//
// MessageId: SPAPI_E_INVALID_FILTER_DRIVER
//
// MessageText:
//
// One of the filter drivers installed for this device is invalid.
//
static const int SPAPI_E_INVALID_FILTER_DRIVER = _HRESULT_TYPEDEF_(0x800F022CL);
//
// MessageId: SPAPI_E_NON_WINDOWS_NT_DRIVER
//
// MessageText:
//
// The driver selected for this device does not support this version of Windows.
//
static const int SPAPI_E_NON_WINDOWS_NT_DRIVER = _HRESULT_TYPEDEF_(0x800F022DL);
//
// MessageId: SPAPI_E_NON_WINDOWS_DRIVER
//
// MessageText:
//
// The driver selected for this device does not support Windows.
//
static const int SPAPI_E_NON_WINDOWS_DRIVER = _HRESULT_TYPEDEF_(0x800F022EL);
//
// MessageId: SPAPI_E_NO_CATALOG_FOR_OEM_INF
//
// MessageText:
//
// The third-party INF does not contain digital signature information.
//
static const int SPAPI_E_NO_CATALOG_FOR_OEM_INF = _HRESULT_TYPEDEF_(0x800F022FL);
//
// MessageId: SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE
//
// MessageText:
//
// An invalid attempt was made to use a device installation file queue for verification of digital signatures relative to other platforms.
//
static const int SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE = _HRESULT_TYPEDEF_(0x800F0230L);
//
// MessageId: SPAPI_E_NOT_DISABLEABLE
//
// MessageText:
//
// The device cannot be disabled.
//
static const int SPAPI_E_NOT_DISABLEABLE = _HRESULT_TYPEDEF_(0x800F0231L);
//
// MessageId: SPAPI_E_CANT_REMOVE_DEVINST
//
// MessageText:
//
// The device could not be dynamically removed.
//
static const int SPAPI_E_CANT_REMOVE_DEVINST = _HRESULT_TYPEDEF_(0x800F0232L);
//
// MessageId: SPAPI_E_INVALID_TARGET
//
// MessageText:
//
// Cannot copy to specified target.
//
static const int SPAPI_E_INVALID_TARGET = _HRESULT_TYPEDEF_(0x800F0233L);
//
// MessageId: SPAPI_E_DRIVER_NONNATIVE
//
// MessageText:
//
// Driver is not intended for this platform.
//
static const int SPAPI_E_DRIVER_NONNATIVE = _HRESULT_TYPEDEF_(0x800F0234L);
//
// MessageId: SPAPI_E_IN_WOW64
//
// MessageText:
//
// Operation not allowed in WOW64.
//
static const int SPAPI_E_IN_WOW64 = _HRESULT_TYPEDEF_(0x800F0235L);
//
// MessageId: SPAPI_E_SET_SYSTEM_RESTORE_POINT
//
// MessageText:
//
// The operation involving unsigned file copying was rolled back, so that a system restore point could be set.
//
static const int SPAPI_E_SET_SYSTEM_RESTORE_POINT = _HRESULT_TYPEDEF_(0x800F0236L);
//
// MessageId: SPAPI_E_INCORRECTLY_COPIED_INF
//
// MessageText:
//
// An INF was copied into the Windows INF directory in an improper manner.
//
static const int SPAPI_E_INCORRECTLY_COPIED_INF = _HRESULT_TYPEDEF_(0x800F0237L);
//
// MessageId: SPAPI_E_SCE_DISABLED
//
// MessageText:
//
// The Security Configuration Editor (SCE) APIs have been disabled on this Embedded product.
//
static const int SPAPI_E_SCE_DISABLED = _HRESULT_TYPEDEF_(0x800F0238L);
//
// MessageId: SPAPI_E_UNKNOWN_EXCEPTION
//
// MessageText:
//
// An unknown exception was encountered.
//
static const int SPAPI_E_UNKNOWN_EXCEPTION = _HRESULT_TYPEDEF_(0x800F0239L);
//
// MessageId: SPAPI_E_PNP_REGISTRY_ERROR
//
// MessageText:
//
// A problem was encountered when accessing the Plug and Play registry database.
//
static const int SPAPI_E_PNP_REGISTRY_ERROR = _HRESULT_TYPEDEF_(0x800F023AL);
//
// MessageId: SPAPI_E_REMOTE_REQUEST_UNSUPPORTED
//
// MessageText:
//
// The requested operation is not supported for a remote machine.
//
static const int SPAPI_E_REMOTE_REQUEST_UNSUPPORTED = _HRESULT_TYPEDEF_(0x800F023BL);
//
// MessageId: SPAPI_E_NOT_AN_INSTALLED_OEM_INF
//
// MessageText:
//
// The specified file is not an installed OEM INF.
//
static const int SPAPI_E_NOT_AN_INSTALLED_OEM_INF = _HRESULT_TYPEDEF_(0x800F023CL);
//
// MessageId: SPAPI_E_INF_IN_USE_BY_DEVICES
//
// MessageText:
//
// One or more devices are presently installed using the specified INF.
//
static const int SPAPI_E_INF_IN_USE_BY_DEVICES = _HRESULT_TYPEDEF_(0x800F023DL);
//
// MessageId: SPAPI_E_DI_FUNCTION_OBSOLETE
//
// MessageText:
//
// The requested device install operation is obsolete.
//
static const int SPAPI_E_DI_FUNCTION_OBSOLETE = _HRESULT_TYPEDEF_(0x800F023EL);
//
// MessageId: SPAPI_E_NO_AUTHENTICODE_CATALOG
//
// MessageText:
//
// A file could not be verified because it does not have an associated catalog signed via Authenticode(tm).
//
static const int SPAPI_E_NO_AUTHENTICODE_CATALOG = _HRESULT_TYPEDEF_(0x800F023FL);
//
// MessageId: SPAPI_E_AUTHENTICODE_DISALLOWED
//
// MessageText:
//
// Authenticode(tm) signature verification is not supported for the specified INF.
//
static const int SPAPI_E_AUTHENTICODE_DISALLOWED = _HRESULT_TYPEDEF_(0x800F0240L);
//
// MessageId: SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER
//
// MessageText:
//
// The INF was signed with an Authenticode(tm) catalog from a trusted publisher.
//
static const int SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER = _HRESULT_TYPEDEF_(0x800F0241L);
//
// MessageId: SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED
//
// MessageText:
//
// The publisher of an Authenticode(tm) signed catalog has not yet been established as trusted.
//
static const int SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED = _HRESULT_TYPEDEF_(0x800F0242L);
//
// MessageId: SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED
//
// MessageText:
//
// The publisher of an Authenticode(tm) signed catalog was not established as trusted.
//
static const int SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED = _HRESULT_TYPEDEF_(0x800F0243L);
//
// MessageId: SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH
//
// MessageText:
//
// The software was tested for compliance with Windows Logo requirements on a different version of Windows, and may not be compatible with this version.
//
static const int SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH = _HRESULT_TYPEDEF_(0x800F0244L);
//
// MessageId: SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE
//
// MessageText:
//
// The file may only be validated by a catalog signed via Authenticode(tm).
//
static const int SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE = _HRESULT_TYPEDEF_(0x800F0245L);
//
// MessageId: SPAPI_E_DEVICE_INSTALLER_NOT_READY
//
// MessageText:
//
// One of the installers for this device cannot perform the installation at this time.
//
static const int SPAPI_E_DEVICE_INSTALLER_NOT_READY = _HRESULT_TYPEDEF_(0x800F0246L);
//
// MessageId: SPAPI_E_DRIVER_STORE_ADD_FAILED
//
// MessageText:
//
// A problem was encountered while attempting to add the driver to the store.
//
static const int SPAPI_E_DRIVER_STORE_ADD_FAILED = _HRESULT_TYPEDEF_(0x800F0247L);
//
// MessageId: SPAPI_E_DEVICE_INSTALL_BLOCKED
//
// MessageText:
//
// The installation of this device is forbidden by system policy. Contact your system administrator.
//
static const int SPAPI_E_DEVICE_INSTALL_BLOCKED = _HRESULT_TYPEDEF_(0x800F0248L);
//
// MessageId: SPAPI_E_DRIVER_INSTALL_BLOCKED
//
// MessageText:
//
// The installation of this driver is forbidden by system policy. Contact your system administrator.
//
static const int SPAPI_E_DRIVER_INSTALL_BLOCKED = _HRESULT_TYPEDEF_(0x800F0249L);
//
// MessageId: SPAPI_E_WRONG_INF_TYPE
//
// MessageText:
//
// The specified INF is the wrong type for this operation.
//
static const int SPAPI_E_WRONG_INF_TYPE = _HRESULT_TYPEDEF_(0x800F024AL);
//
// MessageId: SPAPI_E_FILE_HASH_NOT_IN_CATALOG
//
// MessageText:
//
// The hash for the file is not present in the specified catalog file. The file is likely corrupt or the victim of tampering.
//
static const int SPAPI_E_FILE_HASH_NOT_IN_CATALOG = _HRESULT_TYPEDEF_(0x800F024BL);
//
// MessageId: SPAPI_E_DRIVER_STORE_DELETE_FAILED
//
// MessageText:
//
// A problem was encountered while attempting to delete the driver from the store.
//
static const int SPAPI_E_DRIVER_STORE_DELETE_FAILED = _HRESULT_TYPEDEF_(0x800F024CL);
//
// MessageId: SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW
//
// MessageText:
//
// An unrecoverable stack overflow was encountered.
//
static const int SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW = _HRESULT_TYPEDEF_(0x800F0300L);
//
// MessageId: SPAPI_E_ERROR_NOT_INSTALLED
//
// MessageText:
//
// No installed components were detected.
//
static const int SPAPI_E_ERROR_NOT_INSTALLED = _HRESULT_TYPEDEF_(0x800F1000L);
// *****************
// FACILITY_SCARD
// *****************
//
// =============================
// Facility SCARD Error Messages
// =============================
//
static const int SCARD_S_SUCCESS = NO_ERROR;
//
// MessageId: SCARD_F_INTERNAL_ERROR
//
// MessageText:
//
// An internal consistency check failed.
//
static const int SCARD_F_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0x80100001L);
//
// MessageId: SCARD_E_CANCELLED
//
// MessageText:
//
// The action was cancelled by an SCardCancel request.
//
static const int SCARD_E_CANCELLED = _HRESULT_TYPEDEF_(0x80100002L);
//
// MessageId: SCARD_E_INVALID_HANDLE
//
// MessageText:
//
// The supplied handle was invalid.
//
static const int SCARD_E_INVALID_HANDLE = _HRESULT_TYPEDEF_(0x80100003L);
//
// MessageId: SCARD_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more of the supplied parameters could not be properly interpreted.
//
static const int SCARD_E_INVALID_PARAMETER = _HRESULT_TYPEDEF_(0x80100004L);
//
// MessageId: SCARD_E_INVALID_TARGET
//
// MessageText:
//
// Registry startup information is missing or invalid.
//
static const int SCARD_E_INVALID_TARGET = _HRESULT_TYPEDEF_(0x80100005L);
//
// MessageId: SCARD_E_NO_MEMORY
//
// MessageText:
//
// Not enough memory available to complete this command.
//
static const int SCARD_E_NO_MEMORY = _HRESULT_TYPEDEF_(0x80100006L);
//
// MessageId: SCARD_F_WAITED_TOO_LONG
//
// MessageText:
//
// An internal consistency timer has expired.
//
static const int SCARD_F_WAITED_TOO_LONG = _HRESULT_TYPEDEF_(0x80100007L);
//
// MessageId: SCARD_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The data buffer to receive returned data is too small for the returned data.
//
static const int SCARD_E_INSUFFICIENT_BUFFER = _HRESULT_TYPEDEF_(0x80100008L);
//
// MessageId: SCARD_E_UNKNOWN_READER
//
// MessageText:
//
// The specified reader name is not recognized.
//
static const int SCARD_E_UNKNOWN_READER = _HRESULT_TYPEDEF_(0x80100009L);
//
// MessageId: SCARD_E_TIMEOUT
//
// MessageText:
//
// The user-specified timeout value has expired.
//
static const int SCARD_E_TIMEOUT = _HRESULT_TYPEDEF_(0x8010000AL);
//
// MessageId: SCARD_E_SHARING_VIOLATION
//
// MessageText:
//
// The smart card cannot be accessed because of other connections outstanding.
//
static const int SCARD_E_SHARING_VIOLATION = _HRESULT_TYPEDEF_(0x8010000BL);
//
// MessageId: SCARD_E_NO_SMARTCARD
//
// MessageText:
//
// The operation requires a Smart Card, but no Smart Card is currently in the device.
//
static const int SCARD_E_NO_SMARTCARD = _HRESULT_TYPEDEF_(0x8010000CL);
//
// MessageId: SCARD_E_UNKNOWN_CARD
//
// MessageText:
//
// The specified smart card name is not recognized.
//
static const int SCARD_E_UNKNOWN_CARD = _HRESULT_TYPEDEF_(0x8010000DL);
//
// MessageId: SCARD_E_CANT_DISPOSE
//
// MessageText:
//
// The system could not dispose of the media in the requested manner.
//
static const int SCARD_E_CANT_DISPOSE = _HRESULT_TYPEDEF_(0x8010000EL);
//
// MessageId: SCARD_E_PROTO_MISMATCH
//
// MessageText:
//
// The requested protocols are incompatible with the protocol currently in use with the smart card.
//
static const int SCARD_E_PROTO_MISMATCH = _HRESULT_TYPEDEF_(0x8010000FL);
//
// MessageId: SCARD_E_NOT_READY
//
// MessageText:
//
// The reader or smart card is not ready to accept commands.
//
static const int SCARD_E_NOT_READY = _HRESULT_TYPEDEF_(0x80100010L);
//
// MessageId: SCARD_E_INVALID_VALUE
//
// MessageText:
//
// One or more of the supplied parameters values could not be properly interpreted.
//
static const int SCARD_E_INVALID_VALUE = _HRESULT_TYPEDEF_(0x80100011L);
//
// MessageId: SCARD_E_SYSTEM_CANCELLED
//
// MessageText:
//
// The action was cancelled by the system, presumably to log off or shut down.
//
static const int SCARD_E_SYSTEM_CANCELLED = _HRESULT_TYPEDEF_(0x80100012L);
//
// MessageId: SCARD_F_COMM_ERROR
//
// MessageText:
//
// An internal communications error has been detected.
//
static const int SCARD_F_COMM_ERROR = _HRESULT_TYPEDEF_(0x80100013L);
//
// MessageId: SCARD_F_UNKNOWN_ERROR
//
// MessageText:
//
// An internal error has been detected, but the source is unknown.
//
static const int SCARD_F_UNKNOWN_ERROR = _HRESULT_TYPEDEF_(0x80100014L);
//
// MessageId: SCARD_E_INVALID_ATR
//
// MessageText:
//
// An ATR obtained from the registry is not a valid ATR string.
//
static const int SCARD_E_INVALID_ATR = _HRESULT_TYPEDEF_(0x80100015L);
//
// MessageId: SCARD_E_NOT_TRANSACTED
//
// MessageText:
//
// An attempt was made to end a non-existent transaction.
//
static const int SCARD_E_NOT_TRANSACTED = _HRESULT_TYPEDEF_(0x80100016L);
//
// MessageId: SCARD_E_READER_UNAVAILABLE
//
// MessageText:
//
// The specified reader is not currently available for use.
//
static const int SCARD_E_READER_UNAVAILABLE = _HRESULT_TYPEDEF_(0x80100017L);
//
// MessageId: SCARD_P_SHUTDOWN
//
// MessageText:
//
// The operation has been aborted to allow the server application to exit.
//
static const int SCARD_P_SHUTDOWN = _HRESULT_TYPEDEF_(0x80100018L);
//
// MessageId: SCARD_E_PCI_TOO_SMALL
//
// MessageText:
//
// The PCI Receive buffer was too small.
//
static const int SCARD_E_PCI_TOO_SMALL = _HRESULT_TYPEDEF_(0x80100019L);
//
// MessageId: SCARD_E_READER_UNSUPPORTED
//
// MessageText:
//
// The reader driver does not meet minimal requirements for support.
//
static const int SCARD_E_READER_UNSUPPORTED = _HRESULT_TYPEDEF_(0x8010001AL);
//
// MessageId: SCARD_E_DUPLICATE_READER
//
// MessageText:
//
// The reader driver did not produce a unique reader name.
//
static const int SCARD_E_DUPLICATE_READER = _HRESULT_TYPEDEF_(0x8010001BL);
//
// MessageId: SCARD_E_CARD_UNSUPPORTED
//
// MessageText:
//
// The smart card does not meet minimal requirements for support.
//
static const int SCARD_E_CARD_UNSUPPORTED = _HRESULT_TYPEDEF_(0x8010001CL);
//
// MessageId: SCARD_E_NO_SERVICE
//
// MessageText:
//
// The Smart card resource manager is not running.
//
static const int SCARD_E_NO_SERVICE = _HRESULT_TYPEDEF_(0x8010001DL);
//
// MessageId: SCARD_E_SERVICE_STOPPED
//
// MessageText:
//
// The Smart card resource manager has shut down.
//
static const int SCARD_E_SERVICE_STOPPED = _HRESULT_TYPEDEF_(0x8010001EL);
//
// MessageId: SCARD_E_UNEXPECTED
//
// MessageText:
//
// An unexpected card error has occurred.
//
static const int SCARD_E_UNEXPECTED = _HRESULT_TYPEDEF_(0x8010001FL);
//
// MessageId: SCARD_E_ICC_INSTALLATION
//
// MessageText:
//
// No Primary Provider can be found for the smart card.
//
static const int SCARD_E_ICC_INSTALLATION = _HRESULT_TYPEDEF_(0x80100020L);
//
// MessageId: SCARD_E_ICC_CREATEORDER
//
// MessageText:
//
// The requested order of object creation is not supported.
//
static const int SCARD_E_ICC_CREATEORDER = _HRESULT_TYPEDEF_(0x80100021L);
//
// MessageId: SCARD_E_UNSUPPORTED_FEATURE
//
// MessageText:
//
// This smart card does not support the requested feature.
//
static const int SCARD_E_UNSUPPORTED_FEATURE = _HRESULT_TYPEDEF_(0x80100022L);
//
// MessageId: SCARD_E_DIR_NOT_FOUND
//
// MessageText:
//
// The identified directory does not exist in the smart card.
//
static const int SCARD_E_DIR_NOT_FOUND = _HRESULT_TYPEDEF_(0x80100023L);
//
// MessageId: SCARD_E_FILE_NOT_FOUND
//
// MessageText:
//
// The identified file does not exist in the smart card.
//
static const int SCARD_E_FILE_NOT_FOUND = _HRESULT_TYPEDEF_(0x80100024L);
//
// MessageId: SCARD_E_NO_DIR
//
// MessageText:
//
// The supplied path does not represent a smart card directory.
//
static const int SCARD_E_NO_DIR = _HRESULT_TYPEDEF_(0x80100025L);
//
// MessageId: SCARD_E_NO_FILE
//
// MessageText:
//
// The supplied path does not represent a smart card file.
//
static const int SCARD_E_NO_FILE = _HRESULT_TYPEDEF_(0x80100026L);
//
// MessageId: SCARD_E_NO_ACCESS
//
// MessageText:
//
// Access is denied to this file.
//
static const int SCARD_E_NO_ACCESS = _HRESULT_TYPEDEF_(0x80100027L);
//
// MessageId: SCARD_E_WRITE_TOO_MANY
//
// MessageText:
//
// The smartcard does not have enough memory to store the information.
//
static const int SCARD_E_WRITE_TOO_MANY = _HRESULT_TYPEDEF_(0x80100028L);
//
// MessageId: SCARD_E_BAD_SEEK
//
// MessageText:
//
// There was an error trying to set the smart card file object pointer.
//
static const int SCARD_E_BAD_SEEK = _HRESULT_TYPEDEF_(0x80100029L);
//
// MessageId: SCARD_E_INVALID_CHV
//
// MessageText:
//
// The supplied PIN is incorrect.
//
static const int SCARD_E_INVALID_CHV = _HRESULT_TYPEDEF_(0x8010002AL);
//
// MessageId: SCARD_E_UNKNOWN_RES_MNG
//
// MessageText:
//
// An unrecognized error code was returned from a layered component.
//
static const int SCARD_E_UNKNOWN_RES_MNG = _HRESULT_TYPEDEF_(0x8010002BL);
//
// MessageId: SCARD_E_NO_SUCH_CERTIFICATE
//
// MessageText:
//
// The requested certificate does not exist.
//
static const int SCARD_E_NO_SUCH_CERTIFICATE = _HRESULT_TYPEDEF_(0x8010002CL);
//
// MessageId: SCARD_E_CERTIFICATE_UNAVAILABLE
//
// MessageText:
//
// The requested certificate could not be obtained.
//
static const int SCARD_E_CERTIFICATE_UNAVAILABLE = _HRESULT_TYPEDEF_(0x8010002DL);
//
// MessageId: SCARD_E_NO_READERS_AVAILABLE
//
// MessageText:
//
// Cannot find a smart card reader.
//
static const int SCARD_E_NO_READERS_AVAILABLE = _HRESULT_TYPEDEF_(0x8010002EL);
//
// MessageId: SCARD_E_COMM_DATA_LOST
//
// MessageText:
//
// A communications error with the smart card has been detected. Retry the operation.
//
static const int SCARD_E_COMM_DATA_LOST = _HRESULT_TYPEDEF_(0x8010002FL);
//
// MessageId: SCARD_E_NO_KEY_CONTAINER
//
// MessageText:
//
// The requested key container does not exist on the smart card.
//
static const int SCARD_E_NO_KEY_CONTAINER = _HRESULT_TYPEDEF_(0x80100030L);
//
// MessageId: SCARD_E_SERVER_TOO_BUSY
//
// MessageText:
//
// The Smart card resource manager is too busy to complete this operation.
//
static const int SCARD_E_SERVER_TOO_BUSY = _HRESULT_TYPEDEF_(0x80100031L);
//
// MessageId: SCARD_E_PIN_CACHE_EXPIRED
//
// MessageText:
//
// The smart card PIN cache has expired.
//
static const int SCARD_E_PIN_CACHE_EXPIRED = _HRESULT_TYPEDEF_(0x80100032L);
//
// MessageId: SCARD_E_NO_PIN_CACHE
//
// MessageText:
//
// The smart card PIN cannot be cached.
//
static const int SCARD_E_NO_PIN_CACHE = _HRESULT_TYPEDEF_(0x80100033L);
//
// MessageId: SCARD_E_READ_ONLY_CARD
//
// MessageText:
//
// The smart card is read only and cannot be written to.
//
static const int SCARD_E_READ_ONLY_CARD = _HRESULT_TYPEDEF_(0x80100034L);
//
// These are warning codes.
//
//
// MessageId: SCARD_W_UNSUPPORTED_CARD
//
// MessageText:
//
// The reader cannot communicate with the smart card, due to ATR configuration conflicts.
//
static const int SCARD_W_UNSUPPORTED_CARD = _HRESULT_TYPEDEF_(0x80100065L);
//
// MessageId: SCARD_W_UNRESPONSIVE_CARD
//
// MessageText:
//
// The smart card is not responding to a reset.
//
static const int SCARD_W_UNRESPONSIVE_CARD = _HRESULT_TYPEDEF_(0x80100066L);
//
// MessageId: SCARD_W_UNPOWERED_CARD
//
// MessageText:
//
// Power has been removed from the smart card, so that further communication is not possible.
//
static const int SCARD_W_UNPOWERED_CARD = _HRESULT_TYPEDEF_(0x80100067L);
//
// MessageId: SCARD_W_RESET_CARD
//
// MessageText:
//
// The smart card has been reset, so any shared state information is invalid.
//
static const int SCARD_W_RESET_CARD = _HRESULT_TYPEDEF_(0x80100068L);
//
// MessageId: SCARD_W_REMOVED_CARD
//
// MessageText:
//
// The smart card has been removed, so that further communication is not possible.
//
static const int SCARD_W_REMOVED_CARD = _HRESULT_TYPEDEF_(0x80100069L);
//
// MessageId: SCARD_W_SECURITY_VIOLATION
//
// MessageText:
//
// Access was denied because of a security violation.
//
static const int SCARD_W_SECURITY_VIOLATION = _HRESULT_TYPEDEF_(0x8010006AL);
//
// MessageId: SCARD_W_WRONG_CHV
//
// MessageText:
//
// The card cannot be accessed because the wrong PIN was presented.
//
static const int SCARD_W_WRONG_CHV = _HRESULT_TYPEDEF_(0x8010006BL);
//
// MessageId: SCARD_W_CHV_BLOCKED
//
// MessageText:
//
// The card cannot be accessed because the maximum number of PIN entry attempts has been reached.
//
static const int SCARD_W_CHV_BLOCKED = _HRESULT_TYPEDEF_(0x8010006CL);
//
// MessageId: SCARD_W_EOF
//
// MessageText:
//
// The end of the smart card file has been reached.
//
static const int SCARD_W_EOF = _HRESULT_TYPEDEF_(0x8010006DL);
//
// MessageId: SCARD_W_CANCELLED_BY_USER
//
// MessageText:
//
// The action was cancelled by the user.
//
static const int SCARD_W_CANCELLED_BY_USER = _HRESULT_TYPEDEF_(0x8010006EL);
//
// MessageId: SCARD_W_CARD_NOT_AUTHENTICATED
//
// MessageText:
//
// No PIN was presented to the smart card.
//
static const int SCARD_W_CARD_NOT_AUTHENTICATED = _HRESULT_TYPEDEF_(0x8010006FL);
//
// MessageId: SCARD_W_CACHE_ITEM_NOT_FOUND
//
// MessageText:
//
// The requested item could not be found in the cache.
//
static const int SCARD_W_CACHE_ITEM_NOT_FOUND = _HRESULT_TYPEDEF_(0x80100070L);
//
// MessageId: SCARD_W_CACHE_ITEM_STALE
//
// MessageText:
//
// The requested cache item is too old and was deleted from the cache.
//
static const int SCARD_W_CACHE_ITEM_STALE = _HRESULT_TYPEDEF_(0x80100071L);
//
// MessageId: SCARD_W_CACHE_ITEM_TOO_BIG
//
// MessageText:
//
// The new cache item exceeds the maximum per-item size defined for the cache.
//
static const int SCARD_W_CACHE_ITEM_TOO_BIG = _HRESULT_TYPEDEF_(0x80100072L);
// *****************
// FACILITY_COMPLUS
// *****************
//
// ===============================
// Facility COMPLUS Error Messages
// ===============================
//
//
// The following are the subranges  within the COMPLUS facility
// 0x400 - 0x4ff               COMADMIN_E_CAT
// 0x600 - 0x6ff               COMQC errors
// 0x700 - 0x7ff               MSDTC errors
// 0x800 - 0x8ff               Other COMADMIN errors
//
// COMPLUS Admin errors
//
//
// MessageId: COMADMIN_E_OBJECTERRORS
//
// MessageText:
//
// Errors occurred accessing one or more objects - the ErrorInfo collection may have more detail
//
static const int COMADMIN_E_OBJECTERRORS = _HRESULT_TYPEDEF_(0x80110401L);
//
// MessageId: COMADMIN_E_OBJECTINVALID
//
// MessageText:
//
// One or more of the object's properties are missing or invalid
//
static const int COMADMIN_E_OBJECTINVALID = _HRESULT_TYPEDEF_(0x80110402L);
//
// MessageId: COMADMIN_E_KEYMISSING
//
// MessageText:
//
// The object was not found in the catalog
//
static const int COMADMIN_E_KEYMISSING = _HRESULT_TYPEDEF_(0x80110403L);
//
// MessageId: COMADMIN_E_ALREADYINSTALLED
//
// MessageText:
//
// The object is already registered
//
static const int COMADMIN_E_ALREADYINSTALLED = _HRESULT_TYPEDEF_(0x80110404L);
//
// MessageId: COMADMIN_E_APP_FILE_WRITEFAIL
//
// MessageText:
//
// Error occurred writing to the application file
//
static const int COMADMIN_E_APP_FILE_WRITEFAIL = _HRESULT_TYPEDEF_(0x80110407L);
//
// MessageId: COMADMIN_E_APP_FILE_READFAIL
//
// MessageText:
//
// Error occurred reading the application file
//
static const int COMADMIN_E_APP_FILE_READFAIL = _HRESULT_TYPEDEF_(0x80110408L);
//
// MessageId: COMADMIN_E_APP_FILE_VERSION
//
// MessageText:
//
// Invalid version number in application file
//
static const int COMADMIN_E_APP_FILE_VERSION = _HRESULT_TYPEDEF_(0x80110409L);
//
// MessageId: COMADMIN_E_BADPATH
//
// MessageText:
//
// The file path is invalid
//
static const int COMADMIN_E_BADPATH = _HRESULT_TYPEDEF_(0x8011040AL);
//
// MessageId: COMADMIN_E_APPLICATIONEXISTS
//
// MessageText:
//
// The application is already installed
//
static const int COMADMIN_E_APPLICATIONEXISTS = _HRESULT_TYPEDEF_(0x8011040BL);
//
// MessageId: COMADMIN_E_ROLEEXISTS
//
// MessageText:
//
// The role already exists
//
static const int COMADMIN_E_ROLEEXISTS = _HRESULT_TYPEDEF_(0x8011040CL);
//
// MessageId: COMADMIN_E_CANTCOPYFILE
//
// MessageText:
//
// An error occurred copying the file
//
static const int COMADMIN_E_CANTCOPYFILE = _HRESULT_TYPEDEF_(0x8011040DL);
//
// MessageId: COMADMIN_E_NOUSER
//
// MessageText:
//
// One or more users are not valid
//
static const int COMADMIN_E_NOUSER = _HRESULT_TYPEDEF_(0x8011040FL);
//
// MessageId: COMADMIN_E_INVALIDUSERIDS
//
// MessageText:
//
// One or more users in the application file are not valid
//
static const int COMADMIN_E_INVALIDUSERIDS = _HRESULT_TYPEDEF_(0x80110410L);
//
// MessageId: COMADMIN_E_NOREGISTRYCLSID
//
// MessageText:
//
// The component's CLSID is missing or corrupt
//
static const int COMADMIN_E_NOREGISTRYCLSID = _HRESULT_TYPEDEF_(0x80110411L);
//
// MessageId: COMADMIN_E_BADREGISTRYPROGID
//
// MessageText:
//
// The component's progID is missing or corrupt
//
static const int COMADMIN_E_BADREGISTRYPROGID = _HRESULT_TYPEDEF_(0x80110412L);
//
// MessageId: COMADMIN_E_AUTHENTICATIONLEVEL
//
// MessageText:
//
// Unable to set required authentication level for update request
//
static const int COMADMIN_E_AUTHENTICATIONLEVEL = _HRESULT_TYPEDEF_(0x80110413L);
//
// MessageId: COMADMIN_E_USERPASSWDNOTVALID
//
// MessageText:
//
// The identity or password set on the application is not valid
//
static const int COMADMIN_E_USERPASSWDNOTVALID = _HRESULT_TYPEDEF_(0x80110414L);
//
// MessageId: COMADMIN_E_CLSIDORIIDMISMATCH
//
// MessageText:
//
// Application file CLSIDs or IIDs do not match corresponding DLLs
//
static const int COMADMIN_E_CLSIDORIIDMISMATCH = _HRESULT_TYPEDEF_(0x80110418L);
//
// MessageId: COMADMIN_E_REMOTEINTERFACE
//
// MessageText:
//
// Interface information is either missing or changed
//
static const int COMADMIN_E_REMOTEINTERFACE = _HRESULT_TYPEDEF_(0x80110419L);
//
// MessageId: COMADMIN_E_DLLREGISTERSERVER
//
// MessageText:
//
// DllRegisterServer failed on component install
//
static const int COMADMIN_E_DLLREGISTERSERVER = _HRESULT_TYPEDEF_(0x8011041AL);
//
// MessageId: COMADMIN_E_NOSERVERSHARE
//
// MessageText:
//
// No server file share available
//
static const int COMADMIN_E_NOSERVERSHARE = _HRESULT_TYPEDEF_(0x8011041BL);
//
// MessageId: COMADMIN_E_DLLLOADFAILED
//
// MessageText:
//
// DLL could not be loaded
//
static const int COMADMIN_E_DLLLOADFAILED = _HRESULT_TYPEDEF_(0x8011041DL);
//
// MessageId: COMADMIN_E_BADREGISTRYLIBID
//
// MessageText:
//
// The registered TypeLib ID is not valid
//
static const int COMADMIN_E_BADREGISTRYLIBID = _HRESULT_TYPEDEF_(0x8011041EL);
//
// MessageId: COMADMIN_E_APPDIRNOTFOUND
//
// MessageText:
//
// Application install directory not found
//
static const int COMADMIN_E_APPDIRNOTFOUND = _HRESULT_TYPEDEF_(0x8011041FL);
//
// MessageId: COMADMIN_E_REGISTRARFAILED
//
// MessageText:
//
// Errors occurred while in the component registrar
//
static const int COMADMIN_E_REGISTRARFAILED = _HRESULT_TYPEDEF_(0x80110423L);
//
// MessageId: COMADMIN_E_COMPFILE_DOESNOTEXIST
//
// MessageText:
//
// The file does not exist
//
static const int COMADMIN_E_COMPFILE_DOESNOTEXIST = _HRESULT_TYPEDEF_(0x80110424L);
//
// MessageId: COMADMIN_E_COMPFILE_LOADDLLFAIL
//
// MessageText:
//
// The DLL could not be loaded
//
static const int COMADMIN_E_COMPFILE_LOADDLLFAIL = _HRESULT_TYPEDEF_(0x80110425L);
//
// MessageId: COMADMIN_E_COMPFILE_GETCLASSOBJ
//
// MessageText:
//
// GetClassObject failed in the DLL
//
static const int COMADMIN_E_COMPFILE_GETCLASSOBJ = _HRESULT_TYPEDEF_(0x80110426L);
//
// MessageId: COMADMIN_E_COMPFILE_CLASSNOTAVAIL
//
// MessageText:
//
// The DLL does not support the components listed in the TypeLib
//
static const int COMADMIN_E_COMPFILE_CLASSNOTAVAIL = _HRESULT_TYPEDEF_(0x80110427L);
//
// MessageId: COMADMIN_E_COMPFILE_BADTLB
//
// MessageText:
//
// The TypeLib could not be loaded
//
static const int COMADMIN_E_COMPFILE_BADTLB = _HRESULT_TYPEDEF_(0x80110428L);
//
// MessageId: COMADMIN_E_COMPFILE_NOTINSTALLABLE
//
// MessageText:
//
// The file does not contain components or component information
//
static const int COMADMIN_E_COMPFILE_NOTINSTALLABLE = _HRESULT_TYPEDEF_(0x80110429L);
//
// MessageId: COMADMIN_E_NOTCHANGEABLE
//
// MessageText:
//
// Changes to this object and its sub-objects have been disabled
//
static const int COMADMIN_E_NOTCHANGEABLE = _HRESULT_TYPEDEF_(0x8011042AL);
//
// MessageId: COMADMIN_E_NOTDELETEABLE
//
// MessageText:
//
// The delete function has been disabled for this object
//
static const int COMADMIN_E_NOTDELETEABLE = _HRESULT_TYPEDEF_(0x8011042BL);
//
// MessageId: COMADMIN_E_SESSION
//
// MessageText:
//
// The server catalog version is not supported
//
static const int COMADMIN_E_SESSION = _HRESULT_TYPEDEF_(0x8011042CL);
//
// MessageId: COMADMIN_E_COMP_MOVE_LOCKED
//
// MessageText:
//
// The component move was disallowed, because the source or destination application is either a system application or currently locked against changes
//
static const int COMADMIN_E_COMP_MOVE_LOCKED = _HRESULT_TYPEDEF_(0x8011042DL);
//
// MessageId: COMADMIN_E_COMP_MOVE_BAD_DEST
//
// MessageText:
//
// The component move failed because the destination application no longer exists
//
static const int COMADMIN_E_COMP_MOVE_BAD_DEST = _HRESULT_TYPEDEF_(0x8011042EL);
//
// MessageId: COMADMIN_E_REGISTERTLB
//
// MessageText:
//
// The system was unable to register the TypeLib
//
static const int COMADMIN_E_REGISTERTLB = _HRESULT_TYPEDEF_(0x80110430L);
//
// MessageId: COMADMIN_E_SYSTEMAPP
//
// MessageText:
//
// This operation cannot be performed on the system application
//
static const int COMADMIN_E_SYSTEMAPP = _HRESULT_TYPEDEF_(0x80110433L);
//
// MessageId: COMADMIN_E_COMPFILE_NOREGISTRAR
//
// MessageText:
//
// The component registrar referenced in this file is not available
//
static const int COMADMIN_E_COMPFILE_NOREGISTRAR = _HRESULT_TYPEDEF_(0x80110434L);
//
// MessageId: COMADMIN_E_COREQCOMPINSTALLED
//
// MessageText:
//
// A component in the same DLL is already installed
//
static const int COMADMIN_E_COREQCOMPINSTALLED = _HRESULT_TYPEDEF_(0x80110435L);
//
// MessageId: COMADMIN_E_SERVICENOTINSTALLED
//
// MessageText:
//
// The service is not installed
//
static const int COMADMIN_E_SERVICENOTINSTALLED = _HRESULT_TYPEDEF_(0x80110436L);
//
// MessageId: COMADMIN_E_PROPERTYSAVEFAILED
//
// MessageText:
//
// One or more property settings are either invalid or in conflict with each other
//
static const int COMADMIN_E_PROPERTYSAVEFAILED = _HRESULT_TYPEDEF_(0x80110437L);
//
// MessageId: COMADMIN_E_OBJECTEXISTS
//
// MessageText:
//
// The object you are attempting to add or rename already exists
//
static const int COMADMIN_E_OBJECTEXISTS = _HRESULT_TYPEDEF_(0x80110438L);
//
// MessageId: COMADMIN_E_COMPONENTEXISTS
//
// MessageText:
//
// The component already exists
//
static const int COMADMIN_E_COMPONENTEXISTS = _HRESULT_TYPEDEF_(0x80110439L);
//
// MessageId: COMADMIN_E_REGFILE_CORRUPT
//
// MessageText:
//
// The registration file is corrupt
//
static const int COMADMIN_E_REGFILE_CORRUPT = _HRESULT_TYPEDEF_(0x8011043BL);
//
// MessageId: COMADMIN_E_PROPERTY_OVERFLOW
//
// MessageText:
//
// The property value is too large
//
static const int COMADMIN_E_PROPERTY_OVERFLOW = _HRESULT_TYPEDEF_(0x8011043CL);
//
// MessageId: COMADMIN_E_NOTINREGISTRY
//
// MessageText:
//
// Object was not found in registry
//
static const int COMADMIN_E_NOTINREGISTRY = _HRESULT_TYPEDEF_(0x8011043EL);
//
// MessageId: COMADMIN_E_OBJECTNOTPOOLABLE
//
// MessageText:
//
// This object is not poolable
//
static const int COMADMIN_E_OBJECTNOTPOOLABLE = _HRESULT_TYPEDEF_(0x8011043FL);
//
// MessageId: COMADMIN_E_APPLID_MATCHES_CLSID
//
// MessageText:
//
// A CLSID with the same GUID as the new application ID is already installed on this machine
//
static const int COMADMIN_E_APPLID_MATCHES_CLSID = _HRESULT_TYPEDEF_(0x80110446L);
//
// MessageId: COMADMIN_E_ROLE_DOES_NOT_EXIST
//
// MessageText:
//
// A role assigned to a component, interface, or method did not exist in the application
//
static const int COMADMIN_E_ROLE_DOES_NOT_EXIST = _HRESULT_TYPEDEF_(0x80110447L);
//
// MessageId: COMADMIN_E_START_APP_NEEDS_COMPONENTS
//
// MessageText:
//
// You must have components in an application in order to start the application
//
static const int COMADMIN_E_START_APP_NEEDS_COMPONENTS = _HRESULT_TYPEDEF_(0x80110448L);
//
// MessageId: COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM
//
// MessageText:
//
// This operation is not enabled on this platform
//
static const int COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM = _HRESULT_TYPEDEF_(0x80110449L);
//
// MessageId: COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY
//
// MessageText:
//
// Application Proxy is not exportable
//
static const int COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY = _HRESULT_TYPEDEF_(0x8011044AL);
//
// MessageId: COMADMIN_E_CAN_NOT_START_APP
//
// MessageText:
//
// Failed to start application because it is either a library application or an application proxy
//
static const int COMADMIN_E_CAN_NOT_START_APP = _HRESULT_TYPEDEF_(0x8011044BL);
//
// MessageId: COMADMIN_E_CAN_NOT_EXPORT_SYS_APP
//
// MessageText:
//
// System application is not exportable
//
static const int COMADMIN_E_CAN_NOT_EXPORT_SYS_APP = _HRESULT_TYPEDEF_(0x8011044CL);
//
// MessageId: COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT
//
// MessageText:
//
// Cannot subscribe to this component (the component may have been imported)
//
static const int COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT = _HRESULT_TYPEDEF_(0x8011044DL);
//
// MessageId: COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER
//
// MessageText:
//
// An event class cannot also be a subscriber component
//
static const int COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER = _HRESULT_TYPEDEF_(0x8011044EL);
//
// MessageId: COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE
//
// MessageText:
//
// Library applications and application proxies are incompatible
//
static const int COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE = _HRESULT_TYPEDEF_(0x8011044FL);
//
// MessageId: COMADMIN_E_BASE_PARTITION_ONLY
//
// MessageText:
//
// This function is valid for the base partition only
//
static const int COMADMIN_E_BASE_PARTITION_ONLY = _HRESULT_TYPEDEF_(0x80110450L);
//
// MessageId: COMADMIN_E_START_APP_DISABLED
//
// MessageText:
//
// You cannot start an application that has been disabled
//
static const int COMADMIN_E_START_APP_DISABLED = _HRESULT_TYPEDEF_(0x80110451L);
//
// MessageId: COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME
//
// MessageText:
//
// The specified partition name is already in use on this computer
//
static const int COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME = _HRESULT_TYPEDEF_(0x80110457L);
//
// MessageId: COMADMIN_E_CAT_INVALID_PARTITION_NAME
//
// MessageText:
//
// The specified partition name is invalid. Check that the name contains at least one visible character
//
static const int COMADMIN_E_CAT_INVALID_PARTITION_NAME = _HRESULT_TYPEDEF_(0x80110458L);
//
// MessageId: COMADMIN_E_CAT_PARTITION_IN_USE
//
// MessageText:
//
// The partition cannot be deleted because it is the default partition for one or more users
//
static const int COMADMIN_E_CAT_PARTITION_IN_USE = _HRESULT_TYPEDEF_(0x80110459L);
//
// MessageId: COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES
//
// MessageText:
//
// The partition cannot be exported, because one or more components in the partition have the same file name
//
static const int COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES = _HRESULT_TYPEDEF_(0x8011045AL);
//
// MessageId: COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED
//
// MessageText:
//
// Applications that contain one or more imported components cannot be installed into a non-base partition
//
static const int COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x8011045BL);
//
// MessageId: COMADMIN_E_AMBIGUOUS_APPLICATION_NAME
//
// MessageText:
//
// The application name is not unique and cannot be resolved to an application id
//
static const int COMADMIN_E_AMBIGUOUS_APPLICATION_NAME = _HRESULT_TYPEDEF_(0x8011045CL);
//
// MessageId: COMADMIN_E_AMBIGUOUS_PARTITION_NAME
//
// MessageText:
//
// The partition name is not unique and cannot be resolved to a partition id
//
static const int COMADMIN_E_AMBIGUOUS_PARTITION_NAME = _HRESULT_TYPEDEF_(0x8011045DL);
//
// MessageId: COMADMIN_E_REGDB_NOTINITIALIZED
//
// MessageText:
//
// The COM+ registry database has not been initialized
//
static const int COMADMIN_E_REGDB_NOTINITIALIZED = _HRESULT_TYPEDEF_(0x80110472L);
//
// MessageId: COMADMIN_E_REGDB_NOTOPEN
//
// MessageText:
//
// The COM+ registry database is not open
//
static const int COMADMIN_E_REGDB_NOTOPEN = _HRESULT_TYPEDEF_(0x80110473L);
//
// MessageId: COMADMIN_E_REGDB_SYSTEMERR
//
// MessageText:
//
// The COM+ registry database detected a system error
//
static const int COMADMIN_E_REGDB_SYSTEMERR = _HRESULT_TYPEDEF_(0x80110474L);
//
// MessageId: COMADMIN_E_REGDB_ALREADYRUNNING
//
// MessageText:
//
// The COM+ registry database is already running
//
static const int COMADMIN_E_REGDB_ALREADYRUNNING = _HRESULT_TYPEDEF_(0x80110475L);
//
// MessageId: COMADMIN_E_MIG_VERSIONNOTSUPPORTED
//
// MessageText:
//
// This version of the COM+ registry database cannot be migrated
//
static const int COMADMIN_E_MIG_VERSIONNOTSUPPORTED = _HRESULT_TYPEDEF_(0x80110480L);
//
// MessageId: COMADMIN_E_MIG_SCHEMANOTFOUND
//
// MessageText:
//
// The schema version to be migrated could not be found in the COM+ registry database
//
static const int COMADMIN_E_MIG_SCHEMANOTFOUND = _HRESULT_TYPEDEF_(0x80110481L);
//
// MessageId: COMADMIN_E_CAT_BITNESSMISMATCH
//
// MessageText:
//
// There was a type mismatch between binaries
//
static const int COMADMIN_E_CAT_BITNESSMISMATCH = _HRESULT_TYPEDEF_(0x80110482L);
//
// MessageId: COMADMIN_E_CAT_UNACCEPTABLEBITNESS
//
// MessageText:
//
// A binary of unknown or invalid type was provided
//
static const int COMADMIN_E_CAT_UNACCEPTABLEBITNESS = _HRESULT_TYPEDEF_(0x80110483L);
//
// MessageId: COMADMIN_E_CAT_WRONGAPPBITNESS
//
// MessageText:
//
// There was a type mismatch between a binary and an application
//
static const int COMADMIN_E_CAT_WRONGAPPBITNESS = _HRESULT_TYPEDEF_(0x80110484L);
//
// MessageId: COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED
//
// MessageText:
//
// The application cannot be paused or resumed
//
static const int COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80110485L);
//
// MessageId: COMADMIN_E_CAT_SERVERFAULT
//
// MessageText:
//
// The COM+ Catalog Server threw an exception during execution
//
static const int COMADMIN_E_CAT_SERVERFAULT = _HRESULT_TYPEDEF_(0x80110486L);
//
// COMPLUS Queued component errors
//
//
// MessageId: COMQC_E_APPLICATION_NOT_QUEUED
//
// MessageText:
//
// Only COM+ Applications marked "queued" can be invoked using the "queue" moniker
//
static const int COMQC_E_APPLICATION_NOT_QUEUED = _HRESULT_TYPEDEF_(0x80110600L);
//
// MessageId: COMQC_E_NO_QUEUEABLE_INTERFACES
//
// MessageText:
//
// At least one interface must be marked "queued" in order to create a queued component instance with the "queue" moniker
//
static const int COMQC_E_NO_QUEUEABLE_INTERFACES = _HRESULT_TYPEDEF_(0x80110601L);
//
// MessageId: COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// MSMQ is required for the requested operation and is not installed
//
static const int COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE = _HRESULT_TYPEDEF_(0x80110602L);
//
// MessageId: COMQC_E_NO_IPERSISTSTREAM
//
// MessageText:
//
// Unable to marshal an interface that does not support IPersistStream
//
static const int COMQC_E_NO_IPERSISTSTREAM = _HRESULT_TYPEDEF_(0x80110603L);
//
// MessageId: COMQC_E_BAD_MESSAGE
//
// MessageText:
//
// The message is improperly formatted or was damaged in transit
//
static const int COMQC_E_BAD_MESSAGE = _HRESULT_TYPEDEF_(0x80110604L);
//
// MessageId: COMQC_E_UNAUTHENTICATED
//
// MessageText:
//
// An unauthenticated message was received by an application that accepts only authenticated messages
//
static const int COMQC_E_UNAUTHENTICATED = _HRESULT_TYPEDEF_(0x80110605L);
//
// MessageId: COMQC_E_UNTRUSTED_ENQUEUER
//
// MessageText:
//
// The message was requeued or moved by a user not in the "QC Trusted User" role
//
static const int COMQC_E_UNTRUSTED_ENQUEUER = _HRESULT_TYPEDEF_(0x80110606L);
//
// The range 0x700-0x7ff is reserved for MSDTC errors.
//
//
// MessageId: MSDTC_E_DUPLICATE_RESOURCE
//
// MessageText:
//
// Cannot create a duplicate resource of type Distributed Transaction Coordinator
//
static const int MSDTC_E_DUPLICATE_RESOURCE = _HRESULT_TYPEDEF_(0x80110701L);
//
// More COMADMIN errors from 0x8**
//
//
// MessageId: COMADMIN_E_OBJECT_PARENT_MISSING
//
// MessageText:
//
// One of the objects being inserted or updated does not belong to a valid parent collection
//
static const int COMADMIN_E_OBJECT_PARENT_MISSING = _HRESULT_TYPEDEF_(0x80110808L);
//
// MessageId: COMADMIN_E_OBJECT_DOES_NOT_EXIST
//
// MessageText:
//
// One of the specified objects cannot be found
//
static const int COMADMIN_E_OBJECT_DOES_NOT_EXIST = _HRESULT_TYPEDEF_(0x80110809L);
//
// MessageId: COMADMIN_E_APP_NOT_RUNNING
//
// MessageText:
//
// The specified application is not currently running
//
static const int COMADMIN_E_APP_NOT_RUNNING = _HRESULT_TYPEDEF_(0x8011080AL);
//
// MessageId: COMADMIN_E_INVALID_PARTITION
//
// MessageText:
//
// The partition(s) specified are not valid.
//
static const int COMADMIN_E_INVALID_PARTITION = _HRESULT_TYPEDEF_(0x8011080BL);
//
// MessageId: COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE
//
// MessageText:
//
// COM+ applications that run as NT service may not be pooled or recycled
//
static const int COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE = _HRESULT_TYPEDEF_(0x8011080DL);
//
// MessageId: COMADMIN_E_USER_IN_SET
//
// MessageText:
//
// One or more users are already assigned to a local partition set.
//
static const int COMADMIN_E_USER_IN_SET = _HRESULT_TYPEDEF_(0x8011080EL);
//
// MessageId: COMADMIN_E_CANTRECYCLELIBRARYAPPS
//
// MessageText:
//
// Library applications may not be recycled.
//
static const int COMADMIN_E_CANTRECYCLELIBRARYAPPS = _HRESULT_TYPEDEF_(0x8011080FL);
//
// MessageId: COMADMIN_E_CANTRECYCLESERVICEAPPS
//
// MessageText:
//
// Applications running as NT services may not be recycled.
//
static const int COMADMIN_E_CANTRECYCLESERVICEAPPS = _HRESULT_TYPEDEF_(0x80110811L);
//
// MessageId: COMADMIN_E_PROCESSALREADYRECYCLED
//
// MessageText:
//
// The process has already been recycled.
//
static const int COMADMIN_E_PROCESSALREADYRECYCLED = _HRESULT_TYPEDEF_(0x80110812L);
//
// MessageId: COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED
//
// MessageText:
//
// A paused process may not be recycled.
//
static const int COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED = _HRESULT_TYPEDEF_(0x80110813L);
//
// MessageId: COMADMIN_E_CANTMAKEINPROCSERVICE
//
// MessageText:
//
// Library applications may not be NT services.
//
static const int COMADMIN_E_CANTMAKEINPROCSERVICE = _HRESULT_TYPEDEF_(0x80110814L);
//
// MessageId: COMADMIN_E_PROGIDINUSEBYCLSID
//
// MessageText:
//
// The ProgID provided to the copy operation is invalid. The ProgID is in use by another registered CLSID.
//
static const int COMADMIN_E_PROGIDINUSEBYCLSID = _HRESULT_TYPEDEF_(0x80110815L);
//
// MessageId: COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET
//
// MessageText:
//
// The partition specified as default is not a member of the partition set.
//
static const int COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET = _HRESULT_TYPEDEF_(0x80110816L);
//
// MessageId: COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED
//
// MessageText:
//
// A recycled process may not be paused.
//
static const int COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED = _HRESULT_TYPEDEF_(0x80110817L);
//
// MessageId: COMADMIN_E_PARTITION_ACCESSDENIED
//
// MessageText:
//
// Access to the specified partition is denied.
//
static const int COMADMIN_E_PARTITION_ACCESSDENIED = _HRESULT_TYPEDEF_(0x80110818L);
//
// MessageId: COMADMIN_E_PARTITION_MSI_ONLY
//
// MessageText:
//
// Only Application Files (*.MSI files) can be installed into partitions.
//
static const int COMADMIN_E_PARTITION_MSI_ONLY = _HRESULT_TYPEDEF_(0x80110819L);
//
// MessageId: COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT
//
// MessageText:
//
// Applications containing one or more legacy components may not be exported to 1.0 format.
//
static const int COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT = _HRESULT_TYPEDEF_(0x8011081AL);
//
// MessageId: COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS
//
// MessageText:
//
// Legacy components may not exist in non-base partitions.
//
static const int COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS = _HRESULT_TYPEDEF_(0x8011081BL);
//
// MessageId: COMADMIN_E_COMP_MOVE_SOURCE
//
// MessageText:
//
// A component cannot be moved (or copied) from the System Application, an application proxy or a non-changeable application
//
static const int COMADMIN_E_COMP_MOVE_SOURCE = _HRESULT_TYPEDEF_(0x8011081CL);
//
// MessageId: COMADMIN_E_COMP_MOVE_DEST
//
// MessageText:
//
// A component cannot be moved (or copied) to the System Application, an application proxy or a non-changeable application
//
static const int COMADMIN_E_COMP_MOVE_DEST = _HRESULT_TYPEDEF_(0x8011081DL);
//
// MessageId: COMADMIN_E_COMP_MOVE_PRIVATE
//
// MessageText:
//
// A private component cannot be moved (or copied) to a library application or to the base partition
//
static const int COMADMIN_E_COMP_MOVE_PRIVATE = _HRESULT_TYPEDEF_(0x8011081EL);
//
// MessageId: COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET
//
// MessageText:
//
// The Base Application Partition exists in all partition sets and cannot be removed.
//
static const int COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET = _HRESULT_TYPEDEF_(0x8011081FL);
//
// MessageId: COMADMIN_E_CANNOT_ALIAS_EVENTCLASS
//
// MessageText:
//
// Alas, Event Class components cannot be aliased.
//
static const int COMADMIN_E_CANNOT_ALIAS_EVENTCLASS = _HRESULT_TYPEDEF_(0x80110820L);
//
// MessageId: COMADMIN_E_PRIVATE_ACCESSDENIED
//
// MessageText:
//
// Access is denied because the component is private.
//
static const int COMADMIN_E_PRIVATE_ACCESSDENIED = _HRESULT_TYPEDEF_(0x80110821L);
//
// MessageId: COMADMIN_E_SAFERINVALID
//
// MessageText:
//
// The specified SAFER level is invalid.
//
static const int COMADMIN_E_SAFERINVALID = _HRESULT_TYPEDEF_(0x80110822L);
//
// MessageId: COMADMIN_E_REGISTRY_ACCESSDENIED
//
// MessageText:
//
// The specified user cannot write to the system registry
//
static const int COMADMIN_E_REGISTRY_ACCESSDENIED = _HRESULT_TYPEDEF_(0x80110823L);
//
// MessageId: COMADMIN_E_PARTITIONS_DISABLED
//
// MessageText:
//
// COM+ partitions are currently disabled.
//
static const int COMADMIN_E_PARTITIONS_DISABLED = _HRESULT_TYPEDEF_(0x80110824L);
// ***********************
// FACILITY_USERMODE_FILTER_MANAGER
// ***********************
//
// Translation macro for converting FilterManager error codes only from:
//     NTSTATUS  --> HRESULT
//
static const int FILTER_HRESULT_FROM_FLT_NTSTATUS(x) = (ASSERT((x & 0xfff0000) == 0x001c0000),(HRESULT) (((x) & 0x8000FFFF) | (FACILITY_USERMODE_FILTER_MANAGER << 16)));
//
// MessageId: ERROR_FLT_IO_COMPLETE
//
// MessageText:
//
// The IO was completed by a filter.
//
static const int ERROR_FLT_IO_COMPLETE = _HRESULT_TYPEDEF_(0x001F0001L);
//
// MessageId: ERROR_FLT_NO_HANDLER_DEFINED
//
// MessageText:
//
// A handler was not defined by the filter for this operation.
//
static const int ERROR_FLT_NO_HANDLER_DEFINED = _HRESULT_TYPEDEF_(0x801F0001L);
//
// MessageId: ERROR_FLT_CONTEXT_ALREADY_DEFINED
//
// MessageText:
//
// A context is already defined for this object.
//
static const int ERROR_FLT_CONTEXT_ALREADY_DEFINED = _HRESULT_TYPEDEF_(0x801F0002L);
//
// MessageId: ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST
//
// MessageText:
//
// Asynchronous requests are not valid for this operation.
//
static const int ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST = _HRESULT_TYPEDEF_(0x801F0003L);
//
// MessageId: ERROR_FLT_DISALLOW_FAST_IO
//
// MessageText:
//
// Disallow the Fast IO path for this operation.
//
static const int ERROR_FLT_DISALLOW_FAST_IO = _HRESULT_TYPEDEF_(0x801F0004L);
//
// MessageId: ERROR_FLT_INVALID_NAME_REQUEST
//
// MessageText:
//
// An invalid name request was made. The name requested cannot be retrieved at this time.
//
static const int ERROR_FLT_INVALID_NAME_REQUEST = _HRESULT_TYPEDEF_(0x801F0005L);
//
// MessageId: ERROR_FLT_NOT_SAFE_TO_POST_OPERATION
//
// MessageText:
//
// Posting this operation to a worker thread for further processing is not safe at this time because it could lead to a system deadlock.
//
static const int ERROR_FLT_NOT_SAFE_TO_POST_OPERATION = _HRESULT_TYPEDEF_(0x801F0006L);
//
// MessageId: ERROR_FLT_NOT_INITIALIZED
//
// MessageText:
//
// The Filter Manager was not initialized when a filter tried to register. Make sure that the Filter Manager is getting loaded as a driver.
//
static const int ERROR_FLT_NOT_INITIALIZED = _HRESULT_TYPEDEF_(0x801F0007L);
//
// MessageId: ERROR_FLT_FILTER_NOT_READY
//
// MessageText:
//
// The filter is not ready for attachment to volumes because it has not finished initializing (FltStartFiltering has not been called).
//
static const int ERROR_FLT_FILTER_NOT_READY = _HRESULT_TYPEDEF_(0x801F0008L);
//
// MessageId: ERROR_FLT_POST_OPERATION_CLEANUP
//
// MessageText:
//
// The filter must cleanup any operation specific context at this time because it is being removed from the system before the operation is completed by the lower drivers.
//
static const int ERROR_FLT_POST_OPERATION_CLEANUP = _HRESULT_TYPEDEF_(0x801F0009L);
//
// MessageId: ERROR_FLT_INTERNAL_ERROR
//
// MessageText:
//
// The Filter Manager had an internal error from which it cannot recover, therefore the operation has been failed. This is usually the result of a filter returning an invalid value from a pre-operation callback.
//
static const int ERROR_FLT_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0x801F000AL);
//
// MessageId: ERROR_FLT_DELETING_OBJECT
//
// MessageText:
//
// The object specified for this action is in the process of being deleted, therefore the action requested cannot be completed at this time.
//
static const int ERROR_FLT_DELETING_OBJECT = _HRESULT_TYPEDEF_(0x801F000BL);
//
// MessageId: ERROR_FLT_MUST_BE_NONPAGED_POOL
//
// MessageText:
//
// Non-paged pool must be used for this type of context.
//
static const int ERROR_FLT_MUST_BE_NONPAGED_POOL = _HRESULT_TYPEDEF_(0x801F000CL);
//
// MessageId: ERROR_FLT_DUPLICATE_ENTRY
//
// MessageText:
//
// A duplicate handler definition has been provided for an operation.
//
static const int ERROR_FLT_DUPLICATE_ENTRY = _HRESULT_TYPEDEF_(0x801F000DL);
//
// MessageId: ERROR_FLT_CBDQ_DISABLED
//
// MessageText:
//
// The callback data queue has been disabled.
//
static const int ERROR_FLT_CBDQ_DISABLED = _HRESULT_TYPEDEF_(0x801F000EL);
//
// MessageId: ERROR_FLT_DO_NOT_ATTACH
//
// MessageText:
//
// Do not attach the filter to the volume at this time.
//
static const int ERROR_FLT_DO_NOT_ATTACH = _HRESULT_TYPEDEF_(0x801F000FL);
//
// MessageId: ERROR_FLT_DO_NOT_DETACH
//
// MessageText:
//
// Do not detach the filter from the volume at this time.
//
static const int ERROR_FLT_DO_NOT_DETACH = _HRESULT_TYPEDEF_(0x801F0010L);
//
// MessageId: ERROR_FLT_INSTANCE_ALTITUDE_COLLISION
//
// MessageText:
//
// An instance already exists at this altitude on the volume specified.
//
static const int ERROR_FLT_INSTANCE_ALTITUDE_COLLISION = _HRESULT_TYPEDEF_(0x801F0011L);
//
// MessageId: ERROR_FLT_INSTANCE_NAME_COLLISION
//
// MessageText:
//
// An instance already exists with this name on the volume specified.
//
static const int ERROR_FLT_INSTANCE_NAME_COLLISION = _HRESULT_TYPEDEF_(0x801F0012L);
//
// MessageId: ERROR_FLT_FILTER_NOT_FOUND
//
// MessageText:
//
// The system could not find the filter specified.
//
static const int ERROR_FLT_FILTER_NOT_FOUND = _HRESULT_TYPEDEF_(0x801F0013L);
//
// MessageId: ERROR_FLT_VOLUME_NOT_FOUND
//
// MessageText:
//
// The system could not find the volume specified.
//
static const int ERROR_FLT_VOLUME_NOT_FOUND = _HRESULT_TYPEDEF_(0x801F0014L);
//
// MessageId: ERROR_FLT_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The system could not find the instance specified.
//
static const int ERROR_FLT_INSTANCE_NOT_FOUND = _HRESULT_TYPEDEF_(0x801F0015L);
//
// MessageId: ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND
//
// MessageText:
//
// No registered context allocation definition was found for the given request.
//
static const int ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND = _HRESULT_TYPEDEF_(0x801F0016L);
//
// MessageId: ERROR_FLT_INVALID_CONTEXT_REGISTRATION
//
// MessageText:
//
// An invalid parameter was specified during context registration.
//
static const int ERROR_FLT_INVALID_CONTEXT_REGISTRATION = _HRESULT_TYPEDEF_(0x801F0017L);
//
// MessageId: ERROR_FLT_NAME_CACHE_MISS
//
// MessageText:
//
// The name requested was not found in Filter Manager's name cache and could not be retrieved from the file system.
//
static const int ERROR_FLT_NAME_CACHE_MISS = _HRESULT_TYPEDEF_(0x801F0018L);
//
// MessageId: ERROR_FLT_NO_DEVICE_OBJECT
//
// MessageText:
//
// The requested device object does not exist for the given volume.
//
static const int ERROR_FLT_NO_DEVICE_OBJECT = _HRESULT_TYPEDEF_(0x801F0019L);
//
// MessageId: ERROR_FLT_VOLUME_ALREADY_MOUNTED
//
// MessageText:
//
// The specified volume is already mounted.
//
static const int ERROR_FLT_VOLUME_ALREADY_MOUNTED = _HRESULT_TYPEDEF_(0x801F001AL);
//
// MessageId: ERROR_FLT_ALREADY_ENLISTED
//
// MessageText:
//
// The specified Transaction Context is already enlisted in a transaction
//
static const int ERROR_FLT_ALREADY_ENLISTED = _HRESULT_TYPEDEF_(0x801F001BL);
//
// MessageId: ERROR_FLT_CONTEXT_ALREADY_LINKED
//
// MessageText:
//
// The specifiec context is already attached to another object
//
static const int ERROR_FLT_CONTEXT_ALREADY_LINKED = _HRESULT_TYPEDEF_(0x801F001CL);
//
// MessageId: ERROR_FLT_NO_WAITER_FOR_REPLY
//
// MessageText:
//
// No waiter is present for the filter's reply to this message.
//
static const int ERROR_FLT_NO_WAITER_FOR_REPLY = _HRESULT_TYPEDEF_(0x801F0020L);
//
// ===============================
// Facility Graphics Error Messages
// ===============================
//
//
// The following are the subranges within the Graphics facility
//
// 0x0000 - 0x0fff     Display Driver Loader driver & Video Port errors (displdr.sys, videoprt.sys)
// 0x1000 - 0x1fff     Monitor Class Function driver errors             (monitor.sys)
// 0x2000 - 0x2fff     Windows Graphics Kernel Subsystem errors         (dxgkrnl.sys)
// 0x3000 - 0x3fff               Desktop Window Manager errors
//   0x2000 - 0x20ff      Common errors
//   0x2100 - 0x21ff      Video Memory Manager (VidMM) subsystem errors
//   0x2200 - 0x22ff      Video GPU Scheduler (VidSch) subsystem errors
//   0x2300 - 0x23ff      Video Display Mode Management (VidDMM) subsystem errors
//
// Display Driver Loader driver & Video Port errors {0x0000..0x0fff}
//
//
// MessageId: ERROR_HUNG_DISPLAY_DRIVER_THREAD
//
// MessageText:
//
// {Display Driver Stopped Responding}
// The %hs display driver has stopped working normally. Save your work and reboot the system to restore full display functionality.
// The next time you reboot the machine a dialog will be displayed giving you a chance to report this failure to Microsoft.
//
static const int ERROR_HUNG_DISPLAY_DRIVER_THREAD = _HRESULT_TYPEDEF_(0x80260001L);
//
// Desktop Window Manager errors {0x3000..0x3fff}
//
//
// MessageId: DWM_E_COMPOSITIONDISABLED
//
// MessageText:
//
// {Desktop composition is disabled}
// The operation could not be completed because desktop composition is disabled.
//
static const int DWM_E_COMPOSITIONDISABLED = _HRESULT_TYPEDEF_(0x80263001L);
//
// MessageId: DWM_E_REMOTING_NOT_SUPPORTED
//
// MessageText:
//
// {Some desktop composition APIs are not supported while remoting}
// The operation is not supported while running in a remote session.
//
static const int DWM_E_REMOTING_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80263002L);
//
// MessageId: DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE
//
// MessageText:
//
// {No DWM redirection surface is available}
// The DWM was unable to provide a redireciton surface to complete the DirectX present.
//
static const int DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE = _HRESULT_TYPEDEF_(0x80263003L);
//
// MessageId: DWM_E_NOT_QUEUING_PRESENTS
//
// MessageText:
//
// {DWM is not queuing presents for the specified window}
// The window specified is not currently using queued presents.
//
static const int DWM_E_NOT_QUEUING_PRESENTS = _HRESULT_TYPEDEF_(0x80263004L);
//
// MessageId: DWM_E_ADAPTER_NOT_FOUND
//
// MessageText:
//
// {The adapter specified by the LUID is not found}
// DWM can not find the adapter specified by the LUID.
//
static const int DWM_E_ADAPTER_NOT_FOUND = _HRESULT_TYPEDEF_(0x80263005L);
//
// MessageId: DWM_S_GDI_REDIRECTION_SURFACE
//
// MessageText:
//
// {GDI redirection surface was returned}
// GDI redirection surface of the top level window was returned.
//
static const int DWM_S_GDI_REDIRECTION_SURFACE = _HRESULT_TYPEDEF_(0x00263005L);
//
// Monitor class function driver errors {0x1000..0x1fff}
//
//
// MessageId: ERROR_MONITOR_NO_DESCRIPTOR
//
// MessageText:
//
// Monitor descriptor could not be obtained.
//
static const int ERROR_MONITOR_NO_DESCRIPTOR = _HRESULT_TYPEDEF_(0x00261001L);
//
// MessageId: ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT
//
// MessageText:
//
// Format of the obtained monitor descriptor is not supported by this release.
//
static const int ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = _HRESULT_TYPEDEF_(0x00261002L);
//
// MessageId: ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM
//
// MessageText:
//
// Checksum of the obtained monitor descriptor is invalid.
//
static const int ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = _HRESULT_TYPEDEF_(0xC0261003L);
//
// MessageId: ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid standard timing block.
//
static const int ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK = _HRESULT_TYPEDEF_(0xC0261004L);
//
// MessageId: ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED
//
// MessageText:
//
// WMI data block registration failed for one of the MSMonitorClass WMI subclasses.
//
static const int ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = _HRESULT_TYPEDEF_(0xC0261005L);
//
// MessageId: ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's detailed serial number.
//
static const int ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = _HRESULT_TYPEDEF_(0xC0261006L);
//
// MessageId: ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's user friendly name.
//
static const int ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = _HRESULT_TYPEDEF_(0xC0261007L);
//
// MessageId: ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA
//
// MessageText:
//
// There is no monitor descriptor data at the specified (offset, size) region.
//
static const int ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA = _HRESULT_TYPEDEF_(0xC0261008L);
//
// MessageId: ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid detailed timing block.
//
static const int ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK = _HRESULT_TYPEDEF_(0xC0261009L);
//
// MessageId: ERROR_MONITOR_INVALID_MANUFACTURE_DATE
//
// MessageText:
//
// Monitor descriptor contains invalid manufacture date.
//
static const int ERROR_MONITOR_INVALID_MANUFACTURE_DATE = _HRESULT_TYPEDEF_(0xC026100AL);
//
// Windows Graphics Kernel Subsystem errors {0x2000..0x2fff}
//
// TODO: Add DXG Win32 errors here
//
// Common errors {0x2000..0x20ff}
//
//
// MessageId: ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER
//
// MessageText:
//
// Exclusive mode ownership is needed to create unmanaged primary allocation.
//
static const int ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = _HRESULT_TYPEDEF_(0xC0262000L);
//
// MessageId: ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER
//
// MessageText:
//
// The driver needs more DMA buffer space in order to complete the requested operation.
//
static const int ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER = _HRESULT_TYPEDEF_(0xC0262001L);
//
// MessageId: ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER
//
// MessageText:
//
// Specified display adapter handle is invalid.
//
static const int ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER = _HRESULT_TYPEDEF_(0xC0262002L);
//
// MessageId: ERROR_GRAPHICS_ADAPTER_WAS_RESET
//
// MessageText:
//
// Specified display adapter and all of its state has been reset.
//
static const int ERROR_GRAPHICS_ADAPTER_WAS_RESET = _HRESULT_TYPEDEF_(0xC0262003L);
//
// MessageId: ERROR_GRAPHICS_INVALID_DRIVER_MODEL
//
// MessageText:
//
// The driver stack doesn't match the expected driver model.
//
static const int ERROR_GRAPHICS_INVALID_DRIVER_MODEL = _HRESULT_TYPEDEF_(0xC0262004L);
//
// MessageId: ERROR_GRAPHICS_PRESENT_MODE_CHANGED
//
// MessageText:
//
// Present happened but ended up into the changed desktop mode
//
static const int ERROR_GRAPHICS_PRESENT_MODE_CHANGED = _HRESULT_TYPEDEF_(0xC0262005L);
//
// MessageId: ERROR_GRAPHICS_PRESENT_OCCLUDED
//
// MessageText:
//
// Nothing to present due to desktop occlusion
//
static const int ERROR_GRAPHICS_PRESENT_OCCLUDED = _HRESULT_TYPEDEF_(0xC0262006L);
//
// MessageId: ERROR_GRAPHICS_PRESENT_DENIED
//
// MessageText:
//
// Not able to present due to denial of desktop access
//
static const int ERROR_GRAPHICS_PRESENT_DENIED = _HRESULT_TYPEDEF_(0xC0262007L);
//
// MessageId: ERROR_GRAPHICS_CANNOTCOLORCONVERT
//
// MessageText:
//
// Not able to present with color convertion
//
static const int ERROR_GRAPHICS_CANNOTCOLORCONVERT = _HRESULT_TYPEDEF_(0xC0262008L);
//
// MessageId: ERROR_GRAPHICS_DRIVER_MISMATCH
//
// MessageText:
//
// The kernel driver detected a version mismatch between it and the user mode driver.
//
static const int ERROR_GRAPHICS_DRIVER_MISMATCH = _HRESULT_TYPEDEF_(0xC0262009L);
//
// MessageId: ERROR_GRAPHICS_PARTIAL_DATA_POPULATED
//
// MessageText:
//
// Specified buffer is not big enough to contain entire requested dataset. Partial data populated up to the size of the buffer. Caller needs to provide buffer of size as specified in the partially populated buffer's content (interface specific).
//
static const int ERROR_GRAPHICS_PARTIAL_DATA_POPULATED = _HRESULT_TYPEDEF_(0x4026200AL);
//
// MessageId: ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED
//
// MessageText:
//
// Present redirection is disabled (desktop windowing management subsystem is off).
//
static const int ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED = _HRESULT_TYPEDEF_(0xC026200BL);
//
// MessageId: ERROR_GRAPHICS_PRESENT_UNOCCLUDED
//
// MessageText:
//
// Previous exclusive VidPn source owner has released its ownership
//
static const int ERROR_GRAPHICS_PRESENT_UNOCCLUDED = _HRESULT_TYPEDEF_(0xC026200CL);
//
// Video Memory Manager (VidMM) subsystem errors {0x2100..0x21ff}
//
//
// MessageId: ERROR_GRAPHICS_NO_VIDEO_MEMORY
//
// MessageText:
//
// Not enough video memory available to complete the operation.
//
static const int ERROR_GRAPHICS_NO_VIDEO_MEMORY = _HRESULT_TYPEDEF_(0xC0262100L);
//
// MessageId: ERROR_GRAPHICS_CANT_LOCK_MEMORY
//
// MessageText:
//
// Couldn't probe and lock the underlying memory of an allocation.
//
static const int ERROR_GRAPHICS_CANT_LOCK_MEMORY = _HRESULT_TYPEDEF_(0xC0262101L);
//
// MessageId: ERROR_GRAPHICS_ALLOCATION_BUSY
//
// MessageText:
//
// The allocation is currently busy.
//
static const int ERROR_GRAPHICS_ALLOCATION_BUSY = _HRESULT_TYPEDEF_(0xC0262102L);
//
// MessageId: ERROR_GRAPHICS_TOO_MANY_REFERENCES
//
// MessageText:
//
// An object being referenced has reach the maximum reference count already and can't be reference further.
//
static const int ERROR_GRAPHICS_TOO_MANY_REFERENCES = _HRESULT_TYPEDEF_(0xC0262103L);
//
// MessageId: ERROR_GRAPHICS_TRY_AGAIN_LATER
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again later.
//
static const int ERROR_GRAPHICS_TRY_AGAIN_LATER = _HRESULT_TYPEDEF_(0xC0262104L);
//
// MessageId: ERROR_GRAPHICS_TRY_AGAIN_NOW
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again immediately.
//
static const int ERROR_GRAPHICS_TRY_AGAIN_NOW = _HRESULT_TYPEDEF_(0xC0262105L);
//
// MessageId: ERROR_GRAPHICS_ALLOCATION_INVALID
//
// MessageText:
//
// The allocation is invalid.
//
static const int ERROR_GRAPHICS_ALLOCATION_INVALID = _HRESULT_TYPEDEF_(0xC0262106L);
//
// MessageId: ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE
//
// MessageText:
//
// No more unswizzling aperture are currently available.
//
static const int ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = _HRESULT_TYPEDEF_(0xC0262107L);
//
// MessageId: ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED
//
// MessageText:
//
// The current allocation can't be unswizzled by an aperture.
//
static const int ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = _HRESULT_TYPEDEF_(0xC0262108L);
//
// MessageId: ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION
//
// MessageText:
//
// The request failed because a pinned allocation can't be evicted.
//
static const int ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = _HRESULT_TYPEDEF_(0xC0262109L);
//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE
//
// MessageText:
//
// The allocation can't be used from it's current segment location for the specified operation.
//
static const int ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE = _HRESULT_TYPEDEF_(0xC0262110L);
//
// MessageId: ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION
//
// MessageText:
//
// A locked allocation can't be used in the current command buffer.
//
static const int ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = _HRESULT_TYPEDEF_(0xC0262111L);
//
// MessageId: ERROR_GRAPHICS_ALLOCATION_CLOSED
//
// MessageText:
//
// The allocation being referenced has been closed permanently.
//
static const int ERROR_GRAPHICS_ALLOCATION_CLOSED = _HRESULT_TYPEDEF_(0xC0262112L);
//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE
//
// MessageText:
//
// An invalid allocation instance is being referenced.
//
static const int ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE = _HRESULT_TYPEDEF_(0xC0262113L);
//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE
//
// MessageText:
//
// An invalid allocation handle is being referenced.
//
static const int ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE = _HRESULT_TYPEDEF_(0xC0262114L);
//
// MessageId: ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE
//
// MessageText:
//
// The allocation being referenced doesn't belong to the current device.
//
static const int ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE = _HRESULT_TYPEDEF_(0xC0262115L);
//
// MessageId: ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST
//
// MessageText:
//
// The specified allocation lost its content.
//
static const int ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST = _HRESULT_TYPEDEF_(0xC0262116L);
//
// Video GPU Scheduler (VidSch) subsystem errors {0x2200..0x22ff}
//
//
// MessageId: ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE
//
// MessageText:
//
// GPU exception is detected on the given device. The device is not able to be scheduled.
//
static const int ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = _HRESULT_TYPEDEF_(0xC0262200L);
//
// Video Present Network Management (VidPNMgr) subsystem errors {0x2300..0x23ff}
//
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY = _HRESULT_TYPEDEF_(0xC0262300L);
//
// MessageId: ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by this model of the display adapter.
//
static const int ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262301L);
//
// MessageId: ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by the display adapter at this time, due to current allocation of its resources.
//
static const int ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262302L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN
//
// MessageText:
//
// Specified VidPN handle is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDPN = _HRESULT_TYPEDEF_(0xC0262303L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE
//
// MessageText:
//
// Specified video present source is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = _HRESULT_TYPEDEF_(0xC0262304L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET
//
// MessageText:
//
// Specified video present target is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = _HRESULT_TYPEDEF_(0xC0262305L);
//
// MessageId: ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN modality is not supported (e.g. at least two of the pinned modes are not cofunctional).
//
static const int ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262306L);
//
// MessageId: ERROR_GRAPHICS_MODE_NOT_PINNED
//
// MessageText:
//
// No mode is pinned on the specified VidPN source/target.
//
static const int ERROR_GRAPHICS_MODE_NOT_PINNED = _HRESULT_TYPEDEF_(0x00262307L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET
//
// MessageText:
//
// Specified VidPN source mode set is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = _HRESULT_TYPEDEF_(0xC0262308L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET
//
// MessageText:
//
// Specified VidPN target mode set is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET = _HRESULT_TYPEDEF_(0xC0262309L);
//
// MessageId: ERROR_GRAPHICS_INVALID_FREQUENCY
//
// MessageText:
//
// Specified video signal frequency is invalid.
//
static const int ERROR_GRAPHICS_INVALID_FREQUENCY = _HRESULT_TYPEDEF_(0xC026230AL);
//
// MessageId: ERROR_GRAPHICS_INVALID_ACTIVE_REGION
//
// MessageText:
//
// Specified video signal active region is invalid.
//
static const int ERROR_GRAPHICS_INVALID_ACTIVE_REGION = _HRESULT_TYPEDEF_(0xC026230BL);
//
// MessageId: ERROR_GRAPHICS_INVALID_TOTAL_REGION
//
// MessageText:
//
// Specified video signal total region is invalid.
//
static const int ERROR_GRAPHICS_INVALID_TOTAL_REGION = _HRESULT_TYPEDEF_(0xC026230CL);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE
//
// MessageText:
//
// Specified video present source mode is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = _HRESULT_TYPEDEF_(0xC0262310L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE
//
// MessageText:
//
// Specified video present target mode is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = _HRESULT_TYPEDEF_(0xC0262311L);
//
// MessageId: ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET
//
// MessageText:
//
// Pinned mode must remain in the set on VidPN's cofunctional modality enumeration.
//
static const int ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = _HRESULT_TYPEDEF_(0xC0262312L);
//
// MessageId: ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY
//
// MessageText:
//
// Specified video present path is already in VidPN's topology.
//
static const int ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = _HRESULT_TYPEDEF_(0xC0262313L);
//
// MessageId: ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET
//
// MessageText:
//
// Specified mode is already in the mode set.
//
static const int ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET = _HRESULT_TYPEDEF_(0xC0262314L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET
//
// MessageText:
//
// Specified video present source set is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = _HRESULT_TYPEDEF_(0xC0262315L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET
//
// MessageText:
//
// Specified video present target set is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = _HRESULT_TYPEDEF_(0xC0262316L);
//
// MessageId: ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present source is already in the video present source set.
//
static const int ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET = _HRESULT_TYPEDEF_(0xC0262317L);
//
// MessageId: ERROR_GRAPHICS_TARGET_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present target is already in the video present target set.
//
static const int ERROR_GRAPHICS_TARGET_ALREADY_IN_SET = _HRESULT_TYPEDEF_(0xC0262318L);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH
//
// MessageText:
//
// Specified VidPN present path is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = _HRESULT_TYPEDEF_(0xC0262319L);
//
// MessageId: ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY
//
// MessageText:
//
// Miniport has no recommendation for augmentation of the specified VidPN's topology.
//
static const int ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = _HRESULT_TYPEDEF_(0xC026231AL);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET
//
// MessageText:
//
// Specified monitor frequency range set is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = _HRESULT_TYPEDEF_(0xC026231BL);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE
//
// MessageText:
//
// Specified monitor frequency range is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = _HRESULT_TYPEDEF_(0xC026231CL);
//
// MessageId: ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET
//
// MessageText:
//
// Specified frequency range is not in the specified monitor frequency range set.
//
static const int ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = _HRESULT_TYPEDEF_(0xC026231DL);
//
// MessageId: ERROR_GRAPHICS_NO_PREFERRED_MODE
//
// MessageText:
//
// Specified mode set does not specify preference for one of its modes.
//
static const int ERROR_GRAPHICS_NO_PREFERRED_MODE = _HRESULT_TYPEDEF_(0x0026231EL);
//
// MessageId: ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET
//
// MessageText:
//
// Specified frequency range is already in the specified monitor frequency range set.
//
static const int ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = _HRESULT_TYPEDEF_(0xC026231FL);
//
// MessageId: ERROR_GRAPHICS_STALE_MODESET
//
// MessageText:
//
// Specified mode set is stale. Please reacquire the new mode set.
//
static const int ERROR_GRAPHICS_STALE_MODESET = _HRESULT_TYPEDEF_(0xC0262320L);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET
//
// MessageText:
//
// Specified monitor source mode set is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = _HRESULT_TYPEDEF_(0xC0262321L);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE
//
// MessageText:
//
// Specified monitor source mode is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = _HRESULT_TYPEDEF_(0xC0262322L);
//
// MessageId: ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN
//
// MessageText:
//
// Miniport does not have any recommendation regarding the request to provide a functional VidPN given the current display adapter configuration.
//
static const int ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = _HRESULT_TYPEDEF_(0xC0262323L);
//
// MessageId: ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified mode is already used by another mode in the set.
//
static const int ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = _HRESULT_TYPEDEF_(0xC0262324L);
//
// MessageId: ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION
//
// MessageText:
//
// System failed to determine a mode that is supported by both the display adapter and the monitor connected to it.
//
static const int ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = _HRESULT_TYPEDEF_(0xC0262325L);
//
// MessageId: ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES
//
// MessageText:
//
// Number of video present targets must be greater than or equal to the number of video present sources.
//
static const int ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = _HRESULT_TYPEDEF_(0xC0262326L);
//
// MessageId: ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified present path is not in VidPN's topology.
//
static const int ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY = _HRESULT_TYPEDEF_(0xC0262327L);
//
// MessageId: ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE
//
// MessageText:
//
// Display adapter must have at least one video present source.
//
static const int ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = _HRESULT_TYPEDEF_(0xC0262328L);
//
// MessageId: ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET
//
// MessageText:
//
// Display adapter must have at least one video present target.
//
static const int ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = _HRESULT_TYPEDEF_(0xC0262329L);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET
//
// MessageText:
//
// Specified monitor descriptor set is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET = _HRESULT_TYPEDEF_(0xC026232AL);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR
//
// MessageText:
//
// Specified monitor descriptor is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR = _HRESULT_TYPEDEF_(0xC026232BL);
//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET
//
// MessageText:
//
// Specified descriptor is not in the specified monitor descriptor set.
//
static const int ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = _HRESULT_TYPEDEF_(0xC026232CL);
//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET
//
// MessageText:
//
// Specified descriptor is already in the specified monitor descriptor set.
//
static const int ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = _HRESULT_TYPEDEF_(0xC026232DL);
//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified monitor descriptor is already used by another descriptor in the set.
//
static const int ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = _HRESULT_TYPEDEF_(0xC026232EL);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE
//
// MessageText:
//
// Specified video present target subset type is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = _HRESULT_TYPEDEF_(0xC026232FL);
//
// MessageId: ERROR_GRAPHICS_RESOURCES_NOT_RELATED
//
// MessageText:
//
// Two or more of the specified resources are not related to each other, as defined by the interface semantics.
//
static const int ERROR_GRAPHICS_RESOURCES_NOT_RELATED = _HRESULT_TYPEDEF_(0xC0262330L);
//
// MessageId: ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present source is already used by another source in the set.
//
static const int ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = _HRESULT_TYPEDEF_(0xC0262331L);
//
// MessageId: ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present target is already used by another target in the set.
//
static const int ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = _HRESULT_TYPEDEF_(0xC0262332L);
//
// MessageId: ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET
//
// MessageText:
//
// Specified VidPN source cannot be used because there is no available VidPN target to connect it to.
//
static const int ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = _HRESULT_TYPEDEF_(0xC0262333L);
//
// MessageId: ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER
//
// MessageText:
//
// Newly arrived monitor could not be associated with a display adapter.
//
static const int ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = _HRESULT_TYPEDEF_(0xC0262334L);
//
// MessageId: ERROR_GRAPHICS_NO_VIDPNMGR
//
// MessageText:
//
// Display adapter in question does not have an associated VidPN manager.
//
static const int ERROR_GRAPHICS_NO_VIDPNMGR = _HRESULT_TYPEDEF_(0xC0262335L);
//
// MessageId: ERROR_GRAPHICS_NO_ACTIVE_VIDPN
//
// MessageText:
//
// VidPN manager of the display adapter in question does not have an active VidPN.
//
static const int ERROR_GRAPHICS_NO_ACTIVE_VIDPN = _HRESULT_TYPEDEF_(0xC0262336L);
//
// MessageId: ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is stale. Please reacquire the new topology.
//
static const int ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY = _HRESULT_TYPEDEF_(0xC0262337L);
//
// MessageId: ERROR_GRAPHICS_MONITOR_NOT_CONNECTED
//
// MessageText:
//
// There is no monitor connected on the specified video present target.
//
static const int ERROR_GRAPHICS_MONITOR_NOT_CONNECTED = _HRESULT_TYPEDEF_(0xC0262338L);
//
// MessageId: ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified source is not part of the specified VidPN's topology.
//
static const int ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = _HRESULT_TYPEDEF_(0xC0262339L);
//
// MessageId: ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE
//
// MessageText:
//
// Specified primary surface size is invalid.
//
static const int ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = _HRESULT_TYPEDEF_(0xC026233AL);
//
// MessageId: ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE
//
// MessageText:
//
// Specified visible region size is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE = _HRESULT_TYPEDEF_(0xC026233BL);
//
// MessageId: ERROR_GRAPHICS_INVALID_STRIDE
//
// MessageText:
//
// Specified stride is invalid.
//
static const int ERROR_GRAPHICS_INVALID_STRIDE = _HRESULT_TYPEDEF_(0xC026233CL);
//
// MessageId: ERROR_GRAPHICS_INVALID_PIXELFORMAT
//
// MessageText:
//
// Specified pixel format is invalid.
//
static const int ERROR_GRAPHICS_INVALID_PIXELFORMAT = _HRESULT_TYPEDEF_(0xC026233DL);
//
// MessageId: ERROR_GRAPHICS_INVALID_COLORBASIS
//
// MessageText:
//
// Specified color basis is invalid.
//
static const int ERROR_GRAPHICS_INVALID_COLORBASIS = _HRESULT_TYPEDEF_(0xC026233EL);
//
// MessageId: ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE
//
// MessageText:
//
// Specified pixel value access mode is invalid.
//
static const int ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = _HRESULT_TYPEDEF_(0xC026233FL);
//
// MessageId: ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified target is not part of the specified VidPN's topology.
//
static const int ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = _HRESULT_TYPEDEF_(0xC0262340L);
//
// MessageId: ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT
//
// MessageText:
//
// Failed to acquire display mode management interface.
//
static const int ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = _HRESULT_TYPEDEF_(0xC0262341L);
//
// MessageId: ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE
//
// MessageText:
//
// Specified VidPN source is already owned by a DMM client and cannot be used until that client releases it.
//
static const int ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE = _HRESULT_TYPEDEF_(0xC0262342L);
//
// MessageId: ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN
//
// MessageText:
//
// Specified VidPN is active and cannot be accessed.
//
static const int ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = _HRESULT_TYPEDEF_(0xC0262343L);
//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL
//
// MessageText:
//
// Specified VidPN present path importance ordinal is invalid.
//
static const int ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = _HRESULT_TYPEDEF_(0xC0262344L);
//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION
//
// MessageText:
//
// Specified VidPN present path content geometry transformation is invalid.
//
static const int ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = _HRESULT_TYPEDEF_(0xC0262345L);
//
// MessageId: ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED
//
// MessageText:
//
// Specified content geometry transformation is not supported on the respective VidPN present path.
//
static const int ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262346L);
//
// MessageId: ERROR_GRAPHICS_INVALID_GAMMA_RAMP
//
// MessageText:
//
// Specified gamma ramp is invalid.
//
static const int ERROR_GRAPHICS_INVALID_GAMMA_RAMP = _HRESULT_TYPEDEF_(0xC0262347L);
//
// MessageId: ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED
//
// MessageText:
//
// Specified gamma ramp is not supported on the respective VidPN present path.
//
static const int ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262348L);
//
// MessageId: ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED
//
// MessageText:
//
// Multi-sampling is not supported on the respective VidPN present path.
//
static const int ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262349L);
//
// MessageId: ERROR_GRAPHICS_MODE_NOT_IN_MODESET
//
// MessageText:
//
// Specified mode is not in the specified mode set.
//
static const int ERROR_GRAPHICS_MODE_NOT_IN_MODESET = _HRESULT_TYPEDEF_(0xC026234AL);
//
// MessageId: ERROR_GRAPHICS_DATASET_IS_EMPTY
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) is empty.
//
static const int ERROR_GRAPHICS_DATASET_IS_EMPTY = _HRESULT_TYPEDEF_(0x0026234BL);
//
// MessageId: ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) does not contain any more elements.
//
static const int ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET = _HRESULT_TYPEDEF_(0x0026234CL);
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON
//
// MessageText:
//
// Specified VidPN topology recommendation reason is invalid.
//
static const int ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = _HRESULT_TYPEDEF_(0xC026234DL);
//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE
//
// MessageText:
//
// Specified VidPN present path content type is invalid.
//
static const int ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE = _HRESULT_TYPEDEF_(0xC026234EL);
//
// MessageId: ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE
//
// MessageText:
//
// Specified VidPN present path copy protection type is invalid.
//
static const int ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE = _HRESULT_TYPEDEF_(0xC026234FL);
//
// MessageId: ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS
//
// MessageText:
//
// No more than one unassigned mode set can exist at any given time for a given VidPN source/target.
//
static const int ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = _HRESULT_TYPEDEF_(0xC0262350L);
//
// MessageId: ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED
//
// MessageText:
//
// Specified content transformation is not pinned on the specified VidPN present path.
//
static const int ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED = _HRESULT_TYPEDEF_(0x00262351L);
//
// MessageId: ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING
//
// MessageText:
//
// Specified scanline ordering type is invalid.
//
static const int ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING = _HRESULT_TYPEDEF_(0xC0262352L);
//
// MessageId: ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED
//
// MessageText:
//
// Topology changes are not allowed for the specified VidPN.
//
static const int ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = _HRESULT_TYPEDEF_(0xC0262353L);
//
// MessageId: ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS
//
// MessageText:
//
// All available importance ordinals are already used in specified topology.
//
static const int ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = _HRESULT_TYPEDEF_(0xC0262354L);
//
// MessageId: ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT
//
// MessageText:
//
// Specified primary surface has a different private format attribute than the current primary surface
//
static const int ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = _HRESULT_TYPEDEF_(0xC0262355L);
//
// MessageId: ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM
//
// MessageText:
//
// Specified mode pruning algorithm is invalid
//
static const int ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = _HRESULT_TYPEDEF_(0xC0262356L);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN
//
// MessageText:
//
// Specified monitor capability origin is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = _HRESULT_TYPEDEF_(0xC0262357L);
//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT
//
// MessageText:
//
// Specified monitor frequency range constraint is invalid.
//
static const int ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = _HRESULT_TYPEDEF_(0xC0262358L);
//
// MessageId: ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED
//
// MessageText:
//
// Maximum supported number of present paths has been reached.
//
static const int ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED = _HRESULT_TYPEDEF_(0xC0262359L);
//
// MessageId: ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION
//
// MessageText:
//
// Miniport requested that augmentation be cancelled for the specified source of the specified VidPN's topology.
//
static const int ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = _HRESULT_TYPEDEF_(0xC026235AL);
//
// MessageId: ERROR_GRAPHICS_INVALID_CLIENT_TYPE
//
// MessageText:
//
// Specified client type was not recognized.
//
static const int ERROR_GRAPHICS_INVALID_CLIENT_TYPE = _HRESULT_TYPEDEF_(0xC026235BL);
//
// MessageId: ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET
//
// MessageText:
//
// Client VidPN is not set on this adapter (e.g. no user mode initiated mode changes took place on this adapter yet).
//
static const int ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET = _HRESULT_TYPEDEF_(0xC026235CL);
//
// Port specific status codes {0x2400..0x24ff}
//
//
// MessageId: ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED
//
// MessageText:
//
// Specified display adapter child device already has an external device connected to it.
//
static const int ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = _HRESULT_TYPEDEF_(0xC0262400L);
//
// MessageId: ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED
//
// MessageText:
//
// Specified display adapter child device does not support descriptor exposure.
//
static const int ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262401L);
//
// MessageId: ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS
//
// MessageText:
//
// Child device presence was not reliably detected.
//
static const int ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS = _HRESULT_TYPEDEF_(0x4026242FL);
//
// MessageId: ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER
//
// MessageText:
//
// The display adapter is not linked to any other adapters.
//
static const int ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER = _HRESULT_TYPEDEF_(0xC0262430L);
//
// MessageId: ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED
//
// MessageText:
//
// Lead adapter in a linked configuration was not enumerated yet.
//
static const int ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED = _HRESULT_TYPEDEF_(0xC0262431L);
//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED
//
// MessageText:
//
// Some chain adapters in a linked configuration were not enumerated yet.
//
static const int ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = _HRESULT_TYPEDEF_(0xC0262432L);
//
// MessageId: ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY
//
// MessageText:
//
// The chain of linked adapters is not ready to start because of an unknown failure.
//
static const int ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY = _HRESULT_TYPEDEF_(0xC0262433L);
//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED
//
// MessageText:
//
// An attempt was made to start a lead link display adapter when the chain links were not started yet.
//
static const int ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED = _HRESULT_TYPEDEF_(0xC0262434L);
//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON
//
// MessageText:
//
// An attempt was made to power up a lead link display adapter when the chain links were powered down.
//
static const int ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = _HRESULT_TYPEDEF_(0xC0262435L);
//
// MessageId: ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE
//
// MessageText:
//
// The adapter link was found to be in an inconsistent state. Not all adapters are in an expected PNP/Power state.
//
static const int ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = _HRESULT_TYPEDEF_(0xC0262436L);
//
// MessageId: ERROR_GRAPHICS_LEADLINK_START_DEFERRED
//
// MessageText:
//
// Starting the leadlink adapter has been deferred temporarily.
//
static const int ERROR_GRAPHICS_LEADLINK_START_DEFERRED = _HRESULT_TYPEDEF_(0x40262437L);
//
// MessageId: ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER
//
// MessageText:
//
// The driver trying to start is not the same as the driver for the POSTed display adapter.
//
static const int ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER = _HRESULT_TYPEDEF_(0xC0262438L);
//
// MessageId: ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY
//
// MessageText:
//
// The display adapter is being polled for children too frequently at the same polling level.
//
static const int ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY = _HRESULT_TYPEDEF_(0x40262439L);
//
// MessageId: ERROR_GRAPHICS_START_DEFERRED
//
// MessageText:
//
// Starting the adapter has been deferred temporarily.
//
static const int ERROR_GRAPHICS_START_DEFERRED = _HRESULT_TYPEDEF_(0x4026243AL);
//
// MessageId: ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED
//
// MessageText:
//
// An operation is being attempted that requires the display adapter to be in a quiescent state.
//
static const int ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = _HRESULT_TYPEDEF_(0xC026243BL);
//
// OPM, UAB and PVP specific error codes {0x2500..0x257f}
//
//
// MessageId: ERROR_GRAPHICS_OPM_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support OPM.
//
static const int ERROR_GRAPHICS_OPM_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262500L);
//
// MessageId: ERROR_GRAPHICS_COPP_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support COPP.
//
static const int ERROR_GRAPHICS_COPP_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262501L);
//
// MessageId: ERROR_GRAPHICS_UAB_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support UAB.
//
static const int ERROR_GRAPHICS_UAB_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262502L);
//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS
//
// MessageText:
//
// The specified encrypted parameters are invalid.
//
static const int ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = _HRESULT_TYPEDEF_(0xC0262503L);
//
// MessageId: ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST
//
// MessageText:
//
// The GDI display device passed to this function does not have any active video outputs.
//
static const int ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST = _HRESULT_TYPEDEF_(0xC0262505L);
//
// MessageId: ERROR_GRAPHICS_OPM_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused this operation to fail.
//
static const int ERROR_GRAPHICS_OPM_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0xC026250BL);
//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_HANDLE
//
// MessageText:
//
// The function failed because the caller passed in an invalid OPM user mode handle.
//
static const int ERROR_GRAPHICS_OPM_INVALID_HANDLE = _HRESULT_TYPEDEF_(0xC026250CL);
//
// MessageId: ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH
//
// MessageText:
//
// A certificate could not be returned because the certificate buffer passed to the function was too small.
//
static const int ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = _HRESULT_TYPEDEF_(0xC026250EL);
//
// MessageId: ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED
//
// MessageText:
//
// A video output could not be created because the frame buffer is in spanning mode.
//
static const int ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED = _HRESULT_TYPEDEF_(0xC026250FL);
//
// MessageId: ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED
//
// MessageText:
//
// A video output could not be created because the frame buffer is in theater mode.
//
static const int ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED = _HRESULT_TYPEDEF_(0xC0262510L);
//
// MessageId: ERROR_GRAPHICS_PVP_HFS_FAILED
//
// MessageText:
//
// The function failed because the display adapter's Hardware Functionality Scan failed to validate the graphics hardware.
//
static const int ERROR_GRAPHICS_PVP_HFS_FAILED = _HRESULT_TYPEDEF_(0xC0262511L);
//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_SRM
//
// MessageText:
//
// The HDCP System Renewability Message passed to this function did not comply with section 5 of the HDCP 1.1 specification.
//
static const int ERROR_GRAPHICS_OPM_INVALID_SRM = _HRESULT_TYPEDEF_(0xC0262512L);
//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP
//
// MessageText:
//
// The video output cannot enable the High-bandwidth Digital Content Protection (HDCP) System because it does not support HDCP.
//
static const int ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = _HRESULT_TYPEDEF_(0xC0262513L);
//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP
//
// MessageText:
//
// The video output cannot enable Analogue Copy Protection (ACP) because it does not support ACP.
//
static const int ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = _HRESULT_TYPEDEF_(0xC0262514L);
//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA
//
// MessageText:
//
// The video output cannot enable the Content Generation Management System Analogue (CGMS-A) protection technology because it does not support CGMS-A.
//
static const int ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = _HRESULT_TYPEDEF_(0xC0262515L);
//
// MessageId: ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET
//
// MessageText:
//
// The IOPMVideoOutput::GetInformation method cannot return the version of the SRM being used because the application never successfully passed an SRM to the video output.
//
static const int ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = _HRESULT_TYPEDEF_(0xC0262516L);
//
// MessageId: ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH
//
// MessageText:
//
// The IOPMVideoOutput::Configure method cannot enable the specified output protection technology because the output's screen resolution is too high.
//
static const int ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = _HRESULT_TYPEDEF_(0xC0262517L);
//
// MessageId: ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE
//
// MessageText:
//
// The IOPMVideoOutput::Configure method cannot enable HDCP because the display adapter's HDCP hardware is already being used by other physical outputs.
//
static const int ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = _HRESULT_TYPEDEF_(0xC0262518L);
//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed this OPM video output because the operating system's state changed. This error typically occurs because the monitor PDO associated with this video output was removed, the monitor PDO associated with this video output was stopped, the video output's session became a non-console session or the video output's desktop became an inactive desktop.
//
static const int ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS = _HRESULT_TYPEDEF_(0xC026251AL);
//
// MessageId: ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The method failed because the session is changing its type. No IOPMVideoOutput methods can be called when a session is changing its type. There are currently three types of sessions: console, disconnected and remote.
//
static const int ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS = _HRESULT_TYPEDEF_(0xC026251BL);
//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS
//
// MessageText:
//
// Either the IOPMVideoOutput::COPPCompatibleGetInformation, IOPMVideoOutput::GetInformation, or IOPMVideoOutput::Configure method failed. This error is returned when the caller tries to use a COPP specific command while the video output has OPM semantics only.
//
static const int ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = _HRESULT_TYPEDEF_(0xC026251CL);
//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST
//
// MessageText:
//
// The IOPMVideoOutput::GetInformation and IOPMVideoOutput::COPPCompatibleGetInformation methods return this error if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//
static const int ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = _HRESULT_TYPEDEF_(0xC026251DL);
//
// MessageId: ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// The method failed because an unexpected error occurred inside of a display driver.
//
static const int ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0xC026251EL);
//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS
//
// MessageText:
//
// Either the IOPMVideoOutput::COPPCompatibleGetInformation, IOPMVideoOutput::GetInformation, or IOPMVideoOutput::Configure method failed. This error is returned when the caller tries to use an OPM specific command while the video output has COPP semantics only.
//
static const int ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = _HRESULT_TYPEDEF_(0xC026251FL);
//
// MessageId: ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED
//
// MessageText:
//
// The IOPMVideoOutput::COPPCompatibleGetInformation or IOPMVideoOutput::Configure method failed because the display driver does not support the OPM_GET_ACP_AND_CGMSA_SIGNALING and OPM_SET_ACP_AND_CGMSA_SIGNALING GUIDs.
//
static const int ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262520L);
//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST
//
// MessageText:
//
// The IOPMVideoOutput::Configure function returns this error code if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//
static const int ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = _HRESULT_TYPEDEF_(0xC0262521L);
//
// Monitor Configuration API error codes {0x2580..0x25DF}
//
//
// MessageId: ERROR_GRAPHICS_I2C_NOT_SUPPORTED
//
// MessageText:
//
// The monitor connected to the specified video output does not have an I2C bus.
//
static const int ERROR_GRAPHICS_I2C_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262580L);
//
// MessageId: ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST
//
// MessageText:
//
// No device on the I2C bus has the specified address.
//
static const int ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = _HRESULT_TYPEDEF_(0xC0262581L);
//
// MessageId: ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA
//
// MessageText:
//
// An error occurred while transmitting data to the device on the I2C bus.
//
static const int ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = _HRESULT_TYPEDEF_(0xC0262582L);
//
// MessageId: ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA
//
// MessageText:
//
// An error occurred while receiving data from the device on the I2C bus.
//
static const int ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA = _HRESULT_TYPEDEF_(0xC0262583L);
//
// MessageId: ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED
//
// MessageText:
//
// The monitor does not support the specified VCP code.
//
static const int ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC0262584L);
//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_DATA
//
// MessageText:
//
// The data received from the monitor is invalid.
//
static const int ERROR_GRAPHICS_DDCCI_INVALID_DATA = _HRESULT_TYPEDEF_(0xC0262585L);
//
// MessageId: ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE
//
// MessageText:
//
// The function failed because a monitor returned an invalid Timing Status byte when the operating system used the DDC/CI Get Timing Report & Timing Message command to get a timing report from a monitor.
//
static const int ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = _HRESULT_TYPEDEF_(0xC0262586L);
//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING
//
// MessageText:
//
// The monitor returned a DDC/CI capabilities string which did not comply with the ACCESS.bus 3.0, DDC/CI 1.1, or MCCS 2 Revision 1 specification.
//
static const int ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING = _HRESULT_TYPEDEF_(0xC0262587L);
//
// MessageId: ERROR_GRAPHICS_MCA_INTERNAL_ERROR
//
// MessageText:
//
// An internal Monitor Configuration API error occured.
//
static const int ERROR_GRAPHICS_MCA_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0xC0262588L);
//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND
//
// MessageText:
//
// An operation failed because a DDC/CI message had an invalid value in its command field.
//
static const int ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = _HRESULT_TYPEDEF_(0xC0262589L);
//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH
//
// MessageText:
//
// An error occurred because the field length of a DDC/CI message contained an invalid value.
//
static const int ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = _HRESULT_TYPEDEF_(0xC026258AL);
//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM
//
// MessageText:
//
// An error occurred because the checksum field in a DDC/CI message did not match the message's computed checksum value. This error implies that the data was corrupted while it was being transmitted from a monitor to a computer.
//
static const int ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = _HRESULT_TYPEDEF_(0xC026258BL);
//
// MessageId: ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE
//
// MessageText:
//
// This function failed because an invalid monitor handle was passed to it.
//
static const int ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = _HRESULT_TYPEDEF_(0xC026258CL);
//
// MessageId: ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed the monitor which corresponds to this handle because the operating system's state changed. This error typically occurs because the monitor PDO associated with this handle was removed, the monitor PDO associated with this handle was stopped, or a display mode change occurred. A display mode change occurs when windows sends a WM_DISPLAYCHANGE windows message to applications.
//
static const int ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS = _HRESULT_TYPEDEF_(0xC026258DL);
//
// MessageId: ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE
//
// MessageText:
//
// A continuous VCP code's current value is greater than its maximum value. This error code indicates that a monitor returned an invalid value.
//
static const int ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE = _HRESULT_TYPEDEF_(0xC02625D8L);
//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION
//
// MessageText:
//
// The monitor's VCP Version (0xDF) VCP code returned an invalid version value.
//
static const int ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION = _HRESULT_TYPEDEF_(0xC02625D9L);
//
// MessageId: ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION
//
// MessageText:
//
// The monitor does not comply with the MCCS specification it claims to support.
//
static const int ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = _HRESULT_TYPEDEF_(0xC02625DAL);
//
// MessageId: ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH
//
// MessageText:
//
// The MCCS version in a monitor's mccs_ver capability does not match the MCCS version the monitor reports when the VCP Version (0xDF) VCP code is used.
//
static const int ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH = _HRESULT_TYPEDEF_(0xC02625DBL);
//
// MessageId: ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION
//
// MessageText:
//
// The Monitor Configuration API only works with monitors which support the MCCS 1.0 specification, MCCS 2.0 specification or the MCCS 2.0 Revision 1 specification.
//
static const int ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION = _HRESULT_TYPEDEF_(0xC02625DCL);
//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED
//
// MessageText:
//
// The monitor returned an invalid monitor technology type. CRT, Plasma and LCD (TFT) are examples of monitor technology types. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
static const int ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = _HRESULT_TYPEDEF_(0xC02625DEL);
//
// MessageId: ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE
//
// MessageText:
//
// SetMonitorColorTemperature()'s caller passed a color temperature to it which the current monitor did not support. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
static const int ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE = _HRESULT_TYPEDEF_(0xC02625DFL);
//
// OPM, UAB, PVP and DDC/CI shared error codes {0x25E0..0x25ff}
//
//
// MessageId: ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED
//
// MessageText:
//
// This function can only be used if a program is running in the local console session. It cannot be used if the program is running on a remote desktop session or on a terminal server session.
//
static const int ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = _HRESULT_TYPEDEF_(0xC02625E0L);
//
// MessageId: ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME
//
// MessageText:
//
// This function cannot find an actual GDI display device which corresponds to the specified GDI display device name.
//
static const int ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = _HRESULT_TYPEDEF_(0xC02625E1L);
//
// MessageId: ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP
//
// MessageText:
//
// The function failed because the specified GDI display device was not attached to the Windows desktop.
//
static const int ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = _HRESULT_TYPEDEF_(0xC02625E2L);
//
// MessageId: ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED
//
// MessageText:
//
// This function does not support GDI mirroring display devices because GDI mirroring display devices do not have any physical monitors associated with them.
//
static const int ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0xC02625E3L);
//
// MessageId: ERROR_GRAPHICS_INVALID_POINTER
//
// MessageText:
//
// The function failed because an invalid pointer parameter was passed to it. A pointer parameter is invalid if it is NULL, points to an invalid address, points to a kernel mode address, or is not correctly aligned.
//
static const int ERROR_GRAPHICS_INVALID_POINTER = _HRESULT_TYPEDEF_(0xC02625E4L);
//
// MessageId: ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE
//
// MessageText:
//
// The function failed because the specified GDI device did not have any monitors associated with it.
//
static const int ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = _HRESULT_TYPEDEF_(0xC02625E5L);
//
// MessageId: ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL
//
// MessageText:
//
// An array passed to the function cannot hold all of the data that the function must copy into the array.
//
static const int ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = _HRESULT_TYPEDEF_(0xC02625E6L);
//
// MessageId: ERROR_GRAPHICS_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused an operation to fail.
//
static const int ERROR_GRAPHICS_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0xC02625E7L);
//
// MessageId: ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The function failed because the current session is changing its type. This function cannot be called when the current session is changing its type. There are currently three types of sessions: console, disconnected and remote.
//
static const int ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = _HRESULT_TYPEDEF_(0xC02605E8L);
//
// ===============================
// TPM Services and TPM Software Error Messages
// ===============================
//
// The TPM services and TPM software facilities are used by the various
// TPM software components. There are two facilities because the services
// errors are within the TCG-defined error space and the software errors
// are not.
//
// The following are the subranges within the TPM Services facility.
// The TPM hardware errors are defined in the document
// TPM Main Specification 1.2 Part 2 TPM Structures.
// The TBS errors are slotted into the TCG error namespace at the TBS layer.
//
// 0x0000 - 0x08ff     TPM hardware errors
// 0x4000 - 0x40ff     TPM Base Services errors (tbssvc.dll)
//
// The following are the subranges within the TPM Software facility. The TBS
// has two classes of errors - those that can be returned (the public errors,
// defined in the TBS spec), which are in the TPM services facility,  and
// those that are internal or implementation specific, which are here in the
// TPM software facility.
//
// 0x0000 - 0x00ff     TPM device driver errors (tpm.sys)
// 0x0100 - 0x01ff     TPM API errors (tpmapi.lib)
// 0x0200 - 0x02ff     TBS internal errors (tbssvc.dll)
// 0x0300 - 0x03ff     TPM Physical Presence errors
//
//
// TPM hardware error codes {0x0000..0x08ff}
// This space is further subdivided into hardware errors, vendor-specific
// errors, and non-fatal errors.
//
//
// TPM hardware errors {0x0000..0x003ff}
//
//
// MessageId: TPM_E_ERROR_MASK
//
// MessageText:
//
// This is an error mask to convert TPM hardware errors to win errors.
//
static const int TPM_E_ERROR_MASK = _HRESULT_TYPEDEF_(0x80280000L);
//
// MessageId: TPM_E_AUTHFAIL
//
// MessageText:
//
// Authentication failed.
//
static const int TPM_E_AUTHFAIL = _HRESULT_TYPEDEF_(0x80280001L);
//
// MessageId: TPM_E_BADINDEX
//
// MessageText:
//
// The index to a PCR, DIR or other register is incorrect.
//
static const int TPM_E_BADINDEX = _HRESULT_TYPEDEF_(0x80280002L);
//
// MessageId: TPM_E_BAD_PARAMETER
//
// MessageText:
//
// One or more parameter is bad.
//
static const int TPM_E_BAD_PARAMETER = _HRESULT_TYPEDEF_(0x80280003L);
//
// MessageId: TPM_E_AUDITFAILURE
//
// MessageText:
//
// An operation completed successfully but the auditing of that operation failed.
//
static const int TPM_E_AUDITFAILURE = _HRESULT_TYPEDEF_(0x80280004L);
//
// MessageId: TPM_E_CLEAR_DISABLED
//
// MessageText:
//
// The clear disable flag is set and all clear operations now require physical access.
//
static const int TPM_E_CLEAR_DISABLED = _HRESULT_TYPEDEF_(0x80280005L);
//
// MessageId: TPM_E_DEACTIVATED
//
// MessageText:
//
// Activate the Trusted Platform Module (TPM).
//
static const int TPM_E_DEACTIVATED = _HRESULT_TYPEDEF_(0x80280006L);
//
// MessageId: TPM_E_DISABLED
//
// MessageText:
//
// Enable the Trusted Platform Module (TPM).
//
static const int TPM_E_DISABLED = _HRESULT_TYPEDEF_(0x80280007L);
//
// MessageId: TPM_E_DISABLED_CMD
//
// MessageText:
//
// The target command has been disabled.
//
static const int TPM_E_DISABLED_CMD = _HRESULT_TYPEDEF_(0x80280008L);
//
// MessageId: TPM_E_FAIL
//
// MessageText:
//
// The operation failed.
//
static const int TPM_E_FAIL = _HRESULT_TYPEDEF_(0x80280009L);
//
// MessageId: TPM_E_BAD_ORDINAL
//
// MessageText:
//
// The ordinal was unknown or inconsistent.
//
static const int TPM_E_BAD_ORDINAL = _HRESULT_TYPEDEF_(0x8028000AL);
//
// MessageId: TPM_E_INSTALL_DISABLED
//
// MessageText:
//
// The ability to install an owner is disabled.
//
static const int TPM_E_INSTALL_DISABLED = _HRESULT_TYPEDEF_(0x8028000BL);
//
// MessageId: TPM_E_INVALID_KEYHANDLE
//
// MessageText:
//
// The key handle cannot be interpreted.
//
static const int TPM_E_INVALID_KEYHANDLE = _HRESULT_TYPEDEF_(0x8028000CL);
//
// MessageId: TPM_E_KEYNOTFOUND
//
// MessageText:
//
// The key handle points to an invalid key.
//
static const int TPM_E_KEYNOTFOUND = _HRESULT_TYPEDEF_(0x8028000DL);
//
// MessageId: TPM_E_INAPPROPRIATE_ENC
//
// MessageText:
//
// Unacceptable encryption scheme.
//
static const int TPM_E_INAPPROPRIATE_ENC = _HRESULT_TYPEDEF_(0x8028000EL);
//
// MessageId: TPM_E_MIGRATEFAIL
//
// MessageText:
//
// Migration authorization failed.
//
static const int TPM_E_MIGRATEFAIL = _HRESULT_TYPEDEF_(0x8028000FL);
//
// MessageId: TPM_E_INVALID_PCR_INFO
//
// MessageText:
//
// PCR information could not be interpreted.
//
static const int TPM_E_INVALID_PCR_INFO = _HRESULT_TYPEDEF_(0x80280010L);
//
// MessageId: TPM_E_NOSPACE
//
// MessageText:
//
// No room to load key.
//
static const int TPM_E_NOSPACE = _HRESULT_TYPEDEF_(0x80280011L);
//
// MessageId: TPM_E_NOSRK
//
// MessageText:
//
// There is no Storage Root Key (SRK) set.
//
static const int TPM_E_NOSRK = _HRESULT_TYPEDEF_(0x80280012L);
//
// MessageId: TPM_E_NOTSEALED_BLOB
//
// MessageText:
//
// An encrypted blob is invalid or was not created by this TPM.
//
static const int TPM_E_NOTSEALED_BLOB = _HRESULT_TYPEDEF_(0x80280013L);
//
// MessageId: TPM_E_OWNER_SET
//
// MessageText:
//
// The Trusted Platform Module (TPM) already has an owner.
//
static const int TPM_E_OWNER_SET = _HRESULT_TYPEDEF_(0x80280014L);
//
// MessageId: TPM_E_RESOURCES
//
// MessageText:
//
// The TPM has insufficient internal resources to perform the requested action.
//
static const int TPM_E_RESOURCES = _HRESULT_TYPEDEF_(0x80280015L);
//
// MessageId: TPM_E_SHORTRANDOM
//
// MessageText:
//
// A random string was too short.
//
static const int TPM_E_SHORTRANDOM = _HRESULT_TYPEDEF_(0x80280016L);
//
// MessageId: TPM_E_SIZE
//
// MessageText:
//
// The TPM does not have the space to perform the operation.
//
static const int TPM_E_SIZE = _HRESULT_TYPEDEF_(0x80280017L);
//
// MessageId: TPM_E_WRONGPCRVAL
//
// MessageText:
//
// The named PCR value does not match the current PCR value.
//
static const int TPM_E_WRONGPCRVAL = _HRESULT_TYPEDEF_(0x80280018L);
//
// MessageId: TPM_E_BAD_PARAM_SIZE
//
// MessageText:
//
// The paramSize argument to the command has the incorrect value .
//
static const int TPM_E_BAD_PARAM_SIZE = _HRESULT_TYPEDEF_(0x80280019L);
//
// MessageId: TPM_E_SHA_THREAD
//
// MessageText:
//
// There is no existing SHA-1 thread.
//
static const int TPM_E_SHA_THREAD = _HRESULT_TYPEDEF_(0x8028001AL);
//
// MessageId: TPM_E_SHA_ERROR
//
// MessageText:
//
// The calculation is unable to proceed because the existing SHA-1 thread has already encountered an error.
//
static const int TPM_E_SHA_ERROR = _HRESULT_TYPEDEF_(0x8028001BL);
//
// MessageId: TPM_E_FAILEDSELFTEST
//
// MessageText:
//
// The TPM hardware device reported a failure during its internal self test. Try restarting the computer to resolve the problem. If the problem continues, you might need to replace your TPM hardware or motherboard.
//
static const int TPM_E_FAILEDSELFTEST = _HRESULT_TYPEDEF_(0x8028001CL);
//
// MessageId: TPM_E_AUTH2FAIL
//
// MessageText:
//
// The authorization for the second key in a 2 key function failed authorization.
//
static const int TPM_E_AUTH2FAIL = _HRESULT_TYPEDEF_(0x8028001DL);
//
// MessageId: TPM_E_BADTAG
//
// MessageText:
//
// The tag value sent to for a command is invalid.
//
static const int TPM_E_BADTAG = _HRESULT_TYPEDEF_(0x8028001EL);
//
// MessageId: TPM_E_IOERROR
//
// MessageText:
//
// An IO error occurred transmitting information to the TPM.
//
static const int TPM_E_IOERROR = _HRESULT_TYPEDEF_(0x8028001FL);
//
// MessageId: TPM_E_ENCRYPT_ERROR
//
// MessageText:
//
// The encryption process had a problem.
//
static const int TPM_E_ENCRYPT_ERROR = _HRESULT_TYPEDEF_(0x80280020L);
//
// MessageId: TPM_E_DECRYPT_ERROR
//
// MessageText:
//
// The decryption process did not complete.
//
static const int TPM_E_DECRYPT_ERROR = _HRESULT_TYPEDEF_(0x80280021L);
//
// MessageId: TPM_E_INVALID_AUTHHANDLE
//
// MessageText:
//
// An invalid handle was used.
//
static const int TPM_E_INVALID_AUTHHANDLE = _HRESULT_TYPEDEF_(0x80280022L);
//
// MessageId: TPM_E_NO_ENDORSEMENT
//
// MessageText:
//
// The TPM does not have an Endorsement Key (EK) installed.
//
static const int TPM_E_NO_ENDORSEMENT = _HRESULT_TYPEDEF_(0x80280023L);
//
// MessageId: TPM_E_INVALID_KEYUSAGE
//
// MessageText:
//
// The usage of a key is not allowed.
//
static const int TPM_E_INVALID_KEYUSAGE = _HRESULT_TYPEDEF_(0x80280024L);
//
// MessageId: TPM_E_WRONG_ENTITYTYPE
//
// MessageText:
//
// The submitted entity type is not allowed.
//
static const int TPM_E_WRONG_ENTITYTYPE = _HRESULT_TYPEDEF_(0x80280025L);
//
// MessageId: TPM_E_INVALID_POSTINIT
//
// MessageText:
//
// The command was received in the wrong sequence relative to TPM_Init and a subsequent TPM_Startup.
//
static const int TPM_E_INVALID_POSTINIT = _HRESULT_TYPEDEF_(0x80280026L);
//
// MessageId: TPM_E_INAPPROPRIATE_SIG
//
// MessageText:
//
// Signed data cannot include additional DER information.
//
static const int TPM_E_INAPPROPRIATE_SIG = _HRESULT_TYPEDEF_(0x80280027L);
//
// MessageId: TPM_E_BAD_KEY_PROPERTY
//
// MessageText:
//
// The key properties in TPM_KEY_PARMs are not supported by this TPM.
//
static const int TPM_E_BAD_KEY_PROPERTY = _HRESULT_TYPEDEF_(0x80280028L);
//
// MessageId: TPM_E_BAD_MIGRATION
//
// MessageText:
//
// The migration properties of this key are incorrect.
//
static const int TPM_E_BAD_MIGRATION = _HRESULT_TYPEDEF_(0x80280029L);
//
// MessageId: TPM_E_BAD_SCHEME
//
// MessageText:
//
// The signature or encryption scheme for this key is incorrect or not permitted in this situation.
//
static const int TPM_E_BAD_SCHEME = _HRESULT_TYPEDEF_(0x8028002AL);
//
// MessageId: TPM_E_BAD_DATASIZE
//
// MessageText:
//
// The size of the data (or blob) parameter is bad or inconsistent with the referenced key.
//
static const int TPM_E_BAD_DATASIZE = _HRESULT_TYPEDEF_(0x8028002BL);
//
// MessageId: TPM_E_BAD_MODE
//
// MessageText:
//
// A mode parameter is bad, such as capArea or subCapArea for TPM_GetCapability, phsicalPresence parameter for TPM_PhysicalPresence, or migrationType for TPM_CreateMigrationBlob.
//
static const int TPM_E_BAD_MODE = _HRESULT_TYPEDEF_(0x8028002CL);
//
// MessageId: TPM_E_BAD_PRESENCE
//
// MessageText:
//
// Either the physicalPresence or physicalPresenceLock bits have the wrong value.
//
static const int TPM_E_BAD_PRESENCE = _HRESULT_TYPEDEF_(0x8028002DL);
//
// MessageId: TPM_E_BAD_VERSION
//
// MessageText:
//
// The TPM cannot perform this version of the capability.
//
static const int TPM_E_BAD_VERSION = _HRESULT_TYPEDEF_(0x8028002EL);
//
// MessageId: TPM_E_NO_WRAP_TRANSPORT
//
// MessageText:
//
// The TPM does not allow for wrapped transport sessions.
//
static const int TPM_E_NO_WRAP_TRANSPORT = _HRESULT_TYPEDEF_(0x8028002FL);
//
// MessageId: TPM_E_AUDITFAIL_UNSUCCESSFUL
//
// MessageText:
//
// TPM audit construction failed and the underlying command was returning a failure code also.
//
static const int TPM_E_AUDITFAIL_UNSUCCESSFUL = _HRESULT_TYPEDEF_(0x80280030L);
//
// MessageId: TPM_E_AUDITFAIL_SUCCESSFUL
//
// MessageText:
//
// TPM audit construction failed and the underlying command was returning success.
//
static const int TPM_E_AUDITFAIL_SUCCESSFUL = _HRESULT_TYPEDEF_(0x80280031L);
//
// MessageId: TPM_E_NOTRESETABLE
//
// MessageText:
//
// Attempt to reset a PCR register that does not have the resettable attribute.
//
static const int TPM_E_NOTRESETABLE = _HRESULT_TYPEDEF_(0x80280032L);
//
// MessageId: TPM_E_NOTLOCAL
//
// MessageText:
//
// Attempt to reset a PCR register that requires locality and locality modifier not part of command transport.
//
static const int TPM_E_NOTLOCAL = _HRESULT_TYPEDEF_(0x80280033L);
//
// MessageId: TPM_E_BAD_TYPE
//
// MessageText:
//
// Make identity blob not properly typed.
//
static const int TPM_E_BAD_TYPE = _HRESULT_TYPEDEF_(0x80280034L);
//
// MessageId: TPM_E_INVALID_RESOURCE
//
// MessageText:
//
// When saving context identified resource type does not match actual resource.
//
static const int TPM_E_INVALID_RESOURCE = _HRESULT_TYPEDEF_(0x80280035L);
//
// MessageId: TPM_E_NOTFIPS
//
// MessageText:
//
// The TPM is attempting to execute a command only available when in FIPS mode.
//
static const int TPM_E_NOTFIPS = _HRESULT_TYPEDEF_(0x80280036L);
//
// MessageId: TPM_E_INVALID_FAMILY
//
// MessageText:
//
// The command is attempting to use an invalid family ID.
//
static const int TPM_E_INVALID_FAMILY = _HRESULT_TYPEDEF_(0x80280037L);
//
// MessageId: TPM_E_NO_NV_PERMISSION
//
// MessageText:
//
// The permission to manipulate the NV storage is not available.
//
static const int TPM_E_NO_NV_PERMISSION = _HRESULT_TYPEDEF_(0x80280038L);
//
// MessageId: TPM_E_REQUIRES_SIGN
//
// MessageText:
//
// The operation requires a signed command.
//
static const int TPM_E_REQUIRES_SIGN = _HRESULT_TYPEDEF_(0x80280039L);
//
// MessageId: TPM_E_KEY_NOTSUPPORTED
//
// MessageText:
//
// Wrong operation to load an NV key.
//
static const int TPM_E_KEY_NOTSUPPORTED = _HRESULT_TYPEDEF_(0x8028003AL);
//
// MessageId: TPM_E_AUTH_CONFLICT
//
// MessageText:
//
// NV_LoadKey blob requires both owner and blob authorization.
//
static const int TPM_E_AUTH_CONFLICT = _HRESULT_TYPEDEF_(0x8028003BL);
//
// MessageId: TPM_E_AREA_LOCKED
//
// MessageText:
//
// The NV area is locked and not writtable.
//
static const int TPM_E_AREA_LOCKED = _HRESULT_TYPEDEF_(0x8028003CL);
//
// MessageId: TPM_E_BAD_LOCALITY
//
// MessageText:
//
// The locality is incorrect for the attempted operation.
//
static const int TPM_E_BAD_LOCALITY = _HRESULT_TYPEDEF_(0x8028003DL);
//
// MessageId: TPM_E_READ_ONLY
//
// MessageText:
//
// The NV area is read only and can't be written to.
//
static const int TPM_E_READ_ONLY = _HRESULT_TYPEDEF_(0x8028003EL);
//
// MessageId: TPM_E_PER_NOWRITE
//
// MessageText:
//
// There is no protection on the write to the NV area.
//
static const int TPM_E_PER_NOWRITE = _HRESULT_TYPEDEF_(0x8028003FL);
//
// MessageId: TPM_E_FAMILYCOUNT
//
// MessageText:
//
// The family count value does not match.
//
static const int TPM_E_FAMILYCOUNT = _HRESULT_TYPEDEF_(0x80280040L);
//
// MessageId: TPM_E_WRITE_LOCKED
//
// MessageText:
//
// The NV area has already been written to.
//
static const int TPM_E_WRITE_LOCKED = _HRESULT_TYPEDEF_(0x80280041L);
//
// MessageId: TPM_E_BAD_ATTRIBUTES
//
// MessageText:
//
// The NV area attributes conflict.
//
static const int TPM_E_BAD_ATTRIBUTES = _HRESULT_TYPEDEF_(0x80280042L);
//
// MessageId: TPM_E_INVALID_STRUCTURE
//
// MessageText:
//
// The structure tag and version are invalid or inconsistent.
//
static const int TPM_E_INVALID_STRUCTURE = _HRESULT_TYPEDEF_(0x80280043L);
//
// MessageId: TPM_E_KEY_OWNER_CONTROL
//
// MessageText:
//
// The key is under control of the TPM Owner and can only be evicted by the TPM Owner.
//
static const int TPM_E_KEY_OWNER_CONTROL = _HRESULT_TYPEDEF_(0x80280044L);
//
// MessageId: TPM_E_BAD_COUNTER
//
// MessageText:
//
// The counter handle is incorrect.
//
static const int TPM_E_BAD_COUNTER = _HRESULT_TYPEDEF_(0x80280045L);
//
// MessageId: TPM_E_NOT_FULLWRITE
//
// MessageText:
//
// The write is not a complete write of the area.
//
static const int TPM_E_NOT_FULLWRITE = _HRESULT_TYPEDEF_(0x80280046L);
//
// MessageId: TPM_E_CONTEXT_GAP
//
// MessageText:
//
// The gap between saved context counts is too large.
//
static const int TPM_E_CONTEXT_GAP = _HRESULT_TYPEDEF_(0x80280047L);
//
// MessageId: TPM_E_MAXNVWRITES
//
// MessageText:
//
// The maximum number of NV writes without an owner has been exceeded.
//
static const int TPM_E_MAXNVWRITES = _HRESULT_TYPEDEF_(0x80280048L);
//
// MessageId: TPM_E_NOOPERATOR
//
// MessageText:
//
// No operator AuthData value is set.
//
static const int TPM_E_NOOPERATOR = _HRESULT_TYPEDEF_(0x80280049L);
//
// MessageId: TPM_E_RESOURCEMISSING
//
// MessageText:
//
// The resource pointed to by context is not loaded.
//
static const int TPM_E_RESOURCEMISSING = _HRESULT_TYPEDEF_(0x8028004AL);
//
// MessageId: TPM_E_DELEGATE_LOCK
//
// MessageText:
//
// The delegate administration is locked.
//
static const int TPM_E_DELEGATE_LOCK = _HRESULT_TYPEDEF_(0x8028004BL);
//
// MessageId: TPM_E_DELEGATE_FAMILY
//
// MessageText:
//
// Attempt to manage a family other then the delegated family.
//
static const int TPM_E_DELEGATE_FAMILY = _HRESULT_TYPEDEF_(0x8028004CL);
//
// MessageId: TPM_E_DELEGATE_ADMIN
//
// MessageText:
//
// Delegation table management not enabled.
//
static const int TPM_E_DELEGATE_ADMIN = _HRESULT_TYPEDEF_(0x8028004DL);
//
// MessageId: TPM_E_TRANSPORT_NOTEXCLUSIVE
//
// MessageText:
//
// There was a command executed outside of an exclusive transport session.
//
static const int TPM_E_TRANSPORT_NOTEXCLUSIVE = _HRESULT_TYPEDEF_(0x8028004EL);
//
// MessageId: TPM_E_OWNER_CONTROL
//
// MessageText:
//
// Attempt to context save a owner evict controlled key.
//
static const int TPM_E_OWNER_CONTROL = _HRESULT_TYPEDEF_(0x8028004FL);
//
// MessageId: TPM_E_DAA_RESOURCES
//
// MessageText:
//
// The DAA command has no resources availble to execute the command.
//
static const int TPM_E_DAA_RESOURCES = _HRESULT_TYPEDEF_(0x80280050L);
//
// MessageId: TPM_E_DAA_INPUT_DATA0
//
// MessageText:
//
// The consistency check on DAA parameter inputData0 has failed.
//
static const int TPM_E_DAA_INPUT_DATA0 = _HRESULT_TYPEDEF_(0x80280051L);
//
// MessageId: TPM_E_DAA_INPUT_DATA1
//
// MessageText:
//
// The consistency check on DAA parameter inputData1 has failed.
//
static const int TPM_E_DAA_INPUT_DATA1 = _HRESULT_TYPEDEF_(0x80280052L);
//
// MessageId: TPM_E_DAA_ISSUER_SETTINGS
//
// MessageText:
//
// The consistency check on DAA_issuerSettings has failed.
//
static const int TPM_E_DAA_ISSUER_SETTINGS = _HRESULT_TYPEDEF_(0x80280053L);
//
// MessageId: TPM_E_DAA_TPM_SETTINGS
//
// MessageText:
//
// The consistency check on DAA_tpmSpecific has failed.
//
static const int TPM_E_DAA_TPM_SETTINGS = _HRESULT_TYPEDEF_(0x80280054L);
//
// MessageId: TPM_E_DAA_STAGE
//
// MessageText:
//
// The atomic process indicated by the submitted DAA command is not the expected process.
//
static const int TPM_E_DAA_STAGE = _HRESULT_TYPEDEF_(0x80280055L);
//
// MessageId: TPM_E_DAA_ISSUER_VALIDITY
//
// MessageText:
//
// The issuer's validity check has detected an inconsistency.
//
static const int TPM_E_DAA_ISSUER_VALIDITY = _HRESULT_TYPEDEF_(0x80280056L);
//
// MessageId: TPM_E_DAA_WRONG_W
//
// MessageText:
//
// The consistency check on w has failed.
//
static const int TPM_E_DAA_WRONG_W = _HRESULT_TYPEDEF_(0x80280057L);
//
// MessageId: TPM_E_BAD_HANDLE
//
// MessageText:
//
// The handle is incorrect.
//
static const int TPM_E_BAD_HANDLE = _HRESULT_TYPEDEF_(0x80280058L);
//
// MessageId: TPM_E_BAD_DELEGATE
//
// MessageText:
//
// Delegation is not correct.
//
static const int TPM_E_BAD_DELEGATE = _HRESULT_TYPEDEF_(0x80280059L);
//
// MessageId: TPM_E_BADCONTEXT
//
// MessageText:
//
// The context blob is invalid.
//
static const int TPM_E_BADCONTEXT = _HRESULT_TYPEDEF_(0x8028005AL);
//
// MessageId: TPM_E_TOOMANYCONTEXTS
//
// MessageText:
//
// Too many contexts held by the TPM.
//
static const int TPM_E_TOOMANYCONTEXTS = _HRESULT_TYPEDEF_(0x8028005BL);
//
// MessageId: TPM_E_MA_TICKET_SIGNATURE
//
// MessageText:
//
// Migration authority signature validation failure.
//
static const int TPM_E_MA_TICKET_SIGNATURE = _HRESULT_TYPEDEF_(0x8028005CL);
//
// MessageId: TPM_E_MA_DESTINATION
//
// MessageText:
//
// Migration destination not authenticated.
//
static const int TPM_E_MA_DESTINATION = _HRESULT_TYPEDEF_(0x8028005DL);
//
// MessageId: TPM_E_MA_SOURCE
//
// MessageText:
//
// Migration source incorrect.
//
static const int TPM_E_MA_SOURCE = _HRESULT_TYPEDEF_(0x8028005EL);
//
// MessageId: TPM_E_MA_AUTHORITY
//
// MessageText:
//
// Incorrect migration authority.
//
static const int TPM_E_MA_AUTHORITY = _HRESULT_TYPEDEF_(0x8028005FL);
//
// MessageId: TPM_E_PERMANENTEK
//
// MessageText:
//
// Attempt to revoke the EK and the EK is not revocable.
//
static const int TPM_E_PERMANENTEK = _HRESULT_TYPEDEF_(0x80280061L);
//
// MessageId: TPM_E_BAD_SIGNATURE
//
// MessageText:
//
// Bad signature of CMK ticket.
//
static const int TPM_E_BAD_SIGNATURE = _HRESULT_TYPEDEF_(0x80280062L);
//
// MessageId: TPM_E_NOCONTEXTSPACE
//
// MessageText:
//
// There is no room in the context list for additional contexts.
//
static const int TPM_E_NOCONTEXTSPACE = _HRESULT_TYPEDEF_(0x80280063L);
//
// TPM vendor specific hardware errors {0x0400..0x04ff}
//
//
// MessageId: TPM_E_COMMAND_BLOCKED
//
// MessageText:
//
// The command was blocked.
//
static const int TPM_E_COMMAND_BLOCKED = _HRESULT_TYPEDEF_(0x80280400L);
//
// MessageId: TPM_E_INVALID_HANDLE
//
// MessageText:
//
// The specified handle was not found.
//
static const int TPM_E_INVALID_HANDLE = _HRESULT_TYPEDEF_(0x80280401L);
//
// MessageId: TPM_E_DUPLICATE_VHANDLE
//
// MessageText:
//
// The TPM returned a duplicate handle and the command needs to be resubmitted.
//
static const int TPM_E_DUPLICATE_VHANDLE = _HRESULT_TYPEDEF_(0x80280402L);
//
// MessageId: TPM_E_EMBEDDED_COMMAND_BLOCKED
//
// MessageText:
//
// The command within the transport was blocked.
//
static const int TPM_E_EMBEDDED_COMMAND_BLOCKED = _HRESULT_TYPEDEF_(0x80280403L);
//
// MessageId: TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
//
// MessageText:
//
// The command within the transport is not supported.
//
static const int TPM_E_EMBEDDED_COMMAND_UNSUPPORTED = _HRESULT_TYPEDEF_(0x80280404L);
//
// TPM non-fatal hardware errors {0x0800..0x08ff}
//
//
// MessageId: TPM_E_RETRY
//
// MessageText:
//
// The TPM is too busy to respond to the command immediately, but the command could be resubmitted at a later time.
//
static const int TPM_E_RETRY = _HRESULT_TYPEDEF_(0x80280800L);
//
// MessageId: TPM_E_NEEDS_SELFTEST
//
// MessageText:
//
// SelfTestFull has not been run.
//
static const int TPM_E_NEEDS_SELFTEST = _HRESULT_TYPEDEF_(0x80280801L);
//
// MessageId: TPM_E_DOING_SELFTEST
//
// MessageText:
//
// The TPM is currently executing a full selftest.
//
static const int TPM_E_DOING_SELFTEST = _HRESULT_TYPEDEF_(0x80280802L);
//
// MessageId: TPM_E_DEFEND_LOCK_RUNNING
//
// MessageText:
//
// The TPM is defending against dictionary attacks and is in a time-out period.
//
static const int TPM_E_DEFEND_LOCK_RUNNING = _HRESULT_TYPEDEF_(0x80280803L);
//
// TPM Base Services error codes {0x4000..0x40ff}
//
//
// MessageId: TBS_E_INTERNAL_ERROR
//
// MessageText:
//
// An internal software error has been detected.
//
static const int TBS_E_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0x80284001L);
//
// MessageId: TBS_E_BAD_PARAMETER
//
// MessageText:
//
// One or more input parameters is bad.
//
static const int TBS_E_BAD_PARAMETER = _HRESULT_TYPEDEF_(0x80284002L);
//
// MessageId: TBS_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// A specified output pointer is bad.
//
static const int TBS_E_INVALID_OUTPUT_POINTER = _HRESULT_TYPEDEF_(0x80284003L);
//
// MessageId: TBS_E_INVALID_CONTEXT
//
// MessageText:
//
// The specified context handle does not refer to a valid context.
//
static const int TBS_E_INVALID_CONTEXT = _HRESULT_TYPEDEF_(0x80284004L);
//
// MessageId: TBS_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// A specified output buffer is too small.
//
static const int TBS_E_INSUFFICIENT_BUFFER = _HRESULT_TYPEDEF_(0x80284005L);
//
// MessageId: TBS_E_IOERROR
//
// MessageText:
//
// An error occurred while communicating with the TPM.
//
static const int TBS_E_IOERROR = _HRESULT_TYPEDEF_(0x80284006L);
//
// MessageId: TBS_E_INVALID_CONTEXT_PARAM
//
// MessageText:
//
// One or more context parameters is invalid.
//
static const int TBS_E_INVALID_CONTEXT_PARAM = _HRESULT_TYPEDEF_(0x80284007L);
//
// MessageId: TBS_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The TBS service is not running and could not be started.
//
static const int TBS_E_SERVICE_NOT_RUNNING = _HRESULT_TYPEDEF_(0x80284008L);
//
// MessageId: TBS_E_TOO_MANY_TBS_CONTEXTS
//
// MessageText:
//
// A new context could not be created because there are too many open contexts.
//
static const int TBS_E_TOO_MANY_TBS_CONTEXTS = _HRESULT_TYPEDEF_(0x80284009L);
//
// MessageId: TBS_E_TOO_MANY_RESOURCES
//
// MessageText:
//
// A new virtual resource could not be created because there are too many open virtual resources.
//
static const int TBS_E_TOO_MANY_RESOURCES = _HRESULT_TYPEDEF_(0x8028400AL);
//
// MessageId: TBS_E_SERVICE_START_PENDING
//
// MessageText:
//
// The TBS service has been started but is not yet running.
//
static const int TBS_E_SERVICE_START_PENDING = _HRESULT_TYPEDEF_(0x8028400BL);
//
// MessageId: TBS_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The physical presence interface is not supported.
//
static const int TBS_E_PPI_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8028400CL);
//
// MessageId: TBS_E_COMMAND_CANCELED
//
// MessageText:
//
// The command was canceled.
//
static const int TBS_E_COMMAND_CANCELED = _HRESULT_TYPEDEF_(0x8028400DL);
//
// MessageId: TBS_E_BUFFER_TOO_LARGE
//
// MessageText:
//
// The input or output buffer is too large.
//
static const int TBS_E_BUFFER_TOO_LARGE = _HRESULT_TYPEDEF_(0x8028400EL);
//
// MessageId: TBS_E_TPM_NOT_FOUND
//
// MessageText:
//
// A compatible Trusted Platform Module (TPM) Security Device cannot be found on this computer.
//
static const int TBS_E_TPM_NOT_FOUND = _HRESULT_TYPEDEF_(0x8028400FL);
//
// MessageId: TBS_E_SERVICE_DISABLED
//
// MessageText:
//
// The TBS service has been disabled.
//
static const int TBS_E_SERVICE_DISABLED = _HRESULT_TYPEDEF_(0x80284010L);
//
// MessageId: TBS_E_NO_EVENT_LOG
//
// MessageText:
//
// No TCG event log is available.
//
static const int TBS_E_NO_EVENT_LOG = _HRESULT_TYPEDEF_(0x80284011L);
//
// TPM API error codes {0x0100..0x01ff}
//
//
// MessageId: TPMAPI_E_INVALID_STATE
//
// MessageText:
//
// The command buffer is not in the correct state.
//
static const int TPMAPI_E_INVALID_STATE = _HRESULT_TYPEDEF_(0x80290100L);
//
// MessageId: TPMAPI_E_NOT_ENOUGH_DATA
//
// MessageText:
//
// The command buffer does not contain enough data to satisfy the request.
//
static const int TPMAPI_E_NOT_ENOUGH_DATA = _HRESULT_TYPEDEF_(0x80290101L);
//
// MessageId: TPMAPI_E_TOO_MUCH_DATA
//
// MessageText:
//
// The command buffer cannot contain any more data.
//
static const int TPMAPI_E_TOO_MUCH_DATA = _HRESULT_TYPEDEF_(0x80290102L);
//
// MessageId: TPMAPI_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// One or more output parameters was NULL or invalid.
//
static const int TPMAPI_E_INVALID_OUTPUT_POINTER = _HRESULT_TYPEDEF_(0x80290103L);
//
// MessageId: TPMAPI_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more input parameters is invalid.
//
static const int TPMAPI_E_INVALID_PARAMETER = _HRESULT_TYPEDEF_(0x80290104L);
//
// MessageId: TPMAPI_E_OUT_OF_MEMORY
//
// MessageText:
//
// Not enough memory was available to satisfy the request.
//
static const int TPMAPI_E_OUT_OF_MEMORY = _HRESULT_TYPEDEF_(0x80290105L);
//
// MessageId: TPMAPI_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The specified buffer was too small.
//
static const int TPMAPI_E_BUFFER_TOO_SMALL = _HRESULT_TYPEDEF_(0x80290106L);
//
// MessageId: TPMAPI_E_INTERNAL_ERROR
//
// MessageText:
//
// An internal error was detected.
//
static const int TPMAPI_E_INTERNAL_ERROR = _HRESULT_TYPEDEF_(0x80290107L);
//
// MessageId: TPMAPI_E_ACCESS_DENIED
//
// MessageText:
//
// The caller does not have the appropriate rights to perform the requested operation.
//
static const int TPMAPI_E_ACCESS_DENIED = _HRESULT_TYPEDEF_(0x80290108L);
//
// MessageId: TPMAPI_E_AUTHORIZATION_FAILED
//
// MessageText:
//
// The specified authorization information was invalid.
//
static const int TPMAPI_E_AUTHORIZATION_FAILED = _HRESULT_TYPEDEF_(0x80290109L);
//
// MessageId: TPMAPI_E_INVALID_CONTEXT_HANDLE
//
// MessageText:
//
// The specified context handle was not valid.
//
static const int TPMAPI_E_INVALID_CONTEXT_HANDLE = _HRESULT_TYPEDEF_(0x8029010AL);
//
// MessageId: TPMAPI_E_TBS_COMMUNICATION_ERROR
//
// MessageText:
//
// An error occurred while communicating with the TBS.
//
static const int TPMAPI_E_TBS_COMMUNICATION_ERROR = _HRESULT_TYPEDEF_(0x8029010BL);
//
// MessageId: TPMAPI_E_TPM_COMMAND_ERROR
//
// MessageText:
//
// The TPM returned an unexpected result.
//
static const int TPMAPI_E_TPM_COMMAND_ERROR = _HRESULT_TYPEDEF_(0x8029010CL);
//
// MessageId: TPMAPI_E_MESSAGE_TOO_LARGE
//
// MessageText:
//
// The message was too large for the encoding scheme.
//
static const int TPMAPI_E_MESSAGE_TOO_LARGE = _HRESULT_TYPEDEF_(0x8029010DL);
//
// MessageId: TPMAPI_E_INVALID_ENCODING
//
// MessageText:
//
// The encoding in the blob was not recognized.
//
static const int TPMAPI_E_INVALID_ENCODING = _HRESULT_TYPEDEF_(0x8029010EL);
//
// MessageId: TPMAPI_E_INVALID_KEY_SIZE
//
// MessageText:
//
// The key size is not valid.
//
static const int TPMAPI_E_INVALID_KEY_SIZE = _HRESULT_TYPEDEF_(0x8029010FL);
//
// MessageId: TPMAPI_E_ENCRYPTION_FAILED
//
// MessageText:
//
// The encryption operation failed.
//
static const int TPMAPI_E_ENCRYPTION_FAILED = _HRESULT_TYPEDEF_(0x80290110L);
//
// MessageId: TPMAPI_E_INVALID_KEY_PARAMS
//
// MessageText:
//
// The key parameters structure was not valid
//
static const int TPMAPI_E_INVALID_KEY_PARAMS = _HRESULT_TYPEDEF_(0x80290111L);
//
// MessageId: TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB
//
// MessageText:
//
// The requested supplied data does not appear to be a valid migration authorization blob.
//
static const int TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB = _HRESULT_TYPEDEF_(0x80290112L);
//
// MessageId: TPMAPI_E_INVALID_PCR_INDEX
//
// MessageText:
//
// The specified PCR index was invalid
//
static const int TPMAPI_E_INVALID_PCR_INDEX = _HRESULT_TYPEDEF_(0x80290113L);
//
// MessageId: TPMAPI_E_INVALID_DELEGATE_BLOB
//
// MessageText:
//
// The data given does not appear to be a valid delegate blob.
//
static const int TPMAPI_E_INVALID_DELEGATE_BLOB = _HRESULT_TYPEDEF_(0x80290114L);
//
// MessageId: TPMAPI_E_INVALID_CONTEXT_PARAMS
//
// MessageText:
//
// One or more of the specified context parameters was not valid.
//
static const int TPMAPI_E_INVALID_CONTEXT_PARAMS = _HRESULT_TYPEDEF_(0x80290115L);
//
// MessageId: TPMAPI_E_INVALID_KEY_BLOB
//
// MessageText:
//
// The data given does not appear to be a valid key blob
//
static const int TPMAPI_E_INVALID_KEY_BLOB = _HRESULT_TYPEDEF_(0x80290116L);
//
// MessageId: TPMAPI_E_INVALID_PCR_DATA
//
// MessageText:
//
// The specified PCR data was invalid.
//
static const int TPMAPI_E_INVALID_PCR_DATA = _HRESULT_TYPEDEF_(0x80290117L);
//
// MessageId: TPMAPI_E_INVALID_OWNER_AUTH
//
// MessageText:
//
// The format of the owner auth data was invalid.
//
static const int TPMAPI_E_INVALID_OWNER_AUTH = _HRESULT_TYPEDEF_(0x80290118L);
//
// MessageId: TPMAPI_E_FIPS_RNG_CHECK_FAILED
//
// MessageText:
//
// The random number generated did not pass FIPS RNG check.
//
static const int TPMAPI_E_FIPS_RNG_CHECK_FAILED = _HRESULT_TYPEDEF_(0x80290119L);
//
// MessageId: TPMAPI_E_EMPTY_TCG_LOG
//
// MessageText:
//
// The TCG Event Log does not contain any data.
//
static const int TPMAPI_E_EMPTY_TCG_LOG = _HRESULT_TYPEDEF_(0x8029011AL);
//
// MessageId: TPMAPI_E_INVALID_TCG_LOG_ENTRY
//
// MessageText:
//
// An entry in the TCG Event Log was invalid.
//
static const int TPMAPI_E_INVALID_TCG_LOG_ENTRY = _HRESULT_TYPEDEF_(0x8029011BL);
//
// MessageId: TPMAPI_E_TCG_SEPARATOR_ABSENT
//
// MessageText:
//
// A TCG Separator was not found.
//
static const int TPMAPI_E_TCG_SEPARATOR_ABSENT = _HRESULT_TYPEDEF_(0x8029011CL);
//
// MessageId: TPMAPI_E_TCG_INVALID_DIGEST_ENTRY
//
// MessageText:
//
// A digest value in a TCG Log entry did not match hashed data.
//
static const int TPMAPI_E_TCG_INVALID_DIGEST_ENTRY = _HRESULT_TYPEDEF_(0x8029011DL);
//
// TBS implementation error codes {0x0200..0x02ff}
//
//
// MessageId: TBSIMP_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The specified buffer was too small.
//
static const int TBSIMP_E_BUFFER_TOO_SMALL = _HRESULT_TYPEDEF_(0x80290200L);
//
// MessageId: TBSIMP_E_CLEANUP_FAILED
//
// MessageText:
//
// The context could not be cleaned up.
//
static const int TBSIMP_E_CLEANUP_FAILED = _HRESULT_TYPEDEF_(0x80290201L);
//
// MessageId: TBSIMP_E_INVALID_CONTEXT_HANDLE
//
// MessageText:
//
// The specified context handle is invalid.
//
static const int TBSIMP_E_INVALID_CONTEXT_HANDLE = _HRESULT_TYPEDEF_(0x80290202L);
//
// MessageId: TBSIMP_E_INVALID_CONTEXT_PARAM
//
// MessageText:
//
// An invalid context parameter was specified.
//
static const int TBSIMP_E_INVALID_CONTEXT_PARAM = _HRESULT_TYPEDEF_(0x80290203L);
//
// MessageId: TBSIMP_E_TPM_ERROR
//
// MessageText:
//
// An error occurred while communicating with the TPM
//
static const int TBSIMP_E_TPM_ERROR = _HRESULT_TYPEDEF_(0x80290204L);
//
// MessageId: TBSIMP_E_HASH_BAD_KEY
//
// MessageText:
//
// No entry with the specified key was found.
//
static const int TBSIMP_E_HASH_BAD_KEY = _HRESULT_TYPEDEF_(0x80290205L);
//
// MessageId: TBSIMP_E_DUPLICATE_VHANDLE
//
// MessageText:
//
// The specified virtual handle matches a virtual handle already in use.
//
static const int TBSIMP_E_DUPLICATE_VHANDLE = _HRESULT_TYPEDEF_(0x80290206L);
//
// MessageId: TBSIMP_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// The pointer to the returned handle location was NULL or invalid
//
static const int TBSIMP_E_INVALID_OUTPUT_POINTER = _HRESULT_TYPEDEF_(0x80290207L);
//
// MessageId: TBSIMP_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more parameters is invalid
//
static const int TBSIMP_E_INVALID_PARAMETER = _HRESULT_TYPEDEF_(0x80290208L);
//
// MessageId: TBSIMP_E_RPC_INIT_FAILED
//
// MessageText:
//
// The RPC subsystem could not be initialized.
//
static const int TBSIMP_E_RPC_INIT_FAILED = _HRESULT_TYPEDEF_(0x80290209L);
//
// MessageId: TBSIMP_E_SCHEDULER_NOT_RUNNING
//
// MessageText:
//
// The TBS scheduler is not running.
//
static const int TBSIMP_E_SCHEDULER_NOT_RUNNING = _HRESULT_TYPEDEF_(0x8029020AL);
//
// MessageId: TBSIMP_E_COMMAND_CANCELED
//
// MessageText:
//
// The command was canceled.
//
static const int TBSIMP_E_COMMAND_CANCELED = _HRESULT_TYPEDEF_(0x8029020BL);
//
// MessageId: TBSIMP_E_OUT_OF_MEMORY
//
// MessageText:
//
// There was not enough memory to fulfill the request
//
static const int TBSIMP_E_OUT_OF_MEMORY = _HRESULT_TYPEDEF_(0x8029020CL);
//
// MessageId: TBSIMP_E_LIST_NO_MORE_ITEMS
//
// MessageText:
//
// The specified list is empty, or the iteration has reached the end of the list.
//
static const int TBSIMP_E_LIST_NO_MORE_ITEMS = _HRESULT_TYPEDEF_(0x8029020DL);
//
// MessageId: TBSIMP_E_LIST_NOT_FOUND
//
// MessageText:
//
// The specified item was not found in the list.
//
static const int TBSIMP_E_LIST_NOT_FOUND = _HRESULT_TYPEDEF_(0x8029020EL);
//
// MessageId: TBSIMP_E_NOT_ENOUGH_SPACE
//
// MessageText:
//
// The TPM does not have enough space to load the requested resource.
//
static const int TBSIMP_E_NOT_ENOUGH_SPACE = _HRESULT_TYPEDEF_(0x8029020FL);
//
// MessageId: TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS
//
// MessageText:
//
// There are too many TPM contexts in use.
//
static const int TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS = _HRESULT_TYPEDEF_(0x80290210L);
//
// MessageId: TBSIMP_E_COMMAND_FAILED
//
// MessageText:
//
// The TPM command failed.
//
static const int TBSIMP_E_COMMAND_FAILED = _HRESULT_TYPEDEF_(0x80290211L);
//
// MessageId: TBSIMP_E_UNKNOWN_ORDINAL
//
// MessageText:
//
// The TBS does not recognize the specified ordinal.
//
static const int TBSIMP_E_UNKNOWN_ORDINAL = _HRESULT_TYPEDEF_(0x80290212L);
//
// MessageId: TBSIMP_E_RESOURCE_EXPIRED
//
// MessageText:
//
// The requested resource is no longer available.
//
static const int TBSIMP_E_RESOURCE_EXPIRED = _HRESULT_TYPEDEF_(0x80290213L);
//
// MessageId: TBSIMP_E_INVALID_RESOURCE
//
// MessageText:
//
// The resource type did not match.
//
static const int TBSIMP_E_INVALID_RESOURCE = _HRESULT_TYPEDEF_(0x80290214L);
//
// MessageId: TBSIMP_E_NOTHING_TO_UNLOAD
//
// MessageText:
//
// No resources can be unloaded.
//
static const int TBSIMP_E_NOTHING_TO_UNLOAD = _HRESULT_TYPEDEF_(0x80290215L);
//
// MessageId: TBSIMP_E_HASH_TABLE_FULL
//
// MessageText:
//
// No new entries can be added to the hash table.
//
static const int TBSIMP_E_HASH_TABLE_FULL = _HRESULT_TYPEDEF_(0x80290216L);
//
// MessageId: TBSIMP_E_TOO_MANY_TBS_CONTEXTS
//
// MessageText:
//
// A new TBS context could not be created because there are too many open contexts.
//
static const int TBSIMP_E_TOO_MANY_TBS_CONTEXTS = _HRESULT_TYPEDEF_(0x80290217L);
//
// MessageId: TBSIMP_E_TOO_MANY_RESOURCES
//
// MessageText:
//
// A new virtual resource could not be created because there are too many open virtual resources.
//
static const int TBSIMP_E_TOO_MANY_RESOURCES = _HRESULT_TYPEDEF_(0x80290218L);
//
// MessageId: TBSIMP_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The physical presence interface is not supported.
//
static const int TBSIMP_E_PPI_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80290219L);
//
// MessageId: TBSIMP_E_TPM_INCOMPATIBLE
//
// MessageText:
//
// TBS is not compatible with the version of TPM found on the system.
//
static const int TBSIMP_E_TPM_INCOMPATIBLE = _HRESULT_TYPEDEF_(0x8029021AL);
//
// MessageId: TBSIMP_E_NO_EVENT_LOG
//
// MessageText:
//
// No TCG event log is available.
//
static const int TBSIMP_E_NO_EVENT_LOG = _HRESULT_TYPEDEF_(0x8029021BL);
//
// TPM Physical Presence implementation error codes {0x0300..0x03ff}
//
//
// MessageId: TPM_E_PPI_ACPI_FAILURE
//
// MessageText:
//
// A general error was detected when attempting to acquire the BIOS's response to a Physical Presence command.
//
static const int TPM_E_PPI_ACPI_FAILURE = _HRESULT_TYPEDEF_(0x80290300L);
//
// MessageId: TPM_E_PPI_USER_ABORT
//
// MessageText:
//
// The user failed to confirm the TPM operation request.
//
static const int TPM_E_PPI_USER_ABORT = _HRESULT_TYPEDEF_(0x80290301L);
//
// MessageId: TPM_E_PPI_BIOS_FAILURE
//
// MessageText:
//
// The BIOS failure prevented the successful execution of the requested TPM operation (e.g. invalid TPM operation request, BIOS communication error with the TPM).
//
static const int TPM_E_PPI_BIOS_FAILURE = _HRESULT_TYPEDEF_(0x80290302L);
//
// MessageId: TPM_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The BIOS does not support the physical presence interface.
//
static const int TPM_E_PPI_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80290303L);
//
// =======================================================
// Facility Performance Logs & Alerts (PLA) Error Messages
// =======================================================
//
//
// MessageId: PLA_E_DCS_NOT_FOUND
//
// MessageText:
//
// Data Collector Set was not found.
//
static const int PLA_E_DCS_NOT_FOUND = _HRESULT_TYPEDEF_(0x80300002L);
//
// MessageId: PLA_E_DCS_IN_USE
//
// MessageText:
//
// The Data Collector Set or one of its dependencies is already in use.
//
static const int PLA_E_DCS_IN_USE = _HRESULT_TYPEDEF_(0x803000AAL);
//
// MessageId: PLA_E_TOO_MANY_FOLDERS
//
// MessageText:
//
// Unable to start Data Collector Set because there are too many folders.
//
static const int PLA_E_TOO_MANY_FOLDERS = _HRESULT_TYPEDEF_(0x80300045L);
//
// MessageId: PLA_E_NO_MIN_DISK
//
// MessageText:
//
// Not enough free disk space to start Data Collector Set.
//
static const int PLA_E_NO_MIN_DISK = _HRESULT_TYPEDEF_(0x80300070L);
//
// MessageId: PLA_E_DCS_ALREADY_EXISTS
//
// MessageText:
//
// Data Collector Set already exists.
//
static const int PLA_E_DCS_ALREADY_EXISTS = _HRESULT_TYPEDEF_(0x803000B7L);
//
// MessageId: PLA_S_PROPERTY_IGNORED
//
// MessageText:
//
// Property value will be ignored.
//
static const int PLA_S_PROPERTY_IGNORED = _HRESULT_TYPEDEF_(0x00300100L);
//
// MessageId: PLA_E_PROPERTY_CONFLICT
//
// MessageText:
//
// Property value conflict.
//
static const int PLA_E_PROPERTY_CONFLICT = _HRESULT_TYPEDEF_(0x80300101L);
//
// MessageId: PLA_E_DCS_SINGLETON_REQUIRED
//
// MessageText:
//
// The current configuration for this Data Collector Set requires that it contain exactly one Data Collector.
//
static const int PLA_E_DCS_SINGLETON_REQUIRED = _HRESULT_TYPEDEF_(0x80300102L);
//
// MessageId: PLA_E_CREDENTIALS_REQUIRED
//
// MessageText:
//
// A user account is required in order to commit the current Data Collector Set properties.
//
static const int PLA_E_CREDENTIALS_REQUIRED = _HRESULT_TYPEDEF_(0x80300103L);
//
// MessageId: PLA_E_DCS_NOT_RUNNING
//
// MessageText:
//
// Data Collector Set is not running.
//
static const int PLA_E_DCS_NOT_RUNNING = _HRESULT_TYPEDEF_(0x80300104L);
//
// MessageId: PLA_E_CONFLICT_INCL_EXCL_API
//
// MessageText:
//
// A conflict was detected in the list of include/exclude APIs. Do not specify the same API in both the include list and the exclude list.
//
static const int PLA_E_CONFLICT_INCL_EXCL_API = _HRESULT_TYPEDEF_(0x80300105L);
//
// MessageId: PLA_E_NETWORK_EXE_NOT_VALID
//
// MessageText:
//
// The executable path you have specified refers to a network share or UNC path.
//
static const int PLA_E_NETWORK_EXE_NOT_VALID = _HRESULT_TYPEDEF_(0x80300106L);
//
// MessageId: PLA_E_EXE_ALREADY_CONFIGURED
//
// MessageText:
//
// The executable path you have specified is already configured for API tracing.
//
static const int PLA_E_EXE_ALREADY_CONFIGURED = _HRESULT_TYPEDEF_(0x80300107L);
//
// MessageId: PLA_E_EXE_PATH_NOT_VALID
//
// MessageText:
//
// The executable path you have specified does not exist. Verify that the specified path is correct.
//
static const int PLA_E_EXE_PATH_NOT_VALID = _HRESULT_TYPEDEF_(0x80300108L);
//
// MessageId: PLA_E_DC_ALREADY_EXISTS
//
// MessageText:
//
// Data Collector already exists.
//
static const int PLA_E_DC_ALREADY_EXISTS = _HRESULT_TYPEDEF_(0x80300109L);
//
// MessageId: PLA_E_DCS_START_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the Data Collector Set start notification has timed out.
//
static const int PLA_E_DCS_START_WAIT_TIMEOUT = _HRESULT_TYPEDEF_(0x8030010AL);
//
// MessageId: PLA_E_DC_START_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the Data Collector to start has timed out.
//
static const int PLA_E_DC_START_WAIT_TIMEOUT = _HRESULT_TYPEDEF_(0x8030010BL);
//
// MessageId: PLA_E_REPORT_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the report generation tool to finish has timed out.
//
static const int PLA_E_REPORT_WAIT_TIMEOUT = _HRESULT_TYPEDEF_(0x8030010CL);
//
// MessageId: PLA_E_NO_DUPLICATES
//
// MessageText:
//
// Duplicate items are not allowed.
//
static const int PLA_E_NO_DUPLICATES = _HRESULT_TYPEDEF_(0x8030010DL);
//
// MessageId: PLA_E_EXE_FULL_PATH_REQUIRED
//
// MessageText:
//
// When specifying the executable that you want to trace, you must specify a full path to the executable and not just a filename.
//
static const int PLA_E_EXE_FULL_PATH_REQUIRED = _HRESULT_TYPEDEF_(0x8030010EL);
//
// MessageId: PLA_E_INVALID_SESSION_NAME
//
// MessageText:
//
// The session name provided is invalid.
//
static const int PLA_E_INVALID_SESSION_NAME = _HRESULT_TYPEDEF_(0x8030010FL);
//
// MessageId: PLA_E_PLA_CHANNEL_NOT_ENABLED
//
// MessageText:
//
// The Event Log channel Microsoft-Windows-Diagnosis-PLA/Operational must be enabled to perform this operation.
//
static const int PLA_E_PLA_CHANNEL_NOT_ENABLED = _HRESULT_TYPEDEF_(0x80300110L);
//
// MessageId: PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED
//
// MessageText:
//
// The Event Log channel Microsoft-Windows-TaskScheduler must be enabled to perform this operation.
//
static const int PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED = _HRESULT_TYPEDEF_(0x80300111L);
//
// MessageId: PLA_E_RULES_MANAGER_FAILED
//
// MessageText:
//
// The execution of the Rules Manager failed.
//
static const int PLA_E_RULES_MANAGER_FAILED = _HRESULT_TYPEDEF_(0x80300112L);
//
// MessageId: PLA_E_CABAPI_FAILURE
//
// MessageText:
//
// An error occurred while attempting to compress or extract the data.
//
static const int PLA_E_CABAPI_FAILURE = _HRESULT_TYPEDEF_(0x80300113L);
//
// =======================================================
// Full Volume Encryption Error Messages
// =======================================================
//
//
// MessageId: FVE_E_LOCKED_VOLUME
//
// MessageText:
//
// This drive is locked by BitLocker Drive Encryption. You must unlock this drive from Control Panel.
//
static const int FVE_E_LOCKED_VOLUME = _HRESULT_TYPEDEF_(0x80310000L);
//
// MessageId: FVE_E_NOT_ENCRYPTED
//
// MessageText:
//
// This drive is not encrypted.
//
static const int FVE_E_NOT_ENCRYPTED = _HRESULT_TYPEDEF_(0x80310001L);
//
// MessageId: FVE_E_NO_TPM_BIOS
//
// MessageText:
//
// The BIOS did not correctly communicate with the Trusted Platform Module (TPM). Contact the computer manufacturer for BIOS upgrade instructions.
//
static const int FVE_E_NO_TPM_BIOS = _HRESULT_TYPEDEF_(0x80310002L);
//
// MessageId: FVE_E_NO_MBR_METRIC
//
// MessageText:
//
// The BIOS did not correctly communicate with the master boot record (MBR). Contact the computer manufacturer for BIOS upgrade instructions.
//
static const int FVE_E_NO_MBR_METRIC = _HRESULT_TYPEDEF_(0x80310003L);
//
// MessageId: FVE_E_NO_BOOTSECTOR_METRIC
//
// MessageText:
//
// A required TPM measurement is missing. If there is a bootable CD or DVD in your computer, remove it, restart the computer, and turn on BitLocker again. If the problem persists, ensure the master boot record is up to date.
//
static const int FVE_E_NO_BOOTSECTOR_METRIC = _HRESULT_TYPEDEF_(0x80310004L);
//
// MessageId: FVE_E_NO_BOOTMGR_METRIC
//
// MessageText:
//
// The boot sector of this drive is not compatible with BitLocker Drive Encryption. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot manager (BOOTMGR).
//
static const int FVE_E_NO_BOOTMGR_METRIC = _HRESULT_TYPEDEF_(0x80310005L);
//
// MessageId: FVE_E_WRONG_BOOTMGR
//
// MessageText:
//
// The boot manager of this operating system is not compatible with BitLocker Drive Encryption. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot manager (BOOTMGR).
//
static const int FVE_E_WRONG_BOOTMGR = _HRESULT_TYPEDEF_(0x80310006L);
//
// MessageId: FVE_E_SECURE_KEY_REQUIRED
//
// MessageText:
//
// At least one secure key protector is required for this operation to be performed.
//
static const int FVE_E_SECURE_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x80310007L);
//
// MessageId: FVE_E_NOT_ACTIVATED
//
// MessageText:
//
// BitLocker Drive Encryption is not enabled on this drive. Turn on BitLocker.
//
static const int FVE_E_NOT_ACTIVATED = _HRESULT_TYPEDEF_(0x80310008L);
//
// MessageId: FVE_E_ACTION_NOT_ALLOWED
//
// MessageText:
//
// BitLocker Drive Encryption cannot perform the requested action. This condition may occur when two requests are issued at the same time. Wait a few moments and then try the action again.
//
static const int FVE_E_ACTION_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310009L);
//
// MessageId: FVE_E_AD_SCHEMA_NOT_INSTALLED
//
// MessageText:
//
// The Active Directory Domain Services forest does not contain the required attributes and classes to host BitLocker Drive Encryption or Trusted Platform Module information. Contact your domain administrator to verify that any required BitLocker Active Directory schema extensions have been installed.
//
static const int FVE_E_AD_SCHEMA_NOT_INSTALLED = _HRESULT_TYPEDEF_(0x8031000AL);
//
// MessageId: FVE_E_AD_INVALID_DATATYPE
//
// MessageText:
//
// The type of the data obtained from Active Directory was not expected. The BitLocker recovery information may be missing or corrupted.
//
static const int FVE_E_AD_INVALID_DATATYPE = _HRESULT_TYPEDEF_(0x8031000BL);
//
// MessageId: FVE_E_AD_INVALID_DATASIZE
//
// MessageText:
//
// The size of the data obtained from Active Directory was not expected. The BitLocker recovery information may be missing or corrupted.
//
static const int FVE_E_AD_INVALID_DATASIZE = _HRESULT_TYPEDEF_(0x8031000CL);
//
// MessageId: FVE_E_AD_NO_VALUES
//
// MessageText:
//
// The attribute read from Active Directory does not contain any values. The BitLocker recovery information may be missing or corrupted.
//
static const int FVE_E_AD_NO_VALUES = _HRESULT_TYPEDEF_(0x8031000DL);
//
// MessageId: FVE_E_AD_ATTR_NOT_SET
//
// MessageText:
//
// The attribute was not set. Verify that you are logged on with a domain account that has the ability to write information to Active Directory objects.
//
static const int FVE_E_AD_ATTR_NOT_SET = _HRESULT_TYPEDEF_(0x8031000EL);
//
// MessageId: FVE_E_AD_GUID_NOT_FOUND
//
// MessageText:
//
// The specified attribute cannot be found in Active Directory Domain Services. Contact your domain administrator to verify that any required BitLocker Active Directory schema extensions have been installed.
//
static const int FVE_E_AD_GUID_NOT_FOUND = _HRESULT_TYPEDEF_(0x8031000FL);
//
// MessageId: FVE_E_BAD_INFORMATION
//
// MessageText:
//
// The BitLocker metadata for the encrypted drive is not valid. You can attempt to repair the drive to restore access.
//
static const int FVE_E_BAD_INFORMATION = _HRESULT_TYPEDEF_(0x80310010L);
//
// MessageId: FVE_E_TOO_SMALL
//
// MessageText:
//
// The drive cannot be encrypted because it does not have enough free space. Delete any unnecessary data on the drive to create additional free space and then try again.
//
static const int FVE_E_TOO_SMALL = _HRESULT_TYPEDEF_(0x80310011L);
//
// MessageId: FVE_E_SYSTEM_VOLUME
//
// MessageText:
//
// The drive cannot be encrypted because it contains system boot information. Create a separate partition for use as the system drive that contains the boot information and a second partition for use as the operating system drive and then encrypt the operating system drive.
//
static const int FVE_E_SYSTEM_VOLUME = _HRESULT_TYPEDEF_(0x80310012L);
//
// MessageId: FVE_E_FAILED_WRONG_FS
//
// MessageText:
//
// The drive cannot be encrypted because the file system is not supported.
//
static const int FVE_E_FAILED_WRONG_FS = _HRESULT_TYPEDEF_(0x80310013L);
//
// MessageId: FVE_E_BAD_PARTITION_SIZE
//
// MessageText:
//
// The file system size is larger than the partition size in the partition table. This drive may be corrupt or may have been tampered with. To use it with BitLocker, you must reformat the partition.
//
static const int FVE_E_BAD_PARTITION_SIZE = _HRESULT_TYPEDEF_(0x80310014L);
//
// MessageId: FVE_E_NOT_SUPPORTED
//
// MessageText:
//
// This drive cannot be encrypted.
//
static const int FVE_E_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80310015L);
//
// MessageId: FVE_E_BAD_DATA
//
// MessageText:
//
// The data is not valid.
//
static const int FVE_E_BAD_DATA = _HRESULT_TYPEDEF_(0x80310016L);
//
// MessageId: FVE_E_VOLUME_NOT_BOUND
//
// MessageText:
//
// The data drive specified is not set to automatically unlock on the current computer and cannot be unlocked automatically.
//
static const int FVE_E_VOLUME_NOT_BOUND = _HRESULT_TYPEDEF_(0x80310017L);
//
// MessageId: FVE_E_TPM_NOT_OWNED
//
// MessageText:
//
// You must initialize the Trusted Platform Module (TPM) before you can use BitLocker Drive Encryption.
//
static const int FVE_E_TPM_NOT_OWNED = _HRESULT_TYPEDEF_(0x80310018L);
//
// MessageId: FVE_E_NOT_DATA_VOLUME
//
// MessageText:
//
// The operation attempted cannot be performed on an operating system drive.
//
static const int FVE_E_NOT_DATA_VOLUME = _HRESULT_TYPEDEF_(0x80310019L);
//
// MessageId: FVE_E_AD_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The buffer supplied to a function was insufficient to contain the returned data. Increase the buffer size before running the function again.
//
static const int FVE_E_AD_INSUFFICIENT_BUFFER = _HRESULT_TYPEDEF_(0x8031001AL);
//
// MessageId: FVE_E_CONV_READ
//
// MessageText:
//
// A read operation failed while converting the drive. The drive was not converted. Please re-enable BitLocker.
//
static const int FVE_E_CONV_READ = _HRESULT_TYPEDEF_(0x8031001BL);
//
// MessageId: FVE_E_CONV_WRITE
//
// MessageText:
//
// A write operation failed while converting the drive. The drive was not converted. Please re-enable BitLocker.
//
static const int FVE_E_CONV_WRITE = _HRESULT_TYPEDEF_(0x8031001CL);
//
// MessageId: FVE_E_KEY_REQUIRED
//
// MessageText:
//
// One or more BitLocker key protectors are required. You cannot delete the last key on this drive.
//
static const int FVE_E_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x8031001DL);
//
// MessageId: FVE_E_CLUSTERING_NOT_SUPPORTED
//
// MessageText:
//
// Cluster configurations are not supported by BitLocker Drive Encryption.
//
static const int FVE_E_CLUSTERING_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8031001EL);
//
// MessageId: FVE_E_VOLUME_BOUND_ALREADY
//
// MessageText:
//
// The drive specified is already configured to be automatically unlocked on the current computer.
//
static const int FVE_E_VOLUME_BOUND_ALREADY = _HRESULT_TYPEDEF_(0x8031001FL);
//
// MessageId: FVE_E_OS_NOT_PROTECTED
//
// MessageText:
//
// The operating system drive is not protected by BitLocker Drive Encryption.
//
static const int FVE_E_OS_NOT_PROTECTED = _HRESULT_TYPEDEF_(0x80310020L);
//
// MessageId: FVE_E_PROTECTION_DISABLED
//
// MessageText:
//
// BitLocker Drive Encryption has been suspended on this drive. All BitLocker key protectors configured for this drive are effectively disabled, and the drive will be automatically unlocked using an unencrypted (clear) key.
//
static const int FVE_E_PROTECTION_DISABLED = _HRESULT_TYPEDEF_(0x80310021L);
//
// MessageId: FVE_E_RECOVERY_KEY_REQUIRED
//
// MessageText:
//
// The drive you are attempting to lock does not have any key protectors available for encryption because BitLocker protection is currently suspended. Re-enable BitLocker to lock this drive.
//
static const int FVE_E_RECOVERY_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x80310022L);
//
// MessageId: FVE_E_FOREIGN_VOLUME
//
// MessageText:
//
// BitLocker cannot use the Trusted Platform Module (TPM) to protect a data drive. TPM protection can only be used with the operating system drive.
//
static const int FVE_E_FOREIGN_VOLUME = _HRESULT_TYPEDEF_(0x80310023L);
//
// MessageId: FVE_E_OVERLAPPED_UPDATE
//
// MessageText:
//
// The BitLocker metadata for the encrypted drive cannot be updated because it was locked for updating by another process. Please try this process again.
//
static const int FVE_E_OVERLAPPED_UPDATE = _HRESULT_TYPEDEF_(0x80310024L);
//
// MessageId: FVE_E_TPM_SRK_AUTH_NOT_ZERO
//
// MessageText:
//
// The authorization data for the storage root key (SRK) of the Trusted Platform Module (TPM) is not zero and is therefore incompatible with BitLocker. Please initialize the TPM before attempting to use it with BitLocker.
//
static const int FVE_E_TPM_SRK_AUTH_NOT_ZERO = _HRESULT_TYPEDEF_(0x80310025L);
//
// MessageId: FVE_E_FAILED_SECTOR_SIZE
//
// MessageText:
//
// The drive encryption algorithm cannot be used on this sector size.
//
static const int FVE_E_FAILED_SECTOR_SIZE = _HRESULT_TYPEDEF_(0x80310026L);
//
// MessageId: FVE_E_FAILED_AUTHENTICATION
//
// MessageText:
//
// The drive cannot be unlocked with the key provided. Confirm that you have provided the correct key and try again.
//
static const int FVE_E_FAILED_AUTHENTICATION = _HRESULT_TYPEDEF_(0x80310027L);
//
// MessageId: FVE_E_NOT_OS_VOLUME
//
// MessageText:
//
// The drive specified is not the operating system drive.
//
static const int FVE_E_NOT_OS_VOLUME = _HRESULT_TYPEDEF_(0x80310028L);
//
// MessageId: FVE_E_AUTOUNLOCK_ENABLED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be turned off on the operating system drive until the auto unlock feature has been disabled for the fixed data drives and removable data drives associated with this computer.
//
static const int FVE_E_AUTOUNLOCK_ENABLED = _HRESULT_TYPEDEF_(0x80310029L);
//
// MessageId: FVE_E_WRONG_BOOTSECTOR
//
// MessageText:
//
// The system partition boot sector does not perform Trusted Platform Module (TPM) measurements. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot sector.
//
static const int FVE_E_WRONG_BOOTSECTOR = _HRESULT_TYPEDEF_(0x8031002AL);
//
// MessageId: FVE_E_WRONG_SYSTEM_FS
//
// MessageText:
//
// BitLocker Drive Encryption operating system drives must be formatted with the NTFS file system in order to be encrypted. Convert the drive to NTFS, and then turn on BitLocker.
//
static const int FVE_E_WRONG_SYSTEM_FS = _HRESULT_TYPEDEF_(0x8031002BL);
//
// MessageId: FVE_E_POLICY_PASSWORD_REQUIRED
//
// MessageText:
//
// Group Policy settings require that a recovery password be specified before encrypting the drive.
//
static const int FVE_E_POLICY_PASSWORD_REQUIRED = _HRESULT_TYPEDEF_(0x8031002CL);
//
// MessageId: FVE_E_CANNOT_SET_FVEK_ENCRYPTED
//
// MessageText:
//
// The drive encryption algorithm and key cannot be set on a previously encrypted drive. To encrypt this drive with BitLocker Drive Encryption, remove the previous encryption and then turn on BitLocker.
//
static const int FVE_E_CANNOT_SET_FVEK_ENCRYPTED = _HRESULT_TYPEDEF_(0x8031002DL);
//
// MessageId: FVE_E_CANNOT_ENCRYPT_NO_KEY
//
// MessageText:
//
// BitLocker Drive Encryption cannot encrypt the specified drive because an encryption key is not available. Add a key protector to encrypt this drive.
//
static const int FVE_E_CANNOT_ENCRYPT_NO_KEY = _HRESULT_TYPEDEF_(0x8031002EL);
//
// MessageId: FVE_E_BOOTABLE_CDDVD
//
// MessageText:
//
// BitLocker Drive Encryption detected bootable media (CD or DVD) in the computer. Remove the media and restart the computer before configuring BitLocker.
//
static const int FVE_E_BOOTABLE_CDDVD = _HRESULT_TYPEDEF_(0x80310030L);
//
// MessageId: FVE_E_PROTECTOR_EXISTS
//
// MessageText:
//
// This key protector cannot be added. Only one key protector of this type is allowed for this drive.
//
static const int FVE_E_PROTECTOR_EXISTS = _HRESULT_TYPEDEF_(0x80310031L);
//
// MessageId: FVE_E_RELATIVE_PATH
//
// MessageText:
//
// The recovery password file was not found because a relative path was specified. Recovery passwords must be saved to a fully qualified path. Environment variables configured on the computer can be used in the path.
//
static const int FVE_E_RELATIVE_PATH = _HRESULT_TYPEDEF_(0x80310032L);
//
// MessageId: FVE_E_PROTECTOR_NOT_FOUND
//
// MessageText:
//
// The specified key protector was not found on the drive. Try another key protector.
//
static const int FVE_E_PROTECTOR_NOT_FOUND = _HRESULT_TYPEDEF_(0x80310033L);
//
// MessageId: FVE_E_INVALID_KEY_FORMAT
//
// MessageText:
//
// The recovery key provided is corrupt and cannot be used to access the drive. An alternative recovery method, such as recovery password, a data recovery agent, or a backup version of the recovery key must be used to recover access to the drive.
//
static const int FVE_E_INVALID_KEY_FORMAT = _HRESULT_TYPEDEF_(0x80310034L);
//
// MessageId: FVE_E_INVALID_PASSWORD_FORMAT
//
// MessageText:
//
// The format of the recovery password provided is invalid. BitLocker recovery passwords are 48 digits. Verify that the recovery password is in the correct format and then try again.
//
static const int FVE_E_INVALID_PASSWORD_FORMAT = _HRESULT_TYPEDEF_(0x80310035L);
//
// MessageId: FVE_E_FIPS_RNG_CHECK_FAILED
//
// MessageText:
//
// The random number generator check test failed.
//
static const int FVE_E_FIPS_RNG_CHECK_FAILED = _HRESULT_TYPEDEF_(0x80310036L);
//
// MessageId: FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents a local recovery password from being generated or used by BitLocker Drive Encryption. When operating in FIPS-compliant mode, BitLocker recovery options can be either a recovery key stored on a USB drive or recovery through a data recovery agent.
//
static const int FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD = _HRESULT_TYPEDEF_(0x80310037L);
//
// MessageId: FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents the recovery password from being saved to Active Directory. When operating in FIPS-compliant mode, BitLocker recovery options can be either a recovery key stored on a USB drive or recovery through a data recovery agent. Check your Group Policy settings configuration.
//
static const int FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT = _HRESULT_TYPEDEF_(0x80310038L);
//
// MessageId: FVE_E_NOT_DECRYPTED
//
// MessageText:
//
// The drive must be fully decrypted to complete this operation.
//
static const int FVE_E_NOT_DECRYPTED = _HRESULT_TYPEDEF_(0x80310039L);
//
// MessageId: FVE_E_INVALID_PROTECTOR_TYPE
//
// MessageText:
//
// The key protector specified cannot be used for this operation.
//
static const int FVE_E_INVALID_PROTECTOR_TYPE = _HRESULT_TYPEDEF_(0x8031003AL);
//
// MessageId: FVE_E_NO_PROTECTORS_TO_TEST
//
// MessageText:
//
// No key protectors exist on the drive to perform the hardware test.
//
static const int FVE_E_NO_PROTECTORS_TO_TEST = _HRESULT_TYPEDEF_(0x8031003BL);
//
// MessageId: FVE_E_KEYFILE_NOT_FOUND
//
// MessageText:
//
// The BitLocker startup key or recovery password cannot be found on the USB device. Verify that you have the correct USB device, that the USB device is plugged into the computer on an active USB port, restart the computer, and then try again. If the problem persists, contact the computer manufacturer for BIOS upgrade instructions.
//
static const int FVE_E_KEYFILE_NOT_FOUND = _HRESULT_TYPEDEF_(0x8031003CL);
//
// MessageId: FVE_E_KEYFILE_INVALID
//
// MessageText:
//
// The BitLocker startup key or recovery password file provided is corrupt or invalid. Verify that you have the correct startup key or recovery password file and try again.
//
static const int FVE_E_KEYFILE_INVALID = _HRESULT_TYPEDEF_(0x8031003DL);
//
// MessageId: FVE_E_KEYFILE_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the startup key or recovery password. Verify that you have the correct startup key or recovery password and try again.
//
static const int FVE_E_KEYFILE_NO_VMK = _HRESULT_TYPEDEF_(0x8031003EL);
//
// MessageId: FVE_E_TPM_DISABLED
//
// MessageText:
//
// The Trusted Platform Module (TPM) is disabled. The TPM must be enabled, initialized, and have valid ownership before it can be used with BitLocker Drive Encryption.
//
static const int FVE_E_TPM_DISABLED = _HRESULT_TYPEDEF_(0x8031003FL);
//
// MessageId: FVE_E_NOT_ALLOWED_IN_SAFE_MODE
//
// MessageText:
//
// The BitLocker configuration of the specified drive cannot be managed because this computer is currently operating in Safe Mode. While in Safe Mode, BitLocker Drive Encryption can only be used for recovery purposes.
//
static const int FVE_E_NOT_ALLOWED_IN_SAFE_MODE = _HRESULT_TYPEDEF_(0x80310040L);
//
// MessageId: FVE_E_TPM_INVALID_PCR
//
// MessageText:
//
// The Trusted Platform Module (TPM) was not able to unlock the drive because the system boot information has changed or a PIN was not provided correctly. Verify that the drive has not been tampered with and that changes to the system boot information were caused by a trusted source. After verifying that the drive is safe to access, use the BitLocker recovery console to unlock the drive and then suspend and resume BitLocker to update system boot information that BitLocker associates with this drive.
//
static const int FVE_E_TPM_INVALID_PCR = _HRESULT_TYPEDEF_(0x80310041L);
//
// MessageId: FVE_E_TPM_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the Trusted Platform Module (TPM).
//
static const int FVE_E_TPM_NO_VMK = _HRESULT_TYPEDEF_(0x80310042L);
//
// MessageId: FVE_E_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the Trusted Platform Module (TPM) and PIN.
//
static const int FVE_E_PIN_INVALID = _HRESULT_TYPEDEF_(0x80310043L);
//
// MessageId: FVE_E_AUTH_INVALID_APPLICATION
//
// MessageText:
//
// A boot application has changed since BitLocker Drive Encryption was enabled.
//
static const int FVE_E_AUTH_INVALID_APPLICATION = _HRESULT_TYPEDEF_(0x80310044L);
//
// MessageId: FVE_E_AUTH_INVALID_CONFIG
//
// MessageText:
//
// The Boot Configuration Data (BCD) settings have changed since BitLocker Drive Encryption was enabled.
//
static const int FVE_E_AUTH_INVALID_CONFIG = _HRESULT_TYPEDEF_(0x80310045L);
//
// MessageId: FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prohibits the use of unencrypted keys, which prevents BitLocker from being suspended on this drive. Please contact your domain administrator for more information.
//
static const int FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310046L);
//
// MessageId: FVE_E_FS_NOT_EXTENDED
//
// MessageText:
//
// This drive cannot be encrypted by BitLocker Drive Encryption because the file system does not extend to the end of the drive. Repartition this drive and then try again.
//
static const int FVE_E_FS_NOT_EXTENDED = _HRESULT_TYPEDEF_(0x80310047L);
//
// MessageId: FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be enabled on the operating system drive. Contact the computer manufacturer for BIOS upgrade instructions.
//
static const int FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80310048L);
//
// MessageId: FVE_E_NO_LICENSE
//
// MessageText:
//
// This version of Windows does not include BitLocker Drive Encryption. To use BitLocker Drive Encryption, please upgrade the operating system.
//
static const int FVE_E_NO_LICENSE = _HRESULT_TYPEDEF_(0x80310049L);
//
// MessageId: FVE_E_NOT_ON_STACK
//
// MessageText:
//
// BitLocker Drive Encryption cannot be used because critical BitLocker system files are missing or corrupted. Use Windows Startup Repair to restore these files to your computer.
//
static const int FVE_E_NOT_ON_STACK = _HRESULT_TYPEDEF_(0x8031004AL);
//
// MessageId: FVE_E_FS_MOUNTED
//
// MessageText:
//
// The drive cannot be locked when the drive is in use.
//
static const int FVE_E_FS_MOUNTED = _HRESULT_TYPEDEF_(0x8031004BL);
//
// MessageId: FVE_E_TOKEN_NOT_IMPERSONATED
//
// MessageText:
//
// The access token associated with the current thread is not an impersonated token.
//
static const int FVE_E_TOKEN_NOT_IMPERSONATED = _HRESULT_TYPEDEF_(0x8031004CL);
//
// MessageId: FVE_E_DRY_RUN_FAILED
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained. Verify that the Trusted Platform Module (TPM) is enabled and ownership has been taken. If this computer does not have a TPM, verify that the USB drive is inserted and available.
//
static const int FVE_E_DRY_RUN_FAILED = _HRESULT_TYPEDEF_(0x8031004DL);
//
// MessageId: FVE_E_REBOOT_REQUIRED
//
// MessageText:
//
// You must restart your computer before continuing with BitLocker Drive Encryption.
//
static const int FVE_E_REBOOT_REQUIRED = _HRESULT_TYPEDEF_(0x8031004EL);
//
// MessageId: FVE_E_DEBUGGER_ENABLED
//
// MessageText:
//
// Drive encryption cannot occur while boot debugging is enabled. Use the bcdedit command-line tool to turn off boot debugging.
//
static const int FVE_E_DEBUGGER_ENABLED = _HRESULT_TYPEDEF_(0x8031004FL);
//
// MessageId: FVE_E_RAW_ACCESS
//
// MessageText:
//
// No action was taken as BitLocker Drive Encryption is in raw access mode.
//
static const int FVE_E_RAW_ACCESS = _HRESULT_TYPEDEF_(0x80310050L);
//
// MessageId: FVE_E_RAW_BLOCKED
//
// MessageText:
//
// BitLocker Drive Encryption cannot enter raw access mode for this drive because the drive is currently in use.
//
static const int FVE_E_RAW_BLOCKED = _HRESULT_TYPEDEF_(0x80310051L);
//
// MessageId: FVE_E_BCD_APPLICATIONS_PATH_INCORRECT
//
// MessageText:
//
// The path specified in the Boot Configuration Data (BCD) for a BitLocker Drive Encryption integrity-protected application is incorrect. Please verify and correct your BCD settings and try again.
//
static const int FVE_E_BCD_APPLICATIONS_PATH_INCORRECT = _HRESULT_TYPEDEF_(0x80310052L);
//
// MessageId: FVE_E_NOT_ALLOWED_IN_VERSION
//
// MessageText:
//
// BitLocker Drive Encryption can only be used for recovery purposes when the computer is running Windows Recovery Environment.
//
static const int FVE_E_NOT_ALLOWED_IN_VERSION = _HRESULT_TYPEDEF_(0x80310053L);
//
// MessageId: FVE_E_NO_AUTOUNLOCK_MASTER_KEY
//
// MessageText:
//
// The auto-unlock master key was not available from the operating system drive.
//
static const int FVE_E_NO_AUTOUNLOCK_MASTER_KEY = _HRESULT_TYPEDEF_(0x80310054L);
//
// MessageId: FVE_E_MOR_FAILED
//
// MessageText:
//
// The system firmware failed to enable clearing of system memory when the computer was restarted.
//
static const int FVE_E_MOR_FAILED = _HRESULT_TYPEDEF_(0x80310055L);
//
// MessageId: FVE_E_HIDDEN_VOLUME
//
// MessageText:
//
// The hidden drive cannot be encrypted.
//
static const int FVE_E_HIDDEN_VOLUME = _HRESULT_TYPEDEF_(0x80310056L);
//
// MessageId: FVE_E_TRANSIENT_STATE
//
// MessageText:
//
// BitLocker encryption keys were ignored because the drive was in a transient state.
//
static const int FVE_E_TRANSIENT_STATE = _HRESULT_TYPEDEF_(0x80310057L);
//
// MessageId: FVE_E_PUBKEY_NOT_ALLOWED
//
// MessageText:
//
// Public key based protectors are not allowed on this drive.
//
static const int FVE_E_PUBKEY_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310058L);
//
// MessageId: FVE_E_VOLUME_HANDLE_OPEN
//
// MessageText:
//
// BitLocker Drive Encryption is already performing an operation on this drive. Please complete all operations before continuing.
//
static const int FVE_E_VOLUME_HANDLE_OPEN = _HRESULT_TYPEDEF_(0x80310059L);
//
// MessageId: FVE_E_NO_FEATURE_LICENSE
//
// MessageText:
//
// This version of Windows does not support this feature of BitLocker Drive Encryption. To use this feature, upgrade the operating system..
//
static const int FVE_E_NO_FEATURE_LICENSE = _HRESULT_TYPEDEF_(0x8031005AL);
//
// MessageId: FVE_E_INVALID_STARTUP_OPTIONS
//
// MessageText:
//
// The Group Policy settings for BitLocker startup options are in conflict and cannot be applied. Contact your system administrator for more information.
//
static const int FVE_E_INVALID_STARTUP_OPTIONS = _HRESULT_TYPEDEF_(0x8031005BL);
//
// MessageId: FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a recovery password.
//
static const int FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x8031005CL);
//
// MessageId: FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a recovery password.
//
static const int FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED = _HRESULT_TYPEDEF_(0x8031005DL);
//
// MessageId: FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a recovery key.
//
static const int FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x8031005EL);
//
// MessageId: FVE_E_POLICY_RECOVERY_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a recovery key.
//
static const int FVE_E_POLICY_RECOVERY_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x8031005FL);
//
// MessageId: FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a PIN at startup. Please choose a different BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310060L);
//
// MessageId: FVE_E_POLICY_STARTUP_PIN_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a PIN at startup. Please choose this BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_PIN_REQUIRED = _HRESULT_TYPEDEF_(0x80310061L);
//
// MessageId: FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a startup key. Please choose a different BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310062L);
//
// MessageId: FVE_E_POLICY_STARTUP_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a startup key. Please choose this BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x80310063L);
//
// MessageId: FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a startup key and PIN. Please choose a different BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310064L);
//
// MessageId: FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a startup key and PIN. Please choose this BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x80310065L);
//
// MessageId: FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED
//
// MessageText:
//
// Group policy does not permit the use of TPM-only at startup. Please choose a different BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310066L);
//
// MessageId: FVE_E_POLICY_STARTUP_TPM_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of TPM-only at startup. Please choose this BitLocker startup option.
//
static const int FVE_E_POLICY_STARTUP_TPM_REQUIRED = _HRESULT_TYPEDEF_(0x80310067L);
//
// MessageId: FVE_E_POLICY_INVALID_PIN_LENGTH
//
// MessageText:
//
// The PIN provided does not meet minimum or maximum length requirements.
//
static const int FVE_E_POLICY_INVALID_PIN_LENGTH = _HRESULT_TYPEDEF_(0x80310068L);
//
// MessageId: FVE_E_KEY_PROTECTOR_NOT_SUPPORTED
//
// MessageText:
//
// The key protector is not supported by the version of BitLocker Drive Encryption currently on the drive. Upgrade the drive to add the key protector.
//
static const int FVE_E_KEY_PROTECTOR_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80310069L);
//
// MessageId: FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a password.
//
static const int FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x8031006AL);
//
// MessageId: FVE_E_POLICY_PASSPHRASE_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a password.
//
static const int FVE_E_POLICY_PASSPHRASE_REQUIRED = _HRESULT_TYPEDEF_(0x8031006BL);
//
// MessageId: FVE_E_FIPS_PREVENTS_PASSPHRASE
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents passwords from being generated or used. Please contact your system administrator for more information.
//
static const int FVE_E_FIPS_PREVENTS_PASSPHRASE = _HRESULT_TYPEDEF_(0x8031006CL);
//
// MessageId: FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED
//
// MessageText:
//
// A password cannot be added to the operating system drive.
//
static const int FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x8031006DL);
//
// MessageId: FVE_E_INVALID_BITLOCKER_OID
//
// MessageText:
//
// The BitLocker object identifier (OID) on the drive appears to be invalid or corrupt. Use manage-BDE to reset the OID on this drive.
//
static const int FVE_E_INVALID_BITLOCKER_OID = _HRESULT_TYPEDEF_(0x8031006EL);
//
// MessageId: FVE_E_VOLUME_TOO_SMALL
//
// MessageText:
//
// The drive is too small to be protected using BitLocker Drive Encryption.
//
static const int FVE_E_VOLUME_TOO_SMALL = _HRESULT_TYPEDEF_(0x8031006FL);
//
// MessageId: FVE_E_DV_NOT_SUPPORTED_ON_FS
//
// MessageText:
//
// The selected discovery drive type is incompatible with the file system on the drive. BitLocker To Go discovery drives must be created on FAT formatted drives.
//
static const int FVE_E_DV_NOT_SUPPORTED_ON_FS = _HRESULT_TYPEDEF_(0x80310070L);
//
// MessageId: FVE_E_DV_NOT_ALLOWED_BY_GP
//
// MessageText:
//
// The selected discovery drive type is not allowed by the computer's Group Policy settings. Verify that Group Policy settings allow the creation of discovery drives for use with BitLocker To Go.
//
static const int FVE_E_DV_NOT_ALLOWED_BY_GP = _HRESULT_TYPEDEF_(0x80310071L);
//
// MessageId: FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit user certificates such as smart cards to be used with BitLocker Drive Encryption.
//
static const int FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310072L);
//
// MessageId: FVE_E_POLICY_USER_CERTIFICATE_REQUIRED
//
// MessageText:
//
// Group Policy settings require that you have a valid user certificate, such as a smart card, to be used with BitLocker Drive Encryption.
//
static const int FVE_E_POLICY_USER_CERTIFICATE_REQUIRED = _HRESULT_TYPEDEF_(0x80310073L);
//
// MessageId: FVE_E_POLICY_USER_CERT_MUST_BE_HW
//
// MessageText:
//
// Group Policy settings requires that you use a smart card-based key protector with BitLocker Drive Encryption.
//
static const int FVE_E_POLICY_USER_CERT_MUST_BE_HW = _HRESULT_TYPEDEF_(0x80310074L);
//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit BitLocker-protected fixed data drives to be automatically unlocked.
//
static const int FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310075L);
//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit BitLocker-protected removable data drives to be automatically unlocked.
//
static const int FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310076L);
//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit you to configure BitLocker Drive Encryption on removable data drives.
//
static const int FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310077L);
//
// MessageId: FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit you to turn on BitLocker Drive Encryption on removable data drives. Please contact your system administrator if you need to turn on BitLocker.
//
static const int FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310078L);
//
// MessageId: FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit turning off BitLocker Drive Encryption on removable data drives. Please contact your system administrator if you need to turn off BitLocker.
//
static const int FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310079L);
//
// MessageId: FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH
//
// MessageText:
//
// Your password does not meet minimum password length requirements. By default, passwords must be at least 8 characters in length. Check with your system administrator for the password length requirement in your organization.
//
static const int FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH = _HRESULT_TYPEDEF_(0x80310080L);
//
// MessageId: FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE
//
// MessageText:
//
// Your password does not meet the complexity requirements set by your system administrator. Try adding upper and lowercase characters, numbers, and symbols.
//
static const int FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE = _HRESULT_TYPEDEF_(0x80310081L);
//
// MessageId: FVE_E_RECOVERY_PARTITION
//
// MessageText:
//
// This drive cannot be encrypted because it is reserved for Windows System Recovery Options.
//
static const int FVE_E_RECOVERY_PARTITION = _HRESULT_TYPEDEF_(0x80310082L);
//
// MessageId: FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because of conflicting Group Policy settings. BitLocker cannot be configured to automatically unlock fixed data drives when user recovery options are disabled. If you want BitLocker-protected fixed data drives to be automatically unlocked after key validation has occurred, please ask your system administrator to resolve the settings conflict before enabling BitLocker.
//
static const int FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON = _HRESULT_TYPEDEF_(0x80310083L);
//
// MessageId: FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because of conflicting Group Policy settings. BitLocker cannot be configured to automatically unlock removable data drives when user recovery option are disabled. If you want BitLocker-protected removable data drives to be automatically unlocked after key validation has occured, please ask your system administrator to resolve the settings conflict before enabling BitLocker.
//
static const int FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON = _HRESULT_TYPEDEF_(0x80310084L);
//
// MessageId: FVE_E_NON_BITLOCKER_OID
//
// MessageText:
//
// The Enhanced Key Usage (EKU) attribute of the specified certificate does not permit it to be used for BitLocker Drive Encryption. BitLocker does not require that a certificate have an EKU attribute, but if one is configured it must be set to an object identifier (OID) that matches the OID configured for BitLocker.
//
static const int FVE_E_NON_BITLOCKER_OID = _HRESULT_TYPEDEF_(0x80310085L);
//
// MessageId: FVE_E_POLICY_PROHIBITS_SELFSIGNED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive as currently configured because of Group Policy settings. The certificate you provided for drive encryption is self-signed. Current Group Policy settings do not permit the use of self-signed certificates. Obtain a new certificate from your certification authority before attempting to enable BitLocker.
//
static const int FVE_E_POLICY_PROHIBITS_SELFSIGNED = _HRESULT_TYPEDEF_(0x80310086L);
//
// MessageId: FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED
//
// MessageText:
//
// BitLocker Encryption cannot be applied to this drive because of conflicting Group Policy settings. When write access to drives not protected by BitLocker is denied, the use of a USB startup key cannot be required. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
static const int FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED = _HRESULT_TYPEDEF_(0x80310087L);
//
// MessageId: FVE_E_CONV_RECOVERY_FAILED
//
// MessageText:
//
// BitLocker Drive Encryption failed to recover from an abruptly terminated conversion. This could be due to either all conversion logs being corrupted or the media being write-protected.
//
static const int FVE_E_CONV_RECOVERY_FAILED = _HRESULT_TYPEDEF_(0x80310088L);
//
// MessageId: FVE_E_VIRTUALIZED_SPACE_TOO_BIG
//
// MessageText:
//
// The requested virtualization size is too big.
//
static const int FVE_E_VIRTUALIZED_SPACE_TOO_BIG = _HRESULT_TYPEDEF_(0x80310089L);
//
// MessageId: FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on operating system drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
static const int FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON = _HRESULT_TYPEDEF_(0x80310090L);
//
// MessageId: FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on fixed data drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
static const int FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON = _HRESULT_TYPEDEF_(0x80310091L);
//
// MessageId: FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on removable data drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
static const int FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON = _HRESULT_TYPEDEF_(0x80310092L);
//
// MessageId: FVE_E_NON_BITLOCKER_KU
//
// MessageText:
//
// The Key Usage (KU) attribute of the specified certificate does not permit it to be used for BitLocker Drive Encryption. BitLocker does not require that a certificate have a KU attribute, but if one is configured it must be set to either Key Encipherment or Key Agreement.
//
static const int FVE_E_NON_BITLOCKER_KU = _HRESULT_TYPEDEF_(0x80310093L);
//
// MessageId: FVE_E_PRIVATEKEY_AUTH_FAILED
//
// MessageText:
//
// The private key associated with the specified certificate cannot be authorized. The private key authorization was either not provided or the provided authorization was invalid.
//
static const int FVE_E_PRIVATEKEY_AUTH_FAILED = _HRESULT_TYPEDEF_(0x80310094L);
//
// MessageId: FVE_E_REMOVAL_OF_DRA_FAILED
//
// MessageText:
//
// Removal of the data recovery agent certificate must be done using the Certificates snap-in.
//
static const int FVE_E_REMOVAL_OF_DRA_FAILED = _HRESULT_TYPEDEF_(0x80310095L);
//
// MessageId: FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME
//
// MessageText:
//
// This drive was encrypted using the version of BitLocker Drive Encryption included with Windows Vista and Windows Server 2008 which does not support organizational identifiers. To specify organizational identifiers for this drive upgrade the drive encryption to the latest version using the "manage-bde -upgrade" command.
//
static const int FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME = _HRESULT_TYPEDEF_(0x80310096L);
//
// MessageId: FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME
//
// MessageText:
//
// The drive cannot be locked because it is automatically unlocked on this computer.  Remove the automatic unlock protector to lock this drive.
//
static const int FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME = _HRESULT_TYPEDEF_(0x80310097L);
//
// MessageId: FVE_E_FIPS_HASH_KDF_NOT_ALLOWED
//
// MessageText:
//
// The default BitLocker Key Derivation Function SP800-56A for ECC smart cards is not supported by your smart card. The Group Policy setting requiring FIPS-compliance prevents BitLocker from using any other key derivation function for encryption. You have to use a FIPS compliant smart card in FIPS restricted environments.
//
static const int FVE_E_FIPS_HASH_KDF_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80310098L);
//
// MessageId: FVE_E_ENH_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key could not be obtained from the Trusted Platform Module (TPM) and enhanced PIN. Try using a PIN containing only numerals.
//
static const int FVE_E_ENH_PIN_INVALID = _HRESULT_TYPEDEF_(0x80310099L);
//
// MessageId: FVE_E_INVALID_PIN_CHARS
//
// MessageText:
//
// The requested TPM PIN contains invalid characters.
//
static const int FVE_E_INVALID_PIN_CHARS = _HRESULT_TYPEDEF_(0x8031009AL);
//
// MessageId: FVE_E_INVALID_DATUM_TYPE
//
// MessageText:
//
// The management information stored on the drive contained an unknown type. If you are using an old version of Windows, try accessing the drive from the latest version.
//
static const int FVE_E_INVALID_DATUM_TYPE = _HRESULT_TYPEDEF_(0x8031009BL);
//
// =======================================================
// Windows Filtering Platform Error Messages
// =======================================================
//
//
// MessageId: FWP_E_CALLOUT_NOT_FOUND
//
// MessageText:
//
// The callout does not exist.
//
static const int FWP_E_CALLOUT_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320001L);
//
// MessageId: FWP_E_CONDITION_NOT_FOUND
//
// MessageText:
//
// The filter condition does not exist.
//
static const int FWP_E_CONDITION_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320002L);
//
// MessageId: FWP_E_FILTER_NOT_FOUND
//
// MessageText:
//
// The filter does not exist.
//
static const int FWP_E_FILTER_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320003L);
//
// MessageId: FWP_E_LAYER_NOT_FOUND
//
// MessageText:
//
// The layer does not exist.
//
static const int FWP_E_LAYER_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320004L);
//
// MessageId: FWP_E_PROVIDER_NOT_FOUND
//
// MessageText:
//
// The provider does not exist.
//
static const int FWP_E_PROVIDER_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320005L);
//
// MessageId: FWP_E_PROVIDER_CONTEXT_NOT_FOUND
//
// MessageText:
//
// The provider context does not exist.
//
static const int FWP_E_PROVIDER_CONTEXT_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320006L);
//
// MessageId: FWP_E_SUBLAYER_NOT_FOUND
//
// MessageText:
//
// The sublayer does not exist.
//
static const int FWP_E_SUBLAYER_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320007L);
//
// MessageId: FWP_E_NOT_FOUND
//
// MessageText:
//
// The object does not exist.
//
static const int FWP_E_NOT_FOUND = _HRESULT_TYPEDEF_(0x80320008L);
//
// MessageId: FWP_E_ALREADY_EXISTS
//
// MessageText:
//
// An object with that GUID or LUID already exists.
//
static const int FWP_E_ALREADY_EXISTS = _HRESULT_TYPEDEF_(0x80320009L);
//
// MessageId: FWP_E_IN_USE
//
// MessageText:
//
// The object is referenced by other objects so cannot be deleted.
//
static const int FWP_E_IN_USE = _HRESULT_TYPEDEF_(0x8032000AL);
//
// MessageId: FWP_E_DYNAMIC_SESSION_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within a dynamic session.
//
static const int FWP_E_DYNAMIC_SESSION_IN_PROGRESS = _HRESULT_TYPEDEF_(0x8032000BL);
//
// MessageId: FWP_E_WRONG_SESSION
//
// MessageText:
//
// The call was made from the wrong session so cannot be completed.
//
static const int FWP_E_WRONG_SESSION = _HRESULT_TYPEDEF_(0x8032000CL);
//
// MessageId: FWP_E_NO_TXN_IN_PROGRESS
//
// MessageText:
//
// The call must be made from within an explicit transaction.
//
static const int FWP_E_NO_TXN_IN_PROGRESS = _HRESULT_TYPEDEF_(0x8032000DL);
//
// MessageId: FWP_E_TXN_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within an explicit transaction.
//
static const int FWP_E_TXN_IN_PROGRESS = _HRESULT_TYPEDEF_(0x8032000EL);
//
// MessageId: FWP_E_TXN_ABORTED
//
// MessageText:
//
// The explicit transaction has been forcibly cancelled.
//
static const int FWP_E_TXN_ABORTED = _HRESULT_TYPEDEF_(0x8032000FL);
//
// MessageId: FWP_E_SESSION_ABORTED
//
// MessageText:
//
// The session has been cancelled.
//
static const int FWP_E_SESSION_ABORTED = _HRESULT_TYPEDEF_(0x80320010L);
//
// MessageId: FWP_E_INCOMPATIBLE_TXN
//
// MessageText:
//
// The call is not allowed from within a read-only transaction.
//
static const int FWP_E_INCOMPATIBLE_TXN = _HRESULT_TYPEDEF_(0x80320011L);
//
// MessageId: FWP_E_TIMEOUT
//
// MessageText:
//
// The call timed out while waiting to acquire the transaction lock.
//
static const int FWP_E_TIMEOUT = _HRESULT_TYPEDEF_(0x80320012L);
//
// MessageId: FWP_E_NET_EVENTS_DISABLED
//
// MessageText:
//
// Collection of network diagnostic events is disabled.
//
static const int FWP_E_NET_EVENTS_DISABLED = _HRESULT_TYPEDEF_(0x80320013L);
//
// MessageId: FWP_E_INCOMPATIBLE_LAYER
//
// MessageText:
//
// The operation is not supported by the specified layer.
//
static const int FWP_E_INCOMPATIBLE_LAYER = _HRESULT_TYPEDEF_(0x80320014L);
//
// MessageId: FWP_E_KM_CLIENTS_ONLY
//
// MessageText:
//
// The call is allowed for kernel-mode callers only.
//
static const int FWP_E_KM_CLIENTS_ONLY = _HRESULT_TYPEDEF_(0x80320015L);
//
// MessageId: FWP_E_LIFETIME_MISMATCH
//
// MessageText:
//
// The call tried to associate two objects with incompatible lifetimes.
//
static const int FWP_E_LIFETIME_MISMATCH = _HRESULT_TYPEDEF_(0x80320016L);
//
// MessageId: FWP_E_BUILTIN_OBJECT
//
// MessageText:
//
// The object is built in so cannot be deleted.
//
static const int FWP_E_BUILTIN_OBJECT = _HRESULT_TYPEDEF_(0x80320017L);
//
// MessageId: FWP_E_TOO_MANY_CALLOUTS
//
// MessageText:
//
// The maximum number of callouts has been reached.
//
static const int FWP_E_TOO_MANY_CALLOUTS = _HRESULT_TYPEDEF_(0x80320018L);
//
// MessageId: FWP_E_NOTIFICATION_DROPPED
//
// MessageText:
//
// A notification could not be delivered because a message queue is at its maximum capacity.
//
static const int FWP_E_NOTIFICATION_DROPPED = _HRESULT_TYPEDEF_(0x80320019L);
//
// MessageId: FWP_E_TRAFFIC_MISMATCH
//
// MessageText:
//
// The traffic parameters do not match those for the security association context.
//
static const int FWP_E_TRAFFIC_MISMATCH = _HRESULT_TYPEDEF_(0x8032001AL);
//
// MessageId: FWP_E_INCOMPATIBLE_SA_STATE
//
// MessageText:
//
// The call is not allowed for the current security association state.
//
static const int FWP_E_INCOMPATIBLE_SA_STATE = _HRESULT_TYPEDEF_(0x8032001BL);
//
// MessageId: FWP_E_NULL_POINTER
//
// MessageText:
//
// A required pointer is null.
//
static const int FWP_E_NULL_POINTER = _HRESULT_TYPEDEF_(0x8032001CL);
//
// MessageId: FWP_E_INVALID_ENUMERATOR
//
// MessageText:
//
// An enumerator is not valid.
//
static const int FWP_E_INVALID_ENUMERATOR = _HRESULT_TYPEDEF_(0x8032001DL);
//
// MessageId: FWP_E_INVALID_FLAGS
//
// MessageText:
//
// The flags field contains an invalid value.
//
static const int FWP_E_INVALID_FLAGS = _HRESULT_TYPEDEF_(0x8032001EL);
//
// MessageId: FWP_E_INVALID_NET_MASK
//
// MessageText:
//
// A network mask is not valid.
//
static const int FWP_E_INVALID_NET_MASK = _HRESULT_TYPEDEF_(0x8032001FL);
//
// MessageId: FWP_E_INVALID_RANGE
//
// MessageText:
//
// An FWP_RANGE is not valid.
//
static const int FWP_E_INVALID_RANGE = _HRESULT_TYPEDEF_(0x80320020L);
//
// MessageId: FWP_E_INVALID_INTERVAL
//
// MessageText:
//
// The time interval is not valid.
//
static const int FWP_E_INVALID_INTERVAL = _HRESULT_TYPEDEF_(0x80320021L);
//
// MessageId: FWP_E_ZERO_LENGTH_ARRAY
//
// MessageText:
//
// An array that must contain at least one element is zero length.
//
static const int FWP_E_ZERO_LENGTH_ARRAY = _HRESULT_TYPEDEF_(0x80320022L);
//
// MessageId: FWP_E_NULL_DISPLAY_NAME
//
// MessageText:
//
// The displayData.name field cannot be null.
//
static const int FWP_E_NULL_DISPLAY_NAME = _HRESULT_TYPEDEF_(0x80320023L);
//
// MessageId: FWP_E_INVALID_ACTION_TYPE
//
// MessageText:
//
// The action type is not one of the allowed action types for a filter.
//
static const int FWP_E_INVALID_ACTION_TYPE = _HRESULT_TYPEDEF_(0x80320024L);
//
// MessageId: FWP_E_INVALID_WEIGHT
//
// MessageText:
//
// The filter weight is not valid.
//
static const int FWP_E_INVALID_WEIGHT = _HRESULT_TYPEDEF_(0x80320025L);
//
// MessageId: FWP_E_MATCH_TYPE_MISMATCH
//
// MessageText:
//
// A filter condition contains a match type that is not compatible with the operands.
//
static const int FWP_E_MATCH_TYPE_MISMATCH = _HRESULT_TYPEDEF_(0x80320026L);
//
// MessageId: FWP_E_TYPE_MISMATCH
//
// MessageText:
//
// An FWP_VALUE or FWPM_CONDITION_VALUE is of the wrong type.
//
static const int FWP_E_TYPE_MISMATCH = _HRESULT_TYPEDEF_(0x80320027L);
//
// MessageId: FWP_E_OUT_OF_BOUNDS
//
// MessageText:
//
// An integer value is outside the allowed range.
//
static const int FWP_E_OUT_OF_BOUNDS = _HRESULT_TYPEDEF_(0x80320028L);
//
// MessageId: FWP_E_RESERVED
//
// MessageText:
//
// A reserved field is non-zero.
//
static const int FWP_E_RESERVED = _HRESULT_TYPEDEF_(0x80320029L);
//
// MessageId: FWP_E_DUPLICATE_CONDITION
//
// MessageText:
//
// A filter cannot contain multiple conditions operating on a single field.
//
static const int FWP_E_DUPLICATE_CONDITION = _HRESULT_TYPEDEF_(0x8032002AL);
//
// MessageId: FWP_E_DUPLICATE_KEYMOD
//
// MessageText:
//
// A policy cannot contain the same keying module more than once.
//
static const int FWP_E_DUPLICATE_KEYMOD = _HRESULT_TYPEDEF_(0x8032002BL);
//
// MessageId: FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The action type is not compatible with the layer.
//
static const int FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER = _HRESULT_TYPEDEF_(0x8032002CL);
//
// MessageId: FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER
//
// MessageText:
//
// The action type is not compatible with the sublayer.
//
static const int FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER = _HRESULT_TYPEDEF_(0x8032002DL);
//
// MessageId: FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The raw context or the provider context is not compatible with the layer.
//
static const int FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER = _HRESULT_TYPEDEF_(0x8032002EL);
//
// MessageId: FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT
//
// MessageText:
//
// The raw context or the provider context is not compatible with the callout.
//
static const int FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = _HRESULT_TYPEDEF_(0x8032002FL);
//
// MessageId: FWP_E_INCOMPATIBLE_AUTH_METHOD
//
// MessageText:
//
// The authentication method is not compatible with the policy type.
//
static const int FWP_E_INCOMPATIBLE_AUTH_METHOD = _HRESULT_TYPEDEF_(0x80320030L);
//
// MessageId: FWP_E_INCOMPATIBLE_DH_GROUP
//
// MessageText:
//
// The Diffie-Hellman group is not compatible with the policy type.
//
static const int FWP_E_INCOMPATIBLE_DH_GROUP = _HRESULT_TYPEDEF_(0x80320031L);
//
// MessageId: FWP_E_EM_NOT_SUPPORTED
//
// MessageText:
//
// An IKE policy cannot contain an Extended Mode policy.
//
static const int FWP_E_EM_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80320032L);
//
// MessageId: FWP_E_NEVER_MATCH
//
// MessageText:
//
// The enumeration template or subscription will never match any objects.
//
static const int FWP_E_NEVER_MATCH = _HRESULT_TYPEDEF_(0x80320033L);
//
// MessageId: FWP_E_PROVIDER_CONTEXT_MISMATCH
//
// MessageText:
//
// The provider context is of the wrong type.
//
static const int FWP_E_PROVIDER_CONTEXT_MISMATCH = _HRESULT_TYPEDEF_(0x80320034L);
//
// MessageId: FWP_E_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
static const int FWP_E_INVALID_PARAMETER = _HRESULT_TYPEDEF_(0x80320035L);
//
// MessageId: FWP_E_TOO_MANY_SUBLAYERS
//
// MessageText:
//
// The maximum number of sublayers has been reached.
//
static const int FWP_E_TOO_MANY_SUBLAYERS = _HRESULT_TYPEDEF_(0x80320036L);
//
// MessageId: FWP_E_CALLOUT_NOTIFICATION_FAILED
//
// MessageText:
//
// The notification function for a callout returned an error.
//
static const int FWP_E_CALLOUT_NOTIFICATION_FAILED = _HRESULT_TYPEDEF_(0x80320037L);
//
// MessageId: FWP_E_INVALID_AUTH_TRANSFORM
//
// MessageText:
//
// The IPsec authentication transform is not valid.
//
static const int FWP_E_INVALID_AUTH_TRANSFORM = _HRESULT_TYPEDEF_(0x80320038L);
//
// MessageId: FWP_E_INVALID_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not valid.
//
static const int FWP_E_INVALID_CIPHER_TRANSFORM = _HRESULT_TYPEDEF_(0x80320039L);
//
// MessageId: FWP_E_DROP_NOICMP
//
// MessageText:
//
// The packet should be dropped, no ICMP should be sent.
//
static const int FWP_E_DROP_NOICMP = _HRESULT_TYPEDEF_(0x80320104L);
//
// MessageId: FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not compatible with the policy.
//
static const int FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM = _HRESULT_TYPEDEF_(0x8032003AL);
//
// MessageId: FWP_E_INVALID_TRANSFORM_COMBINATION
//
// MessageText:
//
// The combination of IPsec transform types is not valid.
//
static const int FWP_E_INVALID_TRANSFORM_COMBINATION = _HRESULT_TYPEDEF_(0x8032003BL);
//
// MessageId: FWP_E_DUPLICATE_AUTH_METHOD
//
// MessageText:
//
// A policy cannot contain the same auth method more than once.
//
static const int FWP_E_DUPLICATE_AUTH_METHOD = _HRESULT_TYPEDEF_(0x8032003CL);
///////////////////////////////////////////////////
//                                               //
//       Web Services Platform Error Codes       //
//                                               //
///////////////////////////////////////////////////
//
// MessageId: WS_S_ASYNC
//
// MessageText:
//
// The function call is completing asynchronously.
//
static const int WS_S_ASYNC = _HRESULT_TYPEDEF_(0x003D0000L);
//
// MessageId: WS_S_END
//
// MessageText:
//
// There are no more messages available on the channel.
//
static const int WS_S_END = _HRESULT_TYPEDEF_(0x003D0001L);
//
// MessageId: WS_E_INVALID_FORMAT
//
// MessageText:
//
// The input data was not in the expected format or did not have the expected value.
//
static const int WS_E_INVALID_FORMAT = _HRESULT_TYPEDEF_(0x803D0000L);
//
// MessageId: WS_E_OBJECT_FAULTED
//
// MessageText:
//
// The operation could not be completed because the object is in a faulted state due to a previous error.
//
static const int WS_E_OBJECT_FAULTED = _HRESULT_TYPEDEF_(0x803D0001L);
//
// MessageId: WS_E_NUMERIC_OVERFLOW
//
// MessageText:
//
// The operation could not be completed because it would lead to numeric overflow.
//
static const int WS_E_NUMERIC_OVERFLOW = _HRESULT_TYPEDEF_(0x803D0002L);
//
// MessageId: WS_E_INVALID_OPERATION
//
// MessageText:
//
// The operation is not allowed due to the current state of the object.
//
static const int WS_E_INVALID_OPERATION = _HRESULT_TYPEDEF_(0x803D0003L);
//
// MessageId: WS_E_OPERATION_ABORTED
//
// MessageText:
//
// The operation was aborted.
//
static const int WS_E_OPERATION_ABORTED = _HRESULT_TYPEDEF_(0x803D0004L);
//
// MessageId: WS_E_ENDPOINT_ACCESS_DENIED
//
// MessageText:
//
// Access was denied by the remote endpoint.
//
static const int WS_E_ENDPOINT_ACCESS_DENIED = _HRESULT_TYPEDEF_(0x803D0005L);
//
// MessageId: WS_E_OPERATION_TIMED_OUT
//
// MessageText:
//
// The operation did not complete within the time allotted.
//
static const int WS_E_OPERATION_TIMED_OUT = _HRESULT_TYPEDEF_(0x803D0006L);
//
// MessageId: WS_E_OPERATION_ABANDONED
//
// MessageText:
//
// The operation was abandoned.
//
static const int WS_E_OPERATION_ABANDONED = _HRESULT_TYPEDEF_(0x803D0007L);
//
// MessageId: WS_E_QUOTA_EXCEEDED
//
// MessageText:
//
// A quota was exceeded.
//
static const int WS_E_QUOTA_EXCEEDED = _HRESULT_TYPEDEF_(0x803D0008L);
//
// MessageId: WS_E_NO_TRANSLATION_AVAILABLE
//
// MessageText:
//
// The information was not available in the specified language.
//
static const int WS_E_NO_TRANSLATION_AVAILABLE = _HRESULT_TYPEDEF_(0x803D0009L);
//
// MessageId: WS_E_SECURITY_VERIFICATION_FAILURE
//
// MessageText:
//
// Security verification was not successful for the received data.
//
static const int WS_E_SECURITY_VERIFICATION_FAILURE = _HRESULT_TYPEDEF_(0x803D000AL);
//
// MessageId: WS_E_ADDRESS_IN_USE
//
// MessageText:
//
// The address is already being used.
//
static const int WS_E_ADDRESS_IN_USE = _HRESULT_TYPEDEF_(0x803D000BL);
//
// MessageId: WS_E_ADDRESS_NOT_AVAILABLE
//
// MessageText:
//
// The address is not valid for this context.
//
static const int WS_E_ADDRESS_NOT_AVAILABLE = _HRESULT_TYPEDEF_(0x803D000CL);
//
// MessageId: WS_E_ENDPOINT_NOT_FOUND
//
// MessageText:
//
// The remote endpoint does not exist or could not be located.
//
static const int WS_E_ENDPOINT_NOT_FOUND = _HRESULT_TYPEDEF_(0x803D000DL);
//
// MessageId: WS_E_ENDPOINT_NOT_AVAILABLE
//
// MessageText:
//
// The remote endpoint is not currently in service at this location.
//
static const int WS_E_ENDPOINT_NOT_AVAILABLE = _HRESULT_TYPEDEF_(0x803D000EL);
//
// MessageId: WS_E_ENDPOINT_FAILURE
//
// MessageText:
//
// The remote endpoint could not process the request.
//
static const int WS_E_ENDPOINT_FAILURE = _HRESULT_TYPEDEF_(0x803D000FL);
//
// MessageId: WS_E_ENDPOINT_UNREACHABLE
//
// MessageText:
//
// The remote endpoint was not reachable.
//
static const int WS_E_ENDPOINT_UNREACHABLE = _HRESULT_TYPEDEF_(0x803D0010L);
//
// MessageId: WS_E_ENDPOINT_ACTION_NOT_SUPPORTED
//
// MessageText:
//
// The operation was not supported by the remote endpoint.
//
static const int WS_E_ENDPOINT_ACTION_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x803D0011L);
//
// MessageId: WS_E_ENDPOINT_TOO_BUSY
//
// MessageText:
//
// The remote endpoint is unable to process the request due to being overloaded.
//
static const int WS_E_ENDPOINT_TOO_BUSY = _HRESULT_TYPEDEF_(0x803D0012L);
//
// MessageId: WS_E_ENDPOINT_FAULT_RECEIVED
//
// MessageText:
//
// A message containing a fault was received from the remote endpoint.
//
static const int WS_E_ENDPOINT_FAULT_RECEIVED = _HRESULT_TYPEDEF_(0x803D0013L);
//
// MessageId: WS_E_ENDPOINT_DISCONNECTED
//
// MessageText:
//
// The connection with the remote endpoint was terminated.
//
static const int WS_E_ENDPOINT_DISCONNECTED = _HRESULT_TYPEDEF_(0x803D0014L);
//
// MessageId: WS_E_PROXY_FAILURE
//
// MessageText:
//
// The HTTP proxy server could not process the request.
//
static const int WS_E_PROXY_FAILURE = _HRESULT_TYPEDEF_(0x803D0015L);
//
// MessageId: WS_E_PROXY_ACCESS_DENIED
//
// MessageText:
//
// Access was denied by the HTTP proxy server.
//
static const int WS_E_PROXY_ACCESS_DENIED = _HRESULT_TYPEDEF_(0x803D0016L);
//
// MessageId: WS_E_NOT_SUPPORTED
//
// MessageText:
//
// The requested feature is not available on this platform.
//
static const int WS_E_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x803D0017L);
//
// MessageId: WS_E_PROXY_REQUIRES_BASIC_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'basic'.
//
static const int WS_E_PROXY_REQUIRES_BASIC_AUTH = _HRESULT_TYPEDEF_(0x803D0018L);
//
// MessageId: WS_E_PROXY_REQUIRES_DIGEST_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'digest'.
//
static const int WS_E_PROXY_REQUIRES_DIGEST_AUTH = _HRESULT_TYPEDEF_(0x803D0019L);
//
// MessageId: WS_E_PROXY_REQUIRES_NTLM_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'NTLM'.
//
static const int WS_E_PROXY_REQUIRES_NTLM_AUTH = _HRESULT_TYPEDEF_(0x803D001AL);
//
// MessageId: WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'negotiate'.
//
static const int WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH = _HRESULT_TYPEDEF_(0x803D001BL);
//
// MessageId: WS_E_SERVER_REQUIRES_BASIC_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'basic'.
//
static const int WS_E_SERVER_REQUIRES_BASIC_AUTH = _HRESULT_TYPEDEF_(0x803D001CL);
//
// MessageId: WS_E_SERVER_REQUIRES_DIGEST_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'digest'.
//
static const int WS_E_SERVER_REQUIRES_DIGEST_AUTH = _HRESULT_TYPEDEF_(0x803D001DL);
//
// MessageId: WS_E_SERVER_REQUIRES_NTLM_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'NTLM'.
//
static const int WS_E_SERVER_REQUIRES_NTLM_AUTH = _HRESULT_TYPEDEF_(0x803D001EL);
//
// MessageId: WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'negotiate'.
//
static const int WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH = _HRESULT_TYPEDEF_(0x803D001FL);
//
// MessageId: WS_E_INVALID_ENDPOINT_URL
//
// MessageText:
//
// The endpoint address URL is invalid.
//
static const int WS_E_INVALID_ENDPOINT_URL = _HRESULT_TYPEDEF_(0x803D0020L);
//
// MessageId: WS_E_OTHER
//
// MessageText:
//
// Unrecognized error occured in the Windows Web Services framework.
//
static const int WS_E_OTHER = _HRESULT_TYPEDEF_(0x803D0021L);
//
// MessageId: WS_E_SECURITY_TOKEN_EXPIRED
//
// MessageText:
//
// A security token was rejected by the server because it has expired.
//
static const int WS_E_SECURITY_TOKEN_EXPIRED = _HRESULT_TYPEDEF_(0x803D0022L);
//
// MessageId: WS_E_SECURITY_SYSTEM_FAILURE
//
// MessageText:
//
// A security operation failed in the Windows Web Services framework.
//
static const int WS_E_SECURITY_SYSTEM_FAILURE = _HRESULT_TYPEDEF_(0x803D0023L);
//
// NDIS error codes (ndis.sys)
//
static const int _NDIS_ERROR_TYPEDEF_(_sc) = (DWORD)(_sc);
//
// MessageId: ERROR_NDIS_INTERFACE_CLOSING
//
// MessageText:
//
// The binding to the network interface is being closed.
//
static const int ERROR_NDIS_INTERFACE_CLOSING = _NDIS_ERROR_TYPEDEF_(0x80340002L);
//
// MessageId: ERROR_NDIS_BAD_VERSION
//
// MessageText:
//
// An invalid version was specified.
//
static const int ERROR_NDIS_BAD_VERSION = _NDIS_ERROR_TYPEDEF_(0x80340004L);
//
// MessageId: ERROR_NDIS_BAD_CHARACTERISTICS
//
// MessageText:
//
// An invalid characteristics table was used.
//
static const int ERROR_NDIS_BAD_CHARACTERISTICS = _NDIS_ERROR_TYPEDEF_(0x80340005L);
//
// MessageId: ERROR_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
// Failed to find the network interface or network interface is not ready.
//
static const int ERROR_NDIS_ADAPTER_NOT_FOUND = _NDIS_ERROR_TYPEDEF_(0x80340006L);
//
// MessageId: ERROR_NDIS_OPEN_FAILED
//
// MessageText:
//
// Failed to open the network interface.
//
static const int ERROR_NDIS_OPEN_FAILED = _NDIS_ERROR_TYPEDEF_(0x80340007L);
//
// MessageId: ERROR_NDIS_DEVICE_FAILED
//
// MessageText:
//
// Network interface has encountered an internal unrecoverable failure.
//
static const int ERROR_NDIS_DEVICE_FAILED = _NDIS_ERROR_TYPEDEF_(0x80340008L);
//
// MessageId: ERROR_NDIS_MULTICAST_FULL
//
// MessageText:
//
// The multicast list on the network interface is full.
//
static const int ERROR_NDIS_MULTICAST_FULL = _NDIS_ERROR_TYPEDEF_(0x80340009L);
//
// MessageId: ERROR_NDIS_MULTICAST_EXISTS
//
// MessageText:
//
// An attempt was made to add a duplicate multicast address to the list.
//
static const int ERROR_NDIS_MULTICAST_EXISTS = _NDIS_ERROR_TYPEDEF_(0x8034000AL);
//
// MessageId: ERROR_NDIS_MULTICAST_NOT_FOUND
//
// MessageText:
//
// At attempt was made to remove a multicast address that was never added.
//
static const int ERROR_NDIS_MULTICAST_NOT_FOUND = _NDIS_ERROR_TYPEDEF_(0x8034000BL);
//
// MessageId: ERROR_NDIS_REQUEST_ABORTED
//
// MessageText:
//
// Netowork interface aborted the request.
//
static const int ERROR_NDIS_REQUEST_ABORTED = _NDIS_ERROR_TYPEDEF_(0x8034000CL);
//
// MessageId: ERROR_NDIS_RESET_IN_PROGRESS
//
// MessageText:
//
// Network interface can not process the request because it is being reset.
//
static const int ERROR_NDIS_RESET_IN_PROGRESS = _NDIS_ERROR_TYPEDEF_(0x8034000DL);
//
// MessageId: ERROR_NDIS_NOT_SUPPORTED
//
// MessageText:
//
// Netword interface does not support this request.
//
static const int ERROR_NDIS_NOT_SUPPORTED = _NDIS_ERROR_TYPEDEF_(0x803400BBL);
//
// MessageId: ERROR_NDIS_INVALID_PACKET
//
// MessageText:
//
// An attempt was made to send an invalid packet on a network interface.
//
static const int ERROR_NDIS_INVALID_PACKET = _NDIS_ERROR_TYPEDEF_(0x8034000FL);
//
// MessageId: ERROR_NDIS_ADAPTER_NOT_READY
//
// MessageText:
//
// Network interface is not ready to complete this operation.
//
static const int ERROR_NDIS_ADAPTER_NOT_READY = _NDIS_ERROR_TYPEDEF_(0x80340011L);
//
// MessageId: ERROR_NDIS_INVALID_LENGTH
//
// MessageText:
//
// The length of the buffer submitted for this operation is not valid.
//
static const int ERROR_NDIS_INVALID_LENGTH = _NDIS_ERROR_TYPEDEF_(0x80340014L);
//
// MessageId: ERROR_NDIS_INVALID_DATA
//
// MessageText:
//
// The data used for this operation is not valid.
//
static const int ERROR_NDIS_INVALID_DATA = _NDIS_ERROR_TYPEDEF_(0x80340015L);
//
// MessageId: ERROR_NDIS_BUFFER_TOO_SHORT
//
// MessageText:
//
// The length of buffer submitted for this operation is too small.
//
static const int ERROR_NDIS_BUFFER_TOO_SHORT = _NDIS_ERROR_TYPEDEF_(0x80340016L);
//
// MessageId: ERROR_NDIS_INVALID_OID
//
// MessageText:
//
// Network interface does not support this OID (Object Identifier)
//
static const int ERROR_NDIS_INVALID_OID = _NDIS_ERROR_TYPEDEF_(0x80340017L);
//
// MessageId: ERROR_NDIS_ADAPTER_REMOVED
//
// MessageText:
//
// The network interface has been removed.
//
static const int ERROR_NDIS_ADAPTER_REMOVED = _NDIS_ERROR_TYPEDEF_(0x80340018L);
//
// MessageId: ERROR_NDIS_UNSUPPORTED_MEDIA
//
// MessageText:
//
// Network interface does not support this media type.
//
static const int ERROR_NDIS_UNSUPPORTED_MEDIA = _NDIS_ERROR_TYPEDEF_(0x80340019L);
//
// MessageId: ERROR_NDIS_GROUP_ADDRESS_IN_USE
//
// MessageText:
//
// An attempt was made to remove a token ring group address that is in use by other components.
//
static const int ERROR_NDIS_GROUP_ADDRESS_IN_USE = _NDIS_ERROR_TYPEDEF_(0x8034001AL);
//
// MessageId: ERROR_NDIS_FILE_NOT_FOUND
//
// MessageText:
//
// An attempt was made to map a file that can not be found.
//
static const int ERROR_NDIS_FILE_NOT_FOUND = _NDIS_ERROR_TYPEDEF_(0x8034001BL);
//
// MessageId: ERROR_NDIS_ERROR_READING_FILE
//
// MessageText:
//
// An error occured while NDIS tried to map the file.
//
static const int ERROR_NDIS_ERROR_READING_FILE = _NDIS_ERROR_TYPEDEF_(0x8034001CL);
//
// MessageId: ERROR_NDIS_ALREADY_MAPPED
//
// MessageText:
//
// An attempt was made to map a file that is alreay mapped.
//
static const int ERROR_NDIS_ALREADY_MAPPED = _NDIS_ERROR_TYPEDEF_(0x8034001DL);
//
// MessageId: ERROR_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
// An attempt to allocate a hardware resource failed because the resource is used by another component.
//
static const int ERROR_NDIS_RESOURCE_CONFLICT = _NDIS_ERROR_TYPEDEF_(0x8034001EL);
//
// MessageId: ERROR_NDIS_MEDIA_DISCONNECTED
//
// MessageText:
//
// The I/O operation failed because network media is disconnected or wireless access point is out of range.
//
static const int ERROR_NDIS_MEDIA_DISCONNECTED = _NDIS_ERROR_TYPEDEF_(0x8034001FL);
//
// MessageId: ERROR_NDIS_INVALID_ADDRESS
//
// MessageText:
//
// The network address used in the request is invalid.
//
static const int ERROR_NDIS_INVALID_ADDRESS = _NDIS_ERROR_TYPEDEF_(0x80340022L);
//
// MessageId: ERROR_NDIS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
// The specified request is not a valid operation for the target device.
//
static const int ERROR_NDIS_INVALID_DEVICE_REQUEST = _NDIS_ERROR_TYPEDEF_(0x80340010L);
//
// MessageId: ERROR_NDIS_PAUSED
//
// MessageText:
//
// The offload operation on the network interface has been paused.
//
static const int ERROR_NDIS_PAUSED = _NDIS_ERROR_TYPEDEF_(0x8034002AL);
//
// MessageId: ERROR_NDIS_INTERFACE_NOT_FOUND
//
// MessageText:
//
// Network interface was not found.
//
static const int ERROR_NDIS_INTERFACE_NOT_FOUND = _NDIS_ERROR_TYPEDEF_(0x8034002BL);
//
// MessageId: ERROR_NDIS_UNSUPPORTED_REVISION
//
// MessageText:
//
// The revision number specified in the structure is not supported.
//
static const int ERROR_NDIS_UNSUPPORTED_REVISION = _NDIS_ERROR_TYPEDEF_(0x8034002CL);
//
// MessageId: ERROR_NDIS_INVALID_PORT
//
// MessageText:
//
// The specified port does not exist on this network interface.
//
static const int ERROR_NDIS_INVALID_PORT = _NDIS_ERROR_TYPEDEF_(0x8034002DL);
//
// MessageId: ERROR_NDIS_INVALID_PORT_STATE
//
// MessageText:
//
// The current state of the specified port on this network interface does not support the requested operation.
//
static const int ERROR_NDIS_INVALID_PORT_STATE = _NDIS_ERROR_TYPEDEF_(0x8034002EL);
//
// MessageId: ERROR_NDIS_LOW_POWER_STATE
//
// MessageText:
//
// The miniport adapter is in low power state.
//
static const int ERROR_NDIS_LOW_POWER_STATE = _NDIS_ERROR_TYPEDEF_(0x8034002FL);
//
// NDIS error codes (802.11 wireless LAN)
//
//
// MessageId: ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED
//
// MessageText:
//
// The wireless local area network interface is in auto configuration mode and doesn't support the requested parameter change operation.
//
static const int ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED = _NDIS_ERROR_TYPEDEF_(0x80342000L);
//
// MessageId: ERROR_NDIS_DOT11_MEDIA_IN_USE
//
// MessageText:
//
// The wireless local area network interface is busy and can not perform the requested operation.
//
static const int ERROR_NDIS_DOT11_MEDIA_IN_USE = _NDIS_ERROR_TYPEDEF_(0x80342001L);
//
// MessageId: ERROR_NDIS_DOT11_POWER_STATE_INVALID
//
// MessageText:
//
// The wireless local area network interface is power down and doesn't support the requested operation.
//
static const int ERROR_NDIS_DOT11_POWER_STATE_INVALID = _NDIS_ERROR_TYPEDEF_(0x80342002L);
//
// MessageId: ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL
//
// MessageText:
//
// The list of wake on LAN patterns is full.
//
static const int ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL = _NDIS_ERROR_TYPEDEF_(0x80342003L);
//
// MessageId: ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL
//
// MessageText:
//
// The list of low power protocol offloads is full.
//
static const int ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = _NDIS_ERROR_TYPEDEF_(0x80342004L);
//
// NDIS informational code (ndis.sys)
//
//
// MessageId: ERROR_NDIS_INDICATION_REQUIRED
//
// MessageText:
//
// The request will be completed later by NDIS status indication.
//
static const int ERROR_NDIS_INDICATION_REQUIRED = _NDIS_ERROR_TYPEDEF_(0x00340001L);
//
// NDIS Chimney Offload codes (ndis.sys)
//
//
// MessageId: ERROR_NDIS_OFFLOAD_POLICY
//
// MessageText:
//
// The TCP connection is not offloadable because of a local policy setting.
//
static const int ERROR_NDIS_OFFLOAD_POLICY = _NDIS_ERROR_TYPEDEF_(0xC034100FL);
//
// MessageId: ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED
//
// MessageText:
//
// The TCP connection is not offloadable by the Chimney Offload target.
//
static const int ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED = _NDIS_ERROR_TYPEDEF_(0xC0341012L);
//
// MessageId: ERROR_NDIS_OFFLOAD_PATH_REJECTED
//
// MessageText:
//
// The IP Path object is not in an offloadable state.
//
static const int ERROR_NDIS_OFFLOAD_PATH_REJECTED = _NDIS_ERROR_TYPEDEF_(0xC0341013L);
//
// Hypervisor error codes
//
//
// MessageId: ERROR_HV_INVALID_HYPERCALL_CODE
//
// MessageText:
//
// The hypervisor does not support the operation because the specified hypercall code is not supported.
//
static const int ERROR_HV_INVALID_HYPERCALL_CODE = _NDIS_ERROR_TYPEDEF_(0xC0350002L);
//
// MessageId: ERROR_HV_INVALID_HYPERCALL_INPUT
//
// MessageText:
//
// The hypervisor does not support the operation because the encoding for the hypercall input register is not supported.
//
static const int ERROR_HV_INVALID_HYPERCALL_INPUT = _NDIS_ERROR_TYPEDEF_(0xC0350003L);
//
// MessageId: ERROR_HV_INVALID_ALIGNMENT
//
// MessageText:
//
// The hypervisor could not perform the operation beacuse a parameter has an invalid alignment.
//
static const int ERROR_HV_INVALID_ALIGNMENT = _NDIS_ERROR_TYPEDEF_(0xC0350004L);
//
// MessageId: ERROR_HV_INVALID_PARAMETER
//
// MessageText:
//
// The hypervisor could not perform the operation beacuse an invalid parameter was specified.
//
static const int ERROR_HV_INVALID_PARAMETER = _NDIS_ERROR_TYPEDEF_(0xC0350005L);
//
// MessageId: ERROR_HV_ACCESS_DENIED
//
// MessageText:
//
// Access to the specified object was denied.
//
static const int ERROR_HV_ACCESS_DENIED = _NDIS_ERROR_TYPEDEF_(0xC0350006L);
//
// MessageId: ERROR_HV_INVALID_PARTITION_STATE
//
// MessageText:
//
// The hypervisor could not perform the operation because the partition is entering or in an invalid state.
//
static const int ERROR_HV_INVALID_PARTITION_STATE = _NDIS_ERROR_TYPEDEF_(0xC0350007L);
//
// MessageId: ERROR_HV_OPERATION_DENIED
//
// MessageText:
//
// The operation is not allowed in the current state.
//
static const int ERROR_HV_OPERATION_DENIED = _NDIS_ERROR_TYPEDEF_(0xC0350008L);
//
// MessageId: ERROR_HV_UNKNOWN_PROPERTY
//
// MessageText:
//
// The hypervisor does not recognize the specified partition property.
//
static const int ERROR_HV_UNKNOWN_PROPERTY = _NDIS_ERROR_TYPEDEF_(0xC0350009L);
//
// MessageId: ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The specified value of a partition property is out of range or violates an invariant.
//
static const int ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE = _NDIS_ERROR_TYPEDEF_(0xC035000AL);
//
// MessageId: ERROR_HV_INSUFFICIENT_MEMORY
//
// MessageText:
//
// There is not enough memory in the hypervisor pool to complete the operation.
//
static const int ERROR_HV_INSUFFICIENT_MEMORY = _NDIS_ERROR_TYPEDEF_(0xC035000BL);
//
// MessageId: ERROR_HV_PARTITION_TOO_DEEP
//
// MessageText:
//
// The maximum partition depth has been exceeded for the partition hierarchy.
//
static const int ERROR_HV_PARTITION_TOO_DEEP = _NDIS_ERROR_TYPEDEF_(0xC035000CL);
//
// MessageId: ERROR_HV_INVALID_PARTITION_ID
//
// MessageText:
//
// A partition with the specified partition Id does not exist.
//
static const int ERROR_HV_INVALID_PARTITION_ID = _NDIS_ERROR_TYPEDEF_(0xC035000DL);
//
// MessageId: ERROR_HV_INVALID_VP_INDEX
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified VP index is invalid.
//
static const int ERROR_HV_INVALID_VP_INDEX = _NDIS_ERROR_TYPEDEF_(0xC035000EL);
//
// MessageId: ERROR_HV_INVALID_PORT_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified port identifier is invalid.
//
static const int ERROR_HV_INVALID_PORT_ID = _NDIS_ERROR_TYPEDEF_(0xC0350011L);
//
// MessageId: ERROR_HV_INVALID_CONNECTION_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified connection identifier is invalid.
//
static const int ERROR_HV_INVALID_CONNECTION_ID = _NDIS_ERROR_TYPEDEF_(0xC0350012L);
//
// MessageId: ERROR_HV_INSUFFICIENT_BUFFERS
//
// MessageText:
//
// Not enough buffers were supplied to send a message.
//
static const int ERROR_HV_INSUFFICIENT_BUFFERS = _NDIS_ERROR_TYPEDEF_(0xC0350013L);
//
// MessageId: ERROR_HV_NOT_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has not been acknowledged.
//
static const int ERROR_HV_NOT_ACKNOWLEDGED = _NDIS_ERROR_TYPEDEF_(0xC0350014L);
//
// MessageId: ERROR_HV_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has already been acknowledged.
//
static const int ERROR_HV_ACKNOWLEDGED = _NDIS_ERROR_TYPEDEF_(0xC0350016L);
//
// MessageId: ERROR_HV_INVALID_SAVE_RESTORE_STATE
//
// MessageText:
//
// The indicated partition is not in a valid state for saving or restoring.
//
static const int ERROR_HV_INVALID_SAVE_RESTORE_STATE = _NDIS_ERROR_TYPEDEF_(0xC0350017L);
//
// MessageId: ERROR_HV_INVALID_SYNIC_STATE
//
// MessageText:
//
// The hypervisor could not complete the operation because a required feature of the synthetic interrupt controller (SynIC) was disabled.
//
static const int ERROR_HV_INVALID_SYNIC_STATE = _NDIS_ERROR_TYPEDEF_(0xC0350018L);
//
// MessageId: ERROR_HV_OBJECT_IN_USE
//
// MessageText:
//
// The hypervisor could not perform the operation because the object or value was either already in use or being used for a purpose that would not permit completing the operation.
//
static const int ERROR_HV_OBJECT_IN_USE = _NDIS_ERROR_TYPEDEF_(0xC0350019L);
//
// MessageId: ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO
//
// MessageText:
//
// The proximity domain information is invalid.
//
static const int ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO = _NDIS_ERROR_TYPEDEF_(0xC035001AL);
//
// MessageId: ERROR_HV_NO_DATA
//
// MessageText:
//
// An attempt to retrieve debugging data failed because none was available.
//
static const int ERROR_HV_NO_DATA = _NDIS_ERROR_TYPEDEF_(0xC035001BL);
//
// MessageId: ERROR_HV_INACTIVE
//
// MessageText:
//
// The physical connection being used for debuggging has not recorded any receive activity since the last operation.
//
static const int ERROR_HV_INACTIVE = _NDIS_ERROR_TYPEDEF_(0xC035001CL);
//
// MessageId: ERROR_HV_NO_RESOURCES
//
// MessageText:
//
// There are not enough resources to complete the operation.
//
static const int ERROR_HV_NO_RESOURCES = _NDIS_ERROR_TYPEDEF_(0xC035001DL);
//
// MessageId: ERROR_HV_FEATURE_UNAVAILABLE
//
// MessageText:
//
// A hypervisor feature is not available to the user.
//
static const int ERROR_HV_FEATURE_UNAVAILABLE = _NDIS_ERROR_TYPEDEF_(0xC035001EL);
//
// MessageId: ERROR_HV_NOT_PRESENT
//
// MessageText:
//
// No hypervisor is present on this system.
//
static const int ERROR_HV_NOT_PRESENT = _NDIS_ERROR_TYPEDEF_(0xC0351000L);
//
// Virtualization error codes - these codes are used by the Virtualization Infrustructure Driver (VID) and other components
//                              of the virtualization stack.
//
// Errors:
//
//
// MessageId: ERROR_VID_DUPLICATE_HANDLER
//
// MessageText:
//
// The handler for the virtualization infrastructure driver is already registered. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_DUPLICATE_HANDLER = _NDIS_ERROR_TYPEDEF_(0xC0370001L);
//
// MessageId: ERROR_VID_TOO_MANY_HANDLERS
//
// MessageText:
//
// The number of registered handlers for the virtualization infrastructure driver exceeded the maximum. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_TOO_MANY_HANDLERS = _NDIS_ERROR_TYPEDEF_(0xC0370002L);
//
// MessageId: ERROR_VID_QUEUE_FULL
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver is full and cannot accept new messages. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_QUEUE_FULL = _NDIS_ERROR_TYPEDEF_(0xC0370003L);
//
// MessageId: ERROR_VID_HANDLER_NOT_PRESENT
//
// MessageText:
//
// No handler exists to handle the message for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_HANDLER_NOT_PRESENT = _NDIS_ERROR_TYPEDEF_(0xC0370004L);
//
// MessageId: ERROR_VID_INVALID_OBJECT_NAME
//
// MessageText:
//
// The name of the partition or message queue for the virtualization infrastructure driver is invalid. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_INVALID_OBJECT_NAME = _NDIS_ERROR_TYPEDEF_(0xC0370005L);
//
// MessageId: ERROR_VID_PARTITION_NAME_TOO_LONG
//
// MessageText:
//
// The partition name of the virtualization infrastructure driver exceeds the maximum.
//
static const int ERROR_VID_PARTITION_NAME_TOO_LONG = _NDIS_ERROR_TYPEDEF_(0xC0370006L);
//
// MessageId: ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG
//
// MessageText:
//
// The message queue name of the virtualization infrastructure driver exceeds the maximum.
//
static const int ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG = _NDIS_ERROR_TYPEDEF_(0xC0370007L);
//
// MessageId: ERROR_VID_PARTITION_ALREADY_EXISTS
//
// MessageText:
//
// Cannot create the partition for the virtualization infrastructure driver because another partition with the same name already exists.
//
static const int ERROR_VID_PARTITION_ALREADY_EXISTS = _NDIS_ERROR_TYPEDEF_(0xC0370008L);
//
// MessageId: ERROR_VID_PARTITION_DOES_NOT_EXIST
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. The requested partition does not exist. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_PARTITION_DOES_NOT_EXIST = _NDIS_ERROR_TYPEDEF_(0xC0370009L);
//
// MessageId: ERROR_VID_PARTITION_NAME_NOT_FOUND
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. Could not find the requested partition. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_PARTITION_NAME_NOT_FOUND = _NDIS_ERROR_TYPEDEF_(0xC037000AL);
//
// MessageId: ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS
//
// MessageText:
//
// A message queue with the same name already exists for the virtualization infrastructure driver.
//
static const int ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS = _NDIS_ERROR_TYPEDEF_(0xC037000BL);
//
// MessageId: ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT
//
// MessageText:
//
// The memory block page for the virtualization infrastructure driver cannot be mapped because the page map limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = _NDIS_ERROR_TYPEDEF_(0xC037000CL);
//
// MessageId: ERROR_VID_MB_STILL_REFERENCED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is still being used and cannot be destroyed.
//
static const int ERROR_VID_MB_STILL_REFERENCED = _NDIS_ERROR_TYPEDEF_(0xC037000DL);
//
// MessageId: ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED
//
// MessageText:
//
// Cannot unlock the page array for the guest operating system memory address because it does not match a previous lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED = _NDIS_ERROR_TYPEDEF_(0xC037000EL);
//
// MessageId: ERROR_VID_INVALID_NUMA_SETTINGS
//
// MessageText:
//
// The non-uniform memory access (NUMA) node settings do not match the system NUMA topology. In order to start the virtual machine, you will need to modify the NUMA configuration. For detailed information, see http://go.microsoft.com/fwlink/?LinkId=92362.
//
static const int ERROR_VID_INVALID_NUMA_SETTINGS = _NDIS_ERROR_TYPEDEF_(0xC037000FL);
//
// MessageId: ERROR_VID_INVALID_NUMA_NODE_INDEX
//
// MessageText:
//
// The non-uniform memory access (NUMA) node index does not match a valid index in the system NUMA topology.
//
static const int ERROR_VID_INVALID_NUMA_NODE_INDEX = _NDIS_ERROR_TYPEDEF_(0xC0370010L);
//
// MessageId: ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is already associated with a message queue.
//
static const int ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = _NDIS_ERROR_TYPEDEF_(0xC0370011L);
//
// MessageId: ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE
//
// MessageText:
//
// The handle is not a valid memory block handle for the virtualization infrastructure driver.
//
static const int ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE = _NDIS_ERROR_TYPEDEF_(0xC0370012L);
//
// MessageId: ERROR_VID_PAGE_RANGE_OVERFLOW
//
// MessageText:
//
// The request exceeded the memory block page limit for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_PAGE_RANGE_OVERFLOW = _NDIS_ERROR_TYPEDEF_(0xC0370013L);
//
// MessageId: ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE
//
// MessageText:
//
// The handle is not a valid message queue handle for the virtualization infrastructure driver.
//
static const int ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE = _NDIS_ERROR_TYPEDEF_(0xC0370014L);
//
// MessageId: ERROR_VID_INVALID_GPA_RANGE_HANDLE
//
// MessageText:
//
// The handle is not a valid page range handle for the virtualization infrastructure driver.
//
static const int ERROR_VID_INVALID_GPA_RANGE_HANDLE = _NDIS_ERROR_TYPEDEF_(0xC0370015L);
//
// MessageId: ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE
//
// MessageText:
//
// Cannot install client notifications because no message queue for the virtualization infrastructure driver is associated with the memory block.
//
static const int ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = _NDIS_ERROR_TYPEDEF_(0xC0370016L);
//
// MessageId: ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED
//
// MessageText:
//
// The request to lock or map a memory block page failed because the virtualization infrastructure driver memory block limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = _NDIS_ERROR_TYPEDEF_(0xC0370017L);
//
// MessageId: ERROR_VID_INVALID_PPM_HANDLE
//
// MessageText:
//
// The handle is not a valid parent partition mapping handle for the virtualization infrastructure driver.
//
static const int ERROR_VID_INVALID_PPM_HANDLE = _NDIS_ERROR_TYPEDEF_(0xC0370018L);
//
// MessageId: ERROR_VID_MBPS_ARE_LOCKED
//
// MessageText:
//
// Notifications cannot be created on the memory block because it is use.
//
static const int ERROR_VID_MBPS_ARE_LOCKED = _NDIS_ERROR_TYPEDEF_(0xC0370019L);
//
// MessageId: ERROR_VID_MESSAGE_QUEUE_CLOSED
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver has been closed. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_MESSAGE_QUEUE_CLOSED = _NDIS_ERROR_TYPEDEF_(0xC037001AL);
//
// MessageId: ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED
//
// MessageText:
//
// Cannot add a virtual processor to the partition because the maximum has been reached.
//
static const int ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = _NDIS_ERROR_TYPEDEF_(0xC037001BL);
//
// MessageId: ERROR_VID_STOP_PENDING
//
// MessageText:
//
// Cannot stop the virtual processor immediately because of a pending intercept.
//
static const int ERROR_VID_STOP_PENDING = _NDIS_ERROR_TYPEDEF_(0xC037001CL);
//
// MessageId: ERROR_VID_INVALID_PROCESSOR_STATE
//
// MessageText:
//
// Invalid state for the virtual processor. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_INVALID_PROCESSOR_STATE = _NDIS_ERROR_TYPEDEF_(0xC037001DL);
//
// MessageId: ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT
//
// MessageText:
//
// The maximum number of kernel mode clients for the virtualization infrastructure driver has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = _NDIS_ERROR_TYPEDEF_(0xC037001EL);
//
// MessageId: ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED
//
// MessageText:
//
// This kernel mode interface for the virtualization infrastructure driver has already been initialized. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED = _NDIS_ERROR_TYPEDEF_(0xC037001FL);
//
// MessageId: ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET
//
// MessageText:
//
// Cannot set or reset the memory block property more than once for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET = _NDIS_ERROR_TYPEDEF_(0xC0370020L);
//
// MessageId: ERROR_VID_MMIO_RANGE_DESTROYED
//
// MessageText:
//
// The memory mapped I/O for this page range no longer exists. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_MMIO_RANGE_DESTROYED = _NDIS_ERROR_TYPEDEF_(0xC0370021L);
//
// MessageId: ERROR_VID_INVALID_CHILD_GPA_PAGE_SET
//
// MessageText:
//
// The lock or unlock request uses an invalid guest operating system memory address. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_INVALID_CHILD_GPA_PAGE_SET = _NDIS_ERROR_TYPEDEF_(0xC0370022L);
//
// MessageId: ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED
//
// MessageText:
//
// Cannot destroy or reuse the reserve page set for the virtualization infrastructure driver because it is in use. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED = _NDIS_ERROR_TYPEDEF_(0xC0370023L);
//
// MessageId: ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL
//
// MessageText:
//
// The reserve page set for the virtualization infrastructure driver is too small to use in the lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL = _NDIS_ERROR_TYPEDEF_(0xC0370024L);
//
// MessageId: ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE
//
// MessageText:
//
// Cannot lock or map the memory block page for the virtualization infrastructure driver because it has already been locked using a reserve page set page. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = _NDIS_ERROR_TYPEDEF_(0xC0370025L);
//
// MessageId: ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT
//
// MessageText:
//
// Cannot create the memory block for the virtualization infrastructure driver because the requested number of pages exceeded the limit. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
static const int ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT = _NDIS_ERROR_TYPEDEF_(0xC0370026L);
//
// MessageId: ERROR_VID_SAVED_STATE_CORRUPT
//
// MessageText:
//
// Cannot restore this virtual machine because the saved state data cannot be read. Delete the saved state data and then try to start the virtual machine.
//
static const int ERROR_VID_SAVED_STATE_CORRUPT = _NDIS_ERROR_TYPEDEF_(0xC0370027L);
//
// MessageId: ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM
//
// MessageText:
//
// Cannot restore this virtual machine because an item read from the saved state data is not recognized. Delete the saved state data and then try to start the virtual machine.
//
static const int ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM = _NDIS_ERROR_TYPEDEF_(0xC0370028L);
//
// MessageId: ERROR_VID_SAVED_STATE_INCOMPATIBLE
//
// MessageText:
//
// Cannot restore this virtual machine to the saved state because of hypervisor incompatibility. Delete the saved state data and then try to start the virtual machine.
//
static const int ERROR_VID_SAVED_STATE_INCOMPATIBLE = _NDIS_ERROR_TYPEDEF_(0xC0370029L);
//
// Warnings:
//
//
// MessageId: ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED
//
// MessageText:
//
// A virtual machine is running with its memory allocated across multiple NUMA nodes. This does not indicate a problem unless the performance of your virtual machine is unusually slow. If you are experiencing performance problems, you may need to modify the NUMA configuration. For detailed information, see http://go.microsoft.com/fwlink/?LinkId=92362.
//
static const int ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED = _NDIS_ERROR_TYPEDEF_(0x80370001L);
//
// Volume manager error codes mapped from status codes
//
//
// WARNINGS
//
//
// MessageId: ERROR_VOLMGR_INCOMPLETE_REGENERATION
//
// MessageText:
//
// The regeneration operation was not able to copy all data from the active plexes due to bad sectors.
//
static const int ERROR_VOLMGR_INCOMPLETE_REGENERATION = _NDIS_ERROR_TYPEDEF_(0x80380001L);
//
// MessageId: ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION
//
// MessageText:
//
// One or more disks were not fully migrated to the target pack. They may or may not require reimport after fixing the hardware problems.
//
static const int ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION = _NDIS_ERROR_TYPEDEF_(0x80380002L);
//
// ERRORS
//
//
// MessageId: ERROR_VOLMGR_DATABASE_FULL
//
// MessageText:
//
// The configuration database is full.
//
static const int ERROR_VOLMGR_DATABASE_FULL = _NDIS_ERROR_TYPEDEF_(0xC0380001L);
//
// MessageId: ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED
//
// MessageText:
//
// The configuration data on the disk is corrupted.
//
static const int ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED = _NDIS_ERROR_TYPEDEF_(0xC0380002L);
//
// MessageId: ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC
//
// MessageText:
//
// The configuration on the disk is not insync with the in-memory configuration.
//
static const int ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = _NDIS_ERROR_TYPEDEF_(0xC0380003L);
//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED
//
// MessageText:
//
// A majority of disks failed to be updated with the new configuration.
//
static const int ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED = _NDIS_ERROR_TYPEDEF_(0xC0380004L);
//
// MessageId: ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME
//
// MessageText:
//
// The disk contains non-simple volumes.
//
static const int ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = _NDIS_ERROR_TYPEDEF_(0xC0380005L);
//
// MessageId: ERROR_VOLMGR_DISK_DUPLICATE
//
// MessageText:
//
// The same disk was specified more than once in the migration list.
//
static const int ERROR_VOLMGR_DISK_DUPLICATE = _NDIS_ERROR_TYPEDEF_(0xC0380006L);
//
// MessageId: ERROR_VOLMGR_DISK_DYNAMIC
//
// MessageText:
//
// The disk is already dynamic.
//
static const int ERROR_VOLMGR_DISK_DYNAMIC = _NDIS_ERROR_TYPEDEF_(0xC0380007L);
//
// MessageId: ERROR_VOLMGR_DISK_ID_INVALID
//
// MessageText:
//
// The specified disk id is invalid. There are no disks with the specified disk id.
//
static const int ERROR_VOLMGR_DISK_ID_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380008L);
//
// MessageId: ERROR_VOLMGR_DISK_INVALID
//
// MessageText:
//
// The specified disk is an invalid disk. Operation cannot complete on an invalid disk.
//
static const int ERROR_VOLMGR_DISK_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380009L);
//
// MessageId: ERROR_VOLMGR_DISK_LAST_VOTER
//
// MessageText:
//
// The specified disk(s) cannot be removed since it is the last remaining voter.
//
static const int ERROR_VOLMGR_DISK_LAST_VOTER = _NDIS_ERROR_TYPEDEF_(0xC038000AL);
//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_INVALID
//
// MessageText:
//
// The specified disk has an invalid disk layout.
//
static const int ERROR_VOLMGR_DISK_LAYOUT_INVALID = _NDIS_ERROR_TYPEDEF_(0xC038000BL);
//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS
//
// MessageText:
//
// The disk layout contains non-basic partitions which appear after basic paritions. This is an invalid disk layout.
//
static const int ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = _NDIS_ERROR_TYPEDEF_(0xC038000CL);
//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED
//
// MessageText:
//
// The disk layout contains partitions which are not cylinder aligned.
//
static const int ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = _NDIS_ERROR_TYPEDEF_(0xC038000DL);
//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL
//
// MessageText:
//
// The disk layout contains partitions which are samller than the minimum size.
//
static const int ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = _NDIS_ERROR_TYPEDEF_(0xC038000EL);
//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS
//
// MessageText:
//
// The disk layout contains primary partitions in between logical drives. This is an invalid disk layout.
//
static const int ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = _NDIS_ERROR_TYPEDEF_(0xC038000FL);
//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS
//
// MessageText:
//
// The disk layout contains more than the maximum number of supported partitions.
//
static const int ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = _NDIS_ERROR_TYPEDEF_(0xC0380010L);
//
// MessageId: ERROR_VOLMGR_DISK_MISSING
//
// MessageText:
//
// The specified disk is missing. The operation cannot complete on a missing disk.
//
static const int ERROR_VOLMGR_DISK_MISSING = _NDIS_ERROR_TYPEDEF_(0xC0380011L);
//
// MessageId: ERROR_VOLMGR_DISK_NOT_EMPTY
//
// MessageText:
//
// The specified disk is not empty.
//
static const int ERROR_VOLMGR_DISK_NOT_EMPTY = _NDIS_ERROR_TYPEDEF_(0xC0380012L);
//
// MessageId: ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough usable space for this operation.
//
static const int ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE = _NDIS_ERROR_TYPEDEF_(0xC0380013L);
//
// MessageId: ERROR_VOLMGR_DISK_REVECTORING_FAILED
//
// MessageText:
//
// The force revectoring of bad sectors failed.
//
static const int ERROR_VOLMGR_DISK_REVECTORING_FAILED = _NDIS_ERROR_TYPEDEF_(0xC0380014L);
//
// MessageId: ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID
//
// MessageText:
//
// The specified disk has an invalid sector size.
//
static const int ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380015L);
//
// MessageId: ERROR_VOLMGR_DISK_SET_NOT_CONTAINED
//
// MessageText:
//
// The specified disk set contains volumes which exist on disks outside of the set.
//
static const int ERROR_VOLMGR_DISK_SET_NOT_CONTAINED = _NDIS_ERROR_TYPEDEF_(0xC0380016L);
//
// MessageId: ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one member of a plex.
//
static const int ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = _NDIS_ERROR_TYPEDEF_(0xC0380017L);
//
// MessageId: ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one plex.
//
static const int ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = _NDIS_ERROR_TYPEDEF_(0xC0380018L);
//
// MessageId: ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED
//
// MessageText:
//
// Dynamic disks are not supported on this system.
//
static const int ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = _NDIS_ERROR_TYPEDEF_(0xC0380019L);
//
// MessageId: ERROR_VOLMGR_EXTENT_ALREADY_USED
//
// MessageText:
//
// The specified extent is already used by other volumes.
//
static const int ERROR_VOLMGR_EXTENT_ALREADY_USED = _NDIS_ERROR_TYPEDEF_(0xC038001AL);
//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS
//
// MessageText:
//
// The specified volume is retained and can only be extended into a contiguous extent. The specified extent to grow the volume is not contiguous with the specified volume.
//
static const int ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS = _NDIS_ERROR_TYPEDEF_(0xC038001BL);
//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION
//
// MessageText:
//
// The specified volume extent is not within the public region of the disk.
//
static const int ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = _NDIS_ERROR_TYPEDEF_(0xC038001CL);
//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED
//
// MessageText:
//
// The specifed volume extent is not sector aligned.
//
static const int ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = _NDIS_ERROR_TYPEDEF_(0xC038001DL);
//
// MessageId: ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION
//
// MessageText:
//
// The specified parition overlaps an EBR (the first track of an extended partition on a MBR disks).
//
static const int ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = _NDIS_ERROR_TYPEDEF_(0xC038001EL);
//
// MessageId: ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH
//
// MessageText:
//
// The specified extent lengths cannot be used to construct a volume with specified length.
//
static const int ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = _NDIS_ERROR_TYPEDEF_(0xC038001FL);
//
// MessageId: ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support fault tolerant volumes.
//
static const int ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = _NDIS_ERROR_TYPEDEF_(0xC0380020L);
//
// MessageId: ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID
//
// MessageText:
//
// The specified interleave length is invalid.
//
static const int ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380021L);
//
// MessageId: ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS
//
// MessageText:
//
// There is already a maximum number of registered users.
//
static const int ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS = _NDIS_ERROR_TYPEDEF_(0xC0380022L);
//
// MessageId: ERROR_VOLMGR_MEMBER_IN_SYNC
//
// MessageText:
//
// The specified member is already in-sync with the other active members. It does not need to be regenerated.
//
static const int ERROR_VOLMGR_MEMBER_IN_SYNC = _NDIS_ERROR_TYPEDEF_(0xC0380023L);
//
// MessageId: ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE
//
// MessageText:
//
// The same member index was specified more than once.
//
static const int ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE = _NDIS_ERROR_TYPEDEF_(0xC0380024L);
//
// MessageId: ERROR_VOLMGR_MEMBER_INDEX_INVALID
//
// MessageText:
//
// The specified member index is greater or equal than the number of members in the volume plex.
//
static const int ERROR_VOLMGR_MEMBER_INDEX_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380025L);
//
// MessageId: ERROR_VOLMGR_MEMBER_MISSING
//
// MessageText:
//
// The specified member is missing. It cannot be regenerated.
//
static const int ERROR_VOLMGR_MEMBER_MISSING = _NDIS_ERROR_TYPEDEF_(0xC0380026L);
//
// MessageId: ERROR_VOLMGR_MEMBER_NOT_DETACHED
//
// MessageText:
//
// The specified member is not detached. Cannot replace a member which is not detached.
//
static const int ERROR_VOLMGR_MEMBER_NOT_DETACHED = _NDIS_ERROR_TYPEDEF_(0xC0380027L);
//
// MessageId: ERROR_VOLMGR_MEMBER_REGENERATING
//
// MessageText:
//
// The specified member is already regenerating.
//
static const int ERROR_VOLMGR_MEMBER_REGENERATING = _NDIS_ERROR_TYPEDEF_(0xC0380028L);
//
// MessageId: ERROR_VOLMGR_ALL_DISKS_FAILED
//
// MessageText:
//
// All disks belonging to the pack failed.
//
static const int ERROR_VOLMGR_ALL_DISKS_FAILED = _NDIS_ERROR_TYPEDEF_(0xC0380029L);
//
// MessageId: ERROR_VOLMGR_NO_REGISTERED_USERS
//
// MessageText:
//
// There are currently no registered users for notifications. The task number is irrelevant unless there are registered users.
//
static const int ERROR_VOLMGR_NO_REGISTERED_USERS = _NDIS_ERROR_TYPEDEF_(0xC038002AL);
//
// MessageId: ERROR_VOLMGR_NO_SUCH_USER
//
// MessageText:
//
// The specified notification user does not exist. Failed to unregister user for notifications.
//
static const int ERROR_VOLMGR_NO_SUCH_USER = _NDIS_ERROR_TYPEDEF_(0xC038002BL);
//
// MessageId: ERROR_VOLMGR_NOTIFICATION_RESET
//
// MessageText:
//
// The notifications have been reset. Notifications for the current user are invalid. Unregister and re-register for notifications.
//
static const int ERROR_VOLMGR_NOTIFICATION_RESET = _NDIS_ERROR_TYPEDEF_(0xC038002CL);
//
// MessageId: ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID
//
// MessageText:
//
// The specified number of members is invalid.
//
static const int ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID = _NDIS_ERROR_TYPEDEF_(0xC038002DL);
//
// MessageId: ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID
//
// MessageText:
//
// The specified number of plexes is invalid.
//
static const int ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID = _NDIS_ERROR_TYPEDEF_(0xC038002EL);
//
// MessageId: ERROR_VOLMGR_PACK_DUPLICATE
//
// MessageText:
//
// The specified source and target packs are identical.
//
static const int ERROR_VOLMGR_PACK_DUPLICATE = _NDIS_ERROR_TYPEDEF_(0xC038002FL);
//
// MessageId: ERROR_VOLMGR_PACK_ID_INVALID
//
// MessageText:
//
// The specified pack id is invalid. There are no packs with the specified pack id.
//
static const int ERROR_VOLMGR_PACK_ID_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380030L);
//
// MessageId: ERROR_VOLMGR_PACK_INVALID
//
// MessageText:
//
// The specified pack is the invalid pack. The operation cannot complete with the invalid pack.
//
static const int ERROR_VOLMGR_PACK_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380031L);
//
// MessageId: ERROR_VOLMGR_PACK_NAME_INVALID
//
// MessageText:
//
// The specified pack name is invalid.
//
static const int ERROR_VOLMGR_PACK_NAME_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380032L);
//
// MessageId: ERROR_VOLMGR_PACK_OFFLINE
//
// MessageText:
//
// The specified pack is offline.
//
static const int ERROR_VOLMGR_PACK_OFFLINE = _NDIS_ERROR_TYPEDEF_(0xC0380033L);
//
// MessageId: ERROR_VOLMGR_PACK_HAS_QUORUM
//
// MessageText:
//
// The specified pack already has a quorum of healthy disks.
//
static const int ERROR_VOLMGR_PACK_HAS_QUORUM = _NDIS_ERROR_TYPEDEF_(0xC0380034L);
//
// MessageId: ERROR_VOLMGR_PACK_WITHOUT_QUORUM
//
// MessageText:
//
// The pack does not have a quorum of healthy disks.
//
static const int ERROR_VOLMGR_PACK_WITHOUT_QUORUM = _NDIS_ERROR_TYPEDEF_(0xC0380035L);
//
// MessageId: ERROR_VOLMGR_PARTITION_STYLE_INVALID
//
// MessageText:
//
// The specified disk has an unsupported partition style. Only MBR and GPT partition styles are supported.
//
static const int ERROR_VOLMGR_PARTITION_STYLE_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380036L);
//
// MessageId: ERROR_VOLMGR_PARTITION_UPDATE_FAILED
//
// MessageText:
//
// Failed to update the disk's partition layout.
//
static const int ERROR_VOLMGR_PARTITION_UPDATE_FAILED = _NDIS_ERROR_TYPEDEF_(0xC0380037L);
//
// MessageId: ERROR_VOLMGR_PLEX_IN_SYNC
//
// MessageText:
//
// The specified plex is already in-sync with the other active plexes. It does not need to be regenerated.
//
static const int ERROR_VOLMGR_PLEX_IN_SYNC = _NDIS_ERROR_TYPEDEF_(0xC0380038L);
//
// MessageId: ERROR_VOLMGR_PLEX_INDEX_DUPLICATE
//
// MessageText:
//
// The same plex index was specified more than once.
//
static const int ERROR_VOLMGR_PLEX_INDEX_DUPLICATE = _NDIS_ERROR_TYPEDEF_(0xC0380039L);
//
// MessageId: ERROR_VOLMGR_PLEX_INDEX_INVALID
//
// MessageText:
//
// The specified plex index is greater or equal than the number of plexes in the volume.
//
static const int ERROR_VOLMGR_PLEX_INDEX_INVALID = _NDIS_ERROR_TYPEDEF_(0xC038003AL);
//
// MessageId: ERROR_VOLMGR_PLEX_LAST_ACTIVE
//
// MessageText:
//
// The specified plex is the last active plex in the volume. The plex cannot be removed or else the volume will go offline.
//
static const int ERROR_VOLMGR_PLEX_LAST_ACTIVE = _NDIS_ERROR_TYPEDEF_(0xC038003BL);
//
// MessageId: ERROR_VOLMGR_PLEX_MISSING
//
// MessageText:
//
// The specified plex is missing.
//
static const int ERROR_VOLMGR_PLEX_MISSING = _NDIS_ERROR_TYPEDEF_(0xC038003CL);
//
// MessageId: ERROR_VOLMGR_PLEX_REGENERATING
//
// MessageText:
//
// The specified plex is currently regenerating.
//
static const int ERROR_VOLMGR_PLEX_REGENERATING = _NDIS_ERROR_TYPEDEF_(0xC038003DL);
//
// MessageId: ERROR_VOLMGR_PLEX_TYPE_INVALID
//
// MessageText:
//
// The specified plex type is invalid.
//
static const int ERROR_VOLMGR_PLEX_TYPE_INVALID = _NDIS_ERROR_TYPEDEF_(0xC038003EL);
//
// MessageId: ERROR_VOLMGR_PLEX_NOT_RAID5
//
// MessageText:
//
// The operation is only supported on RAID-5 plexes.
//
static const int ERROR_VOLMGR_PLEX_NOT_RAID5 = _NDIS_ERROR_TYPEDEF_(0xC038003FL);
//
// MessageId: ERROR_VOLMGR_PLEX_NOT_SIMPLE
//
// MessageText:
//
// The operation is only supported on simple plexes.
//
static const int ERROR_VOLMGR_PLEX_NOT_SIMPLE = _NDIS_ERROR_TYPEDEF_(0xC0380040L);
//
// MessageId: ERROR_VOLMGR_STRUCTURE_SIZE_INVALID
//
// MessageText:
//
// The Size fields in the VM_VOLUME_LAYOUT input structure are incorrectly set.
//
static const int ERROR_VOLMGR_STRUCTURE_SIZE_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380041L);
//
// MessageId: ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS
//
// MessageText:
//
// There is already a pending request for notifications. Wait for the existing request to return before requesting for more notifications.
//
static const int ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = _NDIS_ERROR_TYPEDEF_(0xC0380042L);
//
// MessageId: ERROR_VOLMGR_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// There is currently a transaction in process.
//
static const int ERROR_VOLMGR_TRANSACTION_IN_PROGRESS = _NDIS_ERROR_TYPEDEF_(0xC0380043L);
//
// MessageId: ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE
//
// MessageText:
//
// An unexpected layout change occurred outside of the volume manager.
//
static const int ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = _NDIS_ERROR_TYPEDEF_(0xC0380044L);
//
// MessageId: ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK
//
// MessageText:
//
// The specified volume contains a missing disk.
//
static const int ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = _NDIS_ERROR_TYPEDEF_(0xC0380045L);
//
// MessageId: ERROR_VOLMGR_VOLUME_ID_INVALID
//
// MessageText:
//
// The specified volume id is invalid. There are no volumes with the specified volume id.
//
static const int ERROR_VOLMGR_VOLUME_ID_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380046L);
//
// MessageId: ERROR_VOLMGR_VOLUME_LENGTH_INVALID
//
// MessageText:
//
// The specified volume length is invalid.
//
static const int ERROR_VOLMGR_VOLUME_LENGTH_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380047L);
//
// MessageId: ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The specified size for the volume is not a multiple of the sector size.
//
static const int ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = _NDIS_ERROR_TYPEDEF_(0xC0380048L);
//
// MessageId: ERROR_VOLMGR_VOLUME_NOT_MIRRORED
//
// MessageText:
//
// The operation is only supported on mirrored volumes.
//
static const int ERROR_VOLMGR_VOLUME_NOT_MIRRORED = _NDIS_ERROR_TYPEDEF_(0xC0380049L);
//
// MessageId: ERROR_VOLMGR_VOLUME_NOT_RETAINED
//
// MessageText:
//
// The specified volume does not have a retain partition.
//
static const int ERROR_VOLMGR_VOLUME_NOT_RETAINED = _NDIS_ERROR_TYPEDEF_(0xC038004AL);
//
// MessageId: ERROR_VOLMGR_VOLUME_OFFLINE
//
// MessageText:
//
// The specified volume is offline.
//
static const int ERROR_VOLMGR_VOLUME_OFFLINE = _NDIS_ERROR_TYPEDEF_(0xC038004BL);
//
// MessageId: ERROR_VOLMGR_VOLUME_RETAINED
//
// MessageText:
//
// The specified volume already has a retain partition.
//
static const int ERROR_VOLMGR_VOLUME_RETAINED = _NDIS_ERROR_TYPEDEF_(0xC038004CL);
//
// MessageId: ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID
//
// MessageText:
//
// The specified number of extents is invalid.
//
static const int ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID = _NDIS_ERROR_TYPEDEF_(0xC038004DL);
//
// MessageId: ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE
//
// MessageText:
//
// All disks participating to the volume must have the same sector size.
//
static const int ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE = _NDIS_ERROR_TYPEDEF_(0xC038004EL);
//
// MessageId: ERROR_VOLMGR_BAD_BOOT_DISK
//
// MessageText:
//
// The boot disk experienced failures.
//
static const int ERROR_VOLMGR_BAD_BOOT_DISK = _NDIS_ERROR_TYPEDEF_(0xC038004FL);
//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_OFFLINE
//
// MessageText:
//
// The configuration of the pack is offline.
//
static const int ERROR_VOLMGR_PACK_CONFIG_OFFLINE = _NDIS_ERROR_TYPEDEF_(0xC0380050L);
//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_ONLINE
//
// MessageText:
//
// The configuration of the pack is online.
//
static const int ERROR_VOLMGR_PACK_CONFIG_ONLINE = _NDIS_ERROR_TYPEDEF_(0xC0380051L);
//
// MessageId: ERROR_VOLMGR_NOT_PRIMARY_PACK
//
// MessageText:
//
// The specified pack is not the primary pack.
//
static const int ERROR_VOLMGR_NOT_PRIMARY_PACK = _NDIS_ERROR_TYPEDEF_(0xC0380052L);
//
// MessageId: ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED
//
// MessageText:
//
// All disks failed to be updated with the new content of the log.
//
static const int ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED = _NDIS_ERROR_TYPEDEF_(0xC0380053L);
//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID
//
// MessageText:
//
// The specified number of disks in a plex is invalid.
//
static const int ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380054L);
//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID
//
// MessageText:
//
// The specified number of disks in a plex member is invalid.
//
static const int ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = _NDIS_ERROR_TYPEDEF_(0xC0380055L);
//
// MessageId: ERROR_VOLMGR_VOLUME_MIRRORED
//
// MessageText:
//
// The operation is not supported on mirrored volumes.
//
static const int ERROR_VOLMGR_VOLUME_MIRRORED = _NDIS_ERROR_TYPEDEF_(0xC0380056L);
//
// MessageId: ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED
//
// MessageText:
//
// The operation is only supported on simple and spanned plexes.
//
static const int ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = _NDIS_ERROR_TYPEDEF_(0xC0380057L);
//
// MessageId: ERROR_VOLMGR_NO_VALID_LOG_COPIES
//
// MessageText:
//
// The pack has no valid log copies.
//
static const int ERROR_VOLMGR_NO_VALID_LOG_COPIES = _NDIS_ERROR_TYPEDEF_(0xC0380058L);
//
// MessageId: ERROR_VOLMGR_PRIMARY_PACK_PRESENT
//
// MessageText:
//
// A primary pack is already present.
//
static const int ERROR_VOLMGR_PRIMARY_PACK_PRESENT = _NDIS_ERROR_TYPEDEF_(0xC0380059L);
//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID
//
// MessageText:
//
// The specified number of disks is invalid.
//
static const int ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID = _NDIS_ERROR_TYPEDEF_(0xC038005AL);
//
// MessageId: ERROR_VOLMGR_MIRROR_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support mirrored volumes.
//
static const int ERROR_VOLMGR_MIRROR_NOT_SUPPORTED = _NDIS_ERROR_TYPEDEF_(0xC038005BL);
//
// MessageId: ERROR_VOLMGR_RAID5_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support RAID-5 volumes.
//
static const int ERROR_VOLMGR_RAID5_NOT_SUPPORTED = _NDIS_ERROR_TYPEDEF_(0xC038005CL);
//
// Boot Code Data (BCD) error codes
//
//
// MessageId: ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED
//
// MessageText:
//
// Some BCD entries were not imported correctly from the BCD store.
//
static const int ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED = _NDIS_ERROR_TYPEDEF_(0x80390001L);
//
// MessageId: ERROR_BCD_TOO_MANY_ELEMENTS
//
// MessageText:
//
// Entries enumerated have exceeded the allowed threshold.
//
static const int ERROR_BCD_TOO_MANY_ELEMENTS = _NDIS_ERROR_TYPEDEF_(0xC0390002L);
//
// MessageId: ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED
//
// MessageText:
//
// Some BCD entries were not synchronized correctly with the firmware.
//
static const int ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED = _NDIS_ERROR_TYPEDEF_(0x80390003L);
//
// Vhd error codes - These codes are used by the virtual hard diskparser component.
//
//
// Errors:
//
//
// MessageId: ERROR_VHD_DRIVE_FOOTER_MISSING
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer is missing.
//
static const int ERROR_VHD_DRIVE_FOOTER_MISSING = _NDIS_ERROR_TYPEDEF_(0xC03A0001L);
//
// MessageId: ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer checksum does not match the on-disk checksum.
//
static const int ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = _NDIS_ERROR_TYPEDEF_(0xC03A0002L);
//
// MessageId: ERROR_VHD_DRIVE_FOOTER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer in the virtual hard disk is corrupted.
//
static const int ERROR_VHD_DRIVE_FOOTER_CORRUPT = _NDIS_ERROR_TYPEDEF_(0xC03A0003L);
//
// MessageId: ERROR_VHD_FORMAT_UNKNOWN
//
// MessageText:
//
// The system does not recognize the file format of this virtual hard disk.
//
static const int ERROR_VHD_FORMAT_UNKNOWN = _NDIS_ERROR_TYPEDEF_(0xC03A0004L);
//
// MessageId: ERROR_VHD_FORMAT_UNSUPPORTED_VERSION
//
// MessageText:
//
// The version does not support this version of the file format.
//
static const int ERROR_VHD_FORMAT_UNSUPPORTED_VERSION = _NDIS_ERROR_TYPEDEF_(0xC03A0005L);
//
// MessageId: ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header checksum does not match the on-disk checksum.
//
static const int ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = _NDIS_ERROR_TYPEDEF_(0xC03A0006L);
//
// MessageId: ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION
//
// MessageText:
//
// The system does not support this version of the virtual hard disk.This version of the sparse header is not supported.
//
static const int ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = _NDIS_ERROR_TYPEDEF_(0xC03A0007L);
//
// MessageId: ERROR_VHD_SPARSE_HEADER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header in the virtual hard disk is corrupt.
//
static const int ERROR_VHD_SPARSE_HEADER_CORRUPT = _NDIS_ERROR_TYPEDEF_(0xC03A0008L);
//
// MessageId: ERROR_VHD_BLOCK_ALLOCATION_FAILURE
//
// MessageText:
//
// Failed to write to the virtual hard disk failed because the system failed to allocate a new block in the virtual hard disk.
//
static const int ERROR_VHD_BLOCK_ALLOCATION_FAILURE = _NDIS_ERROR_TYPEDEF_(0xC03A0009L);
//
// MessageId: ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The block allocation table in the virtual hard disk is corrupt.
//
static const int ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = _NDIS_ERROR_TYPEDEF_(0xC03A000AL);
//
// MessageId: ERROR_VHD_INVALID_BLOCK_SIZE
//
// MessageText:
//
// The system does not support this version of the virtual hard disk. The block size is invalid.
//
static const int ERROR_VHD_INVALID_BLOCK_SIZE = _NDIS_ERROR_TYPEDEF_(0xC03A000BL);
//
// MessageId: ERROR_VHD_BITMAP_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The block bitmap does not match with the block data present in the virtual hard disk.
//
static const int ERROR_VHD_BITMAP_MISMATCH = _NDIS_ERROR_TYPEDEF_(0xC03A000CL);
//
// MessageId: ERROR_VHD_PARENT_VHD_NOT_FOUND
//
// MessageText:
//
// The chain of virtual hard disks is broken. The system cannot locate the parent virtual hard disk for the differencing disk.
//
static const int ERROR_VHD_PARENT_VHD_NOT_FOUND = _NDIS_ERROR_TYPEDEF_(0xC03A000DL);
//
// MessageId: ERROR_VHD_CHILD_PARENT_ID_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the identifiers of the parent virtual hard disk and differencing disk.
//
static const int ERROR_VHD_CHILD_PARENT_ID_MISMATCH = _NDIS_ERROR_TYPEDEF_(0xC03A000EL);
//
// MessageId: ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. The time stamp of the parent virtual hard disk does not match the time stamp of the differencing disk.
//
static const int ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = _NDIS_ERROR_TYPEDEF_(0xC03A000FL);
//
// MessageId: ERROR_VHD_METADATA_READ_FAILURE
//
// MessageText:
//
// Failed to read the metadata of the virtual hard disk.
//
static const int ERROR_VHD_METADATA_READ_FAILURE = _NDIS_ERROR_TYPEDEF_(0xC03A0010L);
//
// MessageId: ERROR_VHD_METADATA_WRITE_FAILURE
//
// MessageText:
//
// Failed to write to the metadata of the virtual hard disk.
//
static const int ERROR_VHD_METADATA_WRITE_FAILURE = _NDIS_ERROR_TYPEDEF_(0xC03A0011L);
//
// MessageId: ERROR_VHD_INVALID_SIZE
//
// MessageText:
//
// The size of the virtual hard disk is not valid.
//
static const int ERROR_VHD_INVALID_SIZE = _NDIS_ERROR_TYPEDEF_(0xC03A0012L);
//
// MessageId: ERROR_VHD_INVALID_FILE_SIZE
//
// MessageText:
//
// The file size of this virtual hard disk is not valid.
//
static const int ERROR_VHD_INVALID_FILE_SIZE = _NDIS_ERROR_TYPEDEF_(0xC03A0013L);
//
// MessageId: ERROR_VIRTDISK_PROVIDER_NOT_FOUND
//
// MessageText:
//
// A virtual disk support provider for the specified file was not found.
//
static const int ERROR_VIRTDISK_PROVIDER_NOT_FOUND = _NDIS_ERROR_TYPEDEF_(0xC03A0014L);
//
// MessageId: ERROR_VIRTDISK_NOT_VIRTUAL_DISK
//
// MessageText:
//
// The specified disk is not a virtual disk.
//
static const int ERROR_VIRTDISK_NOT_VIRTUAL_DISK = _NDIS_ERROR_TYPEDEF_(0xC03A0015L);
//
// MessageId: ERROR_VHD_PARENT_VHD_ACCESS_DENIED
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. The process has not been granted access rights to the parent virtual hard disk for the differencing disk.
//
static const int ERROR_VHD_PARENT_VHD_ACCESS_DENIED = _NDIS_ERROR_TYPEDEF_(0xC03A0016L);
//
// MessageId: ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the virtual sizes of the parent virtual hard disk and differencing disk.
//
static const int ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH = _NDIS_ERROR_TYPEDEF_(0xC03A0017L);
//
// MessageId: ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. A differencing disk is indicated in its own parent chain.
//
static const int ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = _NDIS_ERROR_TYPEDEF_(0xC03A0018L);
//
// MessageId: ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. There was an error opening a virtual hard disk further up the chain.
//
static const int ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = _NDIS_ERROR_TYPEDEF_(0xC03A0019L);
//
// MessageId: ERROR_VIRTUAL_DISK_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a virtual disk system limitation.  Virtual disks are only supported on NTFS volumes and must be both uncompressed and unencrypted.
//
static const int ERROR_VIRTUAL_DISK_LIMITATION = _NDIS_ERROR_TYPEDEF_(0xC03A001AL);
//
// MessageId: ERROR_VHD_INVALID_TYPE
//
// MessageText:
//
// The requested operation cannot be performed on a virtual disk of this type.
//
static const int ERROR_VHD_INVALID_TYPE = _NDIS_ERROR_TYPEDEF_(0xC03A001BL);
//
// MessageId: ERROR_VHD_INVALID_STATE
//
// MessageText:
//
// The requested operation cannot be performed on the virtual disk in its current state.
//
static const int ERROR_VHD_INVALID_STATE = _NDIS_ERROR_TYPEDEF_(0xC03A001CL);
//
// MessageId: ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE
//
// MessageText:
//
// The sector size of the physical disk on which the virtual disk resides is not supported.
//
static const int ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = _NDIS_ERROR_TYPEDEF_(0xC03A001DL);
//
// Warnings:
//
//
// MessageId: ERROR_QUERY_STORAGE_ERROR
//
// MessageText:
//
// The virtualization storage subsystem has generated an error.
//
static const int ERROR_QUERY_STORAGE_ERROR = _NDIS_ERROR_TYPEDEF_(0x803A0001L);
//
// =======================================================
// Facility Scripted Diagnostics (SDIAG) Error Messages
// =======================================================
//
//
// MessageId: SDIAG_E_CANCELLED
//
// MessageText:
//
// The operation was cancelled.
//
static const int SDIAG_E_CANCELLED = _NDIS_ERROR_TYPEDEF_(0x803C0100L);
//
// MessageId: SDIAG_E_SCRIPT
//
// MessageText:
//
// An error occurred when running a PowerShell script.
//
static const int SDIAG_E_SCRIPT = _NDIS_ERROR_TYPEDEF_(0x803C0101L);
//
// MessageId: SDIAG_E_POWERSHELL
//
// MessageText:
//
// An error occurred when interacting with PowerShell runtime.
//
static const int SDIAG_E_POWERSHELL = _NDIS_ERROR_TYPEDEF_(0x803C0102L);
//
// MessageId: SDIAG_E_MANAGEDHOST
//
// MessageText:
//
// An error occurred in the Scripted Diagnostic Managed Host.
//
static const int SDIAG_E_MANAGEDHOST = _NDIS_ERROR_TYPEDEF_(0x803C0103L);
//
// MessageId: SDIAG_E_NOVERIFIER
//
// MessageText:
//
// The troubleshooting pack does not contain a required verifier to complete the verification.
//
static const int SDIAG_E_NOVERIFIER = _NDIS_ERROR_TYPEDEF_(0x803C0104L);
//
// MessageId: SDIAG_S_CANNOTRUN
//
// MessageText:
//
// The troubleshooting pack cannot be executed on this system.
//
static const int SDIAG_S_CANNOTRUN = _NDIS_ERROR_TYPEDEF_(0x003C0105L);
//
// MessageId: SDIAG_E_DISABLED
//
// MessageText:
//
// Scripted diagnostics is disabled by group policy.
//
static const int SDIAG_E_DISABLED = _NDIS_ERROR_TYPEDEF_(0x803C0106L);
//
// MessageId: SDIAG_E_TRUST
//
// MessageText:
//
// Trust validation of the troubleshooting pack failed.
//
static const int SDIAG_E_TRUST = _NDIS_ERROR_TYPEDEF_(0x803C0107L);
//
// MessageId: SDIAG_E_CANNOTRUN
//
// MessageText:
//
// The troubleshooting pack cannot be executed on this system.
//
static const int SDIAG_E_CANNOTRUN = _NDIS_ERROR_TYPEDEF_(0x803C0108L);
//
// MessageId: SDIAG_E_VERSION
//
// MessageText:
//
// This version of the troubleshooting pack is not supported.
//
static const int SDIAG_E_VERSION = _NDIS_ERROR_TYPEDEF_(0x803C0109L);
//
// MessageId: SDIAG_E_RESOURCE
//
// MessageText:
//
// A required resource cannot be loaded.
//
static const int SDIAG_E_RESOURCE = _NDIS_ERROR_TYPEDEF_(0x803C010AL);
//
// MessageId: SDIAG_E_ROOTCAUSE
//
// MessageText:
//
// The troubleshooting pack reported information for a root cause without adding the root cause.
//
static const int SDIAG_E_ROOTCAUSE = _NDIS_ERROR_TYPEDEF_(0x803C010BL);
//
// MBN error codes
//
//
// MessageId: E_MBN_CONTEXT_NOT_ACTIVATED
//
// MessageText:
//
// Context is not activated.
//
static const int E_MBN_CONTEXT_NOT_ACTIVATED = _HRESULT_TYPEDEF_(0x80548201L);
//
// MessageId: E_MBN_BAD_SIM
//
// MessageText:
//
// Bad SIM is inserted.
//
static const int E_MBN_BAD_SIM = _HRESULT_TYPEDEF_(0x80548202L);
//
// MessageId: E_MBN_DATA_CLASS_NOT_AVAILABLE
//
// MessageText:
//
// Requested data class is not avaialable.
//
static const int E_MBN_DATA_CLASS_NOT_AVAILABLE = _HRESULT_TYPEDEF_(0x80548203L);
//
// MessageId: E_MBN_INVALID_ACCESS_STRING
//
// MessageText:
//
// Access point name (APN) or Access string is incorrect.
//
static const int E_MBN_INVALID_ACCESS_STRING = _HRESULT_TYPEDEF_(0x80548204L);
//
// MessageId: E_MBN_MAX_ACTIVATED_CONTEXTS
//
// MessageText:
//
// Max activated contexts have reached.
//
static const int E_MBN_MAX_ACTIVATED_CONTEXTS = _HRESULT_TYPEDEF_(0x80548205L);
//
// MessageId: E_MBN_PACKET_SVC_DETACHED
//
// MessageText:
//
// Device is in packet detach state.
//
static const int E_MBN_PACKET_SVC_DETACHED = _HRESULT_TYPEDEF_(0x80548206L);
//
// MessageId: E_MBN_PROVIDER_NOT_VISIBLE
//
// MessageText:
//
// Provider is not visible.
//
static const int E_MBN_PROVIDER_NOT_VISIBLE = _HRESULT_TYPEDEF_(0x80548207L);
//
// MessageId: E_MBN_RADIO_POWER_OFF
//
// MessageText:
//
// Radio is powered off.
//
static const int E_MBN_RADIO_POWER_OFF = _HRESULT_TYPEDEF_(0x80548208L);
//
// MessageId: E_MBN_SERVICE_NOT_ACTIVATED
//
// MessageText:
//
// MBN subscription is not activated.
//
static const int E_MBN_SERVICE_NOT_ACTIVATED = _HRESULT_TYPEDEF_(0x80548209L);
//
// MessageId: E_MBN_SIM_NOT_INSERTED
//
// MessageText:
//
// SIM is not inserted.
//
static const int E_MBN_SIM_NOT_INSERTED = _HRESULT_TYPEDEF_(0x8054820AL);
//
// MessageId: E_MBN_VOICE_CALL_IN_PROGRESS
//
// MessageText:
//
// Voice call in progress.
//
static const int E_MBN_VOICE_CALL_IN_PROGRESS = _HRESULT_TYPEDEF_(0x8054820BL);
//
// MessageId: E_MBN_INVALID_CACHE
//
// MessageText:
//
// Visible provider cache is invalid.
//
static const int E_MBN_INVALID_CACHE = _HRESULT_TYPEDEF_(0x8054820CL);
//
// MessageId: E_MBN_NOT_REGISTERED
//
// MessageText:
//
// Device is not registered.
//
static const int E_MBN_NOT_REGISTERED = _HRESULT_TYPEDEF_(0x8054820DL);
//
// MessageId: E_MBN_PROVIDERS_NOT_FOUND
//
// MessageText:
//
// Providers not found.
//
static const int E_MBN_PROVIDERS_NOT_FOUND = _HRESULT_TYPEDEF_(0x8054820EL);
//
// MessageId: E_MBN_PIN_NOT_SUPPORTED
//
// MessageText:
//
// Pin is not supported.
//
static const int E_MBN_PIN_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x8054820FL);
//
// MessageId: E_MBN_PIN_REQUIRED
//
// MessageText:
//
// Pin is required.
//
static const int E_MBN_PIN_REQUIRED = _HRESULT_TYPEDEF_(0x80548210L);
//
// MessageId: E_MBN_PIN_DISABLED
//
// MessageText:
//
// PIN is disabled.
//
static const int E_MBN_PIN_DISABLED = _HRESULT_TYPEDEF_(0x80548211L);
//
// MessageId: E_MBN_FAILURE
//
// MessageText:
//
// Generic Failure.
//
static const int E_MBN_FAILURE = _HRESULT_TYPEDEF_(0x80548212L);
// Profile related error messages
//
// MessageId: E_MBN_INVALID_PROFILE
//
// MessageText:
//
// Profile is invalid.
//
static const int E_MBN_INVALID_PROFILE = _HRESULT_TYPEDEF_(0x80548218L);
//
// MessageId: E_MBN_DEFAULT_PROFILE_EXIST
//
// MessageText:
//
// Default profile exist.
//
static const int E_MBN_DEFAULT_PROFILE_EXIST = _HRESULT_TYPEDEF_(0x80548219L);
// SMS related error messages
//
// MessageId: E_MBN_SMS_ENCODING_NOT_SUPPORTED
//
// MessageText:
//
// SMS encoding is not supported.
//
static const int E_MBN_SMS_ENCODING_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80548220L);
//
// MessageId: E_MBN_SMS_FILTER_NOT_SUPPORTED
//
// MessageText:
//
// SMS filter is not supported.
//
static const int E_MBN_SMS_FILTER_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80548221L);
//
// MessageId: E_MBN_SMS_INVALID_MEMORY_INDEX
//
// MessageText:
//
// Invalid SMS memory index is used.
//
static const int E_MBN_SMS_INVALID_MEMORY_INDEX = _HRESULT_TYPEDEF_(0x80548222L);
//
// MessageId: E_MBN_SMS_LANG_NOT_SUPPORTED
//
// MessageText:
//
// SMS language is not supported.
//
static const int E_MBN_SMS_LANG_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80548223L);
//
// MessageId: E_MBN_SMS_MEMORY_FAILURE
//
// MessageText:
//
// SMS memory failure occurred.
//
static const int E_MBN_SMS_MEMORY_FAILURE = _HRESULT_TYPEDEF_(0x80548224L);
//
// MessageId: E_MBN_SMS_NETWORK_TIMEOUT
//
// MessageText:
//
// SMS network timeout happened.
//
static const int E_MBN_SMS_NETWORK_TIMEOUT = _HRESULT_TYPEDEF_(0x80548225L);
//
// MessageId: E_MBN_SMS_UNKNOWN_SMSC_ADDRESS
//
// MessageText:
//
// Unknown SMSC address is used.
//
static const int E_MBN_SMS_UNKNOWN_SMSC_ADDRESS = _HRESULT_TYPEDEF_(0x80548226L);
//
// MessageId: E_MBN_SMS_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// SMS format is not supported.
//
static const int E_MBN_SMS_FORMAT_NOT_SUPPORTED = _HRESULT_TYPEDEF_(0x80548227L);
//
// MessageId: E_MBN_SMS_OPERATION_NOT_ALLOWED
//
// MessageText:
//
// SMS operation is not allowed.
//
static const int E_MBN_SMS_OPERATION_NOT_ALLOWED = _HRESULT_TYPEDEF_(0x80548228L);
//
// MessageId: E_MBN_SMS_MEMORY_FULL
//
// MessageText:
//
// Device SMS memory is full.
//
static const int E_MBN_SMS_MEMORY_FULL = _HRESULT_TYPEDEF_(0x80548229L);
//
// UI error codes
//
//
// MessageId: UI_E_CREATE_FAILED
//
// MessageText:
//
// The object could not be created.
//
static const int UI_E_CREATE_FAILED = _HRESULT_TYPEDEF_(0x802A0001L);
//
// MessageId: UI_E_SHUTDOWN_CALLED
//
// MessageText:
//
// Shutdown was already called on this object or the object that owns it.
//
static const int UI_E_SHUTDOWN_CALLED = _HRESULT_TYPEDEF_(0x802A0002L);
//
// MessageId: UI_E_ILLEGAL_REENTRANCY
//
// MessageText:
//
// This method cannot be called during this type of callback.
//
static const int UI_E_ILLEGAL_REENTRANCY = _HRESULT_TYPEDEF_(0x802A0003L);
//
// MessageId: UI_E_OBJECT_SEALED
//
// MessageText:
//
// This object has been sealed, so this change is no longer allowed.
//
static const int UI_E_OBJECT_SEALED = _HRESULT_TYPEDEF_(0x802A0004L);
//
// MessageId: UI_E_VALUE_NOT_SET
//
// MessageText:
//
// The requested value was never set.
//
static const int UI_E_VALUE_NOT_SET = _HRESULT_TYPEDEF_(0x802A0005L);
//
// MessageId: UI_E_VALUE_NOT_DETERMINED
//
// MessageText:
//
// The requested value cannot be determined.
//
static const int UI_E_VALUE_NOT_DETERMINED = _HRESULT_TYPEDEF_(0x802A0006L);
//
// MessageId: UI_E_INVALID_OUTPUT
//
// MessageText:
//
// A callback returned an invalid output parameter.
//
static const int UI_E_INVALID_OUTPUT = _HRESULT_TYPEDEF_(0x802A0007L);
//
// MessageId: UI_E_BOOLEAN_EXPECTED
//
// MessageText:
//
// A callback returned a success code other than S_OK or S_FALSE.
//
static const int UI_E_BOOLEAN_EXPECTED = _HRESULT_TYPEDEF_(0x802A0008L);
//
// MessageId: UI_E_DIFFERENT_OWNER
//
// MessageText:
//
// A parameter that should be owned by this object is owned by a different object.
//
static const int UI_E_DIFFERENT_OWNER = _HRESULT_TYPEDEF_(0x802A0009L);
//
// MessageId: UI_E_AMBIGUOUS_MATCH
//
// MessageText:
//
// More than one item matched the search criteria.
//
static const int UI_E_AMBIGUOUS_MATCH = _HRESULT_TYPEDEF_(0x802A000AL);
//
// MessageId: UI_E_FP_OVERFLOW
//
// MessageText:
//
// A floating-point overflow occurred.
//
static const int UI_E_FP_OVERFLOW = _HRESULT_TYPEDEF_(0x802A000BL);
//
// MessageId: UI_E_WRONG_THREAD
//
// MessageText:
//
// This method can only be called from the thread that created the object.
//
static const int UI_E_WRONG_THREAD = _HRESULT_TYPEDEF_(0x802A000CL);
//
// MessageId: UI_E_STORYBOARD_ACTIVE
//
// MessageText:
//
// The storyboard is currently in the schedule.
//
static const int UI_E_STORYBOARD_ACTIVE = _HRESULT_TYPEDEF_(0x802A0101L);
//
// MessageId: UI_E_STORYBOARD_NOT_PLAYING
//
// MessageText:
//
// The storyboard is not playing.
//
static const int UI_E_STORYBOARD_NOT_PLAYING = _HRESULT_TYPEDEF_(0x802A0102L);
//
// MessageId: UI_E_START_KEYFRAME_AFTER_END
//
// MessageText:
//
// The start keyframe might occur after the end keyframe.
//
static const int UI_E_START_KEYFRAME_AFTER_END = _HRESULT_TYPEDEF_(0x802A0103L);
//
// MessageId: UI_E_END_KEYFRAME_NOT_DETERMINED
//
// MessageText:
//
// It might not be possible to determine the end keyframe time when the start keyframe is reached.
//
static const int UI_E_END_KEYFRAME_NOT_DETERMINED = _HRESULT_TYPEDEF_(0x802A0104L);
//
// MessageId: UI_E_LOOPS_OVERLAP
//
// MessageText:
//
// Two repeated portions of a storyboard might overlap.
//
static const int UI_E_LOOPS_OVERLAP = _HRESULT_TYPEDEF_(0x802A0105L);
//
// MessageId: UI_E_TRANSITION_ALREADY_USED
//
// MessageText:
//
// The transition has already been added to a storyboard.
//
static const int UI_E_TRANSITION_ALREADY_USED = _HRESULT_TYPEDEF_(0x802A0106L);
//
// MessageId: UI_E_TRANSITION_NOT_IN_STORYBOARD
//
// MessageText:
//
// The transition has not been added to a storyboard.
//
static const int UI_E_TRANSITION_NOT_IN_STORYBOARD = _HRESULT_TYPEDEF_(0x802A0107L);
//
// MessageId: UI_E_TRANSITION_ECLIPSED
//
// MessageText:
//
// The transition might eclipse the beginning of another transition in the storyboard.
//
static const int UI_E_TRANSITION_ECLIPSED = _HRESULT_TYPEDEF_(0x802A0108L);
//
// MessageId: UI_E_TIME_BEFORE_LAST_UPDATE
//
// MessageText:
//
// The given time is earlier than the time passed to the last update.
//
static const int UI_E_TIME_BEFORE_LAST_UPDATE = _HRESULT_TYPEDEF_(0x802A0109L);
//
// MessageId: UI_E_TIMER_CLIENT_ALREADY_CONNECTED
//
// MessageText:
//
// This client is already connected to a timer.
//
static const int UI_E_TIMER_CLIENT_ALREADY_CONNECTED = _HRESULT_TYPEDEF_(0x802A010AL);
# 13704 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h" 2
/* Abnormal termination codes */
static const int TC_NORMAL = 0;
static const int TC_HARDERR = 1;
static const int TC_GP_TRAP = 2;
static const int TC_SIGNAL = 3;
//
// Power Management APIs
//
static const int AC_LINE_OFFLINE = 0x00;
static const int AC_LINE_ONLINE = 0x01;
static const int AC_LINE_BACKUP_POWER = 0x02;
static const int AC_LINE_UNKNOWN = 0xFF;
static const int BATTERY_FLAG_HIGH = 0x01;
static const int BATTERY_FLAG_LOW = 0x02;
static const int BATTERY_FLAG_CRITICAL = 0x04;
static const int BATTERY_FLAG_CHARGING = 0x08;
static const int BATTERY_FLAG_NO_BATTERY = 0x80;
static const int BATTERY_FLAG_UNKNOWN = 0xFF;
static const int BATTERY_PERCENTAGE_UNKNOWN = 0xFF;
static const int BATTERY_LIFE_UNKNOWN = 0xFFFFFFFF;
typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;
BOOL
GetSystemPowerStatus(
    LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );
BOOL
SetSystemPowerState(
    BOOL fSuspend,
    BOOL fForce
    );
//
// Very Large Memory API Subset
//
BOOL
AllocateUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );
BOOL
AllocateUserPhysicalPagesNuma(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray,
    DWORD nndPreferred
    );
BOOL
FreeUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );
BOOL
MapUserPhysicalPages(
    PVOID VirtualAddress,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );
BOOL
MapUserPhysicalPagesScatter(
    PVOID *VirtualAddresses,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );
HANDLE
CreateJobObjectA(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCSTR lpName
    );
HANDLE
CreateJobObjectW(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCWSTR lpName
    );
static const int CreateJobObject = CreateJobObjectA;
HANDLE
OpenJobObjectA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );
HANDLE
OpenJobObjectW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );
static const int OpenJobObject = OpenJobObjectA;
BOOL
AssignProcessToJobObject(
    HANDLE hJob,
    HANDLE hProcess
    );
BOOL
TerminateJobObject(
    HANDLE hJob,
    UINT uExitCode
    );
BOOL
QueryInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength,
    LPDWORD lpReturnLength
    );
BOOL
SetInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength
    );
BOOL
IsProcessInJob (
    HANDLE ProcessHandle,
    HANDLE JobHandle,
    PBOOL Result
    );
BOOL
CreateJobSet (
    ULONG NumJob,
    PJOB_SET_ARRAY UserJobSet,
    ULONG Flags);
PVOID
AddVectoredExceptionHandler (
    ULONG First,
    PVECTORED_EXCEPTION_HANDLER Handler
    );
ULONG
RemoveVectoredExceptionHandler (
    PVOID Handle
    );
PVOID
AddVectoredContinueHandler (
    ULONG First,
    PVECTORED_EXCEPTION_HANDLER Handler
    );
ULONG
RemoveVectoredContinueHandler (
    PVOID Handle
    );
//
// New Volume Mount Point API.
//
HANDLE
FindFirstVolumeA(
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );
HANDLE
FindFirstVolumeW(
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );
static const int FindFirstVolume = FindFirstVolumeA;
BOOL
FindNextVolumeA(
    HANDLE hFindVolume,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );
BOOL
FindNextVolumeW(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );
static const int FindNextVolume = FindNextVolumeA;
BOOL
FindVolumeClose(
    HANDLE hFindVolume
    );
HANDLE
FindFirstVolumeMountPointA(
    LPCSTR lpszRootPathName,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
HANDLE
FindFirstVolumeMountPointW(
    LPCWSTR lpszRootPathName,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
static const int FindFirstVolumeMountPoint = FindFirstVolumeMountPointA;
BOOL
FindNextVolumeMountPointA(
    HANDLE hFindVolumeMountPoint,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
BOOL
FindNextVolumeMountPointW(
    HANDLE hFindVolumeMountPoint,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
static const int FindNextVolumeMountPoint = FindNextVolumeMountPointA;
BOOL
FindVolumeMountPointClose(
    HANDLE hFindVolumeMountPoint
    );
BOOL
SetVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPCSTR lpszVolumeName
    );
BOOL
SetVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPCWSTR lpszVolumeName
    );
static const int SetVolumeMountPoint = SetVolumeMountPointA;
BOOL
DeleteVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint
    );
BOOL
DeleteVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint
    );
static const int DeleteVolumeMountPoint = DeleteVolumeMountPointA;
BOOL
GetVolumeNameForVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );
BOOL
GetVolumeNameForVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );
static const int GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointA;
BOOL
GetVolumePathNameA(
    LPCSTR lpszFileName,
    LPSTR lpszVolumePathName,
    DWORD cchBufferLength
    );
BOOL
GetVolumePathNameW(
    LPCWSTR lpszFileName,
    LPWSTR lpszVolumePathName,
    DWORD cchBufferLength
    );
static const int GetVolumePathName = GetVolumePathNameA;
BOOL
GetVolumePathNamesForVolumeNameA(
    LPCSTR lpszVolumeName,
    LPCH lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );
BOOL
GetVolumePathNamesForVolumeNameW(
    LPCWSTR lpszVolumeName,
    LPWCH lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );
static const int GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameA;
static const int ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID = (0x00000001);
static const int ACTCTX_FLAG_LANGID_VALID = (0x00000002);
static const int ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID = (0x00000004);
static const int ACTCTX_FLAG_RESOURCE_NAME_VALID = (0x00000008);
static const int ACTCTX_FLAG_SET_PROCESS_DEFAULT = (0x00000010);
static const int ACTCTX_FLAG_APPLICATION_NAME_VALID = (0x00000020);
static const int ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF = (0x00000040);
static const int ACTCTX_FLAG_HMODULE_VALID = (0x00000080);
typedef struct tagACTCTXA {
    ULONG cbSize;
    DWORD dwFlags;
    LPCSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCSTR lpAssemblyDirectory;
    LPCSTR lpResourceName;
    LPCSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG cbSize;
    DWORD dwFlags;
    LPCWSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCWSTR lpAssemblyDirectory;
    LPCWSTR lpResourceName;
    LPCWSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXW, *PACTCTXW;
typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;
typedef PCACTCTXA PCACTCTX;
HANDLE
CreateActCtxA(
    PCACTCTXA pActCtx
    );
HANDLE
CreateActCtxW(
    PCACTCTXW pActCtx
    );
static const int CreateActCtx = CreateActCtxA;
void
AddRefActCtx(
    HANDLE hActCtx
    );
void
ReleaseActCtx(
    HANDLE hActCtx
    );
BOOL
ZombifyActCtx(
    HANDLE hActCtx
    );
BOOL
ActivateActCtx(
    HANDLE hActCtx,
    ULONG_PTR *lpCookie
    );
static const int DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION = (0x00000001);
BOOL
DeactivateActCtx(
    DWORD dwFlags,
    ULONG_PTR ulCookie
    );
BOOL
GetCurrentActCtx(
    HANDLE *lphActCtx);
typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;
typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
// 2600 stops here
    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;
static const int FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX = (0x00000001);
static const int FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS = (0x00000002);
static const int FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA = (0x00000004);
BOOL
FindActCtxSectionStringA(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
BOOL
FindActCtxSectionStringW(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCWSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
static const int FindActCtxSectionString = FindActCtxSectionStringA;
BOOL
FindActCtxSectionGuid(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    const GUID *lpGuidToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE hActCtx;
    DWORD dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;
typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;
static const int ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED = 1;
static const int QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX = (0x00000004);
static const int QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE = (0x00000008);
static const int QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS = (0x00000010);
static const int QUERY_ACTCTX_FLAG_NO_ADDREF = (0x80000000);
//
// switch (ulInfoClass)
//
//  case ActivationContextBasicInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_BASIC_INFORMATION
//
//  case ActivationContextDetailedInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_DETAILED_INFORMATION
//
//  case AssemblyDetailedInformationInActivationContext:
//    pvSubInstance is of type PULONG
//      *pvSubInstance < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//    pvBuffer is of type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
//
//  case FileInformationInAssemblyOfAssemblyInActivationContext:
//    pvSubInstance is of type PACTIVATION_CONTEXT_QUERY_INDEX
//      pvSubInstance->ulAssemblyIndex < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//      pvSubInstance->ulFileIndexInAssembly < ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION::ulFileCount
//    pvBuffer is of type PASSEMBLY_FILE_DETAILED_INFORMATION
//
//  case RunlevelInformationInActivationContext :
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
//
// String are placed after the structs.
//
BOOL
QueryActCtxW(
    DWORD dwFlags,
    HANDLE hActCtx,
    PVOID pvSubInstance,
    ULONG ulInfoClass,
    PVOID pvBuffer,
    SIZE_T cbBuffer,
    SIZE_T *pcbWrittenOrRequired
    );
typedef BOOL ( * PQUERYACTCTXW_FUNC)(
    DWORD dwFlags,
    HANDLE hActCtx,
    PVOID pvSubInstance,
    ULONG ulInfoClass,
    PVOID pvBuffer,
    SIZE_T cbBuffer,
    SIZE_T *pcbWrittenOrRequired
    );
BOOL
ProcessIdToSessionId(
    DWORD dwProcessId,
    DWORD *pSessionId
    );
DWORD
WTSGetActiveConsoleSessionId(
    void
    );
BOOL
IsWow64Process(
    HANDLE hProcess,
    PBOOL Wow64Process
    );
BOOL
GetLogicalProcessorInformation(
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
    PDWORD ReturnedLength
    );
BOOL
GetLogicalProcessorInformationEx(
    LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
    PDWORD ReturnedLength
    );
WORD
GetActiveProcessorGroupCount(
    void
    );
WORD
GetMaximumProcessorGroupCount(
    void
    );
DWORD
GetActiveProcessorCount(
    WORD GroupNumber
    );
DWORD
GetMaximumProcessorCount(
    WORD GroupNumber
    );
//
// NUMA Information routines.
//
BOOL
GetNumaHighestNodeNumber(
    PULONG HighestNodeNumber
    );
BOOL
GetNumaProcessorNode(
    UCHAR Processor,
    PUCHAR NodeNumber
    );
BOOL
GetNumaNodeNumberFromHandle(
    HANDLE hFile,
    PUSHORT NodeNumber
    );
BOOL
GetNumaProcessorNodeEx(
    PPROCESSOR_NUMBER Processor,
    PUSHORT NodeNumber
    );
BOOL
GetNumaNodeProcessorMask(
    UCHAR Node,
    PULONGLONG ProcessorMask
    );
BOOL
GetNumaNodeProcessorMaskEx(
    USHORT Node,
    PGROUP_AFFINITY ProcessorMask
    );
BOOL
GetNumaAvailableMemoryNode(
    UCHAR Node,
    PULONGLONG AvailableBytes
    );
BOOL
GetNumaAvailableMemoryNodeEx(
    USHORT Node,
    PULONGLONG AvailableBytes
    );
BOOL
GetNumaProximityNode(
    ULONG ProximityId,
    PUCHAR NodeNumber
    );
BOOL
GetNumaProximityNodeEx(
    ULONG ProximityId,
    PUSHORT NodeNumber
    );
//
// Application restart and data recovery callback
//
typedef DWORD ( *APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);
//
// Max length of commandline in characters (including the NULL character that can be registered for restart)
//
static const int RESTART_MAX_CMD_LINE = 1024;
//
// Do not restart the process for termination due to application crashes
//
static const int RESTART_NO_CRASH = 1;
//
// Do not restart the process for termination due to application hangs
//
static const int RESTART_NO_HANG = 2;
//
// Do not restart the process for termination due to patch installations
//
static const int RESTART_NO_PATCH = 4;
//
// Do not restart the process when the system is rebooted due to patch installations
//
static const int RESTART_NO_REBOOT = 8;
HRESULT
RegisterApplicationRecoveryCallback(
    APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
    PVOID pvParameter,
    DWORD dwPingInterval,
    DWORD dwFlags
    );
HRESULT
UnregisterApplicationRecoveryCallback(void);
HRESULT
RegisterApplicationRestart(
    PCWSTR pwzCommandline,
    DWORD dwFlags
    );
HRESULT
UnregisterApplicationRestart(void);
static const int RECOVERY_DEFAULT_PING_INTERVAL = 5000;
static const int RECOVERY_MAX_PING_INTERVAL = (5 * 60 * 1000);
HRESULT
GetApplicationRecoveryCallback(
    HANDLE hProcess,
    APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
    PVOID* ppvParameter,
    PDWORD pdwPingInterval,
    PDWORD pdwFlags
    );
HRESULT
GetApplicationRestartSettings(
    HANDLE hProcess,
    PWSTR pwzCommandline,
    PDWORD pcchSize,
    PDWORD pdwFlags
    );
HRESULT
ApplicationRecoveryInProgress(
    PBOOL pbCancelled
    );
void
ApplicationRecoveryFinished(
    BOOL bSuccess
    );
typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;
typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;
typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;
typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;
typedef struct _FILE_RENAME_INFO {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;
typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;
typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;
typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;
typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;
typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;
typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFileA;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;
typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;
typedef enum _PRIORITY_HINT {
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow,
      IoPriorityHintNormal,
      MaximumIoPriorityHintType
} PRIORITY_HINT;
typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;
// Structure and constants must match those in ntioapi_x.w
static const int REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK = 0x00000001;
static const int REMOTE_PROTOCOL_INFO_FLAG_OFFLINE = 0x00000002;
typedef struct _FILE_REMOTE_PROTOCOL_INFO
{
    // Structure Version
    USHORT StructureVersion; // 1
    USHORT StructureSize; // sizeof(FILE_REMOTE_PROTOCOL_INFO)
    DWORD Protocol; // Protocol (WNNC_NET_*) defined in wnnc.h or ntifs.h.
    // Protocol Version & Type
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;
    USHORT Reserved;
    // Protocol-Generic Information
    DWORD Flags;
    struct {
        DWORD Reserved[8];
    } GenericReserved;
    // Protocol specific information
    struct {
        DWORD Reserved[16];
    } ProtocolSpecificReserved;
} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;
BOOL
SetFileInformationByHandle(
    HANDLE hFile,
    FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
    LPVOID lpFileInformation,
    DWORD dwBufferSize
);
BOOL
GetFileInformationByHandleEx(
    HANDLE hFile,
    FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
    LPVOID lpFileInformation,
    DWORD dwBufferSize
);
typedef enum _FILE_ID_TYPE {
      FileIdType,
      ObjectIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;
typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize; // Size of the struct
    FILE_ID_TYPE Type; // Describes the type of identifier passed in.
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;
    } u;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;
HANDLE
OpenFileById (
    HANDLE hVolumeHint,
    LPFILE_ID_DESCRIPTOR lpFileId,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes
    );
//
//  Flags to be passed into CREATE_SYMBOLIC_LINK
//
static const int SYMBOLIC_LINK_FLAG_DIRECTORY = (0x1);
static const int VALID_SYMBOLIC_LINK_FLAGS = SYMBOLIC_LINK_FLAG_DIRECTORY;
BOOLEAN
CreateSymbolicLinkA (
    LPCSTR lpSymlinkFileName,
    LPCSTR lpTargetFileName,
    DWORD dwFlags
    );
BOOLEAN
CreateSymbolicLinkW (
    LPCWSTR lpSymlinkFileName,
    LPCWSTR lpTargetFileName,
    DWORD dwFlags
    );
static const int CreateSymbolicLink = CreateSymbolicLinkA;
BOOLEAN
CreateSymbolicLinkTransactedA (
    LPCSTR lpSymlinkFileName,
    LPCSTR lpTargetFileName,
    DWORD dwFlags,
    HANDLE hTransaction
    );
BOOLEAN
CreateSymbolicLinkTransactedW (
    LPCWSTR lpSymlinkFileName,
    LPCWSTR lpTargetFileName,
    DWORD dwFlags,
    HANDLE hTransaction
    );
static const int CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedA;
DWORD
GetFinalPathNameByHandleA (
    HANDLE hFile,
    LPSTR lpszFilePath,
    DWORD cchFilePath,
    DWORD dwFlags
);
DWORD
GetFinalPathNameByHandleW (
    HANDLE hFile,
    LPWSTR lpszFilePath,
    DWORD cchFilePath,
    DWORD dwFlags
);
static const int GetFinalPathNameByHandle = GetFinalPathNameByHandleA;
BOOL
QueryActCtxSettingsW(
    DWORD dwFlags,
    HANDLE hActCtx,
    PCWSTR settingsNameSpace,
    PCWSTR settingName,
    PWSTR pvBuffer,
    SIZE_T dwBuffer,
    SIZE_T *pdwWrittenOrRequired
    );
BOOL
ReplacePartitionUnit (
    PWSTR TargetPartition,
    PWSTR SparePartition,
    ULONG Flags
    );
BOOL
AddSecureMemoryCacheCallback(
    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );
BOOL
RemoveSecureMemoryCacheCallback(
    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );
BOOL
CopyExtendedContext(
    PCONTEXT_EX Destination,
    DWORD ContextFlags,
    PCONTEXT_EX Source
    );
BOOL
InitializeExtendedContext(
    PVOID Context,
    DWORD ContextFlags,
    PCONTEXT_EX* ContextEx
    );
DWORD64
GetEnabledExtendedFeatures(
    DWORD64 FeatureMask
    );
BOOL
GetExtendedContextLength(
    DWORD ContextFlags,
    PDWORD ContextLength
    );
DWORD64
GetExtendedFeaturesMask(
    PCONTEXT_EX ContextEx
    );
PVOID
LocateExtendedFeature(
    PCONTEXT_EX ContextEx,
    DWORD FeatureId,
    PDWORD Length
    );
PCONTEXT
LocateLegacyContext(
    PCONTEXT_EX ContextEx,
    PDWORD Length
    );
void
SetExtendedFeaturesMask(
    PCONTEXT_EX ContextEx,
    DWORD64 FeatureMask
    );
DWORD
EnableThreadProfiling(
    HANDLE ThreadHandle,
    DWORD Flags,
    DWORD64 HardwareCounters,
    HANDLE *PerformanceDataHandle
    );
DWORD
DisableThreadProfiling(
    HANDLE PerformanceDataHandle
    );
DWORD
QueryThreadProfiling(
    HANDLE ThreadHandle,
    PBOOLEAN Enabled
    );
DWORD
ReadThreadProfilingData(
    HANDLE PerformanceDataHandle,
    DWORD Flags,
    PPERFORMANCE_DATA PerformanceData
    );
# 15181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    winbase_interlockedcplusplus.h
Abstract:
    C++ function overloads in place of "manual name mangling".
    This file is meant to be #included by winbase.h or any other file declaring the signed interlocked functions.
Author:
    Jay Krell (JayKrell) April 2002
--*/
# 15203 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
/*
To turn off/hide the contents of this file:
 #define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
*/
# 15216 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
static const int MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS = (_WIN32_WINNT >= 0x0502 || !defined(_WINBASE_));
# 15457 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
static const int MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS = 0;
# 157 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 1
/**************************************************************************
*                                                                         *
* wingdi.h -- GDI procedure declarations, constant definitions and macros *
*                                                                         *
* Copyright (c) Microsoft Corp. All rights reserved.                      *
*                                                                         *
**************************************************************************/
# 10 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
//
// Define API decoration for direct importing of DLL references.
//
static const int WINGDIAPI = DECLSPEC_IMPORT;
//
// Define API decoration for direct importing of DLL references.
//
static const int WINSPOOLAPI = DECLSPEC_IMPORT;
# 57 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
/* Binary raster ops */
static const int R2_BLACK = 1;
static const int R2_NOTMERGEPEN = 2;
static const int R2_MASKNOTPEN = 3;
static const int R2_NOTCOPYPEN = 4;
static const int R2_MASKPENNOT = 5;
static const int R2_NOT = 6;
static const int R2_XORPEN = 7;
static const int R2_NOTMASKPEN = 8;
static const int R2_MASKPEN = 9;
static const int R2_NOTXORPEN = 10;
static const int R2_NOP = 11;
static const int R2_MERGENOTPEN = 12;
static const int R2_COPYPEN = 13;
static const int R2_MERGEPENNOT = 14;
static const int R2_MERGEPEN = 15;
static const int R2_WHITE = 16;
static const int R2_LAST = 16;
/* Ternary raster operations */
static const int SRCCOPY = (DWORD)0x00CC0020;
static const int SRCPAINT = (DWORD)0x00EE0086;
static const int SRCAND = (DWORD)0x008800C6;
static const int SRCINVERT = (DWORD)0x00660046;
static const int SRCERASE = (DWORD)0x00440328;
static const int NOTSRCCOPY = (DWORD)0x00330008;
static const int NOTSRCERASE = (DWORD)0x001100A6;
static const int MERGECOPY = (DWORD)0x00C000CA;
static const int MERGEPAINT = (DWORD)0x00BB0226;
static const int PATCOPY = (DWORD)0x00F00021;
static const int PATPAINT = (DWORD)0x00FB0A09;
static const int PATINVERT = (DWORD)0x005A0049;
static const int DSTINVERT = (DWORD)0x00550009;
static const int BLACKNESS = (DWORD)0x00000042;
static const int WHITENESS = (DWORD)0x00FF0062;
static const int NOMIRRORBITMAP = (DWORD)0x80000000;
static const int CAPTUREBLT = (DWORD)0x40000000;
/* Quaternary raster codes */
static const int MAKEROP4(fore,back) = (DWORD)((((back) << 8) & 0xFF000000) | (fore));
static const int GDI_ERROR = (0xFFFFFFFFL);
static const int HGDI_ERROR = (LongToHandle(0xFFFFFFFFL));
/* Region Flags */
static const int ERROR = 0;
static const int NULLREGION = 1;
static const int SIMPLEREGION = 2;
static const int COMPLEXREGION = 3;
static const int RGN_ERROR = ERROR;
/* CombineRgn() Styles */
static const int RGN_AND = 1;
static const int RGN_OR = 2;
static const int RGN_XOR = 3;
static const int RGN_DIFF = 4;
static const int RGN_COPY = 5;
static const int RGN_MIN = RGN_AND;
static const int RGN_MAX = RGN_COPY;
/* StretchBlt() Modes */
static const int BLACKONWHITE = 1;
static const int WHITEONBLACK = 2;
static const int COLORONCOLOR = 3;
static const int HALFTONE = 4;
static const int MAXSTRETCHBLTMODE = 4;
/* New StretchBlt() Modes */
static const int STRETCH_ANDSCANS = BLACKONWHITE;
static const int STRETCH_ORSCANS = WHITEONBLACK;
static const int STRETCH_DELETESCANS = COLORONCOLOR;
static const int STRETCH_HALFTONE = HALFTONE;
/* PolyFill() Modes */
static const int ALTERNATE = 1;
static const int WINDING = 2;
static const int POLYFILL_LAST = 2;
/* Layout Orientation Options */
static const int LAYOUT_RTL = 0x00000001;
static const int LAYOUT_BTT = 0x00000002;
static const int LAYOUT_VBH = 0x00000004;
static const int LAYOUT_ORIENTATIONMASK = (LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH);
static const int LAYOUT_BITMAPORIENTATIONPRESERVED = 0x00000008;
/* Text Alignment Options */
static const int TA_NOUPDATECP = 0;
static const int TA_UPDATECP = 1;
static const int TA_LEFT = 0;
static const int TA_RIGHT = 2;
static const int TA_CENTER = 6;
static const int TA_TOP = 0;
static const int TA_BOTTOM = 8;
static const int TA_BASELINE = 24;
static const int TA_RTLREADING = 256;
static const int TA_MASK = (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING);
static const int VTA_BASELINE = TA_BASELINE;
static const int VTA_LEFT = TA_BOTTOM;
static const int VTA_RIGHT = TA_TOP;
static const int VTA_CENTER = TA_CENTER;
static const int VTA_BOTTOM = TA_RIGHT;
static const int VTA_TOP = TA_LEFT;
static const int ETO_OPAQUE = 0x0002;
static const int ETO_CLIPPED = 0x0004;
static const int ETO_GLYPH_INDEX = 0x0010;
static const int ETO_RTLREADING = 0x0080;
static const int ETO_NUMERICSLOCAL = 0x0400;
static const int ETO_NUMERICSLATIN = 0x0800;
static const int ETO_IGNORELANGUAGE = 0x1000;
static const int ETO_PDY = 0x2000;
static const int ETO_REVERSE_INDEX_MAP = 0x10000;
static const int ASPECT_FILTERING = 0x0001;
/* Bounds Accumulation APIs */
static const int DCB_RESET = 0x0001;
static const int DCB_ACCUMULATE = 0x0002;
static const int DCB_DIRTY = DCB_ACCUMULATE;
static const int DCB_SET = (DCB_RESET | DCB_ACCUMULATE);
static const int DCB_ENABLE = 0x0004;
static const int DCB_DISABLE = 0x0008;
/* Metafile Functions */
static const int META_SETBKCOLOR = 0x0201;
static const int META_SETBKMODE = 0x0102;
static const int META_SETMAPMODE = 0x0103;
static const int META_SETROP2 = 0x0104;
static const int META_SETRELABS = 0x0105;
static const int META_SETPOLYFILLMODE = 0x0106;
static const int META_SETSTRETCHBLTMODE = 0x0107;
static const int META_SETTEXTCHAREXTRA = 0x0108;
static const int META_SETTEXTCOLOR = 0x0209;
static const int META_SETTEXTJUSTIFICATION = 0x020A;
static const int META_SETWINDOWORG = 0x020B;
static const int META_SETWINDOWEXT = 0x020C;
static const int META_SETVIEWPORTORG = 0x020D;
static const int META_SETVIEWPORTEXT = 0x020E;
static const double META_OFFSETWINDOWORG = 0x020F;
static const int META_SCALEWINDOWEXT = 0x0410;
static const int META_OFFSETVIEWPORTORG = 0x0211;
static const int META_SCALEVIEWPORTEXT = 0x0412;
static const int META_LINETO = 0x0213;
static const int META_MOVETO = 0x0214;
static const int META_EXCLUDECLIPRECT = 0x0415;
static const int META_INTERSECTCLIPRECT = 0x0416;
static const int META_ARC = 0x0817;
static const int META_ELLIPSE = 0x0418;
static const int META_FLOODFILL = 0x0419;
static const int META_PIE = 0x081A;
static const int META_RECTANGLE = 0x041B;
static const int META_ROUNDRECT = 0x061C;
static const int META_PATBLT = 0x061D;
static const int META_SAVEDC = 0x001E;
static const double META_SETPIXEL = 0x041F;
static const int META_OFFSETCLIPRGN = 0x0220;
static const int META_TEXTOUT = 0x0521;
static const int META_BITBLT = 0x0922;
static const int META_STRETCHBLT = 0x0B23;
static const int META_POLYGON = 0x0324;
static const int META_POLYLINE = 0x0325;
static const int META_ESCAPE = 0x0626;
static const int META_RESTOREDC = 0x0127;
static const int META_FILLREGION = 0x0228;
static const int META_FRAMEREGION = 0x0429;
static const int META_INVERTREGION = 0x012A;
static const int META_PAINTREGION = 0x012B;
static const int META_SELECTCLIPREGION = 0x012C;
static const int META_SELECTOBJECT = 0x012D;
static const int META_SETTEXTALIGN = 0x012E;
static const int META_CHORD = 0x0830;
static const int META_SETMAPPERFLAGS = 0x0231;
static const int META_EXTTEXTOUT = 0x0a32;
static const int META_SETDIBTODEV = 0x0d33;
static const int META_SELECTPALETTE = 0x0234;
static const int META_REALIZEPALETTE = 0x0035;
static const int META_ANIMATEPALETTE = 0x0436;
static const int META_SETPALENTRIES = 0x0037;
static const int META_POLYPOLYGON = 0x0538;
static const int META_RESIZEPALETTE = 0x0139;
static const int META_DIBBITBLT = 0x0940;
static const int META_DIBSTRETCHBLT = 0x0b41;
static const int META_DIBCREATEPATTERNBRUSH = 0x0142;
static const int META_STRETCHDIB = 0x0f43;
static const int META_EXTFLOODFILL = 0x0548;
static const int META_SETLAYOUT = 0x0149;
static const int META_DELETEOBJECT = 0x01f0;
static const int META_CREATEPALETTE = 0x00f7;
static const int META_CREATEPATTERNBRUSH = 0x01F9;
static const int META_CREATEPENINDIRECT = 0x02FA;
static const int META_CREATEFONTINDIRECT = 0x02FB;
static const int META_CREATEBRUSHINDIRECT = 0x02FC;
static const int META_CREATEREGION = 0x06FF;
typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
/* GDI Escapes */
static const int NEWFRAME = 1;
static const int ABORTDOC = 2;
static const int NEXTBAND = 3;
static const int SETCOLORTABLE = 4;
static const int GETCOLORTABLE = 5;
static const int FLUSHOUTPUT = 6;
static const int DRAFTMODE = 7;
static const int QUERYESCSUPPORT = 8;
static const int SETABORTPROC = 9;
static const int STARTDOC = 10;
static const int ENDDOC = 11;
static const int GETPHYSPAGESIZE = 12;
static const int GETPRINTINGOFFSET = 13;
static const int GETSCALINGFACTOR = 14;
static const int MFCOMMENT = 15;
static const int GETPENWIDTH = 16;
static const int SETCOPYCOUNT = 17;
static const int SELECTPAPERSOURCE = 18;
static const int DEVICEDATA = 19;
static const int PASSTHROUGH = 19;
static const int GETTECHNOLGY = 20;
static const int GETTECHNOLOGY = 20;
static const int SETLINECAP = 21;
static const int SETLINEJOIN = 22;
static const int SETMITERLIMIT = 23;
static const int BANDINFO = 24;
static const int DRAWPATTERNRECT = 25;
static const int GETVECTORPENSIZE = 26;
static const int GETVECTORBRUSHSIZE = 27;
static const int ENABLEDUPLEX = 28;
static const int GETSETPAPERBINS = 29;
static const int GETSETPRINTORIENT = 30;
static const int ENUMPAPERBINS = 31;
static const int SETDIBSCALING = 32;
static const int EPSPRINTING = 33;
static const int ENUMPAPERMETRICS = 34;
static const int GETSETPAPERMETRICS = 35;
static const int POSTSCRIPT_DATA = 37;
static const int POSTSCRIPT_IGNORE = 38;
static const int MOUSETRAILS = 39;
static const int GETDEVICEUNITS = 42;
static const int GETEXTENDEDTEXTMETRICS = 256;
static const int GETEXTENTTABLE = 257;
static const int GETPAIRKERNTABLE = 258;
static const int GETTRACKKERNTABLE = 259;
static const int EXTTEXTOUT = 512;
static const int GETFACENAME = 513;
static const int DOWNLOADFACE = 514;
static const int ENABLERELATIVEWIDTHS = 768;
static const int ENABLEPAIRKERNING = 769;
static const int SETKERNTRACK = 770;
static const int SETALLJUSTVALUES = 771;
static const int SETCHARSET = 772;
static const int STRETCHBLT = 2048;
static const int METAFILE_DRIVER = 2049;
static const int GETSETSCREENPARAMS = 3072;
static const int QUERYDIBSUPPORT = 3073;
static const int BEGIN_PATH = 4096;
static const int CLIP_TO_PATH = 4097;
static const int END_PATH = 4098;
static const int EXT_DEVICE_CAPS = 4099;
static const int RESTORE_CTM = 4100;
static const int SAVE_CTM = 4101;
static const int SET_ARC_DIRECTION = 4102;
static const int SET_BACKGROUND_COLOR = 4103;
static const int SET_POLY_MODE = 4104;
static const int SET_SCREEN_ANGLE = 4105;
static const int SET_SPREAD = 4106;
static const int TRANSFORM_CTM = 4107;
static const int SET_CLIP_BOX = 4108;
static const int SET_BOUNDS = 4109;
static const int SET_MIRROR_MODE = 4110;
static const int OPENCHANNEL = 4110;
static const int DOWNLOADHEADER = 4111;
static const int CLOSECHANNEL = 4112;
static const int POSTSCRIPT_PASSTHROUGH = 4115;
static const int ENCAPSULATED_POSTSCRIPT = 4116;
static const int POSTSCRIPT_IDENTIFY = 4117;
static const int POSTSCRIPT_INJECTION = 4118;
static const int CHECKJPEGFORMAT = 4119;
static const int CHECKPNGFORMAT = 4120;
static const int GET_PS_FEATURESETTING = 4121;
static const int GDIPLUS_TS_QUERYVER = 4122;
static const int GDIPLUS_TS_RECORD = 4123;
/*
 * Return Values for MILCORE_TS_QUERYVER
 */
static const int MILCORE_TS_QUERYVER_RESULT_FALSE = 0x0;
static const int MILCORE_TS_QUERYVER_RESULT_TRUE = 0x7FFFFFFF;
static const int SPCLPASSTHROUGH2 = 4568;
/*
 * Parameters for POSTSCRIPT_IDENTIFY escape
 */
# 402 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
static const int PSIDENT_GDICENTRIC = 0;
static const int PSIDENT_PSCENTRIC = 1;
/*
 * Header structure for the input buffer to POSTSCRIPT_INJECTION escape
 */
# 409 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct _PSINJECTDATA {
    DWORD DataBytes; /* number of raw data bytes (NOT including this header) */
    WORD InjectionPoint; /* injection point */
    WORD PageNumber; /* page number to apply the injection */
    /* Followed by raw data to be injected */
} PSINJECTDATA, *PPSINJECTDATA;
/*
 * Constants for PSINJECTDATA.InjectionPoint field
 */
# 423 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
static const int PSINJECT_BEGINSTREAM = 1;
static const int PSINJECT_PSADOBE = 2;
static const int PSINJECT_PAGESATEND = 3;
static const int PSINJECT_PAGES = 4;
static const int PSINJECT_DOCNEEDEDRES = 5;
static const int PSINJECT_DOCSUPPLIEDRES = 6;
static const int PSINJECT_PAGEORDER = 7;
static const int PSINJECT_ORIENTATION = 8;
static const int PSINJECT_BOUNDINGBOX = 9;
static const int PSINJECT_DOCUMENTPROCESSCOLORS = 10;
static const int PSINJECT_COMMENTS = 11;
static const int PSINJECT_BEGINDEFAULTS = 12;
static const int PSINJECT_ENDDEFAULTS = 13;
static const int PSINJECT_BEGINPROLOG = 14;
static const int PSINJECT_ENDPROLOG = 15;
static const int PSINJECT_BEGINSETUP = 16;
static const int PSINJECT_ENDSETUP = 17;
static const int PSINJECT_TRAILER = 18;
static const int PSINJECT_EOF = 19;
static const int PSINJECT_ENDSTREAM = 20;
static const int PSINJECT_DOCUMENTPROCESSCOLORSATEND = 21;
static const int PSINJECT_PAGENUMBER = 100;
static const int PSINJECT_BEGINPAGESETUP = 101;
static const int PSINJECT_ENDPAGESETUP = 102;
static const int PSINJECT_PAGETRAILER = 103;
static const int PSINJECT_PLATECOLOR = 104;
static const int PSINJECT_SHOWPAGE = 105;
static const int PSINJECT_PAGEBBOX = 106;
static const int PSINJECT_ENDPAGECOMMENTS = 107;
static const int PSINJECT_VMSAVE = 200;
static const int PSINJECT_VMRESTORE = 201;
/*
 * InjectionPoint for publisher mode PScript5 OEM plugin to
 * generate DSC comment for included font resource
 */
# 464 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
static const int PSINJECT_DLFONT = 0xdddddddd;
/*
 * Parameter for GET_PS_FEATURESETTING escape
 */
# 470 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
static const int FEATURESETTING_NUP = 0;
static const int FEATURESETTING_OUTPUT = 1;
static const int FEATURESETTING_PSLEVEL = 2;
static const int FEATURESETTING_CUSTPAPER = 3;
static const int FEATURESETTING_MIRROR = 4;
static const int FEATURESETTING_NEGATIVE = 5;
static const int FEATURESETTING_PROTOCOL = 6;
//
// The range of selectors between FEATURESETTING_PRIVATE_BEGIN and
// FEATURESETTING_PRIVATE_END is reserved by Microsoft for private use
//
static const int FEATURESETTING_PRIVATE_BEGIN = 0x1000;
static const int FEATURESETTING_PRIVATE_END = 0x1FFF;
/*
 * Information about output options
 */
# 491 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct _PSFEATURE_OUTPUT {
    BOOL bPageIndependent;
    BOOL bSetPageDevice;
} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;
/*
 * Information about custom paper size
 */
# 502 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct _PSFEATURE_CUSTPAPER {
    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;
} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;
/* Value returned for FEATURESETTING_PROTOCOL */
static const int PSPROTOCOL_ASCII = 0;
static const int PSPROTOCOL_BCP = 1;
static const int PSPROTOCOL_TBCP = 2;
static const int PSPROTOCOL_BINARY = 3;
/* Flag returned from QUERYDIBSUPPORT */
static const int QDI_SETDIBITS = 1;
static const int QDI_GETDIBITS = 2;
static const int QDI_DIBTOSCREEN = 4;
static const int QDI_STRETCHDIB = 8;
/* Spooler Error Codes */
static const int SP_NOTREPORTED = 0x4000;
static const int SP_ERROR = (-1);
static const int SP_APPABORT = (-2);
static const int SP_USERABORT = (-3);
static const int SP_OUTOFDISK = (-4);
static const int SP_OUTOFMEMORY = (-5);
static const int PR_JOBSTATUS = 0x0000;
/* Object Definitions for EnumObjects() */
static const int OBJ_PEN = 1;
static const int OBJ_BRUSH = 2;
static const int OBJ_DC = 3;
static const int OBJ_METADC = 4;
static const int OBJ_PAL = 5;
static const int OBJ_FONT = 6;
static const int OBJ_BITMAP = 7;
static const int OBJ_REGION = 8;
static const int OBJ_METAFILE = 9;
static const int OBJ_MEMDC = 10;
static const int OBJ_EXTPEN = 11;
static const int OBJ_ENHMETADC = 12;
static const int OBJ_ENHMETAFILE = 13;
static const int OBJ_COLORSPACE = 14;
static const int GDI_OBJ_LAST = OBJ_COLORSPACE;
/* xform stuff */
static const int MWT_IDENTITY = 1;
static const int MWT_LEFTMULTIPLY = 2;
static const int MWT_RIGHTMULTIPLY = 3;
static const int MWT_MIN = MWT_IDENTITY;
static const int MWT_MAX = MWT_RIGHTMULTIPLY;
typedef struct tagXFORM
  {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
  } XFORM, *PXFORM, *LPXFORM;
/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    LPVOID bmBits;
  } BITMAP, *PBITMAP, *NPBITMAP, *LPBITMAP;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack1.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack1.h
Abstract:
    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack1.h"
#pragma pack(1)
# 584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagRGBTRIPLE {
        BYTE rgbtBlue;
        BYTE rgbtGreen;
        BYTE rgbtRed;
} RGBTRIPLE, *PRGBTRIPLE, *NPRGBTRIPLE, *LPRGBTRIPLE;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 590 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagRGBQUAD {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbReserved;
} RGBQUAD;
typedef RGBQUAD * LPRGBQUAD;
/* Image Color Matching color definitions */
static const long CS_ENABLE = 0x00000001L;
static const long CS_DISABLE = 0x00000002L;
static const long CS_DELETE_TRANSFORM = 0x00000003L;
/* Logcolorspace signature */
static const int LCS_SIGNATURE = 'PSOC';
/* Logcolorspace lcsType values */
static const int LCS_sRGB = 'sRGB';
static const int LCS_WINDOWS_COLOR_SPACE = 'Win ';
typedef LONG LCSCSTYPE;
static const long LCS_CALIBRATED_RGB = 0x00000000L;
typedef LONG LCSGAMUTMATCH;
static const long LCS_GM_BUSINESS = 0x00000001L;
static const long LCS_GM_GRAPHICS = 0x00000002L;
static const long LCS_GM_IMAGES = 0x00000004L;
static const long LCS_GM_ABS_COLORIMETRIC = 0x00000008L;
/* ICM Defines for results from CheckColorInGamut() */
static const int CM_OUT_OF_GAMUT = 255;
static const int CM_IN_GAMUT = 0;
/* UpdateICMRegKey Constants               */
static const int ICM_ADDPROFILE = 1;
static const int ICM_DELETEPROFILE = 2;
static const int ICM_QUERYPROFILE = 3;
static const int ICM_SETDEFAULTPROFILE = 4;
static const int ICM_REGISTERICMATCHER = 5;
static const int ICM_UNREGISTERICMATCHER = 6;
static const int ICM_QUERYMATCH = 7;
/* Macros to retrieve CMYK values from a COLORREF */
static const int GetKValue(cmyk) = ((BYTE)(cmyk));
static const int GetYValue(cmyk) = ((BYTE)((cmyk)>> 8));
static const int GetMValue(cmyk) = ((BYTE)((cmyk)>>16));
static const int GetCValue(cmyk) = ((BYTE)((cmyk)>>24));
static const int CMYK(c,m,y,k) = ((COLORREF)((((BYTE)(k)|((WORD)((BYTE)(y))<<8))|(((DWORD)(BYTE)(m))<<16))|(((DWORD)(BYTE)(c))<<24)));
typedef long FXPT16DOT16, *LPFXPT16DOT16;
typedef long FXPT2DOT30, *LPFXPT2DOT30;
/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of CIEXYZ.
typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ *LPCIEXYZ;
typedef struct tagICEXYZTRIPLE
{
        CIEXYZ ciexyzRed;
        CIEXYZ ciexyzGreen;
        CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE *LPCIEXYZTRIPLE;
// The next structures the logical color space. Unlike pens and brushes,
// but like palettes, there is only one way to create a LogColorSpace.
// A pointer to it must be passed, its elements can't be pushed as
// arguments.
typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;
typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;
/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD bcSize; /* used to get to color table */
        WORD bcWidth;
        WORD bcHeight;
        WORD bcPlanes;
        WORD bcBitCount;
} BITMAPCOREHEADER, *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;
typedef struct tagBITMAPINFOHEADER{
        DWORD biSize;
        LONG biWidth;
        LONG biHeight;
        WORD biPlanes;
        WORD biBitCount;
        DWORD biCompression;
        DWORD biSizeImage;
        LONG biXPelsPerMeter;
        LONG biYPelsPerMeter;
        DWORD biClrUsed;
        DWORD biClrImportant;
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;
typedef struct {
        DWORD bV4Size;
        LONG bV4Width;
        LONG bV4Height;
        WORD bV4Planes;
        WORD bV4BitCount;
        DWORD bV4V4Compression;
        DWORD bV4SizeImage;
        LONG bV4XPelsPerMeter;
        LONG bV4YPelsPerMeter;
        DWORD bV4ClrUsed;
        DWORD bV4ClrImportant;
        DWORD bV4RedMask;
        DWORD bV4GreenMask;
        DWORD bV4BlueMask;
        DWORD bV4AlphaMask;
        DWORD bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD bV4GammaRed;
        DWORD bV4GammaGreen;
        DWORD bV4GammaBlue;
} BITMAPV4HEADER, *LPBITMAPV4HEADER, *PBITMAPV4HEADER;
typedef struct {
        DWORD bV5Size;
        LONG bV5Width;
        LONG bV5Height;
        WORD bV5Planes;
        WORD bV5BitCount;
        DWORD bV5Compression;
        DWORD bV5SizeImage;
        LONG bV5XPelsPerMeter;
        LONG bV5YPelsPerMeter;
        DWORD bV5ClrUsed;
        DWORD bV5ClrImportant;
        DWORD bV5RedMask;
        DWORD bV5GreenMask;
        DWORD bV5BlueMask;
        DWORD bV5AlphaMask;
        DWORD bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD bV5GammaRed;
        DWORD bV5GammaGreen;
        DWORD bV5GammaBlue;
        DWORD bV5Intent;
        DWORD bV5ProfileData;
        DWORD bV5ProfileSize;
        DWORD bV5Reserved;
} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;
// Values for bV5CSType
static const int PROFILE_LINKED = 'LINK';
static const int PROFILE_EMBEDDED = 'MBED';
/* constants for the biCompression field */
static const long BI_RGB = 0L;
static const long BI_RLE8 = 1L;
static const long BI_RLE4 = 2L;
static const long BI_BITFIELDS = 3L;
static const long BI_JPEG = 4L;
static const long BI_PNG = 5L;
typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[1];
} BITMAPINFO, *LPBITMAPINFO, *PBITMAPINFO;
typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO, *LPBITMAPCOREINFO, *PBITMAPCOREINFO;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack2.h
Abstract:
    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 809 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagBITMAPFILEHEADER {
        WORD bfType;
        DWORD bfSize;
        WORD bfReserved1;
        WORD bfReserved2;
        DWORD bfOffBits;
} BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 817 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
static const int MAKEPOINTS(l) = (*((POINTS FAR *)&(l)));
typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;
typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO, *NPCHARSETINFO, *LPCHARSETINFO;
static const int TCI_SRCCHARSET = 1;
static const int TCI_SRCCODEPAGE = 2;
static const int TCI_SRCFONTSIG = 3;
static const int TCI_SRCLOCALE = 0x1000;
typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;
/* Clipboard Metafile Picture Structure */
typedef struct tagHANDLETABLE
  {
    HGDIOBJ objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE, *LPHANDLETABLE;
typedef struct tagMETARECORD
  {
    DWORD rdSize;
    WORD rdFunction;
    WORD rdParm[1];
  } METARECORD;
typedef struct tagMETARECORD *PMETARECORD;
typedef struct tagMETARECORD *LPMETARECORD;
typedef struct tagMETAFILEPICT
  {
    LONG mm;
    LONG xExt;
    LONG yExt;
    HMETAFILE hMF;
  } METAFILEPICT, *LPMETAFILEPICT;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack2.h
Abstract:
    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 879 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagMETAHEADER
{
    WORD mtType;
    WORD mtHeaderSize;
    WORD mtVersion;
    DWORD mtSize;
    WORD mtNoObjects;
    DWORD mtMaxRecord;
    WORD mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER *PMETAHEADER;
typedef struct tagMETAHEADER *LPMETAHEADER;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 893 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
/* Enhanced Metafile structures */
typedef struct tagENHMETARECORD
{
    DWORD iType; // Record type EMR_XXX
    DWORD nSize; // Record size in bytes
    DWORD dParm[1]; // Parameters
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;
typedef struct tagENHMETAHEADER
{
    DWORD iType; // Record typeEMR_HEADER
    DWORD nSize; // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    RECTL rclFrame; // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD dSignature; // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD nVersion; // Version number
    DWORD nBytes; // Size of the metafile in bytes
    DWORD nRecords; // Number of records in the metafile
    WORD nHandles; // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD sReserved; // Reserved.  Must be zero.
    DWORD nDescription; // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD offDescription; // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD nPalEntries; // Number of entries in the metafile palette.
    SIZEL szlDevice; // Size of the reference device in pels
    SIZEL szlMillimeters; // Size of the reference device in millimeters
    DWORD cbPixelFormat; // Size of PIXELFORMATDESCRIPTOR information
                                // This is 0 if no pixel format is set
    DWORD offPixelFormat; // Offset to PIXELFORMATDESCRIPTOR
                                // This is 0 if no pixel format is set
    DWORD bOpenGL; // TRUE if OpenGL commands are present in
                                // the metafile, otherwise FALSE
    SIZEL szlMicrometers; // Size of the reference device in micrometers
} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;
/* tmPitchAndFamily flags */
static const int TMPF_FIXED_PITCH = 0x01;
static const int TMPF_VECTOR = 0x02;
static const int TMPF_DEVICE = 0x08;
static const int TMPF_TRUETYPE = 0x04;
//
// BCHAR definition for APPs
//
    typedef BYTE BCHAR;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack4.h
Abstract:
    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 959 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagTEXTMETRICA
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA, *NPTEXTMETRICA, *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW, *NPTEXTMETRICW, *LPTEXTMETRICW;
typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 1017 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
/* ntmFlags field flags */
static const long NTM_REGULAR = 0x00000040L;
static const long NTM_BOLD = 0x00000020L;
static const long NTM_ITALIC = 0x00000001L;
/* new in NT 5.0 */
static const int NTM_NONNEGATIVE_AC = 0x00010000;
static const int NTM_PS_OPENTYPE = 0x00020000;
static const int NTM_TT_OPENTYPE = 0x00040000;
static const int NTM_MULTIPLEMASTER = 0x00080000;
static const int NTM_TYPE1 = 0x00100000;
static const int NTM_DSIG = 0x00200000;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack4.h
Abstract:
    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 1034 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagNEWTEXTMETRICA
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, *NPNEWTEXTMETRICA, *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW, *NPNEWTEXTMETRICW, *LPNEWTEXTMETRICW;
typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 1100 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA ntmTm;
    FONTSIGNATURE ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW ntmTm;
    FONTSIGNATURE ntmFontSig;
}NEWTEXTMETRICEXW;
typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
/* GDI Logical Objects: */
/* Pel Array */
typedef struct tagPELARRAY
  {
    LONG paXCount;
    LONG paYCount;
    LONG paXExt;
    LONG paYExt;
    BYTE paRGBs;
  } PELARRAY, *PPELARRAY, *NPPELARRAY, *LPPELARRAY;
/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG_PTR lbHatch;
  } LOGBRUSH, *PLOGBRUSH, *NPLOGBRUSH, *LPLOGBRUSH;
typedef struct tagLOGBRUSH32
  {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;
typedef LOGBRUSH PATTERN;
typedef PATTERN *PPATTERN;
typedef PATTERN *NPPATTERN;
typedef PATTERN *LPPATTERN;
/* Logical Pen */
typedef struct tagLOGPEN
  {
    UINT lopnStyle;
    POINT lopnWidth;
    COLORREF lopnColor;
  } LOGPEN, *PLOGPEN, *NPLOGPEN, *LPLOGPEN;
typedef struct tagEXTLOGPEN {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG_PTR elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN, *NPEXTLOGPEN, *LPEXTLOGPEN;
typedef struct tagEXTLOGPEN32 {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32, *NPEXTLOGPEN32, *LPEXTLOGPEN32;
typedef struct tagPALETTEENTRY {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
} PALETTEENTRY, *PPALETTEENTRY, *LPPALETTEENTRY;
/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD palVersion;
    WORD palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE, *NPLOGPALETTE, *LPLOGPALETTE;
/* Logical Font */
static const int LF_FACESIZE = 32;
typedef struct tagLOGFONTA
{
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[32];
} LOGFONTA, *PLOGFONTA, *NPLOGFONTA, *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[32];
} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;
typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
static const int LF_FULLFACESIZE = 64;
/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
} ENUMLOGFONTA, * LPENUMLOGFONTA;
/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
} ENUMLOGFONTW, * LPENUMLOGFONTW;
typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;
typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    BYTE elfScript[32];
} ENUMLOGFONTEXA, *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    WCHAR elfScript[32];
} ENUMLOGFONTEXW, *LPENUMLOGFONTEXW;
typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;
static const int OUT_DEFAULT_PRECIS = 0;
static const int OUT_STRING_PRECIS = 1;
static const int OUT_CHARACTER_PRECIS = 2;
static const int OUT_STROKE_PRECIS = 3;
static const int OUT_TT_PRECIS = 4;
static const int OUT_DEVICE_PRECIS = 5;
static const int OUT_RASTER_PRECIS = 6;
static const int OUT_TT_ONLY_PRECIS = 7;
static const int OUT_OUTLINE_PRECIS = 8;
static const int OUT_SCREEN_OUTLINE_PRECIS = 9;
static const int OUT_PS_ONLY_PRECIS = 10;
static const int CLIP_DEFAULT_PRECIS = 0;
static const int CLIP_CHARACTER_PRECIS = 1;
static const int CLIP_STROKE_PRECIS = 2;
static const int CLIP_MASK = 0xf;
static const int CLIP_LH_ANGLES = (1<<4);
static const int CLIP_TT_ALWAYS = (2<<4);
static const int CLIP_DFA_DISABLE = (4<<4);
static const int CLIP_EMBEDDED = (8<<4);
static const int DEFAULT_QUALITY = 0;
static const int DRAFT_QUALITY = 1;
static const int PROOF_QUALITY = 2;
static const int NONANTIALIASED_QUALITY = 3;
static const int ANTIALIASED_QUALITY = 4;
static const int CLEARTYPE_QUALITY = 5;
static const int CLEARTYPE_NATURAL_QUALITY = 6;
static const int DEFAULT_PITCH = 0;
static const int FIXED_PITCH = 1;
static const int VARIABLE_PITCH = 2;
static const int MONO_FONT = 8;
static const int ANSI_CHARSET = 0;
static const int DEFAULT_CHARSET = 1;
static const int SYMBOL_CHARSET = 2;
static const int SHIFTJIS_CHARSET = 128;
static const int HANGEUL_CHARSET = 129;
static const int HANGUL_CHARSET = 129;
static const int GB2312_CHARSET = 134;
static const int CHINESEBIG5_CHARSET = 136;
static const int OEM_CHARSET = 255;
static const int JOHAB_CHARSET = 130;
static const int HEBREW_CHARSET = 177;
static const int ARABIC_CHARSET = 178;
static const int GREEK_CHARSET = 161;
static const int TURKISH_CHARSET = 162;
static const int VIETNAMESE_CHARSET = 163;
static const int THAI_CHARSET = 222;
static const int EASTEUROPE_CHARSET = 238;
static const int RUSSIAN_CHARSET = 204;
static const int MAC_CHARSET = 77;
static const int BALTIC_CHARSET = 186;
static const long FS_LATIN1 = 0x00000001L;
static const long FS_LATIN2 = 0x00000002L;
static const long FS_CYRILLIC = 0x00000004L;
static const long FS_GREEK = 0x00000008L;
static const long FS_TURKISH = 0x00000010L;
static const long FS_HEBREW = 0x00000020L;
static const long FS_ARABIC = 0x00000040L;
static const long FS_BALTIC = 0x00000080L;
static const long FS_VIETNAMESE = 0x00000100L;
static const long FS_THAI = 0x00010000L;
static const long FS_JISJAPAN = 0x00020000L;
static const long FS_CHINESESIMP = 0x00040000L;
static const long FS_WANSUNG = 0x00080000L;
static const long FS_CHINESETRAD = 0x00100000L;
static const long FS_JOHAB = 0x00200000L;
static const long FS_SYMBOL = 0x80000000L;
/* Font Families */
static const int FF_DONTCARE = (0<<4);
static const int FF_ROMAN = (1<<4);
                                    /* Times Roman, Century Schoolbook, etc. */
static const int FF_SWISS = (2<<4);
                                    /* Helvetica, Swiss, etc. */
static const int FF_MODERN = (3<<4);
                                    /* Pica, Elite, Courier, etc. */
static const int FF_SCRIPT = (4<<4);
static const int FF_DECORATIVE = (5<<4);
/* Font Weights */
static const int FW_DONTCARE = 0;
static const int FW_THIN = 100;
static const int FW_EXTRALIGHT = 200;
static const int FW_LIGHT = 300;
static const int FW_NORMAL = 400;
static const int FW_MEDIUM = 500;
static const int FW_SEMIBOLD = 600;
static const int FW_BOLD = 700;
static const int FW_EXTRABOLD = 800;
static const int FW_HEAVY = 900;
static const int FW_ULTRALIGHT = FW_EXTRALIGHT;
static const int FW_REGULAR = FW_NORMAL;
static const int FW_DEMIBOLD = FW_SEMIBOLD;
static const int FW_ULTRABOLD = FW_EXTRABOLD;
static const int FW_BLACK = FW_HEAVY;
static const int PANOSE_COUNT = 10;
static const int PAN_FAMILYTYPE_INDEX = 0;
static const int PAN_SERIFSTYLE_INDEX = 1;
static const int PAN_WEIGHT_INDEX = 2;
static const int PAN_PROPORTION_INDEX = 3;
static const int PAN_CONTRAST_INDEX = 4;
static const int PAN_STROKEVARIATION_INDEX = 5;
static const int PAN_ARMSTYLE_INDEX = 6;
static const int PAN_LETTERFORM_INDEX = 7;
static const int PAN_MIDLINE_INDEX = 8;
static const int PAN_XHEIGHT_INDEX = 9;
static const int PAN_CULTURE_LATIN = 0;
typedef struct tagPANOSE
{
    BYTE bFamilyType;
    BYTE bSerifStyle;
    BYTE bWeight;
    BYTE bProportion;
    BYTE bContrast;
    BYTE bStrokeVariation;
    BYTE bArmStyle;
    BYTE bLetterform;
    BYTE bMidline;
    BYTE bXHeight;
} PANOSE, * LPPANOSE;
static const int PAN_ANY = 0;
static const int PAN_NO_FIT = 1;
static const int PAN_FAMILY_TEXT_DISPLAY = 2;
static const int PAN_FAMILY_SCRIPT = 3;
static const int PAN_FAMILY_DECORATIVE = 4;
static const int PAN_FAMILY_PICTORIAL = 5;
static const int PAN_SERIF_COVE = 2;
static const int PAN_SERIF_OBTUSE_COVE = 3;
static const int PAN_SERIF_SQUARE_COVE = 4;
static const int PAN_SERIF_OBTUSE_SQUARE_COVE = 5;
static const int PAN_SERIF_SQUARE = 6;
static const int PAN_SERIF_THIN = 7;
static const int PAN_SERIF_BONE = 8;
static const int PAN_SERIF_EXAGGERATED = 9;
static const int PAN_SERIF_TRIANGLE = 10;
static const int PAN_SERIF_NORMAL_SANS = 11;
static const int PAN_SERIF_OBTUSE_SANS = 12;
static const int PAN_SERIF_PERP_SANS = 13;
static const int PAN_SERIF_FLARED = 14;
static const int PAN_SERIF_ROUNDED = 15;
static const int PAN_WEIGHT_VERY_LIGHT = 2;
static const int PAN_WEIGHT_LIGHT = 3;
static const int PAN_WEIGHT_THIN = 4;
static const int PAN_WEIGHT_BOOK = 5;
static const int PAN_WEIGHT_MEDIUM = 6;
static const int PAN_WEIGHT_DEMI = 7;
static const int PAN_WEIGHT_BOLD = 8;
static const int PAN_WEIGHT_HEAVY = 9;
static const int PAN_WEIGHT_BLACK = 10;
static const int PAN_WEIGHT_NORD = 11;
static const int PAN_PROP_OLD_STYLE = 2;
static const int PAN_PROP_MODERN = 3;
static const int PAN_PROP_EVEN_WIDTH = 4;
static const int PAN_PROP_EXPANDED = 5;
static const int PAN_PROP_CONDENSED = 6;
static const int PAN_PROP_VERY_EXPANDED = 7;
static const int PAN_PROP_VERY_CONDENSED = 8;
static const int PAN_PROP_MONOSPACED = 9;
static const int PAN_CONTRAST_NONE = 2;
static const int PAN_CONTRAST_VERY_LOW = 3;
static const int PAN_CONTRAST_LOW = 4;
static const int PAN_CONTRAST_MEDIUM_LOW = 5;
static const int PAN_CONTRAST_MEDIUM = 6;
static const int PAN_CONTRAST_MEDIUM_HIGH = 7;
static const int PAN_CONTRAST_HIGH = 8;
static const int PAN_CONTRAST_VERY_HIGH = 9;
static const int PAN_STROKE_GRADUAL_DIAG = 2;
static const int PAN_STROKE_GRADUAL_TRAN = 3;
static const int PAN_STROKE_GRADUAL_VERT = 4;
static const int PAN_STROKE_GRADUAL_HORZ = 5;
static const int PAN_STROKE_RAPID_VERT = 6;
static const int PAN_STROKE_RAPID_HORZ = 7;
static const int PAN_STROKE_INSTANT_VERT = 8;
static const int PAN_STRAIGHT_ARMS_HORZ = 2;
static const int PAN_STRAIGHT_ARMS_WEDGE = 3;
static const int PAN_STRAIGHT_ARMS_VERT = 4;
static const int PAN_STRAIGHT_ARMS_SINGLE_SERIF = 5;
static const int PAN_STRAIGHT_ARMS_DOUBLE_SERIF = 6;
static const int PAN_BENT_ARMS_HORZ = 7;
static const int PAN_BENT_ARMS_WEDGE = 8;
static const int PAN_BENT_ARMS_VERT = 9;
static const int PAN_BENT_ARMS_SINGLE_SERIF = 10;
static const int PAN_BENT_ARMS_DOUBLE_SERIF = 11;
static const int PAN_LETT_NORMAL_CONTACT = 2;
static const int PAN_LETT_NORMAL_WEIGHTED = 3;
static const int PAN_LETT_NORMAL_BOXED = 4;
static const int PAN_LETT_NORMAL_FLATTENED = 5;
static const int PAN_LETT_NORMAL_ROUNDED = 6;
static const int PAN_LETT_NORMAL_OFF_CENTER = 7;
static const int PAN_LETT_NORMAL_SQUARE = 8;
static const int PAN_LETT_OBLIQUE_CONTACT = 9;
static const int PAN_LETT_OBLIQUE_WEIGHTED = 10;
static const int PAN_LETT_OBLIQUE_BOXED = 11;
static const int PAN_LETT_OBLIQUE_FLATTENED = 12;
static const int PAN_LETT_OBLIQUE_ROUNDED = 13;
static const int PAN_LETT_OBLIQUE_OFF_CENTER = 14;
static const int PAN_LETT_OBLIQUE_SQUARE = 15;
static const int PAN_MIDLINE_STANDARD_TRIMMED = 2;
static const int PAN_MIDLINE_STANDARD_POINTED = 3;
static const int PAN_MIDLINE_STANDARD_SERIFED = 4;
static const int PAN_MIDLINE_HIGH_TRIMMED = 5;
static const int PAN_MIDLINE_HIGH_POINTED = 6;
static const int PAN_MIDLINE_HIGH_SERIFED = 7;
static const int PAN_MIDLINE_CONSTANT_TRIMMED = 8;
static const int PAN_MIDLINE_CONSTANT_POINTED = 9;
static const int PAN_MIDLINE_CONSTANT_SERIFED = 10;
static const int PAN_MIDLINE_LOW_TRIMMED = 11;
static const int PAN_MIDLINE_LOW_POINTED = 12;
static const int PAN_MIDLINE_LOW_SERIFED = 13;
static const int PAN_XHEIGHT_CONSTANT_SMALL = 2;
static const int PAN_XHEIGHT_CONSTANT_STD = 3;
static const int PAN_XHEIGHT_CONSTANT_LARGE = 4;
static const int PAN_XHEIGHT_DUCKING_SMALL = 5;
static const int PAN_XHEIGHT_DUCKING_STD = 6;
static const int PAN_XHEIGHT_DUCKING_LARGE = 7;
static const int ELF_VENDOR_SIZE = 4;
/* The extended logical font       */
/* An extension of the ENUMLOGFONT */
typedef struct tagEXTLOGFONTA {
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    DWORD elfVersion; /* 0 for the first release of NT */
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture; /* 0 for Latin                   */
    PANOSE elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA, *NPEXTLOGFONTA, *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    DWORD elfVersion; /* 0 for the first release of NT */
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture; /* 0 for Latin                   */
    PANOSE elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW, *NPEXTLOGFONTW, *LPEXTLOGFONTW;
typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;
static const int ELF_VERSION = 0;
static const int ELF_CULTURE_LATIN = 0;
/* EnumFonts Masks */
static const int RASTER_FONTTYPE = 0x0001;
static const int DEVICE_FONTTYPE = 0x0002;
static const int TRUETYPE_FONTTYPE = 0x0004;
static const int RGB(r,g,b) = ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)));
static const int PALETTERGB(r,g,b) = (0x02000000 | RGB(r,g,b));
static const int PALETTEINDEX(i) = ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)));
/* palette entry flags */
static const int PC_RESERVED = 0x01;
static const int PC_EXPLICIT = 0x02;
static const int PC_NOCOLLAPSE = 0x04;
static const int GetRValue(rgb) = (LOBYTE(rgb));
static const int GetGValue(rgb) = (LOBYTE(((WORD)(rgb)) >> 8));
static const int GetBValue(rgb) = (LOBYTE((rgb)>>16));
/* Background Modes */
static const int TRANSPARENT = 1;
static const int OPAQUE = 2;
static const int BKMODE_LAST = 2;
/* Graphics Modes */
static const int GM_COMPATIBLE = 1;
static const int GM_ADVANCED = 2;
static const int GM_LAST = 2;
/* PolyDraw and GetPath point types */
static const int PT_CLOSEFIGURE = 0x01;
static const int PT_LINETO = 0x02;
static const int PT_BEZIERTO = 0x04;
static const int PT_MOVETO = 0x06;
/* Mapping Modes */
static const int MM_TEXT = 1;
static const int MM_LOMETRIC = 2;
static const int MM_HIMETRIC = 3;
static const int MM_LOENGLISH = 4;
static const int MM_HIENGLISH = 5;
static const int MM_TWIPS = 6;
static const int MM_ISOTROPIC = 7;
static const int MM_ANISOTROPIC = 8;
/* Min and Max Mapping Mode values */
static const int MM_MIN = MM_TEXT;
static const int MM_MAX = MM_ANISOTROPIC;
static const int MM_MAX_FIXEDSCALE = MM_TWIPS;
/* Coordinate Modes */
static const int ABSOLUTE = 1;
static const int RELATIVE = 2;
/* Stock Logical Objects */
static const int WHITE_BRUSH = 0;
static const int LTGRAY_BRUSH = 1;
static const int GRAY_BRUSH = 2;
static const int DKGRAY_BRUSH = 3;
static const int BLACK_BRUSH = 4;
static const int NULL_BRUSH = 5;
static const int HOLLOW_BRUSH = NULL_BRUSH;
static const int WHITE_PEN = 6;
static const int BLACK_PEN = 7;
static const int NULL_PEN = 8;
static const int OEM_FIXED_FONT = 10;
static const int ANSI_FIXED_FONT = 11;
static const int ANSI_VAR_FONT = 12;
static const int SYSTEM_FONT = 13;
static const int DEVICE_DEFAULT_FONT = 14;
static const int DEFAULT_PALETTE = 15;
static const int SYSTEM_FIXED_FONT = 16;
static const int DEFAULT_GUI_FONT = 17;
static const int DC_BRUSH = 18;
static const int DC_PEN = 19;
static const int STOCK_LAST = 19;
static const int CLR_INVALID = 0xFFFFFFFF;
/* Brush Styles */
static const int BS_SOLID = 0;
static const int BS_NULL = 1;
static const int BS_HOLLOW = BS_NULL;
static const int BS_HATCHED = 2;
static const int BS_PATTERN = 3;
static const int BS_INDEXED = 4;
static const int BS_DIBPATTERN = 5;
static const int BS_DIBPATTERNPT = 6;
static const int BS_PATTERN8X8 = 7;
static const int BS_DIBPATTERN8X8 = 8;
static const int BS_MONOPATTERN = 9;
/* Hatch Styles */
static const int HS_HORIZONTAL = 0;
static const int HS_VERTICAL = 1;
static const int HS_FDIAGONAL = 2;
static const int HS_BDIAGONAL = 3;
static const int HS_CROSS = 4;
static const int HS_DIAGCROSS = 5;
static const int HS_API_MAX = 12;
/* Pen Styles */
static const int PS_SOLID = 0;
static const int PS_DASH = 1;
static const int PS_DOT = 2;
static const int PS_DASHDOT = 3;
static const int PS_DASHDOTDOT = 4;
static const int PS_NULL = 5;
static const int PS_INSIDEFRAME = 6;
static const int PS_USERSTYLE = 7;
static const int PS_ALTERNATE = 8;
static const double PS_STYLE_MASK = 0x0000000F;
static const int PS_ENDCAP_ROUND = 0x00000000;
static const int PS_ENDCAP_SQUARE = 0x00000100;
static const int PS_ENDCAP_FLAT = 0x00000200;
static const int PS_ENDCAP_MASK = 0x00000F00;
static const int PS_JOIN_ROUND = 0x00000000;
static const int PS_JOIN_BEVEL = 0x00001000;
static const int PS_JOIN_MITER = 0x00002000;
static const int PS_JOIN_MASK = 0x0000F000;
static const int PS_COSMETIC = 0x00000000;
static const int PS_GEOMETRIC = 0x00010000;
static const int PS_TYPE_MASK = 0x000F0000;
static const int AD_COUNTERCLOCKWISE = 1;
static const int AD_CLOCKWISE = 2;
/* Device Parameters for GetDeviceCaps() */
static const int DRIVERVERSION = 0;
static const int TECHNOLOGY = 2;
static const int HORZSIZE = 4;
static const int VERTSIZE = 6;
static const int HORZRES = 8;
static const int VERTRES = 10;
static const int BITSPIXEL = 12;
static const int PLANES = 14;
static const int NUMBRUSHES = 16;
static const int NUMPENS = 18;
static const int NUMMARKERS = 20;
static const int NUMFONTS = 22;
static const int NUMCOLORS = 24;
static const int PDEVICESIZE = 26;
static const int CURVECAPS = 28;
static const int LINECAPS = 30;
static const int POLYGONALCAPS = 32;
static const int TEXTCAPS = 34;
static const int CLIPCAPS = 36;
static const int RASTERCAPS = 38;
static const int ASPECTX = 40;
static const int ASPECTY = 42;
static const int ASPECTXY = 44;
static const int LOGPIXELSX = 88;
static const int LOGPIXELSY = 90;
static const int SIZEPALETTE = 104;
static const int NUMRESERVED = 106;
static const int COLORRES = 108;
// Printing related DeviceCaps. These replace the appropriate Escapes
static const int PHYSICALWIDTH = 110;
static const int PHYSICALHEIGHT = 111;
static const int PHYSICALOFFSETX = 112;
static const int PHYSICALOFFSETY = 113;
static const int SCALINGFACTORX = 114;
static const int SCALINGFACTORY = 115;
// Display driver specific
static const int VREFRESH = 116;
                             /* display device (for displays only) in Hz*/
static const int DESKTOPVERTRES = 117;
                             /* pixels                                  */
static const int DESKTOPHORZRES = 118;
                             /* pixels                                  */
static const int BLTALIGNMENT = 119;
static const int SHADEBLENDCAPS = 120;
static const int COLORMGMTCAPS = 121;
/* Device Capability Masks: */
/* Device Technologies */
static const int DT_PLOTTER = 0;
static const int DT_RASDISPLAY = 1;
static const int DT_RASPRINTER = 2;
static const int DT_RASCAMERA = 3;
static const int DT_CHARSTREAM = 4;
static const int DT_METAFILE = 5;
static const int DT_DISPFILE = 6;
/* Curve Capabilities */
static const int CC_NONE = 0;
static const int CC_CIRCLES = 1;
static const int CC_PIE = 2;
static const int CC_CHORD = 4;
static const int CC_ELLIPSES = 8;
static const int CC_WIDE = 16;
static const int CC_STYLED = 32;
static const int CC_WIDESTYLED = 64;
static const int CC_INTERIORS = 128;
static const int CC_ROUNDRECT = 256;
/* Line Capabilities */
static const int LC_NONE = 0;
static const int LC_POLYLINE = 2;
static const int LC_MARKER = 4;
static const int LC_POLYMARKER = 8;
static const int LC_WIDE = 16;
static const int LC_STYLED = 32;
static const int LC_WIDESTYLED = 64;
static const int LC_INTERIORS = 128;
/* Polygonal Capabilities */
static const int PC_NONE = 0;
static const int PC_POLYGON = 1;
static const int PC_RECTANGLE = 2;
static const int PC_WINDPOLYGON = 4;
static const int PC_TRAPEZOID = 4;
static const int PC_SCANLINE = 8;
static const int PC_WIDE = 16;
static const int PC_STYLED = 32;
static const int PC_WIDESTYLED = 64;
static const int PC_INTERIORS = 128;
static const int PC_POLYPOLYGON = 256;
static const int PC_PATHS = 512;
/* Clipping Capabilities */
static const int CP_NONE = 0;
static const int CP_RECTANGLE = 1;
static const int CP_REGION = 2;
/* Text Capabilities */
static const int TC_OP_CHARACTER = 0x00000001;
static const int TC_OP_STROKE = 0x00000002;
static const int TC_CP_STROKE = 0x00000004;
static const int TC_CR_90 = 0x00000008;
static const int TC_CR_ANY = 0x00000010;
static const int TC_SF_X_YINDEP = 0x00000020;
static const int TC_SA_DOUBLE = 0x00000040;
static const int TC_SA_INTEGER = 0x00000080;
static const int TC_SA_CONTIN = 0x00000100;
static const int TC_EA_DOUBLE = 0x00000200;
static const int TC_IA_ABLE = 0x00000400;
static const int TC_UA_ABLE = 0x00000800;
static const int TC_SO_ABLE = 0x00001000;
static const int TC_RA_ABLE = 0x00002000;
static const int TC_VA_ABLE = 0x00004000;
static const int TC_RESERVED = 0x00008000;
static const int TC_SCROLLBLT = 0x00010000;
/* Raster Capabilities */
static const int RC_BITBLT = 1;
static const int RC_BANDING = 2;
static const int RC_SCALING = 4;
static const int RC_BITMAP64 = 8;
static const int RC_GDI20_OUTPUT = 0x0010;
static const int RC_GDI20_STATE = 0x0020;
static const int RC_SAVEBITMAP = 0x0040;
static const int RC_DI_BITMAP = 0x0080;
static const int RC_PALETTE = 0x0100;
static const int RC_DIBTODEV = 0x0200;
static const int RC_BIGFONT = 0x0400;
static const int RC_STRETCHBLT = 0x0800;
static const int RC_FLOODFILL = 0x1000;
static const int RC_STRETCHDIB = 0x2000;
static const int RC_OP_DX_OUTPUT = 0x4000;
static const int RC_DEVBITS = 0x8000;
/* Shading and blending caps */
static const int SB_NONE = 0x00000000;
static const int SB_CONST_ALPHA = 0x00000001;
static const int SB_PIXEL_ALPHA = 0x00000002;
static const int SB_PREMULT_ALPHA = 0x00000004;
static const int SB_GRAD_RECT = 0x00000010;
static const int SB_GRAD_TRI = 0x00000020;
/* Color Management caps */
static const int CM_NONE = 0x00000000;
static const int CM_DEVICE_ICM = 0x00000001;
static const int CM_GAMMA_RAMP = 0x00000002;
static const int CM_CMYK_COLOR = 0x00000004;
/* DIB color table identifiers */
static const int DIB_RGB_COLORS = 0;
static const int DIB_PAL_COLORS = 1;
/* constants for Get/SetSystemPaletteUse() */
static const int SYSPAL_ERROR = 0;
static const int SYSPAL_STATIC = 1;
static const int SYSPAL_NOSTATIC = 2;
static const int SYSPAL_NOSTATIC256 = 3;
/* constants for CreateDIBitmap */
static const long CBM_INIT = 0x04L;
/* ExtFloodFill style flags */
static const int FLOODFILLBORDER = 0;
static const int FLOODFILLSURFACE = 1;
/* size of a device name string */
static const int CCHDEVICENAME = 32;
/* size of a form name string */
static const int CCHFORMNAME = 32;
typedef struct _devicemodeA {
    BYTE dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      /* printer only fields */
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      /* display only fields */
      struct {
        POINTL dmPosition;
        DWORD dmDisplayOrientation;
        DWORD dmDisplayFixedOutput;
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    };
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      /* printer only fields */
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      /* display only fields */
      struct {
        POINTL dmPosition;
        DWORD dmDisplayOrientation;
        DWORD dmDisplayFixedOutput;
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    };
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;
typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
# 2158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
/* current version of specification */
static const int DM_SPECVERSION = 0x0401;
/* field selection bits */
static const long DM_ORIENTATION = 0x00000001L;
static const long DM_PAPERSIZE = 0x00000002L;
static const long DM_PAPERLENGTH = 0x00000004L;
static const long DM_PAPERWIDTH = 0x00000008L;
static const long DM_SCALE = 0x00000010L;
static const long DM_POSITION = 0x00000020L;
static const long DM_NUP = 0x00000040L;
static const long DM_DISPLAYORIENTATION = 0x00000080L;
static const long DM_COPIES = 0x00000100L;
static const long DM_DEFAULTSOURCE = 0x00000200L;
static const long DM_PRINTQUALITY = 0x00000400L;
static const long DM_COLOR = 0x00000800L;
static const long DM_DUPLEX = 0x00001000L;
static const long DM_YRESOLUTION = 0x00002000L;
static const long DM_TTOPTION = 0x00004000L;
static const long DM_COLLATE = 0x00008000L;
static const long DM_FORMNAME = 0x00010000L;
static const long DM_LOGPIXELS = 0x00020000L;
static const long DM_BITSPERPEL = 0x00040000L;
static const long DM_PELSWIDTH = 0x00080000L;
static const long DM_PELSHEIGHT = 0x00100000L;
static const long DM_DISPLAYFLAGS = 0x00200000L;
static const long DM_DISPLAYFREQUENCY = 0x00400000L;
static const long DM_ICMMETHOD = 0x00800000L;
static const long DM_ICMINTENT = 0x01000000L;
static const long DM_MEDIATYPE = 0x02000000L;
static const long DM_DITHERTYPE = 0x04000000L;
static const long DM_PANNINGWIDTH = 0x08000000L;
static const long DM_PANNINGHEIGHT = 0x10000000L;
static const long DM_DISPLAYFIXEDOUTPUT = 0x20000000L;
/* orientation selections */
static const int DMORIENT_PORTRAIT = 1;
static const int DMORIENT_LANDSCAPE = 2;
/* paper selections */
static const int DMPAPER_FIRST = DMPAPER_LETTER;
static const int DMPAPER_LETTER = 1;
static const int DMPAPER_LETTERSMALL = 2;
static const int DMPAPER_TABLOID = 3;
static const int DMPAPER_LEDGER = 4;
static const int DMPAPER_LEGAL = 5;
static const int DMPAPER_STATEMENT = 6;
static const int DMPAPER_EXECUTIVE = 7;
static const int DMPAPER_A3 = 8;
static const int DMPAPER_A4 = 9;
static const int DMPAPER_A4SMALL = 10;
static const int DMPAPER_A5 = 11;
static const int DMPAPER_B4 = 12;
static const int DMPAPER_B5 = 13;
static const int DMPAPER_FOLIO = 14;
static const int DMPAPER_QUARTO = 15;
static const int DMPAPER_10X14 = 16;
static const int DMPAPER_11X17 = 17;
static const int DMPAPER_NOTE = 18;
static const int DMPAPER_ENV_9 = 19;
static const int DMPAPER_ENV_10 = 20;
static const int DMPAPER_ENV_11 = 21;
static const int DMPAPER_ENV_12 = 22;
static const int DMPAPER_ENV_14 = 23;
static const int DMPAPER_CSHEET = 24;
static const int DMPAPER_DSHEET = 25;
static const int DMPAPER_ESHEET = 26;
static const int DMPAPER_ENV_DL = 27;
static const int DMPAPER_ENV_C5 = 28;
static const int DMPAPER_ENV_C3 = 29;
static const int DMPAPER_ENV_C4 = 30;
static const int DMPAPER_ENV_C6 = 31;
static const int DMPAPER_ENV_C65 = 32;
static const int DMPAPER_ENV_B4 = 33;
static const int DMPAPER_ENV_B5 = 34;
static const int DMPAPER_ENV_B6 = 35;
static const int DMPAPER_ENV_ITALY = 36;
static const int DMPAPER_ENV_MONARCH = 37;
static const int DMPAPER_ENV_PERSONAL = 38;
static const int DMPAPER_FANFOLD_US = 39;
static const int DMPAPER_FANFOLD_STD_GERMAN = 40;
static const int DMPAPER_FANFOLD_LGL_GERMAN = 41;
static const int DMPAPER_ISO_B4 = 42;
static const int DMPAPER_JAPANESE_POSTCARD = 43;
static const int DMPAPER_9X11 = 44;
static const int DMPAPER_10X11 = 45;
static const int DMPAPER_15X11 = 46;
static const int DMPAPER_ENV_INVITE = 47;
static const int DMPAPER_RESERVED_48 = 48;
static const int DMPAPER_RESERVED_49 = 49;
static const int DMPAPER_LETTER_EXTRA = 50;
static const int DMPAPER_LEGAL_EXTRA = 51;
static const int DMPAPER_TABLOID_EXTRA = 52;
static const int DMPAPER_A4_EXTRA = 53;
static const int DMPAPER_LETTER_TRANSVERSE = 54;
static const int DMPAPER_A4_TRANSVERSE = 55;
static const int DMPAPER_LETTER_EXTRA_TRANSVERSE = 56;
static const int DMPAPER_A_PLUS = 57;
static const int DMPAPER_B_PLUS = 58;
static const int DMPAPER_LETTER_PLUS = 59;
static const int DMPAPER_A4_PLUS = 60;
static const int DMPAPER_A5_TRANSVERSE = 61;
static const int DMPAPER_B5_TRANSVERSE = 62;
static const int DMPAPER_A3_EXTRA = 63;
static const int DMPAPER_A5_EXTRA = 64;
static const int DMPAPER_B5_EXTRA = 65;
static const int DMPAPER_A2 = 66;
static const int DMPAPER_A3_TRANSVERSE = 67;
static const int DMPAPER_A3_EXTRA_TRANSVERSE = 68;
static const int DMPAPER_DBL_JAPANESE_POSTCARD = 69;
static const int DMPAPER_A6 = 70;
static const int DMPAPER_JENV_KAKU2 = 71;
static const int DMPAPER_JENV_KAKU3 = 72;
static const int DMPAPER_JENV_CHOU3 = 73;
static const int DMPAPER_JENV_CHOU4 = 74;
static const int DMPAPER_LETTER_ROTATED = 75;
static const int DMPAPER_A3_ROTATED = 76;
static const int DMPAPER_A4_ROTATED = 77;
static const int DMPAPER_A5_ROTATED = 78;
static const int DMPAPER_B4_JIS_ROTATED = 79;
static const int DMPAPER_B5_JIS_ROTATED = 80;
static const int DMPAPER_JAPANESE_POSTCARD_ROTATED = 81;
static const int DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82;
static const int DMPAPER_A6_ROTATED = 83;
static const int DMPAPER_JENV_KAKU2_ROTATED = 84;
static const int DMPAPER_JENV_KAKU3_ROTATED = 85;
static const int DMPAPER_JENV_CHOU3_ROTATED = 86;
static const int DMPAPER_JENV_CHOU4_ROTATED = 87;
static const int DMPAPER_B6_JIS = 88;
static const int DMPAPER_B6_JIS_ROTATED = 89;
static const int DMPAPER_12X11 = 90;
static const int DMPAPER_JENV_YOU4 = 91;
static const int DMPAPER_JENV_YOU4_ROTATED = 92;
static const int DMPAPER_P16K = 93;
static const int DMPAPER_P32K = 94;
static const int DMPAPER_P32KBIG = 95;
static const int DMPAPER_PENV_1 = 96;
static const int DMPAPER_PENV_2 = 97;
static const int DMPAPER_PENV_3 = 98;
static const int DMPAPER_PENV_4 = 99;
static const int DMPAPER_PENV_5 = 100;
static const int DMPAPER_PENV_6 = 101;
static const int DMPAPER_PENV_7 = 102;
static const int DMPAPER_PENV_8 = 103;
static const int DMPAPER_PENV_9 = 104;
static const int DMPAPER_PENV_10 = 105;
static const int DMPAPER_P16K_ROTATED = 106;
static const int DMPAPER_P32K_ROTATED = 107;
static const int DMPAPER_P32KBIG_ROTATED = 108;
static const int DMPAPER_PENV_1_ROTATED = 109;
static const int DMPAPER_PENV_2_ROTATED = 110;
static const int DMPAPER_PENV_3_ROTATED = 111;
static const int DMPAPER_PENV_4_ROTATED = 112;
static const int DMPAPER_PENV_5_ROTATED = 113;
static const int DMPAPER_PENV_6_ROTATED = 114;
static const int DMPAPER_PENV_7_ROTATED = 115;
static const int DMPAPER_PENV_8_ROTATED = 116;
static const int DMPAPER_PENV_9_ROTATED = 117;
static const int DMPAPER_PENV_10_ROTATED = 118;
static const int DMPAPER_LAST = DMPAPER_PENV_10_ROTATED;
static const int DMPAPER_USER = 256;
/* bin selections */
static const int DMBIN_FIRST = DMBIN_UPPER;
static const int DMBIN_UPPER = 1;
static const int DMBIN_ONLYONE = 1;
static const int DMBIN_LOWER = 2;
static const int DMBIN_MIDDLE = 3;
static const int DMBIN_MANUAL = 4;
static const int DMBIN_ENVELOPE = 5;
static const int DMBIN_ENVMANUAL = 6;
static const int DMBIN_AUTO = 7;
static const int DMBIN_TRACTOR = 8;
static const int DMBIN_SMALLFMT = 9;
static const int DMBIN_LARGEFMT = 10;
static const int DMBIN_LARGECAPACITY = 11;
static const int DMBIN_CASSETTE = 14;
static const int DMBIN_FORMSOURCE = 15;
static const int DMBIN_LAST = DMBIN_FORMSOURCE;
static const int DMBIN_USER = 256;
/* print qualities */
static const int DMRES_DRAFT = (-1);
static const int DMRES_LOW = (-2);
static const int DMRES_MEDIUM = (-3);
static const int DMRES_HIGH = (-4);
/* color enable/disable for color printers */
static const int DMCOLOR_MONOCHROME = 1;
static const int DMCOLOR_COLOR = 2;
/* duplex enable */
static const int DMDUP_SIMPLEX = 1;
static const int DMDUP_VERTICAL = 2;
static const int DMDUP_HORIZONTAL = 3;
/* TrueType options */
static const int DMTT_BITMAP = 1;
static const int DMTT_DOWNLOAD = 2;
static const int DMTT_SUBDEV = 3;
static const int DMTT_DOWNLOAD_OUTLINE = 4;
/* Collation selections */
static const int DMCOLLATE_FALSE = 0;
static const int DMCOLLATE_TRUE = 1;
/* DEVMODE dmDisplayOrientation specifiations */
static const int DMDO_DEFAULT = 0;
static const int DMDO_90 = 1;
static const int DMDO_180 = 2;
static const int DMDO_270 = 3;
/* DEVMODE dmDisplayFixedOutput specifiations */
static const int DMDFO_DEFAULT = 0;
static const int DMDFO_STRETCH = 1;
static const int DMDFO_CENTER = 2;
/* DEVMODE dmDisplayFlags flags */
// #define DM_GRAYSCALE            0x00000001 /* This flag is no longer valid */
static const int DM_INTERLACED = 0x00000002;
static const int DMDISPLAYFLAGS_TEXTMODE = 0x00000004;
/* dmNup , multiple logical page per physical page options */
static const int DMNUP_SYSTEM = 1;
static const int DMNUP_ONEUP = 2;
/* ICM methods */
static const int DMICMMETHOD_NONE = 1;
static const int DMICMMETHOD_SYSTEM = 2;
static const int DMICMMETHOD_DRIVER = 3;
static const int DMICMMETHOD_DEVICE = 4;
static const int DMICMMETHOD_USER = 256;
/* ICM Intents */
static const int DMICM_SATURATE = 1;
static const int DMICM_CONTRAST = 2;
static const int DMICM_COLORIMETRIC = 3;
static const int DMICM_ABS_COLORIMETRIC = 4;
static const int DMICM_USER = 256;
/* Media types */
static const int DMMEDIA_STANDARD = 1;
static const int DMMEDIA_TRANSPARENCY = 2;
static const int DMMEDIA_GLOSSY = 3;
static const int DMMEDIA_USER = 256;
/* Dither types */
static const int DMDITHER_NONE = 1;
static const int DMDITHER_COARSE = 2;
static const int DMDITHER_FINE = 3;
static const int DMDITHER_LINEART = 4;
static const int DMDITHER_ERRORDIFFUSION = 5;
static const int DMDITHER_RESERVED6 = 6;
static const int DMDITHER_RESERVED7 = 7;
static const int DMDITHER_RESERVED8 = 8;
static const int DMDITHER_RESERVED9 = 9;
static const int DMDITHER_GRAYSCALE = 10;
static const int DMDITHER_USER = 256;
typedef struct _DISPLAY_DEVICEA {
    DWORD cb;
    CHAR DeviceName[32];
    CHAR DeviceString[128];
    DWORD StateFlags;
    CHAR DeviceID[128];
    CHAR DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD cb;
    WCHAR DeviceName[32];
    WCHAR DeviceString[128];
    DWORD StateFlags;
    WCHAR DeviceID[128];
    WCHAR DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;
typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
static const int DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 0x00000001;
static const int DISPLAY_DEVICE_MULTI_DRIVER = 0x00000002;
static const int DISPLAY_DEVICE_PRIMARY_DEVICE = 0x00000004;
static const int DISPLAY_DEVICE_MIRRORING_DRIVER = 0x00000008;
static const int DISPLAY_DEVICE_VGA_COMPATIBLE = 0x00000010;
static const int DISPLAY_DEVICE_REMOVABLE = 0x00000020;
static const int DISPLAY_DEVICE_MODESPRUNED = 0x08000000;
static const int DISPLAY_DEVICE_REMOTE = 0x04000000;
static const int DISPLAY_DEVICE_DISCONNECT = 0x02000000;
static const int DISPLAY_DEVICE_TS_COMPATIBLE = 0x00200000;
static const int DISPLAY_DEVICE_UNSAFE_MODES_ON = 0x00080000;
/* Child device state */
static const int DISPLAY_DEVICE_ACTIVE = 0x00000001;
static const int DISPLAY_DEVICE_ATTACHED = 0x00000002;
static const int DISPLAYCONFIG_MAXPATH = 1024;
                                          // Max adapter (16) * Max source (16) *
                                          // Max clone pre source (4)
typedef struct DISPLAYCONFIG_RATIONAL
{
    UINT32 Numerator;
    UINT32 Denominator;
} DISPLAYCONFIG_RATIONAL;
typedef enum
{
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY;
typedef enum
{
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_SCANLINE_ORDERING;
typedef struct DISPLAYCONFIG_2DREGION
{
    UINT32 cx;
    UINT32 cy;
} DISPLAYCONFIG_2DREGION;
typedef struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO
{
    UINT64 pixelRate;
    DISPLAYCONFIG_RATIONAL hSyncFreq;
    DISPLAYCONFIG_RATIONAL vSyncFreq;
    DISPLAYCONFIG_2DREGION activeSize;
    DISPLAYCONFIG_2DREGION totalSize;
    UINT32 videoStandard;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
} DISPLAYCONFIG_VIDEO_SIGNAL_INFO;
typedef enum
{
    DISPLAYCONFIG_SCALING_IDENTITY = 1,
    DISPLAYCONFIG_SCALING_CENTERED = 2,
    DISPLAYCONFIG_SCALING_STRETCHED = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
    DISPLAYCONFIG_SCALING_CUSTOM = 5,
    DISPLAYCONFIG_SCALING_PREFERRED = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_SCALING;
typedef enum
{
    DISPLAYCONFIG_ROTATION_IDENTITY = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_ROTATION;
typedef enum
{
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_MODE_INFO_TYPE;
typedef enum
{
    DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = 0xffffffff
} DISPLAYCONFIG_PIXELFORMAT;
typedef struct DISPLAYCONFIG_SOURCE_MODE
{
    UINT32 width;
    UINT32 height;
    DISPLAYCONFIG_PIXELFORMAT pixelFormat;
    POINTL position;
} DISPLAYCONFIG_SOURCE_MODE;
typedef struct DISPLAYCONFIG_TARGET_MODE
{
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo;
} DISPLAYCONFIG_TARGET_MODE;
typedef struct DISPLAYCONFIG_MODE_INFO
{
    DISPLAYCONFIG_MODE_INFO_TYPE infoType;
    UINT32 id;
    LUID adapterId;
    union
    {
        DISPLAYCONFIG_TARGET_MODE targetMode;
        DISPLAYCONFIG_SOURCE_MODE sourceMode;
    };
} DISPLAYCONFIG_MODE_INFO;
static const int DISPLAYCONFIG_PATH_MODE_IDX_INVALID = 0xffffffff;
typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO
{
    LUID adapterId;
    UINT32 id;
    UINT32 modeInfoIdx;
    UINT32 statusFlags;
} DISPLAYCONFIG_PATH_SOURCE_INFO;
//
// Flags for source info structure (from OS to application through QDC)
//
static const int DISPLAYCONFIG_SOURCE_IN_USE = 0x00000001;
typedef struct DISPLAYCONFIG_PATH_TARGET_INFO
{
    LUID adapterId;
    UINT32 id;
    UINT32 modeInfoIdx;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    DISPLAYCONFIG_ROTATION rotation;
    DISPLAYCONFIG_SCALING scaling;
    DISPLAYCONFIG_RATIONAL refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
    BOOL targetAvailable;
    UINT32 statusFlags;
} DISPLAYCONFIG_PATH_TARGET_INFO;
//
// Status flags for target info structure (from OS to application through QDC)
//
static const int DISPLAYCONFIG_TARGET_IN_USE = 0x00000001;
static const int DISPLAYCONFIG_TARGET_FORCIBLE = 0x00000002;
static const int DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_BOOT = 0x00000004;
static const int DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_PATH = 0x00000008;
static const int DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_SYSTEM = 0x00000010;
typedef struct DISPLAYCONFIG_PATH_INFO
{
    DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO targetInfo;
    UINT32 flags;
} DISPLAYCONFIG_PATH_INFO;
//
// Flags for path info structure (from OS to application through QDC)
//
static const int DISPLAYCONFIG_PATH_ACTIVE = 0x00000001;
typedef enum
{
      DISPLAYCONFIG_TOPOLOGY_INTERNAL = 0x00000001,
      DISPLAYCONFIG_TOPOLOGY_CLONE = 0x00000002,
      DISPLAYCONFIG_TOPOLOGY_EXTEND = 0x00000004,
      DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 0x00000008,
      DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_TOPOLOGY_ID;
typedef enum
{
      DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
      DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
      DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
      DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_DEVICE_INFO_TYPE;
typedef struct DISPLAYCONFIG_DEVICE_INFO_HEADER
{
    DISPLAYCONFIG_DEVICE_INFO_TYPE type;
    UINT32 size;
    LUID adapterId;
    UINT32 id;
} DISPLAYCONFIG_DEVICE_INFO_HEADER;
typedef struct DISPLAYCONFIG_SOURCE_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    WCHAR viewGdiDeviceName[32];
} DISPLAYCONFIG_SOURCE_DEVICE_NAME;
typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS
{
    union
    {
        struct
        {
            UINT32 friendlyNameFromEdid : 1;
            UINT32 friendlyNameForced : 1;
            UINT32 edidIdsValid : 1;
            UINT32 reserved : 29;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;
typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    UINT16 edidManufactureId;
    UINT16 edidProductCodeId;
    UINT32 connectorInstance;
    WCHAR monitorFriendlyDeviceName[64];
    WCHAR monitorDevicePath[128];
} DISPLAYCONFIG_TARGET_DEVICE_NAME;
typedef struct DISPLAYCONFIG_TARGET_PREFERRED_MODE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    UINT32 width;
    UINT32 height;
    DISPLAYCONFIG_TARGET_MODE targetMode;
} DISPLAYCONFIG_TARGET_PREFERRED_MODE;
typedef struct DISPLAYCONFIG_ADAPTER_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    WCHAR adapterDevicePath[128];
} DISPLAYCONFIG_ADAPTER_NAME;
typedef struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union
    {
        struct
        {
            UINT32 bootPersistenceOn : 1;
            UINT32 reserved : 31;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_SET_TARGET_PERSISTENCE;
//
// Definitions to be used by GetDisplayConfigBufferSizes and QueryDisplayConfig.
//
static const int QDC_ALL_PATHS = 0x00000001;
static const int QDC_ONLY_ACTIVE_PATHS = 0x00000002;
static const int QDC_DATABASE_CURRENT = 0x00000004;
//
// Definitions used by SetDisplayConfig.
//
static const int SDC_TOPOLOGY_INTERNAL = 0x00000001;
static const int SDC_TOPOLOGY_CLONE = 0x00000002;
static const int SDC_TOPOLOGY_EXTEND = 0x00000004;
static const int SDC_TOPOLOGY_EXTERNAL = 0x00000008;
static const int SDC_TOPOLOGY_SUPPLIED = 0x00000010;
static const int SDC_USE_DATABASE_CURRENT = (SDC_TOPOLOGY_INTERNAL | SDC_TOPOLOGY_CLONE | SDC_TOPOLOGY_EXTEND | SDC_TOPOLOGY_EXTERNAL);
static const int SDC_USE_SUPPLIED_DISPLAY_CONFIG = 0x00000020;
static const int SDC_VALIDATE = 0x00000040;
static const int SDC_APPLY = 0x00000080;
static const int SDC_NO_OPTIMIZATION = 0x00000100;
static const int SDC_SAVE_TO_DATABASE = 0x00000200;
static const int SDC_ALLOW_CHANGES = 0x00000400;
static const int SDC_PATH_PERSIST_IF_REQUIRED = 0x00000800;
static const int SDC_FORCE_MODE_ENUMERATION = 0x00001000;
static const int SDC_ALLOW_PATH_ORDER_CHANGES = 0x00002000;
/* GetRegionData/ExtCreateRegion */
static const int RDH_RECTANGLES = 1;
typedef struct _RGNDATAHEADER {
    DWORD dwSize;
    DWORD iType;
    DWORD nCount;
    DWORD nRgnSize;
    RECT rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;
typedef struct _RGNDATA {
    RGNDATAHEADER rdh;
    char Buffer[1];
} RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;
/* for GetRandomRgn */
static const int SYSRGN = 4;
typedef struct _ABC {
    int abcA;
    UINT abcB;
    int abcC;
} ABC, *PABC, *NPABC, *LPABC;
typedef struct _ABCFLOAT {
    FLOAT abcfA;
    FLOAT abcfB;
    FLOAT abcfC;
} ABCFLOAT, *PABCFLOAT, *NPABCFLOAT, *LPABCFLOAT;
typedef struct _OUTLINETEXTMETRICA {
    UINT otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
     int otmsCharSlopeRise;
     int otmsCharSlopeRun;
     int otmItalicAngle;
    UINT otmEMSquare;
     int otmAscent;
     int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
     int otmMacAscent;
     int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
     int otmsStrikeoutPosition;
     int otmsUnderscoreSize;
     int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA, *NPOUTLINETEXTMETRICA, *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
     int otmsCharSlopeRise;
     int otmsCharSlopeRun;
     int otmItalicAngle;
    UINT otmEMSquare;
     int otmAscent;
     int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
     int otmMacAscent;
     int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
     int otmsStrikeoutPosition;
     int otmsUnderscoreSize;
     int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW, *NPOUTLINETEXTMETRICW, *LPOUTLINETEXTMETRICW;
typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
# 2928 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct tagPOLYTEXTA
{
    int x;
    int y;
    UINT n;
    LPCSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int *pdx;
} POLYTEXTA, *PPOLYTEXTA, *NPPOLYTEXTA, *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int x;
    int y;
    UINT n;
    LPCWSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int *pdx;
} POLYTEXTW, *PPOLYTEXTW, *NPPOLYTEXTW, *LPPOLYTEXTW;
typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;
typedef struct _FIXED {
    WORD fract;
    short value;
} FIXED;
typedef struct _MAT2 {
     FIXED eM11;
     FIXED eM12;
     FIXED eM21;
     FIXED eM22;
} MAT2, *LPMAT2;
typedef struct _GLYPHMETRICS {
    UINT gmBlackBoxX;
    UINT gmBlackBoxY;
    POINT gmptGlyphOrigin;
    short gmCellIncX;
    short gmCellIncY;
} GLYPHMETRICS, *LPGLYPHMETRICS;
//  GetGlyphOutline constants
static const int GGO_METRICS = 0;
static const int GGO_BITMAP = 1;
static const int GGO_NATIVE = 2;
static const int GGO_BEZIER = 3;
static const int GGO_GRAY2_BITMAP = 4;
static const int GGO_GRAY4_BITMAP = 5;
static const int GGO_GRAY8_BITMAP = 6;
static const int GGO_GLYPH_INDEX = 0x0080;
static const int GGO_UNHINTED = 0x0100;
static const int TT_POLYGON_TYPE = 24;
static const int TT_PRIM_LINE = 1;
static const int TT_PRIM_QSPLINE = 2;
static const int TT_PRIM_CSPLINE = 3;
typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, * LPPOINTFX;
typedef struct tagTTPOLYCURVE
{
    WORD wType;
    WORD cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, * LPTTPOLYCURVE;
typedef struct tagTTPOLYGONHEADER
{
    DWORD cb;
    DWORD dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, * LPTTPOLYGONHEADER;
static const int GCP_DBCS = 0x0001;
static const int GCP_REORDER = 0x0002;
static const int GCP_USEKERNING = 0x0008;
static const int GCP_GLYPHSHAPE = 0x0010;
static const int GCP_LIGATE = 0x0020;
////#define GCP_GLYPHINDEXING  0x0080
static const int GCP_DIACRITIC = 0x0100;
static const int GCP_KASHIDA = 0x0400;
static const int GCP_ERROR = 0x8000;
static const int FLI_MASK = 0x103B;
static const long GCP_JUSTIFY = 0x00010000L;
////#define GCP_NODIACRITICS   0x00020000L
static const long FLI_GLYPHS = 0x00040000L;
static const long GCP_CLASSIN = 0x00080000L;
static const long GCP_MAXEXTENT = 0x00100000L;
static const long GCP_JUSTIFYIN = 0x00200000L;
static const long GCP_DISPLAYZWG = 0x00400000L;
static const long GCP_SYMSWAPOFF = 0x00800000L;
static const long GCP_NUMERICOVERRIDE = 0x01000000L;
static const long GCP_NEUTRALOVERRIDE = 0x02000000L;
static const long GCP_NUMERICSLATIN = 0x04000000L;
static const long GCP_NUMERICSLOCAL = 0x08000000L;
static const int GCPCLASS_LATIN = 1;
static const int GCPCLASS_HEBREW = 2;
static const int GCPCLASS_ARABIC = 2;
static const int GCPCLASS_NEUTRAL = 3;
static const int GCPCLASS_LOCALNUMBER = 4;
static const int GCPCLASS_LATINNUMBER = 5;
static const int GCPCLASS_LATINNUMERICTERMINATOR = 6;
static const int GCPCLASS_LATINNUMERICSEPARATOR = 7;
static const int GCPCLASS_NUMERICSEPARATOR = 8;
static const int GCPCLASS_PREBOUNDLTR = 0x80;
static const int GCPCLASS_PREBOUNDRTL = 0x40;
static const int GCPCLASS_POSTBOUNDLTR = 0x20;
static const int GCPCLASS_POSTBOUNDRTL = 0x10;
static const int GCPGLYPH_LINKBEFORE = 0x8000;
static const int GCPGLYPH_LINKAFTER = 0x4000;
typedef struct tagGCP_RESULTSA
    {
    DWORD lStructSize;
    LPSTR lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
    } GCP_RESULTSA, * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD lStructSize;
    LPWSTR lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
    } GCP_RESULTSW, * LPGCP_RESULTSW;
typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;
typedef struct _RASTERIZER_STATUS {
    short nSize;
    short wFlags;
    short nLanguageID;
} RASTERIZER_STATUS, *LPRASTERIZER_STATUS;
/* bits defined in wFlags of RASTERIZER_STATUS */
static const int TT_AVAILABLE = 0x0001;
static const int TT_ENABLED = 0x0002;
/* Pixel format descriptor */
typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerType;
    BYTE bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR, *LPPIXELFORMATDESCRIPTOR;
/* pixel types */
static const int PFD_TYPE_RGBA = 0;
static const int PFD_TYPE_COLORINDEX = 1;
/* layer types */
static const int PFD_MAIN_PLANE = 0;
static const int PFD_OVERLAY_PLANE = 1;
static const int PFD_UNDERLAY_PLANE = (-1);
/* PIXELFORMATDESCRIPTOR flags */
static const int PFD_DOUBLEBUFFER = 0x00000001;
static const int PFD_STEREO = 0x00000002;
static const int PFD_DRAW_TO_WINDOW = 0x00000004;
static const int PFD_DRAW_TO_BITMAP = 0x00000008;
static const int PFD_SUPPORT_GDI = 0x00000010;
static const int PFD_SUPPORT_OPENGL = 0x00000020;
static const int PFD_GENERIC_FORMAT = 0x00000040;
static const int PFD_NEED_PALETTE = 0x00000080;
static const int PFD_NEED_SYSTEM_PALETTE = 0x00000100;
static const int PFD_SWAP_EXCHANGE = 0x00000200;
static const int PFD_SWAP_COPY = 0x00000400;
static const int PFD_SWAP_LAYER_BUFFERS = 0x00000800;
static const int PFD_GENERIC_ACCELERATED = 0x00001000;
static const int PFD_SUPPORT_DIRECTDRAW = 0x00002000;
static const int PFD_DIRECT3D_ACCELERATED = 0x00004000;
static const int PFD_SUPPORT_COMPOSITION = 0x00008000;
/* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only */
static const int PFD_DEPTH_DONTCARE = 0x20000000;
static const int PFD_DOUBLEBUFFER_DONTCARE = 0x40000000;
static const int PFD_STEREO_DONTCARE = 0x80000000;
typedef int (* OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM);
typedef int (* OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM);
static const int OLDFONTENUMPROC = OLDFONTENUMPROCA;
# 3201 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef OLDFONTENUMPROCA FONTENUMPROCA;
typedef OLDFONTENUMPROCW FONTENUMPROCW;
typedef FONTENUMPROCA FONTENUMPROC;
typedef int (* GOBJENUMPROC)(LPVOID, LPARAM);
typedef void (* LINEDDAPROC)(int, int, LPARAM);
# 3226 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
 int AddFontResourceA( LPCSTR);
 int AddFontResourceW( LPCWSTR);
static const int AddFontResource = AddFontResourceA;
 BOOL AnimatePalette( HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY * ppe);
 BOOL Arc( HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
 BOOL BitBlt( HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
 BOOL CancelDC( HDC hdc);
 BOOL Chord( HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
 int ChoosePixelFormat( HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd);
 HMETAFILE CloseMetaFile( HDC hdc);
 int CombineRgn( HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode);
 HMETAFILE CopyMetaFileA( HMETAFILE, LPCSTR);
 HMETAFILE CopyMetaFileW( HMETAFILE, LPCWSTR);
static const int CopyMetaFile = CopyMetaFileA;
 HBITMAP CreateBitmap( int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits);
 HBITMAP CreateBitmapIndirect( const BITMAP *pbm);
 HBRUSH CreateBrushIndirect( const LOGBRUSH *plbrush);
 HBITMAP CreateCompatibleBitmap( HDC hdc, int cx, int cy);
 HBITMAP CreateDiscardableBitmap( HDC hdc, int cx, int cy);
 HDC CreateCompatibleDC( HDC hdc);
 HDC CreateDCA( LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA * pdm);
 HDC CreateDCW( LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW * pdm);
static const int CreateDC = CreateDCA;
 HBITMAP CreateDIBitmap( HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage);
 HBRUSH CreateDIBPatternBrush( HGLOBAL h, UINT iUsage);
 HBRUSH CreateDIBPatternBrushPt( const void *lpPackedDIB, UINT iUsage);
 HRGN CreateEllipticRgn( int x1, int y1, int x2, int y2);
 HRGN CreateEllipticRgnIndirect( const RECT *lprect);
 HFONT CreateFontIndirectA( const LOGFONTA *lplf);
 HFONT CreateFontIndirectW( const LOGFONTW *lplf);
static const int CreateFontIndirect = CreateFontIndirectA;
 HFONT CreateFontA( int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
                             DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
                             DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
 HFONT CreateFontW( int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
                             DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
                             DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
static const int CreateFont = CreateFontA;
 HBRUSH CreateHatchBrush( int iHatch, COLORREF color);
 HDC CreateICA( LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA * pdm);
 HDC CreateICW( LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW * pdm);
static const int CreateIC = CreateICA;
 HDC CreateMetaFileA( LPCSTR pszFile);
 HDC CreateMetaFileW( LPCWSTR pszFile);
static const int CreateMetaFile = CreateMetaFileA;
 HPALETTE CreatePalette( const LOGPALETTE * plpal);
 HPEN CreatePen( int iStyle, int cWidth, COLORREF color);
 HPEN CreatePenIndirect( const LOGPEN *plpen);
 HRGN CreatePolyPolygonRgn( const POINT *pptl,
                                                const INT *pc,
                                                int cPoly,
                                                int iMode);
 HBRUSH CreatePatternBrush( HBITMAP hbm);
 HRGN CreateRectRgn( int x1, int y1, int x2, int y2);
 HRGN CreateRectRgnIndirect( const RECT *lprect);
 HRGN CreateRoundRectRgn( int x1, int y1, int x2, int y2, int w, int h);
 BOOL CreateScalableFontResourceA( DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath);
 BOOL CreateScalableFontResourceW( DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath);
static const int CreateScalableFontResource = CreateScalableFontResourceA;
 HBRUSH CreateSolidBrush( COLORREF color);
 BOOL DeleteDC( HDC hdc);
 BOOL DeleteMetaFile( HMETAFILE hmf);
 BOOL DeleteObject( HGDIOBJ ho);
 int DescribePixelFormat( HDC hdc,
                                            int iPixelFormat,
                                            UINT nBytes,
                                            LPPIXELFORMATDESCRIPTOR ppfd);
/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 */
# 3333 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef UINT (* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);
typedef DWORD (* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);
/* mode selections for the device mode function */
static const int DM_UPDATE = 1;
static const int DM_COPY = 2;
static const int DM_PROMPT = 4;
static const int DM_MODIFY = 8;
static const int DM_IN_BUFFER = DM_MODIFY;
static const int DM_IN_PROMPT = DM_PROMPT;
static const int DM_OUT_BUFFER = DM_COPY;
static const int DM_OUT_DEFAULT = DM_UPDATE;
/* device capabilities indices */
static const int DC_FIELDS = 1;
static const int DC_PAPERS = 2;
static const int DC_PAPERSIZE = 3;
static const int DC_MINEXTENT = 4;
static const int DC_MAXEXTENT = 5;
static const int DC_BINS = 6;
static const int DC_DUPLEX = 7;
static const int DC_SIZE = 8;
static const int DC_EXTRA = 9;
static const int DC_VERSION = 10;
static const int DC_DRIVER = 11;
static const int DC_BINNAMES = 12;
static const int DC_ENUMRESOLUTIONS = 13;
static const int DC_FILEDEPENDENCIES = 14;
static const int DC_TRUETYPE = 15;
static const int DC_PAPERNAMES = 16;
static const int DC_ORIENTATION = 17;
static const int DC_COPIES = 18;
static const int DC_BINADJUST = 19;
static const int DC_EMF_COMPLIANT = 20;
static const int DC_DATATYPE_PRODUCED = 21;
static const int DC_COLLATE = 22;
static const int DC_MANUFACTURER = 23;
static const int DC_MODEL = 24;
static const int DC_PERSONALITY = 25;
static const int DC_PRINTRATE = 26;
static const int DC_PRINTRATEUNIT = 27;
static const int PRINTRATEUNIT_PPM = 1;
static const int PRINTRATEUNIT_CPS = 2;
static const int PRINTRATEUNIT_LPM = 3;
static const int PRINTRATEUNIT_IPM = 4;
static const int DC_PRINTERMEM = 28;
static const int DC_MEDIAREADY = 29;
static const int DC_STAPLE = 30;
static const int DC_PRINTRATEPPM = 31;
static const int DC_COLORDEVICE = 32;
static const int DC_NUP = 33;
static const int DC_MEDIATYPENAMES = 34;
static const int DC_MEDIATYPES = 35;
/* bit fields of the return value (DWORD) for DC_TRUETYPE */
static const long DCTT_BITMAP = 0x0000001L;
static const long DCTT_DOWNLOAD = 0x0000002L;
static const long DCTT_SUBDEV = 0x0000004L;
static const long DCTT_DOWNLOAD_OUTLINE = 0x0000008L;
/* return values for DC_BINADJUST */
static const int DCBA_FACEUPNONE = 0x0000;
static const int DCBA_FACEUPCENTER = 0x0001;
static const int DCBA_FACEUPLEFT = 0x0002;
static const int DCBA_FACEUPRIGHT = 0x0003;
static const int DCBA_FACEDOWNNONE = 0x0100;
static const int DCBA_FACEDOWNCENTER = 0x0101;
static const int DCBA_FACEDOWNLEFT = 0x0102;
static const int DCBA_FACEDOWNRIGHT = 0x0103;
int
DeviceCapabilitiesA(
    LPCSTR pDevice,
    LPCSTR pPort,
    WORD fwCapability,
    LPSTR pOutput,
    const DEVMODEA *pDevMode
    );
int
DeviceCapabilitiesW(
    LPCWSTR pDevice,
    LPCWSTR pPort,
    WORD fwCapability,
    LPWSTR pOutput,
    const DEVMODEW *pDevMode
    );
static const int DeviceCapabilities = DeviceCapabilitiesA;
 int DrawEscape( HDC hdc,
                                    int iEscape,
                                    int cjIn,
                                    LPCSTR lpIn);
 BOOL Ellipse( HDC hdc, int left, int top, int right, int bottom);
 int EnumFontFamiliesExA( HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags);
 int EnumFontFamiliesExW( HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags);
static const int EnumFontFamiliesEx = EnumFontFamiliesExA;
 int EnumFontFamiliesA( HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
 int EnumFontFamiliesW( HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);
static const int EnumFontFamilies = EnumFontFamiliesA;
 int EnumFontsA( HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
 int EnumFontsW( HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);
static const int EnumFonts = EnumFontsA;
 int EnumObjects( HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam);
 BOOL EqualRgn( HRGN hrgn1, HRGN hrgn2);
 int Escape( HDC hdc,
                                int iEscape,
                                int cjIn,
                                LPCSTR pvIn,
                                LPVOID pvOut);
 int ExtEscape( HDC hdc,
                                    int iEscape,
                                    int cjInput,
                                    LPCSTR lpInData,
                                    int cjOutput,
                                    LPSTR lpOutData);
 int ExcludeClipRect( HDC hdc, int left, int top, int right, int bottom);
 HRGN ExtCreateRegion( const XFORM * lpx, DWORD nCount, const RGNDATA * lpData);
 BOOL ExtFloodFill( HDC hdc, int x, int y, COLORREF color, UINT type);
 BOOL FillRgn( HDC hdc, HRGN hrgn, HBRUSH hbr);
 BOOL FloodFill( HDC hdc, int x, int y, COLORREF color);
 BOOL FrameRgn( HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h);
 int GetROP2( HDC hdc);
 BOOL GetAspectRatioFilterEx( HDC hdc, LPSIZE lpsize);
 COLORREF GetBkColor( HDC hdc);
 COLORREF GetDCBrushColor( HDC hdc);
 COLORREF GetDCPenColor( HDC hdc);
int
GetBkMode(
    HDC hdc
    );
LONG
GetBitmapBits(
    HBITMAP hbit,
    LONG cb,
    LPVOID lpvBits
    );
 BOOL GetBitmapDimensionEx( HBITMAP hbit, LPSIZE lpsize);
 UINT GetBoundsRect( HDC hdc, LPRECT lprect, UINT flags);
 BOOL GetBrushOrgEx( HDC hdc, LPPOINT lppt);
 BOOL GetCharWidthA( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
 BOOL GetCharWidthW( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
static const int GetCharWidth = GetCharWidthA;
 BOOL GetCharWidth32A( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
 BOOL GetCharWidth32W( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
static const int GetCharWidth32 = GetCharWidth32A;
 BOOL GetCharWidthFloatA( HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
 BOOL GetCharWidthFloatW( HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
static const int GetCharWidthFloat = GetCharWidthFloatA;
 BOOL GetCharABCWidthsA( HDC hdc,
                                            UINT wFirst,
                                            UINT wLast,
                                            LPABC lpABC);
 BOOL GetCharABCWidthsW( HDC hdc,
                                            UINT wFirst,
                                            UINT wLast,
                                            LPABC lpABC);
static const int GetCharABCWidths = GetCharABCWidthsA;
 BOOL GetCharABCWidthsFloatA( HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
 BOOL GetCharABCWidthsFloatW( HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
static const int GetCharABCWidthsFloat = GetCharABCWidthsFloatA;
 int GetClipBox( HDC hdc, LPRECT lprect);
 int GetClipRgn( HDC hdc, HRGN hrgn);
 int GetMetaRgn( HDC hdc, HRGN hrgn);
 HGDIOBJ GetCurrentObject( HDC hdc, UINT type);
 BOOL GetCurrentPositionEx( HDC hdc, LPPOINT lppt);
 int GetDeviceCaps( HDC hdc, int index);
 int GetDIBits( HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage); // SAL actual size of lpbmi is computed from structure elements
 DWORD GetFontData ( HDC hdc,
                                        DWORD dwTable,
                                        DWORD dwOffset,
                                        PVOID pvBuffer,
                                        DWORD cjBuffer
                                        );
 DWORD GetGlyphOutlineA( HDC hdc,
                                            UINT uChar,
                                            UINT fuFormat,
                                            LPGLYPHMETRICS lpgm,
                                            DWORD cjBuffer,
                                            LPVOID pvBuffer,
                                            const MAT2 *lpmat2
                                        );
 DWORD GetGlyphOutlineW( HDC hdc,
                                            UINT uChar,
                                            UINT fuFormat,
                                            LPGLYPHMETRICS lpgm,
                                            DWORD cjBuffer,
                                            LPVOID pvBuffer,
                                            const MAT2 *lpmat2
                                        );
static const int GetGlyphOutline = GetGlyphOutlineA;
 int GetGraphicsMode( HDC hdc);
 int GetMapMode( HDC hdc);
 UINT GetMetaFileBitsEx( HMETAFILE hMF, UINT cbBuffer, LPVOID lpData);
 HMETAFILE GetMetaFileA( LPCSTR lpName);
 HMETAFILE GetMetaFileW( LPCWSTR lpName);
static const int GetMetaFile = GetMetaFileA;
 COLORREF GetNearestColor( HDC hdc, COLORREF color);
 UINT GetNearestPaletteIndex( HPALETTE h, COLORREF color);
 DWORD GetObjectType( HGDIOBJ h);
 UINT GetOutlineTextMetricsA( HDC hdc,
                                                UINT cjCopy,
                                                LPOUTLINETEXTMETRICA potm);
 UINT GetOutlineTextMetricsW( HDC hdc,
                                                UINT cjCopy,
                                                LPOUTLINETEXTMETRICW potm);
static const int GetOutlineTextMetrics = GetOutlineTextMetricsA;
 UINT GetPaletteEntries( HPALETTE hpal,
                                            UINT iStart,
                                            UINT cEntries,
                                            LPPALETTEENTRY pPalEntries);
 COLORREF GetPixel( HDC hdc, int x, int y);
 int GetPixelFormat( HDC hdc);
 int GetPolyFillMode( HDC hdc);
 BOOL GetRasterizerCaps( LPRASTERIZER_STATUS lpraststat,
                                            UINT cjBytes);
 int GetRandomRgn ( HDC hdc, HRGN hrgn, INT i);
 DWORD GetRegionData( HRGN hrgn,
                                        DWORD nCount,
                                        LPRGNDATA lpRgnData);
 int GetRgnBox( HRGN hrgn, LPRECT lprc);
 HGDIOBJ GetStockObject( int i);
 int GetStretchBltMode( HDC hdc);
UINT
GetSystemPaletteEntries(
    HDC hdc,
    UINT iStart,
    UINT cEntries,
    LPPALETTEENTRY pPalEntries
    );
 UINT GetSystemPaletteUse( HDC hdc);
 int GetTextCharacterExtra( HDC hdc);
 UINT GetTextAlign( HDC hdc);
 COLORREF GetTextColor( HDC hdc);
BOOL
GetTextExtentPointA(
    HDC hdc,
    LPCSTR lpString,
    int c,
    LPSIZE lpsz
    );
BOOL
GetTextExtentPointW(
    HDC hdc,
    LPCWSTR lpString,
    int c,
    LPSIZE lpsz
    );
static const int GetTextExtentPoint = GetTextExtentPointA;
BOOL
GetTextExtentPoint32A(
    HDC hdc,
    LPCSTR lpString,
    int c,
    LPSIZE psizl
    );
BOOL
GetTextExtentPoint32W(
    HDC hdc,
    LPCWSTR lpString,
    int c,
    LPSIZE psizl
    );
static const int GetTextExtentPoint32 = GetTextExtentPoint32A;
BOOL
GetTextExtentExPointA(
    HDC hdc,
    LPCSTR lpszString,
    int cchString,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT lpnDx,
    LPSIZE lpSize
    );
BOOL
GetTextExtentExPointW(
    HDC hdc,
    LPCWSTR lpszString,
    int cchString,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT lpnDx,
    LPSIZE lpSize
    );
static const int GetTextExtentExPoint = GetTextExtentExPointA;
 int GetTextCharset( HDC hdc);
 int GetTextCharsetInfo( HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
 BOOL TranslateCharsetInfo( DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
 DWORD GetFontLanguageInfo( HDC hdc);
 DWORD GetCharacterPlacementA( HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags);
 DWORD GetCharacterPlacementW( HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags);
static const int GetCharacterPlacement = GetCharacterPlacementA;
typedef struct tagWCRANGE
{
    WCHAR wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;
typedef struct tagGLYPHSET
{
    DWORD cbThis;
    DWORD flAccel;
    DWORD cGlyphsSupported;
    DWORD cRanges;
    WCRANGE ranges[1];
} GLYPHSET, *PGLYPHSET, *LPGLYPHSET;
/* flAccel flags for the GLYPHSET structure above */
static const int GS_8BIT_INDICES = 0x00000001;
/* flags for GetGlyphIndices */
static const int GGI_MARK_NONEXISTING_GLYPHS = 0X0001;
 DWORD GetFontUnicodeRanges( HDC hdc, LPGLYPHSET lpgs);
 DWORD GetGlyphIndicesA( HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl);
 DWORD GetGlyphIndicesW( HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl);
static const int GetGlyphIndices = GetGlyphIndicesA;
 BOOL GetTextExtentPointI( HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize);
 BOOL GetTextExtentExPointI ( HDC hdc,
                                                LPWORD lpwszString,
                                                int cwchString,
                                                int nMaxExtent,
                                                LPINT lpnFit,
                                                LPINT lpnDx,
                                                LPSIZE lpSize
                                                );
 BOOL GetCharWidthI( HDC hdc,
                                        UINT giFirst,
                                        UINT cgi,
                                        LPWORD pgi,
                                        LPINT piWidths
                                        );
 BOOL GetCharABCWidthsI( HDC hdc,
                                            UINT giFirst,
                                            UINT cgi,
                                            LPWORD pgi,
                                            LPABC pabc
                                        );
static const int STAMP_DESIGNVECTOR = (0x8000000 + 'd' + ('v' << 8));
static const int STAMP_AXESLIST = (0x8000000 + 'a' + ('l' << 8));
static const int MM_MAX_NUMAXES = 16;
typedef struct tagDESIGNVECTOR
{
    DWORD dvReserved;
    DWORD dvNumAxes;
    LONG dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR;
 int AddFontResourceExA( LPCSTR name, DWORD fl, PVOID res);
 int AddFontResourceExW( LPCWSTR name, DWORD fl, PVOID res);
static const int AddFontResourceEx = AddFontResourceExA;
 BOOL RemoveFontResourceExA( LPCSTR name, DWORD fl, PVOID pdv);
 BOOL RemoveFontResourceExW( LPCWSTR name, DWORD fl, PVOID pdv);
static const int RemoveFontResourceEx = RemoveFontResourceExA;
 HANDLE AddFontMemResourceEx( PVOID pFileView,
                                                DWORD cjSize,
                                                PVOID pvResrved,
                                                DWORD* pNumFonts);
 BOOL RemoveFontMemResourceEx( HANDLE h);
static const int FR_PRIVATE = 0x10;
static const int FR_NOT_ENUM = 0x20;
// The actual size of the DESIGNVECTOR and ENUMLOGFONTEXDV structures
// is determined by dvNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed
static const int MM_MAX_AXES_NAMELEN = 16;
typedef struct tagAXISINFOA
{
    LONG axMinValue;
    LONG axMaxValue;
    BYTE axAxisName[16];
} AXISINFOA, *PAXISINFOA, *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG axMinValue;
    LONG axMaxValue;
    WCHAR axAxisName[16];
} AXISINFOW, *PAXISINFOW, *LPAXISINFOW;
typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;
typedef struct tagAXESLISTA
{
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOA axlAxisInfo[16];
} AXESLISTA, *PAXESLISTA, *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOW axlAxisInfo[16];
} AXESLISTW, *PAXESLISTW, *LPAXESLISTW;
typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;
// The actual size of the AXESLIST and ENUMTEXTMETRIC structure is
// determined by axlNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed
typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, *LPENUMLOGFONTEXDVW;
typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;
 HFONT CreateFontIndirectExA( const ENUMLOGFONTEXDVA *);
 HFONT CreateFontIndirectExW( const ENUMLOGFONTEXDVW *);
static const int CreateFontIndirectEx = CreateFontIndirectExA;
typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA, *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW, *LPENUMTEXTMETRICW;
typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;
 BOOL GetViewportExtEx( HDC hdc, LPSIZE lpsize);
 BOOL GetViewportOrgEx( HDC hdc, LPPOINT lppoint);
 BOOL GetWindowExtEx( HDC hdc, LPSIZE lpsize);
 BOOL GetWindowOrgEx( HDC hdc, LPPOINT lppoint);
 int IntersectClipRect( HDC hdc, int left, int top, int right, int bottom);
 BOOL InvertRgn( HDC hdc, HRGN hrgn);
 BOOL LineDDA( int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data);
 BOOL LineTo( HDC hdc, int x, int y);
 BOOL MaskBlt( HDC hdcDest, int xDest, int yDest, int width, int height,
              HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop);
 BOOL PlgBlt( HDC hdcDest, const POINT * lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width,
                     int height, HBITMAP hbmMask, int xMask, int yMask);
 int OffsetClipRgn( HDC hdc, int x, int y);
 int OffsetRgn( HRGN hrgn, int x, int y);
 BOOL PatBlt( HDC hdc, int x, int y, int w, int h, DWORD rop);
 BOOL Pie( HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
 BOOL PlayMetaFile( HDC hdc, HMETAFILE hmf);
 BOOL PaintRgn( HDC hdc, HRGN hrgn);
 BOOL PolyPolygon( HDC hdc, const POINT *apt, const INT *asz, int csz);
 BOOL PtInRegion( HRGN hrgn, int x, int y);
 BOOL PtVisible( HDC hdc, int x, int y);
 BOOL RectInRegion( HRGN hrgn, const RECT * lprect);
 BOOL RectVisible( HDC hdc, const RECT * lprect);
 BOOL Rectangle( HDC hdc, int left, int top, int right, int bottom);
 BOOL RestoreDC( HDC hdc, int nSavedDC);
 HDC ResetDCA( HDC hdc, const DEVMODEA * lpdm);
 HDC ResetDCW( HDC hdc, const DEVMODEW * lpdm);
static const int ResetDC = ResetDCA;
 UINT RealizePalette( HDC hdc);
 BOOL RemoveFontResourceA( LPCSTR lpFileName);
 BOOL RemoveFontResourceW( LPCWSTR lpFileName);
static const int RemoveFontResource = RemoveFontResourceA;
 BOOL RoundRect( HDC hdc, int left, int top, int right, int bottom, int width, int height);
 BOOL ResizePalette( HPALETTE hpal, UINT n);
 int SaveDC( HDC hdc);
 int SelectClipRgn( HDC hdc, HRGN hrgn);
 int ExtSelectClipRgn( HDC hdc, HRGN hrgn, int mode);
 int SetMetaRgn( HDC hdc);
 HGDIOBJ SelectObject( HDC hdc, HGDIOBJ h);
 HPALETTE SelectPalette( HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
 COLORREF SetBkColor( HDC hdc, COLORREF color);
 COLORREF SetDCBrushColor( HDC hdc, COLORREF color);
 COLORREF SetDCPenColor( HDC hdc, COLORREF color);
 int SetBkMode( HDC hdc, int mode);
LONG
SetBitmapBits(
    HBITMAP hbm,
    DWORD cb,
    const void *pvBits);
 UINT SetBoundsRect( HDC hdc, const RECT * lprect, UINT flags);
 int SetDIBits( HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO * lpbmi, UINT ColorUse);
 int SetDIBitsToDevice( HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc,
        int ySrc, UINT StartScan, UINT cLines, const void * lpvBits, const BITMAPINFO * lpbmi, UINT ColorUse);
 DWORD SetMapperFlags( HDC hdc, DWORD flags);
 int SetGraphicsMode( HDC hdc, int iMode);
 int SetMapMode( HDC hdc, int iMode);
 DWORD SetLayout( HDC hdc, DWORD l);
 DWORD GetLayout( HDC hdc);
 HMETAFILE SetMetaFileBitsEx( UINT cbBuffer, const BYTE *lpData);
 UINT SetPaletteEntries( HPALETTE hpal,
                                            UINT iStart,
                                            UINT cEntries,
                                            const PALETTEENTRY *pPalEntries);
 COLORREF SetPixel( HDC hdc, int x, int y, COLORREF color);
 BOOL SetPixelV( HDC hdc, int x, int y, COLORREF color);
 BOOL SetPixelFormat( HDC hdc, int format, const PIXELFORMATDESCRIPTOR * ppfd);
 int SetPolyFillMode( HDC hdc, int mode);
 BOOL StretchBlt( HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
 BOOL SetRectRgn( HRGN hrgn, int left, int top, int right, int bottom);
 int StretchDIBits( HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight,
        const void * lpBits, const BITMAPINFO * lpbmi, UINT iUsage, DWORD rop);
 int SetROP2( HDC hdc, int rop2);
 int SetStretchBltMode( HDC hdc, int mode);
 UINT SetSystemPaletteUse( HDC hdc, UINT use);
 int SetTextCharacterExtra( HDC hdc, int extra);
 COLORREF SetTextColor( HDC hdc, COLORREF color);
 UINT SetTextAlign( HDC hdc, UINT align);
 BOOL SetTextJustification( HDC hdc, int extra, int count);
 BOOL UpdateColors( HDC hdc);
# 4098 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
//
// image blt
//
typedef USHORT COLOR16;
typedef struct _TRIVERTEX
{
    LONG x;
    LONG y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;
typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;
typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;
typedef struct _BLENDFUNCTION
{
    BYTE BlendOp;
    BYTE BlendFlags;
    BYTE SourceConstantAlpha;
    BYTE AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;
//
// currentlly defined blend function
//
static const int AC_SRC_OVER = 0x00;
//
// alpha format flags
//
static const int AC_SRC_ALPHA = 0x01;
 BOOL AlphaBlend(
    HDC hdcDest,
    int xoriginDest,
    int yoriginDest,
    int wDest,
    int hDest,
    HDC hdcSrc,
    int xoriginSrc,
    int yoriginSrc,
    int wSrc,
    int hSrc,
    BLENDFUNCTION ftn);
 BOOL TransparentBlt(
    HDC hdcDest,
    int xoriginDest,
    int yoriginDest,
    int wDest,
    int hDest,
    HDC hdcSrc,
    int xoriginSrc,
    int yoriginSrc,
    int wSrc,
    int hSrc,
    UINT crTransparent);
//
// gradient drawing modes
//
static const int GRADIENT_FILL_RECT_H = 0x00000000;
static const int GRADIENT_FILL_RECT_V = 0x00000001;
static const int GRADIENT_FILL_TRIANGLE = 0x00000002;
static const int GRADIENT_FILL_OP_FLAG = 0x000000ff;
BOOL
GradientFill(
    HDC hdc,
    PTRIVERTEX pVertex,
    ULONG nVertex,
    PVOID pMesh,
    ULONG nMesh,
    ULONG ulMode
    );
 BOOL GdiAlphaBlend( HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);
 BOOL GdiTransparentBlt( HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc,
                                           int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);
 BOOL GdiGradientFill( HDC hdc,
                                        PTRIVERTEX pVertex,
                                        ULONG nVertex,
                                        PVOID pMesh,
                                        ULONG nCount,
                                        ULONG ulMode);
 BOOL PlayMetaFileRecord( HDC hdc,
                                            LPHANDLETABLE lpHandleTable,
                                            LPMETARECORD lpMR,
                                            UINT noObjs);
typedef int (* MFENUMPROC)( HDC hdc, HANDLETABLE * lpht, METARECORD * lpMR, int nObj, LPARAM param);
 BOOL EnumMetaFile( HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param);
typedef int (* ENHMFENUMPROC)( HDC hdc, HANDLETABLE * lpht, const ENHMETARECORD * lpmr, int nHandles, LPARAM data);
// Enhanced Metafile Function Declarations
 HENHMETAFILE CloseEnhMetaFile( HDC hdc);
 HENHMETAFILE CopyEnhMetaFileA( HENHMETAFILE hEnh, LPCSTR lpFileName);
 HENHMETAFILE CopyEnhMetaFileW( HENHMETAFILE hEnh, LPCWSTR lpFileName);
static const int CopyEnhMetaFile = CopyEnhMetaFileA;
 HDC CreateEnhMetaFileA( HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc);
 HDC CreateEnhMetaFileW( HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc);
static const int CreateEnhMetaFile = CreateEnhMetaFileA;
 BOOL DeleteEnhMetaFile( HENHMETAFILE hmf);
 BOOL EnumEnhMetaFile( HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc,
                                        LPVOID param, const RECT * lpRect);
 HENHMETAFILE GetEnhMetaFileA( LPCSTR lpName);
 HENHMETAFILE GetEnhMetaFileW( LPCWSTR lpName);
static const int GetEnhMetaFile = GetEnhMetaFileA;
 UINT GetEnhMetaFileBits( HENHMETAFILE hEMF,
                                            UINT nSize,
                                            LPBYTE lpData);
 UINT GetEnhMetaFileDescriptionA( HENHMETAFILE hemf,
                                                    UINT cchBuffer,
                                                    LPSTR lpDescription);
 UINT GetEnhMetaFileDescriptionW( HENHMETAFILE hemf,
                                                    UINT cchBuffer,
                                                    LPWSTR lpDescription);
static const int GetEnhMetaFileDescription = GetEnhMetaFileDescriptionA;
 UINT GetEnhMetaFileHeader( HENHMETAFILE hemf,
                                                UINT nSize,
                                                LPENHMETAHEADER lpEnhMetaHeader);
 UINT GetEnhMetaFilePaletteEntries( HENHMETAFILE hemf,
                                                    UINT nNumEntries,
                                                    LPPALETTEENTRY lpPaletteEntries);
 UINT GetEnhMetaFilePixelFormat( HENHMETAFILE hemf,
                                                    UINT cbBuffer,
                                                    PIXELFORMATDESCRIPTOR *ppfd);
 UINT GetWinMetaFileBits( HENHMETAFILE hemf,
                                            UINT cbData16,
                                            LPBYTE pData16,
                                            INT iMapMode,
                                            HDC hdcRef);
 BOOL PlayEnhMetaFile( HDC hdc, HENHMETAFILE hmf, const RECT * lprect);
 BOOL PlayEnhMetaFileRecord( HDC hdc,
                                                LPHANDLETABLE pht,
                                                const ENHMETARECORD *pmr,
                                                UINT cht);
 HENHMETAFILE SetEnhMetaFileBits( UINT nSize,
                                                    const BYTE * pb);
 HENHMETAFILE SetWinMetaFileBits( UINT nSize,
                                                    const BYTE *lpMeta16Data,
                                                    HDC hdcRef,
                                                    const METAFILEPICT *lpMFP);
 BOOL GdiComment( HDC hdc, UINT nSize, const BYTE *lpData);
 BOOL GetTextMetricsA( HDC hdc, LPTEXTMETRICA lptm);
 BOOL GetTextMetricsW( HDC hdc, LPTEXTMETRICW lptm);
static const int GetTextMetrics = GetTextMetricsA;
# 4334 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
/* new GDI */
typedef struct tagDIBSECTION {
    BITMAP dsBm;
    BITMAPINFOHEADER dsBmih;
    DWORD dsBitfields[3];
    HANDLE dshSection;
    DWORD dsOffset;
} DIBSECTION, *LPDIBSECTION, *PDIBSECTION;
 BOOL AngleArc( HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle);
 BOOL PolyPolyline( HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz);
 BOOL GetWorldTransform( HDC hdc, LPXFORM lpxf);
 BOOL SetWorldTransform( HDC hdc, const XFORM * lpxf);
 BOOL ModifyWorldTransform( HDC hdc, const XFORM * lpxf, DWORD mode);
 BOOL CombineTransform( LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2);
 HBITMAP CreateDIBSection( HDC hdc, const BITMAPINFO *lpbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
 UINT GetDIBColorTable( HDC hdc,
                                        UINT iStart,
                                        UINT cEntries,
                                        RGBQUAD *prgbq);
 UINT SetDIBColorTable( HDC hdc,
                                        UINT iStart,
                                        UINT cEntries,
                                        const RGBQUAD *prgbq);
/* Flags value for COLORADJUSTMENT */
static const int CA_NEGATIVE = 0x0001;
static const int CA_LOG_FILTER = 0x0002;
/* IlluminantIndex values */
static const int ILLUMINANT_DEVICE_DEFAULT = 0;
static const int ILLUMINANT_A = 1;
static const int ILLUMINANT_B = 2;
static const int ILLUMINANT_C = 3;
static const int ILLUMINANT_D50 = 4;
static const int ILLUMINANT_D55 = 5;
static const int ILLUMINANT_D65 = 6;
static const int ILLUMINANT_D75 = 7;
static const int ILLUMINANT_F2 = 8;
static const int ILLUMINANT_MAX_INDEX = ILLUMINANT_F2;
static const int ILLUMINANT_TUNGSTEN = ILLUMINANT_A;
static const int ILLUMINANT_DAYLIGHT = ILLUMINANT_C;
static const int ILLUMINANT_FLUORESCENT = ILLUMINANT_F2;
static const int ILLUMINANT_NTSC = ILLUMINANT_C;
/* Min and max for RedGamma, GreenGamma, BlueGamma */
static const int RGB_GAMMA_MIN = (WORD)02500;
static const int RGB_GAMMA_MAX = (WORD)65000;
/* Min and max for ReferenceBlack and ReferenceWhite */
static const int REFERENCE_WHITE_MIN = (WORD)6000;
static const int REFERENCE_WHITE_MAX = (WORD)10000;
static const int REFERENCE_BLACK_MIN = (WORD)0;
static const int REFERENCE_BLACK_MAX = (WORD)4000;
/* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint */
static const int COLOR_ADJ_MIN = (SHORT)-100;
static const int COLOR_ADJ_MAX = (SHORT)100;
typedef struct tagCOLORADJUSTMENT {
    WORD caSize;
    WORD caFlags;
    WORD caIlluminantIndex;
    WORD caRedGamma;
    WORD caGreenGamma;
    WORD caBlueGamma;
    WORD caReferenceBlack;
    WORD caReferenceWhite;
    SHORT caContrast;
    SHORT caBrightness;
    SHORT caColorfulness;
    SHORT caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT, *LPCOLORADJUSTMENT;
 BOOL SetColorAdjustment( HDC hdc, const COLORADJUSTMENT *lpca);
 BOOL GetColorAdjustment( HDC hdc, LPCOLORADJUSTMENT lpca);
 HPALETTE CreateHalftonePalette( HDC hdc);
typedef BOOL (* ABORTPROC)( HDC, int);
typedef struct _DOCINFOA {
    int cbSize;
    LPCSTR lpszDocName;
    LPCSTR lpszOutput;
    LPCSTR lpszDatatype;
    DWORD fwType;
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int cbSize;
    LPCWSTR lpszDocName;
    LPCWSTR lpszOutput;
    LPCWSTR lpszDatatype;
    DWORD fwType;
} DOCINFOW, *LPDOCINFOW;
typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;
static const int DI_APPBANDING = 0x00000001;
static const int DI_ROPS_READ_DESTINATION = 0x00000002;
 int StartDocA( HDC hdc, const DOCINFOA *lpdi);
 int StartDocW( HDC hdc, const DOCINFOW *lpdi);
static const int StartDoc = StartDocA;
 int EndDoc( HDC hdc);
 int StartPage( HDC hdc);
 int EndPage( HDC hdc);
 int AbortDoc( HDC hdc);
 int SetAbortProc( HDC hdc, ABORTPROC proc);
 BOOL AbortPath( HDC hdc);
 BOOL ArcTo( HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
 BOOL BeginPath( HDC hdc);
 BOOL CloseFigure( HDC hdc);
 BOOL EndPath( HDC hdc);
 BOOL FillPath( HDC hdc);
 BOOL FlattenPath( HDC hdc);
 int GetPath( HDC hdc, LPPOINT apt, LPBYTE aj, int cpt);
 HRGN PathToRegion( HDC hdc);
 BOOL PolyDraw( HDC hdc, const POINT * apt, const BYTE * aj, int cpt);
 BOOL SelectClipPath( HDC hdc, int mode);
 int SetArcDirection( HDC hdc, int dir);
 BOOL SetMiterLimit( HDC hdc, FLOAT limit, PFLOAT old);
 BOOL StrokeAndFillPath( HDC hdc);
 BOOL StrokePath( HDC hdc);
 BOOL WidenPath( HDC hdc);
 HPEN ExtCreatePen( DWORD iPenStyle,
                                    DWORD cWidth,
                                    const LOGBRUSH *plbrush,
                                    DWORD cStyle,
                                    const DWORD *pstyle);
 BOOL GetMiterLimit( HDC hdc, PFLOAT plimit);
 int GetArcDirection( HDC hdc);
 int GetObjectA( HANDLE h, int c, LPVOID pv);
 int GetObjectW( HANDLE h, int c, LPVOID pv);
static const int GetObject = GetObjectA;
# 4520 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
 BOOL MoveToEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL TextOutA( HDC hdc, int x, int y, LPCSTR lpString, int c);
 BOOL TextOutW( HDC hdc, int x, int y, LPCWSTR lpString, int c);
static const int TextOut = TextOutA;
 BOOL ExtTextOutA( HDC hdc, int x, int y, UINT options, const RECT * lprect, LPCSTR lpString, UINT c, const INT * lpDx);
 BOOL ExtTextOutW( HDC hdc, int x, int y, UINT options, const RECT * lprect, LPCWSTR lpString, UINT c, const INT * lpDx);
static const int ExtTextOut = ExtTextOutA;
 BOOL PolyTextOutA( HDC hdc, const POLYTEXTA * ppt, int nstrings);
 BOOL PolyTextOutW( HDC hdc, const POLYTEXTW * ppt, int nstrings);
static const int PolyTextOut = PolyTextOutA;
 HRGN CreatePolygonRgn( const POINT *pptl,
                                            int cPoint,
                                            int iMode);
 BOOL DPtoLP( HDC hdc, LPPOINT lppt, int c);
 BOOL LPtoDP( HDC hdc, LPPOINT lppt, int c);
 BOOL Polygon( HDC hdc, const POINT *apt, int cpt);
 BOOL Polyline( HDC hdc, const POINT *apt, int cpt);
 BOOL PolyBezier( HDC hdc, const POINT * apt, DWORD cpt);
 BOOL PolyBezierTo( HDC hdc, const POINT * apt, DWORD cpt);
 BOOL PolylineTo( HDC hdc, const POINT * apt, DWORD cpt);
 BOOL SetViewportExtEx( HDC hdc, int x, int y, LPSIZE lpsz);
 BOOL SetViewportOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL SetWindowExtEx( HDC hdc, int x, int y, LPSIZE lpsz);
 BOOL SetWindowOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL OffsetViewportOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL OffsetWindowOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL ScaleViewportExtEx( HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz);
 BOOL ScaleWindowExtEx( HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz);
 BOOL SetBitmapDimensionEx( HBITMAP hbm, int w, int h, LPSIZE lpsz);
 BOOL SetBrushOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 int GetTextFaceA( HDC hdc, int c, LPSTR lpName);
 int GetTextFaceW( HDC hdc, int c, LPWSTR lpName);
static const int GetTextFace = GetTextFaceA;
static const int FONTMAPPER_MAX = 10;
typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;
 DWORD GetKerningPairsA( HDC hdc,
                                            DWORD nPairs,
                                            LPKERNINGPAIR lpKernPair);
 DWORD GetKerningPairsW( HDC hdc,
                                            DWORD nPairs,
                                            LPKERNINGPAIR lpKernPair);
static const int GetKerningPairs = GetKerningPairsA;
 BOOL GetDCOrgEx( HDC hdc, LPPOINT lppt);
 BOOL FixBrushOrgEx( HDC hdc, int x, int y, LPPOINT ptl);
 BOOL UnrealizeObject( HGDIOBJ h);
 BOOL GdiFlush(void);
 DWORD GdiSetBatchLimit( DWORD dw);
 DWORD GdiGetBatchLimit(void);
static const int ICM_OFF = 1;
static const int ICM_ON = 2;
static const int ICM_QUERY = 3;
static const int ICM_DONE_OUTSIDEDC = 4;
typedef int (* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (* ICMENUMPROCW)(LPWSTR, LPARAM);
static const int ICMENUMPROC = ICMENUMPROCA;
 int SetICMMode( HDC hdc, int mode);
 BOOL CheckColorsInGamut( HDC hdc,
                                                    LPRGBTRIPLE lpRGBTriple,
                                                    LPVOID dlpBuffer,
                                                    DWORD nCount);
 HCOLORSPACE GetColorSpace( HDC hdc);
 BOOL GetLogColorSpaceA( HCOLORSPACE hColorSpace,
                                                LPLOGCOLORSPACEA lpBuffer,
                                                DWORD nSize);
 BOOL GetLogColorSpaceW( HCOLORSPACE hColorSpace,
                                                LPLOGCOLORSPACEW lpBuffer,
                                                DWORD nSize);
static const int GetLogColorSpace = GetLogColorSpaceA;
 HCOLORSPACE CreateColorSpaceA( LPLOGCOLORSPACEA lplcs);
 HCOLORSPACE CreateColorSpaceW( LPLOGCOLORSPACEW lplcs);
static const int CreateColorSpace = CreateColorSpaceA;
 HCOLORSPACE SetColorSpace( HDC hdc, HCOLORSPACE hcs);
 BOOL DeleteColorSpace( HCOLORSPACE hcs);
 BOOL GetICMProfileA( HDC hdc,
                                                LPDWORD pBufSize,
                                                LPSTR pszFilename);
 BOOL GetICMProfileW( HDC hdc,
                                                LPDWORD pBufSize,
                                                LPWSTR pszFilename);
static const int GetICMProfile = GetICMProfileA;
 BOOL SetICMProfileA( HDC hdc, LPSTR lpFileName);
 BOOL SetICMProfileW( HDC hdc, LPWSTR lpFileName);
static const int SetICMProfile = SetICMProfileA;
 BOOL GetDeviceGammaRamp( HDC hdc, LPVOID lpRamp);
 BOOL SetDeviceGammaRamp( HDC hdc, LPVOID lpRamp);
 BOOL ColorMatchToTarget( HDC hdc, HDC hdcTarget, DWORD action);
 int EnumICMProfilesA( HDC hdc, ICMENUMPROCA proc, LPARAM param);
 int EnumICMProfilesW( HDC hdc, ICMENUMPROCW proc, LPARAM param);
static const int EnumICMProfiles = EnumICMProfilesA;
// The Win95 update API UpdateICMRegKeyA is deprecated to set last error to ERROR_NOT_SUPPORTED and return FALSE
 BOOL UpdateICMRegKeyA( DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command);
// The Win95 update API UpdateICMRegKeyW is deprecated to set last error to ERROR_NOT_SUPPORTED and return FALSE
 BOOL UpdateICMRegKeyW( DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command);
static const int UpdateICMRegKey = UpdateICMRegKeyA;
#pragma deprecated (UpdateICMRegKeyW)
#pragma deprecated (UpdateICMRegKeyA)
 BOOL ColorCorrectPalette( HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num);
// Enhanced metafile constants.
static const int ENHMETA_SIGNATURE = 0x464D4520;
// Stock object flag used in the object handle index in the enhanced
// metafile records.
// E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH)
// represents the stock object BLACK_BRUSH.
static const int ENHMETA_STOCK_OBJECT = 0x80000000;
// Enhanced metafile record types.
static const int EMR_HEADER = 1;
static const int EMR_POLYBEZIER = 2;
static const int EMR_POLYGON = 3;
static const int EMR_POLYLINE = 4;
static const int EMR_POLYBEZIERTO = 5;
static const int EMR_POLYLINETO = 6;
static const int EMR_POLYPOLYLINE = 7;
static const int EMR_POLYPOLYGON = 8;
static const int EMR_SETWINDOWEXTEX = 9;
static const int EMR_SETWINDOWORGEX = 10;
static const int EMR_SETVIEWPORTEXTEX = 11;
static const int EMR_SETVIEWPORTORGEX = 12;
static const int EMR_SETBRUSHORGEX = 13;
static const int EMR_EOF = 14;
static const int EMR_SETPIXELV = 15;
static const int EMR_SETMAPPERFLAGS = 16;
static const int EMR_SETMAPMODE = 17;
static const int EMR_SETBKMODE = 18;
static const int EMR_SETPOLYFILLMODE = 19;
static const int EMR_SETROP2 = 20;
static const int EMR_SETSTRETCHBLTMODE = 21;
static const int EMR_SETTEXTALIGN = 22;
static const int EMR_SETCOLORADJUSTMENT = 23;
static const int EMR_SETTEXTCOLOR = 24;
static const int EMR_SETBKCOLOR = 25;
static const int EMR_OFFSETCLIPRGN = 26;
static const int EMR_MOVETOEX = 27;
static const int EMR_SETMETARGN = 28;
static const int EMR_EXCLUDECLIPRECT = 29;
static const int EMR_INTERSECTCLIPRECT = 30;
static const int EMR_SCALEVIEWPORTEXTEX = 31;
static const int EMR_SCALEWINDOWEXTEX = 32;
static const int EMR_SAVEDC = 33;
static const int EMR_RESTOREDC = 34;
static const int EMR_SETWORLDTRANSFORM = 35;
static const int EMR_MODIFYWORLDTRANSFORM = 36;
static const int EMR_SELECTOBJECT = 37;
static const int EMR_CREATEPEN = 38;
static const int EMR_CREATEBRUSHINDIRECT = 39;
static const int EMR_DELETEOBJECT = 40;
static const int EMR_ANGLEARC = 41;
static const int EMR_ELLIPSE = 42;
static const int EMR_RECTANGLE = 43;
static const int EMR_ROUNDRECT = 44;
static const int EMR_ARC = 45;
static const int EMR_CHORD = 46;
static const int EMR_PIE = 47;
static const int EMR_SELECTPALETTE = 48;
static const int EMR_CREATEPALETTE = 49;
static const int EMR_SETPALETTEENTRIES = 50;
static const int EMR_RESIZEPALETTE = 51;
static const int EMR_REALIZEPALETTE = 52;
static const int EMR_EXTFLOODFILL = 53;
static const int EMR_LINETO = 54;
static const int EMR_ARCTO = 55;
static const int EMR_POLYDRAW = 56;
static const int EMR_SETARCDIRECTION = 57;
static const int EMR_SETMITERLIMIT = 58;
static const int EMR_BEGINPATH = 59;
static const int EMR_ENDPATH = 60;
static const int EMR_CLOSEFIGURE = 61;
static const int EMR_FILLPATH = 62;
static const int EMR_STROKEANDFILLPATH = 63;
static const int EMR_STROKEPATH = 64;
static const int EMR_FLATTENPATH = 65;
static const int EMR_WIDENPATH = 66;
static const int EMR_SELECTCLIPPATH = 67;
static const int EMR_ABORTPATH = 68;
static const int EMR_GDICOMMENT = 70;
static const int EMR_FILLRGN = 71;
static const int EMR_FRAMERGN = 72;
static const int EMR_INVERTRGN = 73;
static const int EMR_PAINTRGN = 74;
static const int EMR_EXTSELECTCLIPRGN = 75;
static const int EMR_BITBLT = 76;
static const int EMR_STRETCHBLT = 77;
static const int EMR_MASKBLT = 78;
static const int EMR_PLGBLT = 79;
static const int EMR_SETDIBITSTODEVICE = 80;
static const int EMR_STRETCHDIBITS = 81;
static const int EMR_EXTCREATEFONTINDIRECTW = 82;
static const int EMR_EXTTEXTOUTA = 83;
static const int EMR_EXTTEXTOUTW = 84;
static const int EMR_POLYBEZIER16 = 85;
static const int EMR_POLYGON16 = 86;
static const int EMR_POLYLINE16 = 87;
static const int EMR_POLYBEZIERTO16 = 88;
static const int EMR_POLYLINETO16 = 89;
static const int EMR_POLYPOLYLINE16 = 90;
static const int EMR_POLYPOLYGON16 = 91;
static const int EMR_POLYDRAW16 = 92;
static const int EMR_CREATEMONOBRUSH = 93;
static const int EMR_CREATEDIBPATTERNBRUSHPT = 94;
static const int EMR_EXTCREATEPEN = 95;
static const int EMR_POLYTEXTOUTA = 96;
static const int EMR_POLYTEXTOUTW = 97;
static const int EMR_SETICMMODE = 98;
static const int EMR_CREATECOLORSPACE = 99;
static const int EMR_SETCOLORSPACE = 100;
static const int EMR_DELETECOLORSPACE = 101;
static const int EMR_GLSRECORD = 102;
static const int EMR_GLSBOUNDEDRECORD = 103;
static const int EMR_PIXELFORMAT = 104;
static const int EMR_RESERVED_105 = 105;
static const int EMR_RESERVED_106 = 106;
static const int EMR_RESERVED_107 = 107;
static const int EMR_RESERVED_108 = 108;
static const int EMR_RESERVED_109 = 109;
static const int EMR_RESERVED_110 = 110;
static const int EMR_COLORCORRECTPALETTE = 111;
static const int EMR_SETICMPROFILEA = 112;
static const int EMR_SETICMPROFILEW = 113;
static const int EMR_ALPHABLEND = 114;
static const int EMR_SETLAYOUT = 115;
static const int EMR_TRANSPARENTBLT = 116;
static const int EMR_RESERVED_117 = 117;
static const int EMR_GRADIENTFILL = 118;
static const int EMR_RESERVED_119 = 119;
static const int EMR_RESERVED_120 = 120;
static const int EMR_COLORMATCHTOTARGETW = 121;
static const int EMR_CREATECOLORSPACEW = 122;
static const int EMR_MIN = 1;
static const int EMR_MAX = 122;
// Base record type for the enhanced metafile.
typedef struct tagEMR
{
    DWORD iType; // Enhanced metafile record type
    DWORD nSize; // Length of the record in bytes.
                                // This must be a multiple of 4.
} EMR, *PEMR;
// Base text record type for the enhanced metafile.
typedef struct tagEMRTEXT
{
    POINTL ptlReference;
    DWORD nChars;
    DWORD offString; // Offset to the string
    DWORD fOptions;
    RECTL rcl;
    DWORD offDx; // Offset to the inter-character spacing array.
                                // This is always given.
} EMRTEXT, *PEMRTEXT;
// Record structures for the enhanced metafile.
typedef struct tagABORTPATH
{
    EMR emr;
} EMRABORTPATH, *PEMRABORTPATH,
  EMRBEGINPATH, *PEMRBEGINPATH,
  EMRENDPATH, *PEMRENDPATH,
  EMRCLOSEFIGURE, *PEMRCLOSEFIGURE,
  EMRFLATTENPATH, *PEMRFLATTENPATH,
  EMRWIDENPATH, *PEMRWIDENPATH,
  EMRSETMETARGN, *PEMRSETMETARGN,
  EMRSAVEDC, *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;
typedef struct tagEMRSELECTCLIPPATH
{
    EMR emr;
    DWORD iMode;
} EMRSELECTCLIPPATH, *PEMRSELECTCLIPPATH,
  EMRSETBKMODE, *PEMRSETBKMODE,
  EMRSETMAPMODE, *PEMRSETMAPMODE,
  EMRSETLAYOUT, *PEMRSETLAYOUT,
  EMRSETPOLYFILLMODE, *PEMRSETPOLYFILLMODE,
  EMRSETROP2, *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE, *PEMRSETICMMODE,
  EMRSETTEXTALIGN, *PEMRSETTEXTALIGN;
typedef struct tagEMRSETMITERLIMIT
{
    EMR emr;
    FLOAT eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;
typedef struct tagEMRRESTOREDC
{
    EMR emr;
    LONG iRelative; // Specifies a relative instance
} EMRRESTOREDC, *PEMRRESTOREDC;
typedef struct tagEMRSETARCDIRECTION
{
    EMR emr;
    DWORD iArcDirection; // Specifies the arc direction in the
                                // advanced graphics mode.
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;
typedef struct tagEMRSETMAPPERFLAGS
{
    EMR emr;
    DWORD dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;
typedef struct tagEMRSETTEXTCOLOR
{
    EMR emr;
    COLORREF crColor;
} EMRSETBKCOLOR, *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;
typedef struct tagEMRSELECTOBJECT
{
    EMR emr;
    DWORD ihObject; // Object handle index
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;
typedef struct tagEMRSELECTPALETTE
{
    EMR emr;
    DWORD ihPal; // Palette handle index, background mode only
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;
typedef struct tagEMRRESIZEPALETTE
{
    EMR emr;
    DWORD ihPal; // Palette handle index
    DWORD cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;
typedef struct tagEMRSETPALETTEENTRIES
{
    EMR emr;
    DWORD ihPal; // Palette handle index
    DWORD iStart;
    DWORD cEntries;
    PALETTEENTRY aPalEntries[1];// The peFlags fields do not contain any flags
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;
typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;
typedef struct tagEMRGDICOMMENT
{
    EMR emr;
    DWORD cbData; // Size of data in bytes
    BYTE Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;
typedef struct tagEMREOF
{
    EMR emr;
    DWORD nPalEntries; // Number of palette entries
    DWORD offPalEntries; // Offset to the palette entries
    DWORD nSizeLast; // Same as nSize and must be the last DWORD
                                // of the record.  The palette entries,
                                // if exist, precede this field.
} EMREOF, *PEMREOF;
typedef struct tagEMRLINETO
{
    EMR emr;
    POINTL ptl;
} EMRLINETO, *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;
typedef struct tagEMROFFSETCLIPRGN
{
    EMR emr;
    POINTL ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;
typedef struct tagEMRFILLPATH
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
} EMRFILLPATH, *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH, *PEMRSTROKEPATH;
typedef struct tagEMREXCLUDECLIPRECT
{
    EMR emr;
    RECTL rclClip;
} EMREXCLUDECLIPRECT, *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;
typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR emr;
    POINTL ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX, *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX, *PEMRSETBRUSHORGEX;
typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR emr;
    SIZEL szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX, *PEMRSETWINDOWEXTEX;
typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR emr;
    LONG xNum;
    LONG xDenom;
    LONG yNum;
    LONG yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX, *PEMRSCALEWINDOWEXTEX;
typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR emr;
    XFORM xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;
typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR emr;
    XFORM xform;
    DWORD iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;
typedef struct tagEMRSETPIXELV
{
    EMR emr;
    POINTL ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;
typedef struct tagEMREXTFLOODFILL
{
    EMR emr;
    POINTL ptlStart;
    COLORREF crColor;
    DWORD iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;
typedef struct tagEMRELLIPSE
{
    EMR emr;
    RECTL rclBox; // Inclusive-inclusive bounding rectangle
} EMRELLIPSE, *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;
typedef struct tagEMRROUNDRECT
{
    EMR emr;
    RECTL rclBox; // Inclusive-inclusive bounding rectangle
    SIZEL szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;
typedef struct tagEMRARC
{
    EMR emr;
    RECTL rclBox; // Inclusive-inclusive bounding rectangle
    POINTL ptlStart;
    POINTL ptlEnd;
} EMRARC, *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE, *PEMRPIE;
typedef struct tagEMRANGLEARC
{
    EMR emr;
    POINTL ptlCenter;
    DWORD nRadius;
    FLOAT eStartAngle;
    FLOAT eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;
typedef struct tagEMRPOLYLINE
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cptl;
    POINTL aptl[1];
} EMRPOLYLINE, *PEMRPOLYLINE,
  EMRPOLYBEZIER, *PEMRPOLYBEZIER,
  EMRPOLYGON, *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO, *PEMRPOLYLINETO;
typedef struct tagEMRPOLYLINE16
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cpts;
    POINTS apts[1];
} EMRPOLYLINE16, *PEMRPOLYLINE16,
  EMRPOLYBEZIER16, *PEMRPOLYBEZIER16,
  EMRPOLYGON16, *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16, *PEMRPOLYLINETO16;
typedef struct tagEMRPOLYDRAW
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cptl; // Number of points
    POINTL aptl[1]; // Array of points
    BYTE abTypes[1]; // Array of point types
} EMRPOLYDRAW, *PEMRPOLYDRAW;
typedef struct tagEMRPOLYDRAW16
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cpts; // Number of points
    POINTS apts[1]; // Array of points
    BYTE abTypes[1]; // Array of point types
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;
typedef struct tagEMRPOLYPOLYLINE
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD nPolys; // Number of polys
    DWORD cptl; // Total number of points in all polys
    DWORD aPolyCounts[1]; // Array of point counts for each poly
    POINTL aptl[1]; // Array of points
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON, *PEMRPOLYPOLYGON;
typedef struct tagEMRPOLYPOLYLINE16
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD nPolys; // Number of polys
    DWORD cpts; // Total number of points in all polys
    DWORD aPolyCounts[1]; // Array of point counts for each poly
    POINTS apts[1]; // Array of points
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16, *PEMRPOLYPOLYGON16;
typedef struct tagEMRINVERTRGN
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cbRgnData; // Size of region data in bytes
    BYTE RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN, *PEMRPAINTRGN;
typedef struct tagEMRFILLRGN
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cbRgnData; // Size of region data in bytes
    DWORD ihBrush; // Brush handle index
    BYTE RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;
typedef struct tagEMRFRAMERGN
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cbRgnData; // Size of region data in bytes
    DWORD ihBrush; // Brush handle index
    SIZEL szlStroke;
    BYTE RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;
typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR emr;
    DWORD cbRgnData; // Size of region data in bytes
    DWORD iMode;
    BYTE RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;
typedef struct tagEMREXTTEXTOUTA
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD iGraphicsMode; // Current graphics mode
    FLOAT exScale; // X and Y scales from Page units to .01mm units
    FLOAT eyScale; //   if graphics mode is GM_COMPATIBLE.
    EMRTEXT emrtext; // This is followed by the string and spacing
                                // array
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;
typedef struct tagEMRPOLYTEXTOUTA
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD iGraphicsMode; // Current graphics mode
    FLOAT exScale; // X and Y scales from Page units to .01mm units
    FLOAT eyScale; //   if graphics mode is GM_COMPATIBLE.
    LONG cStrings;
    EMRTEXT aemrtext[1]; // Array of EMRTEXT structures.  This is
                                // followed by the strings and spacing arrays.
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;
typedef struct tagEMRBITBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
} EMRBITBLT, *PEMRBITBLT;
typedef struct tagEMRSTRETCHBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG cxSrc;
    LONG cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;
typedef struct tagEMRMASKBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG xMask;
    LONG yMask;
    DWORD iUsageMask; // Mask bitmap info color table usage
    DWORD offBmiMask; // Offset to the mask BITMAPINFO structure if any
    DWORD cbBmiMask; // Size of the mask BITMAPINFO structure if any
    DWORD offBitsMask; // Offset to the mask bitmap bits if any
    DWORD cbBitsMask; // Size of the mask bitmap bits if any
} EMRMASKBLT, *PEMRMASKBLT;
typedef struct tagEMRPLGBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    POINTL aptlDest[3];
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG xMask;
    LONG yMask;
    DWORD iUsageMask; // Mask bitmap info color table usage
    DWORD offBmiMask; // Offset to the mask BITMAPINFO structure if any
    DWORD cbBmiMask; // Size of the mask BITMAPINFO structure if any
    DWORD offBitsMask; // Offset to the mask bitmap bits if any
    DWORD cbBitsMask; // Size of the mask bitmap bits if any
} EMRPLGBLT, *PEMRPLGBLT;
typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    DWORD iUsageSrc; // Source bitmap info color table usage
    DWORD iStartScan;
    DWORD cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;
typedef struct tagEMRSTRETCHDIBITS
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    DWORD iUsageSrc; // Source bitmap info color table usage
    DWORD dwRop;
    LONG cxDest;
    LONG cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;
typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR emr;
    DWORD ihFont; // Font handle index
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;
typedef struct tagEMRCREATEPALETTE
{
    EMR emr;
    DWORD ihPal; // Palette handle index
    LOGPALETTE lgpl; // The peFlags fields in the palette entries
                                // do not contain any flags
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;
typedef struct tagEMRCREATEPEN
{
    EMR emr;
    DWORD ihPen; // Pen handle index
    LOGPEN lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;
typedef struct tagEMREXTCREATEPEN
{
    EMR emr;
    DWORD ihPen; // Pen handle index
    DWORD offBmi; // Offset to the BITMAPINFO structure if any
    DWORD cbBmi; // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD offBits; // Offset to the brush bitmap bits if any
    DWORD cbBits; // Size of the brush bitmap bits if any
    EXTLOGPEN32 elp; // The extended pen with the style array.
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;
typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR emr;
    DWORD ihBrush; // Brush handle index
    LOGBRUSH32 lb; // The style must be BS_SOLID, BS_HOLLOW,
                                 // BS_NULL or BS_HATCHED.
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;
typedef struct tagEMRCREATEMONOBRUSH
{
    EMR emr;
    DWORD ihBrush; // Brush handle index
    DWORD iUsage; // Bitmap info color table usage
    DWORD offBmi; // Offset to the BITMAPINFO structure
    DWORD cbBmi; // Size of the BITMAPINFO structure
    DWORD offBits; // Offset to the bitmap bits
    DWORD cbBits; // Size of the bitmap bits
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;
typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR emr;
    DWORD ihBrush; // Brush handle index
    DWORD iUsage; // Bitmap info color table usage
    DWORD offBmi; // Offset to the BITMAPINFO structure
    DWORD cbBmi; // Size of the BITMAPINFO structure
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD offBits; // Offset to the bitmap bits
    DWORD cbBits; // Size of the bitmap bits
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;
typedef struct tagEMRFORMAT
{
    DWORD dSignature; // Format signature, e.g. ENHMETA_SIGNATURE.
    DWORD nVersion; // Format version number.
    DWORD cbData; // Size of data in bytes.
    DWORD offData; // Offset to data from GDICOMMENT_IDENTIFIER.
                                // It must begin at a DWORD offset.
} EMRFORMAT, *PEMRFORMAT;
typedef struct tagEMRGLSRECORD
{
    EMR emr;
    DWORD cbData; // Size of data in bytes
    BYTE Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;
typedef struct tagEMRGLSBOUNDEDRECORD
{
    EMR emr;
    RECTL rclBounds; // Bounds in recording coordinates
    DWORD cbData; // Size of data in bytes
    BYTE Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;
typedef struct tagEMRPIXELFORMAT
{
    EMR emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;
typedef struct tagEMRCREATECOLORSPACE
{
    EMR emr;
    DWORD ihCS; // ColorSpace handle index
    LOGCOLORSPACEA lcs; // Ansi version of LOGCOLORSPACE
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;
typedef struct tagEMRSETCOLORSPACE
{
    EMR emr;
    DWORD ihCS; // ColorSpace handle index
} EMRSETCOLORSPACE, *PEMRSETCOLORSPACE,
  EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;
typedef struct tagEMREXTESCAPE
{
    EMR emr;
    INT iEscape; // Escape code
    INT cbEscData; // Size of escape data
    BYTE EscData[1]; // Escape data
} EMREXTESCAPE, *PEMREXTESCAPE,
  EMRDRAWESCAPE, *PEMRDRAWESCAPE;
typedef struct tagEMRNAMEDESCAPE
{
    EMR emr;
    INT iEscape; // Escape code
    INT cbDriver; // Size of driver name
    INT cbEscData; // Size of escape data
    BYTE EscData[1]; // Driver name and Escape data
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;
static const int SETICMPROFILE_EMBEDED = 0x00000001;
typedef struct tagEMRSETICMPROFILE
{
    EMR emr;
    DWORD dwFlags; // flags
    DWORD cbName; // Size of desired profile name
    DWORD cbData; // Size of raw profile data if attached
    BYTE Data[1]; // Array size is cbName + cbData
} EMRSETICMPROFILE, *PEMRSETICMPROFILE,
  EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
  EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;
static const int CREATECOLORSPACE_EMBEDED = 0x00000001;
typedef struct tagEMRCREATECOLORSPACEW
{
    EMR emr;
    DWORD ihCS; // ColorSpace handle index
    LOGCOLORSPACEW lcs; // Unicode version of logical color space structure
    DWORD dwFlags; // flags
    DWORD cbData; // size of raw source profile data if attached
    BYTE Data[1]; // Array size is cbData
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;
static const int COLORMATCHTOTARGET_EMBEDED = 0x00000001;
typedef struct tagCOLORMATCHTOTARGET
{
    EMR emr;
    DWORD dwAction; // CS_ENABLE, CS_DISABLE or CS_DELETE_TRANSFORM
    DWORD dwFlags; // flags
    DWORD cbName; // Size of desired target profile name
    DWORD cbData; // Size of raw target profile data if attached
    BYTE Data[1]; // Array size is cbName + cbData
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;
typedef struct tagCOLORCORRECTPALETTE
{
    EMR emr;
    DWORD ihPalette; // Palette handle index
    DWORD nFirstEntry; // Index of first entry to correct
    DWORD nPalEntries; // Number of palette entries to correct
    DWORD nReserved; // Reserved
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;
typedef struct tagEMRALPHABLEND
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG cxSrc;
    LONG cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;
typedef struct tagEMRGRADIENTFILL
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD nVer;
    DWORD nTri;
    ULONG ulMode;
    TRIVERTEX Ver[1];
}EMRGRADIENTFILL,*PEMRGRADIENTFILL;
typedef struct tagEMRTRANSPARENTBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG cxSrc;
    LONG cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;
static const int GDICOMMENT_IDENTIFIER = 0x43494447;
static const int GDICOMMENT_WINDOWS_METAFILE = 0x80000001;
static const int GDICOMMENT_BEGINGROUP = 0x00000002;
static const int GDICOMMENT_ENDGROUP = 0x00000003;
static const int GDICOMMENT_MULTIFORMATS = 0x40000004;
static const int EPS_SIGNATURE = 0x46535045;
static const int GDICOMMENT_UNICODE_STRING = 0x00000040;
static const int GDICOMMENT_UNICODE_END = 0x00000080;
// OpenGL wgl prototypes
 BOOL wglCopyContext(HGLRC, HGLRC, UINT);
 HGLRC wglCreateContext(HDC);
 HGLRC wglCreateLayerContext(HDC, int);
 BOOL wglDeleteContext(HGLRC);
 HGLRC wglGetCurrentContext(void);
 HDC wglGetCurrentDC(void);
 PROC wglGetProcAddress(LPCSTR);
 BOOL wglMakeCurrent(HDC, HGLRC);
 BOOL wglShareLists(HGLRC, HGLRC);
 BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
 BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);
static const int wglUseFontBitmaps = wglUseFontBitmapsA;
 BOOL SwapBuffers(HDC);
typedef struct _POINTFLOAT {
    FLOAT x;
    FLOAT y;
} POINTFLOAT, *PPOINTFLOAT;
typedef struct _GLYPHMETRICSFLOAT {
    FLOAT gmfBlackBoxX;
    FLOAT gmfBlackBoxY;
    POINTFLOAT gmfptGlyphOrigin;
    FLOAT gmfCellIncX;
    FLOAT gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT, *LPGLYPHMETRICSFLOAT;
static const int WGL_FONT_LINES = 0;
static const int WGL_FONT_POLYGONS = 1;
 BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
 BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
static const int wglUseFontOutlines = wglUseFontOutlinesA;
/* Layer plane descriptor */
typedef struct tagLAYERPLANEDESCRIPTOR { // lpd
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerPlane;
    BYTE bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR, *LPLAYERPLANEDESCRIPTOR;
/* LAYERPLANEDESCRIPTOR flags */
static const int LPD_DOUBLEBUFFER = 0x00000001;
static const int LPD_STEREO = 0x00000002;
static const int LPD_SUPPORT_GDI = 0x00000010;
static const int LPD_SUPPORT_OPENGL = 0x00000020;
static const int LPD_SHARE_DEPTH = 0x00000040;
static const int LPD_SHARE_STENCIL = 0x00000080;
static const int LPD_SHARE_ACCUM = 0x00000100;
static const int LPD_SWAP_EXCHANGE = 0x00000200;
static const int LPD_SWAP_COPY = 0x00000400;
static const int LPD_TRANSPARENT = 0x00001000;
static const int LPD_TYPE_RGBA = 0;
static const int LPD_TYPE_COLORINDEX = 1;
/* wglSwapLayerBuffers flags */
static const int WGL_SWAP_MAIN_PLANE = 0x00000001;
static const int WGL_SWAP_OVERLAY1 = 0x00000002;
static const int WGL_SWAP_OVERLAY2 = 0x00000004;
static const int WGL_SWAP_OVERLAY3 = 0x00000008;
static const int WGL_SWAP_OVERLAY4 = 0x00000010;
static const int WGL_SWAP_OVERLAY5 = 0x00000020;
static const int WGL_SWAP_OVERLAY6 = 0x00000040;
static const int WGL_SWAP_OVERLAY7 = 0x00000080;
static const int WGL_SWAP_OVERLAY8 = 0x00000100;
static const int WGL_SWAP_OVERLAY9 = 0x00000200;
static const int WGL_SWAP_OVERLAY10 = 0x00000400;
static const int WGL_SWAP_OVERLAY11 = 0x00000800;
static const int WGL_SWAP_OVERLAY12 = 0x00001000;
static const int WGL_SWAP_OVERLAY13 = 0x00002000;
static const int WGL_SWAP_OVERLAY14 = 0x00004000;
static const int WGL_SWAP_OVERLAY15 = 0x00008000;
static const int WGL_SWAP_UNDERLAY1 = 0x00010000;
static const int WGL_SWAP_UNDERLAY2 = 0x00020000;
static const int WGL_SWAP_UNDERLAY3 = 0x00040000;
static const int WGL_SWAP_UNDERLAY4 = 0x00080000;
static const int WGL_SWAP_UNDERLAY5 = 0x00100000;
static const int WGL_SWAP_UNDERLAY6 = 0x00200000;
static const int WGL_SWAP_UNDERLAY7 = 0x00400000;
static const int WGL_SWAP_UNDERLAY8 = 0x00800000;
static const int WGL_SWAP_UNDERLAY9 = 0x01000000;
static const int WGL_SWAP_UNDERLAY10 = 0x02000000;
static const int WGL_SWAP_UNDERLAY11 = 0x04000000;
static const int WGL_SWAP_UNDERLAY12 = 0x08000000;
static const int WGL_SWAP_UNDERLAY13 = 0x10000000;
static const int WGL_SWAP_UNDERLAY14 = 0x20000000;
static const int WGL_SWAP_UNDERLAY15 = 0x40000000;
 BOOL wglDescribeLayerPlane(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
 int wglSetLayerPaletteEntries(HDC, int, int, int,
                                                 const COLORREF *);
 int wglGetLayerPaletteEntries(HDC, int, int, int,
                                                 COLORREF *);
 BOOL wglRealizeLayerPalette(HDC, int, BOOL);
 BOOL wglSwapLayerBuffers(HDC, UINT);
typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP, *LPWGLSWAP;
static const int WGL_SWAPMULTIPLE_MAX = 16;
 DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *);
# 158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 1
/****************************************************************************
*                                                                           *
* winuser.h -- USER procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.                 *
*                                                                           *
****************************************************************************/
# 12 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
//
// Define API decoration for direct importing of DLL references.
//
static const int WINUSERAPI = DECLSPEC_IMPORT;
static const int WINABLEAPI = DECLSPEC_IMPORT;
# 46 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;
typedef MENUTEMPLATEA MENUTEMPLATE;
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;
typedef LPMENUTEMPLATEA LPMENUTEMPLATE;
typedef LRESULT (* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
typedef INT_PTR (* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
typedef void (* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
typedef BOOL (* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void (* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);
typedef BOOL (* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);
typedef BOOL (* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);
typedef int (* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);
typedef BOOL (* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
# 117 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef PROPENUMPROCA PROPENUMPROC;
typedef PROPENUMPROCEXA PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA EDITWORDBREAKPROC;
typedef BOOL (* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (* NAMEENUMPROCW)(LPWSTR, LPARAM);
typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;
# 151 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef WINSTAENUMPROCA WINSTAENUMPROC;
typedef DESKTOPENUMPROCA DESKTOPENUMPROC;
static const int IS_INTRESOURCE(_r) = ((((ULONG_PTR)(_r)) >> 16) == 0);
static const int MAKEINTRESOURCEA(i) = ((LPSTR)((ULONG_PTR)((WORD)(i))));
static const int MAKEINTRESOURCEW(i) = ((LPWSTR)((ULONG_PTR)((WORD)(i))));
static const int MAKEINTRESOURCE = MAKEINTRESOURCEA;
/*
 * Predefined Resource Types
 */
# 170 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RT_CURSOR = MAKEINTRESOURCE(1);
static const int RT_BITMAP = MAKEINTRESOURCE(2);
static const int RT_ICON = MAKEINTRESOURCE(3);
static const int RT_MENU = MAKEINTRESOURCE(4);
static const int RT_DIALOG = MAKEINTRESOURCE(5);
static const int RT_STRING = MAKEINTRESOURCE(6);
static const int RT_FONTDIR = MAKEINTRESOURCE(7);
static const int RT_FONT = MAKEINTRESOURCE(8);
static const int RT_ACCELERATOR = MAKEINTRESOURCE(9);
static const int RT_RCDATA = MAKEINTRESOURCE(10);
static const int RT_MESSAGETABLE = MAKEINTRESOURCE(11);
static const int DIFFERENCE = 11;
static const int RT_GROUP_CURSOR = MAKEINTRESOURCE((ULONG_PTR)(RT_CURSOR) + DIFFERENCE);
static const int RT_GROUP_ICON = MAKEINTRESOURCE((ULONG_PTR)(RT_ICON) + DIFFERENCE);
static const int RT_VERSION = MAKEINTRESOURCE(16);
static const int RT_DLGINCLUDE = MAKEINTRESOURCE(17);
static const int RT_PLUGPLAY = MAKEINTRESOURCE(19);
static const int RT_VXD = MAKEINTRESOURCE(20);
static const int RT_ANICURSOR = MAKEINTRESOURCE(21);
static const int RT_ANIICON = MAKEINTRESOURCE(22);
static const int RT_HTML = MAKEINTRESOURCE(23);
# 202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RT_MANIFEST = MAKEINTRESOURCE(24);
static const int CREATEPROCESS_MANIFEST_RESOURCE_ID = MAKEINTRESOURCE( 1);
static const int ISOLATIONAWARE_MANIFEST_RESOURCE_ID = MAKEINTRESOURCE(2);
static const int ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID = MAKEINTRESOURCE(3);
static const int MINIMUM_RESERVED_MANIFEST_RESOURCE_ID = MAKEINTRESOURCE( 1 );
static const int MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID = MAKEINTRESOURCE(16 );
# 218 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
int
wvsprintfA(
    LPSTR,
    LPCSTR,
    va_list arglist);
int
wvsprintfW(
    LPWSTR,
    LPCWSTR,
    va_list arglist);
static const int wvsprintf = wvsprintfA;
int
wsprintfA(
    LPSTR,
    LPCSTR,
    ...);
int
wsprintfW(
    LPWSTR,
    LPCWSTR,
    ...);
static const int wsprintf = wsprintfA;
/*
 * SPI_SETDESKWALLPAPER defined constants
 */
# 266 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SETWALLPAPER_DEFAULT = ((LPWSTR)-1);
/*
 * Scroll Bar Constants
 */
# 273 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SB_HORZ = 0;
static const int SB_VERT = 1;
static const int SB_CTL = 2;
static const int SB_BOTH = 3;
/*
 * Scroll Bar Commands
 */
# 281 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SB_LINEUP = 0;
static const int SB_LINELEFT = 0;
static const int SB_LINEDOWN = 1;
static const int SB_LINERIGHT = 1;
static const int SB_PAGEUP = 2;
static const int SB_PAGELEFT = 2;
static const int SB_PAGEDOWN = 3;
static const int SB_PAGERIGHT = 3;
static const int SB_THUMBPOSITION = 4;
static const int SB_THUMBTRACK = 5;
static const int SB_TOP = 6;
static const int SB_LEFT = 6;
static const int SB_BOTTOM = 7;
static const int SB_RIGHT = 7;
static const int SB_ENDSCROLL = 8;
/*
 * ShowWindow() Commands
 */
# 305 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SW_HIDE = 0;
static const int SW_SHOWNORMAL = 1;
static const int SW_NORMAL = 1;
static const int SW_SHOWMINIMIZED = 2;
static const int SW_SHOWMAXIMIZED = 3;
static const int SW_MAXIMIZE = 3;
static const int SW_SHOWNOACTIVATE = 4;
static const int SW_SHOW = 5;
static const int SW_MINIMIZE = 6;
static const int SW_SHOWMINNOACTIVE = 7;
static const int SW_SHOWNA = 8;
static const int SW_RESTORE = 9;
static const int SW_SHOWDEFAULT = 10;
static const int SW_FORCEMINIMIZE = 11;
static const int SW_MAX = 11;
/*
 * Old ShowWindow() Commands
 */
# 325 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HIDE_WINDOW = 0;
static const int SHOW_OPENWINDOW = 1;
static const int SHOW_ICONWINDOW = 2;
static const int SHOW_FULLSCREEN = 3;
static const int SHOW_OPENNOACTIVATE = 4;
/*
 * Identifiers for the WM_SHOWWINDOW message
 */
# 334 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SW_PARENTCLOSING = 1;
static const int SW_OTHERZOOM = 2;
static const int SW_PARENTOPENING = 3;
static const int SW_OTHERUNZOOM = 4;
/*
 * AnimateWindow() Commands
 */
# 346 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int AW_HOR_POSITIVE = 0x00000001;
static const int AW_HOR_NEGATIVE = 0x00000002;
static const int AW_VER_POSITIVE = 0x00000004;
static const int AW_VER_NEGATIVE = 0x00000008;
static const int AW_CENTER = 0x00000010;
static const int AW_HIDE = 0x00010000;
static const int AW_ACTIVATE = 0x00020000;
static const int AW_SLIDE = 0x00040000;
static const int AW_BLEND = 0x00080000;
/*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags
 */
# 362 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int KF_EXTENDED = 0x0100;
static const int KF_DLGMODE = 0x0800;
static const int KF_MENUMODE = 0x1000;
static const int KF_ALTDOWN = 0x2000;
static const int KF_REPEAT = 0x4000;
static const int KF_UP = 0x8000;
/*
 * Virtual Keys, Standard Set
 */
# 375 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_LBUTTON = 0x01;
static const int VK_RBUTTON = 0x02;
static const int VK_CANCEL = 0x03;
static const int VK_MBUTTON = 0x04;
static const int VK_XBUTTON1 = 0x05;
static const int VK_XBUTTON2 = 0x06;
/*
 * 0x07 : unassigned
 */
# 389 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_BACK = 0x08;
static const int VK_TAB = 0x09;
/*
 * 0x0A - 0x0B : reserved
 */
# 396 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_CLEAR = 0x0C;
static const int VK_RETURN = 0x0D;
static const int VK_SHIFT = 0x10;
static const int VK_CONTROL = 0x11;
static const int VK_MENU = 0x12;
static const int VK_PAUSE = 0x13;
static const int VK_CAPITAL = 0x14;
static const int VK_KANA = 0x15;
static const int VK_HANGEUL = 0x15;
static const int VK_HANGUL = 0x15;
static const int VK_JUNJA = 0x17;
static const int VK_FINAL = 0x18;
static const int VK_HANJA = 0x19;
static const int VK_KANJI = 0x19;
static const int VK_ESCAPE = 0x1B;
static const int VK_CONVERT = 0x1C;
static const int VK_NONCONVERT = 0x1D;
static const int VK_ACCEPT = 0x1E;
static const double VK_MODECHANGE = 0x1F;
static const int VK_SPACE = 0x20;
static const int VK_PRIOR = 0x21;
static const int VK_NEXT = 0x22;
static const int VK_END = 0x23;
static const int VK_HOME = 0x24;
static const int VK_LEFT = 0x25;
static const int VK_UP = 0x26;
static const int VK_RIGHT = 0x27;
static const int VK_DOWN = 0x28;
static const int VK_SELECT = 0x29;
static const int VK_PRINT = 0x2A;
static const int VK_EXECUTE = 0x2B;
static const int VK_SNAPSHOT = 0x2C;
static const int VK_INSERT = 0x2D;
static const int VK_DELETE = 0x2E;
static const double VK_HELP = 0x2F;
/*
 * VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x40 : unassigned
 * VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */
# 443 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_LWIN = 0x5B;
static const int VK_RWIN = 0x5C;
static const int VK_APPS = 0x5D;
/*
 * 0x5E : reserved
 */
# 451 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const double VK_SLEEP = 0x5F;
static const int VK_NUMPAD0 = 0x60;
static const int VK_NUMPAD1 = 0x61;
static const int VK_NUMPAD2 = 0x62;
static const int VK_NUMPAD3 = 0x63;
static const int VK_NUMPAD4 = 0x64;
static const int VK_NUMPAD5 = 0x65;
static const int VK_NUMPAD6 = 0x66;
static const int VK_NUMPAD7 = 0x67;
static const int VK_NUMPAD8 = 0x68;
static const int VK_NUMPAD9 = 0x69;
static const int VK_MULTIPLY = 0x6A;
static const int VK_ADD = 0x6B;
static const int VK_SEPARATOR = 0x6C;
static const int VK_SUBTRACT = 0x6D;
static const int VK_DECIMAL = 0x6E;
static const double VK_DIVIDE = 0x6F;
static const int VK_F1 = 0x70;
static const int VK_F2 = 0x71;
static const int VK_F3 = 0x72;
static const int VK_F4 = 0x73;
static const int VK_F5 = 0x74;
static const int VK_F6 = 0x75;
static const int VK_F7 = 0x76;
static const int VK_F8 = 0x77;
static const int VK_F9 = 0x78;
static const int VK_F10 = 0x79;
static const int VK_F11 = 0x7A;
static const int VK_F12 = 0x7B;
static const int VK_F13 = 0x7C;
static const int VK_F14 = 0x7D;
static const int VK_F15 = 0x7E;
static const double VK_F16 = 0x7F;
static const int VK_F17 = 0x80;
static const int VK_F18 = 0x81;
static const int VK_F19 = 0x82;
static const int VK_F20 = 0x83;
static const int VK_F21 = 0x84;
static const int VK_F22 = 0x85;
static const int VK_F23 = 0x86;
static const int VK_F24 = 0x87;
/*
 * 0x88 - 0x8F : unassigned
 */
# 498 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_NUMLOCK = 0x90;
static const int VK_SCROLL = 0x91;
/*
 * NEC PC-9800 kbd definitions
 */
# 504 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_OEM_NEC_EQUAL = 0x92;
/*
 * Fujitsu/OASYS kbd definitions
 */
# 509 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_OEM_FJ_JISHO = 0x92;
static const int VK_OEM_FJ_MASSHOU = 0x93;
static const int VK_OEM_FJ_TOUROKU = 0x94;
static const int VK_OEM_FJ_LOYA = 0x95;
static const int VK_OEM_FJ_ROYA = 0x96;
/*
 * 0x97 - 0x9F : unassigned
 */
# 519 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
# 524 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_LSHIFT = 0xA0;
static const int VK_RSHIFT = 0xA1;
static const int VK_LCONTROL = 0xA2;
static const int VK_RCONTROL = 0xA3;
static const int VK_LMENU = 0xA4;
static const int VK_RMENU = 0xA5;
static const int VK_BROWSER_BACK = 0xA6;
static const int VK_BROWSER_FORWARD = 0xA7;
static const int VK_BROWSER_REFRESH = 0xA8;
static const int VK_BROWSER_STOP = 0xA9;
static const int VK_BROWSER_SEARCH = 0xAA;
static const int VK_BROWSER_FAVORITES = 0xAB;
static const int VK_BROWSER_HOME = 0xAC;
static const int VK_VOLUME_MUTE = 0xAD;
static const int VK_VOLUME_DOWN = 0xAE;
static const int VK_VOLUME_UP = 0xAF;
static const int VK_MEDIA_NEXT_TRACK = 0xB0;
static const int VK_MEDIA_PREV_TRACK = 0xB1;
static const int VK_MEDIA_STOP = 0xB2;
static const int VK_MEDIA_PLAY_PAUSE = 0xB3;
static const int VK_LAUNCH_MAIL = 0xB4;
static const int VK_LAUNCH_MEDIA_SELECT = 0xB5;
static const int VK_LAUNCH_APP1 = 0xB6;
static const int VK_LAUNCH_APP2 = 0xB7;
/*
 * 0xB8 - 0xB9 : reserved
 */
# 558 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_OEM_1 = 0xBA;
static const int VK_OEM_PLUS = 0xBB;
static const int VK_OEM_COMMA = 0xBC;
static const int VK_OEM_MINUS = 0xBD;
static const int VK_OEM_PERIOD = 0xBE;
static const int VK_OEM_2 = 0xBF;
static const int VK_OEM_3 = 0xC0;
/*
 * 0xC1 - 0xD7 : reserved
 */
# 570 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * 0xD8 - 0xDA : unassigned
 */
# 574 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_OEM_4 = 0xDB;
static const int VK_OEM_5 = 0xDC;
static const int VK_OEM_6 = 0xDD;
static const int VK_OEM_7 = 0xDE;
static const int VK_OEM_8 = 0xDF;
/*
 * 0xE0 : reserved
 */
# 584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Various extended or enhanced keyboards
 */
# 587 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_OEM_AX = 0xE1;
static const int VK_OEM_102 = 0xE2;
static const int VK_ICO_HELP = 0xE3;
static const int VK_ICO_00 = 0xE4;
static const int VK_PROCESSKEY = 0xE5;
static const int VK_ICO_CLEAR = 0xE6;
static const int VK_PACKET = 0xE7;
/*
 * 0xE8 : unassigned
 */
# 607 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Nokia/Ericsson definitions
 */
# 610 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int VK_OEM_RESET = 0xE9;
static const int VK_OEM_JUMP = 0xEA;
static const int VK_OEM_PA1 = 0xEB;
static const int VK_OEM_PA2 = 0xEC;
static const int VK_OEM_PA3 = 0xED;
static const int VK_OEM_WSCTRL = 0xEE;
static const int VK_OEM_CUSEL = 0xEF;
static const int VK_OEM_ATTN = 0xF0;
static const int VK_OEM_FINISH = 0xF1;
static const int VK_OEM_COPY = 0xF2;
static const int VK_OEM_AUTO = 0xF3;
static const int VK_OEM_ENLW = 0xF4;
static const int VK_OEM_BACKTAB = 0xF5;
static const int VK_ATTN = 0xF6;
static const int VK_CRSEL = 0xF7;
static const int VK_EXSEL = 0xF8;
static const int VK_EREOF = 0xF9;
static const int VK_PLAY = 0xFA;
static const int VK_ZOOM = 0xFB;
static const int VK_NONAME = 0xFC;
static const int VK_PA1 = 0xFD;
static const int VK_OEM_CLEAR = 0xFE;
/*
 * 0xFF : reserved
 */
/*
 * SetWindowsHook() codes
 */
# 646 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WH_MIN = (-1);
static const int WH_MSGFILTER = (-1);
static const int WH_JOURNALRECORD = 0;
static const int WH_JOURNALPLAYBACK = 1;
static const int WH_KEYBOARD = 2;
static const int WH_GETMESSAGE = 3;
static const int WH_CALLWNDPROC = 4;
static const int WH_CBT = 5;
static const int WH_SYSMSGFILTER = 6;
static const int WH_MOUSE = 7;
static const int WH_DEBUG = 9;
static const int WH_SHELL = 10;
static const int WH_FOREGROUNDIDLE = 11;
static const int WH_CALLWNDPROCRET = 12;
static const int WH_KEYBOARD_LL = 13;
static const int WH_MOUSE_LL = 14;
static const int WH_MAX = 14;
static const int WH_MINHOOK = WH_MIN;
static const int WH_MAXHOOK = WH_MAX;
/*
 * Hook Codes
 */
# 687 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HC_ACTION = 0;
static const int HC_GETNEXT = 1;
static const int HC_SKIP = 2;
static const int HC_NOREMOVE = 3;
static const int HC_NOREM = HC_NOREMOVE;
static const int HC_SYSMODALON = 4;
static const int HC_SYSMODALOFF = 5;
/*
 * CBT Hook Codes
 */
# 698 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HCBT_MOVESIZE = 0;
static const int HCBT_MINMAX = 1;
static const int HCBT_QS = 2;
static const int HCBT_CREATEWND = 3;
static const int HCBT_DESTROYWND = 4;
static const int HCBT_ACTIVATE = 5;
static const int HCBT_CLICKSKIPPED = 6;
static const int HCBT_KEYSKIPPED = 7;
static const int HCBT_SYSCOMMAND = 8;
static const int HCBT_SETFOCUS = 9;
/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
# 712 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
# 720 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;
typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
/*
 * HCBT_ACTIVATE structure pointed to by lParam
 */
# 736 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL fMouse;
    HWND hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;
/*
 * WTSSESSION_NOTIFICATION struct pointed by lParam, for WM_WTSSESSION_CHANGE
 */
# 746 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagWTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;
} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;
/*
 * codes passed in WPARAM for WM_WTSSESSION_CHANGE
 */
# 757 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WTS_CONSOLE_CONNECT = 0x1;
static const int WTS_CONSOLE_DISCONNECT = 0x2;
static const int WTS_REMOTE_CONNECT = 0x3;
static const int WTS_REMOTE_DISCONNECT = 0x4;
static const int WTS_SESSION_LOGON = 0x5;
static const int WTS_SESSION_LOGOFF = 0x6;
static const int WTS_SESSION_LOCK = 0x7;
static const int WTS_SESSION_UNLOCK = 0x8;
static const int WTS_SESSION_REMOTE_CONTROL = 0x9;
/*
 * WH_MSGFILTER Filter Proc Codes
 */
# 772 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MSGF_DIALOGBOX = 0;
static const int MSGF_MESSAGEBOX = 1;
static const int MSGF_MENU = 2;
static const int MSGF_SCROLLBAR = 5;
static const int MSGF_NEXTWINDOW = 6;
static const int MSGF_MAX = 8;
static const int MSGF_USER = 4096;
/*
 * Shell support
 */
# 783 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HSHELL_WINDOWCREATED = 1;
static const int HSHELL_WINDOWDESTROYED = 2;
static const int HSHELL_ACTIVATESHELLWINDOW = 3;
static const int HSHELL_WINDOWACTIVATED = 4;
static const int HSHELL_GETMINRECT = 5;
static const int HSHELL_REDRAW = 6;
static const int HSHELL_TASKMAN = 7;
static const int HSHELL_LANGUAGE = 8;
static const int HSHELL_SYSMENU = 9;
static const int HSHELL_ENDTASK = 10;
static const int HSHELL_ACCESSIBILITYSTATE = 11;
static const int HSHELL_APPCOMMAND = 12;
static const int HSHELL_WINDOWREPLACED = 13;
static const int HSHELL_WINDOWREPLACING = 14;
static const int HSHELL_HIGHBIT = 0x8000;
static const int HSHELL_FLASH = (HSHELL_REDRAW|HSHELL_HIGHBIT);
static const int HSHELL_RUDEAPPACTIVATED = (HSHELL_WINDOWACTIVATED|HSHELL_HIGHBIT);
/* cmd for HSHELL_APPCOMMAND and WM_APPCOMMAND */
static const int APPCOMMAND_BROWSER_BACKWARD = 1;
static const int APPCOMMAND_BROWSER_FORWARD = 2;
static const int APPCOMMAND_BROWSER_REFRESH = 3;
static const int APPCOMMAND_BROWSER_STOP = 4;
static const int APPCOMMAND_BROWSER_SEARCH = 5;
static const int APPCOMMAND_BROWSER_FAVORITES = 6;
static const int APPCOMMAND_BROWSER_HOME = 7;
static const int APPCOMMAND_VOLUME_MUTE = 8;
static const int APPCOMMAND_VOLUME_DOWN = 9;
static const int APPCOMMAND_VOLUME_UP = 10;
static const int APPCOMMAND_MEDIA_NEXTTRACK = 11;
static const int APPCOMMAND_MEDIA_PREVIOUSTRACK = 12;
static const int APPCOMMAND_MEDIA_STOP = 13;
static const int APPCOMMAND_MEDIA_PLAY_PAUSE = 14;
static const int APPCOMMAND_LAUNCH_MAIL = 15;
static const int APPCOMMAND_LAUNCH_MEDIA_SELECT = 16;
static const int APPCOMMAND_LAUNCH_APP1 = 17;
static const int APPCOMMAND_LAUNCH_APP2 = 18;
static const int APPCOMMAND_BASS_DOWN = 19;
static const int APPCOMMAND_BASS_BOOST = 20;
static const int APPCOMMAND_BASS_UP = 21;
static const int APPCOMMAND_TREBLE_DOWN = 22;
static const int APPCOMMAND_TREBLE_UP = 23;
static const int APPCOMMAND_MICROPHONE_VOLUME_MUTE = 24;
static const int APPCOMMAND_MICROPHONE_VOLUME_DOWN = 25;
static const int APPCOMMAND_MICROPHONE_VOLUME_UP = 26;
static const int APPCOMMAND_HELP = 27;
static const int APPCOMMAND_FIND = 28;
static const int APPCOMMAND_NEW = 29;
static const int APPCOMMAND_OPEN = 30;
static const int APPCOMMAND_CLOSE = 31;
static const int APPCOMMAND_SAVE = 32;
static const int APPCOMMAND_PRINT = 33;
static const int APPCOMMAND_UNDO = 34;
static const int APPCOMMAND_REDO = 35;
static const int APPCOMMAND_COPY = 36;
static const int APPCOMMAND_CUT = 37;
static const int APPCOMMAND_PASTE = 38;
static const int APPCOMMAND_REPLY_TO_MAIL = 39;
static const int APPCOMMAND_FORWARD_MAIL = 40;
static const int APPCOMMAND_SEND_MAIL = 41;
static const int APPCOMMAND_SPELL_CHECK = 42;
static const int APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE = 43;
static const int APPCOMMAND_MIC_ON_OFF_TOGGLE = 44;
static const int APPCOMMAND_CORRECTION_LIST = 45;
static const int APPCOMMAND_MEDIA_PLAY = 46;
static const int APPCOMMAND_MEDIA_PAUSE = 47;
static const int APPCOMMAND_MEDIA_RECORD = 48;
static const int APPCOMMAND_MEDIA_FAST_FORWARD = 49;
static const int APPCOMMAND_MEDIA_REWIND = 50;
static const int APPCOMMAND_MEDIA_CHANNEL_UP = 51;
static const int APPCOMMAND_MEDIA_CHANNEL_DOWN = 52;
static const int APPCOMMAND_DELETE = 53;
static const int APPCOMMAND_DWM_FLIP3D = 54;
static const int FAPPCOMMAND_MOUSE = 0x8000;
static const int FAPPCOMMAND_KEY = 0;
static const int FAPPCOMMAND_OEM = 0x1000;
static const int FAPPCOMMAND_MASK = 0xF000;
static const int GET_APPCOMMAND_LPARAM(lParam) = ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK));
static const int GET_DEVICE_LPARAM(lParam) = ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK));
static const int GET_MOUSEORKEY_LPARAM = GET_DEVICE_LPARAM;
static const int GET_FLAGS_LPARAM(lParam) = (LOWORD(lParam));
static const int GET_KEYSTATE_LPARAM(lParam) = GET_FLAGS_LPARAM(lParam);
typedef struct
{
    HWND hwnd;
    RECT rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;
/*
 * Message Structure used in Journaling
 */
# 893 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagEVENTMSG {
    UINT message;
    UINT paramL;
    UINT paramH;
    DWORD time;
    HWND hwnd;
} EVENTMSG, *PEVENTMSGMSG, *NPEVENTMSGMSG, *LPEVENTMSGMSG;
typedef struct tagEVENTMSG *PEVENTMSG, *NPEVENTMSG, *LPEVENTMSG;
/*
 * Message structure used by WH_CALLWNDPROC
 */
# 906 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCWPSTRUCT {
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPSTRUCT, *PCWPSTRUCT, *NPCWPSTRUCT, *LPCWPSTRUCT;
/*
 * Message structure used by WH_CALLWNDPROCRET
 */
# 917 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT, *NPCWPRETSTRUCT, *LPCWPRETSTRUCT;
/*
 * Low level hook flags
 */
# 933 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int LLKHF_EXTENDED = (KF_EXTENDED >> 8);
static const int LLKHF_INJECTED = 0x00000010;
static const int LLKHF_ALTDOWN = (KF_ALTDOWN >> 8);
static const int LLKHF_UP = (KF_UP >> 8);
static const int LLMHF_INJECTED = 0x00000001;
/*
 * Structure used by WH_KEYBOARD_LL
 */
# 943 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD vkCode;
    DWORD scanCode;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;
/*
 * Structure used by WH_MOUSE_LL
 */
# 954 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMSLLHOOKSTRUCT {
    POINT pt;
    DWORD mouseData;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;
/*
 * Structure used by WH_DEBUG
 */
# 967 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagDEBUGHOOKINFO
{
    DWORD idThread;
    DWORD idThreadInstaller;
    LPARAM lParam;
    WPARAM wParam;
    int code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, *NPDEBUGHOOKINFO, * LPDEBUGHOOKINFO;
/*
 * Structure used by WH_MOUSE
 */
# 979 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMOUSEHOOKSTRUCT {
    POINT pt;
    HWND hwnd;
    UINT wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT, *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;
# 993 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMOUSEHOOKSTRUCTEX
{
    MOUSEHOOKSTRUCT;
    DWORD mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;
/*
 * Structure used by WH_HARDWARE
 */
# 1005 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
} HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
/*
 * Keyboard Layout API
 */
# 1017 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HKL_PREV = 0;
static const int HKL_NEXT = 1;
static const int KLF_ACTIVATE = 0x00000001;
static const int KLF_SUBSTITUTE_OK = 0x00000002;
static const int KLF_REORDER = 0x00000008;
static const int KLF_REPLACELANG = 0x00000010;
static const int KLF_NOTELLSHELL = 0x00000080;
static const int KLF_SETFORPROCESS = 0x00000100;
static const int KLF_SHIFTLOCK = 0x00010000;
static const int KLF_RESET = 0x40000000;
/*
 * Bits in wParam of WM_INPUTLANGCHANGEREQUEST message
 */
# 1039 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int INPUTLANGCHANGE_SYSCHARSET = 0x0001;
static const int INPUTLANGCHANGE_FORWARD = 0x0002;
static const int INPUTLANGCHANGE_BACKWARD = 0x0004;
/*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 */
# 1047 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int KL_NAMELENGTH = 9;
HKL
LoadKeyboardLayoutA(
    LPCSTR pwszKLID,
    UINT Flags);
HKL
LoadKeyboardLayoutW(
    LPCWSTR pwszKLID,
    UINT Flags);
static const int LoadKeyboardLayout = LoadKeyboardLayoutA;
HKL
ActivateKeyboardLayout(
    HKL hkl,
    UINT Flags);
# 1085 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
int
ToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    const BYTE *lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags,
    HKL dwhkl);
BOOL
UnloadKeyboardLayout(
    HKL hkl);
BOOL
GetKeyboardLayoutNameA(
    LPSTR pwszKLID);
BOOL
GetKeyboardLayoutNameW(
    LPWSTR pwszKLID);
static const int GetKeyboardLayoutName = GetKeyboardLayoutNameA;
int
GetKeyboardLayoutList(
    int nBuff,
    HKL *lpList);
HKL
GetKeyboardLayout(
    DWORD idThread);
typedef struct tagMOUSEMOVEPOINT {
    int x;
    int y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, * LPMOUSEMOVEPOINT;
/*
 * Values for resolution parameter of GetMouseMovePointsEx
 */
# 1149 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GMMP_USE_DISPLAY_POINTS = 1;
static const int GMMP_USE_HIGH_RESOLUTION_POINTS = 2;
int
GetMouseMovePointsEx(
    UINT cbSize,
    LPMOUSEMOVEPOINT lppt,
    LPMOUSEMOVEPOINT lpptBuf,
    int nBufPoints,
    DWORD resolution);
/*
 * Desktop-specific access flags
 */
# 1168 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long DESKTOP_READOBJECTS = 0x0001L;
static const long DESKTOP_CREATEWINDOW = 0x0002L;
static const long DESKTOP_CREATEMENU = 0x0004L;
static const long DESKTOP_HOOKCONTROL = 0x0008L;
static const long DESKTOP_JOURNALRECORD = 0x0010L;
static const long DESKTOP_JOURNALPLAYBACK = 0x0020L;
static const long DESKTOP_ENUMERATE = 0x0040L;
static const long DESKTOP_WRITEOBJECTS = 0x0080L;
static const long DESKTOP_SWITCHDESKTOP = 0x0100L;
/*
 * Desktop-specific control flags
 */
# 1181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long DF_ALLOWOTHERACCOUNTHOOK = 0x0001L;
HDESK
CreateDesktopA(
    LPCSTR lpszDesktop,
    LPCSTR lpszDevice,
    DEVMODEA* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
HDESK
CreateDesktopW(
    LPCWSTR lpszDesktop,
    LPCWSTR lpszDevice,
    DEVMODEW* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
static const int CreateDesktop = CreateDesktopA;
HDESK
CreateDesktopExA(
    LPCSTR lpszDesktop,
    LPCSTR lpszDevice,
    DEVMODEA* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa,
    ULONG ulHeapSize,
    PVOID pvoid);
HDESK
CreateDesktopExW(
    LPCWSTR lpszDesktop,
    LPCWSTR lpszDevice,
    DEVMODEW* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa,
    ULONG ulHeapSize,
    PVOID pvoid);
static const int CreateDesktopEx = CreateDesktopExA;
HDESK
OpenDesktopA(
    LPCSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);
HDESK
OpenDesktopW(
    LPCWSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);
static const int OpenDesktop = OpenDesktopA;
HDESK
OpenInputDesktop(
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);
BOOL
EnumDesktopsA(
    HWINSTA hwinsta,
    DESKTOPENUMPROCA lpEnumFunc,
    LPARAM lParam);
BOOL
EnumDesktopsW(
    HWINSTA hwinsta,
    DESKTOPENUMPROCW lpEnumFunc,
    LPARAM lParam);
static const int EnumDesktops = EnumDesktopsA;
BOOL
EnumDesktopWindows(
    HDESK hDesktop,
    WNDENUMPROC lpfn,
    LPARAM lParam);
BOOL
SwitchDesktop(
    HDESK hDesktop);
BOOL
SetThreadDesktop(
     HDESK hDesktop);
BOOL
CloseDesktop(
    HDESK hDesktop);
HDESK
GetThreadDesktop(
    DWORD dwThreadId);
/*
 * Windowstation-specific access flags
 */
# 1335 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long WINSTA_ENUMDESKTOPS = 0x0001L;
static const long WINSTA_READATTRIBUTES = 0x0002L;
static const long WINSTA_ACCESSCLIPBOARD = 0x0004L;
static const long WINSTA_CREATEDESKTOP = 0x0008L;
static const long WINSTA_WRITEATTRIBUTES = 0x0010L;
static const long WINSTA_ACCESSGLOBALATOMS = 0x0020L;
static const long WINSTA_EXITWINDOWS = 0x0040L;
static const long WINSTA_ENUMERATE = 0x0100L;
static const long WINSTA_READSCREEN = 0x0200L;
static const int WINSTA_ALL_ACCESS = (WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES | WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | WINSTA_ENUMERATE | WINSTA_READSCREEN);
/*
 * Windowstation creation flags.
 */
# 1352 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CWF_CREATE_ONLY = 0x00000001;
/*
 * Windowstation-specific attribute flags
 */
# 1357 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long WSF_VISIBLE = 0x0001L;
HWINSTA
CreateWindowStationA(
    LPCSTR lpwinsta,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
HWINSTA
CreateWindowStationW(
    LPCWSTR lpwinsta,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);
static const int CreateWindowStation = CreateWindowStationA;
HWINSTA
OpenWindowStationA(
    LPCSTR lpszWinSta,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);
HWINSTA
OpenWindowStationW(
    LPCWSTR lpszWinSta,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);
static const int OpenWindowStation = OpenWindowStationA;
BOOL
EnumWindowStationsA(
    WINSTAENUMPROCA lpEnumFunc,
    LPARAM lParam);
BOOL
EnumWindowStationsW(
    WINSTAENUMPROCW lpEnumFunc,
    LPARAM lParam);
static const int EnumWindowStations = EnumWindowStationsA;
BOOL
CloseWindowStation(
    HWINSTA hWinSta);
BOOL
SetProcessWindowStation(
    HWINSTA hWinSta);
HWINSTA
GetProcessWindowStation(
    void);
BOOL
SetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID);
BOOL
GetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);
static const int UOI_FLAGS = 1;
static const int UOI_NAME = 2;
static const int UOI_TYPE = 3;
static const int UOI_USER_SID = 4;
static const int UOI_HEAPSIZE = 5;
static const int UOI_IO = 6;
typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;
BOOL
GetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);
BOOL
GetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);
static const int GetUserObjectInformation = GetUserObjectInformationA;
BOOL
SetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);
BOOL
SetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);
static const int SetUserObjectInformation = SetUserObjectInformationA;
typedef struct tagWNDCLASSEXA {
    UINT cbSize;
    /* Win 3.x */
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;
    /* Win 4.0 */
    HICON hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA, *NPWNDCLASSEXA, *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT cbSize;
    /* Win 3.x */
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
    /* Win 4.0 */
    HICON hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, *NPWNDCLASSEXW, *LPWNDCLASSEXW;
typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
typedef struct tagWNDCLASSA {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;
} WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
} WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;
typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
BOOL
IsHungAppWindow(
    HWND hwnd);
void
DisableProcessWindowsGhosting(
    void);
/*
 * Message structure
 */
# 1624 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMSG {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
} MSG, *PMSG, *NPMSG, *LPMSG;
static const int POINTSTOPOINT(pt,pts) = { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts); (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); };
static const int POINTTOPOINTS(pt) = (MAKELONG((short)((pt).x), (short)((pt).y)));
static const int MAKEWPARAM(l,h) = ((WPARAM)(DWORD)MAKELONG(l, h));
static const int MAKELPARAM(l,h) = ((LPARAM)(DWORD)MAKELONG(l, h));
static const int MAKELRESULT(l,h) = ((LRESULT)(DWORD)MAKELONG(l, h));
/*
 * Window field offsets for GetWindowLong()
 */
# 1653 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GWL_WNDPROC = (-4);
static const int GWL_HINSTANCE = (-6);
static const int GWL_HWNDPARENT = (-8);
static const int GWL_STYLE = (-16);
static const int GWL_EXSTYLE = (-20);
static const int GWL_USERDATA = (-21);
static const int GWL_ID = (-12);
static const int GWLP_WNDPROC = (-4);
static const int GWLP_HINSTANCE = (-6);
static const int GWLP_HWNDPARENT = (-8);
static const int GWLP_USERDATA = (-21);
static const int GWLP_ID = (-12);
/*
 * Class field offsets for GetClassLong()
 */
# 1679 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GCL_MENUNAME = (-8);
static const int GCL_HBRBACKGROUND = (-10);
static const int GCL_HCURSOR = (-12);
static const int GCL_HICON = (-14);
static const int GCL_HMODULE = (-16);
static const int GCL_CBWNDEXTRA = (-18);
static const int GCL_CBCLSEXTRA = (-20);
static const int GCL_WNDPROC = (-24);
static const int GCL_STYLE = (-26);
static const int GCW_ATOM = (-32);
static const int GCL_HICONSM = (-34);
static const int GCLP_MENUNAME = (-8);
static const int GCLP_HBRBACKGROUND = (-10);
static const int GCLP_HCURSOR = (-12);
static const int GCLP_HICON = (-14);
static const int GCLP_HMODULE = (-16);
static const int GCLP_WNDPROC = (-24);
static const int GCLP_HICONSM = (-34);
/*
 * Window Messages
 */
# 1723 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WM_NULL = 0x0000;
static const int WM_CREATE = 0x0001;
static const int WM_DESTROY = 0x0002;
static const int WM_MOVE = 0x0003;
static const int WM_SIZE = 0x0005;
static const int WM_ACTIVATE = 0x0006;
/*
 * WM_ACTIVATE state values
 */
# 1733 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WA_INACTIVE = 0;
static const int WA_ACTIVE = 1;
static const int WA_CLICKACTIVE = 2;
static const int WM_SETFOCUS = 0x0007;
static const int WM_KILLFOCUS = 0x0008;
static const int WM_ENABLE = 0x000A;
static const int WM_SETREDRAW = 0x000B;
static const int WM_SETTEXT = 0x000C;
static const int WM_GETTEXT = 0x000D;
static const int WM_GETTEXTLENGTH = 0x000E;
static const double WM_PAINT = 0x000F;
static const int WM_CLOSE = 0x0010;
static const int WM_QUERYENDSESSION = 0x0011;
static const int WM_QUERYOPEN = 0x0013;
static const int WM_ENDSESSION = 0x0016;
static const int WM_QUIT = 0x0012;
static const int WM_ERASEBKGND = 0x0014;
static const int WM_SYSCOLORCHANGE = 0x0015;
static const int WM_SHOWWINDOW = 0x0018;
static const int WM_WININICHANGE = 0x001A;
static const int WM_SETTINGCHANGE = WM_WININICHANGE;
static const int WM_DEVMODECHANGE = 0x001B;
static const int WM_ACTIVATEAPP = 0x001C;
static const int WM_FONTCHANGE = 0x001D;
static const int WM_TIMECHANGE = 0x001E;
static const double WM_CANCELMODE = 0x001F;
static const int WM_SETCURSOR = 0x0020;
static const int WM_MOUSEACTIVATE = 0x0021;
static const int WM_CHILDACTIVATE = 0x0022;
static const int WM_QUEUESYNC = 0x0023;
static const int WM_GETMINMAXINFO = 0x0024;
/*
 * Struct pointed to by WM_GETMINMAXINFO lParam
 */
# 1775 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;
static const int WM_PAINTICON = 0x0026;
static const int WM_ICONERASEBKGND = 0x0027;
static const int WM_NEXTDLGCTL = 0x0028;
static const int WM_SPOOLERSTATUS = 0x002A;
static const int WM_DRAWITEM = 0x002B;
static const int WM_MEASUREITEM = 0x002C;
static const int WM_DELETEITEM = 0x002D;
static const int WM_VKEYTOITEM = 0x002E;
static const double WM_CHARTOITEM = 0x002F;
static const int WM_SETFONT = 0x0030;
static const int WM_GETFONT = 0x0031;
static const int WM_SETHOTKEY = 0x0032;
static const int WM_GETHOTKEY = 0x0033;
static const int WM_QUERYDRAGICON = 0x0037;
static const int WM_COMPAREITEM = 0x0039;
static const int WM_GETOBJECT = 0x003D;
static const int WM_COMPACTING = 0x0041;
static const int WM_COMMNOTIFY = 0x0044;
static const int WM_WINDOWPOSCHANGING = 0x0046;
static const int WM_WINDOWPOSCHANGED = 0x0047;
static const int WM_POWER = 0x0048;
/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */
# 1812 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int PWR_OK = 1;
static const int PWR_FAIL = (-1);
static const int PWR_SUSPENDREQUEST = 1;
static const int PWR_SUSPENDRESUME = 2;
static const int PWR_CRITICALRESUME = 3;
static const int WM_COPYDATA = 0x004A;
static const int WM_CANCELJOURNAL = 0x004B;
/*
 * lParam of WM_COPYDATA message points to...
 */
# 1825 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;
typedef struct tagMDINEXTMENU
{
    HMENU hmenuIn;
    HMENU hmenuNext;
    HWND hwndNext;
} MDINEXTMENU, * PMDINEXTMENU, * LPMDINEXTMENU;
static const int WM_NOTIFY = 0x004E;
static const int WM_INPUTLANGCHANGEREQUEST = 0x0050;
static const int WM_INPUTLANGCHANGE = 0x0051;
static const int WM_TCARD = 0x0052;
static const int WM_HELP = 0x0053;
static const int WM_USERCHANGED = 0x0054;
static const int WM_NOTIFYFORMAT = 0x0055;
static const int NFR_ANSI = 1;
static const int NFR_UNICODE = 2;
static const int NF_QUERY = 3;
static const int NF_REQUERY = 4;
static const int WM_CONTEXTMENU = 0x007B;
static const int WM_STYLECHANGING = 0x007C;
static const int WM_STYLECHANGED = 0x007D;
static const int WM_DISPLAYCHANGE = 0x007E;
static const double WM_GETICON = 0x007F;
static const int WM_SETICON = 0x0080;
static const int WM_NCCREATE = 0x0081;
static const int WM_NCDESTROY = 0x0082;
static const int WM_NCCALCSIZE = 0x0083;
static const int WM_NCHITTEST = 0x0084;
static const int WM_NCPAINT = 0x0085;
static const int WM_NCACTIVATE = 0x0086;
static const int WM_GETDLGCODE = 0x0087;
static const int WM_SYNCPAINT = 0x0088;
static const int WM_NCMOUSEMOVE = 0x00A0;
static const int WM_NCLBUTTONDOWN = 0x00A1;
static const int WM_NCLBUTTONUP = 0x00A2;
static const int WM_NCLBUTTONDBLCLK = 0x00A3;
static const int WM_NCRBUTTONDOWN = 0x00A4;
static const int WM_NCRBUTTONUP = 0x00A5;
static const int WM_NCRBUTTONDBLCLK = 0x00A6;
static const int WM_NCMBUTTONDOWN = 0x00A7;
static const int WM_NCMBUTTONUP = 0x00A8;
static const int WM_NCMBUTTONDBLCLK = 0x00A9;
static const int WM_NCXBUTTONDOWN = 0x00AB;
static const int WM_NCXBUTTONUP = 0x00AC;
static const int WM_NCXBUTTONDBLCLK = 0x00AD;
static const int WM_INPUT_DEVICE_CHANGE = 0x00FE;
static const int WM_INPUT = 0x00FF;
static const int WM_KEYFIRST = 0x0100;
static const int WM_KEYDOWN = 0x0100;
static const int WM_KEYUP = 0x0101;
static const int WM_CHAR = 0x0102;
static const int WM_DEADCHAR = 0x0103;
static const int WM_SYSKEYDOWN = 0x0104;
static const int WM_SYSKEYUP = 0x0105;
static const int WM_SYSCHAR = 0x0106;
static const int WM_SYSDEADCHAR = 0x0107;
static const int WM_UNICHAR = 0x0109;
static const int WM_KEYLAST = 0x0109;
static const int UNICODE_NOCHAR = 0xFFFF;
static const int WM_IME_STARTCOMPOSITION = 0x010D;
static const int WM_IME_ENDCOMPOSITION = 0x010E;
static const double WM_IME_COMPOSITION = 0x010F;
static const double WM_IME_KEYLAST = 0x010F;
static const int WM_INITDIALOG = 0x0110;
static const int WM_COMMAND = 0x0111;
static const int WM_SYSCOMMAND = 0x0112;
static const int WM_TIMER = 0x0113;
static const int WM_HSCROLL = 0x0114;
static const int WM_VSCROLL = 0x0115;
static const int WM_INITMENU = 0x0116;
static const int WM_INITMENUPOPUP = 0x0117;
static const int WM_GESTURE = 0x0119;
static const int WM_GESTURENOTIFY = 0x011A;
static const double WM_MENUSELECT = 0x011F;
static const int WM_MENUCHAR = 0x0120;
static const int WM_ENTERIDLE = 0x0121;
static const int WM_MENURBUTTONUP = 0x0122;
static const int WM_MENUDRAG = 0x0123;
static const int WM_MENUGETOBJECT = 0x0124;
static const int WM_UNINITMENUPOPUP = 0x0125;
static const int WM_MENUCOMMAND = 0x0126;
static const int WM_CHANGEUISTATE = 0x0127;
static const int WM_UPDATEUISTATE = 0x0128;
static const int WM_QUERYUISTATE = 0x0129;
/*
 * LOWORD(wParam) values in WM_*UISTATE*
 */
# 1957 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int UIS_SET = 1;
static const int UIS_CLEAR = 2;
static const int UIS_INITIALIZE = 3;
/*
 * HIWORD(wParam) values in WM_*UISTATE*
 */
# 1964 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int UISF_HIDEFOCUS = 0x1;
static const int UISF_HIDEACCEL = 0x2;
static const int UISF_ACTIVE = 0x4;
static const int WM_CTLCOLORMSGBOX = 0x0132;
static const int WM_CTLCOLOREDIT = 0x0133;
static const int WM_CTLCOLORLISTBOX = 0x0134;
static const int WM_CTLCOLORBTN = 0x0135;
static const int WM_CTLCOLORDLG = 0x0136;
static const int WM_CTLCOLORSCROLLBAR = 0x0137;
static const int WM_CTLCOLORSTATIC = 0x0138;
static const int MN_GETHMENU = 0x01E1;
static const int WM_MOUSEFIRST = 0x0200;
static const int WM_MOUSEMOVE = 0x0200;
static const int WM_LBUTTONDOWN = 0x0201;
static const int WM_LBUTTONUP = 0x0202;
static const int WM_LBUTTONDBLCLK = 0x0203;
static const int WM_RBUTTONDOWN = 0x0204;
static const int WM_RBUTTONUP = 0x0205;
static const int WM_RBUTTONDBLCLK = 0x0206;
static const int WM_MBUTTONDOWN = 0x0207;
static const int WM_MBUTTONUP = 0x0208;
static const int WM_MBUTTONDBLCLK = 0x0209;
static const int WM_MOUSEWHEEL = 0x020A;
static const int WM_XBUTTONDOWN = 0x020B;
static const int WM_XBUTTONUP = 0x020C;
static const int WM_XBUTTONDBLCLK = 0x020D;
static const int WM_MOUSEHWHEEL = 0x020E;
static const int WM_MOUSELAST = 0x020E;
# 2019 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/* Value for rolling one detent */
static const int WHEEL_DELTA = 120;
static const int GET_WHEEL_DELTA_WPARAM(wParam) = ((short)HIWORD(wParam));
/* Setting to scroll one page for SPI_GET/SETWHEELSCROLLLINES */
static const int WHEEL_PAGESCROLL = (UINT_MAX);
static const int GET_KEYSTATE_WPARAM(wParam) = (LOWORD(wParam));
static const int GET_NCHITTEST_WPARAM(wParam) = ((short)LOWORD(wParam));
static const int GET_XBUTTON_WPARAM(wParam) = (HIWORD(wParam));
/* XButton values are WORD flags */
static const int XBUTTON1 = 0x0001;
static const int XBUTTON2 = 0x0002;
/* Were there to be an XBUTTON3, its value would be 0x0004 */
static const int WM_PARENTNOTIFY = 0x0210;
static const int WM_ENTERMENULOOP = 0x0211;
static const int WM_EXITMENULOOP = 0x0212;
static const int WM_NEXTMENU = 0x0213;
static const int WM_SIZING = 0x0214;
static const int WM_CAPTURECHANGED = 0x0215;
static const int WM_MOVING = 0x0216;
static const int WM_POWERBROADCAST = 0x0218;
static const int PBT_APMQUERYSUSPEND = 0x0000;
static const int PBT_APMQUERYSTANDBY = 0x0001;
static const int PBT_APMQUERYSUSPENDFAILED = 0x0002;
static const int PBT_APMQUERYSTANDBYFAILED = 0x0003;
static const int PBT_APMSUSPEND = 0x0004;
static const int PBT_APMSTANDBY = 0x0005;
static const int PBT_APMRESUMECRITICAL = 0x0006;
static const int PBT_APMRESUMESUSPEND = 0x0007;
static const int PBT_APMRESUMESTANDBY = 0x0008;
static const int PBTF_APMRESUMEFROMFAILURE = 0x00000001;
static const int PBT_APMBATTERYLOW = 0x0009;
static const int PBT_APMPOWERSTATUSCHANGE = 0x000A;
static const int PBT_APMOEMEVENT = 0x000B;
static const int PBT_APMRESUMEAUTOMATIC = 0x0012;
static const int PBT_POWERSETTINGCHANGE = 0x8013;
typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;
# 2095 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WM_DEVICECHANGE = 0x0219;
static const int WM_MDICREATE = 0x0220;
static const int WM_MDIDESTROY = 0x0221;
static const int WM_MDIACTIVATE = 0x0222;
static const int WM_MDIRESTORE = 0x0223;
static const int WM_MDINEXT = 0x0224;
static const int WM_MDIMAXIMIZE = 0x0225;
static const int WM_MDITILE = 0x0226;
static const int WM_MDICASCADE = 0x0227;
static const int WM_MDIICONARRANGE = 0x0228;
static const int WM_MDIGETACTIVE = 0x0229;
static const int WM_MDISETMENU = 0x0230;
static const int WM_ENTERSIZEMOVE = 0x0231;
static const int WM_EXITSIZEMOVE = 0x0232;
static const int WM_DROPFILES = 0x0233;
static const int WM_MDIREFRESHMENU = 0x0234;
static const int WM_TOUCH = 0x0240;
static const int WM_IME_SETCONTEXT = 0x0281;
static const int WM_IME_NOTIFY = 0x0282;
static const int WM_IME_CONTROL = 0x0283;
static const int WM_IME_COMPOSITIONFULL = 0x0284;
static const int WM_IME_SELECT = 0x0285;
static const int WM_IME_CHAR = 0x0286;
static const int WM_IME_REQUEST = 0x0288;
static const int WM_IME_KEYDOWN = 0x0290;
static const int WM_IME_KEYUP = 0x0291;
static const int WM_MOUSEHOVER = 0x02A1;
static const int WM_MOUSELEAVE = 0x02A3;
static const int WM_NCMOUSEHOVER = 0x02A0;
static const int WM_NCMOUSELEAVE = 0x02A2;
static const int WM_WTSSESSION_CHANGE = 0x02B1;
static const int WM_TABLET_FIRST = 0x02c0;
static const int WM_TABLET_LAST = 0x02df;
static const int WM_CUT = 0x0300;
static const int WM_COPY = 0x0301;
static const int WM_PASTE = 0x0302;
static const int WM_CLEAR = 0x0303;
static const int WM_UNDO = 0x0304;
static const int WM_RENDERFORMAT = 0x0305;
static const int WM_RENDERALLFORMATS = 0x0306;
static const int WM_DESTROYCLIPBOARD = 0x0307;
static const int WM_DRAWCLIPBOARD = 0x0308;
static const int WM_PAINTCLIPBOARD = 0x0309;
static const int WM_VSCROLLCLIPBOARD = 0x030A;
static const int WM_SIZECLIPBOARD = 0x030B;
static const int WM_ASKCBFORMATNAME = 0x030C;
static const int WM_CHANGECBCHAIN = 0x030D;
static const int WM_HSCROLLCLIPBOARD = 0x030E;
static const double WM_QUERYNEWPALETTE = 0x030F;
static const int WM_PALETTEISCHANGING = 0x0310;
static const int WM_PALETTECHANGED = 0x0311;
static const int WM_HOTKEY = 0x0312;
static const int WM_PRINT = 0x0317;
static const int WM_PRINTCLIENT = 0x0318;
static const int WM_APPCOMMAND = 0x0319;
static const int WM_THEMECHANGED = 0x031A;
static const int WM_CLIPBOARDUPDATE = 0x031D;
static const int WM_DWMCOMPOSITIONCHANGED = 0x031E;
static const double WM_DWMNCRENDERINGCHANGED = 0x031F;
static const int WM_DWMCOLORIZATIONCOLORCHANGED = 0x0320;
static const int WM_DWMWINDOWMAXIMIZEDCHANGE = 0x0321;
static const int WM_DWMSENDICONICTHUMBNAIL = 0x0323;
static const int WM_DWMSENDICONICLIVEPREVIEWBITMAP = 0x0326;
static const double WM_GETTITLEBARINFOEX = 0x033F;
static const int WM_HANDHELDFIRST = 0x0358;
static const double WM_HANDHELDLAST = 0x035F;
static const int WM_AFXFIRST = 0x0360;
static const double WM_AFXLAST = 0x037F;
static const int WM_PENWINFIRST = 0x0380;
static const double WM_PENWINLAST = 0x038F;
static const int WM_APP = 0x8000;
/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */
# 2231 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WM_USER = 0x0400;
/*  wParam for WM_SIZING message  */
static const int WMSZ_LEFT = 1;
static const int WMSZ_RIGHT = 2;
static const int WMSZ_TOP = 3;
static const int WMSZ_TOPLEFT = 4;
static const int WMSZ_TOPRIGHT = 5;
static const int WMSZ_BOTTOM = 6;
static const int WMSZ_BOTTOMLEFT = 7;
static const int WMSZ_BOTTOMRIGHT = 8;
/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
# 2251 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HTERROR = (-2);
static const int HTTRANSPARENT = (-1);
static const int HTNOWHERE = 0;
static const int HTCLIENT = 1;
static const int HTCAPTION = 2;
static const int HTSYSMENU = 3;
static const int HTGROWBOX = 4;
static const int HTSIZE = HTGROWBOX;
static const int HTMENU = 5;
static const int HTHSCROLL = 6;
static const int HTVSCROLL = 7;
static const int HTMINBUTTON = 8;
static const int HTMAXBUTTON = 9;
static const int HTLEFT = 10;
static const int HTRIGHT = 11;
static const int HTTOP = 12;
static const int HTTOPLEFT = 13;
static const int HTTOPRIGHT = 14;
static const int HTBOTTOM = 15;
static const int HTBOTTOMLEFT = 16;
static const int HTBOTTOMRIGHT = 17;
static const int HTBORDER = 18;
static const int HTREDUCE = HTMINBUTTON;
static const int HTZOOM = HTMAXBUTTON;
static const int HTSIZEFIRST = HTLEFT;
static const int HTSIZELAST = HTBOTTOMRIGHT;
static const int HTOBJECT = 19;
static const int HTCLOSE = 20;
static const int HTHELP = 21;
/*
 * SendMessageTimeout values
 */
# 2287 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SMTO_NORMAL = 0x0000;
static const int SMTO_BLOCK = 0x0001;
static const int SMTO_ABORTIFHUNG = 0x0002;
static const int SMTO_NOTIMEOUTIFNOTHUNG = 0x0008;
static const int SMTO_ERRORONEXIT = 0x0020;
/*
 * WM_MOUSEACTIVATE Return Codes
 */
# 2302 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MA_ACTIVATE = 1;
static const int MA_ACTIVATEANDEAT = 2;
static const int MA_NOACTIVATE = 3;
static const int MA_NOACTIVATEANDEAT = 4;
/*
 * WM_SETICON / WM_GETICON Type Codes
 */
# 2310 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ICON_SMALL = 0;
static const int ICON_BIG = 1;
static const int ICON_SMALL2 = 2;
UINT
RegisterWindowMessageA(
    LPCSTR lpString);
UINT
RegisterWindowMessageW(
    LPCWSTR lpString);
static const int RegisterWindowMessage = RegisterWindowMessageA;
/*
 * WM_SIZE message wParam values
 */
# 2337 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SIZE_RESTORED = 0;
static const int SIZE_MINIMIZED = 1;
static const int SIZE_MAXIMIZED = 2;
static const int SIZE_MAXSHOW = 3;
static const int SIZE_MAXHIDE = 4;
/*
 * Obsolete constant names
 */
# 2346 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SIZENORMAL = SIZE_RESTORED;
static const int SIZEICONIC = SIZE_MINIMIZED;
static const int SIZEFULLSCREEN = SIZE_MAXIMIZED;
static const int SIZEZOOMSHOW = SIZE_MAXSHOW;
static const int SIZEZOOMHIDE = SIZE_MAXHIDE;
/*
 * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam
 */
# 2355 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagWINDOWPOS {
    HWND hwnd;
    HWND hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    UINT flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;
/*
 * WM_NCCALCSIZE parameter structure
 */
# 2368 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagNCCALCSIZE_PARAMS {
    RECT rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
/*
 * WM_NCCALCSIZE "window valid rect" return values
 */
# 2376 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WVR_ALIGNTOP = 0x0010;
static const int WVR_ALIGNLEFT = 0x0020;
static const int WVR_ALIGNBOTTOM = 0x0040;
static const int WVR_ALIGNRIGHT = 0x0080;
static const int WVR_HREDRAW = 0x0100;
static const int WVR_VREDRAW = 0x0200;
static const int WVR_REDRAW = (WVR_HREDRAW | WVR_VREDRAW);
static const int WVR_VALIDRECTS = 0x0400;
/*
 * Key State Masks for Mouse Messages
 */
# 2392 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MK_LBUTTON = 0x0001;
static const int MK_RBUTTON = 0x0002;
static const int MK_SHIFT = 0x0004;
static const int MK_CONTROL = 0x0008;
static const int MK_MBUTTON = 0x0010;
static const int MK_XBUTTON1 = 0x0020;
static const int MK_XBUTTON2 = 0x0040;
# 2408 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int TME_HOVER = 0x00000001;
static const int TME_LEAVE = 0x00000002;
static const int TME_NONCLIENT = 0x00000010;
static const int TME_QUERY = 0x40000000;
static const int TME_CANCEL = 0x80000000;
static const int HOVER_DEFAULT = 0xFFFFFFFF;
typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;
BOOL
TrackMouseEvent(
    LPTRACKMOUSEEVENT lpEventTrack);
# 2446 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Window Styles
 */
# 2449 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long WS_OVERLAPPED = 0x00000000L;
static const long WS_POPUP = 0x80000000L;
static const long WS_CHILD = 0x40000000L;
static const long WS_MINIMIZE = 0x20000000L;
static const long WS_VISIBLE = 0x10000000L;
static const long WS_DISABLED = 0x08000000L;
static const long WS_CLIPSIBLINGS = 0x04000000L;
static const long WS_CLIPCHILDREN = 0x02000000L;
static const long WS_MAXIMIZE = 0x01000000L;
static const long WS_CAPTION = 0x00C00000L;
static const long WS_BORDER = 0x00800000L;
static const long WS_DLGFRAME = 0x00400000L;
static const long WS_VSCROLL = 0x00200000L;
static const long WS_HSCROLL = 0x00100000L;
static const long WS_SYSMENU = 0x00080000L;
static const long WS_THICKFRAME = 0x00040000L;
static const long WS_GROUP = 0x00020000L;
static const long WS_TABSTOP = 0x00010000L;
static const long WS_MINIMIZEBOX = 0x00020000L;
static const long WS_MAXIMIZEBOX = 0x00010000L;
static const int WS_TILED = WS_OVERLAPPED;
static const int WS_ICONIC = WS_MINIMIZE;
static const int WS_SIZEBOX = WS_THICKFRAME;
static const int WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW;
/*
 * Common Window Styles
 */
# 2480 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WS_OVERLAPPEDWINDOW = (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
static const int WS_POPUPWINDOW = (WS_POPUP | WS_BORDER | WS_SYSMENU);
static const int WS_CHILDWINDOW = (WS_CHILD);
/*
 * Extended Window Styles
 */
# 2496 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long WS_EX_DLGMODALFRAME = 0x00000001L;
static const long WS_EX_NOPARENTNOTIFY = 0x00000004L;
static const long WS_EX_TOPMOST = 0x00000008L;
static const long WS_EX_ACCEPTFILES = 0x00000010L;
static const long WS_EX_TRANSPARENT = 0x00000020L;
static const long WS_EX_MDICHILD = 0x00000040L;
static const long WS_EX_TOOLWINDOW = 0x00000080L;
static const long WS_EX_WINDOWEDGE = 0x00000100L;
static const long WS_EX_CLIENTEDGE = 0x00000200L;
static const long WS_EX_CONTEXTHELP = 0x00000400L;
static const long WS_EX_RIGHT = 0x00001000L;
static const long WS_EX_LEFT = 0x00000000L;
static const long WS_EX_RTLREADING = 0x00002000L;
static const long WS_EX_LTRREADING = 0x00000000L;
static const long WS_EX_LEFTSCROLLBAR = 0x00004000L;
static const long WS_EX_RIGHTSCROLLBAR = 0x00000000L;
static const long WS_EX_CONTROLPARENT = 0x00010000L;
static const long WS_EX_STATICEDGE = 0x00020000L;
static const long WS_EX_APPWINDOW = 0x00040000L;
static const int WS_EX_OVERLAPPEDWINDOW = (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE);
static const int WS_EX_PALETTEWINDOW = (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST);
static const int WS_EX_LAYERED = 0x00080000;
static const long WS_EX_NOINHERITLAYOUT = 0x00100000L;
static const long WS_EX_LAYOUTRTL = 0x00400000L;
static const long WS_EX_COMPOSITED = 0x02000000L;
static const long WS_EX_NOACTIVATE = 0x08000000L;
/*
 * Class styles
 */
# 2550 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CS_VREDRAW = 0x0001;
static const int CS_HREDRAW = 0x0002;
static const int CS_DBLCLKS = 0x0008;
static const int CS_OWNDC = 0x0020;
static const int CS_CLASSDC = 0x0040;
static const int CS_PARENTDC = 0x0080;
static const int CS_NOCLOSE = 0x0200;
static const int CS_SAVEBITS = 0x0800;
static const int CS_BYTEALIGNCLIENT = 0x1000;
static const int CS_BYTEALIGNWINDOW = 0x2000;
static const int CS_GLOBALCLASS = 0x4000;
static const int CS_IME = 0x00010000;
static const int CS_DROPSHADOW = 0x00020000;
/* WM_PRINT flags */
static const long PRF_CHECKVISIBLE = 0x00000001L;
static const long PRF_NONCLIENT = 0x00000002L;
static const long PRF_CLIENT = 0x00000004L;
static const long PRF_ERASEBKGND = 0x00000008L;
static const long PRF_CHILDREN = 0x00000010L;
static const long PRF_OWNED = 0x00000020L;
/* 3D border styles */
static const int BDR_RAISEDOUTER = 0x0001;
static const int BDR_SUNKENOUTER = 0x0002;
static const int BDR_RAISEDINNER = 0x0004;
static const int BDR_SUNKENINNER = 0x0008;
static const int BDR_OUTER = (BDR_RAISEDOUTER | BDR_SUNKENOUTER);
static const int BDR_INNER = (BDR_RAISEDINNER | BDR_SUNKENINNER);
static const int BDR_RAISED = (BDR_RAISEDOUTER | BDR_RAISEDINNER);
static const int BDR_SUNKEN = (BDR_SUNKENOUTER | BDR_SUNKENINNER);
static const int EDGE_RAISED = (BDR_RAISEDOUTER | BDR_RAISEDINNER);
static const int EDGE_SUNKEN = (BDR_SUNKENOUTER | BDR_SUNKENINNER);
static const int EDGE_ETCHED = (BDR_SUNKENOUTER | BDR_RAISEDINNER);
static const int EDGE_BUMP = (BDR_RAISEDOUTER | BDR_SUNKENINNER);
/* Border flags */
static const int BF_LEFT = 0x0001;
static const int BF_TOP = 0x0002;
static const int BF_RIGHT = 0x0004;
static const int BF_BOTTOM = 0x0008;
static const int BF_TOPLEFT = (BF_TOP | BF_LEFT);
static const int BF_TOPRIGHT = (BF_TOP | BF_RIGHT);
static const int BF_BOTTOMLEFT = (BF_BOTTOM | BF_LEFT);
static const int BF_BOTTOMRIGHT = (BF_BOTTOM | BF_RIGHT);
static const int BF_RECT = (BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM);
static const int BF_DIAGONAL = 0x0010;
// For diagonal lines, the BF_RECT flags specify the end point of the
// vector bounded by the rectangle parameter.
static const int BF_DIAGONAL_ENDTOPRIGHT = (BF_DIAGONAL | BF_TOP | BF_RIGHT);
static const int BF_DIAGONAL_ENDTOPLEFT = (BF_DIAGONAL | BF_TOP | BF_LEFT);
static const int BF_DIAGONAL_ENDBOTTOMLEFT = (BF_DIAGONAL | BF_BOTTOM | BF_LEFT);
static const int BF_DIAGONAL_ENDBOTTOMRIGHT = (BF_DIAGONAL | BF_BOTTOM | BF_RIGHT);
static const int BF_MIDDLE = 0x0800;
static const int BF_SOFT = 0x1000;
static const int BF_ADJUST = 0x2000;
static const int BF_FLAT = 0x4000;
static const int BF_MONO = 0x8000;
BOOL
DrawEdge(
    HDC hdc,
    LPRECT qrc,
    UINT edge,
    UINT grfFlags);
/* flags for DrawFrameControl */
static const int DFC_CAPTION = 1;
static const int DFC_MENU = 2;
static const int DFC_SCROLL = 3;
static const int DFC_BUTTON = 4;
static const int DFC_POPUPMENU = 5;
static const int DFCS_CAPTIONCLOSE = 0x0000;
static const int DFCS_CAPTIONMIN = 0x0001;
static const int DFCS_CAPTIONMAX = 0x0002;
static const int DFCS_CAPTIONRESTORE = 0x0003;
static const int DFCS_CAPTIONHELP = 0x0004;
static const int DFCS_MENUARROW = 0x0000;
static const int DFCS_MENUCHECK = 0x0001;
static const int DFCS_MENUBULLET = 0x0002;
static const int DFCS_MENUARROWRIGHT = 0x0004;
static const int DFCS_SCROLLUP = 0x0000;
static const int DFCS_SCROLLDOWN = 0x0001;
static const int DFCS_SCROLLLEFT = 0x0002;
static const int DFCS_SCROLLRIGHT = 0x0003;
static const int DFCS_SCROLLCOMBOBOX = 0x0005;
static const int DFCS_SCROLLSIZEGRIP = 0x0008;
static const int DFCS_SCROLLSIZEGRIPRIGHT = 0x0010;
static const int DFCS_BUTTONCHECK = 0x0000;
static const int DFCS_BUTTONRADIOIMAGE = 0x0001;
static const int DFCS_BUTTONRADIOMASK = 0x0002;
static const int DFCS_BUTTONRADIO = 0x0004;
static const int DFCS_BUTTON3STATE = 0x0008;
static const int DFCS_BUTTONPUSH = 0x0010;
static const int DFCS_INACTIVE = 0x0100;
static const int DFCS_PUSHED = 0x0200;
static const int DFCS_CHECKED = 0x0400;
static const int DFCS_TRANSPARENT = 0x0800;
static const int DFCS_HOT = 0x1000;
static const int DFCS_ADJUSTRECT = 0x2000;
static const int DFCS_FLAT = 0x4000;
static const int DFCS_MONO = 0x8000;
BOOL
DrawFrameControl(
    HDC,
    LPRECT,
    UINT,
    UINT);
/* flags for DrawCaption */
static const int DC_ACTIVE = 0x0001;
static const int DC_SMALLCAP = 0x0002;
static const int DC_ICON = 0x0004;
static const int DC_TEXT = 0x0008;
static const int DC_INBUTTON = 0x0010;
static const int DC_GRADIENT = 0x0020;
static const int DC_BUTTONS = 0x1000;
BOOL
DrawCaption(
    HWND hwnd,
    HDC hdc,
    const RECT * lprect,
    UINT flags);
static const int IDANI_OPEN = 1;
static const int IDANI_CAPTION = 3;
BOOL
DrawAnimatedRects(
    HWND hwnd,
    int idAni,
    const RECT *lprcFrom,
    const RECT *lprcTo);
/*
 * Predefined Clipboard Formats
 */
# 2735 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CF_TEXT = 1;
static const int CF_BITMAP = 2;
static const int CF_METAFILEPICT = 3;
static const int CF_SYLK = 4;
static const int CF_DIF = 5;
static const int CF_TIFF = 6;
static const int CF_OEMTEXT = 7;
static const int CF_DIB = 8;
static const int CF_PALETTE = 9;
static const int CF_PENDATA = 10;
static const int CF_RIFF = 11;
static const int CF_WAVE = 12;
static const int CF_UNICODETEXT = 13;
static const int CF_ENHMETAFILE = 14;
static const int CF_HDROP = 15;
static const int CF_LOCALE = 16;
static const int CF_DIBV5 = 17;
static const int CF_MAX = 18;
static const int CF_OWNERDISPLAY = 0x0080;
static const int CF_DSPTEXT = 0x0081;
static const int CF_DSPBITMAP = 0x0082;
static const int CF_DSPMETAFILEPICT = 0x0083;
static const int CF_DSPENHMETAFILE = 0x008E;
/*
 * "Private" formats don't get GlobalFree()'d
 */
# 2774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CF_PRIVATEFIRST = 0x0200;
static const int CF_PRIVATELAST = 0x02FF;
/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */
# 2780 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CF_GDIOBJFIRST = 0x0300;
static const int CF_GDIOBJLAST = 0x03FF;
/*
 * Defines for the fVirt field of the Accelerator table structure.
 */
# 2789 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int FVIRTKEY = TRUE;
static const int FNOINVERT = 0x02;
static const int FSHIFT = 0x04;
static const int FCONTROL = 0x08;
static const int FALT = 0x10;
typedef struct tagACCEL {
    BYTE fVirt; /* Also called the flags field */
    WORD key;
    WORD cmd;
} ACCEL, *LPACCEL;
typedef struct tagPAINTSTRUCT {
    HDC hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;
typedef struct tagCREATESTRUCTA {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCSTR lpszName;
    LPCSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCWSTR lpszName;
    LPCWSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;
typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;
typedef struct tagWINDOWPLACEMENT {
    UINT length;
    UINT flags;
    UINT showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;
static const int WPF_SETMINPOSITION = 0x0001;
static const int WPF_RESTORETOMAXIMIZED = 0x0002;
static const int WPF_ASYNCWINDOWPLACEMENT = 0x0004;
typedef struct tagNMHDR
{
    HWND hwndFrom;
    UINT_PTR idFrom;
    UINT code; // NM_ code
} NMHDR;
typedef NMHDR * LPNMHDR;
typedef struct tagSTYLESTRUCT
{
    DWORD styleOld;
    DWORD styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;
/*
 * Owner draw control types
 */
# 2891 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ODT_MENU = 1;
static const int ODT_LISTBOX = 2;
static const int ODT_COMBOBOX = 3;
static const int ODT_BUTTON = 4;
static const int ODT_STATIC = 5;
/*
 * Owner draw actions
 */
# 2902 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ODA_DRAWENTIRE = 0x0001;
static const int ODA_SELECT = 0x0002;
static const int ODA_FOCUS = 0x0004;
/*
 * Owner draw state
 */
# 2909 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ODS_SELECTED = 0x0001;
static const int ODS_GRAYED = 0x0002;
static const int ODS_DISABLED = 0x0004;
static const int ODS_CHECKED = 0x0008;
static const int ODS_FOCUS = 0x0010;
static const int ODS_DEFAULT = 0x0020;
static const int ODS_COMBOBOXEDIT = 0x1000;
static const int ODS_HOTLIGHT = 0x0040;
static const int ODS_INACTIVE = 0x0080;
static const int ODS_NOACCEL = 0x0100;
static const int ODS_NOFOCUSRECT = 0x0200;
/*
 * MEASUREITEMSTRUCT for ownerdraw
 */
# 2930 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMEASUREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemWidth;
    UINT itemHeight;
    ULONG_PTR itemData;
} MEASUREITEMSTRUCT, *PMEASUREITEMSTRUCT, *LPMEASUREITEMSTRUCT;
/*
 * DRAWITEMSTRUCT for ownerdraw
 */
# 2942 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagDRAWITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemAction;
    UINT itemState;
    HWND hwndItem;
    HDC hDC;
    RECT rcItem;
    ULONG_PTR itemData;
} DRAWITEMSTRUCT, *PDRAWITEMSTRUCT, *LPDRAWITEMSTRUCT;
/*
 * DELETEITEMSTRUCT for ownerdraw
 */
# 2957 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagDELETEITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    HWND hwndItem;
    ULONG_PTR itemData;
} DELETEITEMSTRUCT, *PDELETEITEMSTRUCT, *LPDELETEITEMSTRUCT;
/*
 * COMPAREITEMSTUCT for ownerdraw sorting
 */
# 2968 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCOMPAREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    HWND hwndItem;
    UINT itemID1;
    ULONG_PTR itemData1;
    UINT itemID2;
    ULONG_PTR itemData2;
    DWORD dwLocaleId;
} COMPAREITEMSTRUCT, *PCOMPAREITEMSTRUCT, *LPCOMPAREITEMSTRUCT;
/*
 * Message Function Templates
 */
# 2985 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
GetMessageA(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);
BOOL
GetMessageW(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);
static const int GetMessage = GetMessageA;
# 3032 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
TranslateMessage(
    const MSG *lpMsg);
LRESULT
DispatchMessageA(
    const MSG *lpMsg);
LRESULT
DispatchMessageW(
    const MSG *lpMsg);
static const int DispatchMessage = DispatchMessageA;
# 3072 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
SetMessageQueue(
    int cMessagesMax);
BOOL
PeekMessageA(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);
BOOL
PeekMessageW(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);
static const int PeekMessage = PeekMessageA;
/*
 * PeekMessage() Options
 */
# 3106 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int PM_NOREMOVE = 0x0000;
static const int PM_REMOVE = 0x0001;
static const int PM_NOYIELD = 0x0002;
static const int PM_QS_INPUT = (QS_INPUT << 16);
static const int PM_QS_POSTMESSAGE = ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) << 16);
static const int PM_QS_PAINT = (QS_PAINT << 16);
static const int PM_QS_SENDMESSAGE = (QS_SENDMESSAGE << 16);
BOOL
RegisterHotKey(
    HWND hWnd,
    int id,
    UINT fsModifiers,
    UINT vk);
BOOL
UnregisterHotKey(
    HWND hWnd,
    int id);
static const int MOD_ALT = 0x0001;
static const int MOD_CONTROL = 0x0002;
static const int MOD_SHIFT = 0x0004;
static const int MOD_WIN = 0x0008;
static const int MOD_NOREPEAT = 0x4000;
static const int IDHOT_SNAPWINDOW = (-1);
static const int IDHOT_SNAPDESKTOP = (-2);
# 3158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ENDSESSION_LOGOFF = 0x80000000;
static const int ENDSESSION_CRITICAL = 0x40000000;
static const int ENDSESSION_CLOSEAPP = 0x00000001;
static const int EWX_LOGOFF = 0;
static const int EWX_SHUTDOWN = 0x00000001;
static const int EWX_REBOOT = 0x00000002;
static const int EWX_FORCE = 0x00000004;
static const int EWX_POWEROFF = 0x00000008;
static const int EWX_FORCEIFHUNG = 0x00000010;
static const int EWX_QUICKRESOLVE = 0x00000020;
static const int EWX_RESTARTAPPS = 0x00000040;
static const int ExitWindows(dwReserved,Code) = ExitWindowsEx(EWX_LOGOFF, 0xFFFFFFFF);
BOOL
ExitWindowsEx(
    UINT uFlags,
    DWORD dwReason);
BOOL
SwapMouseButton(
    BOOL fSwap);
DWORD
GetMessagePos(
    void);
LONG
GetMessageTime(
    void);
LPARAM
GetMessageExtraInfo(
    void);
BOOL
IsWow64Message(
    void);
LPARAM
SetMessageExtraInfo(
    LPARAM lParam);
LRESULT
SendMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
LRESULT
SendMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int SendMessage = SendMessageA;
# 3279 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
LRESULT
SendMessageTimeoutA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PDWORD_PTR lpdwResult);
LRESULT
SendMessageTimeoutW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PDWORD_PTR lpdwResult);
static const int SendMessageTimeout = SendMessageTimeoutA;
BOOL
SendNotifyMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
BOOL
SendNotifyMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int SendNotifyMessage = SendNotifyMessageA;
BOOL
SendMessageCallbackA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData);
BOOL
SendMessageCallbackW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData);
static const int SendMessageCallback = SendMessageCallbackA;
typedef struct {
    UINT cbSize;
    HDESK hdesk;
    HWND hwnd;
    LUID luid;
} BSMINFO, *PBSMINFO;
long
BroadcastSystemMessageExA(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pbsmInfo);
long
BroadcastSystemMessageExW(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pbsmInfo);
static const int BroadcastSystemMessageEx = BroadcastSystemMessageExA;
long
BroadcastSystemMessageA(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
long
BroadcastSystemMessageW(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int BroadcastSystemMessage = BroadcastSystemMessageA;
# 3430 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
//Broadcast Special Message Recipient list
static const int BSM_ALLCOMPONENTS = 0x00000000;
static const int BSM_VXDS = 0x00000001;
static const int BSM_NETDRIVER = 0x00000002;
static const int BSM_INSTALLABLEDRIVERS = 0x00000004;
static const int BSM_APPLICATIONS = 0x00000008;
static const int BSM_ALLDESKTOPS = 0x00000010;
//Broadcast Special Message Flags
static const int BSF_QUERY = 0x00000001;
static const int BSF_IGNORECURRENTTASK = 0x00000002;
static const int BSF_FLUSHDISK = 0x00000004;
static const int BSF_NOHANG = 0x00000008;
static const int BSF_POSTMESSAGE = 0x00000010;
static const int BSF_FORCEIFHUNG = 0x00000020;
static const int BSF_NOTIMEOUTIFNOTHUNG = 0x00000040;
static const int BSF_ALLOWSFW = 0x00000080;
static const int BSF_SENDNOTIFYMESSAGE = 0x00000100;
static const int BSF_RETURNHDESK = 0x00000200;
static const int BSF_LUID = 0x00000400;
static const int BROADCAST_QUERY_DENY = 0x424D5144;
// RegisterDeviceNotification
typedef PVOID HDEVNOTIFY;
typedef HDEVNOTIFY *PHDEVNOTIFY;
static const int DEVICE_NOTIFY_WINDOW_HANDLE = 0x00000000;
static const int DEVICE_NOTIFY_SERVICE_HANDLE = 0x00000001;
static const int DEVICE_NOTIFY_ALL_INTERFACE_CLASSES = 0x00000004;
HDEVNOTIFY
RegisterDeviceNotificationA(
    HANDLE hRecipient,
    LPVOID NotificationFilter,
    DWORD Flags);
HDEVNOTIFY
RegisterDeviceNotificationW(
    HANDLE hRecipient,
    LPVOID NotificationFilter,
    DWORD Flags);
static const int RegisterDeviceNotification = RegisterDeviceNotificationA;
BOOL
UnregisterDeviceNotification(
    HDEVNOTIFY Handle
    );
typedef PVOID HPOWERNOTIFY;
typedef HPOWERNOTIFY *PHPOWERNOTIFY;
HPOWERNOTIFY
RegisterPowerSettingNotification(
    HANDLE hRecipient,
    LPCGUID PowerSettingGuid,
    DWORD Flags
    );
BOOL
UnregisterPowerSettingNotification(
    HPOWERNOTIFY Handle
    );
BOOL
PostMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
BOOL
PostMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int PostMessage = PostMessageA;
BOOL
PostThreadMessageA(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
BOOL
PostThreadMessageW(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int PostThreadMessage = PostThreadMessageA;
static const int PostAppMessageA(idThread,wMsg,wParam,lParam) = PostThreadMessageA((DWORD)idThread, wMsg, wParam, lParam);
static const int PostAppMessageW(idThread,wMsg,wParam,lParam) = PostThreadMessageW((DWORD)idThread, wMsg, wParam, lParam);
static const int PostAppMessage = PostAppMessageA;
/*
 * Special HWND value for use with PostMessage() and SendMessage()
 */
# 3584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HWND_BROADCAST = ((HWND)0xffff);
static const int HWND_MESSAGE = ((HWND)-3);
BOOL
AttachThreadInput(
    DWORD idAttach,
    DWORD idAttachTo,
    BOOL fAttach);
BOOL
ReplyMessage(
    LRESULT lResult);
BOOL
WaitMessage(
    void);
DWORD
WaitForInputIdle(
    HANDLE hProcess,
    DWORD dwMilliseconds);
LRESULT
DefWindowProcA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
LRESULT
DefWindowProcW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int DefWindowProc = DefWindowProcA;
void
PostQuitMessage(
    int nExitCode);
LRESULT
CallWindowProcA(
    WNDPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
LRESULT
CallWindowProcW(
    WNDPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int CallWindowProc = CallWindowProcA;
# 3711 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
InSendMessage(
    void);
DWORD
InSendMessageEx(
    LPVOID lpReserved);
/*
 * InSendMessageEx return value
 */
# 3727 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ISMEX_NOSEND = 0x00000000;
static const int ISMEX_SEND = 0x00000001;
static const int ISMEX_NOTIFY = 0x00000002;
static const int ISMEX_CALLBACK = 0x00000004;
static const int ISMEX_REPLIED = 0x00000008;
UINT
GetDoubleClickTime(
    void);
BOOL
SetDoubleClickTime(
    UINT);
ATOM
RegisterClassA(
    const WNDCLASSA *lpWndClass);
ATOM
RegisterClassW(
    const WNDCLASSW *lpWndClass);
static const int RegisterClass = RegisterClassA;
BOOL
UnregisterClassA(
    LPCSTR lpClassName,
    HINSTANCE hInstance);
BOOL
UnregisterClassW(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);
static const int UnregisterClass = UnregisterClassA;
BOOL
GetClassInfoA(
    HINSTANCE hInstance,
    LPCSTR lpClassName,
    LPWNDCLASSA lpWndClass);
BOOL
GetClassInfoW(
    HINSTANCE hInstance,
    LPCWSTR lpClassName,
    LPWNDCLASSW lpWndClass);
static const int GetClassInfo = GetClassInfoA;
ATOM
RegisterClassExA(
    const WNDCLASSEXA *);
ATOM
RegisterClassExW(
    const WNDCLASSEXW *);
static const int RegisterClassEx = RegisterClassExA;
BOOL
GetClassInfoExA(
    HINSTANCE hInstance,
    LPCSTR lpszClass,
    LPWNDCLASSEXA lpwcx);
BOOL
GetClassInfoExW(
    HINSTANCE hInstance,
    LPCWSTR lpszClass,
    LPWNDCLASSEXW lpwcx);
static const int GetClassInfoEx = GetClassInfoExA;
static const int CW_USEDEFAULT = ((int)0x80000000);
/*
 * Special value for CreateWindow, et al.
 */
# 3844 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int HWND_DESKTOP = ((HWND)0);
typedef BOOLEAN ( * PREGISTERCLASSNAMEW)(LPCWSTR);
HWND
CreateWindowExA(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);
HWND
CreateWindowExW(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);
static const int CreateWindowEx = CreateWindowExA;
static const int CreateWindowA(lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam) = CreateWindowExA(0L, lpClassName, lpWindowName, dwStyle, x, y,nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
static const int CreateWindowW(lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam) = CreateWindowExW(0L, lpClassName, lpWindowName, dwStyle, x, y,nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
static const int CreateWindow = CreateWindowA;
BOOL
IsWindow(
    HWND hWnd);
BOOL
IsMenu(
    HMENU hMenu);
BOOL
IsChild(
    HWND hWndParent,
    HWND hWnd);
BOOL
DestroyWindow(
    HWND hWnd);
BOOL
ShowWindow(
    HWND hWnd,
    int nCmdShow);
BOOL
AnimateWindow(
    HWND hWnd,
    DWORD dwTime,
    DWORD dwFlags);
BOOL
UpdateLayeredWindow(
    HWND hWnd,
    HDC hdcDst,
    POINT* pptDst,
    SIZE* psize,
    HDC hdcSrc,
    POINT* pptSrc,
    COLORREF crKey,
    BLENDFUNCTION* pblend,
    DWORD dwFlags);
/*
 * Layered Window Update information
 */
# 3965 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagUPDATELAYEREDWINDOWINFO
{
    DWORD cbSize;
    HDC hdcDst;
    const POINT* pptDst;
    const SIZE* psize;
    HDC hdcSrc;
    const POINT* pptSrc;
    COLORREF crKey;
    const BLENDFUNCTION* pblend;
    DWORD dwFlags;
    const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;
BOOL
UpdateLayeredWindowIndirect(
    HWND hWnd,
    const UPDATELAYEREDWINDOWINFO* pULWInfo);
BOOL
GetLayeredWindowAttributes(
    HWND hwnd,
    COLORREF* pcrKey,
    BYTE* pbAlpha,
    DWORD* pdwFlags);
static const int PW_CLIENTONLY = 0x00000001;
BOOL
PrintWindow(
    HWND hwnd,
    HDC hdcBlt,
    UINT nFlags);
BOOL
SetLayeredWindowAttributes(
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
static const int LWA_COLORKEY = 0x00000001;
static const int LWA_ALPHA = 0x00000002;
static const int ULW_COLORKEY = 0x00000001;
static const int ULW_ALPHA = 0x00000002;
static const int ULW_OPAQUE = 0x00000004;
static const int ULW_EX_NORESIZE = 0x00000008;
BOOL
ShowWindowAsync(
    HWND hWnd,
    int nCmdShow);
BOOL
FlashWindow(
    HWND hWnd,
    BOOL bInvert);
typedef struct {
    UINT cbSize;
    HWND hwnd;
    DWORD dwFlags;
    UINT uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;
BOOL
FlashWindowEx(
    PFLASHWINFO pfwi);
static const int FLASHW_STOP = 0;
static const int FLASHW_CAPTION = 0x00000001;
static const int FLASHW_TRAY = 0x00000002;
static const int FLASHW_ALL = (FLASHW_CAPTION | FLASHW_TRAY);
static const int FLASHW_TIMER = 0x00000004;
static const int FLASHW_TIMERNOFG = 0x0000000C;
BOOL
ShowOwnedPopups(
    HWND hWnd,
    BOOL fShow);
BOOL
OpenIcon(
    HWND hWnd);
BOOL
CloseWindow(
    HWND hWnd);
BOOL
MoveWindow(
    HWND hWnd,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    BOOL bRepaint);
BOOL
SetWindowPos(
    HWND hWnd,
    HWND hWndInsertAfter,
    int X,
    int Y,
    int cx,
    int cy,
    UINT uFlags);
BOOL
GetWindowPlacement(
    HWND hWnd,
    WINDOWPLACEMENT *lpwndpl);
BOOL
SetWindowPlacement(
    HWND hWnd,
    const WINDOWPLACEMENT *lpwndpl);
static const int WDA_NONE = 0x00000000;
static const int WDA_MONITOR = 0x00000001;
BOOL
GetWindowDisplayAffinity(
    HWND hWnd,
    DWORD* pdwAffinity);
BOOL
SetWindowDisplayAffinity(
    HWND hWnd,
    DWORD dwAffinity);
HDWP
BeginDeferWindowPos(
    int nNumWindows);
HDWP
DeferWindowPos(
    HDWP hWinPosInfo,
    HWND hWnd,
    HWND hWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);
BOOL
EndDeferWindowPos(
    HDWP hWinPosInfo);
BOOL
IsWindowVisible(
    HWND hWnd);
BOOL
IsIconic(
    HWND hWnd);
BOOL
AnyPopup(
    void);
BOOL
BringWindowToTop(
    HWND hWnd);
BOOL
IsZoomed(
    HWND hWnd);
/*
 * SetWindowPos Flags
 */
# 4216 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SWP_NOSIZE = 0x0001;
static const int SWP_NOMOVE = 0x0002;
static const int SWP_NOZORDER = 0x0004;
static const int SWP_NOREDRAW = 0x0008;
static const int SWP_NOACTIVATE = 0x0010;
static const int SWP_FRAMECHANGED = 0x0020;
static const int SWP_SHOWWINDOW = 0x0040;
static const int SWP_HIDEWINDOW = 0x0080;
static const int SWP_NOCOPYBITS = 0x0100;
static const int SWP_NOOWNERZORDER = 0x0200;
static const int SWP_NOSENDCHANGING = 0x0400;
static const int SWP_DRAWFRAME = SWP_FRAMECHANGED;
static const int SWP_NOREPOSITION = SWP_NOOWNERZORDER;
static const int SWP_DEFERERASE = 0x2000;
static const int SWP_ASYNCWINDOWPOS = 0x4000;
static const int HWND_TOP = ((HWND)0);
static const int HWND_BOTTOM = ((HWND)1);
static const int HWND_TOPMOST = ((HWND)-1);
static const int HWND_NOTOPMOST = ((HWND)-2);
/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
# 4249 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    pshpack2.h
Abstract:
    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.
    The file poppack.h is the complement to this file.
--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 4250 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 2
/*
 * original NT 32 bit dialog template:
 */
# 4254 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;
typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;
typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEW;
typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
/*
 * 32 bit Dialog item template.
 */
# 4281 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;
typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;
typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    poppack.h
Abstract:
    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.
    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.
    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.
--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 4307 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 2
HWND
CreateDialogParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
HWND
CreateDialogParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
static const int CreateDialogParam = CreateDialogParamA;
HWND
CreateDialogIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
HWND
CreateDialogIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
static const int CreateDialogIndirectParam = CreateDialogIndirectParamA;
static const int CreateDialogA(hInstance,lpName,hWndParent,lpDialogFunc) = CreateDialogParamA(hInstance, lpName, hWndParent, lpDialogFunc, 0L);
static const int CreateDialogW(hInstance,lpName,hWndParent,lpDialogFunc) = CreateDialogParamW(hInstance, lpName, hWndParent, lpDialogFunc, 0L);
static const int CreateDialog = CreateDialogA;
static const int CreateDialogIndirectA(hInstance,lpTemplate,hWndParent,lpDialogFunc) = CreateDialogIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
static const int CreateDialogIndirectW(hInstance,lpTemplate,hWndParent,lpDialogFunc) = CreateDialogIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
static const int CreateDialogIndirect = CreateDialogIndirectA;
INT_PTR
DialogBoxParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
INT_PTR
DialogBoxParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
static const int DialogBoxParam = DialogBoxParamA;
INT_PTR
DialogBoxIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA hDialogTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
INT_PTR
DialogBoxIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW hDialogTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);
static const int DialogBoxIndirectParam = DialogBoxIndirectParamA;
static const int DialogBoxA(hInstance,lpTemplate,hWndParent,lpDialogFunc) = DialogBoxParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
static const int DialogBoxW(hInstance,lpTemplate,hWndParent,lpDialogFunc) = DialogBoxParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
static const int DialogBox = DialogBoxA;
static const int DialogBoxIndirectA(hInstance,lpTemplate,hWndParent,lpDialogFunc) = DialogBoxIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
static const int DialogBoxIndirectW(hInstance,lpTemplate,hWndParent,lpDialogFunc) = DialogBoxIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
static const int DialogBoxIndirect = DialogBoxIndirectA;
BOOL
EndDialog(
    HWND hDlg,
    INT_PTR nResult);
HWND
GetDlgItem(
    HWND hDlg,
    int nIDDlgItem);
BOOL
SetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    UINT uValue,
    BOOL bSigned);
UINT
GetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    BOOL *lpTranslated,
    BOOL bSigned);
BOOL
SetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPCSTR lpString);
BOOL
SetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString);
static const int SetDlgItemText = SetDlgItemTextA;
UINT
GetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPSTR lpString,
    int cchMax);
UINT
GetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int cchMax);
static const int GetDlgItemText = GetDlgItemTextA;
BOOL
CheckDlgButton(
    HWND hDlg,
    int nIDButton,
    UINT uCheck);
BOOL
CheckRadioButton(
    HWND hDlg,
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);
UINT
IsDlgButtonChecked(
    HWND hDlg,
    int nIDButton);
LRESULT
SendDlgItemMessageA(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
LRESULT
SendDlgItemMessageW(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int SendDlgItemMessage = SendDlgItemMessageA;
HWND
GetNextDlgGroupItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);
HWND
GetNextDlgTabItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);
int
GetDlgCtrlID(
    HWND hWnd);
long
GetDialogBaseUnits(void);
LRESULT
DefDlgProcA(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
LRESULT
DefDlgProcW(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
static const int DefDlgProc = DefDlgProcA;
/*
 * Window extra byted needed for private dialog classes.
 */
# 4629 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int DLGWINDOWEXTRA = 30;
# 4638 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
CallMsgFilterA(
    LPMSG lpMsg,
    int nCode);
BOOL
CallMsgFilterW(
    LPMSG lpMsg,
    int nCode);
static const int CallMsgFilter = CallMsgFilterA;
/*
 * Clipboard Manager Functions
 */
# 4664 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
OpenClipboard(
    HWND hWndNewOwner);
BOOL
CloseClipboard(
    void);
DWORD
GetClipboardSequenceNumber(
    void);
HWND
GetClipboardOwner(
    void);
HWND
SetClipboardViewer(
    HWND hWndNewViewer);
HWND
GetClipboardViewer(
    void);
BOOL
ChangeClipboardChain(
    HWND hWndRemove,
    HWND hWndNewNext);
HANDLE
SetClipboardData(
    UINT uFormat,
    HANDLE hMem);
HANDLE
GetClipboardData(
    UINT uFormat);
UINT
RegisterClipboardFormatA(
    LPCSTR lpszFormat);
UINT
RegisterClipboardFormatW(
    LPCWSTR lpszFormat);
static const int RegisterClipboardFormat = RegisterClipboardFormatA;
int
CountClipboardFormats(
    void);
UINT
EnumClipboardFormats(
    UINT format);
int
GetClipboardFormatNameA(
    UINT format,
    LPSTR lpszFormatName,
    int cchMaxCount);
int
GetClipboardFormatNameW(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);
static const int GetClipboardFormatName = GetClipboardFormatNameA;
BOOL
EmptyClipboard(
    void);
BOOL
IsClipboardFormatAvailable(
    UINT format);
int
GetPriorityClipboardFormat(
    UINT *paFormatPriorityList,
    int cFormats);
HWND
GetOpenClipboardWindow(
    void);
BOOL
AddClipboardFormatListener(
    HWND hwnd);
BOOL
RemoveClipboardFormatListener(
    HWND hwnd);
BOOL
GetUpdatedClipboardFormats(
    PUINT lpuiFormats,
    UINT cFormats,
    PUINT pcFormatsOut);
/*
 * Character Translation Routines
 */
# 4825 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
CharToOemA(
    LPCSTR pSrc,
    LPSTR pDst);
BOOL
CharToOemW(
    LPCWSTR pSrc,
    LPSTR pDst);
static const int CharToOem = CharToOemA;
BOOL
OemToCharA(
    LPCSTR pSrc,
    LPSTR pDst);
BOOL
OemToCharW(
    LPCSTR pSrc,
    LPWSTR pDst);
static const int OemToChar = OemToCharA;
BOOL
CharToOemBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
BOOL
CharToOemBuffW(
    LPCWSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
static const int CharToOemBuff = CharToOemBuffA;
BOOL
OemToCharBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);
BOOL
OemToCharBuffW(
    LPCSTR lpszSrc,
    LPWSTR lpszDst,
    DWORD cchDstLength);
static const int OemToCharBuff = OemToCharBuffA;
LPSTR
CharUpperA(
    LPSTR lpsz);
LPWSTR
CharUpperW(
    LPWSTR lpsz);
static const int CharUpper = CharUpperA;
DWORD
CharUpperBuffA(
    LPSTR lpsz,
    DWORD cchLength);
DWORD
CharUpperBuffW(
    LPWSTR lpsz,
    DWORD cchLength);
static const int CharUpperBuff = CharUpperBuffA;
LPSTR
CharLowerA(
    LPSTR lpsz);
LPWSTR
CharLowerW(
    LPWSTR lpsz);
static const int CharLower = CharLowerA;
DWORD
CharLowerBuffA(
    LPSTR lpsz,
    DWORD cchLength);
DWORD
CharLowerBuffW(
    LPWSTR lpsz,
    DWORD cchLength);
static const int CharLowerBuff = CharLowerBuffA;
LPSTR
CharNextA(
    LPCSTR lpsz);
LPWSTR
CharNextW(
    LPCWSTR lpsz);
static const int CharNext = CharNextA;
LPSTR
CharPrevA(
    LPCSTR lpszStart,
    LPCSTR lpszCurrent);
LPWSTR
CharPrevW(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);
static const int CharPrev = CharPrevA;
LPSTR
CharNextExA(
     WORD CodePage,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);
LPSTR
CharPrevExA(
     WORD CodePage,
     LPCSTR lpStart,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);
/*
 * Compatibility defines for character translation routines
 */
# 5027 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int AnsiToOem = CharToOemA;
static const int OemToAnsi = OemToCharA;
static const int AnsiToOemBuff = CharToOemBuffA;
static const int OemToAnsiBuff = OemToCharBuffA;
static const int AnsiUpper = CharUpperA;
static const int AnsiUpperBuff = CharUpperBuffA;
static const int AnsiLower = CharLowerA;
static const int AnsiLowerBuff = CharLowerBuffA;
static const int AnsiNext = CharNextA;
static const int AnsiPrev = CharPrevA;
/*
 * Language dependent Routines
 */
# 5043 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
IsCharAlphaA(
    CHAR ch);
BOOL
IsCharAlphaW(
    WCHAR ch);
static const int IsCharAlpha = IsCharAlphaA;
BOOL
IsCharAlphaNumericA(
    CHAR ch);
BOOL
IsCharAlphaNumericW(
    WCHAR ch);
static const int IsCharAlphaNumeric = IsCharAlphaNumericA;
BOOL
IsCharUpperA(
    CHAR ch);
BOOL
IsCharUpperW(
    WCHAR ch);
static const int IsCharUpper = IsCharUpperA;
BOOL
IsCharLowerA(
    CHAR ch);
BOOL
IsCharLowerW(
    WCHAR ch);
static const int IsCharLower = IsCharLowerA;
HWND
SetFocus(
    HWND hWnd);
HWND
GetActiveWindow(
    void);
HWND
GetFocus(
    void);
UINT
GetKBCodePage(
    void);
SHORT
GetKeyState(
    int nVirtKey);
SHORT
GetAsyncKeyState(
    int vKey);
BOOL
GetKeyboardState(
    PBYTE lpKeyState);
BOOL
SetKeyboardState(
    LPBYTE lpKeyState);
int
GetKeyNameTextA(
    LONG lParam,
    LPSTR lpString,
    int cchSize);
int
GetKeyNameTextW(
    LONG lParam,
    LPWSTR lpString,
    int cchSize);
static const int GetKeyNameText = GetKeyNameTextA;
int
GetKeyboardType(
    int nTypeFlag);
int
ToAscii(
    UINT uVirtKey,
    UINT uScanCode,
    const BYTE *lpKeyState,
    LPWORD lpChar,
    UINT uFlags);
int
ToAsciiEx(
    UINT uVirtKey,
    UINT uScanCode,
    const BYTE *lpKeyState,
    LPWORD lpChar,
    UINT uFlags,
    HKL dwhkl);
int
ToUnicode(
    UINT wVirtKey,
    UINT wScanCode,
    const BYTE *lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags);
DWORD
OemKeyScan(
    WORD wOemChar);
SHORT
VkKeyScanA(
    CHAR ch);
SHORT
VkKeyScanW(
    WCHAR ch);
static const int VkKeyScan = VkKeyScanA;
SHORT
VkKeyScanExA(
    CHAR ch,
    HKL dwhkl);
SHORT
VkKeyScanExW(
    WCHAR ch,
    HKL dwhkl);
static const int VkKeyScanEx = VkKeyScanExA;
static const int KEYEVENTF_EXTENDEDKEY = 0x0001;
static const int KEYEVENTF_KEYUP = 0x0002;
static const int KEYEVENTF_UNICODE = 0x0004;
static const int KEYEVENTF_SCANCODE = 0x0008;
void
keybd_event(
    BYTE bVk,
    BYTE bScan,
    DWORD dwFlags,
    ULONG_PTR dwExtraInfo);
static const int MOUSEEVENTF_MOVE = 0x0001;
static const int MOUSEEVENTF_LEFTDOWN = 0x0002;
static const int MOUSEEVENTF_LEFTUP = 0x0004;
static const int MOUSEEVENTF_RIGHTDOWN = 0x0008;
static const int MOUSEEVENTF_RIGHTUP = 0x0010;
static const int MOUSEEVENTF_MIDDLEDOWN = 0x0020;
static const int MOUSEEVENTF_MIDDLEUP = 0x0040;
static const int MOUSEEVENTF_XDOWN = 0x0080;
static const int MOUSEEVENTF_XUP = 0x0100;
static const int MOUSEEVENTF_WHEEL = 0x0800;
static const int MOUSEEVENTF_HWHEEL = 0x01000;
static const int MOUSEEVENTF_MOVE_NOCOALESCE = 0x2000;
static const int MOUSEEVENTF_VIRTUALDESK = 0x4000;
static const int MOUSEEVENTF_ABSOLUTE = 0x8000;
void
mouse_event(
    DWORD dwFlags,
    DWORD dx,
    DWORD dy,
    DWORD dwData,
    ULONG_PTR dwExtraInfo);
typedef struct tagMOUSEINPUT {
    LONG dx;
    LONG dy;
    DWORD mouseData;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;
typedef struct tagKEYBDINPUT {
    WORD wVk;
    WORD wScan;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, * LPKEYBDINPUT;
typedef struct tagHARDWAREINPUT {
    DWORD uMsg;
    WORD wParamL;
    WORD wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, * LPHARDWAREINPUT;
static const int INPUT_MOUSE = 0;
static const int INPUT_KEYBOARD = 1;
static const int INPUT_HARDWARE = 2;
typedef struct tagINPUT {
    DWORD type;
    union
    {
        MOUSEINPUT mi;
        KEYBDINPUT ki;
        HARDWAREINPUT hi;
    };
} INPUT, *PINPUT, * LPINPUT;
UINT
SendInput(
    UINT cInputs, // number of input in the array
    LPINPUT pInputs, // array of inputs
    int cbSize); // sizeof(INPUT)
/*
 * Touch Input defines and functions
 */
# 5359 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Touch input handle
 */
# 5362 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
struct HTOUCHINPUT__{int unused;}; typedef struct HTOUCHINPUT__ *HTOUCHINPUT;
typedef struct tagTOUCHINPUT {
    LONG x;
    LONG y;
    HANDLE hSource;
    DWORD dwID;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwTime;
    ULONG_PTR dwExtraInfo;
    DWORD cxContact;
    DWORD cyContact;
} TOUCHINPUT, *PTOUCHINPUT;
typedef TOUCHINPUT const * PCTOUCHINPUT;
/*
 * Conversion of touch input coordinates to pixels
 */
# 5382 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int TOUCH_COORD_TO_PIXEL(l) = ((l) / 100);
/*
 * Touch input flag values (TOUCHINPUT.dwFlags)
 */
# 5387 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int TOUCHEVENTF_MOVE = 0x0001;
static const int TOUCHEVENTF_DOWN = 0x0002;
static const int TOUCHEVENTF_UP = 0x0004;
static const int TOUCHEVENTF_INRANGE = 0x0008;
static const int TOUCHEVENTF_PRIMARY = 0x0010;
static const int TOUCHEVENTF_NOCOALESCE = 0x0020;
static const int TOUCHEVENTF_PEN = 0x0040;
static const int TOUCHEVENTF_PALM = 0x0080;
/*
 * Touch input mask values (TOUCHINPUT.dwMask)
 */
# 5399 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int TOUCHINPUTMASKF_TIMEFROMSYSTEM = 0x0001;
static const int TOUCHINPUTMASKF_EXTRAINFO = 0x0002;
static const int TOUCHINPUTMASKF_CONTACTAREA = 0x0004;
BOOL
GetTouchInputInfo(
    HTOUCHINPUT hTouchInput, // input event handle; from touch message lParam
    UINT cInputs, // number of elements in the array
    PTOUCHINPUT pInputs, // array of touch inputs
    int cbSize); // sizeof(TOUCHINPUT)
BOOL
CloseTouchInputHandle(
    HTOUCHINPUT hTouchInput); // input event handle; from touch message lParam
/*
 * RegisterTouchWindow flag values
 */
# 5422 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int TWF_FINETOUCH = (0x00000001);
static const int TWF_WANTPALM = (0x00000002);
BOOL
RegisterTouchWindow(
    HWND hwnd,
    ULONG ulFlags);
BOOL
UnregisterTouchWindow(
    HWND hwnd);
BOOL
IsTouchWindow(
    HWND hwnd,
    PULONG pulFlags);
typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;
BOOL
GetLastInputInfo(
    PLASTINPUTINFO plii);
UINT
MapVirtualKeyA(
    UINT uCode,
    UINT uMapType);
UINT
MapVirtualKeyW(
    UINT uCode,
    UINT uMapType);
static const int MapVirtualKey = MapVirtualKeyA;
UINT
MapVirtualKeyExA(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);
UINT
MapVirtualKeyExW(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);
static const int MapVirtualKeyEx = MapVirtualKeyExA;
static const int MAPVK_VK_TO_VSC = (0);
static const int MAPVK_VSC_TO_VK = (1);
static const int MAPVK_VK_TO_CHAR = (2);
static const int MAPVK_VSC_TO_VK_EX = (3);
static const int MAPVK_VK_TO_VSC_EX = (4);
BOOL
GetInputState(
    void);
DWORD
GetQueueStatus(
    UINT flags);
HWND
GetCapture(
    void);
HWND
SetCapture(
    HWND hWnd);
BOOL
ReleaseCapture(
    void);
DWORD
MsgWaitForMultipleObjects(
    DWORD nCount,
    const HANDLE *pHandles,
    BOOL fWaitAll,
    DWORD dwMilliseconds,
    DWORD dwWakeMask);
DWORD
MsgWaitForMultipleObjectsEx(
    DWORD nCount,
    const HANDLE *pHandles,
    DWORD dwMilliseconds,
    DWORD dwWakeMask,
    DWORD dwFlags);
static const int MWMO_WAITALL = 0x0001;
static const int MWMO_ALERTABLE = 0x0002;
static const int MWMO_INPUTAVAILABLE = 0x0004;
/*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 */
# 5567 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int QS_KEY = 0x0001;
static const int QS_MOUSEMOVE = 0x0002;
static const int QS_MOUSEBUTTON = 0x0004;
static const int QS_POSTMESSAGE = 0x0008;
static const int QS_TIMER = 0x0010;
static const int QS_PAINT = 0x0020;
static const int QS_SENDMESSAGE = 0x0040;
static const int QS_HOTKEY = 0x0080;
static const int QS_ALLPOSTMESSAGE = 0x0100;
static const int QS_RAWINPUT = 0x0400;
static const int QS_MOUSE = (QS_MOUSEMOVE | QS_MOUSEBUTTON);
static const int QS_INPUT = (QS_MOUSE | QS_KEY | QS_RAWINPUT);
static const int QS_ALLEVENTS = (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY);
static const int QS_ALLINPUT = (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY | QS_SENDMESSAGE);
static const int USER_TIMER_MAXIMUM = 0x7FFFFFFF;
static const int USER_TIMER_MINIMUM = 0x0000000A;
/*
 * Windows Functions
 */
# 5613 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
UINT_PTR
SetTimer(
    HWND hWnd,
    UINT_PTR nIDEvent,
    UINT uElapse,
    TIMERPROC lpTimerFunc);
BOOL
KillTimer(
    HWND hWnd,
    UINT_PTR uIDEvent);
BOOL
IsWindowUnicode(
    HWND hWnd);
BOOL
EnableWindow(
    HWND hWnd,
    BOOL bEnable);
BOOL
IsWindowEnabled(
    HWND hWnd);
HACCEL
LoadAcceleratorsA(
    HINSTANCE hInstance,
    LPCSTR lpTableName);
HACCEL
LoadAcceleratorsW(
    HINSTANCE hInstance,
    LPCWSTR lpTableName);
static const int LoadAccelerators = LoadAcceleratorsA;
HACCEL
CreateAcceleratorTableA(
    LPACCEL paccel,
    int cAccel);
HACCEL
CreateAcceleratorTableW(
    LPACCEL paccel,
    int cAccel);
static const int CreateAcceleratorTable = CreateAcceleratorTableA;
BOOL
DestroyAcceleratorTable(
    HACCEL hAccel);
int
CopyAcceleratorTableA(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
int
CopyAcceleratorTableW(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);
static const int CopyAcceleratorTable = CopyAcceleratorTableA;
int
TranslateAcceleratorA(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
int
TranslateAcceleratorW(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);
static const int TranslateAccelerator = TranslateAcceleratorA;
/*
 * GetSystemMetrics() codes
 */
# 5740 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SM_CXSCREEN = 0;
static const int SM_CYSCREEN = 1;
static const int SM_CXVSCROLL = 2;
static const int SM_CYHSCROLL = 3;
static const int SM_CYCAPTION = 4;
static const int SM_CXBORDER = 5;
static const int SM_CYBORDER = 6;
static const int SM_CXDLGFRAME = 7;
static const int SM_CYDLGFRAME = 8;
static const int SM_CYVTHUMB = 9;
static const int SM_CXHTHUMB = 10;
static const int SM_CXICON = 11;
static const int SM_CYICON = 12;
static const int SM_CXCURSOR = 13;
static const int SM_CYCURSOR = 14;
static const int SM_CYMENU = 15;
static const int SM_CXFULLSCREEN = 16;
static const int SM_CYFULLSCREEN = 17;
static const int SM_CYKANJIWINDOW = 18;
static const int SM_MOUSEPRESENT = 19;
static const int SM_CYVSCROLL = 20;
static const int SM_CXHSCROLL = 21;
static const int SM_DEBUG = 22;
static const int SM_SWAPBUTTON = 23;
static const int SM_RESERVED1 = 24;
static const int SM_RESERVED2 = 25;
static const int SM_RESERVED3 = 26;
static const int SM_RESERVED4 = 27;
static const int SM_CXMIN = 28;
static const int SM_CYMIN = 29;
static const int SM_CXSIZE = 30;
static const int SM_CYSIZE = 31;
static const int SM_CXFRAME = 32;
static const int SM_CYFRAME = 33;
static const int SM_CXMINTRACK = 34;
static const int SM_CYMINTRACK = 35;
static const int SM_CXDOUBLECLK = 36;
static const int SM_CYDOUBLECLK = 37;
static const int SM_CXICONSPACING = 38;
static const int SM_CYICONSPACING = 39;
static const int SM_MENUDROPALIGNMENT = 40;
static const int SM_PENWINDOWS = 41;
static const int SM_DBCSENABLED = 42;
static const int SM_CMOUSEBUTTONS = 43;
static const int SM_CXFIXEDFRAME = SM_CXDLGFRAME;
static const int SM_CYFIXEDFRAME = SM_CYDLGFRAME;
static const int SM_CXSIZEFRAME = SM_CXFRAME;
static const int SM_CYSIZEFRAME = SM_CYFRAME;
static const int SM_SECURE = 44;
static const int SM_CXEDGE = 45;
static const int SM_CYEDGE = 46;
static const int SM_CXMINSPACING = 47;
static const int SM_CYMINSPACING = 48;
static const int SM_CXSMICON = 49;
static const int SM_CYSMICON = 50;
static const int SM_CYSMCAPTION = 51;
static const int SM_CXSMSIZE = 52;
static const int SM_CYSMSIZE = 53;
static const int SM_CXMENUSIZE = 54;
static const int SM_CYMENUSIZE = 55;
static const int SM_ARRANGE = 56;
static const int SM_CXMINIMIZED = 57;
static const int SM_CYMINIMIZED = 58;
static const int SM_CXMAXTRACK = 59;
static const int SM_CYMAXTRACK = 60;
static const int SM_CXMAXIMIZED = 61;
static const int SM_CYMAXIMIZED = 62;
static const int SM_NETWORK = 63;
static const int SM_CLEANBOOT = 67;
static const int SM_CXDRAG = 68;
static const int SM_CYDRAG = 69;
static const int SM_SHOWSOUNDS = 70;
static const int SM_CXMENUCHECK = 71;
static const int SM_CYMENUCHECK = 72;
static const int SM_SLOWMACHINE = 73;
static const int SM_MIDEASTENABLED = 74;
static const int SM_MOUSEWHEELPRESENT = 75;
static const int SM_XVIRTUALSCREEN = 76;
static const int SM_YVIRTUALSCREEN = 77;
static const int SM_CXVIRTUALSCREEN = 78;
static const int SM_CYVIRTUALSCREEN = 79;
static const int SM_CMONITORS = 80;
static const int SM_SAMEDISPLAYFORMAT = 81;
static const int SM_IMMENABLED = 82;
static const int SM_CXFOCUSBORDER = 83;
static const int SM_CYFOCUSBORDER = 84;
static const int SM_TABLETPC = 86;
static const int SM_MEDIACENTER = 87;
static const int SM_STARTER = 88;
static const int SM_SERVERR2 = 89;
static const int SM_MOUSEHORIZONTALWHEELPRESENT = 91;
static const int SM_CXPADDEDBORDER = 92;
static const int SM_DIGITIZER = 94;
static const int SM_MAXIMUMTOUCHES = 95;
# 5869 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SM_CMETRICS = 97;
static const int SM_REMOTESESSION = 0x1000;
static const int SM_SHUTTINGDOWN = 0x2000;
static const int SM_REMOTECONTROL = 0x2001;
static const int SM_CARETBLINKINGENABLED = 0x2002;
int
GetSystemMetrics(
    int nIndex);
HMENU
LoadMenuA(
    HINSTANCE hInstance,
    LPCSTR lpMenuName);
HMENU
LoadMenuW(
    HINSTANCE hInstance,
    LPCWSTR lpMenuName);
static const int LoadMenu = LoadMenuA;
HMENU
LoadMenuIndirectA(
    const MENUTEMPLATEA *lpMenuTemplate);
HMENU
LoadMenuIndirectW(
    const MENUTEMPLATEW *lpMenuTemplate);
static const int LoadMenuIndirect = LoadMenuIndirectA;
HMENU
GetMenu(
    HWND hWnd);
BOOL
SetMenu(
    HWND hWnd,
    HMENU hMenu);
BOOL
ChangeMenuA(
    HMENU hMenu,
    UINT cmd,
    LPCSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);
BOOL
ChangeMenuW(
    HMENU hMenu,
    UINT cmd,
    LPCWSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);
static const int ChangeMenu = ChangeMenuA;
BOOL
HiliteMenuItem(
    HWND hWnd,
    HMENU hMenu,
    UINT uIDHiliteItem,
    UINT uHilite);
int
GetMenuStringA(
    HMENU hMenu,
    UINT uIDItem,
    LPSTR lpString,
    int cchMax,
    UINT flags);
int
GetMenuStringW(
    HMENU hMenu,
    UINT uIDItem,
    LPWSTR lpString,
    int cchMax,
    UINT flags);
static const int GetMenuString = GetMenuStringA;
UINT
GetMenuState(
    HMENU hMenu,
    UINT uId,
    UINT uFlags);
BOOL
DrawMenuBar(
    HWND hWnd);
static const int PMB_ACTIVE = 0x00000001;
HMENU
GetSystemMenu(
    HWND hWnd,
    BOOL bRevert);
HMENU
CreateMenu(
    void);
HMENU
CreatePopupMenu(
    void);
BOOL
DestroyMenu(
    HMENU hMenu);
DWORD
CheckMenuItem(
    HMENU hMenu,
    UINT uIDCheckItem,
    UINT uCheck);
BOOL
EnableMenuItem(
    HMENU hMenu,
    UINT uIDEnableItem,
    UINT uEnable);
HMENU
GetSubMenu(
    HMENU hMenu,
    int nPos);
UINT
GetMenuItemID(
    HMENU hMenu,
    int nPos);
int
GetMenuItemCount(
    HMENU hMenu);
BOOL
InsertMenuA(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCSTR lpNewItem);
BOOL
InsertMenuW(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCWSTR lpNewItem);
static const int InsertMenu = InsertMenuA;
BOOL
AppendMenuA(
    HMENU hMenu,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCSTR lpNewItem);
BOOL
AppendMenuW(
    HMENU hMenu,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCWSTR lpNewItem);
static const int AppendMenu = AppendMenuA;
BOOL
ModifyMenuA(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCSTR lpNewItem);
BOOL
ModifyMenuW(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCWSTR lpNewItem);
static const int ModifyMenu = ModifyMenuA;
BOOL
 RemoveMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);
BOOL
DeleteMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);
BOOL
SetMenuItemBitmaps(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    HBITMAP hBitmapUnchecked,
    HBITMAP hBitmapChecked);
LONG
GetMenuCheckMarkDimensions(
    void);
BOOL
TrackPopupMenu(
    HMENU hMenu,
    UINT uFlags,
    int x,
    int y,
    int nReserved,
    HWND hWnd,
    const RECT *prcRect);
/* return codes for WM_MENUCHAR */
static const int MNC_IGNORE = 0;
static const int MNC_CLOSE = 1;
static const int MNC_EXECUTE = 2;
static const int MNC_SELECT = 3;
typedef struct tagTPMPARAMS
{
    UINT cbSize; /* Size of structure */
    RECT rcExclude; /* Screen coordinates of rectangle to exclude when positioning */
} TPMPARAMS;
typedef TPMPARAMS *LPTPMPARAMS;
BOOL
TrackPopupMenuEx(
    HMENU,
    UINT,
    int,
    int,
    HWND,
    LPTPMPARAMS);
BOOL
CalculatePopupWindowPosition(
    const POINT *anchorPoint,
    const SIZE *windowSize,
    UINT /* TPM_XXX values */ flags,
    RECT *excludeRect,
    RECT *popupWindowPosition);
static const int MNS_NOCHECK = 0x80000000;
static const int MNS_MODELESS = 0x40000000;
static const int MNS_DRAGDROP = 0x20000000;
static const int MNS_AUTODISMISS = 0x10000000;
static const int MNS_NOTIFYBYPOS = 0x08000000;
static const int MNS_CHECKORBMP = 0x04000000;
static const int MIM_MAXHEIGHT = 0x00000001;
static const int MIM_BACKGROUND = 0x00000002;
static const int MIM_HELPID = 0x00000004;
static const int MIM_MENUDATA = 0x00000008;
static const int MIM_STYLE = 0x00000010;
static const int MIM_APPLYTOSUBMENUS = 0x80000000;
typedef struct tagMENUINFO
{
    DWORD cbSize;
    DWORD fMask;
    DWORD dwStyle;
    UINT cyMax;
    HBRUSH hbrBack;
    DWORD dwContextHelpID;
    ULONG_PTR dwMenuData;
} MENUINFO, *LPMENUINFO;
typedef MENUINFO const *LPCMENUINFO;
BOOL
GetMenuInfo(
    HMENU,
    LPMENUINFO);
BOOL
SetMenuInfo(
    HMENU,
    LPCMENUINFO);
BOOL
EndMenu(
        void);
/*
 * WM_MENUDRAG return values.
 */
# 6291 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MND_CONTINUE = 0;
static const int MND_ENDMENU = 1;
typedef struct tagMENUGETOBJECTINFO
{
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, * PMENUGETOBJECTINFO;
/*
 * MENUGETOBJECTINFO dwFlags values
 */
# 6306 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MNGOF_TOPGAP = 0x00000001;
static const int MNGOF_BOTTOMGAP = 0x00000002;
/*
 * WM_MENUGETOBJECT return values
 */
# 6312 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MNGO_NOINTERFACE = 0x00000000;
static const int MNGO_NOERROR = 0x00000001;
static const int MIIM_STATE = 0x00000001;
static const int MIIM_ID = 0x00000002;
static const int MIIM_SUBMENU = 0x00000004;
static const int MIIM_CHECKMARKS = 0x00000008;
static const int MIIM_TYPE = 0x00000010;
static const int MIIM_DATA = 0x00000020;
static const int MIIM_STRING = 0x00000040;
static const int MIIM_BITMAP = 0x00000080;
static const int MIIM_FTYPE = 0x00000100;
static const int HBMMENU_CALLBACK = ((HBITMAP) -1);
static const int HBMMENU_SYSTEM = ((HBITMAP) 1);
static const int HBMMENU_MBAR_RESTORE = ((HBITMAP) 2);
static const int HBMMENU_MBAR_MINIMIZE = ((HBITMAP) 3);
static const int HBMMENU_MBAR_CLOSE = ((HBITMAP) 5);
static const int HBMMENU_MBAR_CLOSE_D = ((HBITMAP) 6);
static const int HBMMENU_MBAR_MINIMIZE_D = ((HBITMAP) 7);
static const int HBMMENU_POPUP_CLOSE = ((HBITMAP) 8);
static const int HBMMENU_POPUP_RESTORE = ((HBITMAP) 9);
static const int HBMMENU_POPUP_MAXIMIZE = ((HBITMAP) 10);
static const int HBMMENU_POPUP_MINIMIZE = ((HBITMAP) 11);
typedef struct tagMENUITEMINFOA
{
    UINT cbSize;
    UINT fMask;
    UINT fType; // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT fState; // used if MIIM_STATE
    UINT wID; // used if MIIM_ID
    HMENU hSubMenu; // used if MIIM_SUBMENU
    HBITMAP hbmpChecked; // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData; // used if MIIM_DATA
    LPSTR dwTypeData; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT cch; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    HBITMAP hbmpItem; // used if MIIM_BITMAP
} MENUITEMINFOA, *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT cbSize;
    UINT fMask;
    UINT fType; // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT fState; // used if MIIM_STATE
    UINT wID; // used if MIIM_ID
    HMENU hSubMenu; // used if MIIM_SUBMENU
    HBITMAP hbmpChecked; // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData; // used if MIIM_DATA
    LPWSTR dwTypeData; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT cch; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    HBITMAP hbmpItem; // used if MIIM_BITMAP
} MENUITEMINFOW, *LPMENUITEMINFOW;
typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;
typedef MENUITEMINFOA const *LPCMENUITEMINFOA;
typedef MENUITEMINFOW const *LPCMENUITEMINFOW;
typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
BOOL
InsertMenuItemA(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPCMENUITEMINFOA lpmi);
BOOL
InsertMenuItemW(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPCMENUITEMINFOW lpmi);
static const int InsertMenuItem = InsertMenuItemA;
BOOL
GetMenuItemInfoA(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPMENUITEMINFOA lpmii);
BOOL
GetMenuItemInfoW(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPMENUITEMINFOW lpmii);
static const int GetMenuItemInfo = GetMenuItemInfoA;
BOOL
SetMenuItemInfoA(
    HMENU hmenu,
    UINT item,
    BOOL fByPositon,
    LPCMENUITEMINFOA lpmii);
BOOL
SetMenuItemInfoW(
    HMENU hmenu,
    UINT item,
    BOOL fByPositon,
    LPCMENUITEMINFOW lpmii);
static const int SetMenuItemInfo = SetMenuItemInfoA;
static const long GMDI_USEDISABLED = 0x0001L;
static const long GMDI_GOINTOPOPUPS = 0x0002L;
UINT
GetMenuDefaultItem(
    HMENU hMenu,
    UINT fByPos,
    UINT gmdiFlags);
BOOL
SetMenuDefaultItem(
    HMENU hMenu,
    UINT uItem,
    UINT fByPos);
BOOL
GetMenuItemRect(
    HWND hWnd,
    HMENU hMenu,
    UINT uItem,
    LPRECT lprcItem);
int
MenuItemFromPoint(
    HWND hWnd,
    HMENU hMenu,
    POINT ptScreen);
/*
 * Flags for TrackPopupMenu
 */
# 6501 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long TPM_LEFTBUTTON = 0x0000L;
static const long TPM_RIGHTBUTTON = 0x0002L;
static const long TPM_LEFTALIGN = 0x0000L;
static const long TPM_CENTERALIGN = 0x0004L;
static const long TPM_RIGHTALIGN = 0x0008L;
static const long TPM_TOPALIGN = 0x0000L;
static const long TPM_VCENTERALIGN = 0x0010L;
static const long TPM_BOTTOMALIGN = 0x0020L;
static const long TPM_HORIZONTAL = 0x0000L;
static const long TPM_VERTICAL = 0x0040L;
static const long TPM_NONOTIFY = 0x0080L;
static const long TPM_RETURNCMD = 0x0100L;
static const long TPM_RECURSE = 0x0001L;
static const long TPM_HORPOSANIMATION = 0x0400L;
static const long TPM_HORNEGANIMATION = 0x0800L;
static const long TPM_VERPOSANIMATION = 0x1000L;
static const long TPM_VERNEGANIMATION = 0x2000L;
static const long TPM_NOANIMATION = 0x4000L;
static const long TPM_LAYOUTRTL = 0x8000L;
static const long TPM_WORKAREA = 0x10000L;
//
// Drag-and-drop support
// Obsolete - use OLE instead
//
typedef struct tagDROPSTRUCT
{
    HWND hwndSource;
    HWND hwndSink;
    DWORD wFmt;
    ULONG_PTR dwData;
    POINT ptDrop;
    DWORD dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;
static const int DOF_EXECUTABLE = 0x8001;
static const int DOF_DOCUMENT = 0x8002;
static const int DOF_DIRECTORY = 0x8003;
static const int DOF_MULTIPLE = 0x8004;
static const int DOF_PROGMAN = 0x0001;
static const int DOF_SHELLDATA = 0x0002;
static const long DO_DROPFILE = 0x454C4946L;
static const long DO_PRINTFILE = 0x544E5250L;
DWORD
DragObject(
    HWND hwndParent,
    HWND hwndFrom,
    UINT fmt,
    ULONG_PTR data,
    HCURSOR hcur);
BOOL
DragDetect(
    HWND hwnd,
    POINT pt);
BOOL
DrawIcon(
    HDC hDC,
    int X,
    int Y,
    HICON hIcon);
/*
 * DrawText() Format Flags
 */
# 6594 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int DT_TOP = 0x00000000;
static const int DT_LEFT = 0x00000000;
static const int DT_CENTER = 0x00000001;
static const int DT_RIGHT = 0x00000002;
static const int DT_VCENTER = 0x00000004;
static const int DT_BOTTOM = 0x00000008;
static const int DT_WORDBREAK = 0x00000010;
static const int DT_SINGLELINE = 0x00000020;
static const int DT_EXPANDTABS = 0x00000040;
static const int DT_TABSTOP = 0x00000080;
static const int DT_NOCLIP = 0x00000100;
static const int DT_EXTERNALLEADING = 0x00000200;
static const int DT_CALCRECT = 0x00000400;
static const int DT_NOPREFIX = 0x00000800;
static const int DT_INTERNAL = 0x00001000;
static const int DT_EDITCONTROL = 0x00002000;
static const int DT_PATH_ELLIPSIS = 0x00004000;
static const int DT_END_ELLIPSIS = 0x00008000;
static const int DT_MODIFYSTRING = 0x00010000;
static const int DT_RTLREADING = 0x00020000;
static const int DT_WORD_ELLIPSIS = 0x00040000;
static const int DT_NOFULLWIDTHCHARBREAK = 0x00080000;
static const int DT_HIDEPREFIX = 0x00100000;
static const int DT_PREFIXONLY = 0x00200000;
typedef struct tagDRAWTEXTPARAMS
{
    UINT cbSize;
    int iTabLength;
    int iLeftMargin;
    int iRightMargin;
    UINT uiLengthDrawn;
} DRAWTEXTPARAMS, *LPDRAWTEXTPARAMS;
int
DrawTextA(
    HDC hdc,
    LPCSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format);
int
DrawTextW(
    HDC hdc,
    LPCWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format);
static const int DrawText = DrawTextA;
# 6688 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
int
DrawTextExA(
    HDC hdc,
    LPSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp);
int
DrawTextExW(
    HDC hdc,
    LPWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp);
static const int DrawTextEx = DrawTextExA;
BOOL
GrayStringA(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);
BOOL
GrayStringW(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);
static const int GrayString = GrayStringA;
/* Monolithic state-drawing routine */
/* Image type */
static const int DST_COMPLEX = 0x0000;
static const int DST_TEXT = 0x0001;
static const int DST_PREFIXTEXT = 0x0002;
static const int DST_ICON = 0x0003;
static const int DST_BITMAP = 0x0004;
/* State type */
static const int DSS_NORMAL = 0x0000;
static const int DSS_UNION = 0x0010;
static const int DSS_DISABLED = 0x0020;
static const int DSS_MONO = 0x0080;
static const int DSS_HIDEPREFIX = 0x0200;
static const int DSS_PREFIXONLY = 0x0400;
static const int DSS_RIGHT = 0x8000;
BOOL
DrawStateA(
    HDC hdc,
    HBRUSH hbrFore,
    DRAWSTATEPROC qfnCallBack,
    LPARAM lData,
    WPARAM wData,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);
BOOL
DrawStateW(
    HDC hdc,
    HBRUSH hbrFore,
    DRAWSTATEPROC qfnCallBack,
    LPARAM lData,
    WPARAM wData,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);
static const int DrawState = DrawStateA;
LONG
TabbedTextOutA(
    HDC hdc,
    int x,
    int y,
    LPCSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions,
    int nTabOrigin);
LONG
TabbedTextOutW(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions,
    int nTabOrigin);
static const int TabbedTextOut = TabbedTextOutA;
DWORD
GetTabbedTextExtentA(
    HDC hdc,
    LPCSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions);
DWORD
GetTabbedTextExtentW(
    HDC hdc,
    LPCWSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions);
static const int GetTabbedTextExtent = GetTabbedTextExtentA;
BOOL
UpdateWindow(
    HWND hWnd);
HWND
SetActiveWindow(
    HWND hWnd);
HWND
GetForegroundWindow(
    void);
BOOL
PaintDesktop(
    HDC hdc);
void
SwitchToThisWindow(
    HWND hwnd,
    BOOL fUnknown);
BOOL
SetForegroundWindow(
    HWND hWnd);
BOOL
AllowSetForegroundWindow(
    DWORD dwProcessId);
static const int ASFW_ANY = ((DWORD)-1);
BOOL
LockSetForegroundWindow(
    UINT uLockCode);
static const int LSFW_LOCK = 1;
static const int LSFW_UNLOCK = 2;
HWND
WindowFromDC(
    HDC hDC);
HDC
GetDC(
    HWND hWnd);
HDC
GetDCEx(
    HWND hWnd,
    HRGN hrgnClip,
    DWORD flags);
/*
 * GetDCEx() flags
 */
# 6941 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long DCX_WINDOW = 0x00000001L;
static const long DCX_CACHE = 0x00000002L;
static const long DCX_NORESETATTRS = 0x00000004L;
static const long DCX_CLIPCHILDREN = 0x00000008L;
static const long DCX_CLIPSIBLINGS = 0x00000010L;
static const long DCX_PARENTCLIP = 0x00000020L;
static const long DCX_EXCLUDERGN = 0x00000040L;
static const long DCX_INTERSECTRGN = 0x00000080L;
static const long DCX_EXCLUDEUPDATE = 0x00000100L;
static const long DCX_INTERSECTUPDATE = 0x00000200L;
static const long DCX_LOCKWINDOWUPDATE = 0x00000400L;
static const long DCX_VALIDATE = 0x00200000L;
HDC
GetWindowDC(
    HWND hWnd);
int
ReleaseDC(
    HWND hWnd,
    HDC hDC);
HDC
BeginPaint(
    HWND hWnd,
    LPPAINTSTRUCT lpPaint);
BOOL
EndPaint(
    HWND hWnd,
    const PAINTSTRUCT *lpPaint);
BOOL
GetUpdateRect(
    HWND hWnd,
    LPRECT lpRect,
    BOOL bErase);
int
GetUpdateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);
int
SetWindowRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bRedraw);
int
GetWindowRgn(
    HWND hWnd,
    HRGN hRgn);
int
GetWindowRgnBox(
    HWND hWnd,
    LPRECT lprc);
int
ExcludeUpdateRgn(
    HDC hDC,
    HWND hWnd);
BOOL
InvalidateRect(
    HWND hWnd,
    const RECT *lpRect,
    BOOL bErase);
BOOL
ValidateRect(
    HWND hWnd,
    const RECT *lpRect);
BOOL
InvalidateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);
BOOL
ValidateRgn(
    HWND hWnd,
    HRGN hRgn);
BOOL
RedrawWindow(
    HWND hWnd,
    const RECT *lprcUpdate,
    HRGN hrgnUpdate,
    UINT flags);
/*
 * RedrawWindow() flags
 */
# 7075 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RDW_INVALIDATE = 0x0001;
static const int RDW_INTERNALPAINT = 0x0002;
static const int RDW_ERASE = 0x0004;
static const int RDW_VALIDATE = 0x0008;
static const int RDW_NOINTERNALPAINT = 0x0010;
static const int RDW_NOERASE = 0x0020;
static const int RDW_NOCHILDREN = 0x0040;
static const int RDW_ALLCHILDREN = 0x0080;
static const int RDW_UPDATENOW = 0x0100;
static const int RDW_ERASENOW = 0x0200;
static const int RDW_FRAME = 0x0400;
static const int RDW_NOFRAME = 0x0800;
/*
 * LockWindowUpdate API
 */
# 7097 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
LockWindowUpdate(
    HWND hWndLock);
BOOL
ScrollWindow(
    HWND hWnd,
    int XAmount,
    int YAmount,
    const RECT *lpRect,
    const RECT *lpClipRect);
BOOL
ScrollDC(
    HDC hDC,
    int dx,
    int dy,
    const RECT *lprcScroll,
    const RECT *lprcClip,
    HRGN hrgnUpdate,
    LPRECT lprcUpdate);
int
ScrollWindowEx(
    HWND hWnd,
    int dx,
    int dy,
    const RECT *prcScroll,
    const RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);
static const int SW_SCROLLCHILDREN = 0x0001;
static const int SW_INVALIDATE = 0x0002;
static const int SW_ERASE = 0x0004;
static const int SW_SMOOTHSCROLL = 0x0010;
int
SetScrollPos(
    HWND hWnd,
    int nBar,
    int nPos,
    BOOL bRedraw);
int
GetScrollPos(
    HWND hWnd,
    int nBar);
BOOL
SetScrollRange(
    HWND hWnd,
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw);
BOOL
GetScrollRange(
    HWND hWnd,
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos);
BOOL
ShowScrollBar(
    HWND hWnd,
    int wBar,
    BOOL bShow);
BOOL
EnableScrollBar(
    HWND hWnd,
    UINT wSBflags,
    UINT wArrows);
/*
 * EnableScrollBar() flags
 */
# 7202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ESB_ENABLE_BOTH = 0x0000;
static const int ESB_DISABLE_BOTH = 0x0003;
static const int ESB_DISABLE_LEFT = 0x0001;
static const int ESB_DISABLE_RIGHT = 0x0002;
static const int ESB_DISABLE_UP = 0x0001;
static const int ESB_DISABLE_DOWN = 0x0002;
static const int ESB_DISABLE_LTUP = ESB_DISABLE_LEFT;
static const int ESB_DISABLE_RTDN = ESB_DISABLE_RIGHT;
BOOL
SetPropA(
    HWND hWnd,
    LPCSTR lpString,
    HANDLE hData);
BOOL
SetPropW(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);
static const int SetProp = SetPropA;
HANDLE
GetPropA(
    HWND hWnd,
    LPCSTR lpString);
HANDLE
GetPropW(
    HWND hWnd,
    LPCWSTR lpString);
static const int GetProp = GetPropA;
HANDLE
RemovePropA(
    HWND hWnd,
    LPCSTR lpString);
HANDLE
RemovePropW(
    HWND hWnd,
    LPCWSTR lpString);
static const int RemoveProp = RemovePropA;
int
EnumPropsExA(
    HWND hWnd,
    PROPENUMPROCEXA lpEnumFunc,
    LPARAM lParam);
int
EnumPropsExW(
    HWND hWnd,
    PROPENUMPROCEXW lpEnumFunc,
    LPARAM lParam);
static const int EnumPropsEx = EnumPropsExA;
int
EnumPropsA(
    HWND hWnd,
    PROPENUMPROCA lpEnumFunc);
int
EnumPropsW(
    HWND hWnd,
    PROPENUMPROCW lpEnumFunc);
static const int EnumProps = EnumPropsA;
BOOL
SetWindowTextA(
    HWND hWnd,
    LPCSTR lpString);
BOOL
SetWindowTextW(
    HWND hWnd,
    LPCWSTR lpString);
static const int SetWindowText = SetWindowTextA;
int
GetWindowTextA(
    HWND hWnd,
    LPSTR lpString,
    int nMaxCount);
int
GetWindowTextW(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount);
static const int GetWindowText = GetWindowTextA;
int
GetWindowTextLengthA(
    HWND hWnd);
int
GetWindowTextLengthW(
    HWND hWnd);
static const int GetWindowTextLength = GetWindowTextLengthA;
BOOL
GetClientRect(
    HWND hWnd,
    LPRECT lpRect);
BOOL
GetWindowRect(
    HWND hWnd,
    LPRECT lpRect);
BOOL
AdjustWindowRect(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu);
BOOL
AdjustWindowRectEx(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu,
    DWORD dwExStyle);
static const int HELPINFO_WINDOW = 0x0001;
static const int HELPINFO_MENUITEM = 0x0002;
typedef struct tagHELPINFO /* Structure pointed to by lParam of WM_HELP */
{
    UINT cbSize; /* Size in bytes of this struct  */
    int iContextType; /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int iCtrlId; /* Control Id or a Menu item Id. */
    HANDLE hItemHandle; /* hWnd of control or hMenu.     */
    DWORD_PTR dwContextId; /* Context Id associated with this item */
    POINT MousePos; /* Mouse Position in screen co-ordinates */
} HELPINFO, *LPHELPINFO;
BOOL
SetWindowContextHelpId(
    HWND,
    DWORD);
DWORD
GetWindowContextHelpId(
    HWND);
BOOL
SetMenuContextHelpId(
    HMENU,
    DWORD);
DWORD
GetMenuContextHelpId(
    HMENU);
/*
 * MessageBox() Flags
 */
# 7444 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long MB_OK = 0x00000000L;
static const long MB_OKCANCEL = 0x00000001L;
static const long MB_ABORTRETRYIGNORE = 0x00000002L;
static const long MB_YESNOCANCEL = 0x00000003L;
static const long MB_YESNO = 0x00000004L;
static const long MB_RETRYCANCEL = 0x00000005L;
static const long MB_CANCELTRYCONTINUE = 0x00000006L;
static const long MB_ICONHAND = 0x00000010L;
static const long MB_ICONQUESTION = 0x00000020L;
static const long MB_ICONEXCLAMATION = 0x00000030L;
static const long MB_ICONASTERISK = 0x00000040L;
static const long MB_USERICON = 0x00000080L;
static const int MB_ICONWARNING = MB_ICONEXCLAMATION;
static const int MB_ICONERROR = MB_ICONHAND;
static const int MB_ICONINFORMATION = MB_ICONASTERISK;
static const int MB_ICONSTOP = MB_ICONHAND;
static const long MB_DEFBUTTON1 = 0x00000000L;
static const long MB_DEFBUTTON2 = 0x00000100L;
static const long MB_DEFBUTTON3 = 0x00000200L;
static const long MB_DEFBUTTON4 = 0x00000300L;
static const long MB_APPLMODAL = 0x00000000L;
static const long MB_SYSTEMMODAL = 0x00001000L;
static const long MB_TASKMODAL = 0x00002000L;
static const long MB_HELP = 0x00004000L;
static const long MB_NOFOCUS = 0x00008000L;
static const long MB_SETFOREGROUND = 0x00010000L;
static const long MB_DEFAULT_DESKTOP_ONLY = 0x00020000L;
static const long MB_TOPMOST = 0x00040000L;
static const long MB_RIGHT = 0x00080000L;
static const long MB_RTLREADING = 0x00100000L;
static const long MB_SERVICE_NOTIFICATION = 0x00200000L;
static const long MB_SERVICE_NOTIFICATION_NT3X = 0x00040000L;
static const int MB_TYPEMASK = 0x0000000FL;
static const long MB_ICONMASK = 0x000000F0L;
static const long MB_DEFMASK = 0x00000F00L;
static const long MB_MODEMASK = 0x00003000L;
static const long MB_MISCMASK = 0x0000C000L;
int
MessageBoxA(
    HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType);
int
MessageBoxW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);
static const int MessageBox = MessageBoxA;
# 7555 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
int
MessageBoxExA(
    HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
int
MessageBoxExW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType,
    WORD wLanguageId);
static const int MessageBoxEx = MessageBoxExA;
typedef void ( *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);
typedef struct tagMSGBOXPARAMSA
{
    UINT cbSize;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCSTR lpszText;
    LPCSTR lpszCaption;
    DWORD dwStyle;
    LPCSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT cbSize;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCWSTR lpszText;
    LPCWSTR lpszCaption;
    DWORD dwStyle;
    LPCWSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;
typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;
int
MessageBoxIndirectA(
    const MSGBOXPARAMSA * lpmbp);
int
MessageBoxIndirectW(
    const MSGBOXPARAMSW * lpmbp);
static const int MessageBoxIndirect = MessageBoxIndirectA;
BOOL
MessageBeep(
    UINT uType);
int
ShowCursor(
    BOOL bShow);
BOOL
SetCursorPos(
    int X,
    int Y);
BOOL
SetPhysicalCursorPos(
    int X,
    int Y);
HCURSOR
SetCursor(
    HCURSOR hCursor);
BOOL
GetCursorPos(
    LPPOINT lpPoint);
BOOL
GetPhysicalCursorPos(
    LPPOINT lpPoint);
BOOL
ClipCursor(
    const RECT *lpRect);
BOOL
GetClipCursor(
    LPRECT lpRect);
HCURSOR
GetCursor(
    void);
BOOL
CreateCaret(
    HWND hWnd,
    HBITMAP hBitmap,
    int nWidth,
    int nHeight);
UINT
GetCaretBlinkTime(
    void);
BOOL
SetCaretBlinkTime(
    UINT uMSeconds);
BOOL
DestroyCaret(
    void);
BOOL
HideCaret(
    HWND hWnd);
BOOL
ShowCaret(
    HWND hWnd);
BOOL
SetCaretPos(
    int X,
    int Y);
BOOL
GetCaretPos(
    LPPOINT lpPoint);
BOOL
ClientToScreen(
    HWND hWnd,
    LPPOINT lpPoint);
BOOL
ScreenToClient(
    HWND hWnd,
    LPPOINT lpPoint);
BOOL
LogicalToPhysicalPoint(
    HWND hWnd,
    LPPOINT lpPoint);
BOOL
PhysicalToLogicalPoint(
    HWND hWnd,
    LPPOINT lpPoint);
int
MapWindowPoints(
    HWND hWndFrom,
    HWND hWndTo,
    LPPOINT lpPoints,
    UINT cPoints);
HWND
WindowFromPoint(
    POINT Point);
HWND
WindowFromPhysicalPoint(
    POINT Point);
HWND
ChildWindowFromPoint(
    HWND hWndParent,
    POINT Point);
static const int CWP_ALL = 0x0000;
static const int CWP_SKIPINVISIBLE = 0x0001;
static const int CWP_SKIPDISABLED = 0x0002;
static const int CWP_SKIPTRANSPARENT = 0x0004;
HWND
ChildWindowFromPointEx(
    HWND hwnd,
    POINT pt,
    UINT flags);
/*
 * Color Types
 */
# 7839 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CTLCOLOR_MSGBOX = 0;
static const int CTLCOLOR_EDIT = 1;
static const int CTLCOLOR_LISTBOX = 2;
static const int CTLCOLOR_BTN = 3;
static const int CTLCOLOR_DLG = 4;
static const int CTLCOLOR_SCROLLBAR = 5;
static const int CTLCOLOR_STATIC = 6;
static const int CTLCOLOR_MAX = 7;
static const int COLOR_SCROLLBAR = 0;
static const int COLOR_BACKGROUND = 1;
static const int COLOR_ACTIVECAPTION = 2;
static const int COLOR_INACTIVECAPTION = 3;
static const int COLOR_MENU = 4;
static const int COLOR_WINDOW = 5;
static const int COLOR_WINDOWFRAME = 6;
static const int COLOR_MENUTEXT = 7;
static const int COLOR_WINDOWTEXT = 8;
static const int COLOR_CAPTIONTEXT = 9;
static const int COLOR_ACTIVEBORDER = 10;
static const int COLOR_INACTIVEBORDER = 11;
static const int COLOR_APPWORKSPACE = 12;
static const int COLOR_HIGHLIGHT = 13;
static const int COLOR_HIGHLIGHTTEXT = 14;
static const int COLOR_BTNFACE = 15;
static const int COLOR_BTNSHADOW = 16;
static const int COLOR_GRAYTEXT = 17;
static const int COLOR_BTNTEXT = 18;
static const int COLOR_INACTIVECAPTIONTEXT = 19;
static const int COLOR_BTNHIGHLIGHT = 20;
static const int COLOR_3DDKSHADOW = 21;
static const int COLOR_3DLIGHT = 22;
static const int COLOR_INFOTEXT = 23;
static const int COLOR_INFOBK = 24;
static const int COLOR_HOTLIGHT = 26;
static const int COLOR_GRADIENTACTIVECAPTION = 27;
static const int COLOR_GRADIENTINACTIVECAPTION = 28;
static const int COLOR_MENUHILIGHT = 29;
static const int COLOR_MENUBAR = 30;
static const int COLOR_DESKTOP = COLOR_BACKGROUND;
static const int COLOR_3DFACE = COLOR_BTNFACE;
static const int COLOR_3DSHADOW = COLOR_BTNSHADOW;
static const int COLOR_3DHIGHLIGHT = COLOR_BTNHIGHLIGHT;
static const int COLOR_3DHILIGHT = COLOR_BTNHIGHLIGHT;
static const int COLOR_BTNHILIGHT = COLOR_BTNHIGHLIGHT;
DWORD
GetSysColor(
    int nIndex);
HBRUSH
GetSysColorBrush(
    int nIndex);
BOOL
SetSysColors(
    int cElements,
    const INT * lpaElements,
    const COLORREF * lpaRgbValues);
BOOL
DrawFocusRect(
    HDC hDC,
    const RECT * lprc);
int
FillRect(
    HDC hDC,
    const RECT *lprc,
    HBRUSH hbr);
int
FrameRect(
    HDC hDC,
    const RECT *lprc,
    HBRUSH hbr);
BOOL
InvertRect(
    HDC hDC,
    const RECT *lprc);
BOOL
SetRect(
    LPRECT lprc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom);
BOOL
SetRectEmpty(
    LPRECT lprc);
BOOL
CopyRect(
    LPRECT lprcDst,
    const RECT *lprcSrc);
BOOL
InflateRect(
    LPRECT lprc,
    int dx,
    int dy);
BOOL
IntersectRect(
    LPRECT lprcDst,
    const RECT *lprcSrc1,
    const RECT *lprcSrc2);
BOOL
UnionRect(
    LPRECT lprcDst,
    const RECT *lprcSrc1,
    const RECT *lprcSrc2);
BOOL
SubtractRect(
    LPRECT lprcDst,
    const RECT *lprcSrc1,
    const RECT *lprcSrc2);
BOOL
OffsetRect(
    LPRECT lprc,
    int dx,
    int dy);
BOOL
IsRectEmpty(
    const RECT *lprc);
BOOL
EqualRect(
    const RECT *lprc1,
    const RECT *lprc2);
BOOL
PtInRect(
    const RECT *lprc,
    POINT pt);
WORD
GetWindowWord(
    HWND hWnd,
    int nIndex);
WORD
SetWindowWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);
LONG
GetWindowLongA(
    HWND hWnd,
    int nIndex);
LONG
GetWindowLongW(
    HWND hWnd,
    int nIndex);
static const int GetWindowLong = GetWindowLongA;
LONG
SetWindowLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
LONG
SetWindowLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
static const int SetWindowLong = SetWindowLongA;
LONG_PTR
GetWindowLongPtrA(
    HWND hWnd,
    int nIndex);
LONG_PTR
GetWindowLongPtrW(
    HWND hWnd,
    int nIndex);
static const int GetWindowLongPtr = GetWindowLongPtrA;
LONG_PTR
SetWindowLongPtrA(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);
LONG_PTR
SetWindowLongPtrW(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);
static const int SetWindowLongPtr = SetWindowLongPtrA;
# 8151 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
WORD
GetClassWord(
    HWND hWnd,
    int nIndex);
WORD
SetClassWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);
DWORD
GetClassLongA(
    HWND hWnd,
    int nIndex);
DWORD
GetClassLongW(
    HWND hWnd,
    int nIndex);
static const int GetClassLong = GetClassLongA;
DWORD
SetClassLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
DWORD
SetClassLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);
static const int SetClassLong = SetClassLongA;
ULONG_PTR
GetClassLongPtrA(
    HWND hWnd,
    int nIndex);
ULONG_PTR
GetClassLongPtrW(
    HWND hWnd,
    int nIndex);
static const int GetClassLongPtr = GetClassLongPtrA;
ULONG_PTR
SetClassLongPtrA(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);
ULONG_PTR
SetClassLongPtrW(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);
static const int SetClassLongPtr = SetClassLongPtrA;
# 8267 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
GetProcessDefaultLayout(
    DWORD *pdwDefaultLayout);
BOOL
SetProcessDefaultLayout(
    DWORD dwDefaultLayout);
HWND
GetDesktopWindow(
    void);
HWND
GetParent(
    HWND hWnd);
HWND
SetParent(
    HWND hWndChild,
    HWND hWndNewParent);
BOOL
EnumChildWindows(
    HWND hWndParent,
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);
HWND
FindWindowA(
    LPCSTR lpClassName,
    LPCSTR lpWindowName);
HWND
FindWindowW(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName);
static const int FindWindow = FindWindowA;
HWND
FindWindowExA(
    HWND hWndParent,
    HWND hWndChildAfter,
    LPCSTR lpszClass,
    LPCSTR lpszWindow);
HWND
FindWindowExW(
    HWND hWndParent,
    HWND hWndChildAfter,
    LPCWSTR lpszClass,
    LPCWSTR lpszWindow);
static const int FindWindowEx = FindWindowExA;
HWND
GetShellWindow(
    void);
BOOL
RegisterShellHookWindow(
    HWND hwnd);
BOOL
DeregisterShellHookWindow(
    HWND hwnd);
BOOL
EnumWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);
BOOL
EnumThreadWindows(
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam);
static const int EnumTaskWindows(hTask,lpfn,lParam) = EnumThreadWindows(HandleToUlong(hTask), lpfn, lParam);
int
GetClassNameA(
    HWND hWnd,
    LPSTR lpClassName,
    int nMaxCount
    );
int
GetClassNameW(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount
    );
static const int GetClassName = GetClassNameA;
# 8433 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
HWND
GetTopWindow(
    HWND hWnd);
static const int GetNextWindow(hWnd,wCmd) = GetWindow(hWnd, wCmd);
static const int GetSysModalWindow() = (NULL);
static const int SetSysModalWindow(hWnd) = (NULL);
DWORD
GetWindowThreadProcessId(
    HWND hWnd,
    LPDWORD lpdwProcessId);
BOOL
IsGUIThread(
    BOOL bConvert);
static const int GetWindowTask(hWnd) = ((HANDLE)(DWORD_PTR)GetWindowThreadProcessId(hWnd, NULL));
HWND
GetLastActivePopup(
    HWND hWnd);
/*
 * GetWindow() Constants
 */
# 8472 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GW_HWNDFIRST = 0;
static const int GW_HWNDLAST = 1;
static const int GW_HWNDNEXT = 2;
static const int GW_HWNDPREV = 3;
static const int GW_OWNER = 4;
static const int GW_CHILD = 5;
static const int GW_ENABLEDPOPUP = 6;
static const int GW_MAX = 6;
HWND
GetWindow(
    HWND hWnd,
    UINT uCmd);
HHOOK
SetWindowsHookA(
    int nFilterType,
    HOOKPROC pfnFilterProc);
HHOOK
SetWindowsHookW(
    int nFilterType,
    HOOKPROC pfnFilterProc);
static const int SetWindowsHook = SetWindowsHookA;
# 8537 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
UnhookWindowsHook(
    int nCode,
    HOOKPROC pfnFilterProc);
HHOOK
SetWindowsHookExA(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);
HHOOK
SetWindowsHookExW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);
static const int SetWindowsHookEx = SetWindowsHookExA;
BOOL
UnhookWindowsHookEx(
    HHOOK hhk);
LRESULT
CallNextHookEx(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam);
/*
 * Macros for source-level compatibility with old functions.
 */
# 8585 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int DefHookProc(nCode,wParam,lParam,phhk) = CallNextHookEx(*phhk, nCode, wParam, lParam);
# 8596 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
# 8600 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long MF_INSERT = 0x00000000L;
static const long MF_CHANGE = 0x00000080L;
static const long MF_APPEND = 0x00000100L;
static const long MF_DELETE = 0x00000200L;
static const long MF_REMOVE = 0x00001000L;
static const long MF_BYCOMMAND = 0x00000000L;
static const long MF_BYPOSITION = 0x00000400L;
static const long MF_SEPARATOR = 0x00000800L;
static const long MF_ENABLED = 0x00000000L;
static const long MF_GRAYED = 0x00000001L;
static const long MF_DISABLED = 0x00000002L;
static const long MF_UNCHECKED = 0x00000000L;
static const long MF_CHECKED = 0x00000008L;
static const long MF_USECHECKBITMAPS = 0x00000200L;
static const long MF_STRING = 0x00000000L;
static const long MF_BITMAP = 0x00000004L;
static const long MF_OWNERDRAW = 0x00000100L;
static const long MF_POPUP = 0x00000010L;
static const long MF_MENUBARBREAK = 0x00000020L;
static const long MF_MENUBREAK = 0x00000040L;
static const long MF_UNHILITE = 0x00000000L;
static const long MF_HILITE = 0x00000080L;
static const long MF_DEFAULT = 0x00001000L;
static const long MF_SYSMENU = 0x00002000L;
static const long MF_HELP = 0x00004000L;
static const long MF_RIGHTJUSTIFY = 0x00004000L;
static const long MF_MOUSESELECT = 0x00008000L;
static const long MF_END = 0x00000080L;
static const int MFT_STRING = MF_STRING;
static const int MFT_BITMAP = MF_BITMAP;
static const int MFT_MENUBARBREAK = MF_MENUBARBREAK;
static const int MFT_MENUBREAK = MF_MENUBREAK;
static const int MFT_OWNERDRAW = MF_OWNERDRAW;
static const long MFT_RADIOCHECK = 0x00000200L;
static const int MFT_SEPARATOR = MF_SEPARATOR;
static const long MFT_RIGHTORDER = 0x00002000L;
static const int MFT_RIGHTJUSTIFY = MF_RIGHTJUSTIFY;
/* Menu flags for Add/Check/EnableMenuItem() */
static const long MFS_GRAYED = 0x00000003L;
static const int MFS_DISABLED = MFS_GRAYED;
static const int MFS_CHECKED = MF_CHECKED;
static const int MFS_HILITE = MF_HILITE;
static const int MFS_ENABLED = MF_ENABLED;
static const int MFS_UNCHECKED = MF_UNCHECKED;
static const int MFS_UNHILITE = MF_UNHILITE;
static const int MFS_DEFAULT = MF_DEFAULT;
BOOL
CheckMenuRadioItem(
    HMENU hmenu,
    UINT first,
    UINT last,
    UINT check,
    UINT flags);
/*
 * Menu item resource format
 */
# 8684 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;
typedef struct { // version 0
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;
static const long MF_END = 0x00000080L;
/*
 * System Menu Command Values
 */
# 8703 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SC_SIZE = 0xF000;
static const int SC_MOVE = 0xF010;
static const int SC_MINIMIZE = 0xF020;
static const int SC_MAXIMIZE = 0xF030;
static const int SC_NEXTWINDOW = 0xF040;
static const int SC_PREVWINDOW = 0xF050;
static const int SC_CLOSE = 0xF060;
static const int SC_VSCROLL = 0xF070;
static const int SC_HSCROLL = 0xF080;
static const int SC_MOUSEMENU = 0xF090;
static const int SC_KEYMENU = 0xF100;
static const int SC_ARRANGE = 0xF110;
static const int SC_RESTORE = 0xF120;
static const int SC_TASKLIST = 0xF130;
static const int SC_SCREENSAVE = 0xF140;
static const int SC_HOTKEY = 0xF150;
static const int SC_DEFAULT = 0xF160;
static const int SC_MONITORPOWER = 0xF170;
static const int SC_CONTEXTHELP = 0xF180;
static const double SC_SEPARATOR = 0xF00F;
static const int SCF_ISSECURE = 0x00000001;
static const int GET_SC_WPARAM(wParam) = ((int)wParam & 0xFFF0);
/*
 * Obsolete names
 */
# 8735 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SC_ICON = SC_MINIMIZE;
static const int SC_ZOOM = SC_MAXIMIZE;
/*
 * Resource Loading Routines
 */
# 8744 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
HBITMAP
LoadBitmapA(
    HINSTANCE hInstance,
    LPCSTR lpBitmapName);
HBITMAP
LoadBitmapW(
    HINSTANCE hInstance,
    LPCWSTR lpBitmapName);
static const int LoadBitmap = LoadBitmapA;
HCURSOR
LoadCursorA(
    HINSTANCE hInstance,
    LPCSTR lpCursorName);
HCURSOR
LoadCursorW(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName);
static const int LoadCursor = LoadCursorA;
HCURSOR
LoadCursorFromFileA(
    LPCSTR lpFileName);
HCURSOR
LoadCursorFromFileW(
    LPCWSTR lpFileName);
static const int LoadCursorFromFile = LoadCursorFromFileA;
HCURSOR
CreateCursor(
    HINSTANCE hInst,
    int xHotSpot,
    int yHotSpot,
    int nWidth,
    int nHeight,
    const void *pvANDPlane,
    const void *pvXORPlane);
BOOL
DestroyCursor(
    HCURSOR hCursor);
static const int CopyCursor(pcur) = ((HCURSOR)CopyIcon((HICON)(pcur)));
# 8824 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Standard Cursor IDs
 */
# 8827 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int IDC_ARROW = MAKEINTRESOURCE(32512);
static const int IDC_IBEAM = MAKEINTRESOURCE(32513);
static const int IDC_WAIT = MAKEINTRESOURCE(32514);
static const int IDC_CROSS = MAKEINTRESOURCE(32515);
static const int IDC_UPARROW = MAKEINTRESOURCE(32516);
static const int IDC_SIZE = MAKEINTRESOURCE(32640);
static const int IDC_ICON = MAKEINTRESOURCE(32641);
static const int IDC_SIZENWSE = MAKEINTRESOURCE(32642);
static const int IDC_SIZENESW = MAKEINTRESOURCE(32643);
static const int IDC_SIZEWE = MAKEINTRESOURCE(32644);
static const int IDC_SIZENS = MAKEINTRESOURCE(32645);
static const int IDC_SIZEALL = MAKEINTRESOURCE(32646);
static const int IDC_NO = MAKEINTRESOURCE(32648);
static const int IDC_HAND = MAKEINTRESOURCE(32649);
static const int IDC_APPSTARTING = MAKEINTRESOURCE(32650);
static const int IDC_HELP = MAKEINTRESOURCE(32651);
BOOL
SetSystemCursor(
    HCURSOR hcur,
    DWORD id);
typedef struct _ICONINFO {
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;
HICON
LoadIconA(
    HINSTANCE hInstance,
    LPCSTR lpIconName);
HICON
LoadIconW(
    HINSTANCE hInstance,
    LPCWSTR lpIconName);
static const int LoadIcon = LoadIconA;
UINT
PrivateExtractIconsA(
    LPCSTR szFileName,
    int nIconIndex,
    int cxIcon,
    int cyIcon,
    HICON *phicon,
    UINT *piconid,
    UINT nIcons,
    UINT flags);
UINT
PrivateExtractIconsW(
    LPCWSTR szFileName,
    int nIconIndex,
    int cxIcon,
    int cyIcon,
    HICON *phicon,
    UINT *piconid,
    UINT nIcons,
    UINT flags);
static const int PrivateExtractIcons = PrivateExtractIconsA;
HICON
CreateIcon(
    HINSTANCE hInstance,
    int nWidth,
    int nHeight,
    BYTE cPlanes,
    BYTE cBitsPixel,
    const BYTE *lpbANDbits,
    const BYTE *lpbXORbits);
BOOL
DestroyIcon(
    HICON hIcon);
int
LookupIconIdFromDirectory(
    PBYTE presbits,
    BOOL fIcon);
int
LookupIconIdFromDirectoryEx(
    PBYTE presbits,
    BOOL fIcon,
    int cxDesired,
    int cyDesired,
    UINT Flags);
HICON
CreateIconFromResource(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL fIcon,
    DWORD dwVer);
HICON
CreateIconFromResourceEx(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL fIcon,
    DWORD dwVer,
    int cxDesired,
    int cyDesired,
    UINT Flags);
/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE, *LPCURSORSHAPE;
static const int IMAGE_BITMAP = 0;
static const int IMAGE_ICON = 1;
static const int IMAGE_CURSOR = 2;
static const int IMAGE_ENHMETAFILE = 3;
static const int LR_DEFAULTCOLOR = 0x00000000;
static const int LR_MONOCHROME = 0x00000001;
static const int LR_COLOR = 0x00000002;
static const int LR_COPYRETURNORG = 0x00000004;
static const int LR_COPYDELETEORG = 0x00000008;
static const int LR_LOADFROMFILE = 0x00000010;
static const int LR_LOADTRANSPARENT = 0x00000020;
static const int LR_DEFAULTSIZE = 0x00000040;
static const int LR_VGACOLOR = 0x00000080;
static const int LR_LOADMAP3DCOLORS = 0x00001000;
static const int LR_CREATEDIBSECTION = 0x00002000;
static const int LR_COPYFROMRESOURCE = 0x00004000;
static const int LR_SHARED = 0x00008000;
HANDLE
LoadImageA(
    HINSTANCE hInst,
    LPCSTR name,
    UINT type,
    int cx,
    int cy,
    UINT fuLoad);
HANDLE
LoadImageW(
    HINSTANCE hInst,
    LPCWSTR name,
    UINT type,
    int cx,
    int cy,
    UINT fuLoad);
static const int LoadImage = LoadImageA;
HANDLE
CopyImage(
    HANDLE h,
    UINT type,
    int cx,
    int cy,
    UINT flags);
static const int DI_MASK = 0x0001;
static const int DI_IMAGE = 0x0002;
static const int DI_NORMAL = 0x0003;
static const int DI_COMPAT = 0x0004;
static const int DI_DEFAULTSIZE = 0x0008;
static const int DI_NOMIRROR = 0x0010;
 BOOL DrawIconEx(
    HDC hdc,
    int xLeft,
    int yTop,
    HICON hIcon,
    int cxWidth,
    int cyWidth,
    UINT istepIfAniCur,
    HBRUSH hbrFlickerFreeDraw,
    UINT diFlags);
HICON
CreateIconIndirect(
    PICONINFO piconinfo);
HICON
CopyIcon(
    HICON hIcon);
BOOL
GetIconInfo(
    HICON hIcon,
    PICONINFO piconinfo);
typedef struct _ICONINFOEXA {
    DWORD cbSize;
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD wResID;
    CHAR szModName[260];
    CHAR szResName[260];
} ICONINFOEXA, *PICONINFOEXA;
typedef struct _ICONINFOEXW {
    DWORD cbSize;
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD wResID;
    WCHAR szModName[260];
    WCHAR szResName[260];
} ICONINFOEXW, *PICONINFOEXW;
typedef ICONINFOEXA ICONINFOEX;
typedef PICONINFOEXA PICONINFOEX;
BOOL
GetIconInfoExA(
    HICON hicon,
    PICONINFOEXA piconinfo);
BOOL
GetIconInfoExW(
    HICON hicon,
    PICONINFOEXW piconinfo);
static const int GetIconInfoEx = GetIconInfoExA;
static const int RES_ICON = 1;
static const int RES_CURSOR = 2;
# 9221 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ORD_LANGDRIVER = 1;
/*
 * Standard Icon IDs
 */
# 9243 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int IDI_APPLICATION = MAKEINTRESOURCE(32512);
static const int IDI_HAND = MAKEINTRESOURCE(32513);
static const int IDI_QUESTION = MAKEINTRESOURCE(32514);
static const int IDI_EXCLAMATION = MAKEINTRESOURCE(32515);
static const int IDI_ASTERISK = MAKEINTRESOURCE(32516);
static const int IDI_WINLOGO = MAKEINTRESOURCE(32517);
static const int IDI_SHIELD = MAKEINTRESOURCE(32518);
static const int IDI_WARNING = IDI_EXCLAMATION;
static const int IDI_ERROR = IDI_HAND;
static const int IDI_INFORMATION = IDI_ASTERISK;
int
LoadStringA(
    HINSTANCE hInstance,
    UINT uID,
    LPSTR lpBuffer,
    int cchBufferMax);
int
LoadStringW(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int cchBufferMax);
static const int LoadString = LoadStringA;
/*
 * Dialog Box Command IDs
 */
# 9292 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int IDOK = 1;
static const int IDCANCEL = 2;
static const int IDABORT = 3;
static const int IDRETRY = 4;
static const int IDIGNORE = 5;
static const int IDYES = 6;
static const int IDNO = 7;
static const int IDCLOSE = 8;
static const int IDHELP = 9;
static const int IDTRYAGAIN = 10;
static const int IDCONTINUE = 11;
static const int IDTIMEOUT = 32000;
/*
 * Control Manager Structures and Definitions
 */
/*
 * Edit Control Styles
 */
# 9328 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long ES_LEFT = 0x0000L;
static const long ES_CENTER = 0x0001L;
static const long ES_RIGHT = 0x0002L;
static const long ES_MULTILINE = 0x0004L;
static const long ES_UPPERCASE = 0x0008L;
static const long ES_LOWERCASE = 0x0010L;
static const long ES_PASSWORD = 0x0020L;
static const long ES_AUTOVSCROLL = 0x0040L;
static const long ES_AUTOHSCROLL = 0x0080L;
static const long ES_NOHIDESEL = 0x0100L;
static const long ES_OEMCONVERT = 0x0400L;
static const long ES_READONLY = 0x0800L;
static const long ES_WANTRETURN = 0x1000L;
static const long ES_NUMBER = 0x2000L;
/*
 * Edit Control Notification Codes
 */
# 9351 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EN_SETFOCUS = 0x0100;
static const int EN_KILLFOCUS = 0x0200;
static const int EN_CHANGE = 0x0300;
static const int EN_UPDATE = 0x0400;
static const int EN_ERRSPACE = 0x0500;
static const int EN_MAXTEXT = 0x0501;
static const int EN_HSCROLL = 0x0601;
static const int EN_VSCROLL = 0x0602;
static const int EN_ALIGN_LTR_EC = 0x0700;
static const int EN_ALIGN_RTL_EC = 0x0701;
/* Edit control EM_SETMARGIN parameters */
static const int EC_LEFTMARGIN = 0x0001;
static const int EC_RIGHTMARGIN = 0x0002;
static const int EC_USEFONTINFO = 0xffff;
/* wParam of EM_GET/SETIMESTATUS  */
static const int EMSIS_COMPOSITIONSTRING = 0x0001;
/* lParam for EMSIS_COMPOSITIONSTRING  */
static const int EIMES_GETCOMPSTRATONCE = 0x0001;
static const int EIMES_CANCELCOMPSTRINFOCUS = 0x0002;
static const int EIMES_COMPLETECOMPSTRKILLFOCUS = 0x0004;
/*
 * Edit Control Messages
 */
# 9388 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EM_GETSEL = 0x00B0;
static const int EM_SETSEL = 0x00B1;
static const int EM_GETRECT = 0x00B2;
static const int EM_SETRECT = 0x00B3;
static const int EM_SETRECTNP = 0x00B4;
static const int EM_SCROLL = 0x00B5;
static const int EM_LINESCROLL = 0x00B6;
static const int EM_SCROLLCARET = 0x00B7;
static const int EM_GETMODIFY = 0x00B8;
static const int EM_SETMODIFY = 0x00B9;
static const int EM_GETLINECOUNT = 0x00BA;
static const int EM_LINEINDEX = 0x00BB;
static const int EM_SETHANDLE = 0x00BC;
static const int EM_GETHANDLE = 0x00BD;
static const int EM_GETTHUMB = 0x00BE;
static const int EM_LINELENGTH = 0x00C1;
static const int EM_REPLACESEL = 0x00C2;
static const int EM_GETLINE = 0x00C4;
static const int EM_LIMITTEXT = 0x00C5;
static const int EM_CANUNDO = 0x00C6;
static const int EM_UNDO = 0x00C7;
static const int EM_FMTLINES = 0x00C8;
static const int EM_LINEFROMCHAR = 0x00C9;
static const int EM_SETTABSTOPS = 0x00CB;
static const int EM_SETPASSWORDCHAR = 0x00CC;
static const int EM_EMPTYUNDOBUFFER = 0x00CD;
static const int EM_GETFIRSTVISIBLELINE = 0x00CE;
static const int EM_SETREADONLY = 0x00CF;
static const int EM_SETWORDBREAKPROC = 0x00D0;
static const int EM_GETWORDBREAKPROC = 0x00D1;
static const int EM_GETPASSWORDCHAR = 0x00D2;
static const int EM_SETMARGINS = 0x00D3;
static const int EM_GETMARGINS = 0x00D4;
static const int EM_SETLIMITTEXT = EM_LIMITTEXT;
static const int EM_GETLIMITTEXT = 0x00D5;
static const int EM_POSFROMCHAR = 0x00D6;
static const int EM_CHARFROMPOS = 0x00D7;
static const int EM_SETIMESTATUS = 0x00D8;
static const int EM_GETIMESTATUS = 0x00D9;
/*
 * EDITWORDBREAKPROC code values
 */
# 9439 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WB_LEFT = 0;
static const int WB_RIGHT = 1;
static const int WB_ISDELIMITER = 2;
/*
 * Button Control Styles
 */
# 9447 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long BS_PUSHBUTTON = 0x00000000L;
static const long BS_DEFPUSHBUTTON = 0x00000001L;
static const long BS_CHECKBOX = 0x00000002L;
static const long BS_AUTOCHECKBOX = 0x00000003L;
static const long BS_RADIOBUTTON = 0x00000004L;
static const long BS_3STATE = 0x00000005L;
static const long BS_AUTO3STATE = 0x00000006L;
static const long BS_GROUPBOX = 0x00000007L;
static const long BS_USERBUTTON = 0x00000008L;
static const long BS_AUTORADIOBUTTON = 0x00000009L;
static const int BS_PUSHBOX = 0x0000000AL;
static const int BS_OWNERDRAW = 0x0000000BL;
static const int BS_TYPEMASK = 0x0000000FL;
static const long BS_LEFTTEXT = 0x00000020L;
static const long BS_TEXT = 0x00000000L;
static const long BS_ICON = 0x00000040L;
static const long BS_BITMAP = 0x00000080L;
static const long BS_LEFT = 0x00000100L;
static const long BS_RIGHT = 0x00000200L;
static const long BS_CENTER = 0x00000300L;
static const long BS_TOP = 0x00000400L;
static const long BS_BOTTOM = 0x00000800L;
static const long BS_VCENTER = 0x00000C00L;
static const long BS_PUSHLIKE = 0x00001000L;
static const long BS_MULTILINE = 0x00002000L;
static const long BS_NOTIFY = 0x00004000L;
static const long BS_FLAT = 0x00008000L;
static const int BS_RIGHTBUTTON = BS_LEFTTEXT;
/*
 * User Button Notification Codes
 */
# 9481 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int BN_CLICKED = 0;
static const int BN_PAINT = 1;
static const int BN_HILITE = 2;
static const int BN_UNHILITE = 3;
static const int BN_DISABLE = 4;
static const int BN_DOUBLECLICKED = 5;
static const int BN_PUSHED = BN_HILITE;
static const int BN_UNPUSHED = BN_UNHILITE;
static const int BN_DBLCLK = BN_DOUBLECLICKED;
static const int BN_SETFOCUS = 6;
static const int BN_KILLFOCUS = 7;
/*
 * Button Control Messages
 */
# 9498 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int BM_GETCHECK = 0x00F0;
static const int BM_SETCHECK = 0x00F1;
static const int BM_GETSTATE = 0x00F2;
static const int BM_SETSTATE = 0x00F3;
static const int BM_SETSTYLE = 0x00F4;
static const int BM_CLICK = 0x00F5;
static const int BM_GETIMAGE = 0x00F6;
static const int BM_SETIMAGE = 0x00F7;
static const int BM_SETDONTCLICK = 0x00F8;
static const int BST_UNCHECKED = 0x0000;
static const int BST_CHECKED = 0x0001;
static const int BST_INDETERMINATE = 0x0002;
static const int BST_PUSHED = 0x0004;
static const int BST_FOCUS = 0x0008;
/*
 * Static Control Constants
 */
# 9523 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long SS_LEFT = 0x00000000L;
static const long SS_CENTER = 0x00000001L;
static const long SS_RIGHT = 0x00000002L;
static const long SS_ICON = 0x00000003L;
static const long SS_BLACKRECT = 0x00000004L;
static const long SS_GRAYRECT = 0x00000005L;
static const long SS_WHITERECT = 0x00000006L;
static const long SS_BLACKFRAME = 0x00000007L;
static const long SS_GRAYFRAME = 0x00000008L;
static const long SS_WHITEFRAME = 0x00000009L;
static const int SS_USERITEM = 0x0000000AL;
static const int SS_SIMPLE = 0x0000000BL;
static const int SS_LEFTNOWORDWRAP = 0x0000000CL;
static const long double SS_OWNERDRAW = 0x0000000DL;
static const int SS_BITMAP = 0x0000000EL;
static const int SS_ENHMETAFILE = 0x0000000FL;
static const long SS_ETCHEDHORZ = 0x00000010L;
static const long SS_ETCHEDVERT = 0x00000011L;
static const long SS_ETCHEDFRAME = 0x00000012L;
static const int SS_TYPEMASK = 0x0000001FL;
static const long SS_REALSIZECONTROL = 0x00000040L;
static const long SS_NOPREFIX = 0x00000080L;
static const long SS_NOTIFY = 0x00000100L;
static const long SS_CENTERIMAGE = 0x00000200L;
static const long SS_RIGHTJUST = 0x00000400L;
static const long SS_REALSIZEIMAGE = 0x00000800L;
static const long SS_SUNKEN = 0x00001000L;
static const long SS_EDITCONTROL = 0x00002000L;
static const long SS_ENDELLIPSIS = 0x00004000L;
static const long SS_PATHELLIPSIS = 0x00008000L;
static const long SS_WORDELLIPSIS = 0x0000C000L;
static const long SS_ELLIPSISMASK = 0x0000C000L;
/*
 * Static Control Mesages
 */
# 9568 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int STM_SETICON = 0x0170;
static const int STM_GETICON = 0x0171;
static const int STM_SETIMAGE = 0x0172;
static const int STM_GETIMAGE = 0x0173;
static const int STN_CLICKED = 0;
static const int STN_DBLCLK = 1;
static const int STN_ENABLE = 2;
static const int STN_DISABLE = 3;
static const int STM_MSGMAX = 0x0174;
/*
 * Dialog window class
 */
# 9584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WC_DIALOG = (MAKEINTATOM(0x8002));
/*
 * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows
 */
# 9589 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int DWL_MSGRESULT = 0;
static const int DWL_DLGPROC = 4;
static const int DWL_USER = 8;
static const int DWLP_MSGRESULT = 0;
static const int DWLP_DLGPROC = DWLP_MSGRESULT + sizeof(LRESULT);
static const int DWLP_USER = DWLP_DLGPROC + sizeof(DLGPROC);
/*
 * Dialog Manager Routines
 */
BOOL
IsDialogMessageA(
    HWND hDlg,
    LPMSG lpMsg);
BOOL
IsDialogMessageW(
    HWND hDlg,
    LPMSG lpMsg);
static const int IsDialogMessage = IsDialogMessageA;
BOOL
MapDialogRect(
    HWND hDlg,
    LPRECT lpRect);
int
DlgDirListA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
int
DlgDirListW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);
static const int DlgDirList = DlgDirListA;
/*
 * DlgDirList, DlgDirListComboBox flags values
 */
# 9665 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int DDL_READWRITE = 0x0000;
static const int DDL_READONLY = 0x0001;
static const int DDL_HIDDEN = 0x0002;
static const int DDL_SYSTEM = 0x0004;
static const int DDL_DIRECTORY = 0x0010;
static const int DDL_ARCHIVE = 0x0020;
static const int DDL_POSTMSGS = 0x2000;
static const int DDL_DRIVES = 0x4000;
static const int DDL_EXCLUSIVE = 0x8000;
BOOL
DlgDirSelectExA(
    HWND hwndDlg,
    LPSTR lpString,
    int chCount,
    int idListBox);
BOOL
DlgDirSelectExW(
    HWND hwndDlg,
    LPWSTR lpString,
    int chCount,
    int idListBox);
static const int DlgDirSelectEx = DlgDirSelectExA;
int
DlgDirListComboBoxA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
int
DlgDirListComboBoxW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);
static const int DlgDirListComboBox = DlgDirListComboBoxA;
BOOL
DlgDirSelectComboBoxExA(
    HWND hwndDlg,
    LPSTR lpString,
    int cchOut,
    int idComboBox);
BOOL
DlgDirSelectComboBoxExW(
    HWND hwndDlg,
    LPWSTR lpString,
    int cchOut,
    int idComboBox);
static const int DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
/*
 * Dialog Styles
 */
# 9749 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long DS_ABSALIGN = 0x01L;
static const long DS_SYSMODAL = 0x02L;
static const long DS_LOCALEDIT = 0x20L;
static const long DS_SETFONT = 0x40L;
static const long DS_MODALFRAME = 0x80L;
static const long DS_NOIDLEMSG = 0x100L;
static const long DS_SETFOREGROUND = 0x200L;
static const long DS_3DLOOK = 0x0004L;
static const long DS_FIXEDSYS = 0x0008L;
static const long DS_NOFAILCREATE = 0x0010L;
static const long DS_CONTROL = 0x0400L;
static const long DS_CENTER = 0x0800L;
static const long DS_CENTERMOUSE = 0x1000L;
static const long DS_CONTEXTHELP = 0x2000L;
static const int DS_SHELLFONT = (DS_SETFONT | DS_FIXEDSYS);
static const int DM_GETDEFID = (WM_USER+0);
static const int DM_SETDEFID = (WM_USER+1);
static const int DM_REPOSITION = (WM_USER+2);
/*
 * Returned in HIWORD() of DM_GETDEFID result if msg is supported
 */
# 9784 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int DC_HASDEFID = 0x534B;
/*
 * Dialog Codes
 */
# 9789 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int DLGC_WANTARROWS = 0x0001;
static const int DLGC_WANTTAB = 0x0002;
static const int DLGC_WANTALLKEYS = 0x0004;
static const int DLGC_WANTMESSAGE = 0x0004;
static const int DLGC_HASSETSEL = 0x0008;
static const int DLGC_DEFPUSHBUTTON = 0x0010;
static const int DLGC_UNDEFPUSHBUTTON = 0x0020;
static const int DLGC_RADIOBUTTON = 0x0040;
static const int DLGC_WANTCHARS = 0x0080;
static const int DLGC_STATIC = 0x0100;
static const int DLGC_BUTTON = 0x2000;
static const long LB_CTLCODE = 0L;
/*
 * Listbox Return Values
 */
# 9806 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int LB_OKAY = 0;
static const int LB_ERR = (-1);
static const int LB_ERRSPACE = (-2);
/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
# 9815 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
                                  /* all other details also will be returned */
/*
 * Listbox Notification Codes
 */
# 9821 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int LBN_ERRSPACE = (-2);
static const int LBN_SELCHANGE = 1;
static const int LBN_DBLCLK = 2;
static const int LBN_SELCANCEL = 3;
static const int LBN_SETFOCUS = 4;
static const int LBN_KILLFOCUS = 5;
/*
 * Listbox messages
 */
# 9835 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int LB_ADDSTRING = 0x0180;
static const int LB_INSERTSTRING = 0x0181;
static const int LB_DELETESTRING = 0x0182;
static const int LB_SELITEMRANGEEX = 0x0183;
static const int LB_RESETCONTENT = 0x0184;
static const int LB_SETSEL = 0x0185;
static const int LB_SETCURSEL = 0x0186;
static const int LB_GETSEL = 0x0187;
static const int LB_GETCURSEL = 0x0188;
static const int LB_GETTEXT = 0x0189;
static const int LB_GETTEXTLEN = 0x018A;
static const int LB_GETCOUNT = 0x018B;
static const int LB_SELECTSTRING = 0x018C;
static const int LB_DIR = 0x018D;
static const int LB_GETTOPINDEX = 0x018E;
static const double LB_FINDSTRING = 0x018F;
static const int LB_GETSELCOUNT = 0x0190;
static const int LB_GETSELITEMS = 0x0191;
static const int LB_SETTABSTOPS = 0x0192;
static const int LB_GETHORIZONTALEXTENT = 0x0193;
static const int LB_SETHORIZONTALEXTENT = 0x0194;
static const int LB_SETCOLUMNWIDTH = 0x0195;
static const int LB_ADDFILE = 0x0196;
static const int LB_SETTOPINDEX = 0x0197;
static const int LB_GETITEMRECT = 0x0198;
static const int LB_GETITEMDATA = 0x0199;
static const int LB_SETITEMDATA = 0x019A;
static const int LB_SELITEMRANGE = 0x019B;
static const int LB_SETANCHORINDEX = 0x019C;
static const int LB_GETANCHORINDEX = 0x019D;
static const int LB_SETCARETINDEX = 0x019E;
static const double LB_GETCARETINDEX = 0x019F;
static const int LB_SETITEMHEIGHT = 0x01A0;
static const int LB_GETITEMHEIGHT = 0x01A1;
static const int LB_FINDSTRINGEXACT = 0x01A2;
static const int LB_SETLOCALE = 0x01A5;
static const int LB_GETLOCALE = 0x01A6;
static const int LB_SETCOUNT = 0x01A7;
static const int LB_INITSTORAGE = 0x01A8;
static const int LB_ITEMFROMPOINT = 0x01A9;
static const int LB_GETLISTBOXINFO = 0x01B2;
static const int LB_MSGMAX = 0x01B3;
# 9901 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Listbox Styles
 */
# 9904 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long LBS_NOTIFY = 0x0001L;
static const long LBS_SORT = 0x0002L;
static const long LBS_NOREDRAW = 0x0004L;
static const long LBS_MULTIPLESEL = 0x0008L;
static const long LBS_OWNERDRAWFIXED = 0x0010L;
static const long LBS_OWNERDRAWVARIABLE = 0x0020L;
static const long LBS_HASSTRINGS = 0x0040L;
static const long LBS_USETABSTOPS = 0x0080L;
static const long LBS_NOINTEGRALHEIGHT = 0x0100L;
static const long LBS_MULTICOLUMN = 0x0200L;
static const long LBS_WANTKEYBOARDINPUT = 0x0400L;
static const long LBS_EXTENDEDSEL = 0x0800L;
static const long LBS_DISABLENOSCROLL = 0x1000L;
static const long LBS_NODATA = 0x2000L;
static const long LBS_NOSEL = 0x4000L;
static const long LBS_COMBOBOX = 0x8000L;
static const int LBS_STANDARD = (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER);
/*
 * Combo Box return Values
 */
# 9932 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CB_OKAY = 0;
static const int CB_ERR = (-1);
static const int CB_ERRSPACE = (-2);
/*
 * Combo Box Notification Codes
 */
# 9940 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CBN_ERRSPACE = (-1);
static const int CBN_SELCHANGE = 1;
static const int CBN_DBLCLK = 2;
static const int CBN_SETFOCUS = 3;
static const int CBN_KILLFOCUS = 4;
static const int CBN_EDITCHANGE = 5;
static const int CBN_EDITUPDATE = 6;
static const int CBN_DROPDOWN = 7;
static const int CBN_CLOSEUP = 8;
static const int CBN_SELENDOK = 9;
static const int CBN_SELENDCANCEL = 10;
/*
 * Combo Box styles
 */
# 9957 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long CBS_SIMPLE = 0x0001L;
static const long CBS_DROPDOWN = 0x0002L;
static const long CBS_DROPDOWNLIST = 0x0003L;
static const long CBS_OWNERDRAWFIXED = 0x0010L;
static const long CBS_OWNERDRAWVARIABLE = 0x0020L;
static const long CBS_AUTOHSCROLL = 0x0040L;
static const long CBS_OEMCONVERT = 0x0080L;
static const long CBS_SORT = 0x0100L;
static const long CBS_HASSTRINGS = 0x0200L;
static const long CBS_NOINTEGRALHEIGHT = 0x0400L;
static const long CBS_DISABLENOSCROLL = 0x0800L;
static const long CBS_UPPERCASE = 0x2000L;
static const long CBS_LOWERCASE = 0x4000L;
/*
 * Combo Box messages
 */
# 9980 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CB_GETEDITSEL = 0x0140;
static const int CB_LIMITTEXT = 0x0141;
static const int CB_SETEDITSEL = 0x0142;
static const int CB_ADDSTRING = 0x0143;
static const int CB_DELETESTRING = 0x0144;
static const int CB_DIR = 0x0145;
static const int CB_GETCOUNT = 0x0146;
static const int CB_GETCURSEL = 0x0147;
static const int CB_GETLBTEXT = 0x0148;
static const int CB_GETLBTEXTLEN = 0x0149;
static const int CB_INSERTSTRING = 0x014A;
static const int CB_RESETCONTENT = 0x014B;
static const int CB_FINDSTRING = 0x014C;
static const int CB_SELECTSTRING = 0x014D;
static const int CB_SETCURSEL = 0x014E;
static const double CB_SHOWDROPDOWN = 0x014F;
static const int CB_GETITEMDATA = 0x0150;
static const int CB_SETITEMDATA = 0x0151;
static const int CB_GETDROPPEDCONTROLRECT = 0x0152;
static const int CB_SETITEMHEIGHT = 0x0153;
static const int CB_GETITEMHEIGHT = 0x0154;
static const int CB_SETEXTENDEDUI = 0x0155;
static const int CB_GETEXTENDEDUI = 0x0156;
static const int CB_GETDROPPEDSTATE = 0x0157;
static const int CB_FINDSTRINGEXACT = 0x0158;
static const int CB_SETLOCALE = 0x0159;
static const int CB_GETLOCALE = 0x015A;
static const int CB_GETTOPINDEX = 0x015b;
static const int CB_SETTOPINDEX = 0x015c;
static const int CB_GETHORIZONTALEXTENT = 0x015d;
static const int CB_SETHORIZONTALEXTENT = 0x015e;
static const int CB_GETDROPPEDWIDTH = 0x015f;
static const int CB_SETDROPPEDWIDTH = 0x0160;
static const int CB_INITSTORAGE = 0x0161;
static const int CB_GETCOMBOBOXINFO = 0x0164;
static const int CB_MSGMAX = 0x0165;
# 10040 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Scroll Bar Styles
 */
# 10043 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long SBS_HORZ = 0x0000L;
static const long SBS_VERT = 0x0001L;
static const long SBS_TOPALIGN = 0x0002L;
static const long SBS_LEFTALIGN = 0x0002L;
static const long SBS_BOTTOMALIGN = 0x0004L;
static const long SBS_RIGHTALIGN = 0x0004L;
static const long SBS_SIZEBOXTOPLEFTALIGN = 0x0002L;
static const long SBS_SIZEBOXBOTTOMRIGHTALIGN = 0x0004L;
static const long SBS_SIZEBOX = 0x0008L;
static const long SBS_SIZEGRIP = 0x0010L;
/*
 * Scroll bar messages
 */
# 10063 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SBM_SETPOS = 0x00E0;
static const int SBM_GETPOS = 0x00E1;
static const int SBM_SETRANGE = 0x00E2;
static const int SBM_SETRANGEREDRAW = 0x00E6;
static const int SBM_GETRANGE = 0x00E3;
static const int SBM_ENABLE_ARROWS = 0x00E4;
static const int SBM_SETSCROLLINFO = 0x00E9;
static const int SBM_GETSCROLLINFO = 0x00EA;
static const int SBM_GETSCROLLBARINFO = 0x00EB;
static const int SIF_RANGE = 0x0001;
static const int SIF_PAGE = 0x0002;
static const int SIF_POS = 0x0004;
static const int SIF_DISABLENOSCROLL = 0x0008;
static const int SIF_TRACKPOS = 0x0010;
static const int SIF_ALL = (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS);
typedef struct tagSCROLLINFO
{
    UINT cbSize;
    UINT fMask;
    int nMin;
    int nMax;
    UINT nPage;
    int nPos;
    int nTrackPos;
} SCROLLINFO, *LPSCROLLINFO;
typedef SCROLLINFO const *LPCSCROLLINFO;
int
SetScrollInfo(
    HWND hwnd,
    int nBar,
    LPCSCROLLINFO lpsi,
    BOOL redraw);
BOOL
GetScrollInfo(
    HWND hwnd,
    int nBar,
    LPSCROLLINFO lpsi);
/*
 * MDI client style bits
 */
# 10124 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MDIS_ALLCHILDSTYLES = 0x0001;
/*
 * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.
 */
# 10129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MDITILE_VERTICAL = 0x0000;
static const int MDITILE_HORIZONTAL = 0x0001;
static const int MDITILE_SKIPDISABLED = 0x0002;
static const int MDITILE_ZORDER = 0x0004;
typedef struct tagMDICREATESTRUCTA {
    LPCSTR szClass;
    LPCSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam; /* app-defined stuff */
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR szClass;
    LPCWSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam; /* app-defined stuff */
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;
typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;
typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;
LRESULT
DefFrameProcA(
    HWND hWnd,
    HWND hWndMDIClient,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
LRESULT
DefFrameProcW(
    HWND hWnd,
    HWND hWndMDIClient,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
static const int DefFrameProc = DefFrameProcA;
LRESULT
DefMDIChildProcA(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
LRESULT
DefMDIChildProcW(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
static const int DefMDIChildProc = DefMDIChildProcA;
BOOL
TranslateMDISysAccel(
    HWND hWndClient,
    LPMSG lpMsg);
UINT
ArrangeIconicWindows(
    HWND hWnd);
HWND
CreateMDIWindowA(
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam);
HWND
CreateMDIWindowW(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam);
static const int CreateMDIWindow = CreateMDIWindowA;
WORD
TileWindows(
    HWND hwndParent,
    UINT wHow,
    const RECT * lpRect,
    UINT cKids,
    const HWND * lpKids);
WORD
 CascadeWindows(
    HWND hwndParent,
    UINT wHow,
    const RECT * lpRect,
    UINT cKids,
    const HWND * lpKids);
/****** Help support ********************************************************/
typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {
    DWORD mkSize;
    CHAR mkKeylist;
    CHAR szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {
    DWORD mkSize;
    WCHAR mkKeylist;
    WCHAR szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;
typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;
typedef struct tagHELPWININFOA {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    CHAR rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    WCHAR rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;
typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;
/*
 * Commands to pass to WinHelp()
 */
# 10368 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const long HELP_CONTEXT = 0x0001L;
static const long HELP_QUIT = 0x0002L;
static const long HELP_INDEX = 0x0003L;
static const long HELP_CONTENTS = 0x0003L;
static const long HELP_HELPONHELP = 0x0004L;
static const long HELP_SETINDEX = 0x0005L;
static const long HELP_SETCONTENTS = 0x0005L;
static const long HELP_CONTEXTPOPUP = 0x0008L;
static const long HELP_FORCEFILE = 0x0009L;
static const long HELP_KEY = 0x0101L;
static const long HELP_COMMAND = 0x0102L;
static const long HELP_PARTIALKEY = 0x0105L;
static const long HELP_MULTIKEY = 0x0201L;
static const long HELP_SETWINPOS = 0x0203L;
static const int HELP_CONTEXTMENU = 0x000a;
static const int HELP_FINDER = 0x000b;
static const int HELP_WM_HELP = 0x000c;
static const int HELP_SETPOPUP_POS = 0x000d;
static const int HELP_TCARD = 0x8000;
static const int HELP_TCARD_DATA = 0x0010;
static const int HELP_TCARD_OTHER_CALLER = 0x0011;
// These are in winhelp.h in Win95.
static const int IDH_NO_HELP = 28440;
static const int IDH_MISSING_CONTEXT = 28441;
static const int IDH_GENERIC_HELP_BUTTON = 28442;
static const int IDH_OK = 28443;
static const int IDH_CANCEL = 28444;
static const int IDH_HELP = 28445;
BOOL
WinHelpA(
    HWND hWndMain,
    LPCSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData);
BOOL
WinHelpW(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData);
static const int WinHelp = WinHelpA;
static const int GR_GDIOBJECTS = 0;
static const int GR_USEROBJECTS = 1;
static const int GR_GDIOBJECTS_PEAK = 2;
static const int GR_USEROBJECTS_PEAK = 4;
static const int GR_GLOBAL = ((HANDLE)-2);
DWORD
GetGuiResources(
    HANDLE hProcess,
    DWORD uiFlags);
/*
 * Parameter for SystemParametersInfo.
 */
# 10458 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SPI_GETBEEP = 0x0001;
static const int SPI_SETBEEP = 0x0002;
static const int SPI_GETMOUSE = 0x0003;
static const int SPI_SETMOUSE = 0x0004;
static const int SPI_GETBORDER = 0x0005;
static const int SPI_SETBORDER = 0x0006;
static const int SPI_GETKEYBOARDSPEED = 0x000A;
static const int SPI_SETKEYBOARDSPEED = 0x000B;
static const int SPI_LANGDRIVER = 0x000C;
static const int SPI_ICONHORIZONTALSPACING = 0x000D;
static const int SPI_GETSCREENSAVETIMEOUT = 0x000E;
static const double SPI_SETSCREENSAVETIMEOUT = 0x000F;
static const int SPI_GETSCREENSAVEACTIVE = 0x0010;
static const int SPI_SETSCREENSAVEACTIVE = 0x0011;
static const int SPI_GETGRIDGRANULARITY = 0x0012;
static const int SPI_SETGRIDGRANULARITY = 0x0013;
static const int SPI_SETDESKWALLPAPER = 0x0014;
static const int SPI_SETDESKPATTERN = 0x0015;
static const int SPI_GETKEYBOARDDELAY = 0x0016;
static const int SPI_SETKEYBOARDDELAY = 0x0017;
static const int SPI_ICONVERTICALSPACING = 0x0018;
static const int SPI_GETICONTITLEWRAP = 0x0019;
static const int SPI_SETICONTITLEWRAP = 0x001A;
static const int SPI_GETMENUDROPALIGNMENT = 0x001B;
static const int SPI_SETMENUDROPALIGNMENT = 0x001C;
static const int SPI_SETDOUBLECLKWIDTH = 0x001D;
static const int SPI_SETDOUBLECLKHEIGHT = 0x001E;
static const double SPI_GETICONTITLELOGFONT = 0x001F;
static const int SPI_SETDOUBLECLICKTIME = 0x0020;
static const int SPI_SETMOUSEBUTTONSWAP = 0x0021;
static const int SPI_SETICONTITLELOGFONT = 0x0022;
static const int SPI_GETFASTTASKSWITCH = 0x0023;
static const int SPI_SETFASTTASKSWITCH = 0x0024;
static const int SPI_SETDRAGFULLWINDOWS = 0x0025;
static const int SPI_GETDRAGFULLWINDOWS = 0x0026;
static const int SPI_GETNONCLIENTMETRICS = 0x0029;
static const int SPI_SETNONCLIENTMETRICS = 0x002A;
static const int SPI_GETMINIMIZEDMETRICS = 0x002B;
static const int SPI_SETMINIMIZEDMETRICS = 0x002C;
static const int SPI_GETICONMETRICS = 0x002D;
static const int SPI_SETICONMETRICS = 0x002E;
static const double SPI_SETWORKAREA = 0x002F;
static const int SPI_GETWORKAREA = 0x0030;
static const int SPI_SETPENWINDOWS = 0x0031;
static const int SPI_GETHIGHCONTRAST = 0x0042;
static const int SPI_SETHIGHCONTRAST = 0x0043;
static const int SPI_GETKEYBOARDPREF = 0x0044;
static const int SPI_SETKEYBOARDPREF = 0x0045;
static const int SPI_GETSCREENREADER = 0x0046;
static const int SPI_SETSCREENREADER = 0x0047;
static const int SPI_GETANIMATION = 0x0048;
static const int SPI_SETANIMATION = 0x0049;
static const int SPI_GETFONTSMOOTHING = 0x004A;
static const int SPI_SETFONTSMOOTHING = 0x004B;
static const int SPI_SETDRAGWIDTH = 0x004C;
static const int SPI_SETDRAGHEIGHT = 0x004D;
static const int SPI_SETHANDHELD = 0x004E;
static const double SPI_GETLOWPOWERTIMEOUT = 0x004F;
static const int SPI_GETPOWEROFFTIMEOUT = 0x0050;
static const int SPI_SETLOWPOWERTIMEOUT = 0x0051;
static const int SPI_SETPOWEROFFTIMEOUT = 0x0052;
static const int SPI_GETLOWPOWERACTIVE = 0x0053;
static const int SPI_GETPOWEROFFACTIVE = 0x0054;
static const int SPI_SETLOWPOWERACTIVE = 0x0055;
static const int SPI_SETPOWEROFFACTIVE = 0x0056;
static const int SPI_SETCURSORS = 0x0057;
static const int SPI_SETICONS = 0x0058;
static const int SPI_GETDEFAULTINPUTLANG = 0x0059;
static const int SPI_SETDEFAULTINPUTLANG = 0x005A;
static const int SPI_SETLANGTOGGLE = 0x005B;
static const int SPI_GETWINDOWSEXTENSION = 0x005C;
static const int SPI_SETMOUSETRAILS = 0x005D;
static const int SPI_GETMOUSETRAILS = 0x005E;
static const int SPI_SETSCREENSAVERRUNNING = 0x0061;
static const int SPI_SCREENSAVERRUNNING = SPI_SETSCREENSAVERRUNNING;
static const int SPI_GETFILTERKEYS = 0x0032;
static const int SPI_SETFILTERKEYS = 0x0033;
static const int SPI_GETTOGGLEKEYS = 0x0034;
static const int SPI_SETTOGGLEKEYS = 0x0035;
static const int SPI_GETMOUSEKEYS = 0x0036;
static const int SPI_SETMOUSEKEYS = 0x0037;
static const int SPI_GETSHOWSOUNDS = 0x0038;
static const int SPI_SETSHOWSOUNDS = 0x0039;
static const int SPI_GETSTICKYKEYS = 0x003A;
static const int SPI_SETSTICKYKEYS = 0x003B;
static const int SPI_GETACCESSTIMEOUT = 0x003C;
static const int SPI_SETACCESSTIMEOUT = 0x003D;
static const int SPI_GETSERIALKEYS = 0x003E;
static const double SPI_SETSERIALKEYS = 0x003F;
static const int SPI_GETSOUNDSENTRY = 0x0040;
static const int SPI_SETSOUNDSENTRY = 0x0041;
static const double SPI_GETSNAPTODEFBUTTON = 0x005F;
static const int SPI_SETSNAPTODEFBUTTON = 0x0060;
static const int SPI_GETMOUSEHOVERWIDTH = 0x0062;
static const int SPI_SETMOUSEHOVERWIDTH = 0x0063;
static const int SPI_GETMOUSEHOVERHEIGHT = 0x0064;
static const int SPI_SETMOUSEHOVERHEIGHT = 0x0065;
static const int SPI_GETMOUSEHOVERTIME = 0x0066;
static const int SPI_SETMOUSEHOVERTIME = 0x0067;
static const int SPI_GETWHEELSCROLLLINES = 0x0068;
static const int SPI_SETWHEELSCROLLLINES = 0x0069;
static const int SPI_GETMENUSHOWDELAY = 0x006A;
static const int SPI_SETMENUSHOWDELAY = 0x006B;
static const int SPI_GETWHEELSCROLLCHARS = 0x006C;
static const int SPI_SETWHEELSCROLLCHARS = 0x006D;
static const int SPI_GETSHOWIMEUI = 0x006E;
static const double SPI_SETSHOWIMEUI = 0x006F;
static const int SPI_GETMOUSESPEED = 0x0070;
static const int SPI_SETMOUSESPEED = 0x0071;
static const int SPI_GETSCREENSAVERRUNNING = 0x0072;
static const int SPI_GETDESKWALLPAPER = 0x0073;
static const int SPI_GETAUDIODESCRIPTION = 0x0074;
static const int SPI_SETAUDIODESCRIPTION = 0x0075;
static const int SPI_GETSCREENSAVESECURE = 0x0076;
static const int SPI_SETSCREENSAVESECURE = 0x0077;
static const int SPI_GETHUNGAPPTIMEOUT = 0x0078;
static const int SPI_SETHUNGAPPTIMEOUT = 0x0079;
static const int SPI_GETWAITTOKILLTIMEOUT = 0x007A;
static const int SPI_SETWAITTOKILLTIMEOUT = 0x007B;
static const int SPI_GETWAITTOKILLSERVICETIMEOUT = 0x007C;
static const int SPI_SETWAITTOKILLSERVICETIMEOUT = 0x007D;
static const int SPI_GETMOUSEDOCKTHRESHOLD = 0x007E;
static const double SPI_SETMOUSEDOCKTHRESHOLD = 0x007F;
static const int SPI_GETPENDOCKTHRESHOLD = 0x0080;
static const int SPI_SETPENDOCKTHRESHOLD = 0x0081;
static const int SPI_GETWINARRANGING = 0x0082;
static const int SPI_SETWINARRANGING = 0x0083;
static const int SPI_GETMOUSEDRAGOUTTHRESHOLD = 0x0084;
static const int SPI_SETMOUSEDRAGOUTTHRESHOLD = 0x0085;
static const int SPI_GETPENDRAGOUTTHRESHOLD = 0x0086;
static const int SPI_SETPENDRAGOUTTHRESHOLD = 0x0087;
static const int SPI_GETMOUSESIDEMOVETHRESHOLD = 0x0088;
static const int SPI_SETMOUSESIDEMOVETHRESHOLD = 0x0089;
static const int SPI_GETPENSIDEMOVETHRESHOLD = 0x008A;
static const int SPI_SETPENSIDEMOVETHRESHOLD = 0x008B;
static const int SPI_GETDRAGFROMMAXIMIZE = 0x008C;
static const int SPI_SETDRAGFROMMAXIMIZE = 0x008D;
static const int SPI_GETSNAPSIZING = 0x008E;
static const double SPI_SETSNAPSIZING = 0x008F;
static const int SPI_GETDOCKMOVING = 0x0090;
static const int SPI_SETDOCKMOVING = 0x0091;
static const int SPI_GETACTIVEWINDOWTRACKING = 0x1000;
static const int SPI_SETACTIVEWINDOWTRACKING = 0x1001;
static const int SPI_GETMENUANIMATION = 0x1002;
static const int SPI_SETMENUANIMATION = 0x1003;
static const int SPI_GETCOMBOBOXANIMATION = 0x1004;
static const int SPI_SETCOMBOBOXANIMATION = 0x1005;
static const int SPI_GETLISTBOXSMOOTHSCROLLING = 0x1006;
static const int SPI_SETLISTBOXSMOOTHSCROLLING = 0x1007;
static const int SPI_GETGRADIENTCAPTIONS = 0x1008;
static const int SPI_SETGRADIENTCAPTIONS = 0x1009;
static const int SPI_GETKEYBOARDCUES = 0x100A;
static const int SPI_SETKEYBOARDCUES = 0x100B;
static const int SPI_GETMENUUNDERLINES = SPI_GETKEYBOARDCUES;
static const int SPI_SETMENUUNDERLINES = SPI_SETKEYBOARDCUES;
static const int SPI_GETACTIVEWNDTRKZORDER = 0x100C;
static const int SPI_SETACTIVEWNDTRKZORDER = 0x100D;
static const int SPI_GETHOTTRACKING = 0x100E;
static const double SPI_SETHOTTRACKING = 0x100F;
static const int SPI_GETMENUFADE = 0x1012;
static const int SPI_SETMENUFADE = 0x1013;
static const int SPI_GETSELECTIONFADE = 0x1014;
static const int SPI_SETSELECTIONFADE = 0x1015;
static const int SPI_GETTOOLTIPANIMATION = 0x1016;
static const int SPI_SETTOOLTIPANIMATION = 0x1017;
static const int SPI_GETTOOLTIPFADE = 0x1018;
static const int SPI_SETTOOLTIPFADE = 0x1019;
static const int SPI_GETCURSORSHADOW = 0x101A;
static const int SPI_SETCURSORSHADOW = 0x101B;
static const int SPI_GETMOUSESONAR = 0x101C;
static const int SPI_SETMOUSESONAR = 0x101D;
static const int SPI_GETMOUSECLICKLOCK = 0x101E;
static const double SPI_SETMOUSECLICKLOCK = 0x101F;
static const int SPI_GETMOUSEVANISH = 0x1020;
static const int SPI_SETMOUSEVANISH = 0x1021;
static const int SPI_GETFLATMENU = 0x1022;
static const int SPI_SETFLATMENU = 0x1023;
static const int SPI_GETDROPSHADOW = 0x1024;
static const int SPI_SETDROPSHADOW = 0x1025;
static const int SPI_GETBLOCKSENDINPUTRESETS = 0x1026;
static const int SPI_SETBLOCKSENDINPUTRESETS = 0x1027;
static const int SPI_GETUIEFFECTS = 0x103E;
static const double SPI_SETUIEFFECTS = 0x103F;
static const int SPI_GETDISABLEOVERLAPPEDCONTENT = 0x1040;
static const int SPI_SETDISABLEOVERLAPPEDCONTENT = 0x1041;
static const int SPI_GETCLIENTAREAANIMATION = 0x1042;
static const int SPI_SETCLIENTAREAANIMATION = 0x1043;
static const int SPI_GETCLEARTYPE = 0x1048;
static const int SPI_SETCLEARTYPE = 0x1049;
static const int SPI_GETSPEECHRECOGNITION = 0x104A;
static const int SPI_SETSPEECHRECOGNITION = 0x104B;
static const int SPI_GETFOREGROUNDLOCKTIMEOUT = 0x2000;
static const int SPI_SETFOREGROUNDLOCKTIMEOUT = 0x2001;
static const int SPI_GETACTIVEWNDTRKTIMEOUT = 0x2002;
static const int SPI_SETACTIVEWNDTRKTIMEOUT = 0x2003;
static const int SPI_GETFOREGROUNDFLASHCOUNT = 0x2004;
static const int SPI_SETFOREGROUNDFLASHCOUNT = 0x2005;
static const int SPI_GETCARETWIDTH = 0x2006;
static const int SPI_SETCARETWIDTH = 0x2007;
static const int SPI_GETMOUSECLICKLOCKTIME = 0x2008;
static const int SPI_SETMOUSECLICKLOCKTIME = 0x2009;
static const int SPI_GETFONTSMOOTHINGTYPE = 0x200A;
static const int SPI_SETFONTSMOOTHINGTYPE = 0x200B;
/* constants for SPI_GETFONTSMOOTHINGTYPE and SPI_SETFONTSMOOTHINGTYPE: */
static const int FE_FONTSMOOTHINGSTANDARD = 0x0001;
static const int FE_FONTSMOOTHINGCLEARTYPE = 0x0002;
static const int SPI_GETFONTSMOOTHINGCONTRAST = 0x200C;
static const int SPI_SETFONTSMOOTHINGCONTRAST = 0x200D;
static const int SPI_GETFOCUSBORDERWIDTH = 0x200E;
static const double SPI_SETFOCUSBORDERWIDTH = 0x200F;
static const int SPI_GETFOCUSBORDERHEIGHT = 0x2010;
static const int SPI_SETFOCUSBORDERHEIGHT = 0x2011;
static const int SPI_GETFONTSMOOTHINGORIENTATION = 0x2012;
static const int SPI_SETFONTSMOOTHINGORIENTATION = 0x2013;
/* constants for SPI_GETFONTSMOOTHINGORIENTATION and SPI_SETFONTSMOOTHINGORIENTATION: */
static const int FE_FONTSMOOTHINGORIENTATIONBGR = 0x0000;
static const int FE_FONTSMOOTHINGORIENTATIONRGB = 0x0001;
static const int SPI_GETMINIMUMHITRADIUS = 0x2014;
static const int SPI_SETMINIMUMHITRADIUS = 0x2015;
static const int SPI_GETMESSAGEDURATION = 0x2016;
static const int SPI_SETMESSAGEDURATION = 0x2017;
/*
 * Flags
 */
# 10730 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SPIF_UPDATEINIFILE = 0x0001;
static const int SPIF_SENDWININICHANGE = 0x0002;
static const int SPIF_SENDCHANGE = SPIF_SENDWININICHANGE;
static const int METRICS_USEDEFAULT = -1;
typedef struct tagNONCLIENTMETRICSA
{
    UINT cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
    int iPaddedBorderWidth;
} NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, * LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
    int iPaddedBorderWidth;
} NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, * LPNONCLIENTMETRICSW;
typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;
static const long ARW_BOTTOMLEFT = 0x0000L;
static const long ARW_BOTTOMRIGHT = 0x0001L;
static const long ARW_TOPLEFT = 0x0002L;
static const long ARW_TOPRIGHT = 0x0003L;
static const long ARW_STARTMASK = 0x0003L;
static const long ARW_STARTRIGHT = 0x0001L;
static const long ARW_STARTTOP = 0x0002L;
static const long ARW_LEFT = 0x0000L;
static const long ARW_RIGHT = 0x0000L;
static const long ARW_UP = 0x0004L;
static const long ARW_DOWN = 0x0004L;
static const long ARW_HIDE = 0x0008L;
typedef struct tagMINIMIZEDMETRICS
{
    UINT cbSize;
    int iWidth;
    int iHorzGap;
    int iVertGap;
    int iArrange;
} MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;
typedef struct tagICONMETRICSA
{
    UINT cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTA lfFont;
} ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTW lfFont;
} ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;
typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;
typedef struct tagANIMATIONINFO
{
    UINT cbSize;
    int iMinAnimate;
} ANIMATIONINFO, *LPANIMATIONINFO;
typedef struct tagSERIALKEYSA
{
    UINT cbSize;
    DWORD dwFlags;
    LPSTR lpszActivePort;
    LPSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
} SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR lpszActivePort;
    LPWSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
} SERIALKEYSW, *LPSERIALKEYSW;
typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;
/* flags for SERIALKEYS dwFlags field */
static const int SERKF_SERIALKEYSON = 0x00000001;
static const int SERKF_AVAILABLE = 0x00000002;
static const int SERKF_INDICATOR = 0x00000004;
typedef struct tagHIGHCONTRASTA
{
    UINT cbSize;
    DWORD dwFlags;
    LPSTR lpszDefaultScheme;
} HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR lpszDefaultScheme;
} HIGHCONTRASTW, *LPHIGHCONTRASTW;
typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;
/* flags for HIGHCONTRAST dwFlags field */
static const int HCF_HIGHCONTRASTON = 0x00000001;
static const int HCF_AVAILABLE = 0x00000002;
static const int HCF_HOTKEYACTIVE = 0x00000004;
static const int HCF_CONFIRMHOTKEY = 0x00000008;
static const int HCF_HOTKEYSOUND = 0x00000010;
static const int HCF_INDICATOR = 0x00000020;
static const int HCF_HOTKEYAVAILABLE = 0x00000040;
static const int HCF_LOGONDESKTOP = 0x00000100;
static const int HCF_DEFAULTDESKTOP = 0x00000200;
/* Flags for ChangeDisplaySettings */
static const int CDS_UPDATEREGISTRY = 0x00000001;
static const int CDS_TEST = 0x00000002;
static const int CDS_FULLSCREEN = 0x00000004;
static const int CDS_GLOBAL = 0x00000008;
static const int CDS_SET_PRIMARY = 0x00000010;
static const int CDS_VIDEOPARAMETERS = 0x00000020;
static const int CDS_ENABLE_UNSAFE_MODES = 0x00000100;
static const int CDS_DISABLE_UNSAFE_MODES = 0x00000200;
static const int CDS_RESET = 0x40000000;
static const int CDS_RESET_EX = 0x20000000;
static const int CDS_NORESET = 0x10000000;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/tvout.h" 1
/*++
Copyright (c) Microsoft Corporation. All rights reserved.
*/
# 7 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/tvout.h"
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/tvout.h"
typedef struct _VIDEOPARAMETERS {
    GUID Guid; // GUID for this structure
    ULONG dwOffset; // leave it 0 for now.
    ULONG dwCommand; // VP_COMMAND_*            SET or GET
    ULONG dwFlags; // bitfield, defined below SET or GET
    ULONG dwMode; // bitfield, defined below SET or GET
    ULONG dwTVStandard; // bitfield, defined below SET or GET
    ULONG dwAvailableModes; // bitfield, defined below GET
    ULONG dwAvailableTVStandard; // bitfield, defined below GET
    ULONG dwFlickerFilter; // value                   SET or GET
    ULONG dwOverScanX; // value                   SET or GET
    ULONG dwOverScanY; //                         SET or GET
    ULONG dwMaxUnscaledX; // value                   SET or GET
    ULONG dwMaxUnscaledY; //                         SET or GET
    ULONG dwPositionX; // value                   SET or GET
    ULONG dwPositionY; //                         SET or GET
    ULONG dwBrightness; // value                   SET or GET
    ULONG dwContrast; // value                   SET or GET
    ULONG dwCPType; // copy protection type    SET or GET
    ULONG dwCPCommand; // VP_CP_CMD_
    ULONG dwCPStandard; // what TV standards CP is available on. GET
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits; // (a dword for alignment) SET(bits 0 and 1 valid).
    UCHAR bOEMCopyProtection[256]; // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;
static const int VP_COMMAND_GET = 0x0001;
                                        // returned Flags = 0 if not supported.
static const int VP_COMMAND_SET = 0x0002;
static const int VP_FLAGS_TV_MODE = 0x0001;
static const int VP_FLAGS_TV_STANDARD = 0x0002;
static const int VP_FLAGS_FLICKER = 0x0004;
static const int VP_FLAGS_OVERSCAN = 0x0008;
static const int VP_FLAGS_MAX_UNSCALED = 0x0010;
static const int VP_FLAGS_POSITION = 0x0020;
static const int VP_FLAGS_BRIGHTNESS = 0x0040;
static const int VP_FLAGS_CONTRAST = 0x0080;
static const int VP_FLAGS_COPYPROTECT = 0x0100;
static const int VP_MODE_WIN_GRAPHICS = 0x0001;
static const int VP_MODE_TV_PLAYBACK = 0x0002;
static const int VP_TV_STANDARD_NTSC_M = 0x0001;
static const int VP_TV_STANDARD_NTSC_M_J = 0x0002;
static const int VP_TV_STANDARD_PAL_B = 0x0004;
static const int VP_TV_STANDARD_PAL_D = 0x0008;
static const int VP_TV_STANDARD_PAL_H = 0x0010;
static const int VP_TV_STANDARD_PAL_I = 0x0020;
static const int VP_TV_STANDARD_PAL_M = 0x0040;
static const int VP_TV_STANDARD_PAL_N = 0x0080;
static const int VP_TV_STANDARD_SECAM_B = 0x0100;
static const int VP_TV_STANDARD_SECAM_D = 0x0200;
static const int VP_TV_STANDARD_SECAM_G = 0x0400;
static const int VP_TV_STANDARD_SECAM_H = 0x0800;
static const int VP_TV_STANDARD_SECAM_K = 0x1000;
static const int VP_TV_STANDARD_SECAM_K1 = 0x2000;
static const int VP_TV_STANDARD_SECAM_L = 0x4000;
static const int VP_TV_STANDARD_WIN_VGA = 0x8000;
// and the rest
static const int VP_TV_STANDARD_NTSC_433 = 0x00010000;
static const int VP_TV_STANDARD_PAL_G = 0x00020000;
static const int VP_TV_STANDARD_PAL_60 = 0x00040000;
static const int VP_TV_STANDARD_SECAM_L1 = 0x00080000;
static const int VP_CP_TYPE_APS_TRIGGER = 0x0001;
static const int VP_CP_TYPE_MACROVISION = 0x0002;
static const int VP_CP_CMD_ACTIVATE = 0x0001;
static const int VP_CP_CMD_DEACTIVATE = 0x0002;
static const int VP_CP_CMD_CHANGE = 0x0004;
# 10932 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 2
/* Return values for ChangeDisplaySettings */
static const int DISP_CHANGE_SUCCESSFUL = 0;
static const int DISP_CHANGE_RESTART = 1;
static const int DISP_CHANGE_FAILED = -1;
static const int DISP_CHANGE_BADMODE = -2;
static const int DISP_CHANGE_NOTUPDATED = -3;
static const int DISP_CHANGE_BADFLAGS = -4;
static const int DISP_CHANGE_BADPARAM = -5;
static const int DISP_CHANGE_BADDUALVIEW = -6;
LONG
ChangeDisplaySettingsA(
    DEVMODEA* lpDevMode,
    DWORD dwFlags);
LONG
ChangeDisplaySettingsW(
    DEVMODEW* lpDevMode,
    DWORD dwFlags);
static const int ChangeDisplaySettings = ChangeDisplaySettingsA;
LONG
ChangeDisplaySettingsExA(
    LPCSTR lpszDeviceName,
    DEVMODEA* lpDevMode,
    HWND hwnd,
    DWORD dwflags,
    LPVOID lParam);
LONG
ChangeDisplaySettingsExW(
    LPCWSTR lpszDeviceName,
    DEVMODEW* lpDevMode,
    HWND hwnd,
    DWORD dwflags,
    LPVOID lParam);
static const int ChangeDisplaySettingsEx = ChangeDisplaySettingsExA;
static const int ENUM_CURRENT_SETTINGS = ((DWORD)-1);
static const int ENUM_REGISTRY_SETTINGS = ((DWORD)-2);
BOOL
EnumDisplaySettingsA(
    LPCSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEA* lpDevMode);
BOOL
EnumDisplaySettingsW(
    LPCWSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEW* lpDevMode);
static const int EnumDisplaySettings = EnumDisplaySettingsA;
BOOL
EnumDisplaySettingsExA(
    LPCSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEA* lpDevMode,
    DWORD dwFlags);
BOOL
EnumDisplaySettingsExW(
    LPCWSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEW* lpDevMode,
    DWORD dwFlags);
static const int EnumDisplaySettingsEx = EnumDisplaySettingsExA;
/* Flags for EnumDisplaySettingsEx */
static const int EDS_RAWMODE = 0x00000002;
static const int EDS_ROTATEDMODE = 0x00000004;
BOOL
EnumDisplayDevicesA(
    LPCSTR lpDevice,
    DWORD iDevNum,
    PDISPLAY_DEVICEA lpDisplayDevice,
    DWORD dwFlags);
BOOL
EnumDisplayDevicesW(
    LPCWSTR lpDevice,
    DWORD iDevNum,
    PDISPLAY_DEVICEW lpDisplayDevice,
    DWORD dwFlags);
static const int EnumDisplayDevices = EnumDisplayDevicesA;
/* Flags for EnumDisplayDevices */
static const int EDD_GET_DEVICE_INTERFACE_NAME = 0x00000001;
LONG
GetDisplayConfigBufferSizes(
    UINT32 flags,
    UINT32* numPathArrayElements,
    UINT32* numModeInfoArrayElements);
LONG
SetDisplayConfig(
    UINT32 numPathArrayElements,
    DISPLAYCONFIG_PATH_INFO* pathArray,
    UINT32 numModeInfoArrayElements,
    DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    UINT32 flags);
LONG
QueryDisplayConfig(
    UINT32 flags,
    UINT32* numPathArrayElements,
    DISPLAYCONFIG_PATH_INFO* pathArray,
    UINT32* numModeInfoArrayElements,
    DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);
LONG
DisplayConfigGetDeviceInfo(
    DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);
LONG
DisplayConfigSetDeviceInfo(
    DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);
BOOL
SystemParametersInfoA(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);
BOOL
SystemParametersInfoW(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);
static const int SystemParametersInfo = SystemParametersInfoA;
/*
 * Accessibility support
 */
# 11145 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagFILTERKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec; // Acceptance Delay
    DWORD iDelayMSec; // Delay Until Repeat
    DWORD iRepeatMSec; // Repeat Rate
    DWORD iBounceMSec; // Debounce Time
} FILTERKEYS, *LPFILTERKEYS;
/*
 * FILTERKEYS dwFlags field
 */
# 11158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int FKF_FILTERKEYSON = 0x00000001;
static const int FKF_AVAILABLE = 0x00000002;
static const int FKF_HOTKEYACTIVE = 0x00000004;
static const int FKF_CONFIRMHOTKEY = 0x00000008;
static const int FKF_HOTKEYSOUND = 0x00000010;
static const int FKF_INDICATOR = 0x00000020;
static const int FKF_CLICKON = 0x00000040;
typedef struct tagSTICKYKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;
/*
 * STICKYKEYS dwFlags field
 */
# 11175 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SKF_STICKYKEYSON = 0x00000001;
static const int SKF_AVAILABLE = 0x00000002;
static const int SKF_HOTKEYACTIVE = 0x00000004;
static const int SKF_CONFIRMHOTKEY = 0x00000008;
static const int SKF_HOTKEYSOUND = 0x00000010;
static const int SKF_INDICATOR = 0x00000020;
static const int SKF_AUDIBLEFEEDBACK = 0x00000040;
static const int SKF_TRISTATE = 0x00000080;
static const int SKF_TWOKEYSOFF = 0x00000100;
static const int SKF_LALTLATCHED = 0x10000000;
static const int SKF_LCTLLATCHED = 0x04000000;
static const int SKF_LSHIFTLATCHED = 0x01000000;
static const int SKF_RALTLATCHED = 0x20000000;
static const int SKF_RCTLLATCHED = 0x08000000;
static const int SKF_RSHIFTLATCHED = 0x02000000;
static const int SKF_LWINLATCHED = 0x40000000;
static const int SKF_RWINLATCHED = 0x80000000;
static const int SKF_LALTLOCKED = 0x00100000;
static const int SKF_LCTLLOCKED = 0x00040000;
static const int SKF_LSHIFTLOCKED = 0x00010000;
static const int SKF_RALTLOCKED = 0x00200000;
static const int SKF_RCTLLOCKED = 0x00080000;
static const int SKF_RSHIFTLOCKED = 0x00020000;
static const int SKF_LWINLOCKED = 0x00400000;
static const int SKF_RWINLOCKED = 0x00800000;
typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;
/*
 * MOUSEKEYS dwFlags field
 */
# 11217 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MKF_MOUSEKEYSON = 0x00000001;
static const int MKF_AVAILABLE = 0x00000002;
static const int MKF_HOTKEYACTIVE = 0x00000004;
static const int MKF_CONFIRMHOTKEY = 0x00000008;
static const int MKF_HOTKEYSOUND = 0x00000010;
static const int MKF_INDICATOR = 0x00000020;
static const int MKF_MODIFIERS = 0x00000040;
static const int MKF_REPLACENUMBERS = 0x00000080;
static const int MKF_LEFTBUTTONSEL = 0x10000000;
static const int MKF_RIGHTBUTTONSEL = 0x20000000;
static const int MKF_LEFTBUTTONDOWN = 0x01000000;
static const int MKF_RIGHTBUTTONDOWN = 0x02000000;
static const int MKF_MOUSEMODE = 0x80000000;
typedef struct tagACCESSTIMEOUT
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;
/*
 * ACCESSTIMEOUT dwFlags field
 */
# 11243 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ATF_TIMEOUTON = 0x00000001;
static const int ATF_ONOFFFEEDBACK = 0x00000002;
/* values for SOUNDSENTRY iFSGrafEffect field */
static const int SSGF_NONE = 0;
static const int SSGF_DISPLAY = 3;
/* values for SOUNDSENTRY iFSTextEffect field */
static const int SSTF_NONE = 0;
static const int SSTF_CHARS = 1;
static const int SSTF_BORDER = 2;
static const int SSTF_DISPLAY = 3;
/* values for SOUNDSENTRY iWindowsEffect field */
static const int SSWF_NONE = 0;
static const int SSWF_TITLE = 1;
static const int SSWF_WINDOW = 2;
static const int SSWF_DISPLAY = 3;
static const int SSWF_CUSTOM = 4;
typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;
typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;
/*
 * SOUNDSENTRY dwFlags field
 */
# 11304 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SSF_SOUNDSENTRYON = 0x00000001;
static const int SSF_AVAILABLE = 0x00000002;
static const int SSF_INDICATOR = 0x00000004;
BOOL
SoundSentry(void);
typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;
/*
 * TOGGLEKEYS dwFlags field
 */
# 11324 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int TKF_TOGGLEKEYSON = 0x00000001;
static const int TKF_AVAILABLE = 0x00000002;
static const int TKF_HOTKEYACTIVE = 0x00000004;
static const int TKF_CONFIRMHOTKEY = 0x00000008;
static const int TKF_HOTKEYSOUND = 0x00000010;
static const int TKF_INDICATOR = 0x00000020;
typedef struct tagAUDIODESCRIPTION {
    UINT cbSize; // sizeof(AudioDescriptionType)
    BOOL Enabled; // On/Off
    LCID Locale; // locale ID for language
} AUDIODESCRIPTION, *LPAUDIODESCRIPTION;
/*
 * Set debug level
 */
# 11344 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
void
SetDebugErrorLevel(
    DWORD dwLevel);
/*
 * SetLastErrorEx() types.
 */
# 11354 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SLE_ERROR = 0x00000001;
static const int SLE_MINORERROR = 0x00000002;
static const int SLE_WARNING = 0x00000003;
void
SetLastErrorEx(
    DWORD dwErrCode,
    DWORD dwType);
int
InternalGetWindowText(
    HWND hWnd,
    LPWSTR pString,
    int cchMaxCount);
BOOL
EndTask(
    HWND hWnd,
    BOOL fShutDown,
    BOOL fForce);
BOOL
CancelShutdown(
    void);
/*
 * Multimonitor API.
 */
# 11397 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MONITOR_DEFAULTTONULL = 0x00000000;
static const int MONITOR_DEFAULTTOPRIMARY = 0x00000001;
static const int MONITOR_DEFAULTTONEAREST = 0x00000002;
HMONITOR
MonitorFromPoint(
    POINT pt,
    DWORD dwFlags);
HMONITOR
MonitorFromRect(
    LPCRECT lprc,
    DWORD dwFlags);
HMONITOR
MonitorFromWindow(
    HWND hwnd,
    DWORD dwFlags);
static const int MONITORINFOF_PRIMARY = 0x00000001;
typedef struct tagMONITORINFO
{
    DWORD cbSize;
    RECT rcMonitor;
    RECT rcWork;
    DWORD dwFlags;
} MONITORINFO, *LPMONITORINFO;
# 11453 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMONITORINFOEXA
{
    MONITORINFO;
    CHAR szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW
{
    MONITORINFO;
    WCHAR szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;
typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
BOOL
GetMonitorInfoA(
    HMONITOR hMonitor,
    LPMONITORINFO lpmi);
BOOL
GetMonitorInfoW(
    HMONITOR hMonitor,
    LPMONITORINFO lpmi);
static const int GetMonitorInfo = GetMonitorInfoA;
typedef BOOL (* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);
BOOL
EnumDisplayMonitors(
    HDC hdc,
    LPCRECT lprcClip,
    MONITORENUMPROC lpfnEnum,
    LPARAM dwData);
/*
 * WinEvents - Active Accessibility hooks
 */
# 11508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
void
NotifyWinEvent(
    DWORD event,
    HWND hwnd,
    LONG idObject,
    LONG idChild);
typedef void (* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD event,
    HWND hwnd,
    LONG idObject,
    LONG idChild,
    DWORD idEventThread,
    DWORD dwmsEventTime);
HWINEVENTHOOK
SetWinEventHook(
    DWORD eventMin,
    DWORD eventMax,
    HMODULE hmodWinEventProc,
    WINEVENTPROC pfnWinEventProc,
    DWORD idProcess,
    DWORD idThread,
    DWORD dwFlags);
BOOL
IsWinEventHookInstalled(
    DWORD event);
/*
 * dwFlags for SetWinEventHook
 */
# 11549 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int WINEVENT_OUTOFCONTEXT = 0x0000;
static const int WINEVENT_SKIPOWNTHREAD = 0x0001;
static const int WINEVENT_SKIPOWNPROCESS = 0x0002;
static const int WINEVENT_INCONTEXT = 0x0004;
BOOL
UnhookWinEvent(
    HWINEVENTHOOK hWinEventHook);
/*
 * idObject values for WinEventProc and NotifyWinEvent
 */
# 11564 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * hwnd + idObject can be used with OLEACC.DLL's OleGetObjectFromWindow()
 * to get an interface pointer to the container.  indexChild is the item
 * within the container in question.  Setup a VARIANT with vt VT_I4 and
 * lVal the indexChild and pass that in to all methods.  Then you
 * are raring to go.
 */
# 11573 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Common object IDs (cookies, only for sending WM_GETOBJECT to get at the
 * thing in question).  Positive IDs are reserved for apps (app specific),
 * negative IDs are system things and are global, 0 means "just little old
 * me".
 */
# 11579 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CHILDID_SELF = 0;
static const int INDEXID_OBJECT = 0;
static const int INDEXID_CONTAINER = 0;
/*
 * Reserved IDs for system objects
 */
# 11586 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int OBJID_WINDOW = ((LONG)0x00000000);
static const int OBJID_SYSMENU = ((LONG)0xFFFFFFFF);
static const int OBJID_TITLEBAR = ((LONG)0xFFFFFFFE);
static const int OBJID_MENU = ((LONG)0xFFFFFFFD);
static const int OBJID_CLIENT = ((LONG)0xFFFFFFFC);
static const int OBJID_VSCROLL = ((LONG)0xFFFFFFFB);
static const int OBJID_HSCROLL = ((LONG)0xFFFFFFFA);
static const int OBJID_SIZEGRIP = ((LONG)0xFFFFFFF9);
static const int OBJID_CARET = ((LONG)0xFFFFFFF8);
static const int OBJID_CURSOR = ((LONG)0xFFFFFFF7);
static const int OBJID_ALERT = ((LONG)0xFFFFFFF6);
static const int OBJID_SOUND = ((LONG)0xFFFFFFF5);
static const int OBJID_QUERYCLASSNAMEIDX = ((LONG)0xFFFFFFF4);
static const int OBJID_NATIVEOM = ((LONG)0xFFFFFFF0);
/*
 * EVENT DEFINITION
 */
# 11604 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_MIN = 0x00000001;
static const int EVENT_MAX = 0x7FFFFFFF;
/*
 *  EVENT_SYSTEM_SOUND
 *  Sent when a sound is played.  Currently nothing is generating this, we
 *  this event when a system sound (for menus, etc) is played.  Apps
 *  generate this, if accessible, when a private sound is played.  For
 *  example, if Mail plays a "New Mail" sound.
 *
 *  System Sounds:
 *  (Generated by PlaySoundEvent in USER itself)
 *      hwnd            is NULL
 *      idObject        is OBJID_SOUND
 *      idChild         is sound child ID if one
 *  App Sounds:
 *  (PlaySoundEvent won't generate notification; up to app)
 *      hwnd + idObject gets interface pointer to Sound object
 *      idChild identifies the sound in question
 *  are going to be cleaning up the SOUNDSENTRY feature in the control panel
 *  and will use this at that time.  Applications implementing WinEvents
 *  are perfectly welcome to use it.  Clients of IAccessible* will simply
 *  turn around and get back a non-visual object that describes the sound.
 */
# 11628 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_SOUND = 0x0001;
/*
 * EVENT_SYSTEM_ALERT
 * System Alerts:
 * (Generated by MessageBox() calls for example)
 *      hwnd            is hwndMessageBox
 *      idObject        is OBJID_ALERT
 * App Alerts:
 * (Generated whenever)
 *      hwnd+idObject gets interface pointer to Alert
 */
# 11640 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_ALERT = 0x0002;
/*
 * EVENT_SYSTEM_FOREGROUND
 * Sent when the foreground (active) window changes, even if it is changing
 * to another window in the same thread as the previous one.
 *      hwnd            is hwndNewForeground
 *      idObject        is OBJID_WINDOW
 *      idChild    is INDEXID_OBJECT
 */
# 11650 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_FOREGROUND = 0x0003;
/*
 * Menu
 *      hwnd            is window (top level window or popup menu window)
 *      idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)
 *      idChild         is CHILDID_SELF
 *
 * EVENT_SYSTEM_MENUSTART
 * EVENT_SYSTEM_MENUEND
 * For MENUSTART, hwnd+idObject+idChild refers to the control with the menu bar,
 *  or the control bringing up the context menu.
 *
 * Sent when entering into and leaving from menu mode (system, app bar, and
 * track popups).
 */
# 11666 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_MENUSTART = 0x0004;
static const int EVENT_SYSTEM_MENUEND = 0x0005;
/*
 * EVENT_SYSTEM_MENUPOPUPSTART
 * EVENT_SYSTEM_MENUPOPUPEND
 * Sent when a menu popup comes up and just before it is taken down.  Note
 * that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART
 * followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup
 * being shown.
 *
 * For MENUPOPUP, hwnd+idObject+idChild refers to the NEW popup coming up, not the
 * parent item which is hierarchical.  You can get the parent menu/popup by
 * asking for the accParent object.
 */
# 11681 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_MENUPOPUPSTART = 0x0006;
static const int EVENT_SYSTEM_MENUPOPUPEND = 0x0007;
/*
 * EVENT_SYSTEM_CAPTURESTART
 * EVENT_SYSTEM_CAPTUREEND
 * Sent when a window takes the capture and releases the capture.
 */
# 11690 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_CAPTURESTART = 0x0008;
static const int EVENT_SYSTEM_CAPTUREEND = 0x0009;
/*
 * Move Size
 * EVENT_SYSTEM_MOVESIZESTART
 * EVENT_SYSTEM_MOVESIZEEND
 * Sent when a window enters and leaves move-size dragging mode.
 */
# 11699 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_MOVESIZESTART = 0x000A;
static const int EVENT_SYSTEM_MOVESIZEEND = 0x000B;
/*
 * Context Help
 * EVENT_SYSTEM_CONTEXTHELPSTART
 * EVENT_SYSTEM_CONTEXTHELPEND
 * Sent when a window enters and leaves context sensitive help mode.
 */
# 11708 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_CONTEXTHELPSTART = 0x000C;
static const int EVENT_SYSTEM_CONTEXTHELPEND = 0x000D;
/*
 * Drag & Drop
 * EVENT_SYSTEM_DRAGDROPSTART
 * EVENT_SYSTEM_DRAGDROPEND
 * Send the START notification just before going into drag&drop loop.  Send
 * the END notification just after canceling out.
 * Note that it is up to apps and OLE to generate this, since the system
 * doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this
 * is prevalent.
 */
# 11721 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_DRAGDROPSTART = 0x000E;
static const double EVENT_SYSTEM_DRAGDROPEND = 0x000F;
/*
 * Dialog
 * Send the START notification right after the dialog is completely
 *  initialized and visible.  Send the END right before the dialog
 *  is hidden and goes away.
 * EVENT_SYSTEM_DIALOGSTART
 * EVENT_SYSTEM_DIALOGEND
 */
# 11732 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_DIALOGSTART = 0x0010;
static const int EVENT_SYSTEM_DIALOGEND = 0x0011;
/*
 * EVENT_SYSTEM_SCROLLING
 * EVENT_SYSTEM_SCROLLINGSTART
 * EVENT_SYSTEM_SCROLLINGEND
 * Sent when beginning and ending the tracking of a scrollbar in a window,
 * and also for scrollbar controls.
 */
# 11742 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_SCROLLINGSTART = 0x0012;
static const int EVENT_SYSTEM_SCROLLINGEND = 0x0013;
/*
 * Alt-Tab Window
 * Send the START notification right after the switch window is initialized
 * and visible.  Send the END right before it is hidden and goes away.
 * EVENT_SYSTEM_SWITCHSTART
 * EVENT_SYSTEM_SWITCHEND
 */
# 11752 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_SWITCHSTART = 0x0014;
static const int EVENT_SYSTEM_SWITCHEND = 0x0015;
/*
 * EVENT_SYSTEM_MINIMIZESTART
 * EVENT_SYSTEM_MINIMIZEEND
 * Sent when a window minimizes and just before it restores.
 */
# 11760 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_SYSTEM_MINIMIZESTART = 0x0016;
static const int EVENT_SYSTEM_MINIMIZEEND = 0x0017;
static const int EVENT_SYSTEM_DESKTOPSWITCH = 0x0020;
static const int EVENT_SYSTEM_END = 0x00FF;
static const int EVENT_OEM_DEFINED_START = 0x0101;
static const int EVENT_OEM_DEFINED_END = 0x01FF;
static const int EVENT_UIA_EVENTID_START = 0x4E00;
static const int EVENT_UIA_EVENTID_END = 0x4EFF;
static const int EVENT_UIA_PROPID_START = 0x7500;
static const int EVENT_UIA_PROPID_END = 0x75FF;
static const int EVENT_CONSOLE_CARET = 0x4001;
static const int EVENT_CONSOLE_UPDATE_REGION = 0x4002;
static const int EVENT_CONSOLE_UPDATE_SIMPLE = 0x4003;
static const int EVENT_CONSOLE_UPDATE_SCROLL = 0x4004;
static const int EVENT_CONSOLE_LAYOUT = 0x4005;
static const int EVENT_CONSOLE_START_APPLICATION = 0x4006;
static const int EVENT_CONSOLE_END_APPLICATION = 0x4007;
/*
 * Flags for EVENT_CONSOLE_START/END_APPLICATION.
 */
# 11795 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CONSOLE_APPLICATION_16BIT = 0x0000;
/*
 * Flags for EVENT_CONSOLE_CARET
 */
# 11803 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int CONSOLE_CARET_SELECTION = 0x0001;
static const int CONSOLE_CARET_VISIBLE = 0x0002;
static const int EVENT_CONSOLE_END = 0x40FF;
/*
 * Object events
 *
 * The system AND apps generate these.  The system generates these for
 * real windows.  Apps generate these for objects within their window which
 * act like a separate control, e.g. an item in a list view.
 *
 * When the system generate them, dwParam2 is always WMOBJID_SELF.  When
 * apps generate them, apps put the has-meaning-to-the-app-only ID value
 * in dwParam2.
 * For all events, if you want detailed accessibility information, callers
 * should
 *      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters
 *          of the event, and IID_IAccessible as the REFIID, to get back an
 *          IAccessible* to talk to
 *      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild
 *          parameter of the event.
 *      * If idChild isn't zero, call get_accChild() in the container to see
 *          if the child is an object in its own right.  If so, you will get
 *          back an IDispatch* object for the child.  You should release the
 *          parent, and call QueryInterface() on the child object to get its
 *          IAccessible*.  Then you talk directly to the child.  Otherwise,
 *          if get_accChild() returns you nothing, you should continue to
 *          use the child VARIANT.  You will ask the container for the properties
 *          of the child identified by the VARIANT.  In other words, the
 *          child in this case is accessible but not a full-blown object.
 *          Like a button on a titlebar which is 'small' and has no children.
 */
# 11840 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * For all EVENT_OBJECT events,
 *      hwnd is the dude to Send the WM_GETOBJECT message to (unless NULL,
 *          see above for system things)
 *      idObject is the ID of the object that can resolve any queries a
 *          client might have.  It's a way to deal with windowless controls,
 *          controls that are just drawn on the screen in some larger parent
 *          window (like SDM), or standard frame elements of a window.
 *      idChild is the piece inside of the object that is affected.  This
 *          allows clients to access things that are too small to have full
 *          blown objects in their own right.  Like the thumb of a scrollbar.
 *          The hwnd/idObject pair gets you to the container, the dude you
 *          probably want to talk to most of the time anyway.  The idChild
 *          can then be passed into the acc properties to get the name/value
 *          of it as needed.
 *
 * Example #1:
 *      System propagating a listbox selection change
 *      EVENT_OBJECT_SELECTION
 *          hwnd == listbox hwnd
 *          idObject == OBJID_WINDOW
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing now selected within container.
 *      Word '97 propagating a listbox selection change
 *          hwnd == SDM window
 *          idObject == SDM ID to get at listbox 'control'
 *          idChild == new selected item, or CHILDID_SELF if
 *              nothing
 *
 * Example #2:
 *      System propagating a menu item selection on the menu bar
 *      EVENT_OBJECT_SELECTION
 *          hwnd == top level window
 *          idObject == OBJID_MENU
 *          idChild == ID of child menu bar item selected
 *
 * Example #3:
 *      System propagating a dropdown coming off of said menu bar item
 *      EVENT_OBJECT_CREATE
 *          hwnd == popup item
 *          idObject == OBJID_WINDOW
 *          idChild == CHILDID_SELF
 *
 * Example #4:
 *
 * For EVENT_OBJECT_REORDER, the object referred to by hwnd/idObject is the
 * PARENT container in which the zorder is occurring.  This is because if
 * one child is zordering, all of them are changing their relative zorder.
 */
# 11889 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_OBJECT_CREATE = 0x8000;
static const int EVENT_OBJECT_DESTROY = 0x8001;
static const int EVENT_OBJECT_SHOW = 0x8002;
static const int EVENT_OBJECT_HIDE = 0x8003;
static const int EVENT_OBJECT_REORDER = 0x8004;
/*
 * NOTE:
 * Minimize the number of notifications!
 *
 * When you are hiding a parent object, obviously all child objects are no
 * longer visible on screen.  They still have the same "visible" status,
 * but are not truly visible.  Hence do not send HIDE notifications for the
 * children also.  One implies all.  The same goes for SHOW.
 */
# 11905 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_OBJECT_FOCUS = 0x8005;
static const int EVENT_OBJECT_SELECTION = 0x8006;
static const int EVENT_OBJECT_SELECTIONADD = 0x8007;
static const int EVENT_OBJECT_SELECTIONREMOVE = 0x8008;
static const int EVENT_OBJECT_SELECTIONWITHIN = 0x8009;
/*
 * NOTES:
 * There is only one "focused" child item in a parent.  This is the place
 * keystrokes are going at a given moment.  Hence only send a notification
 * about where the NEW focus is going.  A NEW item getting the focus already
 * implies that the OLD item is losing it.
 *
 * SELECTION however can be multiple.  Hence the different SELECTION
 * notifications.  Here's when to use each:
 *
 * (1) Send a SELECTION notification in the simple single selection
 *     case (like the focus) when the item with the selection is
 *     merely moving to a different item within a container.  hwnd + ID
 *     is the container control, idChildItem is the new child with the
 *     selection.
 *
 * (2) Send a SELECTIONADD notification when a new item has simply been added
 *     to the selection within a container.  This is appropriate when the
 *     number of newly selected items is very small.  hwnd + ID is the
 *     container control, idChildItem is the new child added to the selection.
 *
 * (3) Send a SELECTIONREMOVE notification when a new item has simply been
 *     removed from the selection within a container.  This is appropriate
 *     when the number of newly selected items is very small, just like
 *     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the
 *     new child removed from the selection.
 *
 * (4) Send a SELECTIONWITHIN notification when the selected items within a
 *     control have changed substantially.  Rather than propagate a large
 *     number of changes to reflect removal for some items, addition of
 *     others, just tell somebody who cares that a lot happened.  It will
 *     be faster an easier for somebody watching to just turn around and
 *     query the container control what the new bunch of selected items
 *     are.
 */
# 11947 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_OBJECT_STATECHANGE = 0x800A;
/*
 * Examples of when to send an EVENT_OBJECT_STATECHANGE include
 *      * It is being enabled/disabled (USER does for windows)
 *      * It is being pressed/released (USER does for buttons)
 *      * It is being checked/unchecked (USER does for radio/check buttons)
 */
# 11954 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_OBJECT_LOCATIONCHANGE = 0x800B;
/*
 * Note:
 * A LOCATIONCHANGE is not sent for every child object when the parent
 * changes shape/moves.  Send one notification for the topmost object
 * that is changing.  For example, if the user resizes a top level window,
 * USER will generate a LOCATIONCHANGE for it, but not for the menu bar,
 * title bar, scrollbars, etc.  that are also changing shape/moving.
 *
 * In other words, it only generates LOCATIONCHANGE notifications for
 * real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE
 * for every non-floating child window when the parent moves (the children are
 * logically moving also on screen, but not relative to the parent).
 *
 * Now, if the app itself resizes child windows as a result of being
 * sized, USER will generate LOCATIONCHANGEs for those dudes also because
 * it doesn't know better.
 *
 * Note also that USER will generate LOCATIONCHANGE notifications for two
 * non-window sys objects:
 *      (1) System caret
 *      (2) Cursor
 */
# 11979 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_OBJECT_NAMECHANGE = 0x800C;
static const int EVENT_OBJECT_DESCRIPTIONCHANGE = 0x800D;
static const int EVENT_OBJECT_VALUECHANGE = 0x800E;
static const double EVENT_OBJECT_PARENTCHANGE = 0x800F;
static const int EVENT_OBJECT_HELPCHANGE = 0x8010;
static const int EVENT_OBJECT_DEFACTIONCHANGE = 0x8011;
static const int EVENT_OBJECT_ACCELERATORCHANGE = 0x8012;
static const int EVENT_OBJECT_INVOKED = 0x8013;
static const int EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x8014;
/*
 * EVENT_OBJECT_CONTENTSCROLLED
 * Sent when ending the scrolling of a window object.
 *
 * Unlike the similar event (EVENT_SYSTEM_SCROLLEND), this event will be
 * associated with the scrolling window itself. There is no difference
 * between horizontal or vertical scrolling.
 *
 * This event should be posted whenever scroll action is completed, including
 * when it is scrolled by scroll bars, mouse wheel, or keyboard navigations.
 *
 *   example:
 *          hwnd == window that is scrolling
 *          idObject == OBJID_CLIENT
 *          idChild == CHILDID_SELF
 */
# 12007 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int EVENT_OBJECT_CONTENTSCROLLED = 0x8015;
static const int EVENT_SYSTEM_ARRANGMENTPREVIEW = 0x8016;
static const int EVENT_OBJECT_END = 0x80FF;
static const int EVENT_AIA_START = 0xA000;
static const int EVENT_AIA_END = 0xAFFF;
/*
 * Child IDs
 */
/*
 * System Sounds (idChild of system SOUND notification)
 */
# 12030 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int SOUND_SYSTEM_STARTUP = 1;
static const int SOUND_SYSTEM_SHUTDOWN = 2;
static const int SOUND_SYSTEM_BEEP = 3;
static const int SOUND_SYSTEM_ERROR = 4;
static const int SOUND_SYSTEM_QUESTION = 5;
static const int SOUND_SYSTEM_WARNING = 6;
static const int SOUND_SYSTEM_INFORMATION = 7;
static const int SOUND_SYSTEM_MAXIMIZE = 8;
static const int SOUND_SYSTEM_MINIMIZE = 9;
static const int SOUND_SYSTEM_RESTOREUP = 10;
static const int SOUND_SYSTEM_RESTOREDOWN = 11;
static const int SOUND_SYSTEM_APPSTART = 12;
static const int SOUND_SYSTEM_FAULT = 13;
static const int SOUND_SYSTEM_APPEND = 14;
static const int SOUND_SYSTEM_MENUCOMMAND = 15;
static const int SOUND_SYSTEM_MENUPOPUP = 16;
static const int CSOUND_SYSTEM = 16;
/*
 * System Alerts (indexChild of system ALERT notification)
 */
# 12051 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int ALERT_SYSTEM_INFORMATIONAL = 1;
static const int ALERT_SYSTEM_WARNING = 2;
static const int ALERT_SYSTEM_ERROR = 3;
static const int ALERT_SYSTEM_QUERY = 4;
static const int ALERT_SYSTEM_CRITICAL = 5;
static const int CALERT_SYSTEM = 6;
typedef struct tagGUITHREADINFO
{
    DWORD cbSize;
    DWORD flags;
    HWND hwndActive;
    HWND hwndFocus;
    HWND hwndCapture;
    HWND hwndMenuOwner;
    HWND hwndMoveSize;
    HWND hwndCaret;
    RECT rcCaret;
} GUITHREADINFO, *PGUITHREADINFO, * LPGUITHREADINFO;
static const int GUI_CARETBLINKING = 0x00000001;
static const int GUI_INMOVESIZE = 0x00000002;
static const int GUI_INMENUMODE = 0x00000004;
static const int GUI_SYSTEMMENUMODE = 0x00000008;
static const int GUI_POPUPMENUMODE = 0x00000010;
static const int GUI_16BITTASK = 0x00000000;
BOOL
GetGUIThreadInfo(
    DWORD idThread,
    PGUITHREADINFO pgui);
BOOL
BlockInput(
    BOOL fBlockIt);
static const int USER_DEFAULT_SCREEN_DPI = 96;
BOOL
SetProcessDPIAware(
    void);
BOOL
IsProcessDPIAware(
    void);
UINT
GetWindowModuleFileNameA(
    HWND hwnd,
    LPSTR pszFileName,
    UINT cchFileNameMax);
UINT
GetWindowModuleFileNameW(
    HWND hwnd,
    LPWSTR pszFileName,
    UINT cchFileNameMax);
static const int GetWindowModuleFileName = GetWindowModuleFileNameA;
static const int STATE_SYSTEM_UNAVAILABLE = 0x00000001;
static const int STATE_SYSTEM_SELECTED = 0x00000002;
static const int STATE_SYSTEM_FOCUSED = 0x00000004;
static const int STATE_SYSTEM_PRESSED = 0x00000008;
static const int STATE_SYSTEM_CHECKED = 0x00000010;
static const int STATE_SYSTEM_MIXED = 0x00000020;
static const int STATE_SYSTEM_INDETERMINATE = STATE_SYSTEM_MIXED;
static const int STATE_SYSTEM_READONLY = 0x00000040;
static const int STATE_SYSTEM_HOTTRACKED = 0x00000080;
static const int STATE_SYSTEM_DEFAULT = 0x00000100;
static const int STATE_SYSTEM_EXPANDED = 0x00000200;
static const int STATE_SYSTEM_COLLAPSED = 0x00000400;
static const int STATE_SYSTEM_BUSY = 0x00000800;
static const int STATE_SYSTEM_FLOATING = 0x00001000;
static const int STATE_SYSTEM_MARQUEED = 0x00002000;
static const int STATE_SYSTEM_ANIMATED = 0x00004000;
static const int STATE_SYSTEM_INVISIBLE = 0x00008000;
static const int STATE_SYSTEM_OFFSCREEN = 0x00010000;
static const int STATE_SYSTEM_SIZEABLE = 0x00020000;
static const int STATE_SYSTEM_MOVEABLE = 0x00040000;
static const int STATE_SYSTEM_SELFVOICING = 0x00080000;
static const int STATE_SYSTEM_FOCUSABLE = 0x00100000;
static const int STATE_SYSTEM_SELECTABLE = 0x00200000;
static const int STATE_SYSTEM_LINKED = 0x00400000;
static const int STATE_SYSTEM_TRAVERSED = 0x00800000;
static const int STATE_SYSTEM_MULTISELECTABLE = 0x01000000;
static const int STATE_SYSTEM_EXTSELECTABLE = 0x02000000;
static const int STATE_SYSTEM_ALERT_LOW = 0x04000000;
static const int STATE_SYSTEM_ALERT_MEDIUM = 0x08000000;
static const int STATE_SYSTEM_ALERT_HIGH = 0x10000000;
static const int STATE_SYSTEM_PROTECTED = 0x20000000;
static const int STATE_SYSTEM_VALID = 0x3FFFFFFF;
static const int CCHILDREN_TITLEBAR = 5;
static const int CCHILDREN_SCROLLBAR = 5;
/*
 * Information about the global cursor.
 */
# 12175 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCURSORINFO
{
    DWORD cbSize;
    DWORD flags;
    HCURSOR hCursor;
    POINT ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;
static const int CURSOR_SHOWING = 0x00000001;
BOOL
GetCursorInfo(
    PCURSORINFO pci);
/*
 * Window information snapshot
 */
# 12194 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;
static const int WS_ACTIVECAPTION = 0x0001;
BOOL
GetWindowInfo(
    HWND hwnd,
    PWINDOWINFO pwi);
/*
 * Titlebar information.
 */
# 12220 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;
BOOL
GetTitleBarInfo(
    HWND hwnd,
    PTITLEBARINFO pti);
typedef struct tagTITLEBARINFOEX
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
    RECT rgrect[5 + 1];
} TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;
/*
 * Menubar information
 */
# 12247 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar; // rect of bar, popup, item
    HMENU hMenu; // real menu handle of bar, popup
    HWND hwndMenu; // hwnd of item submenu if one
    BOOL fBarFocused:1; // bar, popup has the focus
    BOOL fFocused:1; // item has the focus
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;
BOOL
GetMenuBarInfo(
    HWND hwnd,
    LONG idObject,
    LONG idItem,
    PMENUBARINFO pmbi);
/*
 * Scrollbar information
 */
# 12269 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[5 + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;
BOOL
GetScrollBarInfo(
    HWND hwnd,
    LONG idObject,
    PSCROLLBARINFO psbi);
/*
 * Combobox information
 */
# 12291 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;
BOOL
GetComboBoxInfo(
    HWND hwndCombo,
    PCOMBOBOXINFO pcbi);
/*
 * The "real" ancestor window
 */
# 12312 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GA_PARENT = 1;
static const int GA_ROOT = 2;
static const int GA_ROOTOWNER = 3;
HWND
GetAncestor(
    HWND hwnd,
    UINT gaFlags);
/*
 * This gets the REAL child window at the point.  If it is in the dead
 * space of a group box, it will try a sibling behind it.  But static
 * fields will get returned.  In other words, it is kind of a cross between
 * ChildWindowFromPointEx and WindowFromPoint.
 */
# 12330 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
HWND
RealChildWindowFromPoint(
    HWND hwndParent,
    POINT ptParentClientCoords);
/*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 */
# 12342 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
UINT
RealGetWindowClassA(
    HWND hwnd,
    LPSTR ptszClassName,
    UINT cchClassNameMax);
/*
 * This gets the name of the window TYPE, not class.  This allows us to
 * recognize ThunderButton32 et al.
 */
# 12353 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
UINT
RealGetWindowClassW(
    HWND hwnd,
    LPWSTR ptszClassName,
    UINT cchClassNameMax);
static const int RealGetWindowClass = RealGetWindowClassA;
/*
 * Alt-Tab Switch window information.
 */
# 12369 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;
BOOL
GetAltTabInfoA(
    HWND hwnd,
    int iItem,
    PALTTABINFO pati,
    LPSTR pszItemText,
    UINT cchItemText);
BOOL
GetAltTabInfoW(
    HWND hwnd,
    int iItem,
    PALTTABINFO pati,
    LPWSTR pszItemText,
    UINT cchItemText);
static const int GetAltTabInfo = GetAltTabInfoA;
/*
 * Listbox information.
 * Returns the number of items per row.
 */
# 12410 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
DWORD
GetListBoxInfo(
    HWND hwnd);
BOOL
LockWorkStation(
    void);
BOOL
UserHandleGrantAccess(
    HANDLE hUserHandle,
    HANDLE hJob,
    BOOL bGrant);
/*
 * Raw Input Messages.
 */
# 12446 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
struct HRAWINPUT__{int unused;}; typedef struct HRAWINPUT__ *HRAWINPUT;
/*
 * WM_INPUT wParam
 */
# 12452 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Use this macro to get the input code from wParam.
 */
# 12455 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GET_RAWINPUT_CODE_WPARAM(wParam) = ((wParam) & 0xff);
/*
 * The input is in the regular message flow,
 * the app is required to call DefWindowProc
 * so that the system can perform clean ups.
 */
# 12462 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RIM_INPUT = 0;
/*
 * The input is sink only. The app is expected
 * to behave nicely.
 */
# 12468 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RIM_INPUTSINK = 1;
/*
 * Raw Input data header
 */
# 12474 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWINPUTHEADER {
    DWORD dwType;
    DWORD dwSize;
    HANDLE hDevice;
    WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;
/*
 * Type of the raw input
 */
# 12484 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RIM_TYPEMOUSE = 0;
static const int RIM_TYPEKEYBOARD = 1;
static const int RIM_TYPEHID = 2;
/*
 * Raw format of the mouse input
 */
# 12491 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWMOUSE {
    /*
     * Indicator flags.
     */
# 12495 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT usFlags;
    /*
     * The transition state of the mouse buttons.
     */
# 12500 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    union {
        ULONG ulButtons;
        struct {
            USHORT usButtonFlags;
            USHORT usButtonData;
        };
    };
    /*
     * The raw state of the mouse buttons.
     */
# 12512 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    ULONG ulRawButtons;
    /*
     * The signed relative or absolute motion in the X direction.
     */
# 12517 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    LONG lLastX;
    /*
     * The signed relative or absolute motion in the Y direction.
     */
# 12522 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    LONG lLastY;
    /*
     * Device-specific additional information for the event.
     */
# 12527 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    ULONG ulExtraInformation;
} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;
/*
 * Define the mouse button state indicators.
 */
# 12535 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RI_MOUSE_LEFT_BUTTON_DOWN = 0x0001;
static const int RI_MOUSE_LEFT_BUTTON_UP = 0x0002;
static const int RI_MOUSE_RIGHT_BUTTON_DOWN = 0x0004;
static const int RI_MOUSE_RIGHT_BUTTON_UP = 0x0008;
static const int RI_MOUSE_MIDDLE_BUTTON_DOWN = 0x0010;
static const int RI_MOUSE_MIDDLE_BUTTON_UP = 0x0020;
static const int RI_MOUSE_BUTTON_1_DOWN = RI_MOUSE_LEFT_BUTTON_DOWN;
static const int RI_MOUSE_BUTTON_1_UP = RI_MOUSE_LEFT_BUTTON_UP;
static const int RI_MOUSE_BUTTON_2_DOWN = RI_MOUSE_RIGHT_BUTTON_DOWN;
static const int RI_MOUSE_BUTTON_2_UP = RI_MOUSE_RIGHT_BUTTON_UP;
static const int RI_MOUSE_BUTTON_3_DOWN = RI_MOUSE_MIDDLE_BUTTON_DOWN;
static const int RI_MOUSE_BUTTON_3_UP = RI_MOUSE_MIDDLE_BUTTON_UP;
static const int RI_MOUSE_BUTTON_4_DOWN = 0x0040;
static const int RI_MOUSE_BUTTON_4_UP = 0x0080;
static const int RI_MOUSE_BUTTON_5_DOWN = 0x0100;
static const int RI_MOUSE_BUTTON_5_UP = 0x0200;
/*
 * If usButtonFlags has RI_MOUSE_WHEEL, the wheel delta is stored in usButtonData.
 * Take it as a signed value.
 */
# 12558 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RI_MOUSE_WHEEL = 0x0400;
/*
 * Define the mouse indicator flags.
 */
# 12563 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MOUSE_MOVE_RELATIVE = 0;
static const int MOUSE_MOVE_ABSOLUTE = 1;
static const int MOUSE_VIRTUAL_DESKTOP = 0x02;
static const int MOUSE_ATTRIBUTES_CHANGED = 0x04;
static const int MOUSE_MOVE_NOCOALESCE = 0x08;
/*
 * Raw format of the keyboard input
 */
# 12574 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWKEYBOARD {
    /*
     * The "make" scan code (key depression).
     */
# 12578 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT MakeCode;
    /*
     * The flags field indicates a "break" (key release) and other
     * miscellaneous scan code information defined in ntddkbd.h.
     */
# 12584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT Flags;
    USHORT Reserved;
    /*
     * Windows message compatible information
     */
# 12591 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT VKey;
    UINT Message;
    /*
     * Device-specific additional information for the event.
     */
# 12597 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    ULONG ExtraInformation;
} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;
/*
 * Define the keyboard overrun MakeCode.
 */
# 12607 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int KEYBOARD_OVERRUN_MAKE_CODE = 0xFF;
/*
 * Define the keyboard input data Flags.
 */
# 12612 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RI_KEY_MAKE = 0;
static const int RI_KEY_BREAK = 1;
static const int RI_KEY_E0 = 2;
static const int RI_KEY_E1 = 4;
static const int RI_KEY_TERMSRV_SET_LED = 8;
static const int RI_KEY_TERMSRV_SHADOW = 0x10;
/*
 * Raw format of the input from Human Input Devices
 */
# 12623 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWHID {
    DWORD dwSizeHid; // byte size of each report
    DWORD dwCount; // number of input packed
    BYTE bRawData[1];
} RAWHID, *PRAWHID, *LPRAWHID;
/*
 * RAWINPUT data structure.
 */
# 12632 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWINPUT {
    RAWINPUTHEADER header;
    union {
        RAWMOUSE mouse;
        RAWKEYBOARD keyboard;
        RAWHID hid;
    } data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;
static const int RAWINPUT_ALIGN(x) = (((x) + sizeof(QWORD) - 1) & ~(sizeof(QWORD) - 1));
static const int NEXTRAWINPUTBLOCK(ptr) = ((PRAWINPUT)RAWINPUT_ALIGN((ULONG_PTR)((PBYTE)(ptr) + (ptr)->header.dwSize)));
/*
 * Flags for GetRawInputData
 */
# 12653 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RID_INPUT = 0x10000003;
static const int RID_HEADER = 0x10000005;
UINT
GetRawInputData(
    HRAWINPUT hRawInput,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize,
    UINT cbSizeHeader);
/*
 * Raw Input Device Information
 */
# 12669 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int RIDI_PREPARSEDDATA = 0x20000005;
static const int RIDI_DEVICENAME = 0x20000007;
static const int RIDI_DEVICEINFO = 0x2000000b;
typedef struct tagRID_DEVICE_INFO_MOUSE {
    DWORD dwId;
    DWORD dwNumberOfButtons;
    DWORD dwSampleRate;
    BOOL fHasHorizontalWheel;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;
typedef struct tagRID_DEVICE_INFO_KEYBOARD {
    DWORD dwType;
    DWORD dwSubType;
    DWORD dwKeyboardMode;
    DWORD dwNumberOfFunctionKeys;
    DWORD dwNumberOfIndicators;
    DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;
typedef struct tagRID_DEVICE_INFO_HID {
    DWORD dwVendorId;
    DWORD dwProductId;
    DWORD dwVersionNumber;
    /*
     * Top level collection UsagePage and Usage
     */
# 12697 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT usUsagePage;
    USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;
typedef struct tagRID_DEVICE_INFO {
    DWORD cbSize;
    DWORD dwType;
    union {
        RID_DEVICE_INFO_MOUSE mouse;
        RID_DEVICE_INFO_KEYBOARD keyboard;
        RID_DEVICE_INFO_HID hid;
    };
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;
UINT
GetRawInputDeviceInfoA(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize);
UINT
GetRawInputDeviceInfoW(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize);
static const int GetRawInputDeviceInfo = GetRawInputDeviceInfoA;
/*
 * Raw Input Bulk Read: GetRawInputBuffer
 */
# 12737 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
UINT
GetRawInputBuffer(
    PRAWINPUT pData,
    PUINT pcbSize,
    UINT cbSizeHeader);
/*
 * Raw Input request APIs
 */
# 12748 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWINPUTDEVICE {
    USHORT usUsagePage; // Toplevel collection UsagePage
    USHORT usUsage; // Toplevel collection Usage
    DWORD dwFlags;
    HWND hwndTarget; // Target hwnd. NULL = follows keyboard focus
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;
typedef const RAWINPUTDEVICE* PCRAWINPUTDEVICE;
static const int RIDEV_REMOVE = 0x00000001;
static const int RIDEV_EXCLUDE = 0x00000010;
static const int RIDEV_PAGEONLY = 0x00000020;
static const int RIDEV_NOLEGACY = 0x00000030;
static const int RIDEV_INPUTSINK = 0x00000100;
static const int RIDEV_CAPTUREMOUSE = 0x00000200;
static const int RIDEV_NOHOTKEYS = 0x00000200;
static const int RIDEV_APPKEYS = 0x00000400;
static const int RIDEV_EXINPUTSINK = 0x00001000;
static const int RIDEV_DEVNOTIFY = 0x00002000;
static const int RIDEV_EXMODEMASK = 0x000000F0;
static const int RIDEV_EXMODE(mode) = ((mode) & RIDEV_EXMODEMASK);
/*
 * Flags for the WM_INPUT_DEVICE_CHANGE message.
 */
# 12777 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GIDC_ARRIVAL = 1;
static const int GIDC_REMOVAL = 2;
static const int GET_DEVICE_CHANGE_WPARAM(wParam) = (LOWORD(wParam));
BOOL
RegisterRawInputDevices(
    PCRAWINPUTDEVICE pRawInputDevices,
    UINT uiNumDevices,
    UINT cbSize);
UINT
GetRegisteredRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    PUINT puiNumDevices,
    UINT cbSize);
typedef struct tagRAWINPUTDEVICELIST {
    HANDLE hDevice;
    DWORD dwType;
} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;
UINT
GetRawInputDeviceList(
    PRAWINPUTDEVICELIST pRawInputDeviceList,
    PUINT puiNumDevices,
    UINT cbSize);
LRESULT
DefRawInputProc(
    PRAWINPUT* paRawInput,
    INT nInput,
    UINT cbSizeHeader);
/*
 * Message Filter
 */
# 12834 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MSGFLT_ADD = 1;
static const int MSGFLT_REMOVE = 2;
BOOL
ChangeWindowMessageFilter(
    UINT message,
    DWORD dwFlag);
/*
 * Message filter info values (CHANGEFILTERSTRUCT.ExtStatus)
 */
# 12851 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MSGFLTINFO_NONE = (0);
static const int MSGFLTINFO_ALREADYALLOWED_FORWND = (1);
static const int MSGFLTINFO_ALREADYDISALLOWED_FORWND = (2);
static const int MSGFLTINFO_ALLOWED_HIGHER = (3);
typedef struct tagCHANGEFILTERSTRUCT {
    DWORD cbSize;
    DWORD ExtStatus;
} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;
/*
 * Message filter action values (action parameter to ChangeWindowMessageFilterEx)
 */
# 12864 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int MSGFLT_RESET = (0);
static const int MSGFLT_ALLOW = (1);
static const int MSGFLT_DISALLOW = (2);
BOOL
ChangeWindowMessageFilterEx(
    HWND hwnd, // Window
    UINT message, // WM_ message
    DWORD action, // Message filter action value
    PCHANGEFILTERSTRUCT pChangeFilterStruct); // Optional
/*
 * Gesture defines and functions
 */
# 12886 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Gesture information handle
 */
# 12889 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
struct HGESTUREINFO__{int unused;}; typedef struct HGESTUREINFO__ *HGESTUREINFO;
/*
 * Gesture flags - GESTUREINFO.dwFlags
 */
# 12895 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GF_BEGIN = 0x00000001;
static const int GF_INERTIA = 0x00000002;
static const int GF_END = 0x00000004;
/*
 * Gesture IDs
 */
# 12902 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GID_BEGIN = 1;
static const int GID_END = 2;
static const int GID_ZOOM = 3;
static const int GID_PAN = 4;
static const int GID_ROTATE = 5;
static const int GID_TWOFINGERTAP = 6;
static const int GID_PRESSANDTAP = 7;
static const int GID_ROLLOVER = GID_PRESSANDTAP;
/*
 * Gesture information structure
 *   - Pass the HGESTUREINFO received in the WM_GESTURE message lParam into the
 *     GetGestureInfo function to retrieve this information.
 *   - If cbExtraArgs is non-zero, pass the HGESTUREINFO received in the WM_GESTURE
 *     message lParam into the GetGestureExtraArgs function to retrieve extended
 *     argument information.
 */
# 12919 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagGESTUREINFO {
    UINT cbSize; // size, in bytes, of this structure (including variable length Args field)
    DWORD dwFlags; // see GF_* flags
    DWORD dwID; // gesture ID, see GID_* defines
    HWND hwndTarget; // handle to window targeted by this gesture
    POINTS ptsLocation; // current location of this gesture
    DWORD dwInstanceID; // internally used
    DWORD dwSequenceID; // internally used
    ULONGLONG ullArguments; // arguments for gestures whose arguments fit in 8 BYTES
    UINT cbExtraArgs; // size, in bytes, of extra arguments, if any, that accompany this gesture
} GESTUREINFO, *PGESTUREINFO;
typedef GESTUREINFO const * PCGESTUREINFO;
/*
 * Gesture notification structure
 *   - The WM_GESTURENOTIFY message lParam contains a pointer to this structure.
 *   - The WM_GESTURENOTIFY message notifies a window that gesture recognition is
 *     in progress and a gesture will be generated if one is recognized under the
 *     current gesture settings.
 */
# 12940 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagGESTURENOTIFYSTRUCT {
    UINT cbSize; // size, in bytes, of this structure
    DWORD dwFlags; // unused
    HWND hwndTarget; // handle to window targeted by the gesture
    POINTS ptsLocation; // starting location
    DWORD dwInstanceID; // internally used
} GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;
/*
 * Gesture argument helpers
 *   - Angle should be a double in the range of -2pi to +2pi
 *   - Argument should be an unsigned 16-bit value
 */
# 12953 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const double GID_ROTATE_ANGLE_TO_ARGUMENT(_arg_) = ((USHORT)((((_arg_) + 2.0 * 3.14159265) / (4.0 * 3.14159265)) * 65535.0));
static const double GID_ROTATE_ANGLE_FROM_ARGUMENT(_arg_) = ((((double)(_arg_) / 65535.0) * 4.0 * 3.14159265) - 2.0 * 3.14159265);
/*
 * Gesture information retrieval
 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.
 */
# 12960 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
GetGestureInfo(
    HGESTUREINFO hGestureInfo,
    PGESTUREINFO pGestureInfo);
/*
 * Gesture extra arguments retrieval
 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.
 *   - Size, in bytes, of the extra argument data is available in the cbExtraArgs
 *     field of the GESTUREINFO structure retrieved using the GetGestureInfo function.
 */
# 12973 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
GetGestureExtraArgs(
    HGESTUREINFO hGestureInfo,
    UINT cbExtraArgs,
    PBYTE pExtraArgs);
/*
 * Gesture information handle management
 *   - If an application processes the WM_GESTURE message, then once it is done
 *     with the associated HGESTUREINFO, the application is responsible for
 *     closing the handle using this function. Failure to do so may result in
 *     process memory leaks.
 *   - If the message is instead passed to DefWindowProc, or is forwarded using
 *     one of the PostMessage or SendMessage class of API functions, the handle
 *     is transfered with the message and need not be closed by the application.
 */
# 12991 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
BOOL
CloseGestureInfoHandle(
    HGESTUREINFO hGestureInfo);
/*
 * Gesture configuration structure
 *   - Used in SetGestureConfig and GetGestureConfig
 *   - Note that any setting not included in either GESTURECONFIG.dwWant or
 *     GESTURECONFIG.dwBlock will use the parent window's preferences or
 *     system defaults.
 */
# 13005 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagGESTURECONFIG {
    DWORD dwID; // gesture ID
    DWORD dwWant; // settings related to gesture ID that are to be turned on
    DWORD dwBlock; // settings related to gesture ID that are to be turned off
} GESTURECONFIG, *PGESTURECONFIG;
/*
 * Gesture configuration flags - GESTURECONFIG.dwWant or GESTURECONFIG.dwBlock
 */
# 13015 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*
 * Common gesture configuration flags - set GESTURECONFIG.dwID to zero
 */
# 13018 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GC_ALLGESTURES = 0x00000001;
/*
 * Zoom gesture configuration flags - set GESTURECONFIG.dwID to GID_ZOOM
 */
# 13023 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GC_ZOOM = 0x00000001;
/*
 * Pan gesture configuration flags - set GESTURECONFIG.dwID to GID_PAN
 */
# 13028 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GC_PAN = 0x00000001;
static const int GC_PAN_WITH_SINGLE_FINGER_VERTICALLY = 0x00000002;
static const int GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY = 0x00000004;
static const int GC_PAN_WITH_GUTTER = 0x00000008;
static const int GC_PAN_WITH_INERTIA = 0x00000010;
/*
 * Rotate gesture configuration flags - set GESTURECONFIG.dwID to GID_ROTATE
 */
# 13037 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GC_ROTATE = 0x00000001;
/*
 * Two finger tap gesture configuration flags - set GESTURECONFIG.dwID to GID_TWOFINGERTAP
 */
# 13042 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GC_TWOFINGERTAP = 0x00000001;
/*
 * PressAndTap gesture configuration flags - set GESTURECONFIG.dwID to GID_PRESSANDTAP
 */
# 13047 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int GC_PRESSANDTAP = 0x00000001;
static const int GC_ROLLOVER = GC_PRESSANDTAP;
static const int GESTURECONFIGMAXCOUNT = 256;
                                                        // in a single call to SetGestureConfig / GetGestureConfig
BOOL
SetGestureConfig(
    HWND hwnd, // window for which configuration is specified
    DWORD dwReserved, // reserved, must be 0
    UINT cIDs, // count of GESTURECONFIG structures
    PGESTURECONFIG pGestureConfig, // array of GESTURECONFIG structures, dwIDs will be processed in the
                                                        // order specified and repeated occurances will overwrite previous ones
    UINT cbSize); // sizeof(GESTURECONFIG)
static const int GCF_INCLUDE_ANCESTORS = 0x00000001;
                                                        // for the specified window and it's parent window chain
BOOL
GetGestureConfig(
    HWND hwnd, // window for which configuration is required
    DWORD dwReserved, // reserved, must be 0
    DWORD dwFlags, // see GCF_* flags
    PUINT pcIDs, // *pcIDs contains the size, in number of GESTURECONFIG structures,
                                                        // of the buffer pointed to by pGestureConfig
    PGESTURECONFIG pGestureConfig,
                                                        // pointer to buffer to receive the returned array of GESTURECONFIG structures
    UINT cbSize); // sizeof(GESTURECONFIG)
/*
 * GetSystemMetrics(SM_DIGITIZER) flag values
 */
# 13090 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
static const int NID_INTEGRATED_TOUCH = 0x00000001;
static const int NID_EXTERNAL_TOUCH = 0x00000002;
static const int NID_INTEGRATED_PEN = 0x00000004;
static const int NID_EXTERNAL_PEN = 0x00000008;
static const int NID_MULTI_INPUT = 0x00000040;
static const int NID_READY = 0x00000080;
static const int MAX_STR_BLOCKREASON = 256;
BOOL
ShutdownBlockReasonCreate(
    HWND hWnd,
    LPCWSTR pwszReason);
BOOL
ShutdownBlockReasonQuery(
    HWND hWnd,
    LPWSTR pwszBuff,
    DWORD *pcchBuff);
BOOL
ShutdownBlockReasonDestroy(
    HWND hWnd);
# 159 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h" 1
/*++
Copyright (c) Microsoft Corporation  All rights reserved.
Module Name:
    winnls.h
Abstract:
    Procedure declarations, constant definitions, and macros for the
    NLS component.
--*/
# 18 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
static const int WINNORMALIZEAPI = DECLSPEC_IMPORT;
////////////////////////////////////////////////////////////////////////////
//
//  Constants
//
//  Define all constants for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////
//
//  String Length Maximums.
//
static const int MAX_LEADBYTES = 12;
static const int MAX_DEFAULTCHAR = 2;
//
//  Surrogate pairs
//
//  Conversion examples:
//
//  A) The first character in the Surrogate range (D800, DC00) as UTF-32:
//
//  1.  D800: binary 1101100000000000  (lower ten bits: 0000000000)
//  2.  DC00: binary 1101110000000000  (lower ten bits: 0000000000)
//  3.  Concatenate 0000000000+0000000000 = 0x0000
//  4.  Add 0x10000
//
//  Result: U+10000. This is correct, since the first character in the Supplementary character
//  range immediately follows the last code point in the 16-bit UTF-16 range (U+FFFF)
//
//  B) A UTF-32 code point such as U+2040A (this a CJK character in CJK Extension B), and wish
//  to convert it in UTF-16:
//
//  1.  Subtract 0x10000 - Result: 0x1040A
//  2.  Split into two ten-bit pieces: 0001000001 0000001010
//  3.  Add 1101100000000000 (0xD800) to the high 10 bits piece (0001000001) - Result: 1101100001000001 (0xD841)
//  4.  Add 1101110000000000 (0xDC00) to the low 10 bits piece (0000001010) - Result: 1101110000001010 (0xDC0A)
//
//  RESULT: The surrogate pair: U+D841, U+DC0A
//
//  Special Unicode code point values, for use with UTF-16 surrogate pairs.
//
static const int HIGH_SURROGATE_START = 0xd800;
static const int HIGH_SURROGATE_END = 0xdbff;
static const int LOW_SURROGATE_START = 0xdc00;
static const int LOW_SURROGATE_END = 0xdfff;
//
//  MBCS and Unicode Translation Flags.
//
static const int MB_PRECOMPOSED = 0x00000001;
static const int MB_COMPOSITE = 0x00000002;
static const int MB_USEGLYPHCHARS = 0x00000004;
static const int MB_ERR_INVALID_CHARS = 0x00000008;
static const int WC_COMPOSITECHECK = 0x00000200;
static const int WC_DISCARDNS = 0x00000010;
static const int WC_SEPCHARS = 0x00000020;
static const int WC_DEFAULTCHAR = 0x00000040;
static const int WC_ERR_INVALID_CHARS = 0x00000080;
static const int WC_NO_BEST_FIT_CHARS = 0x00000400;
//
//  Character Type Flags.
//
static const int CT_CTYPE1 = 0x00000001;
static const int CT_CTYPE2 = 0x00000002;
static const int CT_CTYPE3 = 0x00000004;
//
//  CType 1 Flag Bits.
//
static const int C1_UPPER = 0x0001;
static const int C1_LOWER = 0x0002;
static const int C1_DIGIT = 0x0004;
static const int C1_SPACE = 0x0008;
static const int C1_PUNCT = 0x0010;
static const int C1_CNTRL = 0x0020;
static const int C1_BLANK = 0x0040;
static const int C1_XDIGIT = 0x0080;
static const int C1_ALPHA = 0x0100;
static const int C1_DEFINED = 0x0200;
//
//  CType 2 Flag Bits.
//
static const int C2_LEFTTORIGHT = 0x0001;
static const int C2_RIGHTTOLEFT = 0x0002;
static const int C2_EUROPENUMBER = 0x0003;
static const int C2_EUROPESEPARATOR = 0x0004;
static const int C2_EUROPETERMINATOR = 0x0005;
static const int C2_ARABICNUMBER = 0x0006;
static const int C2_COMMONSEPARATOR = 0x0007;
static const int C2_BLOCKSEPARATOR = 0x0008;
static const int C2_SEGMENTSEPARATOR = 0x0009;
static const int C2_WHITESPACE = 0x000A;
static const int C2_OTHERNEUTRAL = 0x000B;
static const int C2_NOTAPPLICABLE = 0x0000;
//
//  CType 3 Flag Bits.
//
static const int C3_NONSPACING = 0x0001;
static const int C3_DIACRITIC = 0x0002;
static const int C3_VOWELMARK = 0x0004;
static const int C3_SYMBOL = 0x0008;
static const int C3_KATAKANA = 0x0010;
static const int C3_HIRAGANA = 0x0020;
static const int C3_HALFWIDTH = 0x0040;
static const int C3_FULLWIDTH = 0x0080;
static const int C3_IDEOGRAPH = 0x0100;
static const int C3_KASHIDA = 0x0200;
static const int C3_LEXICAL = 0x0400;
static const int C3_HIGHSURROGATE = 0x0800;
static const int C3_LOWSURROGATE = 0x1000;
static const int C3_ALPHA = 0x8000;
static const int C3_NOTAPPLICABLE = 0x0000;
//
//  String Flags.
//
static const int NORM_IGNORECASE = 0x00000001;
static const int NORM_IGNORENONSPACE = 0x00000002;
static const int NORM_IGNORESYMBOLS = 0x00000004;
static const int LINGUISTIC_IGNORECASE = 0x00000010;
static const int LINGUISTIC_IGNOREDIACRITIC = 0x00000020;
static const int NORM_IGNOREKANATYPE = 0x00010000;
static const int NORM_IGNOREWIDTH = 0x00020000;
static const int NORM_LINGUISTIC_CASING = 0x08000000;
//
//  Locale Independent Mapping Flags.
//
static const int MAP_FOLDCZONE = 0x00000010;
static const int MAP_PRECOMPOSED = 0x00000020;
static const int MAP_COMPOSITE = 0x00000040;
static const int MAP_FOLDDIGITS = 0x00000080;
static const int MAP_EXPAND_LIGATURES = 0x00002000;
//
//  Locale Dependent Mapping Flags.
//
static const int LCMAP_LOWERCASE = 0x00000100;
static const int LCMAP_UPPERCASE = 0x00000200;
static const int LCMAP_TITLECASE = 0x00000300;
static const int LCMAP_SORTKEY = 0x00000400;
static const int LCMAP_BYTEREV = 0x00000800;
static const int LCMAP_HIRAGANA = 0x00100000;
static const int LCMAP_KATAKANA = 0x00200000;
static const int LCMAP_HALFWIDTH = 0x00400000;
static const int LCMAP_FULLWIDTH = 0x00800000;
static const int LCMAP_LINGUISTIC_CASING = 0x01000000;
static const int LCMAP_SIMPLIFIED_CHINESE = 0x02000000;
static const int LCMAP_TRADITIONAL_CHINESE = 0x04000000;
//
//  Search Flags
//
static const int FIND_STARTSWITH = 0x00100000;
static const int FIND_ENDSWITH = 0x00200000;
static const int FIND_FROMSTART = 0x00400000;
static const int FIND_FROMEND = 0x00800000;
//
//  Language Group Enumeration Flags.
//
static const int LGRPID_INSTALLED = 0x00000001;
static const int LGRPID_SUPPORTED = 0x00000002;
//
//  Locale Enumeration Flags.
//
static const int LCID_INSTALLED = 0x00000001;
static const int LCID_SUPPORTED = 0x00000002;
static const int LCID_ALTERNATE_SORTS = 0x00000004;
//
//  Named based enumeration flags.
//
static const int LOCALE_ALL = 0;
static const int LOCALE_WINDOWS = 0x00000001;
static const int LOCALE_SUPPLEMENTAL = 0x00000002;
static const int LOCALE_ALTERNATE_SORTS = 0x00000004;
static const int LOCALE_REPLACEMENT = 0x00000008;
static const int LOCALE_NEUTRALDATA = 0x00000010;
static const int LOCALE_SPECIFICDATA = 0x00000020;
//
//  Code Page Enumeration Flags.
//
static const int CP_INSTALLED = 0x00000001;
static const int CP_SUPPORTED = 0x00000002;
//
//  Sorting Flags.
//
//    WORD Sort:    culturally correct sort
//                  hyphen and apostrophe are special cased
//                  example: "coop" and "co-op" will sort together in a list
//
//                        co_op     <-------  underscore (symbol)
//                        coat
//                        comb
//                        coop
//                        co-op     <-------  hyphen (punctuation)
//                        cork
//                        went
//                        were
//                        we're     <-------  apostrophe (punctuation)
//
//
//    STRING Sort:  hyphen and apostrophe will sort with all other symbols
//
//                        co-op     <-------  hyphen (punctuation)
//                        co_op     <-------  underscore (symbol)
//                        coat
//                        comb
//                        coop
//                        cork
//                        we're     <-------  apostrophe (punctuation)
//                        went
//                        were
//
static const int SORT_STRINGSORT = 0x00001000;
//  Sort digits as numbers (ie: 2 comes before 10)
static const int SORT_DIGITSASNUMBERS = 0x00000008;
//
//  Compare String Return Values.
//
static const int CSTR_LESS_THAN = 1;
static const int CSTR_EQUAL = 2;
static const int CSTR_GREATER_THAN = 3;
//
//  Code Page Default Values.
//
static const int CP_ACP = 0;
static const int CP_OEMCP = 1;
static const int CP_MACCP = 2;
static const int CP_THREAD_ACP = 3;
static const int CP_SYMBOL = 42;
static const int CP_UTF7 = 65000;
static const int CP_UTF8 = 65001;
//
//  Country/Region Codes.
//
static const int CTRY_DEFAULT = 0;
static const int CTRY_ALBANIA = 355;
static const int CTRY_ALGERIA = 213;
static const int CTRY_ARGENTINA = 54;
static const int CTRY_ARMENIA = 374;
static const int CTRY_AUSTRALIA = 61;
static const int CTRY_AUSTRIA = 43;
static const int CTRY_AZERBAIJAN = 994;
static const int CTRY_BAHRAIN = 973;
static const int CTRY_BELARUS = 375;
static const int CTRY_BELGIUM = 32;
static const int CTRY_BELIZE = 501;
static const int CTRY_BOLIVIA = 591;
static const int CTRY_BRAZIL = 55;
static const int CTRY_BRUNEI_DARUSSALAM = 673;
static const int CTRY_BULGARIA = 359;
static const int CTRY_CANADA = 2;
static const int CTRY_CARIBBEAN = 1;
static const int CTRY_CHILE = 56;
static const int CTRY_COLOMBIA = 57;
static const int CTRY_COSTA_RICA = 506;
static const int CTRY_CROATIA = 385;
static const int CTRY_CZECH = 420;
static const int CTRY_DENMARK = 45;
static const int CTRY_DOMINICAN_REPUBLIC = 1;
static const int CTRY_ECUADOR = 593;
static const int CTRY_EGYPT = 20;
static const int CTRY_EL_SALVADOR = 503;
static const int CTRY_ESTONIA = 372;
static const int CTRY_FAEROE_ISLANDS = 298;
static const int CTRY_FINLAND = 358;
static const int CTRY_FRANCE = 33;
static const int CTRY_GEORGIA = 995;
static const int CTRY_GERMANY = 49;
static const int CTRY_GREECE = 30;
static const int CTRY_GUATEMALA = 502;
static const int CTRY_HONDURAS = 504;
static const int CTRY_HONG_KONG = 852;
static const int CTRY_HUNGARY = 36;
static const int CTRY_ICELAND = 354;
static const int CTRY_INDIA = 91;
static const int CTRY_INDONESIA = 62;
static const int CTRY_IRAN = 981;
static const int CTRY_IRAQ = 964;
static const int CTRY_IRELAND = 353;
static const int CTRY_ISRAEL = 972;
static const int CTRY_ITALY = 39;
static const int CTRY_JAMAICA = 1;
static const int CTRY_JAPAN = 81;
static const int CTRY_JORDAN = 962;
static const int CTRY_KAZAKSTAN = 7;
static const int CTRY_KENYA = 254;
static const int CTRY_KUWAIT = 965;
static const int CTRY_KYRGYZSTAN = 996;
static const int CTRY_LATVIA = 371;
static const int CTRY_LEBANON = 961;
static const int CTRY_LIBYA = 218;
static const int CTRY_LIECHTENSTEIN = 41;
static const int CTRY_LITHUANIA = 370;
static const int CTRY_LUXEMBOURG = 352;
static const int CTRY_MACAU = 853;
static const int CTRY_MACEDONIA = 389;
static const int CTRY_MALAYSIA = 60;
static const int CTRY_MALDIVES = 960;
static const int CTRY_MEXICO = 52;
static const int CTRY_MONACO = 33;
static const int CTRY_MONGOLIA = 976;
static const int CTRY_MOROCCO = 212;
static const int CTRY_NETHERLANDS = 31;
static const int CTRY_NEW_ZEALAND = 64;
static const int CTRY_NICARAGUA = 505;
static const int CTRY_NORWAY = 47;
static const int CTRY_OMAN = 968;
static const int CTRY_PAKISTAN = 92;
static const int CTRY_PANAMA = 507;
static const int CTRY_PARAGUAY = 595;
static const int CTRY_PERU = 51;
static const int CTRY_PHILIPPINES = 63;
static const int CTRY_POLAND = 48;
static const int CTRY_PORTUGAL = 351;
static const int CTRY_PRCHINA = 86;
static const int CTRY_PUERTO_RICO = 1;
static const int CTRY_QATAR = 974;
static const int CTRY_ROMANIA = 40;
static const int CTRY_RUSSIA = 7;
static const int CTRY_SAUDI_ARABIA = 966;
static const int CTRY_SERBIA = 381;
static const int CTRY_SINGAPORE = 65;
static const int CTRY_SLOVAK = 421;
static const int CTRY_SLOVENIA = 386;
static const int CTRY_SOUTH_AFRICA = 27;
static const int CTRY_SOUTH_KOREA = 82;
static const int CTRY_SPAIN = 34;
static const int CTRY_SWEDEN = 46;
static const int CTRY_SWITZERLAND = 41;
static const int CTRY_SYRIA = 963;
static const int CTRY_TAIWAN = 886;
static const int CTRY_TATARSTAN = 7;
static const int CTRY_THAILAND = 66;
static const int CTRY_TRINIDAD_Y_TOBAGO = 1;
static const int CTRY_TUNISIA = 216;
static const int CTRY_TURKEY = 90;
static const int CTRY_UAE = 971;
static const int CTRY_UKRAINE = 380;
static const int CTRY_UNITED_KINGDOM = 44;
static const int CTRY_UNITED_STATES = 1;
static const int CTRY_URUGUAY = 598;
static const int CTRY_UZBEKISTAN = 7;
static const int CTRY_VENEZUELA = 58;
static const int CTRY_VIET_NAM = 84;
static const int CTRY_YEMEN = 967;
static const int CTRY_ZIMBABWE = 263;
//
//  Locale Types.
//
//  These types are used for the GetLocaleInfo NLS API routine.
//  Some of these types are also used for the SetLocaleInfo NLS API routine.
//
//
//  The following LCTypes may be used in combination with any other LCTypes.
//
//    LOCALE_NOUSEROVERRIDE is also used in GetTimeFormat and
//    GetDateFormat.
//
//    LOCALE_USE_CP_ACP is used in many of the A (Ansi) apis that need
//    to do string translation.
//
//    LOCALE_RETURN_NUMBER will return the result from GetLocaleInfo as a
//    number instead of a string.  This flag is only valid for the LCTypes
//    beginning with LOCALE_I.
//
static const int LOCALE_NOUSEROVERRIDE = 0x80000000;
static const int LOCALE_USE_CP_ACP = 0x40000000;
static const int LOCALE_RETURN_NUMBER = 0x20000000;
static const int LOCALE_RETURN_GENITIVE_NAMES = 0x10000000;
static const int LOCALE_ALLOW_NEUTRAL_NAMES = 0x08000000;
//
//  The following LCTypes are mutually exclusive in that they may NOT
//  be used in combination with each other.
//
//
// These are the various forms of the name of the locale:
//
static const int LOCALE_SLOCALIZEDDISPLAYNAME = 0x00000002;
static const int LOCALE_SENGLISHDISPLAYNAME = 0x00000072;
static const int LOCALE_SNATIVEDISPLAYNAME = 0x00000073;
static const int LOCALE_SLOCALIZEDLANGUAGENAME = 0x0000006f;
static const int LOCALE_SENGLISHLANGUAGENAME = 0x00001001;
static const int LOCALE_SNATIVELANGUAGENAME = 0x00000004;
static const int LOCALE_SLOCALIZEDCOUNTRYNAME = 0x00000006;
static const int LOCALE_SENGLISHCOUNTRYNAME = 0x00001002;
static const int LOCALE_SNATIVECOUNTRYNAME = 0x00000008;
//
// Legacy labels for the locale name values
//
static const int LOCALE_SLANGUAGE = 0x00000002;
static const int LOCALE_SLANGDISPLAYNAME = 0x0000006f;
static const int LOCALE_SENGLANGUAGE = 0x00001001;
static const int LOCALE_SNATIVELANGNAME = 0x00000004;
static const int LOCALE_SCOUNTRY = 0x00000006;
static const int LOCALE_SENGCOUNTRY = 0x00001002;
static const int LOCALE_SNATIVECTRYNAME = 0x00000008;
// Additional LCTypes
static const int LOCALE_ILANGUAGE = 0x00000001;
static const int LOCALE_SABBREVLANGNAME = 0x00000003;
static const int LOCALE_ICOUNTRY = 0x00000005;
static const int LOCALE_SABBREVCTRYNAME = 0x00000007;
static const int LOCALE_IGEOID = 0x0000005B;
static const int LOCALE_IDEFAULTLANGUAGE = 0x00000009;
static const int LOCALE_IDEFAULTCOUNTRY = 0x0000000A;
static const int LOCALE_IDEFAULTCODEPAGE = 0x0000000B;
static const int LOCALE_IDEFAULTANSICODEPAGE = 0x00001004;
static const int LOCALE_IDEFAULTMACCODEPAGE = 0x00001011;
static const int LOCALE_SLIST = 0x0000000C;
static const int LOCALE_IMEASURE = 0x0000000D;
static const int LOCALE_SDECIMAL = 0x0000000E;
static const double LOCALE_STHOUSAND = 0x0000000F;
static const int LOCALE_SGROUPING = 0x00000010;
static const int LOCALE_IDIGITS = 0x00000011;
static const int LOCALE_ILZERO = 0x00000012;
static const int LOCALE_INEGNUMBER = 0x00001010;
static const int LOCALE_SNATIVEDIGITS = 0x00000013;
static const int LOCALE_SCURRENCY = 0x00000014;
static const int LOCALE_SINTLSYMBOL = 0x00000015;
static const int LOCALE_SMONDECIMALSEP = 0x00000016;
static const int LOCALE_SMONTHOUSANDSEP = 0x00000017;
static const int LOCALE_SMONGROUPING = 0x00000018;
static const int LOCALE_ICURRDIGITS = 0x00000019;
static const int LOCALE_IINTLCURRDIGITS = 0x0000001A;
static const int LOCALE_ICURRENCY = 0x0000001B;
static const int LOCALE_INEGCURR = 0x0000001C;
static const int LOCALE_SDATE = 0x0000001D;
static const int LOCALE_STIME = 0x0000001E;
static const double LOCALE_SSHORTDATE = 0x0000001F;
static const int LOCALE_SLONGDATE = 0x00000020;
static const int LOCALE_STIMEFORMAT = 0x00001003;
static const int LOCALE_IDATE = 0x00000021;
static const int LOCALE_ILDATE = 0x00000022;
static const int LOCALE_ITIME = 0x00000023;
static const int LOCALE_ITIMEMARKPOSN = 0x00001005;
static const int LOCALE_ICENTURY = 0x00000024;
static const int LOCALE_ITLZERO = 0x00000025;
static const int LOCALE_IDAYLZERO = 0x00000026;
static const int LOCALE_IMONLZERO = 0x00000027;
static const int LOCALE_S1159 = 0x00000028;
static const int LOCALE_S2359 = 0x00000029;
static const int LOCALE_ICALENDARTYPE = 0x00001009;
static const int LOCALE_IOPTIONALCALENDAR = 0x0000100B;
static const int LOCALE_IFIRSTDAYOFWEEK = 0x0000100C;
static const int LOCALE_IFIRSTWEEKOFYEAR = 0x0000100D;
static const int LOCALE_SDAYNAME1 = 0x0000002A;
static const int LOCALE_SDAYNAME2 = 0x0000002B;
static const int LOCALE_SDAYNAME3 = 0x0000002C;
static const int LOCALE_SDAYNAME4 = 0x0000002D;
static const int LOCALE_SDAYNAME5 = 0x0000002E;
static const double LOCALE_SDAYNAME6 = 0x0000002F;
static const int LOCALE_SDAYNAME7 = 0x00000030;
static const int LOCALE_SABBREVDAYNAME1 = 0x00000031;
static const int LOCALE_SABBREVDAYNAME2 = 0x00000032;
static const int LOCALE_SABBREVDAYNAME3 = 0x00000033;
static const int LOCALE_SABBREVDAYNAME4 = 0x00000034;
static const int LOCALE_SABBREVDAYNAME5 = 0x00000035;
static const int LOCALE_SABBREVDAYNAME6 = 0x00000036;
static const int LOCALE_SABBREVDAYNAME7 = 0x00000037;
static const int LOCALE_SMONTHNAME1 = 0x00000038;
static const int LOCALE_SMONTHNAME2 = 0x00000039;
static const int LOCALE_SMONTHNAME3 = 0x0000003A;
static const int LOCALE_SMONTHNAME4 = 0x0000003B;
static const int LOCALE_SMONTHNAME5 = 0x0000003C;
static const int LOCALE_SMONTHNAME6 = 0x0000003D;
static const int LOCALE_SMONTHNAME7 = 0x0000003E;
static const double LOCALE_SMONTHNAME8 = 0x0000003F;
static const int LOCALE_SMONTHNAME9 = 0x00000040;
static const int LOCALE_SMONTHNAME10 = 0x00000041;
static const int LOCALE_SMONTHNAME11 = 0x00000042;
static const int LOCALE_SMONTHNAME12 = 0x00000043;
static const int LOCALE_SMONTHNAME13 = 0x0000100E;
static const int LOCALE_SABBREVMONTHNAME1 = 0x00000044;
static const int LOCALE_SABBREVMONTHNAME2 = 0x00000045;
static const int LOCALE_SABBREVMONTHNAME3 = 0x00000046;
static const int LOCALE_SABBREVMONTHNAME4 = 0x00000047;
static const int LOCALE_SABBREVMONTHNAME5 = 0x00000048;
static const int LOCALE_SABBREVMONTHNAME6 = 0x00000049;
static const int LOCALE_SABBREVMONTHNAME7 = 0x0000004A;
static const int LOCALE_SABBREVMONTHNAME8 = 0x0000004B;
static const int LOCALE_SABBREVMONTHNAME9 = 0x0000004C;
static const int LOCALE_SABBREVMONTHNAME10 = 0x0000004D;
static const int LOCALE_SABBREVMONTHNAME11 = 0x0000004E;
static const double LOCALE_SABBREVMONTHNAME12 = 0x0000004F;
static const double LOCALE_SABBREVMONTHNAME13 = 0x0000100F;
static const int LOCALE_SPOSITIVESIGN = 0x00000050;
static const int LOCALE_SNEGATIVESIGN = 0x00000051;
static const int LOCALE_IPOSSIGNPOSN = 0x00000052;
static const int LOCALE_INEGSIGNPOSN = 0x00000053;
static const int LOCALE_IPOSSYMPRECEDES = 0x00000054;
static const int LOCALE_IPOSSEPBYSPACE = 0x00000055;
static const int LOCALE_INEGSYMPRECEDES = 0x00000056;
static const int LOCALE_INEGSEPBYSPACE = 0x00000057;
static const int LOCALE_FONTSIGNATURE = 0x00000058;
static const int LOCALE_SISO639LANGNAME = 0x00000059;
static const int LOCALE_SISO3166CTRYNAME = 0x0000005A;
static const int LOCALE_IDEFAULTEBCDICCODEPAGE = 0x00001012;
static const int LOCALE_IPAPERSIZE = 0x0000100A;
static const int LOCALE_SENGCURRNAME = 0x00001007;
static const int LOCALE_SNATIVECURRNAME = 0x00001008;
static const int LOCALE_SYEARMONTH = 0x00001006;
static const int LOCALE_SSORTNAME = 0x00001013;
static const int LOCALE_IDIGITSUBSTITUTION = 0x00001014;
static const int LOCALE_SNAME = 0x0000005c;
static const int LOCALE_SDURATION = 0x0000005d;
static const int LOCALE_SKEYBOARDSTOINSTALL = 0x0000005e;
static const int LOCALE_SSHORTESTDAYNAME1 = 0x00000060;
static const int LOCALE_SSHORTESTDAYNAME2 = 0x00000061;
static const int LOCALE_SSHORTESTDAYNAME3 = 0x00000062;
static const int LOCALE_SSHORTESTDAYNAME4 = 0x00000063;
static const int LOCALE_SSHORTESTDAYNAME5 = 0x00000064;
static const int LOCALE_SSHORTESTDAYNAME6 = 0x00000065;
static const int LOCALE_SSHORTESTDAYNAME7 = 0x00000066;
static const int LOCALE_SISO639LANGNAME2 = 0x00000067;
static const int LOCALE_SISO3166CTRYNAME2 = 0x00000068;
static const int LOCALE_SNAN = 0x00000069;
static const int LOCALE_SPOSINFINITY = 0x0000006a;
static const int LOCALE_SNEGINFINITY = 0x0000006b;
static const int LOCALE_SSCRIPTS = 0x0000006c;
static const int LOCALE_SPARENT = 0x0000006d;
static const int LOCALE_SCONSOLEFALLBACKNAME = 0x0000006e;
static const int LOCALE_IREADINGLAYOUT = 0x00000070;
                                                   // 0 - Left to right (eg en-US)
                                                   // 1 - Right to left (eg arabic locales)
                                                   // 2 - Vertical top to bottom with columns to the left and also left to right (ja-JP locales)
                                                   // 3 - Vertical top to bottom with columns proceeding to the right
static const int LOCALE_INEUTRAL = 0x00000071;
static const int LOCALE_INEGATIVEPERCENT = 0x00000074;
static const int LOCALE_IPOSITIVEPERCENT = 0x00000075;
static const int LOCALE_SPERCENT = 0x00000076;
static const int LOCALE_SPERMILLE = 0x00000077;
static const int LOCALE_SMONTHDAY = 0x00000078;
static const int LOCALE_SSHORTTIME = 0x00000079;
static const int LOCALE_SOPENTYPELANGUAGETAG = 0x0000007a;
static const int LOCALE_SSORTLOCALE = 0x0000007b;
//
//  Time Flags for GetTimeFormat.
//
static const int TIME_NOMINUTESORSECONDS = 0x00000001;
static const int TIME_NOSECONDS = 0x00000002;
static const int TIME_NOTIMEMARKER = 0x00000004;
static const int TIME_FORCE24HOURFORMAT = 0x00000008;
//
//  Date Flags for GetDateFormat.
//
static const int DATE_SHORTDATE = 0x00000001;
static const int DATE_LONGDATE = 0x00000002;
static const int DATE_USE_ALT_CALENDAR = 0x00000004;
static const int DATE_YEARMONTH = 0x00000008;
static const int DATE_LTRREADING = 0x00000010;
static const int DATE_RTLREADING = 0x00000020;
static const int DATE_AUTOLAYOUT = 0x00000040;
//
//  Calendar Types.
//
//  These types are used for the EnumCalendarInfo and GetCalendarInfo
//  NLS API routines.
//  Some of these types are also used for the SetCalendarInfo NLS API
//  routine.
//
//
//  The following CalTypes may be used in combination with any other CalTypes.
//
//    CAL_NOUSEROVERRIDE
//
//    CAL_USE_CP_ACP is used in the A (Ansi) apis that need to do string
//    translation.
//
//    CAL_RETURN_NUMBER will return the result from GetCalendarInfo as a
//    number instead of a string.  This flag is only valid for the CalTypes
//    beginning with CAL_I.
//
static const int CAL_NOUSEROVERRIDE = LOCALE_NOUSEROVERRIDE;
static const int CAL_USE_CP_ACP = LOCALE_USE_CP_ACP;
static const int CAL_RETURN_NUMBER = LOCALE_RETURN_NUMBER;
static const int CAL_RETURN_GENITIVE_NAMES = LOCALE_RETURN_GENITIVE_NAMES;
//
//  The following CalTypes are mutually exclusive in that they may NOT
//  be used in combination with each other.
//
static const int CAL_ICALINTVALUE = 0x00000001;
static const int CAL_SCALNAME = 0x00000002;
static const int CAL_IYEAROFFSETRANGE = 0x00000003;
static const int CAL_SERASTRING = 0x00000004;
static const int CAL_SSHORTDATE = 0x00000005;
static const int CAL_SLONGDATE = 0x00000006;
static const int CAL_SDAYNAME1 = 0x00000007;
static const int CAL_SDAYNAME2 = 0x00000008;
static const int CAL_SDAYNAME3 = 0x00000009;
static const int CAL_SDAYNAME4 = 0x0000000a;
static const int CAL_SDAYNAME5 = 0x0000000b;
static const int CAL_SDAYNAME6 = 0x0000000c;
static const int CAL_SDAYNAME7 = 0x0000000d;
static const int CAL_SABBREVDAYNAME1 = 0x0000000e;
static const int CAL_SABBREVDAYNAME2 = 0x0000000f;
static const int CAL_SABBREVDAYNAME3 = 0x00000010;
static const int CAL_SABBREVDAYNAME4 = 0x00000011;
static const int CAL_SABBREVDAYNAME5 = 0x00000012;
static const int CAL_SABBREVDAYNAME6 = 0x00000013;
static const int CAL_SABBREVDAYNAME7 = 0x00000014;
// Note that in the hebrew calendar the leap month name is always returned as the 7th month
static const int CAL_SMONTHNAME1 = 0x00000015;
static const int CAL_SMONTHNAME2 = 0x00000016;
static const int CAL_SMONTHNAME3 = 0x00000017;
static const int CAL_SMONTHNAME4 = 0x00000018;
static const int CAL_SMONTHNAME5 = 0x00000019;
static const int CAL_SMONTHNAME6 = 0x0000001a;
static const int CAL_SMONTHNAME7 = 0x0000001b;
static const int CAL_SMONTHNAME8 = 0x0000001c;
static const int CAL_SMONTHNAME9 = 0x0000001d;
static const int CAL_SMONTHNAME10 = 0x0000001e;
static const int CAL_SMONTHNAME11 = 0x0000001f;
static const int CAL_SMONTHNAME12 = 0x00000020;
static const int CAL_SMONTHNAME13 = 0x00000021;
static const int CAL_SABBREVMONTHNAME1 = 0x00000022;
static const int CAL_SABBREVMONTHNAME2 = 0x00000023;
static const int CAL_SABBREVMONTHNAME3 = 0x00000024;
static const int CAL_SABBREVMONTHNAME4 = 0x00000025;
static const int CAL_SABBREVMONTHNAME5 = 0x00000026;
static const int CAL_SABBREVMONTHNAME6 = 0x00000027;
static const int CAL_SABBREVMONTHNAME7 = 0x00000028;
static const int CAL_SABBREVMONTHNAME8 = 0x00000029;
static const int CAL_SABBREVMONTHNAME9 = 0x0000002a;
static const int CAL_SABBREVMONTHNAME10 = 0x0000002b;
static const int CAL_SABBREVMONTHNAME11 = 0x0000002c;
static const int CAL_SABBREVMONTHNAME12 = 0x0000002d;
static const int CAL_SABBREVMONTHNAME13 = 0x0000002e;
static const int CAL_SYEARMONTH = 0x0000002f;
static const int CAL_ITWODIGITYEARMAX = 0x00000030;
static const int CAL_SSHORTESTDAYNAME1 = 0x00000031;
static const int CAL_SSHORTESTDAYNAME2 = 0x00000032;
static const int CAL_SSHORTESTDAYNAME3 = 0x00000033;
static const int CAL_SSHORTESTDAYNAME4 = 0x00000034;
static const int CAL_SSHORTESTDAYNAME5 = 0x00000035;
static const int CAL_SSHORTESTDAYNAME6 = 0x00000036;
static const int CAL_SSHORTESTDAYNAME7 = 0x00000037;
static const int CAL_SMONTHDAY = 0x00000038;
static const int CAL_SABBREVERASTRING = 0x00000039;
//
//  Calendar Enumeration Value.
//
static const int ENUM_ALL_CALENDARS = 0xffffffff;
//
//  Calendar ID Values.
//
static const int CAL_GREGORIAN = 1;
static const int CAL_GREGORIAN_US = 2;
static const int CAL_JAPAN = 3;
static const int CAL_TAIWAN = 4;
static const int CAL_KOREA = 5;
static const int CAL_HIJRI = 6;
static const int CAL_THAI = 7;
static const int CAL_HEBREW = 8;
static const int CAL_GREGORIAN_ME_FRENCH = 9;
static const int CAL_GREGORIAN_ARABIC = 10;
static const int CAL_GREGORIAN_XLIT_ENGLISH = 11;
static const int CAL_GREGORIAN_XLIT_FRENCH = 12;
static const int CAL_UMALQURA = 23;
//
//  Language Group ID Values.
//
static const int LGRPID_WESTERN_EUROPE = 0x0001;
static const int LGRPID_CENTRAL_EUROPE = 0x0002;
static const int LGRPID_BALTIC = 0x0003;
static const int LGRPID_GREEK = 0x0004;
static const int LGRPID_CYRILLIC = 0x0005;
static const int LGRPID_TURKIC = 0x0006;
static const int LGRPID_TURKISH = 0x0006;
static const int LGRPID_JAPANESE = 0x0007;
static const int LGRPID_KOREAN = 0x0008;
static const int LGRPID_TRADITIONAL_CHINESE = 0x0009;
static const int LGRPID_SIMPLIFIED_CHINESE = 0x000a;
static const int LGRPID_THAI = 0x000b;
static const int LGRPID_HEBREW = 0x000c;
static const int LGRPID_ARABIC = 0x000d;
static const int LGRPID_VIETNAMESE = 0x000e;
static const int LGRPID_INDIC = 0x000f;
static const int LGRPID_GEORGIAN = 0x0010;
static const int LGRPID_ARMENIAN = 0x0011;
//
//  MUI function flag values
//
static const int MUI_LANGUAGE_ID = 0x4;
static const int MUI_LANGUAGE_NAME = 0x8;
static const int MUI_MERGE_SYSTEM_FALLBACK = 0x10;
static const int MUI_MERGE_USER_FALLBACK = 0x20;
static const int MUI_UI_FALLBACK = MUI_MERGE_SYSTEM_FALLBACK | MUI_MERGE_USER_FALLBACK;
static const int MUI_THREAD_LANGUAGES = 0x40;
static const int MUI_CONSOLE_FILTER = 0x100;
static const int MUI_COMPLEX_SCRIPT_FILTER = 0x200;
static const int MUI_RESET_FILTERS = 0x001;
static const int MUI_USER_PREFERRED_UI_LANGUAGES = 0x10;
static const int MUI_USE_INSTALLED_LANGUAGES = 0x20;
static const int MUI_USE_SEARCH_ALL_LANGUAGES = 0x40;
static const int MUI_LANG_NEUTRAL_PE_FILE = 0x100;
static const int MUI_NON_LANG_NEUTRAL_FILE = 0x200;
static const int MUI_MACHINE_LANGUAGE_SETTINGS = 0x400;
static const int MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL = 0x001;
static const int MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN = 0x002;
static const int MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI = 0x004;
static const int MUI_QUERY_TYPE = 0x001;
static const int MUI_QUERY_CHECKSUM = 0x002;
static const int MUI_QUERY_LANGUAGE_NAME = 0x004;
static const int MUI_QUERY_RESOURCE_TYPES = 0x008;
static const int MUI_FILEINFO_VERSION = 0x001;
static const int MUI_FULL_LANGUAGE = 0x01;
static const int MUI_PARTIAL_LANGUAGE = 0x02;
static const int MUI_LIP_LANGUAGE = 0x04;
static const int MUI_LANGUAGE_INSTALLED = 0x20;
static const int MUI_LANGUAGE_LICENSED = 0x40;
//
// MUI_CALLBACK_FLAG defines are duplicated in rtlmui.h
//
static const int MUI_CALLBACK_ALL_FLAGS = MUI_CALLBACK_FLAG_UPGRADED_INSTALLATION;
//
// MUI_CALLBACK_ flags are duplicated in rtlmui.h
//
////////////////////////////////////////////////////////////////////////////
//
//  Typedefs
//
//  Define all types for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////
//
//  Language Group ID.
//
typedef DWORD LGRPID;
//
//  Locale type constant.
//
typedef DWORD LCTYPE;
//
//  Calendar type constant.
//
typedef DWORD CALTYPE;
//
//  Calendar ID.
//
typedef DWORD CALID;
//
//  CP Info.
//
typedef struct _cpinfo {
    UINT MaxCharSize; // max length (in bytes) of a char
    BYTE DefaultChar[2]; // default character
    BYTE LeadByte[12]; // lead byte ranges
} CPINFO, *LPCPINFO;
typedef struct _cpinfoexA {
    UINT MaxCharSize; // max length (in bytes) of a char
    BYTE DefaultChar[2]; // default character (MB)
    BYTE LeadByte[12]; // lead byte ranges
    WCHAR UnicodeDefaultChar; // default character (Unicode)
    UINT CodePage; // code page id
    CHAR CodePageName[260]; // code page name (Unicode)
} CPINFOEXA, *LPCPINFOEXA;
typedef struct _cpinfoexW {
    UINT MaxCharSize; // max length (in bytes) of a char
    BYTE DefaultChar[2]; // default character (MB)
    BYTE LeadByte[12]; // lead byte ranges
    WCHAR UnicodeDefaultChar; // default character (Unicode)
    UINT CodePage; // code page id
    WCHAR CodePageName[260]; // code page name (Unicode)
} CPINFOEXW, *LPCPINFOEXW;
typedef CPINFOEXA CPINFOEX;
typedef LPCPINFOEXA LPCPINFOEX;
//
//  Number format.
//
typedef struct _numberfmtA {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPSTR lpDecimalSep; // ptr to decimal separator string
    LPSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative number ordering
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPWSTR lpDecimalSep; // ptr to decimal separator string
    LPWSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative number ordering
} NUMBERFMTW, *LPNUMBERFMTW;
typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
//
//  Currency format.
//
typedef struct _currencyfmtA {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPSTR lpDecimalSep; // ptr to decimal separator string
    LPSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative currency ordering
    UINT PositiveOrder; // positive currency ordering
    LPSTR lpCurrencySymbol; // ptr to currency symbol string
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPWSTR lpDecimalSep; // ptr to decimal separator string
    LPWSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative currency ordering
    UINT PositiveOrder; // positive currency ordering
    LPWSTR lpCurrencySymbol; // ptr to currency symbol string
} CURRENCYFMTW, *LPCURRENCYFMTW;
typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
//
//  NLS function capabilities
//
enum SYSNLS_FUNCTION{
    COMPARE_STRING = 0x0001,
};
typedef DWORD NLS_FUNCTION;
//
//  NLS version structure.
//
typedef struct _nlsversioninfo{
    DWORD dwNLSVersionInfoSize; // 12 bytes
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;
} NLSVERSIONINFO, *LPNLSVERSIONINFO;
// This is to be deprecated, please use the NLSVERSIONINFO
// structure above in the future.  The difference is that
// the effective ID is more robust.
typedef struct _nlsversioninfoex{
    DWORD dwNLSVersionInfoSize; // sizeof(NLSVERSIONINFOEX) == 32 bytes
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;
    DWORD dwEffectiveId; // Use NLSVERSIONINFO instead
    GUID guidCustomVersion;
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;
//
//  GEO defines
//
typedef LONG GEOID;
typedef DWORD GEOTYPE;
typedef DWORD GEOCLASS;
static const int GEOID_NOT_AVAILABLE = -1;
//
//  GEO information types for clients to query
//
enum SYSGEOTYPE {
    GEO_NATION = 0x0001,
    GEO_LATITUDE = 0x0002,
    GEO_LONGITUDE = 0x0003,
    GEO_ISO2 = 0x0004,
    GEO_ISO3 = 0x0005,
    GEO_RFC1766 = 0x0006,
    GEO_LCID = 0x0007,
    GEO_FRIENDLYNAME= 0x0008,
    GEO_OFFICIALNAME= 0x0009,
    GEO_TIMEZONES = 0x000A,
    GEO_OFFICIALLANGUAGES = 0x000B,
};
//
//  More GEOCLASS defines will be listed here
//
enum SYSGEOCLASS {
    GEOCLASS_NATION = 16,
    GEOCLASS_REGION = 14,
};
//
//  Normalization forms
//
typedef enum _NORM_FORM {
    NormalizationOther = 0, // Not supported
    NormalizationC = 0x1, // Each base plus combining characters to the canonical precomposed equivalent.
    NormalizationD = 0x2, // Each precomposed character to its canonical decomposed equivalent.
    NormalizationKC = 0x5, // Each base plus combining characters to the canonical precomposed
                                   //   equivalents and all compatibility characters to their equivalents.
    NormalizationKD = 0x6 // Each precomposed character to its canonical decomposed equivalent
                                   //   and all compatibility characters to their equivalents.
} NORM_FORM;
//
// IDN (International Domain Name) Flags
//
static const int IDN_ALLOW_UNASSIGNED = 0x01;
static const int IDN_USE_STD3_ASCII_RULES = 0x02;
static const int VS_ALLOW_LATIN = 0x0001;
static const int GSS_ALLOW_INHERITED_COMMON = 0x0001;
//
//  Enumeration function constants.
//
typedef BOOL (* LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);
typedef BOOL (* LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
typedef BOOL (* UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
typedef BOOL (* LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL (* CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL (* DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (* DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (* TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (* CALINFO_ENUMPROCA)(LPSTR);
typedef BOOL (* CALINFO_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (* LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);
typedef BOOL (* LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
typedef BOOL (* UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (* LOCALE_ENUMPROCW)(LPWSTR);
typedef BOOL (* CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL (* DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (* DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (* TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (* CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (* CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (* GEO_ENUMPROC)(GEOID);
# 1191 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
static const int LANGUAGEGROUP_ENUMPROC = LANGUAGEGROUP_ENUMPROCA;
static const int LANGGROUPLOCALE_ENUMPROC = LANGGROUPLOCALE_ENUMPROCA;
static const int UILANGUAGE_ENUMPROC = UILANGUAGE_ENUMPROCA;
static const int LOCALE_ENUMPROC = LOCALE_ENUMPROCA;
static const int CODEPAGE_ENUMPROC = CODEPAGE_ENUMPROCA;
static const int DATEFMT_ENUMPROC = DATEFMT_ENUMPROCA;
static const int DATEFMT_ENUMPROCEX = DATEFMT_ENUMPROCEXA;
static const int TIMEFMT_ENUMPROC = TIMEFMT_ENUMPROCA;
static const int CALINFO_ENUMPROC = CALINFO_ENUMPROCA;
static const int CALINFO_ENUMPROCEX = CALINFO_ENUMPROCEXA;
//
// Information about a MUI file, used as input/output in GetFileMUIInfo
// All offsets are relative to start of the structure. Offsets with value 0 mean empty field.
//
typedef struct _FILEMUIINFO {
    DWORD dwSize; // Size of the structure including buffer size [in]
    DWORD dwVersion; // Version of the structure [in]
    DWORD dwFileType; // Type of the file [out]
    BYTE pChecksum[16]; // Checksum of the file [out]
    BYTE pServiceChecksum[16]; // Checksum of the file [out]
    DWORD dwLanguageNameOffset; // Language name of the file [out]
    DWORD dwTypeIDMainSize; // Number of TypeIDs in main module [out]
    DWORD dwTypeIDMainOffset; // Array of TypeIDs (DWORD) in main module [out]
    DWORD dwTypeNameMainOffset; // Multistring array of TypeNames in main module [out]
    DWORD dwTypeIDMUISize; // Number of TypeIDs in MUI module [out]
    DWORD dwTypeIDMUIOffset; // Array of TypeIDs (DWORD) in MUI module [out]
    DWORD dwTypeNameMUIOffset; // Multistring array of TypeNames in MUI module [out]
    BYTE abBuffer[8]; // Buffer for extra data [in] (Size 4 is for padding)
} FILEMUIINFO, *PFILEMUIINFO;
////////////////////////////////////////////////////////////////////////////
//
//  Macros
//
//  Define all macros for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////
//
//  Macros to determine whether a character is a high or low surrogate,
//  and whether two code points make up a surrogate pair (a high surrogate
//  and a low surrogate).
//
static const int IS_HIGH_SURROGATE(wch) = (((wch) >= HIGH_SURROGATE_START) && ((wch) <= HIGH_SURROGATE_END));
static const int IS_LOW_SURROGATE(wch) = (((wch) >= LOW_SURROGATE_START) && ((wch) <= LOW_SURROGATE_END));
static const int IS_SURROGATE_PAIR(hs,ls) = (IS_HIGH_SURROGATE(hs) && IS_LOW_SURROGATE(ls));
// ----------------------------------------------------------------------
// The following macros retrieve information from a MUIFILEINFO structure
//
// Gets the culture name (LPWSTR), NULL if not initialized
static const int FILEMUIINFO_GET_CULTURE(pInfo) = ((LPWSTR)((pInfo->dwLanguageNameOffset>0)?(ULONG_PTR)pInfo+pInfo->dwLanguageNameOffset:NULL));
//
// Gets the main module types array (DWORD[]), NULL if not initialized
static const int FILEMUIINFO_GET_MAIN_TYPEIDS(pInfo) = ((DWORD*)((pInfo->dwTypeIDMainOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeIDMainOffset:NULL));
//
// Gets the main module type array element iType (DWORD), the array is not initialized or index is out of bounds
static const int FILEMUIINFO_GET_MAIN_TYPEID(pInfo,iType) = (((iType<pInfo->dwTypeIDMainSize)&&(pInfo->dwTypeIDMainOffset>0))?*((DWORD*)((ULONG_PTR)pInfo+pInfo->dwTypeIDMainOffset)+iType):0);
//
// Gets the main module names multistring array (LPWSTR), NULL if not initialized
static const int FILEMUIINFO_GET_MAIN_TYPENAMES(pInfo) = ((LPWSTR)((pInfo->dwTypeNameMainOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeNameMainOffset:NULL));
//
// Gets the mui module types array (DWORD[]), NULL if not initialized
static const int FILEMUIINFO_GET_MUI_TYPEIDS(pInfo) = ((DWORD*)((pInfo->dwTypeIDMUIOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeIDMUIOffset:NULL));
//
// Gets the mui module type array element iType (DWORD), the array is not initialized or index is out of bounds
static const int FILEMUIINFO_GET_MUI_TYPEID(pInfo,iType) = (((iType<pInfo->dwTypeIDMUISize)&&(pInfo->dwTypeIDMUIOffset>0))?*((DWORD*)((ULONG_PTR)pInfo+pInfo->dwTypeIDMUIOffset)+iType):0);
//
// Gets the mui module names multistring array (LPWSTR), NULL if not initialized
static const int FILEMUIINFO_GET_MUI_TYPENAMES(pInfo) = ((LPWSTR)((pInfo->dwTypeNameMUIOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeNameMUIOffset:NULL));
// ------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
//  Only prototypes for the NLS APIs should go here.
//
////////////////////////////////////////////////////////////////////////////
//
//  Code Page Dependent APIs.
//
BOOL
IsValidCodePage(
    UINT CodePage);
UINT
GetACP(void);
UINT
GetOEMCP(void);
BOOL
GetCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo);
BOOL
GetCPInfoExA(
    UINT CodePage,
    DWORD dwFlags,
    LPCPINFOEXA lpCPInfoEx);
BOOL
GetCPInfoExW(
    UINT CodePage,
    DWORD dwFlags,
    LPCPINFOEXW lpCPInfoEx);
static const int GetCPInfoEx = GetCPInfoExA;
BOOL
IsDBCSLeadByte(
    BYTE TestChar);
BOOL
IsDBCSLeadByteEx(
    UINT CodePage,
    BYTE TestChar);
int
MultiByteToWideChar(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);
int
WideCharToMultiByte(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar);
//
//  Locale Dependent APIs.
//
// For Windows Vista and above CompareStringEx is preferred
int
CompareStringA(
    LCID Locale,
    DWORD dwCmpFlags,
    PCNZCH lpString1,
    int cchCount1,
    PCNZCH lpString2,
    int cchCount2);
int
CompareStringW(
    LCID Locale,
    DWORD dwCmpFlags,
    PCNZWCH lpString1,
    int cchCount1,
    PCNZWCH lpString2,
    int cchCount2);
static const int CompareString = CompareStringA;
# 1433 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
// For Windows Vista and above FindNLSStringEx is preferred
int
FindNLSString(
    LCID Locale,
    DWORD dwFindNLSStringFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    LPINT pcchFound);
int
FindStringOrdinal(
    DWORD dwFindStringOrdinalFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    BOOL bIgnoreCase);
// For Windows Vista and above LCMapStringEx is preferred
int
LCMapStringA(
    LCID Locale,
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);
// For Windows Vista and above LCMapStringEx is preferred
int
LCMapStringW(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);
static const int LCMapString = LCMapStringA;
// For Windows Vista and above GetLocaleInfoEx is preferred
int
GetLocaleInfoA(
    LCID Locale,
    LCTYPE LCType,
    LPSTR lpLCData,
    int cchData);
// For Windows Vista and above GetLocaleInfoEx is preferred
int
GetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPWSTR lpLCData,
    int cchData);
static const int GetLocaleInfo = GetLocaleInfoA;
BOOL
SetLocaleInfoA(
    LCID Locale,
    LCTYPE LCType,
    LPCSTR lpLCData);
BOOL
SetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPCWSTR lpLCData);
static const int SetLocaleInfo = SetLocaleInfoA;
// For Windows Vista and above GetCalendarInfoEx is preferred
int
GetCalendarInfoA(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPSTR lpCalData,
    int cchData,
    LPDWORD lpValue);
// For Windows Vista and above GetCalendarInfoEx is preferred
int
GetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue);
static const int GetCalendarInfo = GetCalendarInfoA;
BOOL
SetCalendarInfoA(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPCSTR lpCalData);
BOOL
SetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPCWSTR lpCalData);
static const int SetCalendarInfo = SetCalendarInfoA;
int
LCIDToLocaleName(
    LCID Locale,
    LPWSTR lpName,
    int cchName,
    DWORD dwFlags);
LCID
LocaleNameToLCID(
    LPCWSTR lpName,
    DWORD dwFlags);
// For Windows Vista and above GetTimeFormatEx is preferred
int
GetTimeFormatA(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpTime,
    LPCSTR lpFormat,
    LPSTR lpTimeStr,
    int cchTime);
// For Windows Vista and above GetTimeFormatEx is preferred
int
GetTimeFormatW(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime);
static const int GetTimeFormat = GetTimeFormatA;
// For Windows Vista and above GetDurationFormatEx is preferred
int
GetDurationFormat(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpDuration,
    ULONGLONG ullDuration,
    LPCWSTR lpFormat,
    LPWSTR lpDurationStr,
    int cchDuration);
// For Windows Vista and above GetDateFormatEx is preferred
int
GetDateFormatA(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpDate,
    LPCSTR lpFormat,
    LPSTR lpDateStr,
    int cchDate);
// For Windows Vista and above GetDateFormatEx is preferred
int
GetDateFormatW(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate);
static const int GetDateFormat = GetDateFormatA;
// For Windows Vista and above GetNumberFormatEx is preferred
int
GetNumberFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    const NUMBERFMTA *lpFormat,
    LPSTR lpNumberStr,
    int cchNumber);
// For Windows Vista and above GetNumberFormatEx is preferred
int
GetNumberFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const NUMBERFMTW *lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber);
static const int GetNumberFormat = GetNumberFormatA;
// For Windows Vista and above GetCurrencyFormatEx is preferred
int
GetCurrencyFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    const CURRENCYFMTA *lpFormat,
    LPSTR lpCurrencyStr,
    int cchCurrency);
// For Windows Vista and above GetCurrencyFormatEx is preferred
int
GetCurrencyFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const CURRENCYFMTW *lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency);
static const int GetCurrencyFormat = GetCurrencyFormatA;
// For Windows Vista and above EnumCalendarInfoExEx is preferred
BOOL
EnumCalendarInfoA(
    CALINFO_ENUMPROCA lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);
// For Windows Vista and above EnumCalendarInfoExEx is preferred
BOOL
EnumCalendarInfoW(
    CALINFO_ENUMPROCW lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);
static const int EnumCalendarInfo = EnumCalendarInfoA;
// For Windows Vista and above EnumCalendarInfoExEx is preferred
BOOL
EnumCalendarInfoExA(
    CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);
// For Windows Vista and above EnumCalendarInfoExEx is preferred
BOOL
EnumCalendarInfoExW(
    CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);
static const int EnumCalendarInfoEx = EnumCalendarInfoExA;
// For Windows Vista and above EnumTimeFormatsEx is preferred
BOOL
EnumTimeFormatsA(
    TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);
// For Windows Vista and above EnumTimeFormatsEx is preferred
BOOL
EnumTimeFormatsW(
    TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);
static const int EnumTimeFormats = EnumTimeFormatsA;
// For Windows Vista and above EnumDateFormatsExEx is preferred
BOOL
EnumDateFormatsA(
    DATEFMT_ENUMPROCA lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);
// For Windows Vista and above EnumDateFormatsExEx is preferred
BOOL
EnumDateFormatsW(
    DATEFMT_ENUMPROCW lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);
static const int EnumDateFormats = EnumDateFormatsA;
// For Windows Vista and above EnumDateFormatsExEx is preferred
BOOL
EnumDateFormatsExA(
    DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
    LCID Locale,
    DWORD dwFlags);
// For Windows Vista and above EnumDateFormatsExEx is preferred
BOOL
EnumDateFormatsExW(
    DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
    LCID Locale,
    DWORD dwFlags);
static const int EnumDateFormatsEx = EnumDateFormatsExA;
BOOL
IsValidLanguageGroup(
    LGRPID LanguageGroup,
    DWORD dwFlags);
// For Windows Vista and above GetNLSVersionEx is preferred
BOOL
GetNLSVersion(
    NLS_FUNCTION Function,
    LCID Locale,
    LPNLSVERSIONINFO lpVersionInformation);
BOOL
IsNLSDefinedString(
    NLS_FUNCTION Function,
    DWORD dwFlags,
    LPNLSVERSIONINFO lpVersionInformation,
    LPCWSTR lpString,
    INT cchStr);
// For Windows Vista and above IsValidLocaleName is preferred
BOOL
IsValidLocale(
    LCID Locale,
    DWORD dwFlags);
int
GetGeoInfoA(
    GEOID Location,
    GEOTYPE GeoType,
    LPSTR lpGeoData,
    int cchData,
    LANGID LangId);
int
GetGeoInfoW(
    GEOID Location,
    GEOTYPE GeoType,
    LPWSTR lpGeoData,
    int cchData,
    LANGID LangId);
static const int GetGeoInfo = GetGeoInfoA;
BOOL
EnumSystemGeoID(
    GEOCLASS GeoClass,
    GEOID ParentGeoId,
    GEO_ENUMPROC lpGeoEnumProc);
GEOID
GetUserGeoID(
    GEOCLASS GeoClass);
BOOL
SetUserGeoID(
    GEOID GeoId);
LCID
ConvertDefaultLocale(
    LCID Locale);
LCID
GetThreadLocale(void);
BOOL
SetThreadLocale(
    LCID Locale
    );
LANGID
GetSystemDefaultUILanguage(void);
LANGID
GetUserDefaultUILanguage(void);
LANGID
GetSystemDefaultLangID(void);
LANGID
GetUserDefaultLangID(void);
LCID
GetSystemDefaultLCID(void);
LCID
GetUserDefaultLCID(void);
LANGID
SetThreadUILanguage( LANGID LangId);
LANGID
GetThreadUILanguage(void);
BOOL
GetProcessPreferredUILanguages(
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);
BOOL
SetProcessPreferredUILanguages(
    DWORD dwFlags,
    PCZZWSTR pwszLanguagesBuffer,
    PULONG pulNumLanguages
);
BOOL
GetUserPreferredUILanguages (
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);
BOOL
GetSystemPreferredUILanguages (
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);
BOOL
GetThreadPreferredUILanguages(
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);
BOOL
SetThreadPreferredUILanguages(
    DWORD dwFlags,
    PCZZWSTR pwszLanguagesBuffer,
    PULONG pulNumLanguages
);
BOOL
GetFileMUIInfo(
                        DWORD dwFlags,
    PCWSTR pcwszFilePath,
    PFILEMUIINFO pFileMUIInfo,
    DWORD* pcbFileMUIInfo);
BOOL
GetFileMUIPath(
    DWORD dwFlags,
    PCWSTR pcwszFilePath ,
    PWSTR pwszLanguage,
    PULONG pcchLanguage,
    PWSTR pwszFileMUIPath,
    PULONG pcchFileMUIPath,
    PULONGLONG pululEnumerator
);
BOOL
GetUILanguageInfo(
    DWORD dwFlags,
    PCZZWSTR pwmszLanguage,
    PZZWSTR pwszFallbackLanguages,
    PDWORD pcchFallbackLanguages,
    PDWORD pAttributes
);
BOOL
NotifyUILanguageChange(
    DWORD dwFlags,
    PCWSTR pcwstrNewLanguage,
    PCWSTR pcwstrPreviousLanguage,
    DWORD dwReserved,
    PDWORD pdwStatusRtrn
);
//
//  Locale Independent APIs.
//
BOOL
GetStringTypeExA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);
BOOL
GetStringTypeExW(
    LCID Locale,
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);
static const int GetStringTypeEx = GetStringTypeExA;
//
//  NOTE: The parameters for GetStringTypeA and GetStringTypeW are
//        NOT the same.  The W version was shipped in NT 3.1.  The
//        A version was then shipped in 16-bit OLE with the wrong
//        parameters (ported from Win95).  To be compatible, we
//        must break the relationship between the A and W versions
//        of GetStringType.  There will be NO function call for the
//        generic GetStringType.
//
//        GetStringTypeEx (above) should be used instead.
//
BOOL
GetStringTypeA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);
BOOL
GetStringTypeW(
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);
int
FoldStringA(
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);
int
FoldStringW(
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);
static const int FoldString = FoldStringA;
BOOL
EnumSystemLanguageGroupsA(
    LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);
BOOL
EnumSystemLanguageGroupsW(
    LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);
static const int EnumSystemLanguageGroups = EnumSystemLanguageGroupsA;
BOOL
EnumLanguageGroupLocalesA(
    LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam);
BOOL
EnumLanguageGroupLocalesW(
    LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam);
static const int EnumLanguageGroupLocales = EnumLanguageGroupLocalesA;
BOOL
EnumUILanguagesA(
    UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);
BOOL
EnumUILanguagesW(
    UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);
static const int EnumUILanguages = EnumUILanguagesA;
BOOL
EnumSystemLocalesA(
    LOCALE_ENUMPROCA lpLocaleEnumProc,
    DWORD dwFlags);
BOOL
EnumSystemLocalesW(
    LOCALE_ENUMPROCW lpLocaleEnumProc,
    DWORD dwFlags);
static const int EnumSystemLocales = EnumSystemLocalesA;
BOOL
EnumSystemCodePagesA(
    CODEPAGE_ENUMPROCA lpCodePageEnumProc,
    DWORD dwFlags);
BOOL
EnumSystemCodePagesW(
    CODEPAGE_ENUMPROCW lpCodePageEnumProc,
    DWORD dwFlags);
static const int EnumSystemCodePages = EnumSystemCodePagesA;
//
// Windows API Normalization Functions
//
int
 NormalizeString( NORM_FORM NormForm,
                        LPCWSTR lpSrcString,
                        int cwSrcLength,
                        LPWSTR lpDstString,
                        int cwDstLength );
BOOL
 IsNormalizedString( NORM_FORM NormForm,
                           LPCWSTR lpString,
                           int cwLength );
//
// IDN (International Domain Name) Functions
//
int
 IdnToAscii( DWORD dwFlags,
                  LPCWSTR lpUnicodeCharStr,
                  int cchUnicodeChar,
                  LPWSTR lpASCIICharStr,
                  int cchASCIIChar);
int
 IdnToNameprepUnicode( DWORD dwFlags,
                            LPCWSTR lpUnicodeCharStr,
                            int cchUnicodeChar,
                            LPWSTR lpNameprepCharStr,
                            int cchNameprepChar);
int
 IdnToUnicode( DWORD dwFlags,
                    LPCWSTR lpASCIICharStr,
                    int cchASCIIChar,
                    LPWSTR lpUnicodeCharStr,
                    int cchUnicodeChar);
BOOL
 VerifyScripts(
    DWORD dwFlags, // optional behavior flags
    LPCWSTR lpLocaleScripts, // Locale list of scripts string
    int cchLocaleScripts, // size of locale script list string
    LPCWSTR lpTestScripts, // test scripts string
    int cchTestScripts); // size of test list string
int
 GetStringScripts(
        DWORD dwFlags, // optional behavior flags
        LPCWSTR lpString, // Unicode character input string
        int cchString, // size of input string
        LPWSTR lpScripts, // Script list output string
        int cchScripts); // size of output string
//
// String based NLS APIs
//
static const int LOCALE_NAME_USER_DEFAULT = NULL;
static const char LOCALE_NAME_INVARIANT = L"";
static const char LOCALE_NAME_SYSTEM_DEFAULT = L"!x-sys-default-locale";
int
GetLocaleInfoEx(
    LPCWSTR lpLocaleName,
    LCTYPE LCType,
    LPWSTR lpLCData,
    int cchData
);
int
GetCalendarInfoEx(
    LPCWSTR lpLocaleName,
    CALID Calendar,
    LPCWSTR lpReserved,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue
);
int
GetTimeFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime
);
int
GetDateFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate,
    LPCWSTR lpCalendar
);
int
GetDurationFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME *lpDuration,
    ULONGLONG ullDuration,
    LPCWSTR lpFormat,
    LPWSTR lpDurationStr,
    int cchDuration
);
int
GetNumberFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const NUMBERFMTW *lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber
);
int
GetCurrencyFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const CURRENCYFMTW *lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency
);
int
GetUserDefaultLocaleName(
    LPWSTR lpLocaleName,
    int cchLocaleName
);
int
GetSystemDefaultLocaleName(
    LPWSTR lpLocaleName,
    int cchLocaleName
);
BOOL
GetNLSVersionEx(
    NLS_FUNCTION function,
    LPCWSTR lpLocaleName,
    LPNLSVERSIONINFOEX lpVersionInformation
);
int
CompareStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM lParam
);
int
FindNLSStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwFindNLSStringFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    LPINT pcchFound,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM lParam
);
int
LCMapStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM lParam
);
int
CompareStringOrdinal(
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    BOOL bIgnoreCase
);
BOOL
IsValidLocaleName(
    LPCWSTR lpLocaleName
);
typedef BOOL (* CALINFO_ENUMPROCEXEX)(LPWSTR, CALID, LPWSTR, LPARAM);
BOOL
EnumCalendarInfoExEx(
    CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx,
    LPCWSTR lpLocaleName,
    CALID Calendar,
    LPCWSTR lpReserved,
    CALTYPE CalType,
    LPARAM lParam
);
typedef BOOL (* DATEFMT_ENUMPROCEXEX)(LPWSTR, CALID, LPARAM);
BOOL
EnumDateFormatsExEx(
    DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx,
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPARAM lParam
);
typedef BOOL (* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);
BOOL
EnumTimeFormatsEx(
    TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx,
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPARAM lParam
);
typedef BOOL (* LOCALE_ENUMPROCEX)(LPWSTR, DWORD, LPARAM);
BOOL
EnumSystemLocalesEx(
    LOCALE_ENUMPROCEX lpLocaleEnumProcEx,
    DWORD dwFlags,
    LPARAM lParam,
    LPVOID lpReserved
);
int
ResolveLocaleName(
    LPCWSTR lpNameToResolve,
    LPWSTR lpLocaleName,
    int cchLocaleName
);
# 161 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wincon.h" 1
/*++ BUILD Version: 0002    // Increment this if a change has global effects
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    wincon.h
Abstract:
    This module contains the public data structures, data types,
    and procedures exported by the NT console subsystem.
Created:
    26-Oct-1990
Revision History:
--*/
# 23 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wincon.h"
# 35 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wincon.h"
typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;
typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;
typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;
//
// ControlKeyState flags
//
static const int RIGHT_ALT_PRESSED = 0x0001;
static const int LEFT_ALT_PRESSED = 0x0002;
static const int RIGHT_CTRL_PRESSED = 0x0004;
static const int LEFT_CTRL_PRESSED = 0x0008;
static const int SHIFT_PRESSED = 0x0010;
static const int NUMLOCK_ON = 0x0020;
static const int SCROLLLOCK_ON = 0x0040;
static const int CAPSLOCK_ON = 0x0080;
static const int ENHANCED_KEY = 0x0100;
static const int NLS_DBCSCHAR = 0x00010000;
static const int NLS_ALPHANUMERIC = 0x00000000;
static const int NLS_KATAKANA = 0x00020000;
static const int NLS_HIRAGANA = 0x00040000;
static const int NLS_ROMAN = 0x00400000;
static const int NLS_IME_CONVERSION = 0x00800000;
static const int NLS_IME_DISABLE = 0x20000000;
typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;
//
// ButtonState flags
//
static const int FROM_LEFT_1ST_BUTTON_PRESSED = 0x0001;
static const int RIGHTMOST_BUTTON_PRESSED = 0x0002;
static const int FROM_LEFT_2ND_BUTTON_PRESSED = 0x0004;
static const int FROM_LEFT_3RD_BUTTON_PRESSED = 0x0008;
static const int FROM_LEFT_4TH_BUTTON_PRESSED = 0x0010;
//
// EventFlags
//
static const int MOUSE_MOVED = 0x0001;
static const int DOUBLE_CLICK = 0x0002;
static const int MOUSE_WHEELED = 0x0004;
static const int MOUSE_HWHEELED = 0x0008;
typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;
typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;
typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;
typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;
//
//  EventType flags:
//
static const int KEY_EVENT = 0x0001;
static const int MOUSE_EVENT = 0x0002;
static const int WINDOW_BUFFER_SIZE_EVENT = 0x0004;
static const int MENU_EVENT = 0x0008;
static const int FOCUS_EVENT = 0x0010;
typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;
//
// Attributes flags:
//
static const int FOREGROUND_BLUE = 0x0001;
static const int FOREGROUND_GREEN = 0x0002;
static const int FOREGROUND_RED = 0x0004;
static const int FOREGROUND_INTENSITY = 0x0008;
static const int BACKGROUND_BLUE = 0x0010;
static const int BACKGROUND_GREEN = 0x0020;
static const int BACKGROUND_RED = 0x0040;
static const int BACKGROUND_INTENSITY = 0x0080;
static const int COMMON_LVB_LEADING_BYTE = 0x0100;
static const int COMMON_LVB_TRAILING_BYTE = 0x0200;
static const int COMMON_LVB_GRID_HORIZONTAL = 0x0400;
static const int COMMON_LVB_GRID_LVERTICAL = 0x0800;
static const int COMMON_LVB_GRID_RVERTICAL = 0x1000;
static const int COMMON_LVB_REVERSE_VIDEO = 0x4000;
static const int COMMON_LVB_UNDERSCORE = 0x8000;
static const int COMMON_LVB_SBCSDBCS = 0x0300;
typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;
typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;
typedef struct _CONSOLE_CURSOR_INFO {
    DWORD dwSize;
    BOOL bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;
typedef struct _CONSOLE_FONT_INFO {
    DWORD nFont;
    COORD dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;
typedef struct _CONSOLE_FONT_INFOEX {
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[32];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
static const int HISTORY_NO_DUP_FLAG = 0x1;
typedef struct _CONSOLE_HISTORY_INFO {
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;
typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;
//
// Selection flags
//
static const int CONSOLE_NO_SELECTION = 0x0000;
static const int CONSOLE_SELECTION_IN_PROGRESS = 0x0001;
static const int CONSOLE_SELECTION_NOT_EMPTY = 0x0002;
static const int CONSOLE_MOUSE_SELECTION = 0x0004;
static const int CONSOLE_MOUSE_DOWN = 0x0008;
//
// typedef for ctrl-c handler routines
//
typedef
BOOL
( *PHANDLER_ROUTINE)(
    DWORD CtrlType
    );
static const int CTRL_C_EVENT = 0;
static const int CTRL_BREAK_EVENT = 1;
static const int CTRL_CLOSE_EVENT = 2;
// 3 is reserved!
// 4 is reserved!
static const int CTRL_LOGOFF_EVENT = 5;
static const int CTRL_SHUTDOWN_EVENT = 6;
//
//  Input Mode flags:
//
static const int ENABLE_PROCESSED_INPUT = 0x0001;
static const int ENABLE_LINE_INPUT = 0x0002;
static const int ENABLE_ECHO_INPUT = 0x0004;
static const int ENABLE_WINDOW_INPUT = 0x0008;
static const int ENABLE_MOUSE_INPUT = 0x0010;
static const int ENABLE_INSERT_MODE = 0x0020;
static const int ENABLE_QUICK_EDIT_MODE = 0x0040;
static const int ENABLE_EXTENDED_FLAGS = 0x0080;
static const int ENABLE_AUTO_POSITION = 0x0100;
//
// Output Mode flags:
//
static const int ENABLE_PROCESSED_OUTPUT = 0x0001;
static const int ENABLE_WRAP_AT_EOL_OUTPUT = 0x0002;
//
// direct API definitions.
//
BOOL
PeekConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
BOOL
PeekConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
static const int PeekConsoleInput = PeekConsoleInputA;
BOOL
ReadConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
BOOL
ReadConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );
static const int ReadConsoleInput = ReadConsoleInputA;
BOOL
WriteConsoleInputA(
    HANDLE hConsoleInput,
    const INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
BOOL
WriteConsoleInputW(
    HANDLE hConsoleInput,
    const INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
static const int WriteConsoleInput = WriteConsoleInputA;
BOOL
ReadConsoleOutputA(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );
BOOL
ReadConsoleOutputW(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );
static const int ReadConsoleOutput = ReadConsoleOutputA;
BOOL
WriteConsoleOutputA(
    HANDLE hConsoleOutput,
    const CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );
BOOL
WriteConsoleOutputW(
    HANDLE hConsoleOutput,
    const CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );
static const int WriteConsoleOutput = WriteConsoleOutputA;
BOOL
ReadConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );
BOOL
ReadConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPWSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );
static const int ReadConsoleOutputCharacter = ReadConsoleOutputCharacterA;
BOOL
ReadConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    LPWORD lpAttribute,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfAttrsRead
    );
BOOL
WriteConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPCSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
BOOL
WriteConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPCWSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
static const int WriteConsoleOutputCharacter = WriteConsoleOutputCharacterA;
BOOL
WriteConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    const WORD *lpAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );
BOOL
FillConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    CHAR cCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
BOOL
FillConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    WCHAR cCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );
static const int FillConsoleOutputCharacter = FillConsoleOutputCharacterA;
BOOL
FillConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    WORD wAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );
BOOL
GetConsoleMode(
    HANDLE hConsoleHandle,
    LPDWORD lpMode
    );
BOOL
GetNumberOfConsoleInputEvents(
    HANDLE hConsoleInput,
    LPDWORD lpNumberOfEvents
    );
static const int CONSOLE_REAL_OUTPUT_HANDLE = (LongToHandle(-2));
static const int CONSOLE_REAL_INPUT_HANDLE = (LongToHandle(-3));
BOOL
GetConsoleScreenBufferInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );
BOOL
GetConsoleScreenBufferInfoEx(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
BOOL
SetConsoleScreenBufferInfoEx(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
COORD
GetLargestConsoleWindowSize(
    HANDLE hConsoleOutput
    );
BOOL
GetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );
BOOL
GetCurrentConsoleFont(
    HANDLE hConsoleOutput,
    BOOL bMaximumWindow,
    PCONSOLE_FONT_INFO lpConsoleCurrentFont
    );
BOOL
GetCurrentConsoleFontEx(
    HANDLE hConsoleOutput,
    BOOL bMaximumWindow,
    PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
BOOL
SetCurrentConsoleFontEx(
    HANDLE hConsoleOutput,
    BOOL bMaximumWindow,
    PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
BOOL
GetConsoleHistoryInfo(
    PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
BOOL
SetConsoleHistoryInfo(
    PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
COORD
GetConsoleFontSize(
    HANDLE hConsoleOutput,
    DWORD nFont
    );
BOOL
GetConsoleSelectionInfo(
    PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    );
BOOL
GetNumberOfConsoleMouseButtons(
    LPDWORD lpNumberOfMouseButtons
    );
BOOL
SetConsoleMode(
    HANDLE hConsoleHandle,
    DWORD dwMode
    );
BOOL
SetConsoleActiveScreenBuffer(
    HANDLE hConsoleOutput
    );
BOOL
FlushConsoleInputBuffer(
    HANDLE hConsoleInput
    );
BOOL
SetConsoleScreenBufferSize(
    HANDLE hConsoleOutput,
    COORD dwSize
    );
BOOL
SetConsoleCursorPosition(
    HANDLE hConsoleOutput,
    COORD dwCursorPosition
    );
BOOL
SetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );
BOOL
ScrollConsoleScreenBufferA(
    HANDLE hConsoleOutput,
    const SMALL_RECT *lpScrollRectangle,
    const SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    const CHAR_INFO *lpFill
    );
BOOL
ScrollConsoleScreenBufferW(
    HANDLE hConsoleOutput,
    const SMALL_RECT *lpScrollRectangle,
    const SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    const CHAR_INFO *lpFill
    );
static const int ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferA;
BOOL
SetConsoleWindowInfo(
    HANDLE hConsoleOutput,
    BOOL bAbsolute,
    const SMALL_RECT *lpConsoleWindow
    );
BOOL
SetConsoleTextAttribute(
    HANDLE hConsoleOutput,
    WORD wAttributes
    );
BOOL
SetConsoleCtrlHandler(
    PHANDLER_ROUTINE HandlerRoutine,
    BOOL Add);
BOOL
GenerateConsoleCtrlEvent(
    DWORD dwCtrlEvent,
    DWORD dwProcessGroupId);
BOOL
AllocConsole(
    void);
BOOL
FreeConsole(
    void);
BOOL
AttachConsole(
    DWORD dwProcessId);
static const int ATTACH_PARENT_PROCESS = ((DWORD)-1);
DWORD
GetConsoleTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize
    );
DWORD
GetConsoleTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize
    );
static const int GetConsoleTitle = GetConsoleTitleA;
DWORD
GetConsoleOriginalTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize);
DWORD
GetConsoleOriginalTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize);
static const int GetConsoleOriginalTitle = GetConsoleOriginalTitleA;
BOOL
SetConsoleTitleA(
    LPCSTR lpConsoleTitle
    );
BOOL
SetConsoleTitleW(
    LPCWSTR lpConsoleTitle
    );
static const int SetConsoleTitle = SetConsoleTitleA;
typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;
BOOL
ReadConsoleA(
    HANDLE hConsoleInput,
       LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    PCONSOLE_READCONSOLE_CONTROL pInputControl
    );
BOOL
ReadConsoleW(
    HANDLE hConsoleInput,
       LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    PCONSOLE_READCONSOLE_CONTROL pInputControl
    );
static const int ReadConsole = ReadConsoleA;
BOOL
WriteConsoleA(
    HANDLE hConsoleOutput,
    const void *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved);
BOOL
WriteConsoleW(
    HANDLE hConsoleOutput,
    const void *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved);
static const int WriteConsole = WriteConsoleA;
static const int CONSOLE_TEXTMODE_BUFFER = 1;
HANDLE
CreateConsoleScreenBuffer(
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    const SECURITY_ATTRIBUTES *lpSecurityAttributes,
    DWORD dwFlags,
    LPVOID lpScreenBufferData
    );
UINT
GetConsoleCP(
    void);
BOOL
SetConsoleCP(
    UINT wCodePageID
    );
UINT
GetConsoleOutputCP(
    void);
BOOL
SetConsoleOutputCP(
    UINT wCodePageID
    );
static const int CONSOLE_FULLSCREEN = 1;
static const int CONSOLE_FULLSCREEN_HARDWARE = 2;
BOOL
GetConsoleDisplayMode(
    LPDWORD lpModeFlags);
static const int CONSOLE_FULLSCREEN_MODE = 1;
static const int CONSOLE_WINDOWED_MODE = 2;
BOOL
SetConsoleDisplayMode(
    HANDLE hConsoleOutput,
    DWORD dwFlags,
    PCOORD lpNewScreenBufferDimensions);
HWND
GetConsoleWindow(
    void
    );
DWORD
GetConsoleProcessList(
    LPDWORD lpdwProcessList,
    DWORD dwProcessCount);
//
// Aliasing apis.
//
BOOL
AddConsoleAliasA(
    LPSTR Source,
    LPSTR Target,
    LPSTR ExeName);
BOOL
AddConsoleAliasW(
    LPWSTR Source,
    LPWSTR Target,
    LPWSTR ExeName);
static const int AddConsoleAlias = AddConsoleAliasA;
DWORD
GetConsoleAliasA(
    LPSTR Source,
    LPSTR TargetBuffer,
    DWORD TargetBufferLength,
    LPSTR ExeName);
DWORD
GetConsoleAliasW(
    LPWSTR Source,
    LPWSTR TargetBuffer,
    DWORD TargetBufferLength,
    LPWSTR ExeName);
static const int GetConsoleAlias = GetConsoleAliasA;
DWORD
GetConsoleAliasesLengthA(
    LPSTR ExeName);
DWORD
GetConsoleAliasesLengthW(
    LPWSTR ExeName);
static const int GetConsoleAliasesLength = GetConsoleAliasesLengthA;
DWORD
GetConsoleAliasExesLengthA(
    void);
DWORD
GetConsoleAliasExesLengthW(
    void);
static const int GetConsoleAliasExesLength = GetConsoleAliasExesLengthA;
DWORD
GetConsoleAliasesA(
    LPSTR AliasBuffer,
    DWORD AliasBufferLength,
    LPSTR ExeName);
DWORD
GetConsoleAliasesW(
    LPWSTR AliasBuffer,
    DWORD AliasBufferLength,
    LPWSTR ExeName);
static const int GetConsoleAliases = GetConsoleAliasesA;
DWORD
GetConsoleAliasExesA(
    LPSTR ExeNameBuffer,
    DWORD ExeNameBufferLength);
DWORD
GetConsoleAliasExesW(
    LPWSTR ExeNameBuffer,
    DWORD ExeNameBufferLength);
static const int GetConsoleAliasExes = GetConsoleAliasExesA;
# 164 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h" 1
/******************************************************************************                                                                             *
 *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                                             *
\*****************************************************************************/
# 15 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/SpecStrings.h" 1
# 18 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/verrsrc.h" 1
/******************************************************************************                                                                             *
 *
* verrsrc.h -   Version Resource definitions                                  *
*                                                                             *
*               Include file declaring version resources in rc files          *
*                                                                             *
*               Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                                             *
\*****************************************************************************/
# 11 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/verrsrc.h"
/* ----- Symbols ----- */
static const int VS_FILE_INFO = RT_VERSION;
static const int VS_VERSION_INFO = 1;
static const int VS_USER_DEFINED = 100;
/* ----- VS_VERSION.dwFileFlags ----- */
static const int VS_FFI_SIGNATURE = 0xFEEF04BDL;
static const long VS_FFI_STRUCVERSION = 0x00010000L;
static const int VS_FFI_FILEFLAGSMASK = 0x0000003FL;
/* ----- VS_VERSION.dwFileFlags ----- */
static const long VS_FF_DEBUG = 0x00000001L;
static const long VS_FF_PRERELEASE = 0x00000002L;
static const long VS_FF_PATCHED = 0x00000004L;
static const long VS_FF_PRIVATEBUILD = 0x00000008L;
static const long VS_FF_INFOINFERRED = 0x00000010L;
static const long VS_FF_SPECIALBUILD = 0x00000020L;
/* ----- VS_VERSION.dwFileOS ----- */
static const long VOS_UNKNOWN = 0x00000000L;
static const long VOS_DOS = 0x00010000L;
static const long VOS_OS216 = 0x00020000L;
static const long VOS_OS232 = 0x00030000L;
static const long VOS_NT = 0x00040000L;
static const long VOS_WINCE = 0x00050000L;
static const long VOS__BASE = 0x00000000L;
static const long VOS__WINDOWS16 = 0x00000001L;
static const long VOS__PM16 = 0x00000002L;
static const long VOS__PM32 = 0x00000003L;
static const long VOS__WINDOWS32 = 0x00000004L;
static const long VOS_DOS_WINDOWS16 = 0x00010001L;
static const long VOS_DOS_WINDOWS32 = 0x00010004L;
static const long VOS_OS216_PM16 = 0x00020002L;
static const long VOS_OS232_PM32 = 0x00030003L;
static const long VOS_NT_WINDOWS32 = 0x00040004L;
/* ----- VS_VERSION.dwFileType ----- */
static const long VFT_UNKNOWN = 0x00000000L;
static const long VFT_APP = 0x00000001L;
static const long VFT_DLL = 0x00000002L;
static const long VFT_DRV = 0x00000003L;
static const long VFT_FONT = 0x00000004L;
static const long VFT_VXD = 0x00000005L;
static const long VFT_STATIC_LIB = 0x00000007L;
/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
static const long VFT2_UNKNOWN = 0x00000000L;
static const long VFT2_DRV_PRINTER = 0x00000001L;
static const long VFT2_DRV_KEYBOARD = 0x00000002L;
static const long VFT2_DRV_LANGUAGE = 0x00000003L;
static const long VFT2_DRV_DISPLAY = 0x00000004L;
static const long VFT2_DRV_MOUSE = 0x00000005L;
static const long VFT2_DRV_NETWORK = 0x00000006L;
static const long VFT2_DRV_SYSTEM = 0x00000007L;
static const long VFT2_DRV_INSTALLABLE = 0x00000008L;
static const long VFT2_DRV_SOUND = 0x00000009L;
static const int VFT2_DRV_COMM = 0x0000000AL;
static const int VFT2_DRV_INPUTMETHOD = 0x0000000BL;
static const int VFT2_DRV_VERSIONED_PRINTER = 0x0000000CL;
/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
static const long VFT2_FONT_RASTER = 0x00000001L;
static const long VFT2_FONT_VECTOR = 0x00000002L;
static const long VFT2_FONT_TRUETYPE = 0x00000003L;
/* ----- VerFindFile() flags ----- */
static const int VFFF_ISSHAREDFILE = 0x0001;
static const int VFF_CURNEDEST = 0x0001;
static const int VFF_FILEINUSE = 0x0002;
static const int VFF_BUFFTOOSMALL = 0x0004;
/* ----- VerInstallFile() flags ----- */
static const int VIFF_FORCEINSTALL = 0x0001;
static const int VIFF_DONTDELETEOLD = 0x0002;
static const long VIF_TEMPFILE = 0x00000001L;
static const long VIF_MISMATCH = 0x00000002L;
static const long VIF_SRCOLD = 0x00000004L;
static const long VIF_DIFFLANG = 0x00000008L;
static const long VIF_DIFFCODEPG = 0x00000010L;
static const long VIF_DIFFTYPE = 0x00000020L;
static const long VIF_WRITEPROT = 0x00000040L;
static const long VIF_FILEINUSE = 0x00000080L;
static const long VIF_OUTOFSPACE = 0x00000100L;
static const long VIF_ACCESSVIOLATION = 0x00000200L;
static const long VIF_SHARINGVIOLATION = 0x00000400L;
static const long VIF_CANNOTCREATE = 0x00000800L;
static const long VIF_CANNOTDELETE = 0x00001000L;
static const long VIF_CANNOTRENAME = 0x00002000L;
static const long VIF_CANNOTDELETECUR = 0x00004000L;
static const long VIF_OUTOFMEMORY = 0x00008000L;
static const long VIF_CANNOTREADSRC = 0x00010000L;
static const long VIF_CANNOTREADDST = 0x00020000L;
static const long VIF_BUFFTOOSMALL = 0x00040000L;
static const long VIF_CANNOTLOADLZ32 = 0x00080000L;
static const long VIF_CANNOTLOADCABINET = 0x00100000L;
/* 
    FILE_VER_GET_... flags are for use by 
    GetFileVersionInfoSizeEx
    GetFileVersionInfoExW
*/
# 130 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/verrsrc.h"
static const int FILE_VER_GET_LOCALISED = 0x01;
static const int FILE_VER_GET_NEUTRAL = 0x02;
static const int FILE_VER_GET_PREFETCHED = 0x04;
/* ----- Types and structures ----- */
typedef struct tagVS_FIXEDFILEINFO
{
    DWORD dwSignature; /* e.g. 0xfeef04bd */
    DWORD dwStrucVersion; /* e.g. 0x00000042 = "0.42" */
    DWORD dwFileVersionMS; /* e.g. 0x00030075 = "3.75" */
    DWORD dwFileVersionLS; /* e.g. 0x00000031 = "0.31" */
    DWORD dwProductVersionMS; /* e.g. 0x00030010 = "3.10" */
    DWORD dwProductVersionLS; /* e.g. 0x00000031 = "0.31" */
    DWORD dwFileFlagsMask; /* = 0x3F for version "0.42" */
    DWORD dwFileFlags; /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD dwFileOS; /* e.g. VOS_DOS_WINDOWS16 */
    DWORD dwFileType; /* e.g. VFT_DRIVER */
    DWORD dwFileSubtype; /* e.g. VFT2_DRV_KEYBOARD */
    DWORD dwFileDateMS; /* e.g. 0 */
    DWORD dwFileDateLS; /* e.g. 0 */
} VS_FIXEDFILEINFO;
# 19 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h" 2
# 28 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h"
/* ----- Function prototypes ----- */
DWORD
VerFindFileA(
        DWORD uFlags,
        LPCSTR szFileName,
        LPCSTR szWinDir,
        LPCSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
VerFindFileW(
        DWORD uFlags,
        LPCWSTR szFileName,
        LPCWSTR szWinDir,
        LPCWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
static const int VerFindFile = VerFindFileA;
DWORD
VerInstallFileA(
        DWORD uFlags,
        LPCSTR szSrcFileName,
        LPCSTR szDestFileName,
        LPCSTR szSrcDir,
        LPCSTR szDestDir,
        LPCSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
VerInstallFileW(
        DWORD uFlags,
        LPCWSTR szSrcFileName,
        LPCWSTR szDestFileName,
        LPCWSTR szSrcDir,
        LPCWSTR szDestDir,
        LPCWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
static const int VerInstallFile = VerInstallFileA;
/* Returns size of version info in bytes */
DWORD
GetFileVersionInfoSizeA(
        LPCSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle /* Information for use by GetFileVersionInfo */
        );
/* Returns size of version info in bytes */
DWORD
GetFileVersionInfoSizeW(
        LPCWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle /* Information for use by GetFileVersionInfo */
        );
static const int GetFileVersionInfoSize = GetFileVersionInfoSizeA;
/* Read version info into buffer */
BOOL
GetFileVersionInfoA(
        LPCSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle, /* Information from GetFileVersionSize */
        DWORD dwLen, /* Length of buffer for info */
        LPVOID lpData /* Buffer to place the data structure */
        );
/* Read version info into buffer */
BOOL
GetFileVersionInfoW(
        LPCWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle, /* Information from GetFileVersionSize */
        DWORD dwLen, /* Length of buffer for info */
        LPVOID lpData /* Buffer to place the data structure */
        );
static const int GetFileVersionInfo = GetFileVersionInfoA;
DWORD GetFileVersionInfoSizeExA( DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle);
DWORD GetFileVersionInfoSizeExW( DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle);
static const int GetFileVersionInfoSizeEx = GetFileVersionInfoSizeExA;
BOOL GetFileVersionInfoExA( DWORD dwFlags,
                                    LPCSTR lpwstrFilename,
                                    DWORD dwHandle,
                                    DWORD dwLen,
                                    LPVOID lpData);
BOOL GetFileVersionInfoExW( DWORD dwFlags,
                                    LPCWSTR lpwstrFilename,
                                    DWORD dwHandle,
                                    DWORD dwLen,
                                    LPVOID lpData);
static const int GetFileVersionInfoEx = GetFileVersionInfoExA;
DWORD
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD cchLang
        );
DWORD
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD cchLang
        );
static const int VerLanguageName = VerLanguageNameA;
BOOL
VerQueryValueA(
        LPCVOID pBlock,
        LPCSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
VerQueryValueW(
        LPCVOID pBlock,
        LPCWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
static const int VerQueryValue = VerQueryValueA;
# 165 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h" 1
/*++ BUILD Version: 0001    // Increment this if a change has global effects
Copyright (c) Microsoft Corporation.  All rights reserved.
Module Name:
    Winreg.h
Abstract:
    This module contains the function prototypes and constant, type and
    structure definitions for the Windows 32-Bit Registry API.
--*/
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h"
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h"
//
// RRF - Registry Routine Flags (for RegGetValue)
//
static const int RRF_RT_REG_NONE = 0x00000001;
static const int RRF_RT_REG_SZ = 0x00000002;
static const int RRF_RT_REG_EXPAND_SZ = 0x00000004;
static const int RRF_RT_REG_BINARY = 0x00000008;
static const int RRF_RT_REG_DWORD = 0x00000010;
static const int RRF_RT_REG_MULTI_SZ = 0x00000020;
static const int RRF_RT_REG_QWORD = 0x00000040;
static const int RRF_RT_DWORD = (RRF_RT_REG_BINARY | RRF_RT_REG_DWORD);
static const int RRF_RT_QWORD = (RRF_RT_REG_BINARY | RRF_RT_REG_QWORD);
static const int RRF_RT_ANY = 0x0000ffff;
static const int RRF_NOEXPAND = 0x10000000;
static const int RRF_ZEROONFAILURE = 0x20000000;
//
// Flags for RegLoadAppKey
//
static const int REG_PROCESS_APPKEY = 0x00000001;
//
// Flags for RegLoadMUIString
//
static const int REG_MUI_STRING_TRUNCATE = 0x00000001;
//
// Requested Key access mask type.
//
typedef ACCESS_MASK REGSAM;
//
// Reserved Key Handles.
//
static const int HKEY_CLASSES_ROOT = (( HKEY ) (ULONG_PTR)((LONG)0x80000000) );
static const int HKEY_CURRENT_USER = (( HKEY ) (ULONG_PTR)((LONG)0x80000001) );
static const int HKEY_LOCAL_MACHINE = (( HKEY ) (ULONG_PTR)((LONG)0x80000002) );
static const int HKEY_USERS = (( HKEY ) (ULONG_PTR)((LONG)0x80000003) );
static const int HKEY_PERFORMANCE_DATA = (( HKEY ) (ULONG_PTR)((LONG)0x80000004) );
static const int HKEY_PERFORMANCE_TEXT = (( HKEY ) (ULONG_PTR)((LONG)0x80000050) );
static const int HKEY_PERFORMANCE_NLSTEXT = (( HKEY ) (ULONG_PTR)((LONG)0x80000060) );
static const int HKEY_CURRENT_CONFIG = (( HKEY ) (ULONG_PTR)((LONG)0x80000005) );
static const int HKEY_DYN_DATA = (( HKEY ) (ULONG_PTR)((LONG)0x80000006) );
static const int HKEY_CURRENT_USER_LOCAL_SETTINGS = (( HKEY ) (ULONG_PTR)((LONG)0x80000007) );
//
// RegConnectRegistryEx supported flags
//
static const int REG_SECURE_CONNECTION = 1;
/*NOINC*/
static const int PROVIDER_KEEPS_VALUE_LENGTH = 0x1;
struct val_context {
    int valuelen; // the total length of this value
    LPVOID value_context; // provider's context
    LPVOID val_buff_ptr; // where in the ouput buffer the value is.
};
typedef struct val_context *PVALCONTEXT;
typedef struct pvalueA { // Provider supplied value/context.
    LPSTR pv_valuename; // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA, *PPVALUEA;
typedef struct pvalueW { // Provider supplied value/context.
    LPWSTR pv_valuename; // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW, *PPVALUEW;
typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
typedef
DWORD
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD *total_outlen, DWORD input_blen);
typedef QUERYHANDLER *PQUERYHANDLER;
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags; // capability flags (none defined yet).
    LPVOID pi_key_context;
}REG_PROVIDER;
typedef struct provider_info *PPROVIDER;
typedef struct value_entA {
    LPSTR ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA, *PVALENTA;
typedef struct value_entW {
    LPWSTR ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW, *PVALENTW;
typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
/*INC*/
//
// Default values for parameters that do not exist in the Win 3.1
// compatible APIs.
//
static const int WIN31_CLASS = NULL;
//
// API Prototypes.
//
typedef LONG LSTATUS;
LSTATUS
RegCloseKey (
    HKEY hKey
    );
LSTATUS
RegOverridePredefKey (
    HKEY hKey,
    HKEY hNewHKey
    );
LSTATUS
RegOpenUserClassesRoot(
    HANDLE hToken,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );
LSTATUS
RegOpenCurrentUser(
    REGSAM samDesired,
    PHKEY phkResult
    );
LSTATUS
RegDisablePredefinedCache(
    void
    );
LSTATUS
RegDisablePredefinedCacheEx(
    void
    );
LSTATUS
RegConnectRegistryA (
    LPCSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );
LSTATUS
RegConnectRegistryW (
    LPCWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );
static const int RegConnectRegistry = RegConnectRegistryA;
LSTATUS
RegConnectRegistryExA (
    LPCSTR lpMachineName,
    HKEY hKey,
    ULONG Flags,
    PHKEY phkResult
    );
LSTATUS
RegConnectRegistryExW (
    LPCWSTR lpMachineName,
    HKEY hKey,
    ULONG Flags,
    PHKEY phkResult
    );
static const int RegConnectRegistryEx = RegConnectRegistryExA;
LSTATUS
RegCreateKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );
LSTATUS
RegCreateKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );
static const int RegCreateKey = RegCreateKeyA;
LSTATUS
RegCreateKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );
LSTATUS
RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );
static const int RegCreateKeyEx = RegCreateKeyExA;
LSTATUS
RegCreateKeyTransactedA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );
LSTATUS
RegCreateKeyTransactedW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );
static const int RegCreateKeyTransacted = RegCreateKeyTransactedA;
LSTATUS
RegDeleteKeyA (
    HKEY hKey,
    LPCSTR lpSubKey
    );
LSTATUS
RegDeleteKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );
static const int RegDeleteKey = RegDeleteKeyA;
LSTATUS
RegDeleteKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved
    );
LSTATUS
RegDeleteKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved
    );
static const int RegDeleteKeyEx = RegDeleteKeyExA;
LSTATUS
RegDeleteKeyTransactedA (
    HKEY hKey,
    LPCSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved,
    HANDLE hTransaction,
    PVOID pExtendedParameter
    );
LSTATUS
RegDeleteKeyTransactedW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved,
    HANDLE hTransaction,
    PVOID pExtendedParameter
    );
static const int RegDeleteKeyTransacted = RegDeleteKeyTransactedA;
LONG
RegDisableReflectionKey (
    HKEY hBase
    );
LONG
RegEnableReflectionKey (
    HKEY hBase
    );
LONG
RegQueryReflectionKey (
    HKEY hBase,
    BOOL *bIsReflectionDisabled
    );
LSTATUS
RegDeleteValueA (
    HKEY hKey,
    LPCSTR lpValueName
    );
LSTATUS
RegDeleteValueW (
    HKEY hKey,
    LPCWSTR lpValueName
    );
static const int RegDeleteValue = RegDeleteValueA;
LSTATUS
RegEnumKeyA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cchName
    );
LSTATUS
RegEnumKeyW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cchName
    );
static const int RegEnumKey = RegEnumKeyA;
LSTATUS
RegEnumKeyExA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcchName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcchClass,
    PFILETIME lpftLastWriteTime
    );
LSTATUS
RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcchName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcchClass,
    PFILETIME lpftLastWriteTime
    );
static const int RegEnumKeyEx = RegEnumKeyExA;
LSTATUS
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
LSTATUS
RegEnumValueW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
static const int RegEnumValue = RegEnumValueA;
LSTATUS
RegFlushKey (
    HKEY hKey
    );
LSTATUS
RegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    );
LSTATUS
RegLoadKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpFile
    );
LSTATUS
RegLoadKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpFile
    );
static const int RegLoadKey = RegLoadKeyA;
LSTATUS
RegNotifyChangeKeyValue (
    HKEY hKey,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    HANDLE hEvent,
    BOOL fAsynchronous
    );
LSTATUS
RegOpenKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );
LSTATUS
RegOpenKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );
static const int RegOpenKey = RegOpenKeyA;
LSTATUS
RegOpenKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );
LSTATUS
RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );
static const int RegOpenKeyEx = RegOpenKeyExA;
LSTATUS
RegOpenKeyTransactedA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );
LSTATUS
RegOpenKeyTransactedW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );
static const int RegOpenKeyTransacted = RegOpenKeyTransactedA;
LSTATUS
RegQueryInfoKeyA (
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcchClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );
LSTATUS
RegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcchClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );
static const int RegQueryInfoKey = RegQueryInfoKeyA;
LSTATUS
RegQueryValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    );
LSTATUS
RegQueryValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG lpcbData
    );
static const int RegQueryValue = RegQueryValueA;
LSTATUS
RegQueryMultipleValuesA (
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );
LSTATUS
RegQueryMultipleValuesW (
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );
static const int RegQueryMultipleValues = RegQueryMultipleValuesA;
LSTATUS
RegQueryValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
LSTATUS
RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );
static const int RegQueryValueEx = RegQueryValueExA;
LSTATUS
RegReplaceKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpNewFile,
    LPCSTR lpOldFile
    );
LSTATUS
RegReplaceKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpNewFile,
    LPCWSTR lpOldFile
    );
static const int RegReplaceKey = RegReplaceKeyA;
LSTATUS
RegRestoreKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    DWORD dwFlags
    );
LSTATUS
RegRestoreKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    DWORD dwFlags
    );
static const int RegRestoreKey = RegRestoreKeyA;
LSTATUS
RegRenameKey(
    HKEY hKey,
    LPCWSTR lpSubKeyName,
    LPCWSTR lpNewKeyName
    );
LSTATUS
RegSaveKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
LSTATUS
RegSaveKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
static const int RegSaveKey = RegSaveKeyA;
LSTATUS
RegSetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
LSTATUS
RegSetValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );
LSTATUS
RegSetValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );
static const int RegSetValue = RegSetValueA;
LSTATUS
RegSetValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    const BYTE* lpData,
    DWORD cbData
    );
LSTATUS
RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    const BYTE* lpData,
    DWORD cbData
    );
static const int RegSetValueEx = RegSetValueExA;
LSTATUS
RegUnLoadKeyA (
    HKEY hKey,
    LPCSTR lpSubKey
    );
LSTATUS
RegUnLoadKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );
static const int RegUnLoadKey = RegUnLoadKeyA;
//
// Utils wrappers
//
LSTATUS
RegDeleteKeyValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpValueName
    );
LSTATUS
RegDeleteKeyValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName
    );
static const int RegDeleteKeyValue = RegDeleteKeyValueA;
LSTATUS
RegSetKeyValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpValueName,
    DWORD dwType,
    LPCVOID lpData,
    DWORD cbData
    );
LSTATUS
RegSetKeyValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName,
    DWORD dwType,
    LPCVOID lpData,
    DWORD cbData
    );
static const int RegSetKeyValue = RegSetKeyValueA;
LSTATUS
RegDeleteTreeA (
    HKEY hKey,
    LPCSTR lpSubKey
    );
LSTATUS
RegDeleteTreeW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );
static const int RegDeleteTree = RegDeleteTreeA;
LSTATUS
RegCopyTreeA (
    HKEY hKeySrc,
    LPCSTR lpSubKey,
    HKEY hKeyDest
    );
LSTATUS
RegCopyTreeW (
    HKEY hKeySrc,
    LPCWSTR lpSubKey,
    HKEY hKeyDest
    );
static const int RegCopyTree = RegCopyTreeA;
LSTATUS
RegGetValueA (
    HKEY hkey,
    LPCSTR lpSubKey,
    LPCSTR lpValue,
    DWORD dwFlags,
    LPDWORD pdwType,
    PVOID pvData,
    LPDWORD pcbData
    );
LSTATUS
RegGetValueW (
    HKEY hkey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValue,
    DWORD dwFlags,
    LPDWORD pdwType,
    PVOID pvData,
    LPDWORD pcbData
    );
static const int RegGetValue = RegGetValueA;
LSTATUS
RegLoadMUIStringA (
                    HKEY hKey,
                    LPCSTR pszValue,
                    LPSTR pszOutBuf,
                    DWORD cbOutBuf,
                    LPDWORD pcbData,
                    DWORD Flags,
                    LPCSTR pszDirectory
                    );
LSTATUS
RegLoadMUIStringW (
                    HKEY hKey,
                    LPCWSTR pszValue,
                    LPWSTR pszOutBuf,
                    DWORD cbOutBuf,
                    LPDWORD pcbData,
                    DWORD Flags,
                    LPCWSTR pszDirectory
                    );
static const int RegLoadMUIString = RegLoadMUIStringA;
LSTATUS
RegLoadAppKeyA (
        LPCSTR lpFile,
        PHKEY phkResult,
        REGSAM samDesired,
        DWORD dwOptions,
        DWORD Reserved
    );
LSTATUS
RegLoadAppKeyW (
        LPCWSTR lpFile,
        PHKEY phkResult,
        REGSAM samDesired,
        DWORD dwOptions,
        DWORD Reserved
    );
static const int RegLoadAppKey = RegLoadAppKeyA;
//
// Remoteable System Shutdown APIs
//
BOOL
InitiateSystemShutdownA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );
BOOL
InitiateSystemShutdownW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );
static const int InitiateSystemShutdown = InitiateSystemShutdownA;
BOOL
AbortSystemShutdownA(
    LPSTR lpMachineName
    );
BOOL
AbortSystemShutdownW(
    LPWSTR lpMachineName
    );
static const int AbortSystemShutdown = AbortSystemShutdownA;
//
// defines for InitiateSystemShutdownEx reason codes
//
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h" 1
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:        reason.h
//
//  Contents:    Shutdown reason code values.
//
//  History:     8-00        Created         Hughleat
//
//--------------------------------------------------------------------
// Reason flags
// Flags used by the various UIs.
static const int SHTDN_REASON_FLAG_COMMENT_REQUIRED = 0x01000000;
static const int SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED = 0x02000000;
static const int SHTDN_REASON_FLAG_CLEAN_UI = 0x04000000;
static const int SHTDN_REASON_FLAG_DIRTY_UI = 0x08000000;
// Flags that end up in the event log code.
static const int SHTDN_REASON_FLAG_USER_DEFINED = 0x40000000;
static const int SHTDN_REASON_FLAG_PLANNED = 0x80000000;
// Microsoft major reasons.
static const int SHTDN_REASON_MAJOR_OTHER = 0x00000000;
static const int SHTDN_REASON_MAJOR_NONE = 0x00000000;
static const int SHTDN_REASON_MAJOR_HARDWARE = 0x00010000;
static const int SHTDN_REASON_MAJOR_OPERATINGSYSTEM = 0x00020000;
static const int SHTDN_REASON_MAJOR_SOFTWARE = 0x00030000;
static const int SHTDN_REASON_MAJOR_APPLICATION = 0x00040000;
static const int SHTDN_REASON_MAJOR_SYSTEM = 0x00050000;
static const int SHTDN_REASON_MAJOR_POWER = 0x00060000;
static const int SHTDN_REASON_MAJOR_LEGACY_API = 0x00070000;
// Microsoft minor reasons.
static const int SHTDN_REASON_MINOR_OTHER = 0x00000000;
static const int SHTDN_REASON_MINOR_NONE = 0x000000ff;
static const int SHTDN_REASON_MINOR_MAINTENANCE = 0x00000001;
static const int SHTDN_REASON_MINOR_INSTALLATION = 0x00000002;
static const int SHTDN_REASON_MINOR_UPGRADE = 0x00000003;
static const int SHTDN_REASON_MINOR_RECONFIG = 0x00000004;
static const int SHTDN_REASON_MINOR_HUNG = 0x00000005;
static const int SHTDN_REASON_MINOR_UNSTABLE = 0x00000006;
static const int SHTDN_REASON_MINOR_DISK = 0x00000007;
static const int SHTDN_REASON_MINOR_PROCESSOR = 0x00000008;
static const int SHTDN_REASON_MINOR_NETWORKCARD = 0x00000009;
static const int SHTDN_REASON_MINOR_POWER_SUPPLY = 0x0000000a;
static const int SHTDN_REASON_MINOR_CORDUNPLUGGED = 0x0000000b;
static const int SHTDN_REASON_MINOR_ENVIRONMENT = 0x0000000c;
static const int SHTDN_REASON_MINOR_HARDWARE_DRIVER = 0x0000000d;
static const int SHTDN_REASON_MINOR_OTHERDRIVER = 0x0000000e;
static const double SHTDN_REASON_MINOR_BLUESCREEN = 0x0000000F;
static const int SHTDN_REASON_MINOR_SERVICEPACK = 0x00000010;
static const int SHTDN_REASON_MINOR_HOTFIX = 0x00000011;
static const int SHTDN_REASON_MINOR_SECURITYFIX = 0x00000012;
static const int SHTDN_REASON_MINOR_SECURITY = 0x00000013;
static const int SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY = 0x00000014;
static const int SHTDN_REASON_MINOR_WMI = 0x00000015;
static const int SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL = 0x00000016;
static const int SHTDN_REASON_MINOR_HOTFIX_UNINSTALL = 0x00000017;
static const int SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL = 0x00000018;
static const int SHTDN_REASON_MINOR_MMC = 0x00000019;
static const int SHTDN_REASON_MINOR_SYSTEMRESTORE = 0x0000001a;
static const int SHTDN_REASON_MINOR_TERMSRV = 0x00000020;
static const int SHTDN_REASON_MINOR_DC_PROMOTION = 0x00000021;
static const int SHTDN_REASON_MINOR_DC_DEMOTION = 0x00000022;
static const int SHTDN_REASON_UNKNOWN = SHTDN_REASON_MINOR_NONE;
static const int SHTDN_REASON_LEGACY_API = (SHTDN_REASON_MAJOR_LEGACY_API | SHTDN_REASON_FLAG_PLANNED);
// This mask cuts out UI flags.
static const int SHTDN_REASON_VALID_BIT_MASK = 0xc0ffffff;
// Convenience flags.
static const int PCLEANUI = (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_CLEAN_UI);
static const int UCLEANUI = (SHTDN_REASON_FLAG_CLEAN_UI);
static const int PDIRTYUI = (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_DIRTY_UI);
static const int UDIRTYUI = (SHTDN_REASON_FLAG_DIRTY_UI);
/*
 * Maximum character lengths for reason name, description, problem id, and
 * comment respectively.
 */
# 89 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
static const int MAX_REASON_NAME_LEN = 64;
static const int MAX_REASON_DESC_LEN = 256;
static const int MAX_REASON_BUGID_LEN = 32;
static const int MAX_REASON_COMMENT_LEN = 512;
static const int SHUTDOWN_TYPE_LEN = 32;
/*
 *	S.E.T. policy value
 *
 */
# 99 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
static const int POLICY_SHOWREASONUI_NEVER = 0;
static const int POLICY_SHOWREASONUI_ALWAYS = 1;
static const int POLICY_SHOWREASONUI_WORKSTATIONONLY = 2;
static const int POLICY_SHOWREASONUI_SERVERONLY = 3;
/*
 * Snapshot policy values
 */
# 108 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
static const int SNAPSHOT_POLICY_NEVER = 0;
static const int SNAPSHOT_POLICY_ALWAYS = 1;
static const int SNAPSHOT_POLICY_UNPLANNED = 2;
/*
 * Maximue user defined reasons
 */
# 115 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
static const int MAX_NUM_REASONS = 256;
# 1223 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h" 2
//
// Then for Historical reasons support some old symbols, internal only
static const int REASON_SWINSTALL = (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_INSTALLATION);
static const int REASON_HWINSTALL = (SHTDN_REASON_MAJOR_HARDWARE|SHTDN_REASON_MINOR_INSTALLATION);
static const int REASON_SERVICEHANG = (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_HUNG);
static const int REASON_UNSTABLE = (SHTDN_REASON_MAJOR_SYSTEM|SHTDN_REASON_MINOR_UNSTABLE);
static const int REASON_SWHWRECONF = (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_RECONFIG);
static const int REASON_OTHER = (SHTDN_REASON_MAJOR_OTHER|SHTDN_REASON_MINOR_OTHER);
static const int REASON_UNKNOWN = SHTDN_REASON_UNKNOWN;
static const int REASON_LEGACY_API = SHTDN_REASON_LEGACY_API;
static const int REASON_PLANNED_FLAG = SHTDN_REASON_FLAG_PLANNED;
//
// MAX Shutdown TimeOut == 10 Years in seconds
//
static const int MAX_SHUTDOWN_TIMEOUT = (10*365*24*60*60);
BOOL
InitiateSystemShutdownExA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown,
    DWORD dwReason
    );
BOOL
InitiateSystemShutdownExW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown,
    DWORD dwReason
    );
static const int InitiateSystemShutdownEx = InitiateSystemShutdownExA;
//
// Shutdown flags
//
static const int SHUTDOWN_FORCE_OTHERS = 0x00000001;
static const int SHUTDOWN_FORCE_SELF = 0x00000002;
static const int SHUTDOWN_RESTART = 0x00000004;
static const int SHUTDOWN_POWEROFF = 0x00000008;
static const int SHUTDOWN_NOREBOOT = 0x00000010;
static const int SHUTDOWN_GRACE_OVERRIDE = 0x00000020;
static const int SHUTDOWN_INSTALL_UPDATES = 0x00000040;
static const int SHUTDOWN_RESTARTAPPS = 0x00000080;
static const int SHUTDOWN_SKIP_SVC_PRESHUTDOWN = 0x00000100;
DWORD
InitiateShutdownA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwGracePeriod,
    DWORD dwShutdownFlags,
    DWORD dwReason
    );
DWORD
InitiateShutdownW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwGracePeriod,
    DWORD dwShutdownFlags,
    DWORD dwReason
    );
static const int InitiateShutdown = InitiateShutdownA;
LSTATUS
RegSaveKeyExA (
    HKEY hKey,
    LPCSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD Flags
    );
LSTATUS
RegSaveKeyExW (
    HKEY hKey,
    LPCWSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD Flags
    );
static const int RegSaveKeyEx = RegSaveKeyExA;
# 168 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h" 1
/*++
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    winnetwk.h
Abstract:
    Standard WINNET Header File for WIN32
Environment:
    User Mode -Win32
Notes:
    optional-notes
--*/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h"
//
// Network types
//
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wnnc.h" 1
/*++
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    wnnc.h
Abstract:
    This header provides the Windows Networking WNNC_NET definitions to winnetwk.h
    and the IFS Kit.
Environment:
    User Mode / Kernel Mode
Notes:
--*/
# 22 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wnnc.h"
// begin_ntifs
//
// Network types
//
static const int WNNC_NET_MSNET = 0x00010000;
static const int WNNC_NET_SMB = 0x00020000;
static const int WNNC_NET_NETWARE = 0x00030000;
static const int WNNC_NET_VINES = 0x00040000;
static const int WNNC_NET_10NET = 0x00050000;
static const int WNNC_NET_LOCUS = 0x00060000;
static const int WNNC_NET_SUN_PC_NFS = 0x00070000;
static const int WNNC_NET_LANSTEP = 0x00080000;
static const int WNNC_NET_9TILES = 0x00090000;
static const int WNNC_NET_LANTASTIC = 0x000A0000;
static const int WNNC_NET_AS400 = 0x000B0000;
static const int WNNC_NET_FTP_NFS = 0x000C0000;
static const int WNNC_NET_PATHWORKS = 0x000D0000;
static const int WNNC_NET_LIFENET = 0x000E0000;
static const int WNNC_NET_POWERLAN = 0x000F0000;
static const int WNNC_NET_BWNFS = 0x00100000;
static const int WNNC_NET_COGENT = 0x00110000;
static const int WNNC_NET_FARALLON = 0x00120000;
static const int WNNC_NET_APPLETALK = 0x00130000;
static const int WNNC_NET_INTERGRAPH = 0x00140000;
static const int WNNC_NET_SYMFONET = 0x00150000;
static const int WNNC_NET_CLEARCASE = 0x00160000;
static const int WNNC_NET_FRONTIER = 0x00170000;
static const int WNNC_NET_BMC = 0x00180000;
static const int WNNC_NET_DCE = 0x00190000;
static const int WNNC_NET_AVID = 0x001A0000;
static const int WNNC_NET_DOCUSPACE = 0x001B0000;
static const int WNNC_NET_MANGOSOFT = 0x001C0000;
static const int WNNC_NET_SERNET = 0x001D0000;
static const int WNNC_NET_RIVERFRONT1 = 0X001E0000;
static const int WNNC_NET_RIVERFRONT2 = 0x001F0000;
static const int WNNC_NET_DECORB = 0x00200000;
static const int WNNC_NET_PROTSTOR = 0x00210000;
static const int WNNC_NET_FJ_REDIR = 0x00220000;
static const int WNNC_NET_DISTINCT = 0x00230000;
static const int WNNC_NET_TWINS = 0x00240000;
static const int WNNC_NET_RDR2SAMPLE = 0x00250000;
static const int WNNC_NET_CSC = 0x00260000;
static const int WNNC_NET_3IN1 = 0x00270000;
static const int WNNC_NET_EXTENDNET = 0x00290000;
static const int WNNC_NET_STAC = 0x002A0000;
static const int WNNC_NET_FOXBAT = 0x002B0000;
static const int WNNC_NET_YAHOO = 0x002C0000;
static const int WNNC_NET_EXIFS = 0x002D0000;
static const int WNNC_NET_DAV = 0x002E0000;
static const int WNNC_NET_KNOWARE = 0x002F0000;
static const int WNNC_NET_OBJECT_DIRE = 0x00300000;
static const int WNNC_NET_MASFAX = 0x00310000;
static const int WNNC_NET_HOB_NFS = 0x00320000;
static const int WNNC_NET_SHIVA = 0x00330000;
static const int WNNC_NET_IBMAL = 0x00340000;
static const int WNNC_NET_LOCK = 0x00350000;
static const int WNNC_NET_TERMSRV = 0x00360000;
static const int WNNC_NET_SRT = 0x00370000;
static const int WNNC_NET_QUINCY = 0x00380000;
static const int WNNC_NET_OPENAFS = 0x00390000;
static const int WNNC_NET_AVID1 = 0X003A0000;
static const int WNNC_NET_DFS = 0x003B0000;
static const int WNNC_NET_KWNP = 0x003C0000;
static const int WNNC_NET_ZENWORKS = 0x003D0000;
static const int WNNC_NET_DRIVEONWEB = 0x003E0000;
static const int WNNC_NET_VMWARE = 0x003F0000;
static const int WNNC_NET_RSFX = 0x00400000;
static const int WNNC_NET_MFILES = 0x00410000;
static const int WNNC_NET_MS_NFS = 0x00420000;
static const int WNNC_NET_GOOGLE = 0x00430000;
static const int WNNC_CRED_MANAGER = 0xFFFF0000;
//
// Network type aliases
//
static const int WNNC_NET_LANMAN = WNNC_NET_SMB;
// end_ntifs
# 39 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h" 2
//
//  Network Resources.
//
static const int RESOURCE_CONNECTED = 0x00000001;
static const int RESOURCE_GLOBALNET = 0x00000002;
static const int RESOURCE_REMEMBERED = 0x00000003;
static const int RESOURCE_RECENT = 0x00000004;
static const int RESOURCE_CONTEXT = 0x00000005;
static const int RESOURCETYPE_ANY = 0x00000000;
static const int RESOURCETYPE_DISK = 0x00000001;
static const int RESOURCETYPE_PRINT = 0x00000002;
static const int RESOURCETYPE_RESERVED = 0x00000008;
static const int RESOURCETYPE_UNKNOWN = 0xFFFFFFFF;
static const int RESOURCEUSAGE_CONNECTABLE = 0x00000001;
static const int RESOURCEUSAGE_CONTAINER = 0x00000002;
static const int RESOURCEUSAGE_NOLOCALDEVICE = 0x00000004;
static const int RESOURCEUSAGE_SIBLING = 0x00000008;
static const int RESOURCEUSAGE_ATTACHED = 0x00000010;
static const int RESOURCEUSAGE_ALL = (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_ATTACHED);
static const int RESOURCEUSAGE_RESERVED = 0x80000000;
static const int RESOURCEDISPLAYTYPE_GENERIC = 0x00000000;
static const int RESOURCEDISPLAYTYPE_DOMAIN = 0x00000001;
static const int RESOURCEDISPLAYTYPE_SERVER = 0x00000002;
static const int RESOURCEDISPLAYTYPE_SHARE = 0x00000003;
static const int RESOURCEDISPLAYTYPE_FILE = 0x00000004;
static const int RESOURCEDISPLAYTYPE_GROUP = 0x00000005;
static const int RESOURCEDISPLAYTYPE_NETWORK = 0x00000006;
static const int RESOURCEDISPLAYTYPE_ROOT = 0x00000007;
static const int RESOURCEDISPLAYTYPE_SHAREADMIN = 0x00000008;
static const int RESOURCEDISPLAYTYPE_DIRECTORY = 0x00000009;
static const int RESOURCEDISPLAYTYPE_TREE = 0x0000000A;
static const int RESOURCEDISPLAYTYPE_NDSCONTAINER = 0x0000000B;
typedef struct _NETRESOURCEA {
    DWORD dwScope;
    DWORD dwType;
    DWORD dwDisplayType;
    DWORD dwUsage;
    LPSTR lpLocalName;
    LPSTR lpRemoteName;
    LPSTR lpComment ;
    LPSTR lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct _NETRESOURCEW {
    DWORD dwScope;
    DWORD dwType;
    DWORD dwDisplayType;
    DWORD dwUsage;
    LPWSTR lpLocalName;
    LPWSTR lpRemoteName;
    LPWSTR lpComment ;
    LPWSTR lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;
typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
//
//  Network Connections.
//
static const int NETPROPERTY_PERSISTENT = 1;
static const int CONNECT_UPDATE_PROFILE = 0x00000001;
static const int CONNECT_UPDATE_RECENT = 0x00000002;
static const int CONNECT_TEMPORARY = 0x00000004;
static const int CONNECT_INTERACTIVE = 0x00000008;
static const int CONNECT_PROMPT = 0x00000010;
static const int CONNECT_NEED_DRIVE = 0x00000020;
static const int CONNECT_REFCOUNT = 0x00000040;
static const int CONNECT_REDIRECT = 0x00000080;
static const int CONNECT_LOCALDRIVE = 0x00000100;
static const int CONNECT_CURRENT_MEDIA = 0x00000200;
static const int CONNECT_DEFERRED = 0x00000400;
static const int CONNECT_RESERVED = 0xFF000000;
static const int CONNECT_COMMANDLINE = 0x00000800;
static const int CONNECT_CMD_SAVECRED = 0x00001000;
static const int CONNECT_CRED_RESET = 0x00002000;
DWORD
WNetAddConnectionA(
    LPCSTR lpRemoteName,
    LPCSTR lpPassword,
    LPCSTR lpLocalName
    );
DWORD
WNetAddConnectionW(
    LPCWSTR lpRemoteName,
    LPCWSTR lpPassword,
    LPCWSTR lpLocalName
    );
static const int WNetAddConnection = WNetAddConnectionA;
DWORD
WNetAddConnection2A(
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserName,
    DWORD dwFlags
    );
DWORD
WNetAddConnection2W(
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserName,
    DWORD dwFlags
    );
static const int WNetAddConnection2 = WNetAddConnection2A;
DWORD
WNetAddConnection3A(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserName,
    DWORD dwFlags
    );
DWORD
WNetAddConnection3W(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserName,
    DWORD dwFlags
    );
static const int WNetAddConnection3 = WNetAddConnection3A;
DWORD
WNetCancelConnectionA(
    LPCSTR lpName,
    BOOL fForce
    );
DWORD
WNetCancelConnectionW(
    LPCWSTR lpName,
    BOOL fForce
    );
static const int WNetCancelConnection = WNetCancelConnectionA;
DWORD
WNetCancelConnection2A(
    LPCSTR lpName,
    DWORD dwFlags,
    BOOL fForce
    );
DWORD
WNetCancelConnection2W(
    LPCWSTR lpName,
    DWORD dwFlags,
    BOOL fForce
    );
static const int WNetCancelConnection2 = WNetCancelConnection2A;
DWORD
WNetGetConnectionA(
    LPCSTR lpLocalName,
    LPSTR lpRemoteName,
    LPDWORD lpnLength
    );
DWORD
WNetGetConnectionW(
    LPCWSTR lpLocalName,
    LPWSTR lpRemoteName,
    LPDWORD lpnLength
    );
static const int WNetGetConnection = WNetGetConnectionA;
DWORD
WNetRestoreSingleConnectionW(
    HWND hwndParent,
    LPCWSTR lpDevice,
    BOOL fUseUI
    );
# 290 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h"
DWORD
WNetUseConnectionA(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserId,
    DWORD dwFlags,
    LPSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult
    );
DWORD
WNetUseConnectionW(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserId,
    DWORD dwFlags,
    LPWSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult
    );
static const int WNetUseConnection = WNetUseConnectionA;
//
//  Network Connection Dialogs.
//
DWORD
WNetConnectionDialog(
    HWND hwnd,
    DWORD dwType
    );
DWORD
WNetDisconnectDialog(
    HWND hwnd,
    DWORD dwType
    );
typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPNETRESOURCEA lpConnRes;/* Requested Resource info    */
    DWORD dwFlags; /* flags (see below) */
    DWORD dwDevNum; /* number of devices connected to */
} CONNECTDLGSTRUCTA, *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPNETRESOURCEW lpConnRes;/* Requested Resource info    */
    DWORD dwFlags; /* flags (see below) */
    DWORD dwDevNum; /* number of devices connected to */
} CONNECTDLGSTRUCTW, *LPCONNECTDLGSTRUCTW;
typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
static const int CONNDLG_RO_PATH = 0x00000001;
static const int CONNDLG_CONN_POINT = 0x00000002;
static const int CONNDLG_USE_MRU = 0x00000004;
static const int CONNDLG_HIDE_BOX = 0x00000008;
/*
 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,
 *        then the persistence is set to whatever the user chose during
 *        a previous connection
 */
# 372 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h"
static const int CONNDLG_PERSIST = 0x00000010;
static const int CONNDLG_NOT_PERSIST = 0x00000020;
DWORD
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
DWORD
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );
static const int WNetConnectionDialog1 = WNetConnectionDialog1A;
typedef struct _DISCDLGSTRUCTA{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPSTR lpLocalName; /* local device name */
    LPSTR lpRemoteName; /* network resource name */
    DWORD dwFlags; /* flags */
} DISCDLGSTRUCTA, *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPWSTR lpLocalName; /* local device name */
    LPWSTR lpRemoteName; /* network resource name */
    DWORD dwFlags; /* flags */
} DISCDLGSTRUCTW, *LPDISCDLGSTRUCTW;
typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
static const int DISC_UPDATE_PROFILE = 0x00000001;
static const int DISC_NO_FORCE = 0x00000040;
DWORD
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpConnDlgStruct
    );
DWORD
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpConnDlgStruct
    );
static const int WNetDisconnectDialog1 = WNetDisconnectDialog1A;
//
//  Network Browsing.
//
DWORD
WNetOpenEnumA(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEA lpNetResource,
    LPHANDLE lphEnum
    );
DWORD
WNetOpenEnumW(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEW lpNetResource,
    LPHANDLE lphEnum
    );
static const int WNetOpenEnum = WNetOpenEnumA;
DWORD
WNetEnumResourceA(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );
DWORD
WNetEnumResourceW(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );
static const int WNetEnumResource = WNetEnumResourceA;
DWORD
WNetCloseEnum(
    HANDLE hEnum
    );
DWORD
WNetGetResourceParentA(
    LPNETRESOURCEA lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer
    );
DWORD
WNetGetResourceParentW(
    LPNETRESOURCEW lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer
    );
static const int WNetGetResourceParent = WNetGetResourceParentA;
DWORD
WNetGetResourceInformationA(
    LPNETRESOURCEA lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPSTR *lplpSystem
    );
DWORD
WNetGetResourceInformationW(
    LPNETRESOURCEW lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPWSTR *lplpSystem
    );
static const int WNetGetResourceInformation = WNetGetResourceInformationA;
//
//  Universal Naming.
//
static const int UNIVERSAL_NAME_INFO_LEVEL = 0x00000001;
static const int REMOTE_NAME_INFO_LEVEL = 0x00000002;
typedef struct _UNIVERSAL_NAME_INFOA {
    LPSTR lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct _UNIVERSAL_NAME_INFOW {
    LPWSTR lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;
typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
typedef struct _REMOTE_NAME_INFOA {
    LPSTR lpUniversalName;
    LPSTR lpConnectionName;
    LPSTR lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct _REMOTE_NAME_INFOW {
    LPWSTR lpUniversalName;
    LPWSTR lpConnectionName;
    LPWSTR lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;
typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
DWORD
WNetGetUniversalNameA(
    LPCSTR lpLocalPath,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );
DWORD
WNetGetUniversalNameW(
    LPCWSTR lpLocalPath,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );
static const int WNetGetUniversalName = WNetGetUniversalNameA;
//
//  Authentication and Logon/Logoff.
//
DWORD
WNetGetUserA(
    LPCSTR lpName,
    LPSTR lpUserName,
    LPDWORD lpnLength
    );
//
//  Authentication and Logon/Logoff.
//
DWORD
WNetGetUserW(
    LPCWSTR lpName,
    LPWSTR lpUserName,
    LPDWORD lpnLength
    );
static const int WNetGetUser = WNetGetUserA;
//
// Other.
//
static const int WNFMT_MULTILINE = 0x01;
static const int WNFMT_ABBREVIATED = 0x02;
static const int WNFMT_INENUM = 0x10;
static const int WNFMT_CONNECTION = 0x20;
DWORD
WNetGetProviderNameA(
    DWORD dwNetType,
    LPSTR lpProviderName,
    LPDWORD lpBufferSize
    );
DWORD
WNetGetProviderNameW(
    DWORD dwNetType,
    LPWSTR lpProviderName,
    LPDWORD lpBufferSize
    );
static const int WNetGetProviderName = WNetGetProviderNameA;
typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    ULONG_PTR dwHandle;
    WORD wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT, *LPNETINFOSTRUCT;
static const int NETINFO_DLL16 = 0x00000001;
static const int NETINFO_DISKRED = 0x00000004;
static const int NETINFO_PRINTERRED = 0x00000008;
DWORD
WNetGetNetworkInformationA(
    LPCSTR lpProvider,
    LPNETINFOSTRUCT lpNetInfoStruct
    );
DWORD
WNetGetNetworkInformationW(
    LPCWSTR lpProvider,
    LPNETINFOSTRUCT lpNetInfoStruct
    );
static const int WNetGetNetworkInformation = WNetGetNetworkInformationA;
//
//  Error handling.
//
DWORD
WNetGetLastErrorA(
    LPDWORD lpError,
    LPSTR lpErrorBuf,
    DWORD nErrorBufSize,
    LPSTR lpNameBuf,
    DWORD nNameBufSize
    );
DWORD
WNetGetLastErrorW(
    LPDWORD lpError,
    LPWSTR lpErrorBuf,
    DWORD nErrorBufSize,
    LPWSTR lpNameBuf,
    DWORD nNameBufSize
    );
static const int WNetGetLastError = WNetGetLastErrorA;
//
//  STATUS CODES
//
// General
static const int WN_SUCCESS = NO_ERROR;
static const int WN_NO_ERROR = NO_ERROR;
static const int WN_NOT_SUPPORTED = ERROR_NOT_SUPPORTED;
static const int WN_CANCEL = ERROR_CANCELLED;
static const int WN_RETRY = ERROR_RETRY;
static const int WN_NET_ERROR = ERROR_UNEXP_NET_ERR;
static const int WN_MORE_DATA = ERROR_MORE_DATA;
static const int WN_BAD_POINTER = ERROR_INVALID_ADDRESS;
static const int WN_BAD_VALUE = ERROR_INVALID_PARAMETER;
static const int WN_BAD_USER = ERROR_BAD_USERNAME;
static const int WN_BAD_PASSWORD = ERROR_INVALID_PASSWORD;
static const int WN_ACCESS_DENIED = ERROR_ACCESS_DENIED;
static const int WN_FUNCTION_BUSY = ERROR_BUSY;
static const int WN_WINDOWS_ERROR = ERROR_UNEXP_NET_ERR;
static const int WN_OUT_OF_MEMORY = ERROR_NOT_ENOUGH_MEMORY;
static const int WN_NO_NETWORK = ERROR_NO_NETWORK;
static const int WN_EXTENDED_ERROR = ERROR_EXTENDED_ERROR;
static const int WN_BAD_LEVEL = ERROR_INVALID_LEVEL;
static const int WN_BAD_HANDLE = ERROR_INVALID_HANDLE;
static const int WN_NOT_INITIALIZING = ERROR_ALREADY_INITIALIZED;
static const int WN_NO_MORE_DEVICES = ERROR_NO_MORE_DEVICES;
// Connection
static const int WN_NOT_CONNECTED = ERROR_NOT_CONNECTED;
static const int WN_OPEN_FILES = ERROR_OPEN_FILES;
static const int WN_DEVICE_IN_USE = ERROR_DEVICE_IN_USE;
static const int WN_BAD_NETNAME = ERROR_BAD_NET_NAME;
static const int WN_BAD_LOCALNAME = ERROR_BAD_DEVICE;
static const int WN_ALREADY_CONNECTED = ERROR_ALREADY_ASSIGNED;
static const int WN_DEVICE_ERROR = ERROR_GEN_FAILURE;
static const int WN_CONNECTION_CLOSED = ERROR_CONNECTION_UNAVAIL;
static const int WN_NO_NET_OR_BAD_PATH = ERROR_NO_NET_OR_BAD_PATH;
static const int WN_BAD_PROVIDER = ERROR_BAD_PROVIDER;
static const int WN_CANNOT_OPEN_PROFILE = ERROR_CANNOT_OPEN_PROFILE;
static const int WN_BAD_PROFILE = ERROR_BAD_PROFILE;
static const int WN_BAD_DEV_TYPE = ERROR_BAD_DEV_TYPE;
static const int WN_DEVICE_ALREADY_REMEMBERED = ERROR_DEVICE_ALREADY_REMEMBERED;
static const int WN_CONNECTED_OTHER_PASSWORD = ERROR_CONNECTED_OTHER_PASSWORD;
static const int WN_CONNECTED_OTHER_PASSWORD_DEFAULT = ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT;
// Enumeration
static const int WN_NO_MORE_ENTRIES = ERROR_NO_MORE_ITEMS;
static const int WN_NOT_CONTAINER = ERROR_NOT_CONTAINER;
// Authentication
static const int WN_NOT_AUTHENTICATED = ERROR_NOT_AUTHENTICATED;
static const int WN_NOT_LOGGED_ON = ERROR_NOT_LOGGED_ON;
static const int WN_NOT_VALIDATED = ERROR_NO_LOGON_SERVERS;
//
//  For Shell
//
typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT, *LPNETCONNECTINFOSTRUCT;
static const int WNCON_FORNETCARD = 0x00000001;
static const int WNCON_NOTROUTED = 0x00000002;
static const int WNCON_SLOWLINK = 0x00000004;
static const int WNCON_DYNAMIC = 0x00000008;
DWORD
MultinetGetConnectionPerformanceA(
    LPNETRESOURCEA lpNetResource,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );
DWORD
MultinetGetConnectionPerformanceW(
    LPNETRESOURCEW lpNetResource,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );
static const int MultinetGetConnectionPerformance = MultinetGetConnectionPerformanceA;
# 171 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 208 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h" 1
/*++
Copyright (c) 2000  Microsoft Corporation
Module Name:
    stralign.h
Abstract:
    This module contains macros and prototypes to expose the unaligned wide
    character interfaces.
    Public interfaces created or declared here include:
    ua_CharUpper()
    ua_CharUpperW()
    ua_lstrcmp()
    ua_lstrcmpW()
    ua_lstrcmpi()
    ua_lstrcmpiW()
    ua_lstrlen()
    ua_lstrlenW()
    ua_tcscpy()
    ua_tcscpy_s()
    ua_wcschr()
    ua_wcscpy()
    ua_wcscpy_s()
    ua_wcsicmp()
    ua_wcslen()
    ua_wcsrchr()
    STRUC_ALIGNED_STACK_COPY()
    TSTR_ALIGNED()
    TSTR_ALIGNED_STACK_COPY()
    WSTR_ALIGNED()
    WSTR_ALIGNED_STACK_COPY()
Author:
--*/
# 44 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
static const int _STRALIGN_USE_SECURE_CRT = 1;
# 58 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
static const int _WINDOWS_INSECURE_DEPRECATE = __declspec(deprecated);
//
// N.B. On AMD64 platforms the key word __unaligned is enabled, but has no
//      effect and strings can be unaligned exactly as they are on the x86.
//      Therefore, all AMD64 alignment macros are forced to produce values
//      that make the subject arguments appear as it they are aligned.
//
# 119 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
//
// The C runtime libraries expect aligned string pointers.  Following are the
// prototypes for our own, slower worker functions that accept unaligned
// UNICODE strings.
//
// Macro to determine whether a pointer to a unicode character is naturally
// aligned.
//
static const int WSTR_ALIGNED(s) = (((DWORD_PTR)(s) & (sizeof(WCHAR)-1)) == 0);
//
// Platform-specific prototypes for worker functions exported from kernel32.
// Do not call these directly, they do not exist on all platforms.  Instead
// use the equivalent ua_xxx() routines.
//
LPUWSTR
uaw_CharUpperW(
    LPUWSTR String
    );
int
uaw_lstrcmpW(
    PCUWSTR String1,
    PCUWSTR String2
    );
int
uaw_lstrcmpiW(
    PCUWSTR String1,
    PCUWSTR String2
    );
int
uaw_lstrlenW(
    LPCUWSTR String
    );
PUWSTR
uaw_wcschr(
    PCUWSTR String,
    WCHAR Character
    );
PUWSTR
uaw_wcscpy(
    PUWSTR Destination,
    PCUWSTR Source
    );
int
uaw_wcsicmp(
    PCUWSTR String1,
    PCUWSTR String2
    );
size_t
uaw_wcslen(
    PCUWSTR String
    );
PUWSTR
uaw_wcsrchr(
    PCUWSTR String,
    WCHAR Character
    );
//
// Following are the inline wrappers that determine the optimal worker function
// to call based on the alignment of the UNICODE string arguments.  Their
// behavior is otherwise identical to the corresponding standard run-time
// routiunes.
//
__inline
LPUWSTR
static
ua_CharUpperW(
    LPUWSTR String
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return CharUpperW( (PWSTR)String );
    } else {
        return uaw_CharUpperW( String );
    }
}
__inline
int
static
ua_lstrcmpW(
    LPCUWSTR String1,
    LPCUWSTR String2
    )
{
    if ((((DWORD_PTR)(String1) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(String2) & (sizeof(WCHAR)-1)) == 0)) {
        return lstrcmpW( (LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_lstrcmpW( String1, String2 );
    }
}
__inline
int
static
ua_lstrcmpiW(
    LPCUWSTR String1,
    LPCUWSTR String2
    )
{
    if ((((DWORD_PTR)(String1) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(String2) & (sizeof(WCHAR)-1)) == 0)) {
        return lstrcmpiW( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_lstrcmpiW( String1, String2 );
    }
}
__inline
int
static
ua_lstrlenW(
    LPCUWSTR String
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return lstrlenW( (PCWSTR)String );
    } else {
        return uaw_lstrlenW( String );
    }
}
//
// Certain run-time string functions are overloaded in C++, to avoid
// inadvertent stripping of the const attribute.
//
// The functions of interest here include: wcschr and wcsrchr.
//
// There are three flavors of these functions:
//
// Flavor  Returns    Parameter
//
// 1       PWSTR      PCWSTR
// 2       PCWSTR     PCWSTR
// 3       PWSTR      PWSTR
//
// string.h declares flavor 1 whether for C or C++.  This is the non-ANSI,
// backward compatible mode.
//
// wchar.h declares flavor 1 if C, or flavors 2 and 3 if C++.  This is the
// ANSI method.
//
// Our corresponding functions need to match what was declared.  The way
// we can tell is by looking at _WConst_return... if it is defined then
// we want to match the prototypes in wchar.h, otherwise we'll match
// the prototypes in string.h.
//
typedef WCHAR *PUWSTR_C;
//
// Here is flavor 1 or 2
//
__inline
PUWSTR_C
static
ua_wcschr(
    PCUWSTR String,
    WCHAR Character
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return wcschr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcschr(String, Character);
    }
}
__inline
PUWSTR_C
static
ua_wcsrchr(
    PCUWSTR String,
    WCHAR Character
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return wcsrchr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcsrchr(String, Character);
    }
}
# 405 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
__inline
PUWSTR
static
__attribute__((deprecated))
ua_wcscpy(
    PUWSTR Destination,
    PCUWSTR Source
    )
{
    if ((((DWORD_PTR)(Source) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(Destination) & (sizeof(WCHAR)-1)) == 0)) {
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)
        return wcscpy( (PWSTR)Destination, (PCWSTR)Source );
#pragma warning(pop)
    } else {
        return uaw_wcscpy( Destination, Source );
    }
}
__inline
PUWSTR
static
ua_wcscpy_s(
    PUWSTR Destination,
    size_t DestinationSize,
    PCUWSTR Source
    )
{
    if ((((DWORD_PTR)(Source) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(Destination) & (sizeof(WCHAR)-1)) == 0)) {
        return (wcscpy_s( (PWSTR)Destination, DestinationSize, (PCWSTR)Source ) == 0 ? Destination : ((void *)0));
    } else {
        /* TODO: Need to reference uaw_wcscpy_s */
        return uaw_wcscpy( Destination, Source );
    }
}
__inline
size_t
static
ua_wcslen(
    PCUWSTR String
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return wcslen( (PCWSTR)String );
    } else {
        return uaw_wcslen( String );
    }
}
__inline
int
static
ua_wcsicmp(
    PCUWSTR String1,
    PCUWSTR String2
    )
{
    if ((((DWORD_PTR)(String1) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(String2) & (sizeof(WCHAR)-1)) == 0)) {
        return _wcsicmp( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_wcsicmp( String1, String2 );
    }
}
//++
//
// VOID
// WSTR_ALIGNED_STACK_COPY (
//    __out PCWSTR *TargetString,
//    __in_opt  PCUWSTR SourceString
//    )
//
// VOID
// TSTR_ALIGNED_STACK_COPY (
//    __out PCTSTR *TargetString,
//    __in_opt  PCUTSTR SourceString
//    )
//
// Routine Description:
//
//    These macros set TargetString to an aligned pointer to the string
//    represented by SourceString.  If necessary, an aligned copy of
//    SourceString is copied onto the stack.
//
// Arguments:
//
//    TargetString - Supplies a pointer to a pointer to the resultant
//                   string.  This may be the same as SourceString if
//                   that argument is aligned.
//
//    SourceString - Supplies a pointer to the possibly unaligned UNICODE
//                   string.
//
// Return Value:
//
//    None.
//
// Note:
//
//    These macros may allocate memory on the stack via the CRT function
//    _alloca().  This memory is "freed" when the calling function exits.
//    As a result, do not use these macros inside of a loop that may execute
//    a large number of times - instead, use a wrapper function, or use
//    an explicit buffer like this:
//
//    TCHAR AlignedStringBuffer[ MAX_FOOSTR_CHARS ];
//    PTSTR AlignedString;
//
//    while (a < b) {
//        ...
//        if (TSTR_ALIGNED(s) {
//            AlignedString = s;
//        } else {
//            AlignedString = (PTSTR)ua_tcscpy(AlignedStringBuffer,s);
//        }
//        SomeSystemFunction(AlignedString);
//        ...
//    }
//
//
//--
//
// __UA_WSTRSIZE returns the number of bytes required to store the
// supplied null-terminated UNICODE string.
//
// __UA_LOCALCOPY accepts a pointer to unaligned data and a size.  It
// allocates an aligned buffer on the stack and copies the data into
// it, returning a pointer to the buffer.
//
static const int __UA_WCSLEN = ua_wcslen;
static const int __UA_WSTRSIZE(s) = ((__UA_WCSLEN(s)+1)*sizeof(WCHAR));
static const int __UA_STACKCOPY(p,s) = memcpy(_alloca(s),p,s);
//
// Note that NULL is aligned.
//
//
// Use of an inline function here is not possible, as the results of
// the _alloca() will not be preserved upon return from the function.
//
static const int WSTR_ALIGNED_STACK_COPY(d,s) = { PCUWSTR __ua_src; size_t __ua_size; PWSTR __ua_dst; __ua_src = (s); if (WSTR_ALIGNED(__ua_src)) { __ua_dst = (PWSTR)__ua_src; } else { __ua_size = __UA_WSTRSIZE(__ua_src); __ua_dst = (PWSTR)_alloca(__ua_size); memcpy(__ua_dst,__ua_src,__ua_size); } *(d) = (PCWSTR)__ua_dst; };
# 589 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
static const int ASTR_ALIGNED_STACK_COPY(d,s) = (*(d) = (PCSTR)(s));
//++
//
// <type> CONST *
// STRUC_ALIGNED_STACK_COPY (
//     __in <type name>,
//     __in_opt PVOID Struc
//     )
//
// Routine Description:
//
//    This macro returns an aligned pointer to Struc, creating a local
//    copy on the stack if necessary.
//
//    This should be used only for relatively small structures, and efforts
//    should be made to align the structure properly in the first place.  Use
//    this macro only as a last resort.
//
// Arguments:
//
//    <type> - The type specifier of Struc
//
//    Struc - Supplies a pointer to the structure in question.
//
// Return Value:
//
//    Returns a const pointer to Struc if it is properly aligned, or a pointer
//    to a stack-allocated copy of Struc if it is not.
//
//--
static const int __UA_STRUC_ALIGNED(t,s) = (((DWORD_PTR)(s) & (TYPE_ALIGNMENT(t)-1)) == 0);
static const int STRUC_ALIGNED_STACK_COPY(t,s) = __UA_STRUC_ALIGNED(t,s) ? ((t const *)(s)) : ((t const *)__UA_STACKCOPY((s),sizeof(t)));
# 652 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
static const int TSTR_ALIGNED_STACK_COPY(d,s) = ASTR_ALIGNED_STACK_COPY(d,s);
static const int TSTR_ALIGNED(x) = TRUE;
static const int ua_CharUpper = CharUpperA;
static const int ua_lstrcmp = lstrcmpA;
static const int ua_lstrcmpi = lstrcmpiA;
static const int ua_lstrlen = lstrlenA;
static const int ua_tcscpy = strcpy;
static const int ua_tcscpy_s = strcpy_s;
# 209 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 221 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h" 1
/*++ BUILD Version: 0010    // Increment this if a change has global effects
Copyright (c) 1995-1998  Microsoft Corporation
Module Name:
    winsvc.h
Abstract:
    Header file for the Service Control Manager
Environment:
    User Mode - Win32
--*/
# 19 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
//
// Define API decoration for direct importing of DLL references.
//
# 37 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
//
// Constants
//
//
// Service database names
//
static const char SERVICES_ACTIVE_DATABASEW = L"ServicesActive";
static const char SERVICES_FAILED_DATABASEW = L"ServicesFailed";
static const char SERVICES_ACTIVE_DATABASEA = "ServicesActive";
static const char SERVICES_FAILED_DATABASEA = "ServicesFailed";
//
// Character to designate that a name is a group
//
static const int SC_GROUP_IDENTIFIERW = L'+';
static const int SC_GROUP_IDENTIFIERA = '+';
# 68 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
static const int SERVICES_ACTIVE_DATABASE = SERVICES_ACTIVE_DATABASEA;
static const int SERVICES_FAILED_DATABASE = SERVICES_FAILED_DATABASEA;
static const int SC_GROUP_IDENTIFIER = SC_GROUP_IDENTIFIERA;
//
// Value to indicate no change to an optional parameter
//
static const int SERVICE_NO_CHANGE = 0xffffffff;
//
// Service State -- for Enum Requests (Bit Mask)
//
static const int SERVICE_ACTIVE = 0x00000001;
static const int SERVICE_INACTIVE = 0x00000002;
static const int SERVICE_STATE_ALL = (SERVICE_ACTIVE | SERVICE_INACTIVE);
//
// Controls
//
static const int SERVICE_CONTROL_STOP = 0x00000001;
static const int SERVICE_CONTROL_PAUSE = 0x00000002;
static const int SERVICE_CONTROL_CONTINUE = 0x00000003;
static const int SERVICE_CONTROL_INTERROGATE = 0x00000004;
static const int SERVICE_CONTROL_SHUTDOWN = 0x00000005;
static const int SERVICE_CONTROL_PARAMCHANGE = 0x00000006;
static const int SERVICE_CONTROL_NETBINDADD = 0x00000007;
static const int SERVICE_CONTROL_NETBINDREMOVE = 0x00000008;
static const int SERVICE_CONTROL_NETBINDENABLE = 0x00000009;
static const int SERVICE_CONTROL_NETBINDDISABLE = 0x0000000A;
static const int SERVICE_CONTROL_DEVICEEVENT = 0x0000000B;
static const int SERVICE_CONTROL_HARDWAREPROFILECHANGE = 0x0000000C;
static const int SERVICE_CONTROL_POWEREVENT = 0x0000000D;
static const int SERVICE_CONTROL_SESSIONCHANGE = 0x0000000E;
static const double SERVICE_CONTROL_PRESHUTDOWN = 0x0000000F;
static const int SERVICE_CONTROL_TIMECHANGE = 0x00000010;
static const int SERVICE_CONTROL_TRIGGEREVENT = 0x00000020;
//
// Service State -- for CurrentState
//
static const int SERVICE_STOPPED = 0x00000001;
static const int SERVICE_START_PENDING = 0x00000002;
static const int SERVICE_STOP_PENDING = 0x00000003;
static const int SERVICE_RUNNING = 0x00000004;
static const int SERVICE_CONTINUE_PENDING = 0x00000005;
static const int SERVICE_PAUSE_PENDING = 0x00000006;
static const int SERVICE_PAUSED = 0x00000007;
//
// Controls Accepted  (Bit Mask)
//
static const int SERVICE_ACCEPT_STOP = 0x00000001;
static const int SERVICE_ACCEPT_PAUSE_CONTINUE = 0x00000002;
static const int SERVICE_ACCEPT_SHUTDOWN = 0x00000004;
static const int SERVICE_ACCEPT_PARAMCHANGE = 0x00000008;
static const int SERVICE_ACCEPT_NETBINDCHANGE = 0x00000010;
static const int SERVICE_ACCEPT_HARDWAREPROFILECHANGE = 0x00000020;
static const int SERVICE_ACCEPT_POWEREVENT = 0x00000040;
static const int SERVICE_ACCEPT_SESSIONCHANGE = 0x00000080;
static const int SERVICE_ACCEPT_PRESHUTDOWN = 0x00000100;
static const int SERVICE_ACCEPT_TIMECHANGE = 0x00000200;
static const int SERVICE_ACCEPT_TRIGGEREVENT = 0x00000400;
//
// Service Control Manager object specific access types
//
static const int SC_MANAGER_CONNECT = 0x0001;
static const int SC_MANAGER_CREATE_SERVICE = 0x0002;
static const int SC_MANAGER_ENUMERATE_SERVICE = 0x0004;
static const int SC_MANAGER_LOCK = 0x0008;
static const int SC_MANAGER_QUERY_LOCK_STATUS = 0x0010;
static const int SC_MANAGER_MODIFY_BOOT_CONFIG = 0x0020;
static const int SC_MANAGER_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_LOCK | SC_MANAGER_QUERY_LOCK_STATUS | SC_MANAGER_MODIFY_BOOT_CONFIG);
# 155 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
//
// Service object specific access type
//
static const int SERVICE_QUERY_CONFIG = 0x0001;
static const int SERVICE_CHANGE_CONFIG = 0x0002;
static const int SERVICE_QUERY_STATUS = 0x0004;
static const int SERVICE_ENUMERATE_DEPENDENTS = 0x0008;
static const int SERVICE_START = 0x0010;
static const int SERVICE_STOP = 0x0020;
static const int SERVICE_PAUSE_CONTINUE = 0x0040;
static const int SERVICE_INTERROGATE = 0x0080;
static const int SERVICE_USER_DEFINED_CONTROL = 0x0100;
static const int SERVICE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_START | SERVICE_STOP | SERVICE_PAUSE_CONTINUE | SERVICE_INTERROGATE | SERVICE_USER_DEFINED_CONTROL);
# 179 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
//
// Service flags for QueryServiceStatusEx
//
static const int SERVICE_RUNS_IN_SYSTEM_PROCESS = 0x00000001;
//
// Info levels for ChangeServiceConfig2 and QueryServiceConfig2
//
static const int SERVICE_CONFIG_DESCRIPTION = 1;
static const int SERVICE_CONFIG_FAILURE_ACTIONS = 2;
static const int SERVICE_CONFIG_DELAYED_AUTO_START_INFO = 3;
static const int SERVICE_CONFIG_FAILURE_ACTIONS_FLAG = 4;
static const int SERVICE_CONFIG_SERVICE_SID_INFO = 5;
static const int SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO = 6;
static const int SERVICE_CONFIG_PRESHUTDOWN_INFO = 7;
static const int SERVICE_CONFIG_TRIGGER_INFO = 8;
static const int SERVICE_CONFIG_PREFERRED_NODE = 9;
//
// Info levels for NotifyServiceStatusChange
//
static const int SERVICE_NOTIFY_STATUS_CHANGE_1 = 1;
static const int SERVICE_NOTIFY_STATUS_CHANGE_2 = 2;
static const int SERVICE_NOTIFY_STATUS_CHANGE = SERVICE_NOTIFY_STATUS_CHANGE_2;
//
// Service notification masks
//
static const int SERVICE_NOTIFY_STOPPED = 0x00000001;
static const int SERVICE_NOTIFY_START_PENDING = 0x00000002;
static const int SERVICE_NOTIFY_STOP_PENDING = 0x00000004;
static const int SERVICE_NOTIFY_RUNNING = 0x00000008;
static const int SERVICE_NOTIFY_CONTINUE_PENDING = 0x00000010;
static const int SERVICE_NOTIFY_PAUSE_PENDING = 0x00000020;
static const int SERVICE_NOTIFY_PAUSED = 0x00000040;
static const int SERVICE_NOTIFY_CREATED = 0x00000080;
static const int SERVICE_NOTIFY_DELETED = 0x00000100;
static const int SERVICE_NOTIFY_DELETE_PENDING = 0x00000200;
//
// The following defines are for service stop reason codes
//
//
// Stop reason flags. Update SERVICE_STOP_REASON_FLAG_MAX when
// new flags are added.
//
static const int SERVICE_STOP_REASON_FLAG_MIN = 0x00000000;
static const int SERVICE_STOP_REASON_FLAG_UNPLANNED = 0x10000000;
static const int SERVICE_STOP_REASON_FLAG_CUSTOM = 0x20000000;
static const int SERVICE_STOP_REASON_FLAG_PLANNED = 0x40000000;
static const int SERVICE_STOP_REASON_FLAG_MAX = 0x80000000;
//
// Microsoft major reasons. Update SERVICE_STOP_REASON_MAJOR_MAX when
// new codes are added.
//
static const int SERVICE_STOP_REASON_MAJOR_MIN = 0x00000000;
static const int SERVICE_STOP_REASON_MAJOR_OTHER = 0x00010000;
static const int SERVICE_STOP_REASON_MAJOR_HARDWARE = 0x00020000;
static const int SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM = 0x00030000;
static const int SERVICE_STOP_REASON_MAJOR_SOFTWARE = 0x00040000;
static const int SERVICE_STOP_REASON_MAJOR_APPLICATION = 0x00050000;
static const int SERVICE_STOP_REASON_MAJOR_NONE = 0x00060000;
static const int SERVICE_STOP_REASON_MAJOR_MAX = 0x00070000;
static const int SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM = 0x00400000;
static const int SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM = 0x00ff0000;
//
// Microsoft minor reasons. Update SERVICE_STOP_REASON_MINOR_MAX when
// new codes are added.
//
static const int SERVICE_STOP_REASON_MINOR_MIN = 0x00000000;
static const int SERVICE_STOP_REASON_MINOR_OTHER = 0x00000001;
static const int SERVICE_STOP_REASON_MINOR_MAINTENANCE = 0x00000002;
static const int SERVICE_STOP_REASON_MINOR_INSTALLATION = 0x00000003;
static const int SERVICE_STOP_REASON_MINOR_UPGRADE = 0x00000004;
static const int SERVICE_STOP_REASON_MINOR_RECONFIG = 0x00000005;
static const int SERVICE_STOP_REASON_MINOR_HUNG = 0x00000006;
static const int SERVICE_STOP_REASON_MINOR_UNSTABLE = 0x00000007;
static const int SERVICE_STOP_REASON_MINOR_DISK = 0x00000008;
static const int SERVICE_STOP_REASON_MINOR_NETWORKCARD = 0x00000009;
static const int SERVICE_STOP_REASON_MINOR_ENVIRONMENT = 0x0000000a;
static const int SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER = 0x0000000b;
static const int SERVICE_STOP_REASON_MINOR_OTHERDRIVER = 0x0000000c;
static const int SERVICE_STOP_REASON_MINOR_SERVICEPACK = 0x0000000d;
static const int SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE = 0x0000000e;
static const int SERVICE_STOP_REASON_MINOR_SECURITYFIX = 0x0000000f;
static const int SERVICE_STOP_REASON_MINOR_SECURITY = 0x00000010;
static const int SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY = 0x00000011;
static const int SERVICE_STOP_REASON_MINOR_WMI = 0x00000012;
static const int SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL = 0x00000013;
static const int SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL = 0x00000014;
static const int SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL = 0x00000015;
static const int SERVICE_STOP_REASON_MINOR_MMC = 0x00000016;
static const int SERVICE_STOP_REASON_MINOR_NONE = 0x00000017;
static const int SERVICE_STOP_REASON_MINOR_MAX = 0x00000018;
static const int SERVICE_STOP_REASON_MINOR_MIN_CUSTOM = 0x00000100;
static const int SERVICE_STOP_REASON_MINOR_MAX_CUSTOM = 0x0000FFFF;
//
// Info levels for ControlServiceEx
//
static const int SERVICE_CONTROL_STATUS_REASON_INFO = 1;
//
// Service SID types supported
//
static const int SERVICE_SID_TYPE_NONE = 0x00000000;
static const int SERVICE_SID_TYPE_UNRESTRICTED = 0x00000001;
static const int SERVICE_SID_TYPE_RESTRICTED = ( 0x00000002 | SERVICE_SID_TYPE_UNRESTRICTED );
//
// Service trigger types
//
static const int SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL = 1;
static const int SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY = 2;
static const int SERVICE_TRIGGER_TYPE_DOMAIN_JOIN = 3;
static const int SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT = 4;
static const int SERVICE_TRIGGER_TYPE_GROUP_POLICY = 5;
static const int SERVICE_TRIGGER_TYPE_CUSTOM = 20;
//
// Service trigger data types
//
static const int SERVICE_TRIGGER_DATA_TYPE_BINARY = 1;
static const int SERVICE_TRIGGER_DATA_TYPE_STRING = 2;
//
//  NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID & NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID are used with
//  SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY trigger.
//
extern const GUID /* 4f27f2de-14e2-430b-a549-7cd48cbc8245 */ NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID
   ;
extern const GUID /* cc4ba62a-162e-4648-847a-b6bdf993e335 */ NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID
   ;
//
//  DOMAIN_JOIN_GUID & DOMAIN_LEAVE_GUID are used with SERVICE_TRIGGER_TYPE_DOMAIN_JOIN trigger.
//
extern const GUID /* 1ce20aba-9851-4421-9430-1ddeb766e809 */ DOMAIN_JOIN_GUID
   ;
extern const GUID /* ddaf516e-58c2-4866-9574-c3b615d42ea1 */ DOMAIN_LEAVE_GUID
   ;
//
//  FIREWALL_PORT_OPEN_GUID & FIREWALL_PORT_CLOSE_GUID are used with
//  SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT trigger.
//
extern const GUID /* b7569e07-8421-4ee0-ad10-86915afdad09 */ FIREWALL_PORT_OPEN_GUID
   ;
extern const GUID /* a144ed38-8e12-4de4-9d96-e64740b1a524 */ FIREWALL_PORT_CLOSE_GUID
   ;
//
//  MACHINE_POLICY_PRESENT_GUID & USER_POLICY_PRESENT_GUID are used with
//  SERVICE_TRIGGER_TYPE_GROUP_POLICY trigger.
//
extern const GUID /* 659FCAE6-5BDB-4DA9-B1FF-CA2A178D46E0 */ MACHINE_POLICY_PRESENT_GUID
   ;
extern const GUID /* 54FB46C8-F089-464C-B1FD-59D1B62C3B50 */ USER_POLICY_PRESENT_GUID
   ;
//
// Service trigger actions
//
static const int SERVICE_TRIGGER_ACTION_SERVICE_START = 1;
static const int SERVICE_TRIGGER_ACTION_SERVICE_STOP = 2;
//
// argv[1] passed into ServiceMain of trigger started services
//
static const char SERVICE_TRIGGER_STARTED_ARGUMENT = L"TriggerStarted";
//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;
//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;
typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;
//
// Actions to take on service failure
//
typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE = 0,
        SC_ACTION_RESTART = 1,
        SC_ACTION_REBOOT = 2,
        SC_ACTION_RUN_COMMAND = 3
} SC_ACTION_TYPE;
typedef struct _SC_ACTION {
    SC_ACTION_TYPE Type;
    DWORD Delay;
} SC_ACTION, *LPSC_ACTION;
typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD dwResetPeriod;
    LPSTR lpRebootMsg;
    LPSTR lpCommand;
    DWORD cActions;
    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD dwResetPeriod;
    LPWSTR lpRebootMsg;
    LPWSTR lpCommand;
    DWORD cActions;
    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;
typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;
//
// Service delayed autostart info setting
//
typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
    BOOL fDelayedAutostart; // Delayed autostart flag
} SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;
//
// Service failure actions flag setting
//
typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
    BOOL fFailureActionsOnNonCrashFailures; // Failure actions flag
} SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;
//
// Service SID info setting
//
typedef struct _SERVICE_SID_INFO {
    DWORD dwServiceSidType; // Service SID type
} SERVICE_SID_INFO, *LPSERVICE_SID_INFO;
//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    LPSTR pmszRequiredPrivileges; // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    LPWSTR pmszRequiredPrivileges; // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;
typedef SERVICE_REQUIRED_PRIVILEGES_INFOA SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO;
//
// Service preshutdown timeout setting
//
typedef struct _SERVICE_PRESHUTDOWN_INFO {
    DWORD dwPreshutdownTimeout; // Timeout in msecs
} SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;
//
//  Service trigger data item
//
typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    DWORD dwDataType; // Data type -- one of SERVICE_TRIGGER_DATA_TYPE_* constants
    DWORD cbData; // Size of trigger specific data
    PBYTE pData; // Trigger specific data
} SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
//
//  Trigger-specific information
//
typedef struct _SERVICE_TRIGGER
{
    DWORD dwTriggerType; // One of SERVICE_TRIGGER_TYPE_* constants
    DWORD dwAction; // One of SERVICE_TRIGGER_ACTION_* constants
    GUID * pTriggerSubtype; // Provider GUID if the trigger type is SERVICE_TRIGGER_TYPE_CUSTOM
                                                            // Device class interface GUID if the trigger type is
                                                            // SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL
    DWORD cDataItems; // Number of data items in pDataItems array
    PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM pDataItems; // Trigger specific data
} SERVICE_TRIGGER, *PSERVICE_TRIGGER;
//
// Service trigger information
//
typedef struct _SERVICE_TRIGGER_INFO {
    DWORD cTriggers; // Number of triggers in the pTriggers array
    PSERVICE_TRIGGER pTriggers; // Array of triggers
    PBYTE pReserved; // Reserved, must be NULL
} SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;
//
// Preferred node information
//
typedef struct _SERVICE_PREFERRED_NODE_INFO {
    USHORT usPreferredNode; // Preferred node
    BOOLEAN fDelete; // Delete the preferred node setting
} SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;
//
// Time change information
//
typedef struct _SERVICE_TIMECHANGE_INFO {
    LARGE_INTEGER liNewTime; // New time
    LARGE_INTEGER liOldTime; // Old time
} SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;
//
// Handle Types
//
struct SC_HANDLE__{int unused;}; typedef struct SC_HANDLE__ *SC_HANDLE;
typedef SC_HANDLE *LPSC_HANDLE;
struct SERVICE_STATUS_HANDLE__{int unused;}; typedef struct SERVICE_STATUS_HANDLE__ *SERVICE_STATUS_HANDLE;
//
// Info levels for QueryServiceStatusEx
//
typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO = 0
} SC_STATUS_TYPE;
//
// Info levels for EnumServicesStatusEx
//
typedef enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO = 0
} SC_ENUM_TYPE;
//
// Service Status Structures
//
typedef struct _SERVICE_STATUS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;
typedef struct _SERVICE_STATUS_PROCESS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
    DWORD dwProcessId;
    DWORD dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;
//
// Service Status Enumeration Structure
//
typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR lpServiceName;
    LPSTR lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR lpServiceName;
    LPWSTR lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;
typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR lpServiceName;
    LPSTR lpDisplayName;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR lpServiceName;
    LPWSTR lpDisplayName;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;
typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;
//
// Structures for the Lock API functions
//
typedef LPVOID SC_LOCK;
typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD fIsLocked;
    LPSTR lpLockOwner;
    DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD fIsLocked;
    LPWSTR lpLockOwner;
    DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;
typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
//
// Query Service Configuration Structure
//
typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPSTR lpBinaryPathName;
    LPSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPSTR lpDependencies;
    LPSTR lpServiceStartName;
    LPSTR lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPWSTR lpBinaryPathName;
    LPWSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPWSTR lpDependencies;
    LPWSTR lpServiceStartName;
    LPWSTR lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
//
// Function Prototype for the Service Main Function
//
typedef void ( *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD dwNumServicesArgs,
    LPWSTR *lpServiceArgVectors
    );
typedef void ( *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD dwNumServicesArgs,
    LPSTR *lpServiceArgVectors
    );
static const int LPSERVICE_MAIN_FUNCTION = LPSERVICE_MAIN_FUNCTIONA;
//
// Service Start Table
//
typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;
typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
//
// Prototype for the Service Control Handler Function
//
typedef void ( *LPHANDLER_FUNCTION)(
    DWORD dwControl
    );
typedef DWORD ( *LPHANDLER_FUNCTION_EX)(
    DWORD dwControl,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpContext
    );
//
// Service notification parameters
//
typedef
void
( * PFN_SC_NOTIFY_CALLBACK ) (
    PVOID pParameter
    );
//
//  Each new notify structure is a superset of the older version
//
typedef struct _SERVICE_NOTIFY_1 {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;
typedef struct _SERVICE_NOTIFY_2A {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationTriggered;
    LPSTR pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationTriggered;
    LPWSTR pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;
typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;
typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;
typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;
//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    DWORD dwReason;
    LPSTR pszComment;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    DWORD dwReason;
    LPWSTR pszComment;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;
typedef SERVICE_CONTROL_STATUS_REASON_PARAMSA SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS;
///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////
BOOL
ChangeServiceConfigA(
    SC_HANDLE hService,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCSTR lpBinaryPathName,
    LPCSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCSTR lpDependencies,
    LPCSTR lpServiceStartName,
    LPCSTR lpPassword,
    LPCSTR lpDisplayName
    );
BOOL
ChangeServiceConfigW(
    SC_HANDLE hService,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCWSTR lpBinaryPathName,
    LPCWSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCWSTR lpDependencies,
    LPCWSTR lpServiceStartName,
    LPCWSTR lpPassword,
    LPCWSTR lpDisplayName
    );
static const int ChangeServiceConfig = ChangeServiceConfigA;
BOOL
ChangeServiceConfig2A(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
    LPVOID lpInfo
    );
BOOL
ChangeServiceConfig2W(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
    LPVOID lpInfo
    );
static const int ChangeServiceConfig2 = ChangeServiceConfig2A;
BOOL
CloseServiceHandle(
    SC_HANDLE hSCObject
    );
BOOL
ControlService(
    SC_HANDLE hService,
    DWORD dwControl,
    LPSERVICE_STATUS lpServiceStatus
    );
SC_HANDLE
CreateServiceA(
    SC_HANDLE hSCManager,
    LPCSTR lpServiceName,
    LPCSTR lpDisplayName,
    DWORD dwDesiredAccess,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCSTR lpBinaryPathName,
    LPCSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCSTR lpDependencies,
    LPCSTR lpServiceStartName,
    LPCSTR lpPassword
    );
SC_HANDLE
CreateServiceW(
    SC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
    LPCWSTR lpDisplayName,
    DWORD dwDesiredAccess,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCWSTR lpBinaryPathName,
    LPCWSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCWSTR lpDependencies,
    LPCWSTR lpServiceStartName,
    LPCWSTR lpPassword
    );
static const int CreateService = CreateServiceA;
BOOL
DeleteService(
    SC_HANDLE hService
    );
BOOL
EnumDependentServicesA(
    SC_HANDLE hService,
    DWORD dwServiceState,
                    LPENUM_SERVICE_STATUSA lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned
    );
BOOL
EnumDependentServicesW(
    SC_HANDLE hService,
    DWORD dwServiceState,
                    LPENUM_SERVICE_STATUSW lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned
    );
static const int EnumDependentServices = EnumDependentServicesA;
BOOL
EnumServicesStatusA(
    SC_HANDLE hSCManager,
    DWORD dwServiceType,
    DWORD dwServiceState,
                    LPENUM_SERVICE_STATUSA lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle
    );
BOOL
EnumServicesStatusW(
    SC_HANDLE hSCManager,
    DWORD dwServiceType,
    DWORD dwServiceState,
                    LPENUM_SERVICE_STATUSW lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle
    );
static const int EnumServicesStatus = EnumServicesStatusA;
BOOL
EnumServicesStatusExA(
    SC_HANDLE hSCManager,
    SC_ENUM_TYPE InfoLevel,
    DWORD dwServiceType,
    DWORD dwServiceState,
                    LPBYTE lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle,
    LPCSTR pszGroupName
    );
BOOL
EnumServicesStatusExW(
    SC_HANDLE hSCManager,
    SC_ENUM_TYPE InfoLevel,
    DWORD dwServiceType,
    DWORD dwServiceState,
                    LPBYTE lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle,
    LPCWSTR pszGroupName
    );
static const int EnumServicesStatusEx = EnumServicesStatusExA;
BOOL
GetServiceKeyNameA(
    SC_HANDLE hSCManager,
    LPCSTR lpDisplayName,
                    LPSTR lpServiceName,
    LPDWORD lpcchBuffer
    );
BOOL
GetServiceKeyNameW(
    SC_HANDLE hSCManager,
    LPCWSTR lpDisplayName,
                    LPWSTR lpServiceName,
    LPDWORD lpcchBuffer
    );
static const int GetServiceKeyName = GetServiceKeyNameA;
BOOL
GetServiceDisplayNameA(
    SC_HANDLE hSCManager,
    LPCSTR lpServiceName,
                    LPSTR lpDisplayName,
    LPDWORD lpcchBuffer
    );
BOOL
GetServiceDisplayNameW(
    SC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
                    LPWSTR lpDisplayName,
    LPDWORD lpcchBuffer
    );
static const int GetServiceDisplayName = GetServiceDisplayNameA;
SC_LOCK
LockServiceDatabase(
    SC_HANDLE hSCManager
    );
BOOL
NotifyBootConfigStatus(
    BOOL BootAcceptable
    );
SC_HANDLE
OpenSCManagerA(
    LPCSTR lpMachineName,
    LPCSTR lpDatabaseName,
    DWORD dwDesiredAccess
    );
SC_HANDLE
OpenSCManagerW(
    LPCWSTR lpMachineName,
    LPCWSTR lpDatabaseName,
    DWORD dwDesiredAccess
    );
static const int OpenSCManager = OpenSCManagerA;
SC_HANDLE
OpenServiceA(
    SC_HANDLE hSCManager,
    LPCSTR lpServiceName,
    DWORD dwDesiredAccess
    );
SC_HANDLE
OpenServiceW(
    SC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
    DWORD dwDesiredAccess
    );
static const int OpenService = OpenServiceA;
BOOL
QueryServiceConfigA(
    SC_HANDLE hService,
                    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
BOOL
QueryServiceConfigW(
    SC_HANDLE hService,
                    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
static const int QueryServiceConfig = QueryServiceConfigA;
BOOL
QueryServiceConfig2A(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
                    LPBYTE lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
BOOL
QueryServiceConfig2W(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
                    LPBYTE lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
static const int QueryServiceConfig2 = QueryServiceConfig2A;
BOOL
QueryServiceLockStatusA(
    SC_HANDLE hSCManager,
                    LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
BOOL
QueryServiceLockStatusW(
    SC_HANDLE hSCManager,
                    LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
static const int QueryServiceLockStatus = QueryServiceLockStatusA;
BOOL
QueryServiceObjectSecurity(
    SC_HANDLE hService,
    SECURITY_INFORMATION dwSecurityInformation,
                    PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
BOOL
QueryServiceStatus(
    SC_HANDLE hService,
    LPSERVICE_STATUS lpServiceStatus
    );
BOOL
QueryServiceStatusEx(
    SC_HANDLE hService,
    SC_STATUS_TYPE InfoLevel,
                    LPBYTE lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );
SERVICE_STATUS_HANDLE
RegisterServiceCtrlHandlerA(
    LPCSTR lpServiceName,
            LPHANDLER_FUNCTION lpHandlerProc
    );
SERVICE_STATUS_HANDLE
RegisterServiceCtrlHandlerW(
    LPCWSTR lpServiceName,
            LPHANDLER_FUNCTION lpHandlerProc
    );
static const int RegisterServiceCtrlHandler = RegisterServiceCtrlHandlerA;
SERVICE_STATUS_HANDLE
RegisterServiceCtrlHandlerExA(
    LPCSTR lpServiceName,
            LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext
    );
SERVICE_STATUS_HANDLE
RegisterServiceCtrlHandlerExW(
    LPCWSTR lpServiceName,
            LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext
    );
static const int RegisterServiceCtrlHandlerEx = RegisterServiceCtrlHandlerExA;
BOOL
SetServiceObjectSecurity(
    SC_HANDLE hService,
    SECURITY_INFORMATION dwSecurityInformation,
    PSECURITY_DESCRIPTOR lpSecurityDescriptor
    );
BOOL
SetServiceStatus(
    SERVICE_STATUS_HANDLE hServiceStatus,
    LPSERVICE_STATUS lpServiceStatus
    );
BOOL
StartServiceCtrlDispatcherA(
    const SERVICE_TABLE_ENTRYA *lpServiceStartTable
    );
BOOL
StartServiceCtrlDispatcherW(
    const SERVICE_TABLE_ENTRYW *lpServiceStartTable
    );
static const int StartServiceCtrlDispatcher = StartServiceCtrlDispatcherA;
BOOL
StartServiceA(
    SC_HANDLE hService,
    DWORD dwNumServiceArgs,
                    LPCSTR *lpServiceArgVectors
    );
BOOL
StartServiceW(
    SC_HANDLE hService,
    DWORD dwNumServiceArgs,
                    LPCWSTR *lpServiceArgVectors
    );
static const int StartService = StartServiceA;
BOOL
UnlockServiceDatabase(
    SC_LOCK ScLock
    );
DWORD
NotifyServiceStatusChangeA (
    SC_HANDLE hService,
    DWORD dwNotifyMask,
    PSERVICE_NOTIFYA pNotifyBuffer
    );
DWORD
NotifyServiceStatusChangeW (
    SC_HANDLE hService,
    DWORD dwNotifyMask,
    PSERVICE_NOTIFYW pNotifyBuffer
    );
static const int NotifyServiceStatusChange = NotifyServiceStatusChangeA;
BOOL
ControlServiceExA(
    SC_HANDLE hService,
    DWORD dwControl,
    DWORD dwInfoLevel,
    PVOID pControlParams
    );
BOOL
ControlServiceExW(
    SC_HANDLE hService,
    DWORD dwControl,
    DWORD dwInfoLevel,
    PVOID pControlParams
    );
static const int ControlServiceEx = ControlServiceExA;
# 222 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h" 1
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
# 10 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
typedef struct _MODEMDEVCAPS {
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;
    // product and version identification
    DWORD dwModemProviderVersion;
    DWORD dwModemManufacturerOffset;
    DWORD dwModemManufacturerSize;
    DWORD dwModemModelOffset;
    DWORD dwModemModelSize;
    DWORD dwModemVersionOffset;
    DWORD dwModemVersionSize;
    // local option capabilities
    DWORD dwDialOptions; // bitmap of supported values
    DWORD dwCallSetupFailTimer; // maximum in seconds
    DWORD dwInactivityTimeout; // maximum in seconds
    DWORD dwSpeakerVolume; // bitmap of supported values
    DWORD dwSpeakerMode; // bitmap of supported values
    DWORD dwModemOptions; // bitmap of supported values
    DWORD dwMaxDTERate; // maximum value in bit/s
    DWORD dwMaxDCERate; // maximum value in bit/s
    // Variable portion for proprietary expansion
    BYTE abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;
typedef struct _MODEMSETTINGS {
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;
    // static local options (read/write)
    DWORD dwCallSetupFailTimer; // seconds
    DWORD dwInactivityTimeout; // seconds
    DWORD dwSpeakerVolume; // level
    DWORD dwSpeakerMode; // mode
    DWORD dwPreferredModemOptions; // bitmap
    // negotiated options (read only) for current or last call
    DWORD dwNegotiatedModemOptions; // bitmap
    DWORD dwNegotiatedDCERate; // bit/s
    // Variable portion for proprietary expansion
    BYTE abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;
// Dial Options
static const int DIALOPTION_BILLING = 0x00000040;
static const int DIALOPTION_QUIET = 0x00000080;
static const int DIALOPTION_DIALTONE = 0x00000100;
// SpeakerVolume for MODEMDEVCAPS
static const int MDMVOLFLAG_LOW = 0x00000001;
static const int MDMVOLFLAG_MEDIUM = 0x00000002;
static const int MDMVOLFLAG_HIGH = 0x00000004;
// SpeakerVolume for MODEMSETTINGS
static const int MDMVOL_LOW = 0x00000000;
static const int MDMVOL_MEDIUM = 0x00000001;
static const int MDMVOL_HIGH = 0x00000002;
// SpeakerMode for MODEMDEVCAPS
static const int MDMSPKRFLAG_OFF = 0x00000001;
static const int MDMSPKRFLAG_DIAL = 0x00000002;
static const int MDMSPKRFLAG_ON = 0x00000004;
static const int MDMSPKRFLAG_CALLSETUP = 0x00000008;
// SpeakerMode for MODEMSETTINGS
static const int MDMSPKR_OFF = 0x00000000;
static const int MDMSPKR_DIAL = 0x00000001;
static const int MDMSPKR_ON = 0x00000002;
static const int MDMSPKR_CALLSETUP = 0x00000003;
// Modem Options
static const int MDM_COMPRESSION = 0x00000001;
static const int MDM_ERROR_CONTROL = 0x00000002;
static const int MDM_FORCED_EC = 0x00000004;
static const int MDM_CELLULAR = 0x00000008;
static const int MDM_FLOWCONTROL_HARD = 0x00000010;
static const int MDM_FLOWCONTROL_SOFT = 0x00000020;
static const int MDM_CCITT_OVERRIDE = 0x00000040;
static const int MDM_SPEED_ADJUST = 0x00000080;
static const int MDM_TONE_DIAL = 0x00000100;
static const int MDM_BLIND_DIAL = 0x00000200;
static const int MDM_V23_OVERRIDE = 0x00000400;
static const int MDM_DIAGNOSTICS = 0x00000800;
//=========================================================================
//
//
//      EXTENDED MODEM OPTIONS INFORMATION
//
//      THE following macros define additional bits in dwPreferredModemOptions.
//
//      These bits specify information relevant to making ISDN and GSM
//      calls, such as which protocol to use.
//
//=========================================================================
static const int MDM_MASK_BEARERMODE = 0x0000f000;
static const int MDM_SHIFT_BEARERMODE = 12;
static const int MDM_MASK_PROTOCOLID = 0x000f0000;
static const int MDM_SHIFT_PROTOCOLID = 16;
static const int MDM_MASK_PROTOCOLDATA = 0x0ff00000;
static const int MDM_SHIFT_PROTOCOLDATA = 20;
//
// PROTOCOLINFO is the union of PROTOCOLID and PROTOCOLDATA ...
//
static const int MDM_MASK_PROTOCOLINFO = (MDM_MASK_PROTOCOLID|MDM_MASK_PROTOCOLDATA);
static const int MDM_SHIFT_PROTOCOLINFO = MDM_SHIFT_PROTOCOLID;
//
// EXTENDEDINFO is the union of BEARERMODE and PROTOCOLINFO
//
static const int MDM_MASK_EXTENDEDINFO = (MDM_MASK_BEARERMODE|MDM_MASK_PROTOCOLINFO);
static const int MDM_SHIFT_EXTENDEDINFO = MDM_SHIFT_BEARERMODE;
static const int MDM_GET_BEARERMODE(_dwOptions) = (((_dwOptions)&MDM_MASK_BEARERMODE) >> MDM_SHIFT_BEARERMODE);
static const int MDM_SET_BEARERMODE(_dwOptions,_bm) = (((_dwOptions) &= ~MDM_MASK_BEARERMODE), ((_dwOptions) |= (((_bm)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE)));
static const int MDM_GET_PROTOCOLID(_dwOptions) = (((_dwOptions)&MDM_MASK_PROTOCOLID) >> MDM_SHIFT_PROTOCOLID);
static const int MDM_SET_PROTOCOLID(_dwOptions,_prot) = (((_dwOptions) &= ~MDM_MASK_PROTOCOLID), ((_dwOptions) |= (((_prot)<<MDM_SHIFT_PROTOCOLID)&MDM_MASK_PROTOCOLID)));
static const int MDM_GET_PROTOCOLDATA(_dwOptions) = (((_dwOptions)&MDM_MASK_PROTOCOLDATA) >> MDM_SHIFT_PROTOCOLDATA);
static const int MDM_SET_PROTOCOLDATA(_dwOptions,_pd) = (((_dwOptions) &= ~MDM_MASK_PROTOCOLDATA), ((_dwOptions) |= (((_pd)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA)));
//
// MDM_GET_PROTOCOLINFO gets the protocol-id and info bits in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
static const int MDM_GET_PROTOCOLINFO(_dwOptions) = ((_dwOptions)&MDM_MASK_PROTOCOLINFO);
//
// MDM_SET_PROTOCOLINFO takes as its argument the protocol-id and info bits in
// their IN-PLACE form (final position within dwModemPreferredOptions)
//
static const int MDM_SET_PROTOCOLINFO(_dwOptions,_pinfo) = (((_dwOptions) &= ~MDM_MASK_PROTOCOLINFO), ((_dwOptions) |= ((_pinfo)&MDM_MASK_PROTOCOLINFO)));
//
// MDM_GEN_PROTOCOLINFO generates the  the protocol-id and info bits in
// their IN-PLACE form (final position  within dwModemPreferredOptions).
//
static const int MDM_GEN_PROTOCOLINFO(_pid,_pdata) = ((((_pid )<<MDM_SHIFT_PROTOCOLID )&MDM_MASK_PROTOCOLID ) |(((_pdata)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA));
//
// MDM_GET_EXTENDEDIONFO gets the bearermode and protocol information in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
static const int MDM_GET_EXTENDEDINFO(_dwOptions) = ((_dwOptions)&MDM_MASK_EXTENDEDINFO);
//
// MDM_SET_PROTOCOLINFO takes as its argument the bearermode and
// protocol bits in their IN-PLACE form (final position within
// dwModemPreferredOptions)
//
static const int MDM_SET_EXTENDEDINFO(_dwOptions,_extinfo) = (((_dwOptions) &= ~MDM_MASK_EXTENDEDINFO), ((_dwOptions) |= ((_extinfo) & MDM_MASK_EXTENDEDINFO)));
//
// MDM_GEN_EXTENDEDINFO generates the bearermode and protocol information
// in their IN-PLACE form (final position within dwModemPreferredOptions0.
//
static const int MDM_GEN_EXTENDEDINFO(_bearermode,_pinfo) = (((_pinfo)&MDM_MASK_PROTOCOLINFO ) |(((_bearermode)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE));
//=========================================================================
//  BEARER MODES
//=========================================================================
//
static const int MDM_BEARERMODE_ANALOG = 0x0;
static const int MDM_BEARERMODE_ISDN = 0x1;
static const int MDM_BEARERMODE_GSM = 0x2;
//=========================================================================
//  PROTOCOL IDs
//=========================================================================
//
static const int MDM_PROTOCOLID_DEFAULT = 0x0;
static const int MDM_PROTOCOLID_HDLCPPP = 0x1;
static const int MDM_PROTOCOLID_V128 = 0x2;
static const int MDM_PROTOCOLID_X75 = 0x3;
static const int MDM_PROTOCOLID_V110 = 0x4;
static const int MDM_PROTOCOLID_V120 = 0x5;
static const int MDM_PROTOCOLID_AUTO = 0x6;
static const int MDM_PROTOCOLID_ANALOG = 0x7;
static const int MDM_PROTOCOLID_GPRS = 0x8;
static const int MDM_PROTOCOLID_PIAFS = 0x9;
//=========================================================================
//  HDLC PPP PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to the HDLC-PPP protocol.
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
static const int MDM_SHIFT_HDLCPPP_SPEED = 0x0;
static const int MDM_MASK_HDLCPPP_SPEED = 0x7;
static const int MDM_HDLCPPP_SPEED_DEFAULT = 0x0;
static const int MDM_HDLCPPP_SPEED_64K = 0x1;
static const int MDM_HDLCPPP_SPEED_56K = 0x2;
static const int MDM_SHIFT_HDLCPPP_AUTH = 0x3;
static const int MDM_MASK_HDLCPPP_AUTH = (0x7<<3);
static const int MDM_HDLCPPP_AUTH_DEFAULT = 0x0;
static const int MDM_HDLCPPP_AUTH_NONE = 0x1;
static const int MDM_HDLCPPP_AUTH_PAP = 0x2;
static const int MDM_HDLCPPP_AUTH_CHAP = 0x3;
static const int MDM_HDLCPPP_AUTH_MSCHAP = 0x4;
static const int MDM_SHIFT_HDLCPPP_ML = 0x6;
static const int MDM_MASK_HDLCPPP_ML = (0x3<<6);
static const int MDM_HDLCPPP_ML_DEFAULT = 0x0;
static const int MDM_HDLCPPP_ML_NONE = 0x1;
static const int MDM_HDLCPPP_ML_2 = 0x2;
static const int MDM_GEN_HDLCPPP_PROTOCOL_DATA(_speed,_auth,_ml) = ((((_speed)<<MDM_SHIFT_HDLCPPP_SPEED)&MDM_MASK_HDLCPPP_SPEED) |(((_auth )<<MDM_SHIFT_HDLCPPP_AUTH )&MDM_MASK_HDLCPPP_AUTH ) |(((_ml )<<MDM_SHIFT_HDLCPPP_ML )&MDM_MASK_HDLCPPP_ML ));
static const int MDM_PROTOCOL_HDLCPPP_64K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_DEFAULT ) );
# 285 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_56K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_DEFAULT ) );
# 295 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_112K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_2 ) );
# 305 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_112K_PAP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_PAP, MDM_HDLCPPP_ML_2 ) );
# 315 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_112K_CHAP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_CHAP, MDM_HDLCPPP_ML_2 ) );
# 325 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_112K_MSCHAP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_MSCHAP, MDM_HDLCPPP_ML_2 ) );
# 334 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_128K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_2 ) );
# 344 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_128K_PAP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_PAP, MDM_HDLCPPP_ML_2 ) );
# 354 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_128K_CHAP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_CHAP, MDM_HDLCPPP_ML_2 ) );
# 364 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_HDLCPPP_128K_MSCHAP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_MSCHAP, MDM_HDLCPPP_ML_2 ) );
# 374 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  V120 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
static const int MDM_SHIFT_V120_SPEED = 0x0;
static const int MDM_MASK_V120_SPEED = 0x7;
static const int MDM_V120_SPEED_DEFAULT = 0x0;
static const int MDM_V120_SPEED_64K = 0x1;
static const int MDM_V120_SPEED_56K = 0x2;
static const int MDM_SHIFT_V120_ML = 0x6;
static const int MDM_MASK_V120_ML = (0x3<<6);
static const int MDM_V120_ML_DEFAULT = 0x0;
static const int MDM_V120_ML_NONE = 0x1;
static const int MDM_V120_ML_2 = 0x2;
static const int MDM_GEN_V120_PROTOCOL_DATA(_speed,_ml) = ((((_speed)<<MDM_SHIFT_V120_SPEED)&MDM_MASK_V120_SPEED) |(((_ml )<<MDM_SHIFT_V120_ML )&MDM_MASK_V120_ML ));
static const int MDM_PROTOCOL_V120_64K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_64K, MDM_V120_ML_NONE ) );
# 411 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_V120_56K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_56K, MDM_V120_ML_NONE ) );
# 420 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_V120_112K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_56K, MDM_V120_ML_2 ) );
# 429 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_V120_128K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_64K, MDM_V120_ML_2 ) );
# 439 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  X75 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
static const int MDM_SHIFT_X75_DATA = 0x0;
static const int MDM_MASK_X75_DATA = 0x7;
static const int MDM_X75_DATA_DEFAULT = 0x0;
static const int MDM_X75_DATA_64K = 0x1;
static const int MDM_X75_DATA_128K = 0x2;
static const int MDM_X75_DATA_T_70 = 0x3;
static const int MDM_X75_DATA_BTX = 0x4;
static const int MDM_GEN_X75_PROTOCOL_DATA(_data) = (((_data)<<MDM_SHIFT_X75_DATA)&MDM_MASK_X75_DATA);
static const int MDM_PROTOCOL_X75_64K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_64K ) );
static const int MDM_PROTOCOL_X75_128K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_128K ) );
static const int MDM_PROTOCOL_X75_T_70 = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_T_70 ) );
static const int MDM_PROTOCOL_X75_BTX = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_BTX ) );
# 493 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  V110 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
static const int MDM_SHIFT_V110_SPEED = 0x0;
static const int MDM_MASK_V110_SPEED = 0xf;
static const int MDM_V110_SPEED_DEFAULT = 0x0;
static const int MDM_V110_SPEED_1DOT2K = 0x1;
static const int MDM_V110_SPEED_2DOT4K = 0x2;
static const int MDM_V110_SPEED_4DOT8K = 0x3;
static const int MDM_V110_SPEED_9DOT6K = 0x4;
static const int MDM_V110_SPEED_12DOT0K = 0x5;
static const int MDM_V110_SPEED_14DOT4K = 0x6;
static const int MDM_V110_SPEED_19DOT2K = 0x7;
static const int MDM_V110_SPEED_28DOT8K = 0x8;
static const int MDM_V110_SPEED_38DOT4K = 0x9;
static const int MDM_V110_SPEED_57DOT6K = 0xA;
static const int MDM_GEN_V110_PROTOCOL_DATA(_data) = (((_data)<<MDM_SHIFT_V110_SPEED)&MDM_MASK_V110_SPEED);
static const int MDM_PROTOCOL_V110_1DOT2K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_1DOT2K ) );
static const int MDM_PROTOCOL_V110_2DOT4K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_2DOT4K ) );
static const int MDM_PROTOCOL_V110_4DOT8K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_4DOT8K ) );
static const int MDM_PROTOCOL_V110_9DOT6K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_9DOT6K ) );
static const int MDM_PROTOCOL_V110_12DOT0K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_12DOT0K ) );
static const int MDM_PROTOCOL_V110_14DOT4K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_14DOT4K ) );
static const int MDM_PROTOCOL_V110_19DOT2K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_19DOT2K ) );
static const int MDM_PROTOCOL_V110_28DOT8K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_28DOT8K ) );
static const int MDM_PROTOCOL_V110_38DOT4K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_38DOT4K ) );
static const int MDM_PROTOCOL_V110_57DOT6K = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_57DOT6K ) );
//=========================================================================
//  AUTO PROTOCOL INFORMATION (ie, when the protocol is detected automatically)
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
//
// Following are specific to the AUTO-protocol
//
static const int MDM_SHIFT_AUTO_SPEED = 0x0;
static const int MDM_MASK_AUTO_SPEED = 0x7;
static const int MDM_AUTO_SPEED_DEFAULT = 0x0;
static const int MDM_SHIFT_AUTO_ML = 0x6;
static const int MDM_MASK_AUTO_ML = (0x3<<6);
static const int MDM_AUTO_ML_DEFAULT = 0x0;
static const int MDM_AUTO_ML_NONE = 0x1;
static const int MDM_AUTO_ML_2 = 0x2;
static const int MDM_GEN_AUTO_PROTOCOL_DATA(_speed,_ml) = ((((_speed)<<MDM_SHIFT_AUTO_SPEED)&MDM_MASK_AUTO_SPEED) |(((_ml )<<MDM_SHIFT_AUTO_ML )&MDM_MASK_AUTO_ML));
static const int MDM_PROTOCOL_AUTO_1CH = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_AUTO, MDM_GEN_AUTO_PROTOCOL_DATA ( MDM_AUTO_SPEED_DEFAULT, MDM_AUTO_ML_NONE ) );
# 634 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
static const int MDM_PROTOCOL_AUTO_2CH = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_AUTO, MDM_GEN_AUTO_PROTOCOL_DATA ( MDM_AUTO_SPEED_DEFAULT, MDM_AUTO_ML_2 ) );
# 643 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  ANALOG PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GSM Analog protocol
//
static const int MDM_ANALOG_RLP_ON = 0x0;
static const int MDM_ANALOG_RLP_OFF = 0x1;
static const int MDM_ANALOG_V34 = 0x2;
static const int MDM_GEN_ANALOG_PROTOCOL_DATA(_rlp) = (_rlp);
static const int MDM_PROTOCOL_ANALOG_RLP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_ANALOG, MDM_GEN_ANALOG_PROTOCOL_DATA ( MDM_ANALOG_RLP_ON ) );
static const int MDM_PROTOCOL_ANALOG_NRLP = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_ANALOG, MDM_GEN_ANALOG_PROTOCOL_DATA ( MDM_ANALOG_RLP_OFF ) );
//
//  v34 anolog for isdn
//
static const int MDM_PROTOCOL_ANALOG_V34 = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_ANALOG, MDM_GEN_ANALOG_PROTOCOL_DATA ( MDM_ANALOG_V34 ) );
# 686 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  GPRS PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GPRS protocol
//
static const int MDM_PROTOCOL_GPRS = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_GPRS, 0 );
//=========================================================================
//  PIAFS PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to PIAFS protocol
//
static const int MDM_PIAFS_INCOMING = 0;
static const int MDM_PIAFS_OUTGOING = 1;
static const int MDM_PROTOCOL_PIAFS_INCOMING = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_PIAFS, MDM_PIAFS_INCOMING );
static const int MDM_PROTOCOL_PIAFS_OUTGOING = MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_PIAFS, MDM_PIAFS_OUTGOING );
# 227 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/imm.h" 1
/**********************************************************************/
/*      imm.h - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) Microsoft Corporation. All rights reserved.     */
/**********************************************************************/
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/imm.h"
struct HIMC__{int unused;}; typedef struct HIMC__ *HIMC;
struct HIMCC__{int unused;}; typedef struct HIMCC__ *HIMCC;
typedef HKL *LPHKL;
typedef UINT *LPUINT;
typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, *NPCOMPOSITIONFORM, *LPCOMPOSITIONFORM;
typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, *NPCANDIDATEFORM, *LPCANDIDATEFORM;
typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, *NPCANDIDATELIST, *LPCANDIDATELIST;
typedef struct tagREGISTERWORDA {
    LPSTR lpReading;
    LPSTR lpWord;
} REGISTERWORDA, *PREGISTERWORDA, *NPREGISTERWORDA, *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR lpReading;
    LPWSTR lpWord;
} REGISTERWORDW, *PREGISTERWORDW, *NPREGISTERWORDW, *LPREGISTERWORDW;
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, *NPRECONVERTSTRING, *LPRECONVERTSTRING;
static const int STYLE_DESCRIPTION_SIZE = 32;
typedef struct tagSTYLEBUFA {
    DWORD dwStyle;
    CHAR szDescription[32];
} STYLEBUFA, *PSTYLEBUFA, *NPSTYLEBUFA, *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD dwStyle;
    WCHAR szDescription[32];
} STYLEBUFW, *PSTYLEBUFW, *NPSTYLEBUFW, *LPSTYLEBUFW;
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
static const int IMEMENUITEM_STRING_SIZE = 80;
typedef struct tagIMEMENUITEMINFOA {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[80];
    HBITMAP hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, *NPIMEMENUITEMINFOA, *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[80];
    HBITMAP hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, *NPIMEMENUITEMINFOW, *LPIMEMENUITEMINFOW;
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
typedef struct tagIMECHARPOSITION {
    DWORD dwSize;
    DWORD dwCharPos;
    POINT pt;
    UINT cLineHeight;
    RECT rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, *NPIMECHARPOSITION, *LPIMECHARPOSITION;
typedef BOOL (* IMCENUMPROC)(HIMC, LPARAM);
// prototype of IMM API
HKL ImmInstallIMEA( LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL ImmInstallIMEW( LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
static const int ImmInstallIME = ImmInstallIMEA;
HWND ImmGetDefaultIMEWnd( HWND);
UINT ImmGetDescriptionA( HKL, LPSTR lpszDescription, UINT uBufLen);
UINT ImmGetDescriptionW( HKL, LPWSTR lpszDescription, UINT uBufLen);
static const int ImmGetDescription = ImmGetDescriptionA;
UINT ImmGetIMEFileNameA( HKL, LPSTR lpszFileName, UINT uBufLen);
UINT ImmGetIMEFileNameW( HKL, LPWSTR lpszFileName, UINT uBufLen);
static const int ImmGetIMEFileName = ImmGetIMEFileNameA;
DWORD ImmGetProperty( HKL, DWORD);
BOOL ImmIsIME( HKL);
BOOL ImmSimulateHotKey( HWND, DWORD);
HIMC ImmCreateContext(void);
BOOL ImmDestroyContext( HIMC);
HIMC ImmGetContext( HWND);
BOOL ImmReleaseContext( HWND, HIMC);
HIMC ImmAssociateContext( HWND, HIMC);
BOOL ImmAssociateContextEx( HWND, HIMC, DWORD);
LONG ImmGetCompositionStringA( HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);
LONG ImmGetCompositionStringW( HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);
static const int ImmGetCompositionString = ImmGetCompositionStringA;
BOOL ImmSetCompositionStringA( HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
BOOL ImmSetCompositionStringW( HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
static const int ImmSetCompositionString = ImmSetCompositionStringA;
DWORD ImmGetCandidateListCountA( HIMC, LPDWORD lpdwListCount);
DWORD ImmGetCandidateListCountW( HIMC, LPDWORD lpdwListCount);
static const int ImmGetCandidateListCount = ImmGetCandidateListCountA;
DWORD ImmGetCandidateListA( HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);
DWORD ImmGetCandidateListW( HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);
static const int ImmGetCandidateList = ImmGetCandidateListA;
DWORD ImmGetGuideLineA( HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen);
DWORD ImmGetGuideLineW( HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen);
static const int ImmGetGuideLine = ImmGetGuideLineA;
BOOL ImmGetConversionStatus( HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence);
BOOL ImmSetConversionStatus( HIMC, DWORD, DWORD);
BOOL ImmGetOpenStatus( HIMC);
BOOL ImmSetOpenStatus( HIMC, BOOL);
BOOL ImmGetCompositionFontA( HIMC, LPLOGFONTA lplf);
BOOL ImmGetCompositionFontW( HIMC, LPLOGFONTW lplf);
static const int ImmGetCompositionFont = ImmGetCompositionFontA;
BOOL ImmSetCompositionFontA( HIMC, LPLOGFONTA lplf);
BOOL ImmSetCompositionFontW( HIMC, LPLOGFONTW lplf);
static const int ImmSetCompositionFont = ImmSetCompositionFontA;
BOOL ImmConfigureIMEA( HKL, HWND, DWORD, LPVOID);
BOOL ImmConfigureIMEW( HKL, HWND, DWORD, LPVOID);
static const int ImmConfigureIME = ImmConfigureIMEA;
LRESULT ImmEscapeA( HKL, HIMC, UINT, LPVOID);
LRESULT ImmEscapeW( HKL, HIMC, UINT, LPVOID);
static const int ImmEscape = ImmEscapeA;
DWORD ImmGetConversionListA( HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);
DWORD ImmGetConversionListW( HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);
static const int ImmGetConversionList = ImmGetConversionListA;
BOOL ImmNotifyIME( HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
BOOL ImmGetStatusWindowPos( HIMC, LPPOINT lpptPos);
BOOL ImmSetStatusWindowPos( HIMC, LPPOINT lpptPos);
BOOL ImmGetCompositionWindow( HIMC, LPCOMPOSITIONFORM lpCompForm);
BOOL ImmSetCompositionWindow( HIMC, LPCOMPOSITIONFORM lpCompForm);
BOOL ImmGetCandidateWindow( HIMC, DWORD, LPCANDIDATEFORM lpCandidate);
BOOL ImmSetCandidateWindow( HIMC, LPCANDIDATEFORM lpCandidate);
BOOL ImmIsUIMessageA( HWND, UINT, WPARAM, LPARAM);
BOOL ImmIsUIMessageW( HWND, UINT, WPARAM, LPARAM);
static const int ImmIsUIMessage = ImmIsUIMessageA;
UINT ImmGetVirtualKey( HWND);
typedef int ( *REGISTERWORDENUMPROCA)( LPCSTR lpszReading, DWORD, LPCSTR lpszString, LPVOID);
typedef int ( *REGISTERWORDENUMPROCW)( LPCWSTR lpszReading, DWORD, LPCWSTR lpszString, LPVOID);
static const int REGISTERWORDENUMPROC = REGISTERWORDENUMPROCA;
BOOL ImmRegisterWordA( HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
BOOL ImmRegisterWordW( HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
static const int ImmRegisterWord = ImmRegisterWordA;
BOOL ImmUnregisterWordA( HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
BOOL ImmUnregisterWordW( HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
static const int ImmUnregisterWord = ImmUnregisterWordA;
UINT ImmGetRegisterWordStyleA( HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
UINT ImmGetRegisterWordStyleW( HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);
static const int ImmGetRegisterWordStyle = ImmGetRegisterWordStyleA;
UINT ImmEnumRegisterWordA( HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
UINT ImmEnumRegisterWordW( HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);
static const int ImmEnumRegisterWord = ImmEnumRegisterWordA;
BOOL ImmDisableIME( DWORD);
BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD ImmGetImeMenuItemsA( HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize);
DWORD ImmGetImeMenuItemsW( HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize);
static const int ImmGetImeMenuItems = ImmGetImeMenuItemsA;
BOOL ImmDisableTextFrameService(DWORD idThread);
// wParam for WM_IME_CONTROL
static const int IMC_GETCANDIDATEPOS = 0x0007;
static const int IMC_SETCANDIDATEPOS = 0x0008;
static const int IMC_GETCOMPOSITIONFONT = 0x0009;
static const int IMC_SETCOMPOSITIONFONT = 0x000A;
static const int IMC_GETCOMPOSITIONWINDOW = 0x000B;
static const int IMC_SETCOMPOSITIONWINDOW = 0x000C;
static const double IMC_GETSTATUSWINDOWPOS = 0x000F;
static const int IMC_SETSTATUSWINDOWPOS = 0x0010;
static const int IMC_CLOSESTATUSWINDOW = 0x0021;
static const int IMC_OPENSTATUSWINDOW = 0x0022;
// dwAction for ImmNotifyIME
static const int NI_OPENCANDIDATE = 0x0010;
static const int NI_CLOSECANDIDATE = 0x0011;
static const int NI_SELECTCANDIDATESTR = 0x0012;
static const int NI_CHANGECANDIDATELIST = 0x0013;
static const int NI_FINALIZECONVERSIONRESULT = 0x0014;
static const int NI_COMPOSITIONSTR = 0x0015;
static const int NI_SETCANDIDATE_PAGESTART = 0x0016;
static const int NI_SETCANDIDATE_PAGESIZE = 0x0017;
static const int NI_IMEMENUSELECTED = 0x0018;
// lParam for WM_IME_SETCONTEXT
static const int ISC_SHOWUICANDIDATEWINDOW = 0x00000001;
static const int ISC_SHOWUICOMPOSITIONWINDOW = 0x80000000;
static const int ISC_SHOWUIGUIDELINE = 0x40000000;
static const double ISC_SHOWUIALLCANDIDATEWINDOW = 0x0000000F;
static const double ISC_SHOWUIALL = 0xC000000F;
// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
static const int CPS_COMPLETE = 0x0001;
static const int CPS_CONVERT = 0x0002;
static const int CPS_REVERT = 0x0003;
static const int CPS_CANCEL = 0x0004;
// the modifiers of hot key
static const int MOD_ALT = 0x0001;
static const int MOD_CONTROL = 0x0002;
static const int MOD_SHIFT = 0x0004;
static const int MOD_LEFT = 0x8000;
static const int MOD_RIGHT = 0x4000;
static const int MOD_ON_KEYUP = 0x0800;
static const int MOD_IGNORE_ALL_MODIFIER = 0x0400;
// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
static const int IME_CHOTKEY_IME_NONIME_TOGGLE = 0x10;
static const int IME_CHOTKEY_SHAPE_TOGGLE = 0x11;
static const int IME_CHOTKEY_SYMBOL_TOGGLE = 0x12;
// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
static const int IME_JHOTKEY_CLOSE_OPEN = 0x30;
// Windows for Korean Edition hot key ID from 0x50 - 0x6F
static const int IME_KHOTKEY_SHAPE_TOGGLE = 0x50;
static const int IME_KHOTKEY_HANJACONVERT = 0x51;
static const int IME_KHOTKEY_ENGLISH = 0x52;
// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
static const int IME_THOTKEY_IME_NONIME_TOGGLE = 0x70;
static const int IME_THOTKEY_SHAPE_TOGGLE = 0x71;
static const int IME_THOTKEY_SYMBOL_TOGGLE = 0x72;
// direct switch hot key ID from 0x100 - 0x11F
static const int IME_HOTKEY_DSWITCH_FIRST = 0x100;
static const double IME_HOTKEY_DSWITCH_LAST = 0x11F;
// IME private hot key from 0x200 - 0x21F
static const int IME_HOTKEY_PRIVATE_FIRST = 0x200;
static const int IME_ITHOTKEY_RESEND_RESULTSTR = 0x200;
static const int IME_ITHOTKEY_PREVIOUS_COMPOSITION = 0x201;
static const int IME_ITHOTKEY_UISTYLE_TOGGLE = 0x202;
static const int IME_ITHOTKEY_RECONVERTSTRING = 0x203;
static const double IME_HOTKEY_PRIVATE_LAST = 0x21F;
// parameter of ImmGetCompositionString
static const int GCS_COMPREADSTR = 0x0001;
static const int GCS_COMPREADATTR = 0x0002;
static const int GCS_COMPREADCLAUSE = 0x0004;
static const int GCS_COMPSTR = 0x0008;
static const int GCS_COMPATTR = 0x0010;
static const int GCS_COMPCLAUSE = 0x0020;
static const int GCS_CURSORPOS = 0x0080;
static const int GCS_DELTASTART = 0x0100;
static const int GCS_RESULTREADSTR = 0x0200;
static const int GCS_RESULTREADCLAUSE = 0x0400;
static const int GCS_RESULTSTR = 0x0800;
static const int GCS_RESULTCLAUSE = 0x1000;
// style bit flags for WM_IME_COMPOSITION
static const int CS_INSERTCHAR = 0x2000;
static const int CS_NOMOVECARET = 0x4000;
// IME version constants
static const int IMEVER_0310 = 0x0003000A;
static const int IMEVER_0400 = 0x00040000;
// IME property bits
static const int IME_PROP_AT_CARET = 0x00010000;
static const int IME_PROP_SPECIAL_UI = 0x00020000;
static const int IME_PROP_CANDLIST_START_FROM_1 = 0x00040000;
static const int IME_PROP_UNICODE = 0x00080000;
static const int IME_PROP_COMPLETE_ON_UNSELECT = 0x00100000;
// IME UICapability bits
static const int UI_CAP_2700 = 0x00000001;
static const int UI_CAP_ROT90 = 0x00000002;
static const int UI_CAP_ROTANY = 0x00000004;
// ImmSetCompositionString Capability bits
static const int SCS_CAP_COMPSTR = 0x00000001;
static const int SCS_CAP_MAKEREAD = 0x00000002;
static const int SCS_CAP_SETRECONVERTSTRING = 0x00000004;
// IME WM_IME_SELECT inheritance Capability bits
static const int SELECT_CAP_CONVERSION = 0x00000001;
static const int SELECT_CAP_SENTENCE = 0x00000002;
// ID for deIndex of ImmGetGuideLine
static const int GGL_LEVEL = 0x00000001;
static const int GGL_INDEX = 0x00000002;
static const int GGL_STRING = 0x00000003;
static const int GGL_PRIVATE = 0x00000004;
// ID for dwLevel of GUIDELINE Structure
static const int GL_LEVEL_NOGUIDELINE = 0x00000000;
static const int GL_LEVEL_FATAL = 0x00000001;
static const int GL_LEVEL_ERROR = 0x00000002;
static const int GL_LEVEL_WARNING = 0x00000003;
static const int GL_LEVEL_INFORMATION = 0x00000004;
// ID for dwIndex of GUIDELINE Structure
static const int GL_ID_UNKNOWN = 0x00000000;
static const int GL_ID_NOMODULE = 0x00000001;
static const int GL_ID_NODICTIONARY = 0x00000010;
static const int GL_ID_CANNOTSAVE = 0x00000011;
static const int GL_ID_NOCONVERT = 0x00000020;
static const int GL_ID_TYPINGERROR = 0x00000021;
static const int GL_ID_TOOMANYSTROKE = 0x00000022;
static const int GL_ID_READINGCONFLICT = 0x00000023;
static const int GL_ID_INPUTREADING = 0x00000024;
static const int GL_ID_INPUTRADICAL = 0x00000025;
static const int GL_ID_INPUTCODE = 0x00000026;
static const int GL_ID_INPUTSYMBOL = 0x00000027;
static const int GL_ID_CHOOSECANDIDATE = 0x00000028;
static const int GL_ID_REVERSECONVERSION = 0x00000029;
static const int GL_ID_PRIVATE_FIRST = 0x00008000;
static const int GL_ID_PRIVATE_LAST = 0x0000FFFF;
// ID for dwIndex of ImmGetProperty
static const int IGP_GETIMEVERSION = (DWORD)(-4);
static const int IGP_PROPERTY = 0x00000004;
static const int IGP_CONVERSION = 0x00000008;
static const int IGP_SENTENCE = 0x0000000c;
static const int IGP_UI = 0x00000010;
static const int IGP_SETCOMPSTR = 0x00000014;
static const int IGP_SELECT = 0x00000018;
// dwIndex for ImmSetCompositionString API
static const int SCS_SETSTR = (GCS_COMPREADSTR|GCS_COMPSTR);
static const int SCS_CHANGEATTR = (GCS_COMPREADATTR|GCS_COMPATTR);
static const int SCS_CHANGECLAUSE = (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE);
static const int SCS_SETRECONVERTSTRING = 0x00010000;
static const int SCS_QUERYRECONVERTSTRING = 0x00020000;
// attribute for COMPOSITIONSTRING Structure
static const int ATTR_INPUT = 0x00;
static const int ATTR_TARGET_CONVERTED = 0x01;
static const int ATTR_CONVERTED = 0x02;
static const int ATTR_TARGET_NOTCONVERTED = 0x03;
static const int ATTR_INPUT_ERROR = 0x04;
static const int ATTR_FIXEDCONVERTED = 0x05;
// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
static const int CFS_DEFAULT = 0x0000;
static const int CFS_RECT = 0x0001;
static const int CFS_POINT = 0x0002;
static const int CFS_FORCE_POSITION = 0x0020;
static const int CFS_CANDIDATEPOS = 0x0040;
static const int CFS_EXCLUDE = 0x0080;
// conversion direction for ImmGetConversionList
static const int GCL_CONVERSION = 0x0001;
static const int GCL_REVERSECONVERSION = 0x0002;
static const int GCL_REVERSE_LENGTH = 0x0003;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ime_cmodes.h" 1
// bit field for conversion mode
static const int IME_CMODE_ALPHANUMERIC = 0x0000;
static const int IME_CMODE_NATIVE = 0x0001;
static const int IME_CMODE_CHINESE = IME_CMODE_NATIVE;
static const int IME_CMODE_HANGUL = IME_CMODE_NATIVE;
static const int IME_CMODE_JAPANESE = IME_CMODE_NATIVE;
static const int IME_CMODE_KATAKANA = 0x0002;
static const int IME_CMODE_LANGUAGE = 0x0003;
static const int IME_CMODE_FULLSHAPE = 0x0008;
static const int IME_CMODE_ROMAN = 0x0010;
static const int IME_CMODE_CHARCODE = 0x0020;
static const int IME_CMODE_HANJACONVERT = 0x0040;
# 570 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/imm.h" 2
// bit field for conversion mode
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
static const int IME_CMODE_HANGEUL = IME_CMODE_NATIVE;
static const int IME_CMODE_SOFTKBD = 0x0080;
static const int IME_CMODE_NOCONVERSION = 0x0100;
static const int IME_CMODE_EUDC = 0x0200;
static const int IME_CMODE_SYMBOL = 0x0400;
static const int IME_CMODE_FIXED = 0x0800;
static const int IME_CMODE_RESERVED = 0xF0000000;
// bit field for sentence mode
static const int IME_SMODE_NONE = 0x0000;
static const int IME_SMODE_PLAURALCLAUSE = 0x0001;
static const int IME_SMODE_SINGLECONVERT = 0x0002;
static const int IME_SMODE_AUTOMATIC = 0x0004;
static const int IME_SMODE_PHRASEPREDICT = 0x0008;
static const int IME_SMODE_CONVERSATION = 0x0010;
static const int IME_SMODE_RESERVED = 0x0000F000;
// style of candidate
static const int IME_CAND_UNKNOWN = 0x0000;
static const int IME_CAND_READ = 0x0001;
static const int IME_CAND_CODE = 0x0002;
static const int IME_CAND_MEANING = 0x0003;
static const int IME_CAND_RADICAL = 0x0004;
static const int IME_CAND_STROKE = 0x0005;
// wParam of report message WM_IME_NOTIFY
static const int IMN_CLOSESTATUSWINDOW = 0x0001;
static const int IMN_OPENSTATUSWINDOW = 0x0002;
static const int IMN_CHANGECANDIDATE = 0x0003;
static const int IMN_CLOSECANDIDATE = 0x0004;
static const int IMN_OPENCANDIDATE = 0x0005;
static const int IMN_SETCONVERSIONMODE = 0x0006;
static const int IMN_SETSENTENCEMODE = 0x0007;
static const int IMN_SETOPENSTATUS = 0x0008;
static const int IMN_SETCANDIDATEPOS = 0x0009;
static const int IMN_SETCOMPOSITIONFONT = 0x000A;
static const int IMN_SETCOMPOSITIONWINDOW = 0x000B;
static const int IMN_SETSTATUSWINDOWPOS = 0x000C;
static const int IMN_GUIDELINE = 0x000D;
static const int IMN_PRIVATE = 0x000E;
// wParam of report message WM_IME_REQUEST
static const int IMR_COMPOSITIONWINDOW = 0x0001;
static const int IMR_CANDIDATEWINDOW = 0x0002;
static const int IMR_COMPOSITIONFONT = 0x0003;
static const int IMR_RECONVERTSTRING = 0x0004;
static const int IMR_CONFIRMRECONVERTSTRING = 0x0005;
static const int IMR_QUERYCHARPOSITION = 0x0006;
static const int IMR_DOCUMENTFEED = 0x0007;
// error code of ImmGetCompositionString
static const int IMM_ERROR_NODATA = (-1);
static const int IMM_ERROR_GENERAL = (-2);
// dialog mode of ImmConfigureIME
static const int IME_CONFIG_GENERAL = 1;
static const int IME_CONFIG_REGISTERWORD = 2;
static const int IME_CONFIG_SELECTDICTIONARY = 3;
// flags for ImmEscape
static const int IME_ESC_QUERY_SUPPORT = 0x0003;
static const int IME_ESC_RESERVED_FIRST = 0x0004;
static const int IME_ESC_RESERVED_LAST = 0x07FF;
static const int IME_ESC_PRIVATE_FIRST = 0x0800;
static const int IME_ESC_PRIVATE_LAST = 0x0FFF;
static const int IME_ESC_SEQUENCE_TO_INTERNAL = 0x1001;
static const int IME_ESC_GET_EUDC_DICTIONARY = 0x1003;
static const int IME_ESC_SET_EUDC_DICTIONARY = 0x1004;
static const int IME_ESC_MAX_KEY = 0x1005;
static const int IME_ESC_IME_NAME = 0x1006;
static const int IME_ESC_SYNC_HOTKEY = 0x1007;
static const int IME_ESC_HANJA_MODE = 0x1008;
static const int IME_ESC_AUTOMATA = 0x1009;
static const int IME_ESC_PRIVATE_HOTKEY = 0x100a;
static const int IME_ESC_GETHELPFILENAME = 0x100b;
// style of word registration
static const int IME_REGWORD_STYLE_EUDC = 0x00000001;
static const int IME_REGWORD_STYLE_USER_FIRST = 0x80000000;
static const int IME_REGWORD_STYLE_USER_LAST = 0xFFFFFFFF;
// dwFlags for ImmAssociateContextEx
static const int IACE_CHILDREN = 0x0001;
static const int IACE_DEFAULT = 0x0010;
static const int IACE_IGNORENOCONTEXT = 0x0020;
// dwFlags for ImmGetImeMenuItems
static const int IGIMIF_RIGHTMENU = 0x0001;
// dwType for ImmGetImeMenuItems
static const int IGIMII_CMODE = 0x0001;
static const int IGIMII_SMODE = 0x0002;
static const int IGIMII_CONFIGURE = 0x0004;
static const int IGIMII_TOOLS = 0x0008;
static const int IGIMII_HELP = 0x0010;
static const int IGIMII_OTHER = 0x0020;
static const int IGIMII_INPUTTOOLS = 0x0040;
// fType of IMEMENUITEMINFO structure
static const int IMFT_RADIOCHECK = 0x00001;
static const int IMFT_SEPARATOR = 0x00002;
static const int IMFT_SUBMENU = 0x00004;
// fState of IMEMENUITEMINFO structure
static const int IMFS_GRAYED = MFS_GRAYED;
static const int IMFS_DISABLED = MFS_DISABLED;
static const int IMFS_CHECKED = MFS_CHECKED;
static const int IMFS_HILITE = MFS_HILITE;
static const int IMFS_ENABLED = MFS_ENABLED;
static const int IMFS_UNCHECKED = MFS_UNCHECKED;
static const int IMFS_UNHILITE = MFS_UNHILITE;
static const int IMFS_DEFAULT = MFS_DEFAULT;
// type of soft keyboard
// for Windows Tranditional Chinese Edition
static const int SOFTKEYBOARD_TYPE_T1 = 0x0001;
// for Windows Simplified Chinese Edition
static const int SOFTKEYBOARD_TYPE_C1 = 0x0002;
# 231 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 67 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 2
/*
 * Define the current Winsock version. To build an earlier Winsock version
 * application redefine this value prior to including Winsock2.h.
 */
static const int WINSOCK_VERSION = MAKEWORD(2,2);
/*
 * Establish DLL function linkage if supported by the current build
 * environment and not previously defined.
 */
static const int WINSOCK_API_LINKAGE = DECLSPEC_IMPORT;
# 100 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
# 103 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned __int64 u_int64;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h" 1
/*++
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    ws2def.h
Abstract:
    This file contains the core definitions for the Winsock2
    specification that can be used by both user-mode and 
    kernel mode modules.
    This file is included in WINSOCK2.H. User mode applications
    should include WINSOCK2.H rather than including this file
    directly. This file can not be included by a module that also
    includes WINSOCK.H.
Environment:
    user mode or kernel mode
--*/
# 27 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
# 41 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
//
// Allow Winsock components to disable PREfast errors.
//
# 58 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int WS2DEF_INLINE = extern inline;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/inaddr.h" 1
/*++
Copyright (c) Microsoft Corporation
Module Name:
    inaddr.h
Environment:
    user mode or kernel mode
--*/
# 16 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/inaddr.h"
//
// IPv4 Internet address
// This is an 'on-wire' format structure.
//
typedef struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
static const int s_addr = S_un.S_addr;
static const int s_host = S_un.S_un_b.s_b2;
static const int s_net = S_un.S_un_b.s_b1;
static const int s_imp = S_un.S_un_w.s_w2;
static const int s_impno = S_un.S_un_b.s_b4;
static const int s_lh = S_un.S_un_b.s_b3;
} IN_ADDR, *PIN_ADDR, *LPIN_ADDR;
# 64 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h" 2
//#if(_WIN32_WINNT >= 0x0600)
//
// Address families.
//
typedef USHORT ADDRESS_FAMILY;
//#endif//(_WIN32_WINNT >= 0x0600)
//
// Although AF_UNSPEC is defined for backwards compatibility, using
// AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
// DISCOURAGED.  The interpretation of the "protocol" parameter
// depends on the actual address family chosen.  As environments grow
// to include more and more address families that use overlapping
// protocol values there is more and more chance of choosing an
// undesired address family when AF_UNSPEC is used.
//
static const int AF_UNSPEC = 0;
static const int AF_UNIX = 1;
static const int AF_INET = 2;
static const int AF_IMPLINK = 3;
static const int AF_PUP = 4;
static const int AF_CHAOS = 5;
static const int AF_NS = 6;
static const int AF_IPX = AF_NS;
static const int AF_ISO = 7;
static const int AF_OSI = AF_ISO;
static const int AF_ECMA = 8;
static const int AF_DATAKIT = 9;
static const int AF_CCITT = 10;
static const int AF_SNA = 11;
static const int AF_DECnet = 12;
static const int AF_DLI = 13;
static const int AF_LAT = 14;
static const int AF_HYLINK = 15;
static const int AF_APPLETALK = 16;
static const int AF_NETBIOS = 17;
static const int AF_VOICEVIEW = 18;
static const int AF_FIREFOX = 19;
static const int AF_UNKNOWN1 = 20;
static const int AF_BAN = 21;
static const int AF_ATM = 22;
static const int AF_INET6 = 23;
static const int AF_CLUSTER = 24;
static const int AF_12844 = 25;
static const int AF_IRDA = 26;
static const int AF_NETDES = 28;
static const int AF_TCNPROCESS = 29;
static const int AF_TCNMESSAGE = 30;
static const int AF_ICLFXBM = 31;
static const int AF_BTH = 32;
static const int AF_LINK = 33;
static const int AF_MAX = 34;
//
// Socket types.
//
static const int SOCK_STREAM = 1;
static const int SOCK_DGRAM = 2;
static const int SOCK_RAW = 3;
static const int SOCK_RDM = 4;
static const int SOCK_SEQPACKET = 5;
//
// Define a level for socket I/O controls in the same numbering space as
// IPPROTO_TCP, IPPROTO_IP, etc.
//
static const int SOL_SOCKET = 0xffff;
//
// Define socket-level options.
//
static const int SO_DEBUG = 0x0001;
static const int SO_ACCEPTCONN = 0x0002;
static const int SO_REUSEADDR = 0x0004;
static const int SO_KEEPALIVE = 0x0008;
static const int SO_DONTROUTE = 0x0010;
static const int SO_BROADCAST = 0x0020;
static const int SO_USELOOPBACK = 0x0040;
static const int SO_LINGER = 0x0080;
static const int SO_OOBINLINE = 0x0100;
static const int SO_DONTLINGER = (int)(~SO_LINGER);
static const int SO_EXCLUSIVEADDRUSE = ((int)(~SO_REUSEADDR));
static const int SO_SNDBUF = 0x1001;
static const int SO_RCVBUF = 0x1002;
static const int SO_SNDLOWAT = 0x1003;
static const int SO_RCVLOWAT = 0x1004;
static const int SO_SNDTIMEO = 0x1005;
static const int SO_RCVTIMEO = 0x1006;
static const int SO_ERROR = 0x1007;
static const int SO_TYPE = 0x1008;
static const int SO_BSP_STATE = 0x1009;
static const int SO_GROUP_ID = 0x2001;
static const int SO_GROUP_PRIORITY = 0x2002;
static const int SO_MAX_MSG_SIZE = 0x2003;
static const int SO_CONDITIONAL_ACCEPT = 0x3002;
                                    // connection is not ack-ed to the
                                    // other side until conditional
                                    // function returns CF_ACCEPT
static const int SO_PAUSE_ACCEPT = 0x3003;
static const int SO_COMPARTMENT_ID = 0x3004;
static const int SO_RANDOMIZE_PORT = 0x3005;
static const int SO_PORT_SCALABILITY = 0x3006;
//
// Base constant used for defining WSK-specific options.
//
static const int WSK_SO_BASE = 0x4000;
//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
//
static const int TCP_NODELAY = 0x0001;
//
// Structure used to store most addresses.
//
typedef struct sockaddr {
    ADDRESS_FAMILY sa_family; // Address family.
    CHAR sa_data[14]; // Up to 14 bytes of direct address.
} SOCKADDR, *PSOCKADDR, *LPSOCKADDR;
/*
 * SockAddr Information
 */
# 230 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr;
    INT iSockaddrLength;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, *LPSOCKET_ADDRESS;
/*
 * Address list returned via SIO_ADDRESS_LIST_QUERY
 */
# 238 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _SOCKET_ADDRESS_LIST {
    INT iAddressCount;
    SOCKET_ADDRESS Address[1];
} SOCKET_ADDRESS_LIST, *PSOCKET_ADDRESS_LIST, *LPSOCKET_ADDRESS_LIST;
static const int SIZEOF_SOCKET_ADDRESS_LIST(AddressCount) = (FIELD_OFFSET(SOCKET_ADDRESS_LIST, Address) + AddressCount * sizeof(SOCKET_ADDRESS));
/*
 * CSAddr Information
 */
# 254 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO, * LPCSADDR_INFO ;
//
// Portable socket structure (RFC 2553).
//
//
// Desired design of maximum size and alignment.
// These are implementation specific.
//
static const int _SS_MAXSIZE = 128;
static const int _SS_ALIGNSIZE = (sizeof(__int64));
//
// Definitions used for sockaddr_storage structure paddings design.
//
static const int _SS_PAD1SIZE = (_SS_ALIGNSIZE - sizeof(USHORT));
static const int _SS_PAD2SIZE = (_SS_MAXSIZE - (sizeof(USHORT) + _SS_PAD1SIZE + _SS_ALIGNSIZE));
typedef struct sockaddr_storage {
    ADDRESS_FAMILY ss_family; // address family
    CHAR __ss_pad1[((sizeof(__int64)) - sizeof(USHORT))]; // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align; // Field to force desired structure
    CHAR __ss_pad2[(128 - (sizeof(USHORT) + ((sizeof(__int64)) - sizeof(USHORT)) + (sizeof(__int64))))]; // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_LH, *PSOCKADDR_STORAGE_LH, *LPSOCKADDR_STORAGE_LH;
typedef struct sockaddr_storage_xp {
    short ss_family; // Address family.
    CHAR __ss_pad1[((sizeof(__int64)) - sizeof(USHORT))]; // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align; // Field to force desired structure
    CHAR __ss_pad2[(128 - (sizeof(USHORT) + ((sizeof(__int64)) - sizeof(USHORT)) + (sizeof(__int64))))]; // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_XP, *PSOCKADDR_STORAGE_XP, *LPSOCKADDR_STORAGE_XP;
typedef SOCKADDR_STORAGE_LH SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, *LPSOCKADDR_STORAGE;
/*
 * WinSock 2 extension -- manifest constants for WSAIoctl()
 */
# 327 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int IOC_UNIX = 0x00000000;
static const int IOC_WS2 = 0x08000000;
static const int IOC_PROTOCOL = 0x10000000;
static const int IOC_VENDOR = 0x18000000;
/*
 * WSK-specific IO control codes are Winsock2 codes with the highest-order
 * 3 bits of the Vendor/AddressFamily-specific field set to 1.
 */
# 337 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int IOC_WSK = (IOC_WS2|0x07000000);
static const int _WSAIO(x,y) = (IOC_VOID|(x)|(y));
static const int _WSAIOR(x,y) = (IOC_OUT|(x)|(y));
static const int _WSAIOW(x,y) = (IOC_IN|(x)|(y));
static const int _WSAIORW(x,y) = (IOC_INOUT|(x)|(y));
static const int SIO_ASSOCIATE_HANDLE = _WSAIOW(IOC_WS2,1);
static const int SIO_ENABLE_CIRCULAR_QUEUEING = _WSAIO(IOC_WS2,2);
static const int SIO_FIND_ROUTE = _WSAIOR(IOC_WS2,3);
static const int SIO_FLUSH = _WSAIO(IOC_WS2,4);
static const int SIO_GET_BROADCAST_ADDRESS = _WSAIOR(IOC_WS2,5);
static const int SIO_GET_EXTENSION_FUNCTION_POINTER = _WSAIORW(IOC_WS2,6);
static const int SIO_GET_QOS = _WSAIORW(IOC_WS2,7);
static const int SIO_GET_GROUP_QOS = _WSAIORW(IOC_WS2,8);
static const int SIO_MULTIPOINT_LOOPBACK = _WSAIOW(IOC_WS2,9);
static const int SIO_MULTICAST_SCOPE = _WSAIOW(IOC_WS2,10);
static const int SIO_SET_QOS = _WSAIOW(IOC_WS2,11);
static const int SIO_SET_GROUP_QOS = _WSAIOW(IOC_WS2,12);
static const int SIO_TRANSLATE_HANDLE = _WSAIORW(IOC_WS2,13);
static const int SIO_ROUTING_INTERFACE_QUERY = _WSAIORW(IOC_WS2,20);
static const int SIO_ROUTING_INTERFACE_CHANGE = _WSAIOW(IOC_WS2,21);
static const int SIO_ADDRESS_LIST_QUERY = _WSAIOR(IOC_WS2,22);
static const int SIO_ADDRESS_LIST_CHANGE = _WSAIO(IOC_WS2,23);
static const int SIO_QUERY_TARGET_PNP_HANDLE = _WSAIOR(IOC_WS2,24);
static const int SIO_ADDRESS_LIST_SORT = _WSAIORW(IOC_WS2,25);
static const int SIO_RESERVED_1 = _WSAIOW(IOC_WS2,26);
static const int SIO_RESERVED_2 = _WSAIOW(IOC_WS2,33);
//
// Constants and structures defined by the internet system (RFC 790)
//
//
// N.B. required for backwards compatability to support 0 = IP for the
// level argument to get/setsockopt.
//
static const int IPPROTO_IP = 0;
//
// Protocols.  The IPv6 defines are specified in RFC 2292.
//
typedef enum {
    IPPROTO_HOPOPTS = 0, // IPv6 Hop-by-Hop options
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_GGP = 3,
    IPPROTO_IPV4 = 4,
    IPPROTO_ST = 5,
    IPPROTO_TCP = 6,
    IPPROTO_CBT = 7,
    IPPROTO_EGP = 8,
    IPPROTO_IGP = 9,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_RDP = 27,
    IPPROTO_IPV6 = 41, // IPv6 header
    IPPROTO_ROUTING = 43, // IPv6 Routing header
    IPPROTO_FRAGMENT = 44, // IPv6 fragmentation header
    IPPROTO_ESP = 50, // encapsulating security payload
    IPPROTO_AH = 51, // authentication header
    IPPROTO_ICMPV6 = 58, // ICMPv6
    IPPROTO_NONE = 59, // IPv6 no next header
    IPPROTO_DSTOPTS = 60, // IPv6 Destination options
    IPPROTO_ND = 77,
    IPPROTO_ICLFXBM = 78,
    IPPROTO_PIM = 103,
    IPPROTO_PGM = 113,
    IPPROTO_L2TP = 115,
    IPPROTO_SCTP = 132,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
//
//  These are reserved for internal use by Windows.
//
    IPPROTO_RESERVED_RAW = 257,
    IPPROTO_RESERVED_IPSEC = 258,
    IPPROTO_RESERVED_IPSECOFFLOAD = 259,
    IPPROTO_RESERVED_MAX = 260
} IPPROTO, *PIPROTO;
//
// Port/socket numbers: network standard functions
//
static const int IPPORT_TCPMUX = 1;
static const int IPPORT_ECHO = 7;
static const int IPPORT_DISCARD = 9;
static const int IPPORT_SYSTAT = 11;
static const int IPPORT_DAYTIME = 13;
static const int IPPORT_NETSTAT = 15;
static const int IPPORT_QOTD = 17;
static const int IPPORT_MSP = 18;
static const int IPPORT_CHARGEN = 19;
static const int IPPORT_FTP_DATA = 20;
static const int IPPORT_FTP = 21;
static const int IPPORT_TELNET = 23;
static const int IPPORT_SMTP = 25;
static const int IPPORT_TIMESERVER = 37;
static const int IPPORT_NAMESERVER = 42;
static const int IPPORT_WHOIS = 43;
static const int IPPORT_MTP = 57;
/*
 * Port/socket numbers: host specific functions
 */
# 469 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int IPPORT_TFTP = 69;
static const int IPPORT_RJE = 77;
static const int IPPORT_FINGER = 79;
static const int IPPORT_TTYLINK = 87;
static const int IPPORT_SUPDUP = 95;
/*
 * UNIX TCP sockets
 */
# 478 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int IPPORT_POP3 = 110;
static const int IPPORT_NTP = 123;
static const int IPPORT_EPMAP = 135;
static const int IPPORT_NETBIOS_NS = 137;
static const int IPPORT_NETBIOS_DGM = 138;
static const int IPPORT_NETBIOS_SSN = 139;
static const int IPPORT_IMAP = 143;
static const int IPPORT_SNMP = 161;
static const int IPPORT_SNMP_TRAP = 162;
static const int IPPORT_IMAP3 = 220;
static const int IPPORT_LDAP = 389;
static const int IPPORT_HTTPS = 443;
static const int IPPORT_MICROSOFT_DS = 445;
static const int IPPORT_EXECSERVER = 512;
static const int IPPORT_LOGINSERVER = 513;
static const int IPPORT_CMDSERVER = 514;
static const int IPPORT_EFSSERVER = 520;
/*
 * UNIX UDP sockets
 */
# 499 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int IPPORT_BIFFUDP = 512;
static const int IPPORT_WHOSERVER = 513;
static const int IPPORT_ROUTESERVER = 520;
                                        /* 520+1 also used */
/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
# 508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int IPPORT_RESERVED = 1024;
static const int IPPORT_REGISTERED_MIN = IPPORT_RESERVED;
static const int IPPORT_REGISTERED_MAX = 0xbfff;
static const int IPPORT_DYNAMIC_MIN = 0xc000;
static const int IPPORT_DYNAMIC_MAX = 0xffff;
/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *
 * N.B. RFC-compliant definitions for host-order elements are named IN_xxx,
 * while network-order elements are named IN4_xxx.
 */
# 524 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int IN_CLASSA(i) = (((LONG)(i) & 0x80000000) == 0);
static const int IN_CLASSA_NET = 0xff000000;
static const int IN_CLASSA_NSHIFT = 24;
static const int IN_CLASSA_HOST = 0x00ffffff;
static const int IN_CLASSA_MAX = 128;
static const int IN_CLASSB(i) = (((LONG)(i) & 0xc0000000) == 0x80000000);
static const int IN_CLASSB_NET = 0xffff0000;
static const int IN_CLASSB_NSHIFT = 16;
static const int IN_CLASSB_HOST = 0x0000ffff;
static const int IN_CLASSB_MAX = 65536;
static const int IN_CLASSC(i) = (((LONG)(i) & 0xe0000000) == 0xc0000000);
static const int IN_CLASSC_NET = 0xffffff00;
static const int IN_CLASSC_NSHIFT = 8;
static const int IN_CLASSC_HOST = 0x000000ff;
static const int IN_CLASSD(i) = (((long)(i) & 0xf0000000) == 0xe0000000);
static const int IN_CLASSD_NET = 0xf0000000;
static const int IN_CLASSD_NSHIFT = 28;
static const int IN_CLASSD_HOST = 0x0fffffff;
static const int IN_MULTICAST(i) = IN_CLASSD(i);
static const int INADDR_ANY = (ULONG)0x00000000;
static const int INADDR_LOOPBACK = 0x7f000001;
static const int INADDR_BROADCAST = (ULONG)0xffffffff;
static const int INADDR_NONE = 0xffffffff;
//
// Scope ID definition
//
typedef enum {
    ScopeLevelInterface = 1,
    ScopeLevelLink = 2,
    ScopeLevelSubnet = 3,
    ScopeLevelAdmin = 4,
    ScopeLevelSite = 5,
    ScopeLevelOrganization = 8,
    ScopeLevelGlobal = 14,
    ScopeLevelCount = 16
} SCOPE_LEVEL;
typedef struct {
    union {
        struct {
            ULONG Zone : 28;
            ULONG Level : 4;
        };
        ULONG Value;
    };
} SCOPE_ID, *PSCOPE_ID;
static const int SCOPEID_UNSPECIFIED_INIT = { 0 };
//
// IPv4 Socket address, Internet style
//
typedef struct sockaddr_in {
    ADDRESS_FAMILY sin_family;
    USHORT sin_port;
    IN_ADDR sin_addr;
    CHAR sin_zero[8];
} SOCKADDR_IN, *PSOCKADDR_IN;
//
// Datalink (MAC) address
//
// If you don't use the entire sdl_data field, then fill it starting with the low
// bytes...
//
typedef struct sockaddr_dl {
    ADDRESS_FAMILY sdl_family;
    UCHAR sdl_data[8];
    UCHAR sdl_zero[4];
} SOCKADDR_DL, *PSOCKADDR_DL;
static const int IOCPARM_MASK = 0x7f;
static const int IOC_VOID = 0x20000000;
static const int IOC_OUT = 0x40000000;
static const int IOC_IN = 0x80000000;
static const int IOC_INOUT = (IOC_IN|IOC_OUT);
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
# 620 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int _IO(x,y) = (IOC_VOID|((x)<<8)|(y));
static const int _IOR(x,y,t) = (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y));
static const int _IOW(x,y,t) = (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y));
/*
 * WinSock 2 extension -- WSABUF and QOS struct, include qos.h
 * to pull in FLOWSPEC and related definitions
 */
# 631 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _WSABUF {
    ULONG len; /* the length of the buffer */
    CHAR *buf; /* the pointer to the buffer */
} WSABUF, * LPWSABUF;
/*
 * WSAMSG -- for WSASendMsg 
 */
# 640 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _WSAMSG {
    LPSOCKADDR name; /* Remote address */
    INT namelen; /* Remote address length */
    LPWSABUF lpBuffers; /* Data buffer array */
    ULONG dwBufferCount; /* Number of elements in the array */
    WSABUF Control; /* Control buffer */
    ULONG dwFlags; /* Flags */
} WSAMSG, *PWSAMSG, * LPWSAMSG;
/*
 * Layout of ancillary data objects in the control buffer (RFC 2292).
 */
# 665 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int _WSACMSGHDR = cmsghdr;
typedef struct cmsghdr {
    SIZE_T cmsg_len;
    INT cmsg_level;
    INT cmsg_type;
    /* followed by UCHAR cmsg_data[] */
} WSACMSGHDR, *PWSACMSGHDR, *LPWSACMSGHDR;
typedef WSACMSGHDR CMSGHDR, *PCMSGHDR;
/*
 * Alignment macros for header and data members of
 * the control buffer.
 */
# 683 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int WSA_CMSGHDR_ALIGN(length) = ( ((length) + TYPE_ALIGNMENT(WSACMSGHDR)-1) & (~(TYPE_ALIGNMENT(WSACMSGHDR)-1)) );
static const int WSA_CMSGDATA_ALIGN(length) = ( ((length) + MAX_NATURAL_ALIGNMENT-1) & (~(MAX_NATURAL_ALIGNMENT-1)) );
static const int CMSGHDR_ALIGN = WSA_CMSGHDR_ALIGN;
static const int CMSGDATA_ALIGN = WSA_CMSGDATA_ALIGN;
/*
 *  WSA_CMSG_FIRSTHDR
 *
 *  Returns a pointer to the first ancillary data object, 
 *  or a null pointer if there is no ancillary data in the 
 *  control buffer of the WSAMSG structure.
 *
 *  LPCMSGHDR 
 *  WSA_CMSG_FIRSTHDR (
 *      LPWSAMSG    msg
 *      );
 */
# 708 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int WSA_CMSG_FIRSTHDR(msg) = ( ((msg)->Control.len >= sizeof(WSACMSGHDR)) ? (LPWSACMSGHDR)(msg)->Control.buf : (LPWSACMSGHDR)NULL );
static const int CMSG_FIRSTHDR = WSA_CMSG_FIRSTHDR;
/* 
 *  WSA_CMSG_NXTHDR
 *
 *  Returns a pointer to the next ancillary data object,
 *  or a null if there are no more data objects.
 *
 *  LPCMSGHDR 
 *  WSA_CMSG_NEXTHDR (
 *      LPWSAMSG        msg,
 *      LPWSACMSGHDR    cmsg
 *      );
 */
# 729 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int WSA_CMSG_NXTHDR(msg,cmsg) = ( ((cmsg) == NULL) ? WSA_CMSG_FIRSTHDR(msg) : ( ( ((PUCHAR)(cmsg) + WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len) + sizeof(WSACMSGHDR) ) > (PUCHAR)((msg)->Control.buf) + (msg)->Control.len ) ? (LPWSACMSGHDR)NULL : (LPWSACMSGHDR)((PUCHAR)(cmsg) + WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len)) ) );
# 742 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int CMSG_NXTHDR = WSA_CMSG_NXTHDR;
/* 
 *  WSA_CMSG_DATA
 *
 *  Returns a pointer to the first byte of data (what is referred 
 *  to as the cmsg_data member though it is not defined in 
 *  the structure).
 *
 *  Note that RFC 2292 defines this as CMSG_DATA, but that name
 *  is already used by wincrypt.h, and so Windows has used WSA_CMSG_DATA.
 *
 *  PUCHAR
 *  WSA_CMSG_DATA (
 *      LPWSACMSGHDR   pcmsg
 *      );
 */
# 760 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int WSA_CMSG_DATA(cmsg) = ( (PUCHAR)(cmsg) + WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) );
/*
 *  WSA_CMSG_SPACE
 *
 *  Returns total size of an ancillary data object given 
 *  the amount of data. Used to allocate the correct amount 
 *  of space.
 *
 *  SIZE_T
 *  WSA_CMSG_SPACE (
 *      SIZE_T length
 *      );
 */
# 775 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int WSA_CMSG_SPACE(length) = (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR) + WSA_CMSGHDR_ALIGN(length)));
static const int CMSG_SPACE = WSA_CMSG_SPACE;
/*
 *  WSA_CMSG_LEN
 *
 *  Returns the value to store in cmsg_len given the amount of data.
 *
 *  SIZE_T
 *  WSA_CMSG_LEN (
 *      SIZE_T length
 *  );
 */
# 792 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int WSA_CMSG_LEN(length) = (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) + length);
static const int CMSG_LEN = WSA_CMSG_LEN;
/*
 * Definition for flags member of the WSAMSG structure
 * This is in addition to other MSG_xxx flags defined
 * for recv/recvfrom/send/sendto.
 */
# 804 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
static const int MSG_TRUNC = 0x0100;
static const int MSG_CTRUNC = 0x0200;
static const int MSG_BCAST = 0x0400;
static const int MSG_MCAST = 0x0800;
//
//  Flags used in "hints" argument to getaddrinfo()
//      - AI_ADDRCONFIG is supported starting with Vista
//      - default is AI_ADDRCONFIG ON whether the flag is set or not
//        because the performance penalty in not having ADDRCONFIG in
//        the multi-protocol stack environment is severe;
//        this defaulting may be disabled by specifying the AI_ALL flag,
//        in that case AI_ADDRCONFIG must be EXPLICITLY specified to
//        enable ADDRCONFIG behavior
//
static const int AI_PASSIVE = 0x00000001;
static const int AI_CANONNAME = 0x00000002;
static const int AI_NUMERICHOST = 0x00000004;
static const int AI_NUMERICSERV = 0x00000008;
static const int AI_ALL = 0x00000100;
static const int AI_ADDRCONFIG = 0x00000400;
static const int AI_V4MAPPED = 0x00000800;
static const int AI_NON_AUTHORITATIVE = 0x00004000;
static const int AI_SECURE = 0x00008000;
static const int AI_RETURN_PREFERRED_NAMES = 0x00010000;
static const int AI_FQDN = 0x00020000;
static const int AI_FILESERVER = 0x00040000;
//
//  Structure used in getaddrinfo() call
//
typedef struct addrinfo
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    char * ai_canonname; // Canonical name for nodename
    struct sockaddr * ai_addr; // Binary address
    struct addrinfo * ai_next; // Next structure in linked list
}
ADDRINFOA, *PADDRINFOA;
typedef struct addrinfoW
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    PWSTR ai_canonname; // Canonical name for nodename
    struct sockaddr * ai_addr; // Binary address
    struct addrinfoW * ai_next; // Next structure in linked list
}
ADDRINFOW, *PADDRINFOW;
typedef struct addrinfoexA
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    char *ai_canonname; // Canonical name for nodename
    struct sockaddr *ai_addr; // Binary address
    void *ai_blob;
    size_t ai_bloblen;
    LPGUID ai_provider;
    struct addrinfoexA *ai_next; // Next structure in linked list
} ADDRINFOEXA, *PADDRINFOEXA, *LPADDRINFOEXA;
typedef struct addrinfoexW
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    PWSTR ai_canonname; // Canonical name for nodename
    struct sockaddr *ai_addr; // Binary address
    void *ai_blob;
    size_t ai_bloblen;
    LPGUID ai_provider;
    struct addrinfoexW *ai_next; // Next structure in linked list
} ADDRINFOEXW, *PADDRINFOEXW, *LPADDRINFOEXW;
//
// Flags for getaddrinfo()
//
// Name Spaces
static const int NS_ALL = (0);
static const int NS_SAP = (1);
static const int NS_NDS = (2);
static const int NS_PEER_BROWSE = (3);
static const int NS_SLP = (5);
static const int NS_DHCP = (6);
static const int NS_TCPIP_LOCAL = (10);
static const int NS_TCPIP_HOSTS = (11);
static const int NS_DNS = (12);
static const int NS_NETBT = (13);
static const int NS_WINS = (14);
static const int NS_NLA = (15);
static const int NS_BTH = (16);
static const int NS_NBP = (20);
static const int NS_MS = (30);
static const int NS_STDA = (31);
static const int NS_NTDS = (32);
static const int NS_EMAIL = (37);
static const int NS_PNRPNAME = (38);
static const int NS_PNRPCLOUD = (39);
static const int NS_X500 = (40);
static const int NS_NIS = (41);
static const int NS_NISPLUS = (42);
static const int NS_WRQ = (50);
static const int NS_NETDES = (60);
//
// Flags for getnameinfo()
//
static const int NI_NOFQDN = 0x01;
static const int NI_NUMERICHOST = 0x02;
static const int NI_NAMEREQD = 0x04;
static const int NI_NUMERICSERV = 0x08;
static const int NI_DGRAM = 0x10;
static const int NI_MAXHOST = 1025;
static const int NI_MAXSERV = 32;
#pragma warning(pop)
# 113 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 2
/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
# 118 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef UINT_PTR SOCKET;
/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK2.H EXACTLY AS SHOWN HERE.
 */
# 129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int FD_SETSIZE = 64;
typedef struct fd_set {
        u_int fd_count; /* how many are SET? */
        SOCKET fd_array[64]; /* an array of SOCKETs */
} fd_set;
 extern int __WSAFDIsSet(SOCKET fd, fd_set *);
static const int FD_CLR(fd,set) = do { u_int __i; for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { if (((fd_set FAR *)(set))->fd_array[__i] == fd) { while (__i < ((fd_set FAR *)(set))->fd_count-1) { ((fd_set FAR *)(set))->fd_array[__i] = ((fd_set FAR *)(set))->fd_array[__i+1]; __i++; } ((fd_set FAR *)(set))->fd_count--; break; } } } while(0);
# 154 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int FD_SET(fd,set) = do { u_int __i; for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count; __i++) { if (((fd_set FAR *)(set))->fd_array[__i] == (fd)) { break; } } if (__i == ((fd_set FAR *)(set))->fd_count) { if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) { ((fd_set FAR *)(set))->fd_array[__i] = (fd); ((fd_set FAR *)(set))->fd_count++; } } } while(0);
# 169 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int FD_ZERO(set) = (((fd_set FAR *)(set))->fd_count=0);
static const int FD_ISSET(fd,set) = __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set));
/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
# 176 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct timeval {
        long tv_sec; /* seconds */
        long tv_usec; /* and microseconds */
};
/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
# 186 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int timerisset(tvp) = ((tvp)->tv_sec || (tvp)->tv_usec);
static const int timercmp(tvp,uvp,cmp) = ((tvp)->tv_sec cmp (uvp)->tv_sec || (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec);
static const int timerclear(tvp) = (tvp)->tv_sec = (tvp)->tv_usec = 0;
/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
# 202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int IOCPARM_MASK = 0x7f;
static const int IOC_VOID = 0x20000000;
static const int IOC_OUT = 0x40000000;
static const int IOC_IN = 0x80000000;
static const int IOC_INOUT = (IOC_IN|IOC_OUT);
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
# 209 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int _IO(x,y) = (IOC_VOID|((x)<<8)|(y));
static const int _IOR(x,y,t) = (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y));
static const int _IOW(x,y,t) = (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y));
static const int FIONREAD = _IOR('f', 127, u_long);
static const int FIONBIO = _IOW('f', 126, u_long);
static const int FIOASYNC = _IOW('f', 125, u_long);
/* Socket I/O Controls */
static const int SIOCSHIWAT = _IOW('s', 0, u_long);
static const int SIOCGHIWAT = _IOR('s', 1, u_long);
static const int SIOCSLOWAT = _IOW('s', 2, u_long);
static const int SIOCGLOWAT = _IOR('s', 3, u_long);
static const int SIOCATMARK = _IOR('s', 7, u_long);
/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */
# 232 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct hostent {
        char * h_name; /* official name of host */
        char * * h_aliases; /* alias list */
        short h_addrtype; /* host address type */
        short h_length; /* length of address */
        char * * h_addr_list; /* list of addresses */
static const int h_addr = h_addr_list[0];
};
/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
# 245 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct netent {
        char * n_name; /* official name of net */
        char * * n_aliases; /* alias list */
        short n_addrtype; /* net address type */
        u_long n_net; /* network # */
};
struct servent {
        char * s_name; /* official service name */
        char * * s_aliases; /* alias list */
        char * s_proto; /* protocol to use */
        short s_port; /* port # */
};
struct protoent {
        char * p_name; /* official protocol name */
        char * * p_aliases; /* alias list */
        short p_proto; /* protocol # */
};
/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 * IPv6 additions per RFC 2292.
 */
# 276 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * Port/socket numbers: network standard functions
 */
# 279 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int IPPORT_ECHO = 7;
static const int IPPORT_DISCARD = 9;
static const int IPPORT_SYSTAT = 11;
static const int IPPORT_DAYTIME = 13;
static const int IPPORT_NETSTAT = 15;
static const int IPPORT_FTP = 21;
static const int IPPORT_TELNET = 23;
static const int IPPORT_SMTP = 25;
static const int IPPORT_TIMESERVER = 37;
static const int IPPORT_NAMESERVER = 42;
static const int IPPORT_WHOIS = 43;
static const int IPPORT_MTP = 57;
/*
 * Port/socket numbers: host specific functions
 */
# 295 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int IPPORT_TFTP = 69;
static const int IPPORT_RJE = 77;
static const int IPPORT_FINGER = 79;
static const int IPPORT_TTYLINK = 87;
static const int IPPORT_SUPDUP = 95;
/*
 * UNIX TCP sockets
 */
# 304 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int IPPORT_EXECSERVER = 512;
static const int IPPORT_LOGINSERVER = 513;
static const int IPPORT_CMDSERVER = 514;
static const int IPPORT_EFSSERVER = 520;
/*
 * UNIX UDP sockets
 */
# 312 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int IPPORT_BIFFUDP = 512;
static const int IPPORT_WHOSERVER = 513;
static const int IPPORT_ROUTESERVER = 520;
                                        /* 520+1 also used */
/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
# 321 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int IPPORT_RESERVED = 1024;
/*
 * Link numbers
 */
# 326 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int IMPLINK_IP = 155;
static const int IMPLINK_LOWEXPER = 156;
static const int IMPLINK_HIGHEXPER = 158;
# 355 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int ADDR_ANY = INADDR_ANY;
static const int WSADESCRIPTION_LEN = 256;
static const int WSASYS_STATUS_LEN = 128;
typedef struct WSAData {
        WORD wVersion;
        WORD wHighVersion;
        unsigned short iMaxSockets;
        unsigned short iMaxUdpDg;
        char * lpVendorInfo;
        char szDescription[256 +1];
        char szSystemStatus[128 +1];
} WSADATA, * LPWSADATA;
/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */
# 383 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
# 387 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int INVALID_SOCKET = (SOCKET)(~0);
static const int SOCKET_ERROR = (-1);
/*
 * The  following  may  be used in place of the address family, socket type, or
 * protocol  in  a  call  to WSASocket to indicate that the corresponding value
 * should  be taken from the supplied WSAPROTOCOL_INFO structure instead of the
 * parameter itself.
 */
# 396 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int FROM_PROTOCOL_INFO = (-1);
/*
 * Types
 */
# 401 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SOCK_STREAM = 1;
static const int SOCK_DGRAM = 2;
static const int SOCK_RAW = 3;
static const int SOCK_RDM = 4;
static const int SOCK_SEQPACKET = 5;
/*
 * Option flags per-socket.
 */
# 410 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SO_DEBUG = 0x0001;
static const int SO_ACCEPTCONN = 0x0002;
static const int SO_REUSEADDR = 0x0004;
static const int SO_KEEPALIVE = 0x0008;
static const int SO_DONTROUTE = 0x0010;
static const int SO_BROADCAST = 0x0020;
static const int SO_USELOOPBACK = 0x0040;
static const int SO_LINGER = 0x0080;
static const int SO_OOBINLINE = 0x0100;
static const int SO_DONTLINGER = (int)(~SO_LINGER);
static const int SO_EXCLUSIVEADDRUSE = ((int)(~SO_REUSEADDR));
/*
 * Additional options.
 */
# 426 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SO_SNDBUF = 0x1001;
static const int SO_RCVBUF = 0x1002;
static const int SO_SNDLOWAT = 0x1003;
static const int SO_RCVLOWAT = 0x1004;
static const int SO_SNDTIMEO = 0x1005;
static const int SO_RCVTIMEO = 0x1006;
static const int SO_ERROR = 0x1007;
static const int SO_TYPE = 0x1008;
/*
 * WinSock 2 extension -- new options
 */
# 438 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SO_GROUP_ID = 0x2001;
static const int SO_GROUP_PRIORITY = 0x2002;
static const int SO_MAX_MSG_SIZE = 0x2003;
static const int SO_PROTOCOL_INFOA = 0x2004;
static const int SO_PROTOCOL_INFOW = 0x2005;
static const int SO_PROTOCOL_INFO = SO_PROTOCOL_INFOA;
static const int PVD_CONFIG = 0x3001;
static const int SO_CONDITIONAL_ACCEPT = 0x3002;
                                       /*  connection is not ack-ed to the */
                                       /*  other side until conditional */
                                       /*  function returns CF_ACCEPT */
/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
# 458 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct sockproto {
        u_short sp_family; /* address family */
        u_short sp_protocol; /* protocol */
};
/*
 * Protocol families, same as address families for now.
 */
# 466 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int PF_UNSPEC = AF_UNSPEC;
static const int PF_UNIX = AF_UNIX;
static const int PF_INET = AF_INET;
static const int PF_IMPLINK = AF_IMPLINK;
static const int PF_PUP = AF_PUP;
static const int PF_CHAOS = AF_CHAOS;
static const int PF_NS = AF_NS;
static const int PF_IPX = AF_IPX;
static const int PF_ISO = AF_ISO;
static const int PF_OSI = AF_OSI;
static const int PF_ECMA = AF_ECMA;
static const int PF_DATAKIT = AF_DATAKIT;
static const int PF_CCITT = AF_CCITT;
static const int PF_SNA = AF_SNA;
static const int PF_DECnet = AF_DECnet;
static const int PF_DLI = AF_DLI;
static const int PF_LAT = AF_LAT;
static const int PF_HYLINK = AF_HYLINK;
static const int PF_APPLETALK = AF_APPLETALK;
static const int PF_VOICEVIEW = AF_VOICEVIEW;
static const int PF_FIREFOX = AF_FIREFOX;
static const int PF_UNKNOWN1 = AF_UNKNOWN1;
static const int PF_BAN = AF_BAN;
static const int PF_ATM = AF_ATM;
static const int PF_INET6 = AF_INET6;
static const int PF_BTH = AF_BTH;
static const int PF_MAX = AF_MAX;
/*
 * Structure used for manipulating linger option.
 */
# 500 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct linger {
        u_short l_onoff; /* option on/off */
        u_short l_linger; /* linger time */
};
/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
# 508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SOL_SOCKET = 0xffff;
/*
 * Maximum queue length specifiable by listen.
 */
# 513 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SOMAXCONN = 0x7fffffff;
static const int MSG_OOB = 0x1;
static const int MSG_PEEK = 0x2;
static const int MSG_DONTROUTE = 0x4;
static const int MSG_WAITALL = 0x8;
static const int MSG_PARTIAL = 0x8000;
/*
 * WinSock 2 extension -- new flags for WSASend(), WSASendTo(), WSARecv() and
 *                          WSARecvFrom()
 */
# 529 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int MSG_INTERRUPT = 0x10;
static const int MSG_MAXIOVLEN = 16;
/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
# 536 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int MAXGETHOSTSTRUCT = 1024;
/*
 * WinSock 2 extension -- bit values and indices for FD_XXX network events
 */
# 541 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int FD_READ_BIT = 0;
static const int FD_READ = (1 << FD_READ_BIT);
static const int FD_WRITE_BIT = 1;
static const int FD_WRITE = (1 << FD_WRITE_BIT);
static const int FD_OOB_BIT = 2;
static const int FD_OOB = (1 << FD_OOB_BIT);
static const int FD_ACCEPT_BIT = 3;
static const int FD_ACCEPT = (1 << FD_ACCEPT_BIT);
static const int FD_CONNECT_BIT = 4;
static const int FD_CONNECT = (1 << FD_CONNECT_BIT);
static const int FD_CLOSE_BIT = 5;
static const int FD_CLOSE = (1 << FD_CLOSE_BIT);
static const int FD_QOS_BIT = 6;
static const int FD_QOS = (1 << FD_QOS_BIT);
static const int FD_GROUP_QOS_BIT = 7;
static const int FD_GROUP_QOS = (1 << FD_GROUP_QOS_BIT);
static const int FD_ROUTING_INTERFACE_CHANGE_BIT = 8;
static const int FD_ROUTING_INTERFACE_CHANGE = (1 << FD_ROUTING_INTERFACE_CHANGE_BIT);
static const int FD_ADDRESS_LIST_CHANGE_BIT = 9;
static const int FD_ADDRESS_LIST_CHANGE = (1 << FD_ADDRESS_LIST_CHANGE_BIT);
static const int FD_MAX_EVENTS = 10;
static const int FD_ALL_EVENTS = ((1 << FD_MAX_EVENTS) - 1);
/*
 * WinSock error codes are also defined in winerror.h
 * Hence the IFDEF.
 */
# 748 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * Compatibility macros.
 */
# 752 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int h_errno = WSAGetLastError();
static const int HOST_NOT_FOUND = WSAHOST_NOT_FOUND;
static const int TRY_AGAIN = WSATRY_AGAIN;
static const int NO_RECOVERY = WSANO_RECOVERY;
static const int NO_DATA = WSANO_DATA;
/* no address, look for MX record */
static const int WSANO_ADDRESS = WSANO_DATA;
static const int NO_ADDRESS = WSANO_ADDRESS;
/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
# 808 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * WinSock 2 extension -- new error codes and type definition
 */
static const int WSAAPI = FAR PASCAL;
static const int WSAEVENT = HANDLE;
static const int LPWSAEVENT = LPHANDLE;
static const int WSAOVERLAPPED = OVERLAPPED;
typedef struct _OVERLAPPED * LPWSAOVERLAPPED;
static const int WSA_IO_PENDING = (ERROR_IO_PENDING);
static const int WSA_IO_INCOMPLETE = (ERROR_IO_INCOMPLETE);
static const int WSA_INVALID_HANDLE = (ERROR_INVALID_HANDLE);
static const int WSA_INVALID_PARAMETER = (ERROR_INVALID_PARAMETER);
static const int WSA_NOT_ENOUGH_MEMORY = (ERROR_NOT_ENOUGH_MEMORY);
static const int WSA_OPERATION_ABORTED = (ERROR_OPERATION_ABORTED);
static const int WSA_INVALID_EVENT = ((WSAEVENT)NULL);
static const int WSA_MAXIMUM_WAIT_EVENTS = (MAXIMUM_WAIT_OBJECTS);
static const int WSA_WAIT_FAILED = (WAIT_FAILED);
static const int WSA_WAIT_EVENT_0 = (WAIT_OBJECT_0);
static const int WSA_WAIT_IO_COMPLETION = (WAIT_IO_COMPLETION);
static const int WSA_WAIT_TIMEOUT = (WAIT_TIMEOUT);
static const int WSA_INFINITE = (INFINITE);
# 864 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * Include qos.h to pull in FLOWSPEC and related definitions
 */
# 867 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h" 1
/*++
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    qos.h - QoS definitions for NDIS components.
Abstract:
    This module defines the Quality of Service structures and types used
    by Winsock applications.
WARNING:
    This api is deprecated and will be removed in a future release of Windows.
    Please use the QOS2.h api.
Revision History:
--*/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
/*
 *  Definitions for valued-based Service Type for each direction of data flow.
 */
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef ULONG SERVICETYPE;
static const int SERVICETYPE_NOTRAFFIC = 0x00000000;
static const int SERVICETYPE_BESTEFFORT = 0x00000001;
static const int SERVICETYPE_CONTROLLEDLOAD = 0x00000002;
static const int SERVICETYPE_GUARANTEED = 0x00000003;
static const int SERVICETYPE_NETWORK_UNAVAILABLE = 0x00000004;
static const int SERVICETYPE_GENERAL_INFORMATION = 0x00000005;
static const int SERVICETYPE_NOCHANGE = 0x00000006;
static const int SERVICETYPE_NONCONFORMING = 0x00000009;
static const int SERVICETYPE_NETWORK_CONTROL = 0x0000000A;
static const int SERVICETYPE_QUALITATIVE = 0x0000000D;
/*********  The usage of these is currently not supported.  ***************/
static const int SERVICE_BESTEFFORT = 0x80010000;
static const int SERVICE_CONTROLLEDLOAD = 0x80020000;
static const int SERVICE_GUARANTEED = 0x80040000;
static const int SERVICE_QUALITATIVE = 0x80200000;
/* **************************** ***** ************************************ */
/*
 * Flags to control the usage of RSVP on this flow.
 */
# 69 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
/*
 * to turn off traffic control, 'OR' ( | ) this flag with the 
 * ServiceType field in the FLOWSPEC
 */
# 73 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
static const int SERVICE_NO_TRAFFIC_CONTROL = 0x81000000;
/*
 * this flag can be used to prevent any rsvp signaling messages from being 
 * sent. Local traffic control will be invoked, but no RSVP Path messages 
 * will be sent.This flag can also be used in conjunction with a receiving 
 * flowspec to suppress the automatic generation of a Reserve message.  
 * The application would receive notification that a Path  message had arrived 
 * and would then need to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), 
 * to unset this flag and thereby causing Reserve messages to go out.
 */
# 86 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
static const int SERVICE_NO_QOS_SIGNALING = 0x40000000;
/*
 *  Flow Specifications for each direction of data flow.
 */
# 94 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct _flowspec
{
    ULONG TokenRate; /* In Bytes/sec */
    ULONG TokenBucketSize; /* In Bytes */
    ULONG PeakBandwidth; /* In Bytes/sec */
    ULONG Latency; /* In microseconds */
    ULONG DelayVariation; /* In microseconds */
    SERVICETYPE ServiceType;
    ULONG MaxSduSize; /* In Bytes */
    ULONG MinimumPolicedSize; /* In Bytes */
} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;
/*
 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service 
 * provider to derive the appropriate default value for the parameter.  Note 
 * that not all values in the FLOWSPEC structure can be defaults. In the
 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.  
 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be
 * defaulted. Other defaults may be possible. Refer to the appropriate
 * documentation.
 */
# 116 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
static const int QOS_NOT_SPECIFIED = 0xFFFFFFFF;
/*
 * define a value that can be used for the PeakBandwidth, which will map into 
 * positive infinity when the FLOWSPEC is converted into IntServ floating point 
 * format.  We can't use (-1) because that value was previously defined to mean
 * "select the default".
 */
# 124 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
static const int POSITIVE_INFINITY_RATE = 0xFFFFFFFE;
/*
 * the provider specific structure can have a number of objects in it.
 * Each next structure in the
 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual
 * data with a type and length for that object.  This QOS_OBJECT struct can 
 * repeat several times if there are several objects.  This list of objects
 * terminates either when the buffer length has been reached ( WSABUF ) or
 * an object of type QOS_END_OF_LIST is encountered.
 */
# 137 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct {
    ULONG ObjectType;
    ULONG ObjectLength; /* the length of object buffer INCLUDING 
                            * this header */
} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;
/*
 * general QOS objects start at this offset from the base and have a range 
 * of 1000
 */
# 150 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
static const int QOS_GENERAL_ID_BASE = 2000;
static const int QOS_OBJECT_END_OF_LIST = (0x00000001 + QOS_GENERAL_ID_BASE);
          /* QOS_End_of_list structure passed */
static const int QOS_OBJECT_SD_MODE = (0x00000002 + QOS_GENERAL_ID_BASE);
          /* QOS_ShapeDiscard structure passed */
static const int QOS_OBJECT_SHAPING_RATE = (0x00000003 + QOS_GENERAL_ID_BASE);
          /* QOS_ShapingRate structure */
static const int QOS_OBJECT_DESTADDR = (0x00000004 + QOS_GENERAL_ID_BASE);
          /* QOS_DestAddr structure (defined in qossp.h) */
/*
 * This structure is used to define the behaviour that the traffic
 * control packet shaper will apply to the flow.
 *
 * TC_NONCONF_BORROW - the flow will receive resources remaining 
 *  after all higher priority flows have been serviced. If a 
 *  TokenRate is specified, packets may be non-conforming and
 *  will be demoted to less than best-effort priority.
 *  
 * TC_NONCONF_SHAPE - TokenRate must be specified. Non-conforming
 *  packets will be retianed in the packet shaper until they become
 *  conforming.
 *
 * TC_NONCONF_DISCARD - TokenRate must be specified. Non-conforming
 *  packets will be discarded.
 *
 */
# 180 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct _QOS_SD_MODE {
    QOS_OBJECT_HDR ObjectHdr;
    ULONG ShapeDiscardMode;
} QOS_SD_MODE, *LPQOS_SD_MODE;
static const int TC_NONCONF_BORROW = 0;
static const int TC_NONCONF_SHAPE = 1;
static const int TC_NONCONF_DISCARD = 2;
static const int TC_NONCONF_BORROW_PLUS = 3;
/*
 * This structure allows an app to specify a prorated "average token rate" using by
 * the traffic shaper under SHAPE modehaper queue. It is expressed in bytes per sec.
 *
 * ShapingRate (bytes per sec.)
 *
 */
# 201 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct _QOS_SHAPING_RATE {
    QOS_OBJECT_HDR ObjectHdr;
    ULONG ShapingRate;
} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;
# 868 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 2
typedef struct _QualityOfService
{
    FLOWSPEC SendingFlowspec; /* the flow spec for data sending */
    FLOWSPEC ReceivingFlowspec; /* the flow spec for data receiving */
    WSABUF ProviderSpecific; /* additional provider specific stuff */
} QOS, * LPQOS;
/*
 * WinSock 2 extension -- manifest constants for return values of the condition function
 */
# 879 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int CF_ACCEPT = 0x0000;
static const int CF_REJECT = 0x0001;
static const int CF_DEFER = 0x0002;
/*
 * WinSock 2 extension -- manifest constants for shutdown()
 */
# 886 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SD_RECEIVE = 0x00;
static const int SD_SEND = 0x01;
static const int SD_BOTH = 0x02;
/*
 * WinSock 2 extension -- data type and manifest constants for socket groups
 */
# 893 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef unsigned int GROUP;
static const int SG_UNCONSTRAINED_GROUP = 0x01;
static const int SG_CONSTRAINED_GROUP = 0x02;
/*
 * WinSock 2 extension -- data type for WSAEnumNetworkEvents()
 */
# 901 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef struct _WSANETWORKEVENTS {
       long lNetworkEvents;
       int iErrorCode[10];
} WSANETWORKEVENTS, * LPWSANETWORKEVENTS;
/*
 * WinSock 2 extension -- WSAPROTOCOL_INFO structure and associated
 * manifest constants
 */
static const int MAX_PROTOCOL_CHAIN = 7;
static const int BASE_PROTOCOL = 1;
static const int LAYERED_PROTOCOL = 0;
typedef struct _WSAPROTOCOLCHAIN {
    int ChainLen; /* the length of the chain,     */
                                                  /* length = 0 means layered protocol, */
                                                  /* length = 1 means base protocol, */
                                                  /* length > 1 means protocol chain */
    DWORD ChainEntries[7]; /* a list of dwCatalogEntryIds */
} WSAPROTOCOLCHAIN, * LPWSAPROTOCOLCHAIN;
static const int WSAPROTOCOL_LEN = 255;
typedef struct _WSAPROTOCOL_INFOA {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    CHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOA, * LPWSAPROTOCOL_INFOA;
typedef struct _WSAPROTOCOL_INFOW {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    WCHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOW, * LPWSAPROTOCOL_INFOW;
typedef WSAPROTOCOL_INFOA WSAPROTOCOL_INFO;
typedef LPWSAPROTOCOL_INFOA LPWSAPROTOCOL_INFO;
/* Flag bit definitions for dwProviderFlags */
static const int PFL_MULTIPLE_PROTO_ENTRIES = 0x00000001;
static const int PFL_RECOMMENDED_PROTO_ENTRY = 0x00000002;
static const int PFL_HIDDEN = 0x00000004;
static const int PFL_MATCHES_PROTOCOL_ZERO = 0x00000008;
static const int PFL_NETWORKDIRECT_PROVIDER = 0x00000010;
/* Flag bit definitions for dwServiceFlags1 */
static const int XP1_CONNECTIONLESS = 0x00000001;
static const int XP1_GUARANTEED_DELIVERY = 0x00000002;
static const int XP1_GUARANTEED_ORDER = 0x00000004;
static const int XP1_MESSAGE_ORIENTED = 0x00000008;
static const int XP1_PSEUDO_STREAM = 0x00000010;
static const int XP1_GRACEFUL_CLOSE = 0x00000020;
static const int XP1_EXPEDITED_DATA = 0x00000040;
static const int XP1_CONNECT_DATA = 0x00000080;
static const int XP1_DISCONNECT_DATA = 0x00000100;
static const int XP1_SUPPORT_BROADCAST = 0x00000200;
static const int XP1_SUPPORT_MULTIPOINT = 0x00000400;
static const int XP1_MULTIPOINT_CONTROL_PLANE = 0x00000800;
static const int XP1_MULTIPOINT_DATA_PLANE = 0x00001000;
static const int XP1_QOS_SUPPORTED = 0x00002000;
static const int XP1_INTERRUPT = 0x00004000;
static const int XP1_UNI_SEND = 0x00008000;
static const int XP1_UNI_RECV = 0x00010000;
static const int XP1_IFS_HANDLES = 0x00020000;
static const int XP1_PARTIAL_MESSAGE = 0x00040000;
static const int XP1_SAN_SUPPORT_SDP = 0x00080000;
static const int BIGENDIAN = 0x0000;
static const int LITTLEENDIAN = 0x0001;
static const int SECURITY_PROTOCOL_NONE = 0x0000;
/*
 * WinSock 2 extension -- manifest constants for WSAJoinLeaf()
 */
# 1019 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int JL_SENDER_ONLY = 0x01;
static const int JL_RECEIVER_ONLY = 0x02;
static const int JL_BOTH = 0x04;
/*
 * WinSock 2 extension -- manifest constants for WSASocket()
 */
# 1026 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int WSA_FLAG_OVERLAPPED = 0x01;
static const int WSA_FLAG_MULTIPOINT_C_ROOT = 0x02;
static const int WSA_FLAG_MULTIPOINT_C_LEAF = 0x04;
static const int WSA_FLAG_MULTIPOINT_D_ROOT = 0x08;
static const int WSA_FLAG_MULTIPOINT_D_LEAF = 0x10;
static const int WSA_FLAG_ACCESS_SYSTEM_SECURITY = 0x40;
/*
 * WinSock 2 extensions -- data types for the condition function in
 * WSAAccept() and overlapped I/O completion routine.
 */
# 1038 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef
int
( * LPCONDITIONPROC)(
    LPWSABUF lpCallerId,
    LPWSABUF lpCallerData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    LPWSABUF lpCalleeId,
    LPWSABUF lpCalleeData,
    GROUP * g,
    DWORD_PTR dwCallbackData
    );
typedef
void
( * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );
/*
 * WinSock 2 extension -- manifest constants and associated structures
 * for WSANSPIoctl()
 */
# 1066 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SIO_NSP_NOTIFY_CHANGE = _WSAIOW(IOC_WS2,25);
typedef enum _WSACOMPLETIONTYPE {
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC,
} WSACOMPLETIONTYPE, *PWSACOMPLETIONTYPE, * LPWSACOMPLETIONTYPE;
typedef struct _WSACOMPLETION {
    WSACOMPLETIONTYPE Type;
    union {
        struct {
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION, *LPWSACOMPLETION;
/*
 * WinSock 2 extension -- manifest constants for SIO_TRANSLATE_HANDLE ioctl
 */
# 1103 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int TH_NETDEV = 0x00000001;
static const int TH_TAPI = 0x00000002;
/*
 * Manifest constants and type definitions related to name resolution and
 * registration (RNR) API
 */
# 1112 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef struct _BLOB {
    ULONG cbSize ;
    BYTE *pBlobData ;
} BLOB, *LPBLOB ;
/*
 * Service Install Flags
 */
# 1129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SERVICE_MULTIPLE = (0x00000001);
/*
 *& Name Spaces
 */
# 1135 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int NS_ALL = (0);
static const int NS_SAP = (1);
static const int NS_NDS = (2);
static const int NS_PEER_BROWSE = (3);
static const int NS_SLP = (5);
static const int NS_DHCP = (6);
static const int NS_TCPIP_LOCAL = (10);
static const int NS_TCPIP_HOSTS = (11);
static const int NS_DNS = (12);
static const int NS_NETBT = (13);
static const int NS_WINS = (14);
static const int NS_NLA = (15);
static const int NS_BTH = (16);
static const int NS_NBP = (20);
static const int NS_MS = (30);
static const int NS_STDA = (31);
static const int NS_NTDS = (32);
static const int NS_EMAIL = (37);
static const int NS_PNRPNAME = (38);
static const int NS_PNRPCLOUD = (39);
static const int NS_X500 = (40);
static const int NS_NIS = (41);
static const int NS_NISPLUS = (42);
static const int NS_WRQ = (50);
static const int NS_NETDES = (60);
/*
 *& Name Spaces
 */
# 1181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int NS_ALL = (0);
static const int NS_SAP = (1);
static const int NS_NDS = (2);
static const int NS_PEER_BROWSE = (3);
static const int NS_SLP = (5);
static const int NS_DHCP = (6);
static const int NS_TCPIP_LOCAL = (10);
static const int NS_TCPIP_HOSTS = (11);
static const int NS_DNS = (12);
static const int NS_NETBT = (13);
static const int NS_WINS = (14);
static const int NS_NLA = (15);
static const int NS_BTH = (16);
static const int NS_LOCALNAME = (19);
static const int NS_NBP = (20);
static const int NS_MS = (30);
static const int NS_STDA = (31);
static const int NS_NTDS = (32);
static const int NS_EMAIL = (37);
static const int NS_PNRPNAME = (38);
static const int NS_PNRPCLOUD = (39);
static const int NS_X500 = (40);
static const int NS_NIS = (41);
static const int NS_NISPLUS = (42);
static const int NS_WRQ = (50);
static const int NS_NETDES = (60);
/*
 * Resolution flags for WSAGetAddressByName().
 * Note these are also used by the 1.1 API GetAddressByName, so
 * leave them around.
 */
# 1230 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int RES_UNUSED_1 = (0x00000001);
static const int RES_FLUSH_CACHE = (0x00000002);
static const int RES_SERVICE = (0x00000004);
/*
 * Well known value names for Service Types
 */
# 1240 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const char SERVICE_TYPE_VALUE_IPXPORTA = "IpxSocket";
static const char SERVICE_TYPE_VALUE_IPXPORTW = L"IpxSocket";
static const char SERVICE_TYPE_VALUE_SAPIDA = "SapId";
static const char SERVICE_TYPE_VALUE_SAPIDW = L"SapId";
static const char SERVICE_TYPE_VALUE_TCPPORTA = "TcpPort";
static const char SERVICE_TYPE_VALUE_TCPPORTW = L"TcpPort";
static const char SERVICE_TYPE_VALUE_UDPPORTA = "UdpPort";
static const char SERVICE_TYPE_VALUE_UDPPORTW = L"UdpPort";
static const char SERVICE_TYPE_VALUE_OBJECTIDA = "ObjectId";
static const char SERVICE_TYPE_VALUE_OBJECTIDW = L"ObjectId";
# 1263 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int SERVICE_TYPE_VALUE_SAPID = SERVICE_TYPE_VALUE_SAPIDA;
static const int SERVICE_TYPE_VALUE_TCPPORT = SERVICE_TYPE_VALUE_TCPPORTA;
static const int SERVICE_TYPE_VALUE_UDPPORT = SERVICE_TYPE_VALUE_UDPPORTA;
static const int SERVICE_TYPE_VALUE_OBJECTID = SERVICE_TYPE_VALUE_OBJECTIDA;
/*
 *  Address Family/Protocol Tuples
 */
# 1273 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef struct _AFPROTOCOLS {
    INT iAddressFamily;
    INT iProtocol;
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS;
/*
 * Client Query API Typedefs
 */
# 1282 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*
 * The comparators
 */
# 1285 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef enum _WSAEcomparator
{
    COMP_EQUAL = 0,
    COMP_NOTLESS
} WSAECOMPARATOR, *PWSAECOMPARATOR, *LPWSAECOMPARATOR;
typedef struct _WSAVersion
{
    DWORD dwVersion;
    WSAECOMPARATOR ecHow;
}WSAVERSION, *PWSAVERSION, *LPWSAVERSION;
typedef struct _WSAQuerySetA
{
    DWORD dwSize;
    LPSTR lpszServiceInstanceName;
    LPGUID lpServiceClassId;
    LPWSAVERSION lpVersion;
    LPSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSETA, *PWSAQUERYSETA, *LPWSAQUERYSETA;
typedef struct _WSAQuerySetW
{
    DWORD dwSize;
    LPWSTR lpszServiceInstanceName;
    LPGUID lpServiceClassId;
    LPWSAVERSION lpVersion;
    LPWSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPWSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPWSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW;
typedef struct _WSAQuerySet2A
{
    DWORD dwSize;
    LPSTR lpszServiceInstanceName;
    LPWSAVERSION lpVersion;
    LPSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSET2A, *PWSAQUERYSET2A, *LPWSAQUERYSET2A;
typedef struct _WSAQuerySet2W
{
    DWORD dwSize;
    LPWSTR lpszServiceInstanceName;
    LPWSAVERSION lpVersion;
    LPWSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPWSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPWSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSET2W, *PWSAQUERYSET2W, *LPWSAQUERYSET2W;
# 1377 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef WSAQUERYSETA WSAQUERYSET;
typedef PWSAQUERYSETA PWSAQUERYSET;
typedef LPWSAQUERYSETA LPWSAQUERYSET;
typedef WSAQUERYSET2A WSAQUERYSET2;
typedef PWSAQUERYSET2A PWSAQUERYSET2;
typedef LPWSAQUERYSET2A LPWSAQUERYSET2;
static const int LUP_DEEP = 0x0001;
static const int LUP_CONTAINERS = 0x0002;
static const int LUP_NOCONTAINERS = 0x0004;
static const int LUP_NEAREST = 0x0008;
static const int LUP_RETURN_NAME = 0x0010;
static const int LUP_RETURN_TYPE = 0x0020;
static const int LUP_RETURN_VERSION = 0x0040;
static const int LUP_RETURN_COMMENT = 0x0080;
static const int LUP_RETURN_ADDR = 0x0100;
static const int LUP_RETURN_BLOB = 0x0200;
static const int LUP_RETURN_ALIASES = 0x0400;
static const int LUP_RETURN_QUERY_STRING = 0x0800;
static const int LUP_RETURN_ALL = 0x0FF0;
static const int LUP_RES_SERVICE = 0x8000;
static const int LUP_FLUSHCACHE = 0x1000;
static const int LUP_FLUSHPREVIOUS = 0x2000;
static const int LUP_NON_AUTHORITATIVE = 0x4000;
static const int LUP_SECURE = 0x8000;
static const int LUP_RETURN_PREFERRED_NAMES = 0x10000;
static const int LUP_ADDRCONFIG = 0x00100000;
static const int LUP_DUAL_ADDR = 0x00200000;
static const int LUP_FILESERVER = 0x00400000;
/*
 * Return flags
 */
# 1416 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int RESULT_IS_ALIAS = 0x0001;
static const int RESULT_IS_ADDED = 0x0010;
static const int RESULT_IS_CHANGED = 0x0020;
static const int RESULT_IS_DELETED = 0x0040;
/*
 * Service Address Registration and Deregistration Data Types.
 */
# 1427 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef enum _WSAESETSERVICEOP
{
    RNRSERVICE_REGISTER=0,
    RNRSERVICE_DEREGISTER,
    RNRSERVICE_DELETE
} WSAESETSERVICEOP, *PWSAESETSERVICEOP, *LPWSAESETSERVICEOP;
/*
 * Service Installation/Removal Data Types.
 */
# 1438 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef struct _WSANSClassInfoA
{
    LPSTR lpszName;
    DWORD dwNameSpace;
    DWORD dwValueType;
    DWORD dwValueSize;
    LPVOID lpValue;
}WSANSCLASSINFOA, *PWSANSCLASSINFOA, *LPWSANSCLASSINFOA;
typedef struct _WSANSClassInfoW
{
    LPWSTR lpszName;
    DWORD dwNameSpace;
    DWORD dwValueType;
    DWORD dwValueSize;
    LPVOID lpValue;
}WSANSCLASSINFOW, *PWSANSCLASSINFOW, *LPWSANSCLASSINFOW;
typedef WSANSCLASSINFOA WSANSCLASSINFO;
typedef PWSANSCLASSINFOA PWSANSCLASSINFO;
typedef LPWSANSCLASSINFOA LPWSANSCLASSINFO;
typedef struct _WSAServiceClassInfoA
{
    LPGUID lpServiceClassId;
    LPSTR lpszServiceClassName;
    DWORD dwCount;
    LPWSANSCLASSINFOA lpClassInfos;
}WSASERVICECLASSINFOA, *PWSASERVICECLASSINFOA, *LPWSASERVICECLASSINFOA;
typedef struct _WSAServiceClassInfoW
{
    LPGUID lpServiceClassId;
    LPWSTR lpszServiceClassName;
    DWORD dwCount;
    LPWSANSCLASSINFOW lpClassInfos;
}WSASERVICECLASSINFOW, *PWSASERVICECLASSINFOW, *LPWSASERVICECLASSINFOW;
typedef WSASERVICECLASSINFOA WSASERVICECLASSINFO;
typedef PWSASERVICECLASSINFOA PWSASERVICECLASSINFO;
typedef LPWSASERVICECLASSINFOA LPWSASERVICECLASSINFO;
typedef struct _WSANAMESPACE_INFOA {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPSTR lpszIdentifier;
} WSANAMESPACE_INFOA, *PWSANAMESPACE_INFOA, *LPWSANAMESPACE_INFOA;
typedef struct _WSANAMESPACE_INFOW {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPWSTR lpszIdentifier;
} WSANAMESPACE_INFOW, *PWSANAMESPACE_INFOW, *LPWSANAMESPACE_INFOW;
typedef struct _WSANAMESPACE_INFOEXA {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPSTR lpszIdentifier;
    BLOB ProviderSpecific;
} WSANAMESPACE_INFOEXA, *PWSANAMESPACE_INFOEXA, *LPWSANAMESPACE_INFOEXA;
typedef struct _WSANAMESPACE_INFOEXW {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPWSTR lpszIdentifier;
    BLOB ProviderSpecific;
} WSANAMESPACE_INFOEXW, *PWSANAMESPACE_INFOEXW, *LPWSANAMESPACE_INFOEXW;
# 1530 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef WSANAMESPACE_INFOA WSANAMESPACE_INFO;
typedef PWSANAMESPACE_INFOA PWSANAMESPACE_INFO;
typedef LPWSANAMESPACE_INFOA LPWSANAMESPACE_INFO;
typedef WSANAMESPACE_INFOEXA WSANAMESPACE_INFOEX;
typedef PWSANAMESPACE_INFOEXA PWSANAMESPACE_INFOEX;
typedef LPWSANAMESPACE_INFOEXA LPWSANAMESPACE_INFOEX;
/* Event flag definitions for WSAPoll(). */
static const int POLLRDNORM = 0x0100;
static const int POLLRDBAND = 0x0200;
static const int POLLIN = (POLLRDNORM | POLLRDBAND);
static const int POLLPRI = 0x0400;
static const int POLLWRNORM = 0x0010;
static const int POLLOUT = (POLLWRNORM);
static const int POLLWRBAND = 0x0020;
static const int POLLERR = 0x0001;
static const int POLLHUP = 0x0002;
static const int POLLNVAL = 0x0004;
typedef struct pollfd {
    SOCKET fd;
    SHORT events;
    SHORT revents;
} WSAPOLLFD, *PWSAPOLLFD, *LPWSAPOLLFD;
/* Socket function prototypes */
SOCKET
accept(
    SOCKET s,
    struct sockaddr * addr,
    int * addrlen
    );
# 1593 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
bind(
    SOCKET s,
    const struct sockaddr * name,
    int namelen
    );
# 1614 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
closesocket(
    SOCKET s
    );
# 1631 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
connect(
    SOCKET s,
    const struct sockaddr * name,
    int namelen
    );
# 1652 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
ioctlsocket(
    SOCKET s,
    long cmd,
    u_long * argp
    );
# 1673 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
getpeername(
    SOCKET s,
    struct sockaddr * name,
    int * namelen
    );
# 1694 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
getsockname(
    SOCKET s,
    struct sockaddr * name,
    int * namelen
    );
# 1715 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
getsockopt(
    SOCKET s,
    int level,
    int optname,
    char * optval,
    int * optlen
    );
# 1740 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
u_long
htonl(
    u_long hostlong
    );
# 1757 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
u_short
htons(
    u_short hostshort
    );
# 1774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
unsigned long
inet_addr(
    const char * cp
    );
# 1792 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
char *
inet_ntoa(
    struct in_addr in
    );
# 1809 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
listen(
    SOCKET s,
    int backlog
    );
# 1828 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
u_long
ntohl(
    u_long netlong
    );
# 1845 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
u_short
ntohs(
    u_short netshort
    );
# 1862 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
recv(
    SOCKET s,
    char * buf,
    int len,
    int flags
    );
# 1885 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
recvfrom(
    SOCKET s,
    char * buf,
    int len,
    int flags,
    struct sockaddr * from,
    int * fromlen
    );
# 1912 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
select(
    int nfds,
    fd_set * readfds,
    fd_set * writefds,
    fd_set * exceptfds,
    const struct timeval * timeout
    );
# 1937 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
send(
    SOCKET s,
    const char * buf,
    int len,
    int flags
    );
# 1960 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
sendto(
    SOCKET s,
    const char * buf,
    int len,
    int flags,
    const struct sockaddr * to,
    int tolen
    );
# 1987 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
setsockopt(
    SOCKET s,
    int level,
    int optname,
    const char * optval,
    int optlen
    );
# 2012 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
shutdown(
    SOCKET s,
    int how
    );
# 2031 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
SOCKET
socket(
    int af,
    int type,
    int protocol
    );
# 2053 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* Database function prototypes */
struct hostent *
gethostbyaddr(
    const char * addr,
    int len,
    int type
    );
# 2077 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct hostent *
gethostbyname(
    const char * name
    );
# 2095 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
gethostname(
    char * name,
    int namelen
    );
# 2114 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct servent *
getservbyport(
    int port,
    const char * proto
    );
# 2134 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct servent *
getservbyname(
    const char * name,
    const char * proto
    );
# 2154 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct protoent *
getprotobynumber(
    int number
    );
# 2172 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct protoent *
getprotobyname(
    const char * name
    );
# 2189 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* Microsoft Windows Extension function prototypes */
int
WSAStartup(
    WORD wVersionRequested,
    LPWSADATA lpWSAData
    );
# 2214 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSACleanup(
    void
    );
# 2231 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
void
WSASetLastError(
    int iError
    );
# 2248 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAGetLastError(
    void
    );
# 2265 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
BOOL
WSAIsBlocking(
    void
    );
# 2282 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAUnhookBlockingHook(
    void
    );
# 2299 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
FARPROC
WSASetBlockingHook(
    FARPROC lpBlockFunc
    );
# 2316 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSACancelBlockingCall(
    void
    );
# 2333 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
HANDLE
WSAAsyncGetServByName(
    HWND hWnd,
    u_int wMsg,
    const char * name,
    const char * proto,
    char * buf,
    int buflen
    );
# 2360 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
HANDLE
WSAAsyncGetServByPort(
    HWND hWnd,
    u_int wMsg,
    int port,
    const char * proto,
    char * buf,
    int buflen
    );
# 2387 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
HANDLE
WSAAsyncGetProtoByName(
    HWND hWnd,
    u_int wMsg,
    const char * name,
    char * buf,
    int buflen
    );
# 2412 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
HANDLE
WSAAsyncGetProtoByNumber(
    HWND hWnd,
    u_int wMsg,
    int number,
    char * buf,
    int buflen
    );
# 2437 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
HANDLE
WSAAsyncGetHostByName(
    HWND hWnd,
    u_int wMsg,
    const char * name,
    char * buf,
    int buflen
    );
# 2462 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
HANDLE
WSAAsyncGetHostByAddr(
    HWND hWnd,
    u_int wMsg,
    const char * addr,
    int len,
    int type,
    char * buf,
    int buflen
    );
# 2491 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSACancelAsyncRequest(
    HANDLE hAsyncTaskHandle
    );
# 2508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAAsyncSelect(
    SOCKET s,
    HWND hWnd,
    u_int wMsg,
    long lEvent
    );
# 2531 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* WinSock 2 API new function prototypes */
SOCKET
WSAAccept(
    SOCKET s,
    struct sockaddr * addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD_PTR dwCallbackData
    );
# 2561 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
BOOL
WSACloseEvent(
    HANDLE hEvent
    );
# 2578 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAConnect(
    SOCKET s,
    const struct sockaddr * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS
    );
static const int WSAConnectByName = WSAConnectByNameA;
BOOL
WSAConnectByNameW(
    SOCKET s,
    LPWSTR nodename,
    LPWSTR servicename,
    LPDWORD LocalAddressLength,
    LPSOCKADDR LocalAddress,
    LPDWORD RemoteAddressLength,
    LPSOCKADDR RemoteAddress,
    const struct timeval * timeout,
    LPWSAOVERLAPPED Reserved);
BOOL
WSAConnectByNameA(
    SOCKET s,
    LPCSTR nodename,
    LPCSTR servicename,
    LPDWORD LocalAddressLength,
    LPSOCKADDR LocalAddress,
    LPDWORD RemoteAddressLength,
    LPSOCKADDR RemoteAddress,
    const struct timeval * timeout,
    LPWSAOVERLAPPED Reserved);
BOOL
WSAConnectByList(
    SOCKET s,
    PSOCKET_ADDRESS_LIST SocketAddress,
    LPDWORD LocalAddressLength,
    LPSOCKADDR LocalAddress,
    LPDWORD RemoteAddressLength,
    LPSOCKADDR RemoteAddress,
    const struct timeval * timeout,
    LPWSAOVERLAPPED Reserved);
# 2660 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
HANDLE
WSACreateEvent(
    void
    );
# 2677 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSADuplicateSocketA(
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOA lpProtocolInfo
    );
int
WSADuplicateSocketW(
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo
    );
static const int WSADuplicateSocket = WSADuplicateSocketA;
# 2725 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAEnumNetworkEvents(
    SOCKET s,
    HANDLE hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents
    );
# 2747 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAEnumProtocolsA(
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    LPDWORD lpdwBufferLength
    );
int
WSAEnumProtocolsW(
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength
    );
static const int WSAEnumProtocols = WSAEnumProtocolsA;
# 2793 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAEventSelect(
    SOCKET s,
    HANDLE hEventObject,
    long lNetworkEvents
    );
# 2814 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
BOOL
WSAGetOverlappedResult(
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags
    );
# 2840 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
BOOL
WSAGetQOSByName(
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS
    );
# 2862 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAHtonl(
    SOCKET s,
    u_long hostlong,
    u_long * lpnetlong
    );
# 2884 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAHtons(
    SOCKET s,
    u_short hostshort,
    u_short * lpnetshort
    );
# 2906 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAIoctl(
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 2939 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
SOCKET
WSAJoinLeaf(
    SOCKET s,
    const struct sockaddr * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags
    );
# 2970 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSANtohl(
    SOCKET s,
    u_long netlong,
    u_long * lphostlong
    );
# 2992 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSANtohs(
    SOCKET s,
    u_short netshort,
    u_short * lphostshort
    );
# 3014 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSARecv(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3043 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSARecvDisconnect(
    SOCKET s,
    LPWSABUF lpInboundDisconnectData
    );
# 3062 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSARecvFrom(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3095 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
BOOL
WSAResetEvent(
    HANDLE hEvent
    );
# 3112 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSASend(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3142 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSASendMsg(
    SOCKET Handle,
    LPWSAMSG lpMsg,
    DWORD dwFlags,
    LPDWORD lpNumberOfBytesSent,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
int
WSASendDisconnect(
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData
    );
# 3177 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSASendTo(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3210 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
BOOL
WSASetEvent(
    HANDLE hEvent
    );
# 3227 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
SOCKET
WSASocketA(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    GROUP g,
    DWORD dwFlags
    );
SOCKET
WSASocketW(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags
    );
static const int WSASocket = WSASocketA;
# 3293 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
DWORD
WSAWaitForMultipleEvents(
    DWORD cEvents,
    const HANDLE * lphEvents,
    BOOL fWaitAll,
    DWORD dwTimeout,
    BOOL fAlertable
    );
# 3318 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSAAddressToStringA(
    LPSOCKADDR lpsaAddress,
    DWORD dwAddressLength,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    LPSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength
    );
INT
WSAAddressToStringW(
    LPSOCKADDR lpsaAddress,
    DWORD dwAddressLength,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPWSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength
    );
static const int WSAAddressToString = WSAAddressToStringA;
# 3372 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSAStringToAddressA(
    LPSTR AddressString,
    INT AddressFamily,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    LPSOCKADDR lpAddress,
    LPINT lpAddressLength
    );
INT
WSAStringToAddressW(
    LPWSTR AddressString,
    INT AddressFamily,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPSOCKADDR lpAddress,
    LPINT lpAddressLength
    );
static const int WSAStringToAddress = WSAStringToAddressA;
# 3425 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* Registration and Name Resolution API functions */
INT
WSALookupServiceBeginA(
    LPWSAQUERYSETA lpqsRestrictions,
    DWORD dwControlFlags,
    LPHANDLE lphLookup
    );
INT
WSALookupServiceBeginW(
    LPWSAQUERYSETW lpqsRestrictions,
    DWORD dwControlFlags,
    LPHANDLE lphLookup
    );
static const int WSALookupServiceBegin = WSALookupServiceBeginA;
# 3477 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSALookupServiceNextA(
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSETA lpqsResults
    );
INT
WSALookupServiceNextW(
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSETW lpqsResults
    );
static const int WSALookupServiceNext = WSALookupServiceNextA;
# 3528 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSANSPIoctl(
    HANDLE hLookup,
    DWORD dwControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSACOMPLETION lpCompletion
    );
# 3561 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSALookupServiceEnd(
    HANDLE hLookup
    );
# 3578 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSAInstallServiceClassA(
    LPWSASERVICECLASSINFOA lpServiceClassInfo
    );
INT
WSAInstallServiceClassW(
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );
static const int WSAInstallServiceClass = WSAInstallServiceClassA;
# 3618 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSARemoveServiceClass(
    LPGUID lpServiceClassId
    );
# 3636 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSAGetServiceClassInfoA(
    LPGUID lpProviderId,
    LPGUID lpServiceClassId,
    LPDWORD lpdwBufSize,
    LPWSASERVICECLASSINFOA lpServiceClassInfo
    );
INT
WSAGetServiceClassInfoW(
    LPGUID lpProviderId,
    LPGUID lpServiceClassId,
    LPDWORD lpdwBufSize,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );
static const int WSAGetServiceClassInfo = WSAGetServiceClassInfoA;
# 3686 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSAEnumNameSpaceProvidersA(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOA lpnspBuffer
    );
INT
WSAEnumNameSpaceProvidersW(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOW lpnspBuffer
    );
static const int WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersA;
INT
WSAEnumNameSpaceProvidersExA(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOEXA lpnspBuffer
    );
INT
WSAEnumNameSpaceProvidersExW(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOEXW lpnspBuffer
    );
static const int WSAEnumNameSpaceProvidersEx = WSAEnumNameSpaceProvidersExA;
# 3777 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
 INT
WSAGetServiceClassNameByClassIdA(
    LPGUID lpServiceClassId,
    LPSTR lpszServiceClassName,
    LPDWORD lpdwBufferLength
    );
 INT
WSAGetServiceClassNameByClassIdW(
    LPGUID lpServiceClassId,
    LPWSTR lpszServiceClassName,
    LPDWORD lpdwBufferLength
    );
static const int WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdA;
# 3823 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSASetServiceA(
    LPWSAQUERYSETA lpqsRegInfo,
    WSAESETSERVICEOP essoperation,
    DWORD dwControlFlags
    );
INT
WSASetServiceW(
    LPWSAQUERYSETW lpqsRegInfo,
    WSAESETSERVICEOP essoperation,
    DWORD dwControlFlags
    );
static const int WSASetService = WSASetServiceA;
# 3871 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
INT
WSAProviderConfigChange(
    LPHANDLE lpNotificationHandle,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3894 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
int
WSAPoll(
    LPWSAPOLLFD fdArray,
    ULONG fds,
    INT timeout
    );
/* Microsoft Windows Extended data types */
typedef struct sockaddr_in *LPSOCKADDR_IN;
typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger *LPLINGER;
typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set *LPFD_SET;
typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent *LPHOSTENT;
typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent *LPSERVENT;
typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent *LPPROTOENT;
typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval *LPTIMEVAL;
/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
# 3942 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int WSAMAKEASYNCREPLY(buflen,error) = MAKELONG(buflen,error);
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
# 3947 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int WSAMAKESELECTREPLY(event,error) = MAKELONG(event,error);
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAAsyncGetXByY().
 */
# 3953 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int WSAGETASYNCBUFLEN(lParam) = LOWORD(lParam);
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
# 3959 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int WSAGETASYNCERROR(lParam) = HIWORD(lParam);
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
# 3965 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int WSAGETSELECTEVENT(lParam) = LOWORD(lParam);
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
# 3971 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
static const int WSAGETSELECTERROR(lParam) = HIWORD(lParam);
# 31 "c_include/windows/original/ws2tcpip.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h" 1
/*++
Copyright (c) Microsoft Corporation. All rights reserved.
Module Name:
    ws2ipdef.h
Abstract:
    This file contains TCP/IP specific information for use
    by WinSock2 compatible applications.
   Copyright (c) Microsoft Corporation. All rights reserved.
    To provide the backward compatibility, all the TCP/IP
    specific definitions that were included in the WINSOCK.H
    file are now included in WINSOCK2.H file. WS2TCPIP.H
    file includes only the definitions  introduced in the
    "WinSock 2 Protocol-Specific Annex" document.
    Rev 0.3 Nov 13, 1995
        Rev 0.4 Dec 15, 1996
Environment:
    user mode or kernel mode
--*/
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h"
# 42 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h"
#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4127)
static const int WS2IPDEF_ASSERT(exp) = ((VOID) 0);
static const int WS2TCPIP_INLINE = extern inline;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/in6addr.h" 1
/*++
Copyright (c) Microsoft Corporation
Module Name:
    in6addr.h
Environment:
    user mode or kernel mode
--*/
# 16 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/in6addr.h"
//
// IPv6 Internet address (RFC 2553)
// This is an 'on-wire' format structure.
//
typedef struct in6_addr {
    union {
        UCHAR Byte[16];
        USHORT Word[8];
    } u;
} IN6_ADDR, *PIN6_ADDR, *LPIN6_ADDR;
static const int in_addr6 = in6_addr;
//
// Defines to match RFC 2553.
//
static const int _S6_un = u;
static const int _S6_u8 = Byte;
static const int s6_addr = _S6_un._S6_u8;
//
// Defines for our implementation.
//
static const int s6_bytes = u.Byte;
static const int s6_words = u.Word;
# 62 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h" 2
//
// Old IPv6 socket address structure (retained for sockaddr_gen definition).
//
struct sockaddr_in6_old {
    SHORT sin6_family; // AF_INET6.
    USHORT sin6_port; // Transport level port number.
    ULONG sin6_flowinfo; // IPv6 flow information.
    IN6_ADDR sin6_addr; // IPv6 address.
};
typedef union sockaddr_gen {
    struct sockaddr Address;
    struct sockaddr_in AddressIn;
    struct sockaddr_in6_old AddressIn6;
} sockaddr_gen;
//
// Structure to keep interface specific information
//
typedef struct _INTERFACE_INFO {
    ULONG iiFlags; // Interface flags.
    sockaddr_gen iiAddress; // Interface address.
    sockaddr_gen iiBroadcastAddress; // Broadcast address.
    sockaddr_gen iiNetmask; // Network mask.
} INTERFACE_INFO, *LPINTERFACE_INFO;
//
// New structure that does not have dependency on the address size.
//
typedef struct _INTERFACE_INFO_EX {
    ULONG iiFlags; // Interface flags.
    SOCKET_ADDRESS iiAddress; // Interface address.
    SOCKET_ADDRESS iiBroadcastAddress; // Broadcast address.
    SOCKET_ADDRESS iiNetmask; // Network mask.
} INTERFACE_INFO_EX, *LPINTERFACE_INFO_EX;
//
// Possible flags for the  iiFlags - bitmask.
//
static const int IFF_UP = 0x00000001;
static const int IFF_BROADCAST = 0x00000002;
static const int IFF_LOOPBACK = 0x00000004;
static const int IFF_POINTTOPOINT = 0x00000008;
static const int IFF_MULTICAST = 0x00000010;
//
// Options to use with [gs]etsockopt at the IPPROTO_IP level.
// The values should be consistent with the IPv6 equivalents.
//
static const int IP_OPTIONS = 1;
static const int IP_HDRINCL = 2;
static const int IP_TOS = 3;
static const int IP_TTL = 4;
static const int IP_MULTICAST_IF = 9;
static const int IP_MULTICAST_TTL = 10;
static const int IP_MULTICAST_LOOP = 11;
static const int IP_ADD_MEMBERSHIP = 12;
static const int IP_DROP_MEMBERSHIP = 13;
static const int IP_DONTFRAGMENT = 14;
static const int IP_ADD_SOURCE_MEMBERSHIP = 15;
static const int IP_DROP_SOURCE_MEMBERSHIP = 16;
static const int IP_BLOCK_SOURCE = 17;
static const int IP_UNBLOCK_SOURCE = 18;
static const int IP_PKTINFO = 19;
static const int IP_HOPLIMIT = 21;
static const int IP_RECEIVE_BROADCAST = 22;
static const int IP_RECVIF = 24;
static const int IP_RECVDSTADDR = 25;
static const int IP_IFLIST = 28;
static const int IP_ADD_IFLIST = 29;
static const int IP_DEL_IFLIST = 30;
static const int IP_UNICAST_IF = 31;
static const int IP_RTHDR = 32;
static const int IP_RECVRTHDR = 38;
static const int IP_TCLASS = 39;
static const int IP_RECVTCLASS = 40;
static const int IP_ORIGINAL_ARRIVAL_IF = 47;
static const int IP_UNSPECIFIED_TYPE_OF_SERVICE = -1;
static const int IPV6_ADDRESS_BITS = RTL_BITS_OF(IN6_ADDR);
//
// IPv6 socket address structure, RFC 3493.
//
//
// NB: The LH version of sockaddr_in6 has the struct tag sockaddr_in6 rather
// than sockaddr_in6_lh.  This is to make sure that standard sockets apps
// that conform to RFC 2553 (Basic Socket Interface Extensions for IPv6).
//
typedef struct sockaddr_in6 {
    ADDRESS_FAMILY sin6_family; // AF_INET6.
    USHORT sin6_port; // Transport level port number.
    ULONG sin6_flowinfo; // IPv6 flow information.
    IN6_ADDR sin6_addr; // IPv6 address.
    union {
        ULONG sin6_scope_id; // Set of interfaces for a scope.
        SCOPE_ID sin6_scope_struct;
    };
} SOCKADDR_IN6_LH, *PSOCKADDR_IN6_LH, *LPSOCKADDR_IN6_LH;
typedef struct sockaddr_in6_w2ksp1 {
    short sin6_family; /* AF_INET6 */
    USHORT sin6_port; /* Transport level port number */
    ULONG sin6_flowinfo; /* IPv6 flow information */
    struct in6_addr sin6_addr; /* IPv6 address */
    ULONG sin6_scope_id; /* set of interfaces for a scope */
} SOCKADDR_IN6_W2KSP1, *PSOCKADDR_IN6_W2KSP1, *LPSOCKADDR_IN6_W2KSP1;
typedef SOCKADDR_IN6_LH SOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *LPSOCKADDR_IN6;
# 192 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h"
typedef union _SOCKADDR_INET {
    SOCKADDR_IN Ipv4;
    SOCKADDR_IN6 Ipv6;
    ADDRESS_FAMILY si_family;
} SOCKADDR_INET, *PSOCKADDR_INET;
//
// Structure to hold a pair of source, destination addresses.
//
typedef struct _sockaddr_in6_pair
{
    PSOCKADDR_IN6 SourceAddress;
    PSOCKADDR_IN6 DestinationAddress;
} SOCKADDR_IN6_PAIR, *PSOCKADDR_IN6_PAIR;
//
// Macro that works for both IPv4 and IPv6
//
static const int SS_PORT(ssp) = (((PSOCKADDR_IN)(ssp))->sin_port);
//
// N.B. These addresses are in network byte order.
//
static const int IN6ADDR_ANY_INIT = { 0 };
static const int IN6ADDR_LOOPBACK_INIT = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 };
static const int IN6ADDR_ALLNODESONNODE_INIT = { 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
static const int IN6ADDR_ALLNODESONLINK_INIT = { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
static const int IN6ADDR_ALLROUTERSONLINK_INIT = { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 };
static const int IN6ADDR_ALLMLDV2ROUTERSONLINK_INIT = { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16 };
static const int IN6ADDR_TEREDOINITIALLINKLOCALADDRESS_INIT = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe };
//
// The old link local address for XP-SP2/Win2K3 machines.
//
static const int IN6ADDR_TEREDOOLDLINKLOCALADDRESSXP_INIT = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 'T', 'E', 'R', 'E', 'D', 'O' };
//
// The old link local address for Vista Beta-2 and earlier machines.
//
static const int IN6ADDR_TEREDOOLDLINKLOCALADDRESSVISTA_INIT = { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
static const int IN6ADDR_LINKLOCALPREFIX_INIT = { 0xfe, 0x80, };
static const int IN6ADDR_MULTICASTPREFIX_INIT = { 0xff, 0x00, };
static const int IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_INIT = { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, };
static const int IN6ADDR_V4MAPPEDPREFIX_INIT = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, };
static const int IN6ADDR_6TO4PREFIX_INIT = { 0x20, 0x02, };
static const int IN6ADDR_TEREDOPREFIX_INIT = { 0x20, 0x01, 0x00, 0x00, };
static const int IN6ADDR_TEREDOPREFIX_INIT_OLD = { 0x3f, 0xfe, 0x83, 0x1f, };
static const int IN6ADDR_LINKLOCALPREFIX_LENGTH = 64;
static const int IN6ADDR_MULTICASTPREFIX_LENGTH = 8;
static const int IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH = 104;
static const int IN6ADDR_V4MAPPEDPREFIX_LENGTH = 96;
static const int IN6ADDR_6TO4PREFIX_LENGTH = 16;
static const int IN6ADDR_TEREDOPREFIX_LENGTH = 32;
//
// N.B. These addresses are in network byte order.
//
extern const SCOPE_ID scopeid_unspecified;
extern const IN_ADDR in4addr_any;
extern const IN_ADDR in4addr_loopback;
extern const IN_ADDR in4addr_broadcast;
extern const IN_ADDR in4addr_allnodesonlink;
extern const IN_ADDR in4addr_allroutersonlink;
extern const IN_ADDR in4addr_alligmpv3routersonlink;
extern const IN_ADDR in4addr_allteredohostsonlink;
extern const IN_ADDR in4addr_linklocalprefix;
extern const IN_ADDR in4addr_multicastprefix;
extern const IN6_ADDR in6addr_any;
extern const IN6_ADDR in6addr_loopback;
extern const IN6_ADDR in6addr_allnodesonnode;
extern const IN6_ADDR in6addr_allnodesonlink;
extern const IN6_ADDR in6addr_allroutersonlink;
extern const IN6_ADDR in6addr_allmldv2routersonlink;
extern const IN6_ADDR in6addr_teredoinitiallinklocaladdress;
extern const IN6_ADDR in6addr_linklocalprefix;
extern const IN6_ADDR in6addr_multicastprefix;
extern const IN6_ADDR in6addr_solicitednodemulticastprefix;
extern const IN6_ADDR in6addr_v4mappedprefix;
extern const IN6_ADDR in6addr_6to4prefix;
extern const IN6_ADDR in6addr_teredoprefix;
extern const IN6_ADDR in6addr_teredoprefix_old;
extern inline
BOOLEAN
IN6_ADDR_EQUAL(const IN6_ADDR *x, const IN6_ADDR *y)
{
    __int64 *a;
    __int64 *b;
    a = (__int64 *)x;
    b = (__int64 *)y;
    return (BOOLEAN)((a[1] == b[1]) && (a[0] == b[0]));
}
//
// RFC 3542 uses IN6_ARE_ADDR_EQUAL().
//
static const int IN6_ARE_ADDR_EQUAL = IN6_ADDR_EQUAL;
extern inline
BOOLEAN
IN6_IS_ADDR_UNSPECIFIED(const IN6_ADDR *a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     (a->u.Word[6] == 0) &&
                     (a->u.Word[7] == 0));
}
extern inline
BOOLEAN
IN6_IS_ADDR_LOOPBACK(const IN6_ADDR *a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     (a->u.Word[6] == 0) &&
                     (a->u.Word[7] == 0x0100));
}
extern inline
BOOLEAN
IN6_IS_ADDR_MULTICAST(const IN6_ADDR *a)
{
    return (BOOLEAN)(a->u.Byte[0] == 0xff);
}
//
//  Does the address have a format prefix
//  that indicates it uses EUI-64 interface identifiers?
//
extern inline
BOOLEAN
IN6_IS_ADDR_EUI64(const IN6_ADDR *a)
{
    //
    // Format prefixes 001 through 111, except for multicast.
    //
    return (BOOLEAN)(((a->u.Byte[0] & 0xe0) != 0) &&
                     !IN6_IS_ADDR_MULTICAST(a));
}
//
//  Is this the subnet router anycast address?
//  See RFC 2373.
//
extern inline
BOOLEAN
IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     (a->u.Word[6] == 0) &&
                     (a->u.Word[7] == 0));
}
//
//  Is this a subnet reserved anycast address?
//  See RFC 2526. It talks about non-EUI-64
//  addresses as well, but IMHO that part
//  of the RFC doesn't make sense. For example,
//  it shouldn't apply to multicast or v4-compatible
//  addresses.
//
extern inline
BOOLEAN
IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->u.Word[4] == 0xfffd) &&
                     (a->u.Word[5] == 0xffff) &&
                     (a->u.Word[6] == 0xffff) &&
                     ((a->u.Word[7] & 0x80ff) == 0x80ff));
}
//
//  As best we can tell from simple inspection,
//  is this an anycast address?
//
extern inline
BOOLEAN
IN6_IS_ADDR_ANYCAST(const IN6_ADDR *a)
{
    return (IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(a) ||
            IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(a));
}
extern inline
BOOLEAN
IN6_IS_ADDR_LINKLOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Byte[0] == 0xfe) &&
                     ((a->u.Byte[1] & 0xc0) == 0x80));
}
extern inline
BOOLEAN
IN6_IS_ADDR_SITELOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Byte[0] == 0xfe) &&
                     ((a->u.Byte[1] & 0xc0) == 0xc0));
}
extern inline
BOOLEAN
IN6_IS_ADDR_GLOBAL(const IN6_ADDR *a)
{
    //
    // Check the format prefix and exclude addresses
    // whose high 4 bits are all zero or all one.
    // This is a cheap way of excluding v4-compatible,
    // v4-mapped, loopback, multicast, link-local, site-local.
    //
    ULONG High = (a->u.Byte[0] & 0xf0);
    return (BOOLEAN)((High != 0) && (High != 0xf0));
}
extern inline
BOOLEAN
IN6_IS_ADDR_V4MAPPED(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0xffff));
}
extern inline
BOOLEAN
IN6_IS_ADDR_V4COMPAT(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     !((a->u.Word[6] == 0) &&
                       (a->u.Byte[14] == 0) &&
                       ((a->u.Byte[15] == 0) || (a->u.Byte[15] == 1))));
}
extern inline
BOOLEAN
IN6_IS_ADDR_V4TRANSLATED(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0xffff) &&
                     (a->u.Word[5] == 0));
}
extern inline
BOOLEAN
IN6_IS_ADDR_MC_NODELOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 1));
}
extern inline
BOOLEAN
IN6_IS_ADDR_MC_LINKLOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 2));
}
extern inline
BOOLEAN
IN6_IS_ADDR_MC_SITELOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 5));
}
extern inline
BOOLEAN
IN6_IS_ADDR_MC_ORGLOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 8));
}
extern inline
BOOLEAN
IN6_IS_ADDR_MC_GLOBAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 0xe));
}
extern inline
void
IN6_SET_ADDR_UNSPECIFIED(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->u.Byte, 0, sizeof(IN6_ADDR));
}
extern inline
void
IN6_SET_ADDR_LOOPBACK(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->u.Byte, 0, sizeof(IN6_ADDR));
    a->u.Byte[15] = 1;
}
extern inline
void
IN6ADDR_SETANY(PSOCKADDR_IN6 a)
{
    a->sin6_family = 23;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_UNSPECIFIED(&a->sin6_addr);
    a->sin6_scope_id = 0;
}
extern inline
void
IN6ADDR_SETLOOPBACK(PSOCKADDR_IN6 a)
{
    a->sin6_family = 23;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_LOOPBACK(&a->sin6_addr);
    a->sin6_scope_id = 0;
}
extern inline
BOOLEAN
IN6ADDR_ISANY(const SOCKADDR_IN6 *a)
{
    ((void) 0);
    return IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr);
}
extern inline
BOOLEAN
IN6ADDR_ISLOOPBACK(const SOCKADDR_IN6 *a)
{
    ((void) 0);
    return IN6_IS_ADDR_LOOPBACK(&a->sin6_addr);
}
extern inline
BOOLEAN
IN6ADDR_ISEQUAL(const SOCKADDR_IN6 *a, const SOCKADDR_IN6 *b)
{
    ((void) 0);
    return (BOOLEAN)(a->sin6_scope_id == b->sin6_scope_id &&
                     IN6_ADDR_EQUAL(&a->sin6_addr, &b->sin6_addr));
}
extern inline
BOOLEAN
IN6ADDR_ISUNSPECIFIED(const SOCKADDR_IN6 *a)
{
    ((void) 0);
    return (BOOLEAN)(a->sin6_scope_id == 0 &&
                     IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr));
}
//
// TCP/IP specific Ioctl codes.
//
static const int SIO_GET_INTERFACE_LIST = _IOR('t', 127, ULONG);
static const int SIO_GET_INTERFACE_LIST_EX = _IOR('t', 126, ULONG);
static const int SIO_SET_MULTICAST_FILTER = _IOW('t', 125, ULONG);
static const int SIO_GET_MULTICAST_FILTER = _IOW('t', 124 | IOC_IN, ULONG);
static const int SIOCSIPMSFILTER = SIO_SET_MULTICAST_FILTER;
static const int SIOCGIPMSFILTER = SIO_GET_MULTICAST_FILTER;
//
// Protocol independent ioctls for setting and retrieving multicast filters. 
//
static const int SIOCSMSFILTER = _IOW('t', 126, ULONG);
static const int SIOCGMSFILTER = _IOW('t', 127 | IOC_IN, ULONG);
//
// Query and change notification ioctls for the ideal send backlog size
// for a given connection. Clients should use the wrappers defined in 
// ws2tcpip.h rather than using these ioctls directly.
//
static const int SIO_IDEAL_SEND_BACKLOG_QUERY = _IOR('t', 123, ULONG);
static const int SIO_IDEAL_SEND_BACKLOG_CHANGE = _IO('t', 122);
//
// Protocol independent multicast source filter options.
//
static const int MCAST_JOIN_GROUP = 41;
static const int MCAST_LEAVE_GROUP = 42;
static const int MCAST_BLOCK_SOURCE = 43;
static const int MCAST_UNBLOCK_SOURCE = 44;
static const int MCAST_JOIN_SOURCE_GROUP = 45;
static const int MCAST_LEAVE_SOURCE_GROUP = 46;
//
// Definitions of MCAST_INCLUDE and MCAST_EXCLUDE for multicast source filter. 
//
typedef enum {
    MCAST_INCLUDE = 0,
    MCAST_EXCLUDE
} MULTICAST_MODE_TYPE;
//
// Structure for IP_MREQ (used by IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP). 
//
typedef struct ip_mreq {
    IN_ADDR imr_multiaddr; // IP multicast address of group.
    IN_ADDR imr_interface; // Local IP address of interface.
} IP_MREQ, *PIP_MREQ;
//
// Structure for IP_MREQ_SOURCE (used by IP_BLOCK_SOURCE, IP_UNBLOCK_SOURCE
// etc.). 
//
typedef struct ip_mreq_source {
    IN_ADDR imr_multiaddr; // IP multicast address of group.
    IN_ADDR imr_sourceaddr; // IP address of source.
    IN_ADDR imr_interface; // Local IP address of interface.
} IP_MREQ_SOURCE, *PIP_MREQ_SOURCE;
//
// Structure for IP_MSFILTER (used by SIOCSIPMSFILTER and SIOCGIPMSFILTER). 
// 
typedef struct ip_msfilter {
    IN_ADDR imsf_multiaddr; // IP multicast address of group.
    IN_ADDR imsf_interface; // Local IP address of interface.
    MULTICAST_MODE_TYPE imsf_fmode; // Filter mode.
    ULONG imsf_numsrc; // Number of sources in src_list.
    IN_ADDR imsf_slist[1]; // Start of source list.
} IP_MSFILTER, *PIP_MSFILTER;
static const int IP_MSFILTER_SIZE(NumSources) = (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (NumSources) * sizeof(IN_ADDR));
//
// Options to use with [gs]etsockopt at the IPPROTO_IPV6 level.
// These are specified in RFCs 3493 and 3542.
// The values should be consistent with the IPv6 equivalents.
//
static const int IPV6_HOPOPTS = 1;
static const int IPV6_HDRINCL = 2;
static const int IPV6_UNICAST_HOPS = 4;
static const int IPV6_MULTICAST_IF = 9;
static const int IPV6_MULTICAST_HOPS = 10;
static const int IPV6_MULTICAST_LOOP = 11;
static const int IPV6_ADD_MEMBERSHIP = 12;
static const int IPV6_JOIN_GROUP = IPV6_ADD_MEMBERSHIP;
static const int IPV6_DROP_MEMBERSHIP = 13;
static const int IPV6_LEAVE_GROUP = IPV6_DROP_MEMBERSHIP;
static const int IPV6_DONTFRAG = 14;
static const int IPV6_PKTINFO = 19;
static const int IPV6_HOPLIMIT = 21;
static const int IPV6_PROTECTION_LEVEL = 23;
static const int IPV6_RECVIF = 24;
static const int IPV6_RECVDSTADDR = 25;
static const int IPV6_CHECKSUM = 26;
static const int IPV6_V6ONLY = 27;
static const int IPV6_IFLIST = 28;
static const int IPV6_ADD_IFLIST = 29;
static const int IPV6_DEL_IFLIST = 30;
static const int IPV6_UNICAST_IF = 31;
static const int IPV6_RTHDR = 32;
static const int IPV6_RECVRTHDR = 38;
static const int IPV6_TCLASS = 39;
static const int IPV6_RECVTCLASS = 40;
static const int IP_UNSPECIFIED_HOP_LIMIT = -1;
static const int IP_PROTECTION_LEVEL = IPV6_PROTECTION_LEVEL;
//
// Values of IPV6_PROTECTION_LEVEL.
//
static const int PROTECTION_LEVEL_UNRESTRICTED = 10;
static const int PROTECTION_LEVEL_EDGERESTRICTED = 20;
                                           // Teredo.
static const int PROTECTION_LEVEL_RESTRICTED = 30;
static const int PROTECTION_LEVEL_DEFAULT = ((UINT)-1);
//
// Structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP (also,
// IPV6_ADD_MEMBERSHIP and IPV6_DROP_MEMBERSHIP).
//
typedef struct ipv6_mreq {
    IN6_ADDR ipv6mr_multiaddr; // IPv6 multicast address.
    ULONG ipv6mr_interface; // Interface index.
} IPV6_MREQ, *PIPV6_MREQ;
//
// Structure for GROUP_REQ used by protocol independent source filters
// (MCAST_JOIN_GROUP and MCAST_LEAVE_GROUP). 
//
typedef struct group_req {
    ULONG gr_interface; // Interface index.
    SOCKADDR_STORAGE gr_group; // Multicast address.
} GROUP_REQ, *PGROUP_REQ;
//
// Structure for GROUP_SOURCE_REQ used by protocol independent source filters
// (MCAST_JOIN_SOURCE_GROUP, MCAST_LEAVE_SOURCE_GROUP etc.).
//
typedef struct group_source_req {
    ULONG gsr_interface; // Interface index.
    SOCKADDR_STORAGE gsr_group; // Group address.
    SOCKADDR_STORAGE gsr_source; // Source address.
} GROUP_SOURCE_REQ, *PGROUP_SOURCE_REQ;
//
// Structure for GROUP_FILTER used by protocol independent source filters
// (SIOCSMSFILTER and SIOCGMSFILTER).
//
typedef struct group_filter {
    ULONG gf_interface; // Interface index.
    SOCKADDR_STORAGE gf_group; // Multicast address.
    MULTICAST_MODE_TYPE gf_fmode; // Filter mode.
    ULONG gf_numsrc; // Number of sources.
    SOCKADDR_STORAGE gf_slist[1]; // Source address.
} GROUP_FILTER, *PGROUP_FILTER;
static const int GROUP_FILTER_SIZE(numsrc) = (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) + (numsrc) * sizeof(SOCKADDR_STORAGE));
//
// Structure for IP_PKTINFO option.
//
typedef struct in_pktinfo {
    IN_ADDR ipi_addr; // Source/destination IPv4 address.
    ULONG ipi_ifindex; // Send/receive interface index.
} IN_PKTINFO, *PIN_PKTINFO;
typedef char __C_ASSERT__[(sizeof(IN_PKTINFO) == 8)?1:-1];
//
// Structure for IPV6_PKTINFO option.
//
typedef struct in6_pktinfo {
    IN6_ADDR ipi6_addr; // Source/destination IPv6 address.
    ULONG ipi6_ifindex; // Send/receive interface index.
} IN6_PKTINFO, *PIN6_PKTINFO;
typedef char __C_ASSERT__[(sizeof(IN6_PKTINFO) == 20)?1:-1];
//
// Maximum length of address literals (potentially including a port number)
// generated by any address-to-string conversion routine.  This length can
// be used when declaring buffers used with getnameinfo, WSAAddressToString,
// inet_ntoa, etc.  We just provide one define, rather than one per api,
// to avoid confusion.
//
// The totals are derived from the following data:
//  15: IPv4 address
//  45: IPv6 address including embedded IPv4 address
//  11: Scope Id
//   2: Brackets around IPv6 address when port is present
//   6: Port (including colon)
//   1: Terminating null byte
//
static const int INET_ADDRSTRLEN = 22;
static const int INET6_ADDRSTRLEN = 65;
//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
// TCP_NODELAY is defined in ws2def.h for historical reasons.
//
//
// Offload preferences supported.
//
static const int TCP_OFFLOAD_NO_PREFERENCE = 0;
static const int TCP_OFFLOAD_NOT_PREFERRED = 1;
static const int TCP_OFFLOAD_PREFERRED = 2;
//      TCP_NODELAY         	 0x0001
static const int TCP_EXPEDITED_1122 = 0x0002;
static const int TCP_KEEPALIVE = 3;
static const int TCP_MAXSEG = 4;
static const int TCP_MAXRT = 5;
static const int TCP_STDURG = 6;
static const int TCP_NOURG = 7;
static const int TCP_ATMARK = 8;
static const int TCP_NOSYNRETRIES = 9;
static const int TCP_TIMESTAMPS = 10;
static const int TCP_OFFLOAD_PREFERENCE = 11;
static const int TCP_CONGESTION_ALGORITHM = 12;
static const int TCP_DELAY_FIN_ACK = 13;
#pragma warning(pop)
# 32 "c_include/windows/original/ws2tcpip.h" 2
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h" 1
/***
*limits.h - implementation dependent values
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */
/* Define _CRTIMP */
# 18 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h" 2
static const int CHAR_BIT = 8;
static const int SCHAR_MIN = (-128);
static const int SCHAR_MAX = 127;
static const int UCHAR_MAX = 0xff;
static const int CHAR_MIN = SCHAR_MIN;
static const int CHAR_MAX = SCHAR_MAX;
static const int MB_LEN_MAX = 5;
static const int SHRT_MIN = (-32768);
static const int SHRT_MAX = 32767;
static const int USHRT_MAX = 0xffff;
static const int INT_MIN = (-2147483647 - 1);
static const int INT_MAX = 2147483647;
static const int UINT_MAX = 0xffffffff;
static const int LONG_MIN = (-2147483647L - 1);
static const long LONG_MAX = 2147483647L;
static const int ULONG_MAX = 0xffffffffUL;
static const int LLONG_MAX = 9223372036854775807i64;
static const int LLONG_MIN = (-9223372036854775807i64 - 1);
static const int ULLONG_MAX = 0xffffffffffffffffui64;
static const int _I8_MIN = (-127i8 - 1);
static const int _I8_MAX = 127i8;
static const int _UI8_MAX = 0xffui8;
static const int _I16_MIN = (-32767i16 - 1);
static const int _I16_MAX = 32767i16;
static const int _UI16_MAX = 0xffffui16;
static const int _I32_MIN = (-2147483647i32 - 1);
static const int _I32_MAX = 2147483647i32;
static const int _UI32_MAX = 0xffffffffui32;
/* minimum signed 64 bit value */
static const int _I64_MIN = (-9223372036854775807i64 - 1);
/* maximum signed 64 bit value */
static const int _I64_MAX = 9223372036854775807i64;
/* maximum unsigned 64 bit value */
static const int _UI64_MAX = 0xffffffffffffffffui64;
# 80 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h"
static const int SIZE_MAX = _UI64_MAX;
/* While waiting to the C standard committee to finalize the decision on RSIZE_MAX and rsize_t,
 * we define RSIZE_MAX as SIZE_MAX
 */
# 91 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h"
static const int RSIZE_MAX = SIZE_MAX;
# 33 "c_include/windows/original/ws2tcpip.h" 2
/* Option to use with [gs]etsockopt at the IPPROTO_UDP level */
static const int UDP_NOCHECKSUM = 1;
static const int UDP_CHECKSUM_COVERAGE = 20;
static const int WS2TCPIP_INLINE = extern inline;
/* Error codes from getaddrinfo() */
static const int EAI_AGAIN = WSATRY_AGAIN;
static const int EAI_BADFLAGS = WSAEINVAL;
static const int EAI_FAIL = WSANO_RECOVERY;
static const int EAI_FAMILY = WSAEAFNOSUPPORT;
static const int EAI_MEMORY = WSA_NOT_ENOUGH_MEMORY;
static const int EAI_NOSECURENAME = WSA_SECURE_HOST_NOT_FOUND;
//#define EAI_NODATA        WSANO_DATA
static const int EAI_NONAME = WSAHOST_NOT_FOUND;
static const int EAI_SERVICE = WSATYPE_NOT_FOUND;
static const int EAI_SOCKTYPE = WSAESOCKTNOSUPPORT;
static const int EAI_IPSECPOLICY = WSA_IPSEC_NAME_POLICY_ERROR;
//
//  DCR_FIX:  EAI_NODATA remove or fix
//
//  EAI_NODATA was removed from rfc2553bis
//  need to find out from the authors why and
//  determine the error for "no records of this type"
//  temporarily, we'll keep #define to avoid changing
//  code that could change back;  use NONAME
//
static const int EAI_NODATA = EAI_NONAME;
//  Switchable definition for GetAddrInfo()
typedef ADDRINFOA ADDRINFOT, *PADDRINFOT;
//  RFC standard definition for getaddrinfo()
typedef ADDRINFOA ADDRINFO, * LPADDRINFO;
typedef ADDRINFOEXA ADDRINFOEX, *PADDRINFOEX;
# 96 "c_include/windows/original/ws2tcpip.h"
INT
getaddrinfo(
    PCSTR pNodeName,
    PCSTR pServiceName,
    const ADDRINFOA * pHints,
    PADDRINFOA * ppResult
    );
INT
GetAddrInfoW(
    PCWSTR pNodeName,
    PCWSTR pServiceName,
    const ADDRINFOW * pHints,
    PADDRINFOW * ppResult
    );
static const int GetAddrInfoA = getaddrinfo;
static const int GetAddrInfo = GetAddrInfoA;
# 156 "c_include/windows/original/ws2tcpip.h"
typedef
void
( * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD dwBytes,
    LPWSAOVERLAPPED lpOverlapped
    );
INT
GetAddrInfoExA(
    PCSTR pName,
    PCSTR pServiceName,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    const ADDRINFOEXA *hints,
    PADDRINFOEXA * ppResult,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpNameHandle
    );
INT
GetAddrInfoExW(
    PCWSTR pName,
    PCWSTR pServiceName,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    const ADDRINFOEXW *hints,
    PADDRINFOEXW * ppResult,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpHandle
    );
static const int GetAddrInfoEx = GetAddrInfoExA;
# 245 "c_include/windows/original/ws2tcpip.h"
INT
SetAddrInfoExA(
    PCSTR pName,
    PCSTR pServiceName,
    SOCKET_ADDRESS *pAddresses,
    DWORD dwAddressCount,
    LPBLOB lpBlob,
    DWORD dwFlags,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpNameHandle
    );
INT
SetAddrInfoExW(
    PCWSTR pName,
    PCWSTR pServiceName,
    SOCKET_ADDRESS *pAddresses,
    DWORD dwAddressCount,
    LPBLOB lpBlob,
    DWORD dwFlags,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpNameHandle
    );
static const int SetAddrInfoEx = SetAddrInfoExA;
# 331 "c_include/windows/original/ws2tcpip.h"
void
freeaddrinfo(
    PADDRINFOA pAddrInfo
    );
void
FreeAddrInfoW(
    PADDRINFOW pAddrInfo
    );
static const int FreeAddrInfoA = freeaddrinfo;
static const int FreeAddrInfo = FreeAddrInfoA;
# 379 "c_include/windows/original/ws2tcpip.h"
void
FreeAddrInfoEx(
    PADDRINFOEXA pAddrInfoEx
    );
void
FreeAddrInfoExW(
    PADDRINFOEXW pAddrInfoEx
    );
static const int FreeAddrInfoExA = FreeAddrInfoEx;
typedef
void
( *LPFN_FREEADDRINFOEXA)(
    PADDRINFOEXA pAddrInfoEx
    );
typedef
void
( *LPFN_FREEADDRINFOEXW)(
    PADDRINFOEXW pAddrInfoEx
    );
static const int LPFN_FREEADDRINFOEX = LPFN_FREEADDRINFOEXA;
typedef int socklen_t;
INT
getnameinfo(
    const SOCKADDR * pSockaddr,
    socklen_t SockaddrLength,
    PCHAR pNodeBuffer,
    DWORD NodeBufferSize,
    PCHAR pServiceBuffer,
    DWORD ServiceBufferSize,
    INT Flags
    );
INT
GetNameInfoW(
    const SOCKADDR * pSockaddr,
    socklen_t SockaddrLength,
    PWCHAR pNodeBuffer,
    DWORD NodeBufferSize,
    PWCHAR pServiceBuffer,
    DWORD ServiceBufferSize,
    INT Flags
    );
static const int GetNameInfoA = getnameinfo;
static const int GetNameInfo = GetNameInfoA;
# 496 "c_include/windows/original/ws2tcpip.h"
INT
inet_pton(
    INT Family,
    PCSTR pszAddrString,
    PVOID pAddrBuf
    );
INT
InetPtonW(
    INT Family,
    PCWSTR pszAddrString,
    PVOID pAddrBuf
    );
PCSTR
inet_ntop(
    INT Family,
    PVOID pAddr,
    PSTR pStringBuf,
    size_t StringBufSize
    );
PCWSTR
InetNtopW(
    INT Family,
    PVOID pAddr,
    PWSTR pStringBuf,
    size_t StringBufSize
    );
static const int InetPtonA = inet_pton;
static const int InetNtopA = inet_ntop;
static const int InetPton = InetPtonA;
static const int InetNtop = InetNtopA;
# 594 "c_include/windows/original/ws2tcpip.h"
static const int gai_strerror = gai_strerrorA;
// WARNING: The gai_strerror inline functions below use static buffers,
// and hence are not thread-safe.  We'll use buffers long enough to hold
// 1k characters.  Any system error messages longer than this will be
// returned as empty strings.  However 1k should work for the error codes
// used by getaddrinfo().
static const int GAI_STRERROR_BUFFER_SIZE = 1024;
extern inline
char *
gai_strerrorA(
    int ecode)
{
    DWORD dwMsgLen;
    static char buff[1024 + 1];
    dwMsgLen = FormatMessageA(0x00001000
                             |0x00000200
                             |0x000000FF,
                              ((void *)0),
                              ecode,
                              ((((WORD )(0x01)) << 10) | (WORD )(0x00)),
                              (LPSTR)buff,
                              1024,
                              ((void *)0));
    return buff;
}
extern inline
WCHAR *
gai_strerrorW(
    int ecode
    )
{
    DWORD dwMsgLen;
    static WCHAR buff[1024 + 1];
    dwMsgLen = FormatMessageW(0x00001000
                             |0x00000200
                             |0x000000FF,
                              ((void *)0),
                              ecode,
                              ((((WORD )(0x01)) << 10) | (WORD )(0x00)),
                              (LPWSTR)buff,
                              1024,
                              ((void *)0));
    return buff;
}
/* Multicast source filter APIs from RFC 3678. */
extern inline
int
setipv4sourcefilter(
    SOCKET Socket,
    IN_ADDR Interface,
    IN_ADDR Group,
    MULTICAST_MODE_TYPE FilterMode,
    ULONG SourceCount,
    const IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;
    if (SourceCount >
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }
    Size = (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (SourceCount) * sizeof(IN_ADDR));
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }
    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_fmode = FilterMode;
    Filter->imsf_numsrc = SourceCount;
    if (SourceCount > 0) {
        memcpy((Filter->imsf_slist),(SourceList),(SourceCount * sizeof(*SourceList)))
                                                     ;
    }
    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(125)), Filter, Size, ((void *)0), 0,
                     &Returned, ((void *)0), ((void *)0));
    HeapFree(GetProcessHeap(), 0, Filter);
    return Error;
}
extern inline
int
getipv4sourcefilter(
    SOCKET Socket,
    IN_ADDR Interface,
    IN_ADDR Group,
    MULTICAST_MODE_TYPE *FilterMode,
    ULONG *SourceCount,
    IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;
    if (*SourceCount >
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }
    Size = (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (*SourceCount) * sizeof(IN_ADDR));
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }
    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_numsrc = *SourceCount;
    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(124 | 0x80000000)), Filter, Size, Filter, Size,
                     &Returned, ((void *)0), ((void *)0));
    if (Error == 0) {
        if (*SourceCount > 0) {
            memcpy((SourceList),(Filter->imsf_slist),(*SourceCount * sizeof(*SourceList)))
                                                          ;
            *SourceCount = Filter->imsf_numsrc;
        }
        *FilterMode = Filter->imsf_fmode;
    }
    HeapFree(GetProcessHeap(), 0, Filter);
    return Error;
}
extern inline
int
setsourcefilter(
    SOCKET Socket,
    ULONG Interface,
    const SOCKADDR *Group,
    int GroupLength,
    MULTICAST_MODE_TYPE FilterMode,
    ULONG SourceCount,
    const SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;
    if (SourceCount >=
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }
    Size = (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) + (SourceCount) * sizeof(SOCKADDR_STORAGE));
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }
    Filter->gf_interface = Interface;
    memset((&Filter->gf_group),0,(sizeof(Filter->gf_group)));
    memcpy((&Filter->gf_group),(Group),(GroupLength));
    Filter->gf_fmode = FilterMode;
    Filter->gf_numsrc = SourceCount;
    if (SourceCount > 0) {
        memcpy((Filter->gf_slist),(SourceList),(SourceCount * sizeof(*SourceList)))
                                                     ;
    }
    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(126)), Filter, Size, ((void *)0), 0,
                     &Returned, ((void *)0), ((void *)0));
    HeapFree(GetProcessHeap(), 0, Filter);
    return Error;
}
extern inline
int
getsourcefilter(
    SOCKET Socket,
    ULONG Interface,
    const SOCKADDR *Group,
    int GroupLength,
    MULTICAST_MODE_TYPE *FilterMode,
    ULONG *SourceCount,
    SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;
    if (*SourceCount >
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }
    Size = (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) + (*SourceCount) * sizeof(SOCKADDR_STORAGE));
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }
    Filter->gf_interface = Interface;
    memset((&Filter->gf_group),0,(sizeof(Filter->gf_group)));
    memcpy((&Filter->gf_group),(Group),(GroupLength));
    Filter->gf_numsrc = *SourceCount;
    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(127 | 0x80000000)), Filter, Size, Filter, Size,
                     &Returned, ((void *)0), ((void *)0));
    if (Error == 0) {
        if (*SourceCount > 0) {
            memcpy((SourceList),(Filter->gf_slist),(*SourceCount * sizeof(*SourceList)))
                                                          ;
            *SourceCount = Filter->gf_numsrc;
        }
        *FilterMode = Filter->gf_fmode;
    }
    HeapFree(GetProcessHeap(), 0, Filter);
    return Error;
}
//
// Wrapper functions for the ideal send backlog query and change notification
// ioctls
//
extern inline
int
idealsendbacklogquery(
    SOCKET s,
    ULONG *pISB
    )
{
    DWORD bytes;
    return WSAIoctl(s, (0x40000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(123)),
                    ((void *)0), 0, pISB, sizeof(*pISB), &bytes, ((void *)0), ((void *)0));
}
extern inline
int
idealsendbacklognotify(
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    DWORD bytes;
    return WSAIoctl(s, (0x20000000|(('t')<<8)|(122)),
                    ((void *)0), 0, ((void *)0), 0, &bytes,
                    lpOverlapped, lpCompletionRoutine);
}
# 957 "c_include/windows/original/ws2tcpip.h"
//
// Unless the build environment is explicitly targeting only
// platforms that include built-in getaddrinfo() support, include
// the backwards-compatibility version of the relevant APIs.
//

# 1 "c_include/windows/original/ws2tcpip.h"
#define __STDC__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __STDC_HOSTED__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GNUC__ 4
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GNUC_MINOR__ 8
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GNUC_PATCHLEVEL__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __VERSION__ "4.8.1 20130328 (prerelease)"
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_RELAXED 0
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_SEQ_CST 5
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_ACQUIRE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_RELEASE 3
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_ACQ_REL 4
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_CONSUME 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __pic__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __PIC__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FINITE_MATH_ONLY__ 0
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_INT__ 4
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_LONG__ 4
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_LONG_LONG__ 8
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_SHORT__ 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_FLOAT__ 4
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_DOUBLE__ 8
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_LONG_DOUBLE__ 16
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_SIZE_T__ 8
# 1 "c_include/windows/original/ws2tcpip.h"
#define __CHAR_BIT__ 8
# 1 "c_include/windows/original/ws2tcpip.h"
#define __BIGGEST_ALIGNMENT__ 16
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ORDER_LITTLE_ENDIAN__ 1234
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ORDER_BIG_ENDIAN__ 4321
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ORDER_PDP_ENDIAN__ 3412
# 1 "c_include/windows/original/ws2tcpip.h"
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_POINTER__ 8
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZE_TYPE__ long long unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __PTRDIFF_TYPE__ long long int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WCHAR_TYPE__ short unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WINT_TYPE__ short unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INTMAX_TYPE__ long long int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINTMAX_TYPE__ long long unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __CHAR16_TYPE__ short unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __CHAR32_TYPE__ unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIG_ATOMIC_TYPE__ int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT8_TYPE__ signed char
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT16_TYPE__ short int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT32_TYPE__ int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT64_TYPE__ long long int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT8_TYPE__ unsigned char
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT16_TYPE__ short unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT32_TYPE__ unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT64_TYPE__ long long unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST8_TYPE__ signed char
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST16_TYPE__ short int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST32_TYPE__ int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST64_TYPE__ long long int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST8_TYPE__ unsigned char
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST16_TYPE__ short unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST32_TYPE__ unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST64_TYPE__ long long unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST8_TYPE__ signed char
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST16_TYPE__ short int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST32_TYPE__ int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST64_TYPE__ long long int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST8_TYPE__ unsigned char
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST16_TYPE__ short unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST32_TYPE__ unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST64_TYPE__ long long unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INTPTR_TYPE__ long long int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINTPTR_TYPE__ long long unsigned int
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GXX_ABI_VERSION 1002
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SCHAR_MAX__ 127
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SHRT_MAX__ 32767
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_MAX__ 2147483647
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LONG_MAX__ 2147483647L
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LONG_LONG_MAX__ 9223372036854775807LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WCHAR_MAX__ 65535
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WCHAR_MIN__ 0
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WINT_MAX__ 65535
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WINT_MIN__ 0
# 1 "c_include/windows/original/ws2tcpip.h"
#define __PTRDIFF_MAX__ 9223372036854775807LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZE_MAX__ 18446744073709551615ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INTMAX_MAX__ 9223372036854775807LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INTMAX_C(c) c ## LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINTMAX_MAX__ 18446744073709551615ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINTMAX_C(c) c ## ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIG_ATOMIC_MAX__ 2147483647
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT8_MAX__ 127
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT16_MAX__ 32767
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT32_MAX__ 2147483647
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT64_MAX__ 9223372036854775807LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT8_MAX__ 255
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT16_MAX__ 65535
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT32_MAX__ 4294967295U
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT64_MAX__ 18446744073709551615ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST8_MAX__ 127
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT8_C(c) c
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST16_MAX__ 32767
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT16_C(c) c
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST32_MAX__ 2147483647
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT32_C(c) c
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_LEAST64_MAX__ 9223372036854775807LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT64_C(c) c ## LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST8_MAX__ 255
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT8_C(c) c
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST16_MAX__ 65535
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT16_C(c) c
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST32_MAX__ 4294967295U
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT32_C(c) c ## U
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_LEAST64_MAX__ 18446744073709551615ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT64_C(c) c ## ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST8_MAX__ 127
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST16_MAX__ 32767
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST32_MAX__ 2147483647
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INT_FAST64_MAX__ 9223372036854775807LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST8_MAX__ 255
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST16_MAX__ 65535
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST32_MAX__ 4294967295U
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINT_FAST64_MAX__ 18446744073709551615ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __INTPTR_MAX__ 9223372036854775807LL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __UINTPTR_MAX__ 18446744073709551615ULL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_EVAL_METHOD__ 0
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC_EVAL_METHOD__ 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_RADIX__ 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_MANT_DIG__ 24
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_DIG__ 6
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_MIN_EXP__ (-125)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_MIN_10_EXP__ (-37)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_MAX_EXP__ 128
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_MAX_10_EXP__ 38
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_DECIMAL_DIG__ 9
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_MAX__ 3.40282346638528859812e+38F
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_MIN__ 1.17549435082228750797e-38F
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_EPSILON__ 1.19209289550781250000e-7F
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_DENORM_MIN__ 1.40129846432481707092e-45F
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_HAS_DENORM__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_HAS_INFINITY__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __FLT_HAS_QUIET_NAN__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_MANT_DIG__ 53
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_DIG__ 15
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_MIN_EXP__ (-1021)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_MIN_10_EXP__ (-307)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_MAX_EXP__ 1024
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_MAX_10_EXP__ 308
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_DECIMAL_DIG__ 17
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_MAX__ ((double)1.79769313486231570815e+308L)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_MIN__ ((double)2.22507385850720138309e-308L)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_EPSILON__ ((double)2.22044604925031308085e-16L)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544177e-324L)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_HAS_DENORM__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_HAS_INFINITY__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DBL_HAS_QUIET_NAN__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_MANT_DIG__ 64
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_DIG__ 18
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_MIN_EXP__ (-16381)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_MIN_10_EXP__ (-4931)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_MAX_EXP__ 16384
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_MAX_10_EXP__ 4932
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DECIMAL_DIG__ 21
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_MAX__ 1.18973149535723176502e+4932L
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_MIN__ 3.36210314311209350626e-4932L
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_HAS_DENORM__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_HAS_INFINITY__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __LDBL_HAS_QUIET_NAN__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC32_MANT_DIG__ 7
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC32_MIN_EXP__ (-94)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC32_MAX_EXP__ 97
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC32_MIN__ 1E-95DF
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC32_MAX__ 9.999999E96DF
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC32_EPSILON__ 1E-6DF
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC64_MANT_DIG__ 16
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC64_MIN_EXP__ (-382)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC64_MAX_EXP__ 385
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC64_MIN__ 1E-383DD
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC64_MAX__ 9.999999999999999E384DD
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC64_EPSILON__ 1E-15DD
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC128_MANT_DIG__ 34
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC128_MIN_EXP__ (-6142)
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC128_MAX_EXP__ 6145
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC128_MIN__ 1E-6143DL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC128_EPSILON__ 1E-33DL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
# 1 "c_include/windows/original/ws2tcpip.h"
#define __REGISTER_PREFIX__ 
# 1 "c_include/windows/original/ws2tcpip.h"
#define __USER_LABEL_PREFIX__ 
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GNUC_GNU_INLINE__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __NO_INLINE__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_INT_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __PRAGMA_REDEFINE_EXTNAME 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_INT128__ 16
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_WCHAR_T__ 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_WINT_T__ 2
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SIZEOF_PTRDIFF_T__ 8
# 1 "c_include/windows/original/ws2tcpip.h"
#define __amd64 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __amd64__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __x86_64 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __x86_64__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_HLE_ACQUIRE 65536
# 1 "c_include/windows/original/ws2tcpip.h"
#define __ATOMIC_HLE_RELEASE 131072
# 1 "c_include/windows/original/ws2tcpip.h"
#define __k8 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __k8__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __code_model_small__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __MMX__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SSE__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SSE2__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SSE_MATH__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SSE2_MATH__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __SEH__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __stdcall __attribute__((__stdcall__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define __fastcall __attribute__((__fastcall__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define __thiscall __attribute__((__thiscall__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define __cdecl __attribute__((__cdecl__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define _stdcall __attribute__((__stdcall__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define _fastcall __attribute__((__fastcall__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define _thiscall __attribute__((__thiscall__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define _cdecl __attribute__((__cdecl__))
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GXX_MERGED_TYPEINFO_NAMES 0
# 1 "c_include/windows/original/ws2tcpip.h"
#define __GXX_TYPEINFO_EQUALITY_INLINE 0
# 1 "c_include/windows/original/ws2tcpip.h"
#define __MSVCRT__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __MINGW32__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define _WIN32 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WIN32 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WIN32__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define WIN32 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WINNT 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WINNT__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define WINNT 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define _INTEGRAL_MAX_BITS 64
# 1 "c_include/windows/original/ws2tcpip.h"
#define __MINGW64__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WIN64 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __WIN64__ 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define WIN64 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define _WIN64 1
# 1 "c_include/windows/original/ws2tcpip.h"
#define __declspec(x) __attribute__((x))
# 1 "c_include/windows/original/ws2tcpip.h"
#define __DECIMAL_BID_FORMAT__ 1
# 1 "<command-line>"
#undef _REENTRANT
# 1 "c_include/windows/original/ws2tcpip.h"
#define _WIN32_WINNT 0x0602
#define WINVER _WIN32_WINNT
#define WIN32_LEAN_AND_MEAN 
#pragma comment (lib, "Ws2_32.lib")
/*
**  WS2TCPIP.H - WinSock2 Extension for TCP/IP protocols
**
**  This file contains TCP/IP specific information for use
**  by WinSock2 compatible applications.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**  To provide the backward compatibility, all the TCP/IP
**  specific definitions that were included in the WINSOCK.H
**   file are now included in WINSOCK2.H file. WS2TCPIP.H
**  file includes only the definitions  introduced in the
**  "WinSock 2 Protocol-Specific Annex" document.
**
**  Rev 0.3 Nov 13, 1995
**      Rev 0.4 Dec 15, 1996
*/


#define _WS2TCPIP_H_ 





# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 1
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    118736
//  $AgreementName:  berkeley software distribution license
//  $AgreementType:  oss license
//  $ExternalOrigin: regents of the university of california
//$ENDTAG

//$TAG ENGR 
//  $Owner:    vadime
//  $Module:   published_inc
//
//$ENDTAG

/* Winsock2.h -- definitions to be used with the WinSock 2 DLL and

 *               WinSock 2 applications.

 *

 * This header file corresponds to version 2.2.x of the WinSock API

 * specification.

 *

 * This file includes parts which are Copyright (c) 1982-1986 Regents

 * of the University of California.  All rights reserved.  The

 * Berkeley Software License Agreement specifies the terms and

 * conditions for redistribution.

 */
# 28 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define _WINSOCK2API_ 
#define _WINSOCKAPI_ 

       

/*

 * Ensure structures are packed consistently.

 * Not necessary for WIN32, it is already packed >=4 and there are

 * no structures in this header that have alignment requirement 

 * higher than 4.

 * For WIN64 we do not have compatibility requirement because it is

 * not possible to mix 32/16 bit code with 64 bit code in the same

 * process.

 */
/*

 * Default: include function prototypes, don't include function typedefs.

 */
#define INCL_WINSOCK_API_PROTOTYPES 1



#define INCL_WINSOCK_API_TYPEDEFS 0


/*

 * Pull in WINDOWS.H if necessary

 */
# 66 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 1

/*++ BUILD Version: 0001    Increment this if a change has global effects



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:





    windows.h



Abstract:



    Master include file for Windows applications.



--*/
# 18 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
#define _WINDOWS_ 


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h" 1
/*



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    sdkddkver.h



Abstract:



    Master include file for versioning windows SDK/DDK.



*/
# 16 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
#define _INC_SDKDDKVER 
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
       

//
// _WIN32_WINNT version constants
//
#define _WIN32_WINNT_NT4 0x0400
#define _WIN32_WINNT_WIN2K 0x0500
#define _WIN32_WINNT_WINXP 0x0501
#define _WIN32_WINNT_WS03 0x0502
#define _WIN32_WINNT_WIN6 0x0600
#define _WIN32_WINNT_VISTA 0x0600
#define _WIN32_WINNT_WS08 0x0600
#define _WIN32_WINNT_LONGHORN 0x0600
#define _WIN32_WINNT_WIN7 0x0601

//
// _WIN32_IE_ version constants
//
#define _WIN32_IE_IE20 0x0200
#define _WIN32_IE_IE30 0x0300
#define _WIN32_IE_IE302 0x0302
#define _WIN32_IE_IE40 0x0400
#define _WIN32_IE_IE401 0x0401
#define _WIN32_IE_IE50 0x0500
#define _WIN32_IE_IE501 0x0501
#define _WIN32_IE_IE55 0x0550
#define _WIN32_IE_IE60 0x0600
#define _WIN32_IE_IE60SP1 0x0601
#define _WIN32_IE_IE60SP2 0x0603
#define _WIN32_IE_IE70 0x0700
#define _WIN32_IE_IE80 0x0800

//
// IE <-> OS version mapping
//
// NT4 supports IE versions 2.0 -> 6.0 SP1
#define _WIN32_IE_NT4 _WIN32_IE_IE20
#define _WIN32_IE_NT4SP1 _WIN32_IE_IE20
#define _WIN32_IE_NT4SP2 _WIN32_IE_IE20
#define _WIN32_IE_NT4SP3 _WIN32_IE_IE302
#define _WIN32_IE_NT4SP4 _WIN32_IE_IE401
#define _WIN32_IE_NT4SP5 _WIN32_IE_IE401
#define _WIN32_IE_NT4SP6 _WIN32_IE_IE50
// Win98 supports IE versions 4.01 -> 6.0 SP1
#define _WIN32_IE_WIN98 _WIN32_IE_IE401
// Win98SE supports IE versions 5.0 -> 6.0 SP1
#define _WIN32_IE_WIN98SE _WIN32_IE_IE50
// WinME supports IE versions 5.5 -> 6.0 SP1
#define _WIN32_IE_WINME _WIN32_IE_IE55
// Win2k supports IE versions 5.01 -> 6.0 SP1
#define _WIN32_IE_WIN2K _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP1 _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP2 _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP3 _WIN32_IE_IE501
#define _WIN32_IE_WIN2KSP4 _WIN32_IE_IE501
#define _WIN32_IE_XP _WIN32_IE_IE60
#define _WIN32_IE_XPSP1 _WIN32_IE_IE60SP1
#define _WIN32_IE_XPSP2 _WIN32_IE_IE60SP2
#define _WIN32_IE_WS03 0x0602
#define _WIN32_IE_WS03SP1 _WIN32_IE_IE60SP2
#define _WIN32_IE_WIN6 _WIN32_IE_IE70
#define _WIN32_IE_LONGHORN _WIN32_IE_IE70
#define _WIN32_IE_WIN7 _WIN32_IE_IE80


//
// NTDDI version constants
//
#define NTDDI_WIN2K 0x05000000
#define NTDDI_WIN2KSP1 0x05000100
#define NTDDI_WIN2KSP2 0x05000200
#define NTDDI_WIN2KSP3 0x05000300
#define NTDDI_WIN2KSP4 0x05000400

#define NTDDI_WINXP 0x05010000
#define NTDDI_WINXPSP1 0x05010100
#define NTDDI_WINXPSP2 0x05010200
#define NTDDI_WINXPSP3 0x05010300
#define NTDDI_WINXPSP4 0x05010400

#define NTDDI_WS03 0x05020000
#define NTDDI_WS03SP1 0x05020100
#define NTDDI_WS03SP2 0x05020200
#define NTDDI_WS03SP3 0x05020300
#define NTDDI_WS03SP4 0x05020400

#define NTDDI_WIN6 0x06000000
#define NTDDI_WIN6SP1 0x06000100
#define NTDDI_WIN6SP2 0x06000200
#define NTDDI_WIN6SP3 0x06000300
#define NTDDI_WIN6SP4 0x06000400

#define NTDDI_VISTA NTDDI_WIN6
#define NTDDI_VISTASP1 NTDDI_WIN6SP1
#define NTDDI_VISTASP2 NTDDI_WIN6SP2
#define NTDDI_VISTASP3 NTDDI_WIN6SP3
#define NTDDI_VISTASP4 NTDDI_WIN6SP4

#define NTDDI_LONGHORN NTDDI_VISTA

#define NTDDI_WS08 NTDDI_WIN6SP1
#define NTDDI_WS08SP2 NTDDI_WIN6SP2
#define NTDDI_WS08SP3 NTDDI_WIN6SP3
#define NTDDI_WS08SP4 NTDDI_WIN6SP4

#define NTDDI_WIN7 0x06010000

//
// masks for version macros
//
#define OSVERSION_MASK 0xFFFF0000
#define SPVERSION_MASK 0x0000FF00
#define SUBVERSION_MASK 0x000000FF


//
// macros to extract various version fields from the NTDDI version
//
#define OSVER(Version) ((Version) & OSVERSION_MASK)
#define SPVER(Version) (((Version) & SPVERSION_MASK) >> 8)
#define SUBVER(Version) (((Version) & SUBVERSION_MASK) )
# 183 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
//
// if versions aren't already defined, default to most current
//

#define NTDDI_VERSION_FROM_WIN32_WINNT2(ver) ver ##0000
#define NTDDI_VERSION_FROM_WIN32_WINNT(ver) NTDDI_VERSION_FROM_WIN32_WINNT2(ver)
# 202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
// set NTDDI_VERSION based on _WIN32_WINNT
#define NTDDI_VERSION NTDDI_VERSION_FROM_WIN32_WINNT(_WIN32_WINNT)
# 220 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
// set _WIN32_IE based on _WIN32_WINNT
# 230 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdkddkver.h"
#define _WIN32_IE 0x0800






//
// Sanity check for compatible versions
//
# 22 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2


#define _INC_WINDOWS 





/*  If defined, the following flags inhibit definition

 *     of the indicated items.

 *

 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_

 *  NOVIRTUALKEYCODES - VK_*

 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*

 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*

 *  NOSYSMETRICS      - SM_*

 *  NOMENUS           - MF_*

 *  NOICONS           - IDI_*

 *  NOKEYSTATES       - MK_*

 *  NOSYSCOMMANDS     - SC_*

 *  NORASTEROPS       - Binary and Tertiary raster ops

 *  NOSHOWWINDOW      - SW_*

 *  OEMRESOURCE       - OEM Resource values

 *  NOATOM            - Atom Manager routines

 *  NOCLIPBOARD       - Clipboard routines

 *  NOCOLOR           - Screen colors

 *  NOCTLMGR          - Control and Dialog routines

 *  NODRAWTEXT        - DrawText() and DT_*

 *  NOGDI             - All GDI defines and routines

 *  NOKERNEL          - All KERNEL defines and routines

 *  NOUSER            - All USER defines and routines

 *  NONLS             - All NLS defines and routines

 *  NOMB              - MB_* and MessageBox()

 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines

 *  NOMETAFILE        - typedef METAFILEPICT

 *  NOMINMAX          - Macros min(a,b) and max(a,b)

 *  NOMSG             - typedef MSG and associated routines

 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*

 *  NOSCROLL          - SB_* and scrolling routines

 *  NOSERVICE         - All Service Controller routines, SERVICE_ equates, etc.

 *  NOSOUND           - Sound driver routines

 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines

 *  NOWH              - SetWindowsHook and WH_*

 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines

 *  NOCOMM            - COMM driver routines

 *  NOKANJI           - Kanji support stuff.

 *  NOHELP            - Help engine interface.

 *  NOPROFILER        - Profiler interface.

 *  NODEFERWINDOWPOS  - DeferWindowPos routines

 *  NOMCX             - Modem Configuration Extensions

 */
# 151 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h" 1
/***

*excpt.h - defines exception values, types and routines

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This file contains the definitions and prototypes for the compiler-

*       dependent intrinsics, support functions and keywords which implement

*       the structured exception handling extensions.

*

*       [Public]

*

****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
       


#define _INC_EXCPT 

# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***

*crtdefs.h - definitions/declarations common to all CRT

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This file has mostly defines used by the entire CRT.

*

*       [Public]

*

****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */

/* Define _CRTIMP */




#define _CRTIMP 




#define _INC_CRTDEFS 
# 47 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Note on use of "deprecate":

 * Various places in this header and other headers use __declspec(deprecate) or macros that have the term DEPRECATE in them.

 * We use deprecate here ONLY to signal the compiler to emit a warning about these items. The use of deprecate

 * should NOT be taken to imply that any standard committee has deprecated these functions from the relevant standards.

 * In fact, these functions are NOT deprecated from the standard.

 *

 * Full details can be found in our documentation by searching for "Security Enhancements in the CRT".

*/
# 56 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h" 1
/***

*sal.h - markers for documenting the semantics of APIs

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       sal.h provides a set of annotations to describe how a function uses its

*       parameters - the assumptions it makes about them, and the guarantees it makes

*       upon finishing.

*

*       [Public]

*

****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
       
/*==========================================================================



   The macros are defined in 3 layers:



   _In_\_Out_ Layer:

   ----------------

   This layer provides the highest abstraction and its macros should be used

   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the

   typical case they provide the most concise annotations.



   _Pre_\_Post_ Layer:

   ------------------

   The macros of this layer only should be used when there is no suitable macro

   in the _In_\_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,

   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most

   flexibility for annotations.



   Implementation Abstraction Layer:

   --------------------------------

   Macros from this layer should never be used directly. The layer only exists

   to hide the implementation of the annotation macros.





   Annotation Syntax:

   |--------------|----------|----------------|-----------------------------|

   |   Usage      | Nullness | ZeroTerminated |  Extent                     |

   |--------------|----------|----------------|-----------------------------|

   | _In_         | <>       | <>             | <>                          |

   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |

   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |

   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |

   |--------------|          |                | ptrdiff_count_( ptr )       |

   | _Ret_        |          |                |                             |

   | _Deref_ret_  |          |                |                             |

   |--------------|          |                |                             |

   | _Pre_        |          |                |                             |

   | _Post_       |          |                |                             |

   | _Deref_pre_  |          |                |                             |

   | _Deref_post_ |          |                |                             |

   |--------------|----------|----------------|-----------------------------|



   Usage:

   -----

   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for

   formal parameters.

   _Ret_, _Deref_ret_ must be used for return values.



   Nullness:

   --------

   If the pointer can be NULL the annotation contains _opt. If the macro

   does not contain '_opt' the pointer may not be NULL.



   String Type:

   -----------

   _z: NullTerminated string

   for _In_ parameters the buffer must have the specified stringtype before the call

   for _Out_ parameters the buffer must have the specified stringtype after the call

   for _Inout_ parameters both conditions apply



   Extent Syntax:

   |------|---------------|---------------|

   | Unit | Writ\Readable | Argument Type |

   |------|---------------|---------------|

   |  <>  | cap_          | <>            |

   | byte | count_        | c_            |

   |      |               | x_            |

   |------|---------------|---------------|



   'cap' (capacity) describes the writable size of the buffer and is typically used

   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes

   'count' describes the readable size of the buffer and is typically used with _In_.

   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   

   Argument syntax for cap_, bytecap_, count_, bytecount_:

   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   

   If the buffer size is a constant expression use the c_ postfix.

   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)



   If the buffer size is given by a limiting pointer use the ptrdiff_ versions

   of the macros.



   If the buffer size is neither a parameter nor a constant expression use the x_

   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.

   No analysis can be done for x_ annotations but they at least tell the tool that

   the buffer has some sort of extent description. x_ annotations might be supported

   by future compiler versions.



============================================================================*/
# 106 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
#define __ATTR_SAL 
# 140 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
// Disable expansion of SAL macros in non-Prefast mode to 
// improve compiler throughput.

#define _USE_DECLSPECS_FOR_SAL 0


#define _USE_ATTRIBUTES_FOR_SAL 0


// safeguard for MIDL and RC builds
# 163 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
//============================================================================
//   _In_\_Out_ Layer:
//============================================================================

// 'in' parameters --------------------------

// input pointer parameter
// e.g. void SetPoint( _In_ const POINT* pPT );
#define _In_ _Pre1_impl_(_$notnull) _Deref_pre2_impl_(_$valid, _$readaccess)
#define _In_opt_ _Pre_opt_valid_ _Deref_pre_readonly_

// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _In_z_ _Pre_z_ _Deref_pre_readonly_
#define _In_opt_z_ _Pre_opt_z_ _Deref_pre_readonly_

// 'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter
#define _In_count_(size) _Pre_count_(size) _Deref_pre_readonly_
#define _In_opt_count_(size) _Pre_opt_count_(size) _Deref_pre_readonly_
#define _In_bytecount_(size) _Pre_bytecount_(size) _Deref_pre_readonly_
#define _In_opt_bytecount_(size) _Pre_opt_bytecount_(size) _Deref_pre_readonly_

// valid buffer extent described by a constant extression
#define _In_count_c_(size) _Pre_count_c_(size) _Deref_pre_readonly_
#define _In_opt_count_c_(size) _Pre_opt_count_c_(size) _Deref_pre_readonly_
#define _In_bytecount_c_(size) _Pre_bytecount_c_(size) _Deref_pre_readonly_
#define _In_opt_bytecount_c_(size) _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_

// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter
#define _In_z_count_(size) _Pre_z_ _Pre_count_(size) _Deref_pre_readonly_
#define _In_opt_z_count_(size) _Pre_opt_z_ _Pre_opt_count_(size) _Deref_pre_readonly_
#define _In_z_bytecount_(size) _Pre_z_ _Pre_bytecount_(size) _Deref_pre_readonly_
#define _In_opt_z_bytecount_(size) _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_

// nullterminated valid buffer extent described by a constant extression
#define _In_z_count_c_(size) _Pre_z_ _Pre_count_c_(size) _Deref_pre_readonly_
#define _In_opt_z_count_c_(size) _Pre_opt_z_ _Pre_opt_count_c_(size) _Deref_pre_readonly_
#define _In_z_bytecount_c_(size) _Pre_z_ _Pre_bytecount_c_(size) _Deref_pre_readonly_
#define _In_opt_z_bytecount_c_(size) _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_

// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _In_ptrdiff_count_(size) _Pre_ptrdiff_count_(size) _Deref_pre_readonly_
#define _In_opt_ptrdiff_count_(size) _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_

// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );
#define _In_count_x_(size) _Pre_count_x_(size) _Deref_pre_readonly_
#define _In_opt_count_x_(size) _Pre_opt_count_x_(size) _Deref_pre_readonly_
#define _In_bytecount_x_(size) _Pre_bytecount_x_(size) _Deref_pre_readonly_
#define _In_opt_bytecount_x_(size) _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_

// 'out' parameters --------------------------

// output pointer parameter
// e.g. void GetPoint( _Out_ POINT* pPT );
#define _Out_ _Pre_cap_c_(1) _Pre_invalid_
#define _Out_opt_ _Pre_opt_cap_c_(1) _Pre_invalid_

// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter
#define _Out_cap_(size) _Pre_cap_(size) _Pre_invalid_
#define _Out_opt_cap_(size) _Pre_opt_cap_(size) _Pre_invalid_
#define _Out_bytecap_(size) _Pre_bytecap_(size) _Pre_invalid_
#define _Out_opt_bytecap_(size) _Pre_opt_bytecap_(size) _Pre_invalid_

// buffer capacity is described by a constant expression
#define _Out_cap_c_(size) _Pre_cap_c_(size) _Pre_invalid_
#define _Out_opt_cap_c_(size) _Pre_opt_cap_c_(size) _Pre_invalid_
#define _Out_bytecap_c_(size) _Pre_bytecap_c_(size) _Pre_invalid_
#define _Out_opt_bytecap_c_(size) _Pre_opt_bytecap_c_(size) _Pre_invalid_

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Out_cap_m_(mult,size) _Pre_cap_m_(mult,size) _Pre_invalid_
#define _Out_opt_cap_m_(mult,size) _Pre_opt_cap_m_(mult,size) _Pre_invalid_
#define _Out_z_cap_m_(mult,size) _Pre_cap_m_(mult,size) _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_m_(mult,size) _Pre_opt_cap_m_(mult,size) _Pre_invalid_ _Post_z_

// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _Out_ptrdiff_cap_(size) _Pre_ptrdiff_cap_(size) _Pre_invalid_
#define _Out_opt_ptrdiff_cap_(size) _Pre_opt_ptrdiff_cap_(size) _Pre_invalid_

// buffer capacity is described by a complex expression
#define _Out_cap_x_(size) _Pre_cap_x_(size) _Pre_invalid_
#define _Out_opt_cap_x_(size) _Pre_opt_cap_x_(size) _Pre_invalid_
#define _Out_bytecap_x_(size) _Pre_bytecap_x_(size) _Pre_invalid_
#define _Out_opt_bytecap_x_(size) _Pre_opt_bytecap_x_(size) _Pre_invalid_

// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter
#define _Out_z_cap_(size) _Pre_cap_(size) _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_(size) _Pre_opt_cap_(size) _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_(size) _Pre_bytecap_(size) _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_(size) _Pre_opt_bytecap_(size) _Pre_invalid_ _Post_z_

// buffer capacity is described by a constant expression
#define _Out_z_cap_c_(size) _Pre_cap_c_(size) _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_c_(size) _Pre_opt_cap_c_(size) _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_c_(size) _Pre_bytecap_c_(size) _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_c_(size) _Pre_opt_bytecap_c_(size) _Pre_invalid_ _Post_z_

// buffer capacity is described by a complex expression
#define _Out_z_cap_x_(size) _Pre_cap_x_(size) _Pre_invalid_ _Post_z_
#define _Out_opt_z_cap_x_(size) _Pre_opt_cap_x_(size) _Pre_invalid_ _Post_z_
#define _Out_z_bytecap_x_(size) _Pre_bytecap_x_(size) _Pre_invalid_ _Post_z_
#define _Out_opt_z_bytecap_x_(size) _Pre_opt_bytecap_x_(size) _Pre_invalid_ _Post_z_

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );
#define _Out_cap_post_count_(cap,count) _Pre_cap_(cap) _Pre_invalid_ _Post_count_(count)
#define _Out_opt_cap_post_count_(cap,count) _Pre_opt_cap_(cap) _Pre_invalid_ _Post_count_(count)
#define _Out_bytecap_post_bytecount_(cap,count) _Pre_bytecap_(cap) _Pre_invalid_ _Post_bytecount_(count)
#define _Out_opt_bytecap_post_bytecount_(cap,count) _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_bytecount_(count)

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );
#define _Out_z_cap_post_count_(cap,count) _Pre_cap_(cap) _Pre_invalid_ _Post_z_count_(count)
#define _Out_opt_z_cap_post_count_(cap,count) _Pre_opt_cap_(cap) _Pre_invalid_ _Post_z_count_(count)
#define _Out_z_bytecap_post_bytecount_(cap,count) _Pre_bytecap_(cap) _Pre_invalid_ _Post_z_bytecount_(count)
#define _Out_opt_z_bytecap_post_bytecount_(cap,count) _Pre_opt_bytecap_(cap) _Pre_invalid_ _Post_z_bytecount_(count)

// only use with dereferenced arguments e.g. '*pcch' 
#define _Out_capcount_(capcount) _Pre_cap_(capcount) _Pre_invalid_ _Post_count_(capcount)
#define _Out_opt_capcount_(capcount) _Pre_opt_cap_(capcount) _Pre_invalid_ _Post_count_(capcount)
#define _Out_bytecapcount_(capcount) _Pre_bytecap_(capcount) _Pre_invalid_ _Post_bytecount_(capcount)
#define _Out_opt_bytecapcount_(capcount) _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_bytecount_(capcount)

#define _Out_capcount_x_(capcount) _Pre_cap_x_(capcount) _Pre_invalid_ _Post_count_x_(capcount)
#define _Out_opt_capcount_x_(capcount) _Pre_opt_cap_x_(capcount) _Pre_invalid_ _Post_count_x_(capcount)
#define _Out_bytecapcount_x_(capcount) _Pre_bytecap_x_(capcount) _Pre_invalid_ _Post_bytecount_x_(capcount)
#define _Out_opt_bytecapcount_x_(capcount) _Pre_opt_bytecap_x_(capcount) _Pre_invalid_ _Post_bytecount_x_(capcount)

// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );
#define _Out_z_capcount_(capcount) _Pre_cap_(capcount) _Pre_invalid_ _Post_z_count_(capcount)
#define _Out_opt_z_capcount_(capcount) _Pre_opt_cap_(capcount) _Pre_invalid_ _Post_z_count_(capcount)
#define _Out_z_bytecapcount_(capcount) _Pre_bytecap_(capcount) _Pre_invalid_ _Post_z_bytecount_(capcount)
#define _Out_opt_z_bytecapcount_(capcount) _Pre_opt_bytecap_(capcount) _Pre_invalid_ _Post_z_bytecount_(capcount)

// inout parameters ----------------------------

// inout pointer parameter
// e.g. void ModifyPoint( _Inout_ POINT* pPT );
#define _Inout_ _Prepost_valid_
#define _Inout_opt_ _Prepost_opt_valid_

// string buffers
// e.g. void toupper( _Inout_z_ char* sz );
#define _Inout_z_ _Prepost_z_
#define _Inout_opt_z_ _Prepost_opt_z_

// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_count_(size) _Prepost_count_(size)
#define _Inout_opt_count_(size) _Prepost_opt_count_(size)
#define _Inout_bytecount_(size) _Prepost_bytecount_(size)
#define _Inout_opt_bytecount_(size) _Prepost_opt_bytecount_(size)

#define _Inout_count_c_(size) _Prepost_count_c_(size)
#define _Inout_opt_count_c_(size) _Prepost_opt_count_c_(size)
#define _Inout_bytecount_c_(size) _Prepost_bytecount_c_(size)
#define _Inout_opt_bytecount_c_(size) _Prepost_opt_bytecount_c_(size)

// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );
#define _Inout_z_count_(size) _Prepost_z_ _Prepost_count_(size)
#define _Inout_opt_z_count_(size) _Prepost_z_ _Prepost_opt_count_(size)
#define _Inout_z_bytecount_(size) _Prepost_z_ _Prepost_bytecount_(size)
#define _Inout_opt_z_bytecount_(size) _Prepost_z_ _Prepost_opt_bytecount_(size)

#define _Inout_z_count_c_(size) _Prepost_z_ _Prepost_count_c_(size)
#define _Inout_opt_z_count_c_(size) _Prepost_z_ _Prepost_opt_count_c_(size)
#define _Inout_z_bytecount_c_(size) _Prepost_z_ _Prepost_bytecount_c_(size)
#define _Inout_opt_z_bytecount_c_(size) _Prepost_z_ _Prepost_opt_bytecount_c_(size)

#define _Inout_ptrdiff_count_(size) _Pre_ptrdiff_count_(size)
#define _Inout_opt_ptrdiff_count_(size) _Pre_opt_ptrdiff_count_(size)

#define _Inout_count_x_(size) _Prepost_count_x_(size)
#define _Inout_opt_count_x_(size) _Prepost_opt_count_x_(size)
#define _Inout_bytecount_x_(size) _Prepost_bytecount_x_(size)
#define _Inout_opt_bytecount_x_(size) _Prepost_opt_bytecount_x_(size)

// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );
#define _Inout_cap_(size) _Pre_valid_cap_(size) _Post_valid_
#define _Inout_opt_cap_(size) _Pre_opt_valid_cap_(size) _Post_valid_
#define _Inout_bytecap_(size) _Pre_valid_bytecap_(size) _Post_valid_
#define _Inout_opt_bytecap_(size) _Pre_opt_valid_bytecap_(size) _Post_valid_

#define _Inout_cap_c_(size) _Pre_valid_cap_c_(size) _Post_valid_
#define _Inout_opt_cap_c_(size) _Pre_opt_valid_cap_c_(size) _Post_valid_
#define _Inout_bytecap_c_(size) _Pre_valid_bytecap_c_(size) _Post_valid_
#define _Inout_opt_bytecap_c_(size) _Pre_opt_valid_bytecap_c_(size) _Post_valid_

#define _Inout_cap_x_(size) _Pre_valid_cap_x_(size) _Post_valid_
#define _Inout_opt_cap_x_(size) _Pre_opt_valid_cap_x_(size) _Post_valid_
#define _Inout_bytecap_x_(size) _Pre_valid_bytecap_x_(size) _Post_valid_
#define _Inout_opt_bytecap_x_(size) _Pre_opt_valid_bytecap_x_(size) _Post_valid_

// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _Inout_z_cap_(size) _Pre_z_cap_(size) _Post_z_
#define _Inout_opt_z_cap_(size) _Pre_opt_z_cap_(size) _Post_z_
#define _Inout_z_bytecap_(size) _Pre_z_bytecap_(size) _Post_z_
#define _Inout_opt_z_bytecap_(size) _Pre_opt_z_bytecap_(size) _Post_z_

#define _Inout_z_cap_c_(size) _Pre_z_cap_c_(size) _Post_z_
#define _Inout_opt_z_cap_c_(size) _Pre_opt_z_cap_c_(size) _Post_z_
#define _Inout_z_bytecap_c_(size) _Pre_z_bytecap_c_(size) _Post_z_
#define _Inout_opt_z_bytecap_c_(size) _Pre_opt_z_bytecap_c_(size) _Post_z_

#define _Inout_z_cap_x_(size) _Pre_z_cap_x_(size) _Post_z_
#define _Inout_opt_z_cap_x_(size) _Pre_opt_z_cap_x_(size) _Post_z_
#define _Inout_z_bytecap_x_(size) _Pre_z_bytecap_x_(size) _Post_z_
#define _Inout_opt_z_bytecap_x_(size) _Pre_opt_z_bytecap_x_(size) _Post_z_

// return values -------------------------------

// returning pointers to valid objects
#define _Ret_ _Ret_valid_
#define _Ret_opt_ _Ret_opt_valid_

// More _Ret_ annotations are defined below

// Pointer to pointers -------------------------

// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );
#define _Deref_out_ _Out_ _Deref_pre_invalid_ _Deref_post_valid_
#define _Deref_out_opt_ _Out_ _Deref_pre_invalid_ _Deref_post_opt_valid_
#define _Deref_opt_out_ _Out_opt_ _Deref_pre_invalid_ _Deref_post_valid_
#define _Deref_opt_out_opt_ _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_valid_

// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );
#define _Deref_out_z_ _Out_ _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_out_opt_z_ _Out_ _Deref_pre_invalid_ _Deref_post_opt_z_
#define _Deref_opt_out_z_ _Out_opt_ _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_opt_out_opt_z_ _Out_opt_ _Deref_pre_invalid_ _Deref_post_opt_z_

// More _Deref_ annotations are defined below

// Other annotations

// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();
#define _Check_return_ _Check_return_impl_

// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );
#define _Printf_format_string_ _Printf_format_string_impl_
#define _Scanf_format_string_ _Scanf_format_string_impl_
#define _Scanf_s_format_string_ _Scanf_s_format_string_impl_
#define _FormatMessage_format_string_ 

// <expr> indicates whether post conditions apply
#define _Success_(expr) _Success_impl_(expr)

// annotations to express 'boundedness' of integral value parameter
#define _In_bound_ _In_bound_impl_
#define _Out_bound_ _Out_bound_impl_
#define _Ret_bound_ _Ret_bound_impl_
#define _Deref_in_bound_ _Deref_in_bound_impl_
#define _Deref_out_bound_ _Deref_out_bound_impl_
#define _Deref_inout_bound_ _Deref_in_bound_ _Deref_out_bound_
#define _Deref_ret_bound_ _Deref_ret_bound_impl_

// annotations to express upper and lower bounds of integral value parameter
#define _In_range_(lb,ub) _In_range_impl_(lb,ub)
#define _Out_range_(lb,ub) _Out_range_impl_(lb,ub)
#define _Ret_range_(lb,ub) _Ret_range_impl_(lb,ub)
#define _Deref_in_range_(lb,ub) _Deref_in_range_impl_(lb,ub)
#define _Deref_out_range_(lb,ub) _Deref_out_range_impl_(lb,ub)
#define _Deref_ret_range_(lb,ub) _Deref_ret_range_impl_(lb,ub)

//============================================================================
//   _Pre_\_Post_ Layer:
//============================================================================

//
// _Pre_ annotation ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string
#define _Pre_z_ _Pre2_impl_(_$notnull, _$zterm) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_ _Pre2_impl_(_$maybenull,_$zterm) _Deref_pre1_impl_(_$valid)

// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter
#define _Pre_cap_(size) _Pre2_impl_(_$notnull, _$cap(size))
#define _Pre_opt_cap_(size) _Pre2_impl_(_$maybenull,_$cap(size))
#define _Pre_bytecap_(size) _Pre2_impl_(_$notnull, _$bytecap(size))
#define _Pre_opt_bytecap_(size) _Pre2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity described by a constant expression
#define _Pre_cap_c_(size) _Pre2_impl_(_$notnull, _$cap_c(size))
#define _Pre_opt_cap_c_(size) _Pre2_impl_(_$maybenull,_$cap_c(size))
#define _Pre_bytecap_c_(size) _Pre2_impl_(_$notnull, _$bytecap_c(size))
#define _Pre_opt_bytecap_c_(size) _Pre2_impl_(_$maybenull,_$bytecap_c(size))

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Pre_cap_m_(mult,size) _Pre2_impl_(_$notnull, _$mult(mult,size))
#define _Pre_opt_cap_m_(mult,size) _Pre2_impl_(_$maybenull,_$mult(mult,size))

// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);
#define _Pre_cap_for_(param) _Pre2_impl_(_$notnull, _$cap_for(param))
#define _Pre_opt_cap_for_(param) _Pre2_impl_(_$maybenull,_$cap_for(param))

// buffer capacity described by a complex condition
#define _Pre_cap_x_(size) _Pre2_impl_(_$notnull, _$cap_x(size))
#define _Pre_opt_cap_x_(size) _Pre2_impl_(_$maybenull,_$cap_x(size))
#define _Pre_bytecap_x_(size) _Pre2_impl_(_$notnull, _$bytecap_x(size))
#define _Pre_opt_bytecap_x_(size) _Pre2_impl_(_$maybenull,_$bytecap_x(size))

// buffer capacity described by the difference to another pointer parameter
#define _Pre_ptrdiff_cap_(ptr) _Pre2_impl_(_$notnull, _$cap_x(__ptrdiff(ptr)))
#define _Pre_opt_ptrdiff_cap_(ptr) _Pre2_impl_(_$maybenull,_$cap_x(__ptrdiff(ptr)))

// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );
#define _Pre_z_cap_(size) _Pre3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_(size) _Pre3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_(size) _Pre3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_(size) _Pre3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_z_cap_c_(size) _Pre3_impl_(_$notnull, _$zterm,_$cap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_c_(size) _Pre3_impl_(_$maybenull,_$zterm,_$cap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_c_(size) _Pre3_impl_(_$notnull, _$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_c_(size) _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_z_cap_x_(size) _Pre3_impl_(_$notnull, _$zterm,_$cap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_cap_x_(size) _Pre3_impl_(_$maybenull,_$zterm,_$cap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_z_bytecap_x_(size) _Pre3_impl_(_$notnull, _$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_z_bytecap_x_(size) _Pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Pre_valid_cap_(size) _Pre2_impl_(_$notnull, _$cap(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_(size) _Pre2_impl_(_$maybenull,_$cap(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_(size) _Pre2_impl_(_$notnull, _$bytecap(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_(size) _Pre2_impl_(_$maybenull,_$bytecap(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_valid_cap_c_(size) _Pre2_impl_(_$notnull, _$cap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_c_(size) _Pre2_impl_(_$maybenull,_$cap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_c_(size) _Pre2_impl_(_$notnull, _$bytecap_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_c_(size) _Pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref_pre1_impl_(_$valid)

#define _Pre_valid_cap_x_(size) _Pre2_impl_(_$notnull, _$cap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_cap_x_(size) _Pre2_impl_(_$maybenull,_$cap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_valid_bytecap_x_(size) _Pre2_impl_(_$notnull, _$bytecap_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_bytecap_x_(size) _Pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref_pre1_impl_(_$valid)

// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter
#define _Pre_count_(size) _Pre2_impl_(_$notnull, _$count(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_(size) _Pre2_impl_(_$maybenull,_$count(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_(size) _Pre2_impl_(_$notnull, _$bytecount(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_(size) _Pre2_impl_(_$maybenull,_$bytecount(size)) _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by a constant expression
#define _Pre_count_c_(size) _Pre2_impl_(_$notnull, _$count_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_c_(size) _Pre2_impl_(_$maybenull,_$count_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_c_(size) _Pre2_impl_(_$notnull, _$bytecount_c(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_c_(size) _Pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by a complex expression
#define _Pre_count_x_(size) _Pre2_impl_(_$notnull, _$count_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_count_x_(size) _Pre2_impl_(_$maybenull,_$count_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_bytecount_x_(size) _Pre2_impl_(_$notnull, _$bytecount_x(size)) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_bytecount_x_(size) _Pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_pre1_impl_(_$valid)

// Valid buffer extent described by the difference to another pointer parameter
#define _Pre_ptrdiff_count_(ptr) _Pre2_impl_(_$notnull, _$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_ptrdiff_count_(ptr) _Pre2_impl_(_$maybenull,_$count_x(__ptrdiff(ptr))) _Deref_pre1_impl_(_$valid)

// valid size unknown or indicated by type (e.g.:LPSTR)
#define _Pre_valid_ _Pre1_impl_(_$notnull) _Deref_pre1_impl_(_$valid)
#define _Pre_opt_valid_ _Pre1_impl_(_$maybenull) _Deref_pre1_impl_(_$valid)

#define _Pre_invalid_ _Deref_pre1_impl_(_$notvalid)

// used with allocated but not yet initialized objects
#define _Pre_notnull_ _Pre1_impl_(_$notnull)
#define _Pre_maybenull_ _Pre1_impl_(_$maybenull)
#define _Pre_null_ _Pre1_impl_(_$null)

// restrict access rights
#define _Pre_readonly_ _Pre1_impl_(_$readaccess)
#define _Pre_writeonly_ _Pre1_impl_(_$writeaccess)
//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call
#define _Post_z_ _Post1_impl_(_$zterm) _Deref_post1_impl_(_$valid)

// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call
#define _Post_maybez_ _Post1_impl_(_$maybezterm)

// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );
#define _Post_cap_(size) _Post1_impl_(_$cap(size))
#define _Post_bytecap_(size) _Post1_impl_(_$bytecap(size))

// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );
#define _Post_count_(size) _Post1_impl_(_$count(size)) _Deref_post1_impl_(_$valid)
#define _Post_bytecount_(size) _Post1_impl_(_$bytecount(size)) _Deref_post1_impl_(_$valid)
#define _Post_count_c_(size) _Post1_impl_(_$count_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_bytecount_c_(size) _Post1_impl_(_$bytecount_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_count_x_(size) _Post1_impl_(_$count_x(size)) _Deref_post1_impl_(_$valid)
#define _Post_bytecount_x_(size) _Post1_impl_(_$bytecount_x(size)) _Deref_post1_impl_(_$valid)

// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );
#define _Post_z_count_(size) _Post2_impl_(_$zterm,_$count(size)) _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_(size) _Post2_impl_(_$zterm,_$bytecount(size)) _Deref_post1_impl_(_$valid)
#define _Post_z_count_c_(size) _Post2_impl_(_$zterm,_$count_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_c_(size) _Post2_impl_(_$zterm,_$bytecount_c(size)) _Deref_post1_impl_(_$valid)
#define _Post_z_count_x_(size) _Post2_impl_(_$zterm,_$count_x(size)) _Deref_post1_impl_(_$valid)
#define _Post_z_bytecount_x_(size) _Post2_impl_(_$zterm,_$bytecount_x(size)) _Deref_post1_impl_(_$valid)

// e.g. void free( _Post_ptr_invalid_ void* pv );
#define _Post_ptr_invalid_ _Post1_impl_(_$notvalid)

// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );
#define _Post_valid_ _Deref_post1_impl_(_$valid)
#define _Post_invalid_ _Deref_post1_impl_(_$notvalid)

// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );
#define _Post_notnull_ _Post1_impl_(_$notnull)

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const throw();
#define _Ret_z_ _Ret2_impl_(_$notnull, _$zterm) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_ _Ret2_impl_(_$maybenull,_$zterm) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter
#define _Ret_cap_(size) _Ret2_impl_(_$notnull, _$cap(size))
#define _Ret_opt_cap_(size) _Ret2_impl_(_$maybenull,_$cap(size))
#define _Ret_bytecap_(size) _Ret2_impl_(_$notnull, _$bytecap(size))
#define _Ret_opt_bytecap_(size) _Ret2_impl_(_$maybenull,_$bytecap(size))

// Buffer capacity is described by a constant expression
#define _Ret_cap_c_(size) _Ret2_impl_(_$notnull, _$cap_c(size))
#define _Ret_opt_cap_c_(size) _Ret2_impl_(_$maybenull,_$cap_c(size))
#define _Ret_bytecap_c_(size) _Ret2_impl_(_$notnull, _$bytecap_c(size))
#define _Ret_opt_bytecap_c_(size) _Ret2_impl_(_$maybenull,_$bytecap_c(size))

// Buffer capacity is described by a complex condition
#define _Ret_cap_x_(size) _Ret2_impl_(_$notnull, _$cap_x(size))
#define _Ret_opt_cap_x_(size) _Ret2_impl_(_$maybenull,_$cap_x(size))
#define _Ret_bytecap_x_(size) _Ret2_impl_(_$notnull, _$bytecap_x(size))
#define _Ret_opt_bytecap_x_(size) _Ret2_impl_(_$maybenull,_$bytecap_x(size))

// return value is nullterminated and capacity is given by another parameter
#define _Ret_z_cap_(size) _Ret3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_cap_(size) _Ret3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_z_bytecap_(size) _Ret3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_bytecap_(size) _Ret3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter
#define _Ret_count_(size) _Ret2_impl_(_$notnull, _$count(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_(size) _Ret2_impl_(_$maybenull,_$count(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_(size) _Ret2_impl_(_$notnull, _$bytecount(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_(size) _Ret2_impl_(_$maybenull,_$bytecount(size)) _Deref_ret1_impl_(_$valid)

// Valid Buffer extent is described by a constant expression
#define _Ret_count_c_(size) _Ret2_impl_(_$notnull, _$count_c(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_c_(size) _Ret2_impl_(_$maybenull,_$count_c(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_c_(size) _Ret2_impl_(_$notnull, _$bytecount_c(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_c_(size) _Ret2_impl_(_$maybenull,_$bytecount_c(size)) _Deref_ret1_impl_(_$valid)

// Valid Buffer extent is described by a complex expression
#define _Ret_count_x_(size) _Ret2_impl_(_$notnull, _$count_x(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_count_x_(size) _Ret2_impl_(_$maybenull,_$count_x(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_bytecount_x_(size) _Ret2_impl_(_$notnull, _$bytecount_x(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_bytecount_x_(size) _Ret2_impl_(_$maybenull,_$bytecount_x(size)) _Deref_ret1_impl_(_$valid)

// return value is nullterminated and length is given by another parameter
#define _Ret_z_count_(size) _Ret3_impl_(_$notnull, _$zterm,_$count(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_count_(size) _Ret3_impl_(_$maybenull,_$zterm,_$count(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_z_bytecount_(size) _Ret3_impl_(_$notnull, _$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_z_bytecount_(size) _Ret3_impl_(_$maybenull,_$zterm,_$bytecount(size)) _Deref_ret1_impl_(_$valid)

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );
#define _Ret_valid_ _Ret1_impl_(_$notnull) _Deref_ret1_impl_(_$valid)
#define _Ret_opt_valid_ _Ret1_impl_(_$maybenull) _Deref_ret1_impl_(_$valid)

// used with allocated but not yet initialized objects
#define _Ret_notnull_ _Ret1_impl_(_$notnull)
#define _Ret_maybenull_ _Ret1_impl_(_$maybenull)
#define _Ret_null_ _Ret1_impl_(_$null)

//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );
#define _Deref_pre_z_ _Deref_pre2_impl_(_$notnull, _$zterm) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_ _Deref_pre2_impl_(_$maybenull,_$zterm) _Deref2_pre1_impl_(_$valid)

// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter
#define _Deref_pre_cap_(size) _Deref_pre2_impl_(_$notnull, _$cap(size))
#define _Deref_pre_opt_cap_(size) _Deref_pre2_impl_(_$maybenull,_$cap(size))
#define _Deref_pre_bytecap_(size) _Deref_pre2_impl_(_$notnull, _$bytecap(size))
#define _Deref_pre_opt_bytecap_(size) _Deref_pre2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity is described by a constant expression
#define _Deref_pre_cap_c_(size) _Deref_pre2_impl_(_$notnull, _$cap_c(size))
#define _Deref_pre_opt_cap_c_(size) _Deref_pre2_impl_(_$maybenull,_$cap_c(size))
#define _Deref_pre_bytecap_c_(size) _Deref_pre2_impl_(_$notnull, _$bytecap_c(size))
#define _Deref_pre_opt_bytecap_c_(size) _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size))

// buffer capacity is described by a complex condition
#define _Deref_pre_cap_x_(size) _Deref_pre2_impl_(_$notnull, _$cap_x(size))
#define _Deref_pre_opt_cap_x_(size) _Deref_pre2_impl_(_$maybenull,_$cap_x(size))
#define _Deref_pre_bytecap_x_(size) _Deref_pre2_impl_(_$notnull, _$bytecap_x(size))
#define _Deref_pre_opt_bytecap_x_(size) _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_pre_z_cap_(size) _Deref_pre3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_(size) _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_(size) _Deref_pre3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_(size) _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_z_cap_c_(size) _Deref_pre3_impl_(_$notnull, _$zterm,_$cap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_c_(size) _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_c_(size) _Deref_pre3_impl_(_$notnull, _$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_c_(size) _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_z_cap_x_(size) _Deref_pre3_impl_(_$notnull, _$zterm,_$cap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_cap_x_(size) _Deref_pre3_impl_(_$maybenull,_$zterm,_$cap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_z_bytecap_x_(size) _Deref_pre3_impl_(_$notnull, _$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_z_bytecap_x_(size) _Deref_pre3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Deref_pre_valid_cap_(size) _Deref_pre2_impl_(_$notnull, _$cap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_(size) _Deref_pre2_impl_(_$maybenull,_$cap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_(size) _Deref_pre2_impl_(_$notnull, _$bytecap(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_(size) _Deref_pre2_impl_(_$maybenull,_$bytecap(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_valid_cap_c_(size) _Deref_pre2_impl_(_$notnull, _$cap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_c_(size) _Deref_pre2_impl_(_$maybenull,_$cap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_c_(size) _Deref_pre2_impl_(_$notnull, _$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_c_(size) _Deref_pre2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_pre1_impl_(_$valid)

#define _Deref_pre_valid_cap_x_(size) _Deref_pre2_impl_(_$notnull, _$cap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_cap_x_(size) _Deref_pre2_impl_(_$maybenull,_$cap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_valid_bytecap_x_(size) _Deref_pre2_impl_(_$notnull, _$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_bytecap_x_(size) _Deref_pre2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_pre1_impl_(_$valid)

// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n ); 
// valid buffer extent is described by another parameter
#define _Deref_pre_count_(size) _Deref_pre2_impl_(_$notnull, _$count(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_(size) _Deref_pre2_impl_(_$maybenull,_$count(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_(size) _Deref_pre2_impl_(_$notnull, _$bytecount(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_(size) _Deref_pre2_impl_(_$maybenull,_$bytecount(size)) _Deref2_pre1_impl_(_$valid)

// valid buffer extent is described by a constant expression
#define _Deref_pre_count_c_(size) _Deref_pre2_impl_(_$notnull, _$count_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_c_(size) _Deref_pre2_impl_(_$maybenull,_$count_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_c_(size) _Deref_pre2_impl_(_$notnull, _$bytecount_c(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_c_(size) _Deref_pre2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_pre1_impl_(_$valid)

// valid buffer extent is described by a complex expression
#define _Deref_pre_count_x_(size) _Deref_pre2_impl_(_$notnull, _$count_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_count_x_(size) _Deref_pre2_impl_(_$maybenull,_$count_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_bytecount_x_(size) _Deref_pre2_impl_(_$notnull, _$bytecount_x(size)) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_bytecount_x_(size) _Deref_pre2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_pre1_impl_(_$valid)

// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );
#define _Deref_pre_valid_ _Deref_pre1_impl_(_$notnull) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_opt_valid_ _Deref_pre1_impl_(_$maybenull) _Deref2_pre1_impl_(_$valid)
#define _Deref_pre_invalid_ _Deref2_pre1_impl_(_$notvalid)

#define _Deref_pre_notnull_ _Deref_pre1_impl_(_$notnull)
#define _Deref_pre_maybenull_ _Deref_pre1_impl_(_$maybenull)
#define _Deref_pre_null_ _Deref_pre1_impl_(_$null)

// restrict access rights
#define _Deref_pre_readonly_ _Deref_pre1_impl_(_$readaccess)
#define _Deref_pre_writeonly_ _Deref_pre1_impl_(_$writeaccess)

//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );
#define _Deref_post_z_ _Deref_post2_impl_(_$notnull, _$zterm) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_ _Deref_post2_impl_(_$maybenull,_$zterm) _Deref2_post1_impl_(_$valid)

// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter
#define _Deref_post_cap_(size) _Deref_post2_impl_(_$notnull, _$cap(size))
#define _Deref_post_opt_cap_(size) _Deref_post2_impl_(_$maybenull,_$cap(size))
#define _Deref_post_bytecap_(size) _Deref_post2_impl_(_$notnull, _$bytecap(size))
#define _Deref_post_opt_bytecap_(size) _Deref_post2_impl_(_$maybenull,_$bytecap(size))

// buffer capacity is described by a constant expression
#define _Deref_post_cap_c_(size) _Deref_post2_impl_(_$notnull, _$cap_z(size))
#define _Deref_post_opt_cap_c_(size) _Deref_post2_impl_(_$maybenull,_$cap_z(size))
#define _Deref_post_bytecap_c_(size) _Deref_post2_impl_(_$notnull, _$bytecap_z(size))
#define _Deref_post_opt_bytecap_c_(size) _Deref_post2_impl_(_$maybenull,_$bytecap_z(size))

// buffer capacity is described by a complex expression
#define _Deref_post_cap_x_(size) _Deref_post2_impl_(_$notnull, _$cap_x(size))
#define _Deref_post_opt_cap_x_(size) _Deref_post2_impl_(_$maybenull,_$cap_x(size))
#define _Deref_post_bytecap_x_(size) _Deref_post2_impl_(_$notnull, _$bytecap_x(size))
#define _Deref_post_opt_bytecap_x_(size) _Deref_post2_impl_(_$maybenull,_$bytecap_x(size))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_post_z_cap_(size) _Deref_post3_impl_(_$notnull, _$zterm,_$cap(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_(size) _Deref_post3_impl_(_$maybenull,_$zterm,_$cap(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_(size) _Deref_post3_impl_(_$notnull, _$zterm,_$bytecap(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_(size) _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap(size)) _Deref2_post1_impl_(_$valid)

#define _Deref_post_z_cap_c_(size) _Deref_post3_impl_(_$notnull, _$zterm,_$cap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_c_(size) _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_c_(size) _Deref_post3_impl_(_$notnull, _$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_c_(size) _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)

#define _Deref_post_z_cap_x_(size) _Deref_post3_impl_(_$notnull, _$zterm,_$cap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_cap_x_(size) _Deref_post3_impl_(_$maybenull,_$zterm,_$cap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_z_bytecap_x_(size) _Deref_post3_impl_(_$notnull, _$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_z_bytecap_x_(size) _Deref_post3_impl_(_$maybenull,_$zterm,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)

// known capacity and valid but unknown readable extent
#define _Deref_post_valid_cap_(size) _Deref_post2_impl_(_$notnull, _$cap(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_(size) _Deref_post2_impl_(_$maybenull,_$cap(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_(size) _Deref_post2_impl_(_$notnull, _$bytecap(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_(size) _Deref_post2_impl_(_$maybenull,_$bytecap(size)) _Deref2_post1_impl_(_$valid)

#define _Deref_post_valid_cap_c_(size) _Deref_post2_impl_(_$notnull, _$cap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_c_(size) _Deref_post2_impl_(_$maybenull,_$cap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_c_(size) _Deref_post2_impl_(_$notnull, _$bytecap_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_c_(size) _Deref_post2_impl_(_$maybenull,_$bytecap_c(size)) _Deref2_post1_impl_(_$valid)

#define _Deref_post_valid_cap_x_(size) _Deref_post2_impl_(_$notnull, _$cap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_cap_x_(size) _Deref_post2_impl_(_$maybenull,_$cap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_valid_bytecap_x_(size) _Deref_post2_impl_(_$notnull, _$bytecap_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_bytecap_x_(size) _Deref_post2_impl_(_$maybenull,_$bytecap_x(size)) _Deref2_post1_impl_(_$valid)

// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter
#define _Deref_post_count_(size) _Deref_post2_impl_(_$notnull, _$count(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_(size) _Deref_post2_impl_(_$maybenull,_$count(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_(size) _Deref_post2_impl_(_$notnull, _$bytecount(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_(size) _Deref_post2_impl_(_$maybenull,_$bytecount(size)) _Deref2_post1_impl_(_$valid)

// buffer capacity is described by a constant expression
#define _Deref_post_count_c_(size) _Deref_post2_impl_(_$notnull, _$count_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_c_(size) _Deref_post2_impl_(_$maybenull,_$count_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_c_(size) _Deref_post2_impl_(_$notnull, _$bytecount_c(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_c_(size) _Deref_post2_impl_(_$maybenull,_$bytecount_c(size)) _Deref2_post1_impl_(_$valid)

// buffer capacity is described by a complex expression
#define _Deref_post_count_x_(size) _Deref_post2_impl_(_$notnull, _$count_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_count_x_(size) _Deref_post2_impl_(_$maybenull,_$count_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_bytecount_x_(size) _Deref_post2_impl_(_$notnull, _$bytecount_x(size)) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_bytecount_x_(size) _Deref_post2_impl_(_$maybenull,_$bytecount_x(size)) _Deref2_post1_impl_(_$valid)

// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );
#define _Deref_post_valid_ _Deref_post1_impl_(_$notnull) _Deref2_post1_impl_(_$valid)
#define _Deref_post_opt_valid_ _Deref_post1_impl_(_$maybenull) _Deref2_post1_impl_(_$valid)

#define _Deref_post_notnull_ _Deref_post1_impl_(_$notnull)
#define _Deref_post_maybenull_ _Deref_post1_impl_(_$maybenull)
#define _Deref_post_null_ _Deref_post1_impl_(_$null)

//
// _Deref_ret_ ---
//

#define _Deref_ret_z_ _Deref_ret2_impl_(_$notnull, _$zterm)
#define _Deref_ret_opt_z_ _Deref_ret2_impl_(_$maybenull,_$zterm)

//
// special _Deref_ ---
//
#define _Deref2_pre_readonly_ _Deref2_pre1_impl_(_$readaccess)

// Convenience macros for more concise annotations

//
// _Pre_post ---
//
// describing conditions that hold before and after the function call

#define _Prepost_z_ _Pre_z_ _Post_z_
#define _Prepost_opt_z_ _Pre_opt_z_ _Post_z_

#define _Prepost_count_(size) _Pre_count_(size) _Post_count_(size)
#define _Prepost_opt_count_(size) _Pre_opt_count_(size) _Post_count_(size)
#define _Prepost_bytecount_(size) _Pre_bytecount_(size) _Post_bytecount_(size)
#define _Prepost_opt_bytecount_(size) _Pre_opt_bytecount_(size) _Post_bytecount_(size)
#define _Prepost_count_c_(size) _Pre_count_c_(size) _Post_count_c_(size)
#define _Prepost_opt_count_c_(size) _Pre_opt_count_c_(size) _Post_count_c_(size)
#define _Prepost_bytecount_c_(size) _Pre_bytecount_c_(size) _Post_bytecount_c_(size)
#define _Prepost_opt_bytecount_c_(size) _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size)
#define _Prepost_count_x_(size) _Pre_count_x_(size) _Post_count_x_(size)
#define _Prepost_opt_count_x_(size) _Pre_opt_count_x_(size) _Post_count_x_(size)
#define _Prepost_bytecount_x_(size) _Pre_bytecount_x_(size) _Post_bytecount_x_(size)
#define _Prepost_opt_bytecount_x_(size) _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size)

#define _Prepost_valid_ _Pre_valid_ _Post_valid_
#define _Prepost_opt_valid_ _Pre_opt_valid_ _Post_valid_

//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call

#define _Deref_prepost_z_ _Deref_pre_z_ _Deref_post_z_
#define _Deref_prepost_opt_z_ _Deref_pre_opt_z_ _Deref_post_opt_z_

#define _Deref_prepost_cap_(size) _Deref_pre_cap_(size) _Deref_post_cap_(size)
#define _Deref_prepost_opt_cap_(size) _Deref_pre_opt_cap_(size) _Deref_post_opt_cap_(size)
#define _Deref_prepost_bytecap_(size) _Deref_pre_bytecap_(size) _Deref_post_bytecap_(size)
#define _Deref_prepost_opt_bytecap_(size) _Deref_pre_opt_bytecap_(size) _Deref_post_opt_bytecap_(size)

#define _Deref_prepost_cap_x_(size) _Deref_pre_cap_x_(size) _Deref_post_cap_x_(size)
#define _Deref_prepost_opt_cap_x_(size) _Deref_pre_opt_cap_x_(size) _Deref_post_opt_cap_x_(size)
#define _Deref_prepost_bytecap_x_(size) _Deref_pre_bytecap_x_(size) _Deref_post_bytecap_x_(size)
#define _Deref_prepost_opt_bytecap_x_(size) _Deref_pre_opt_bytecap_x_(size) _Deref_post_opt_bytecap_x_(size)

#define _Deref_prepost_z_cap_(size) _Deref_pre_z_cap_(size) _Deref_post_z_cap_(size)
#define _Deref_prepost_opt_z_cap_(size) _Deref_pre_opt_z_cap_(size) _Deref_post_opt_z_cap_(size)
#define _Deref_prepost_z_bytecap_(size) _Deref_pre_z_bytecap_(size) _Deref_post_z_bytecap_(size)
#define _Deref_prepost_opt_z_bytecap_(size) _Deref_pre_opt_z_bytecap_(size) _Deref_post_opt_z_bytecap_(size)

#define _Deref_prepost_valid_cap_(size) _Deref_pre_valid_cap_(size) _Deref_post_valid_cap_(size)
#define _Deref_prepost_opt_valid_cap_(size) _Deref_pre_opt_valid_cap_(size) _Deref_post_opt_valid_cap_(size)
#define _Deref_prepost_valid_bytecap_(size) _Deref_pre_valid_bytecap_(size) _Deref_post_valid_bytecap_(size)
#define _Deref_prepost_opt_valid_bytecap_(size) _Deref_pre_opt_valid_bytecap_(size) _Deref_post_opt_valid_bytecap_(size)

#define _Deref_prepost_valid_cap_x_(size) _Deref_pre_valid_cap_x_(size) _Deref_post_valid_cap_x_(size)
#define _Deref_prepost_opt_valid_cap_x_(size) _Deref_pre_opt_valid_cap_x_(size) _Deref_post_opt_valid_cap_x_(size)
#define _Deref_prepost_valid_bytecap_x_(size) _Deref_pre_valid_bytecap_x_(size) _Deref_post_valid_bytecap_x_(size)
#define _Deref_prepost_opt_valid_bytecap_x_(size) _Deref_pre_opt_valid_bytecap_x_(size) _Deref_post_opt_valid_bytecap_x_(size)

#define _Deref_prepost_count_(size) _Deref_pre_count_(size) _Deref_post_count_(size)
#define _Deref_prepost_opt_count_(size) _Deref_pre_opt_count_(size) _Deref_post_opt_count_(size)
#define _Deref_prepost_bytecount_(size) _Deref_pre_bytecount_(size) _Deref_post_bytecount_(size)
#define _Deref_prepost_opt_bytecount_(size) _Deref_pre_opt_bytecount_(size) _Deref_post_opt_bytecount_(size)

#define _Deref_prepost_count_x_(size) _Deref_pre_count_x_(size) _Deref_post_count_x_(size)
#define _Deref_prepost_opt_count_x_(size) _Deref_pre_opt_count_x_(size) _Deref_post_opt_count_x_(size)
#define _Deref_prepost_bytecount_x_(size) _Deref_pre_bytecount_x_(size) _Deref_post_bytecount_x_(size)
#define _Deref_prepost_opt_bytecount_x_(size) _Deref_pre_opt_bytecount_x_(size) _Deref_post_opt_bytecount_x_(size)

#define _Deref_prepost_valid_ _Deref_pre_valid_ _Deref_post_valid_
#define _Deref_prepost_opt_valid_ _Deref_pre_opt_valid_ _Deref_post_opt_valid_

//
// _Deref_<miscellaneous>
//
// used with references to arrays

#define _Deref_out_z_cap_c_(size) _Deref_pre_cap_c_(size) _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_inout_z_cap_c_(size) _Deref_pre_z_cap_c_(size) _Deref_post_z_
#define _Deref_out_z_bytecap_c_(size) _Deref_pre_bytecap_c_(size) _Deref_pre_invalid_ _Deref_post_z_
#define _Deref_inout_z_bytecap_c_(size) _Deref_pre_z_bytecap_c_(size) _Deref_post_z_
#define _Deref_inout_z_ _Deref_prepost_z_

//============================================================================
//   Implementation Layer:
//============================================================================
# 1231 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
#define _Check_return_impl_ 

#define _Success_impl_(expr) 

#define _Printf_format_string_impl_ 
#define _Scanf_format_string_impl_ 
#define _Scanf_s_format_string_impl_ 

#define _In_bound_impl_ 
#define _Out_bound_impl_ 
#define _Ret_bound_impl_ 
#define _Deref_in_bound_impl_ 
#define _Deref_out_bound_impl_ 
#define _Deref_ret_bound_impl_ 

#define _In_range_impl_(min,max) 
#define _Out_range_impl_(min,max) 
#define _Ret_range_impl_(min,max) 
#define _Deref_in_range_impl_(min,max) 
#define _Deref_out_range_impl_(min,max) 
#define _Deref_ret_range_impl_(min,max) 

#define _Pre1_impl_(p1) 
#define _Pre2_impl_(p1,p2) 
#define _Pre3_impl_(p1,p2,p3) 

#define _Post1_impl_(p1) 
#define _Post2_impl_(p1,p2) 
#define _Post3_impl_(p1,p2,p3) 

#define _Ret1_impl_(p1) 
#define _Ret2_impl_(p1,p2) 
#define _Ret3_impl_(p1,p2,p3) 

#define _Deref_pre1_impl_(p1) 
#define _Deref_pre2_impl_(p1,p2) 
#define _Deref_pre3_impl_(p1,p2,p3) 

#define _Deref_post1_impl_(p1) 
#define _Deref_post2_impl_(p1,p2) 
#define _Deref_post3_impl_(p1,p2,p3) 

#define _Deref_ret1_impl_(p1) 
#define _Deref_ret2_impl_(p1,p2) 
#define _Deref_ret3_impl_(p1,p2,p3) 

#define _Deref2_pre1_impl_(p1) 
#define _Deref2_post1_impl_(p1) 
#define _Deref2_ret1_impl_(p1) 



// This section contains the deprecated annotations

/* 

 -------------------------------------------------------------------------------

 Introduction



 sal.h provides a set of annotations to describe how a function uses its

 parameters - the assumptions it makes about them, and the guarantees it makes

 upon finishing.



 Annotations may be placed before either a function parameter's type or its return

 type, and describe the function's behavior regarding the parameter or return value.

 There are two classes of annotations: buffer annotations and advanced annotations.

 Buffer annotations describe how functions use their pointer parameters, and

 advanced annotations either describe complex/unusual buffer behavior, or provide

 additional information about a parameter that is not otherwise expressible.



 -------------------------------------------------------------------------------

 Buffer Annotations



 The most important annotations in sal.h provide a consistent way to annotate

 buffer parameters or return values for a function. Each of these annotations describes

 a single buffer (which could be a string, a fixed-length or variable-length array,

 or just a pointer) that the function interacts with: where it is, how large it is,

 how much is initialized, and what the function does with it.



 The appropriate macro for a given buffer can be constructed using the table below.

 Just pick the appropriate values from each category, and combine them together

 with a leading underscore. Some combinations of values do not make sense as buffer

 annotations. Only meaningful annotations can be added to your code; for a list of

 these, see the buffer annotation definitions section.



 Only a single buffer annotation should be used for each parameter.



 |------------|------------|---------|--------|----------|----------|---------------|

 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |

 |------------|------------|---------|--------|----------|----------|---------------|

 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |

 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |

 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |

 |            | _inout     |         |        |          |          |               |

 |            |            |         |        |          |          |               |

 |------------|------------|---------|--------|----------|----------|---------------|



 Level: Describes the buffer pointer's level of indirection from the parameter or

          return value 'p'.



 <>         : p is the buffer pointer.

 _deref     : *p is the buffer pointer. p must not be NULL.

 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of

                the annotation is ignored.



 Usage: Describes how the function uses the buffer.



 <>     : The buffer is not accessed. If used on the return value or with _deref, the

            function will provide the buffer, and it will be uninitialized at exit.

            Otherwise, the caller must provide the buffer. This should only be used

            for alloc and free functions.

 _in    : The function will only read from the buffer. The caller must provide the

            buffer and initialize it. Cannot be used with _deref.

 _out   : The function will only write to the buffer. If used on the return value or

            with _deref, the function will provide the buffer and initialize it.

            Otherwise, the caller must provide the buffer, and the function will

            initialize it.

 _inout : The function may freely read from and write to the buffer. The caller must

            provide the buffer and initialize it. If used with _deref, the buffer may

            be reallocated by the function.



 Size: Describes the total size of the buffer. This may be less than the space actually

         allocated for the buffer, in which case it describes the accessible amount.



 <>      : No buffer size is given. If the type specifies the buffer size (such as

             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one

             element long. Must be used with _in, _out, or _inout.

 _ecount : The buffer size is an explicit element count.

 _bcount : The buffer size is an explicit byte count.



 Output: Describes how much of the buffer will be initialized by the function. For

           _inout buffers, this also describes how much is initialized at entry. Omit this

           category for _in buffers; they must be fully initialized by the caller.



 <>    : The type specifies how much is initialized. For instance, a function initializing

           an LPWSTR must NULL-terminate the string.

 _full : The function initializes the entire buffer.

 _part : The function initializes part of the buffer, and explicitly indicates how much.



 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.

 _z    : A '\0' indicated the end of the buffer

 _nz	 : The buffer may not be null terminated and a '\0' does not indicate the end of the

          buffer.

 Optional: Describes if the buffer itself is optional.



 <>   : The pointer to the buffer must not be NULL.

 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.



 Parameters: Gives explicit counts for the size and length of the buffer.



 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.

 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.

 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part

                   and _bcount_part.



 -------------------------------------------------------------------------------

 Buffer Annotation Examples



 LWSTDAPI_(BOOL) StrToIntExA(

     LPCSTR pszString,                    -- No annotation required, const implies __in.

     DWORD dwFlags,

     __out int *piRet                     -- A pointer whose dereference will be filled in.

 );



 void MyPaintingFunction(

     __in HWND hwndControl,               -- An initialized read-only parameter.

     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.

     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used

                                          --   and modified.

 );



 LWSTDAPI_(BOOL) PathCompactPathExA(

     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will

                                          --   be NULL terminated on exit.

     LPCSTR pszSrc,                       -- No annotation required, const implies __in.

     UINT cchMax,

     DWORD dwFlags

 );



 HRESULT SHLocalAllocBytes(

     size_t cb,

     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an

                                          --   uninitialized buffer with cb bytes.

 );



 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at

     entry and exit, and may be written to by this function.



 __out_ecount_part(count, *countOut) : A buffer with count elements that will be

     partially initialized by this function. The function indicates how much it

     initialized by setting *countOut.



 -------------------------------------------------------------------------------

 Advanced Annotations



 Advanced annotations describe behavior that is not expressible with the regular

 buffer macros. These may be used either to annotate buffer parameters that involve

 complex or conditional behavior, or to enrich existing annotations with additional

 information.



 __success(expr) f :

     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,

     all the function's guarantees (as given by other annotations) must hold. If <expr>

     is false at exit, the caller should not expect any of the function's guarantees

     to hold. If not used, the function must always satisfy its guarantees. Added

     automatically to functions that indicate success in standard ways, such as by

     returning an HRESULT.



 __nullterminated p :

     Pointer p is a buffer that may be read or written up to and including the first

     NULL character or pointer. May be used on typedefs, which marks valid (properly

     initialized) instances of that type as being NULL-terminated.



 __nullnullterminated p :

     Pointer p is a buffer that may be read or written up to and including the first

     sequence of two NULL characters or pointers. May be used on typedefs, which marks

     valid instances of that type as being double-NULL terminated.



 __reserved v :

     Value v must be 0/NULL, reserved for future use.



 __checkReturn v :

     Return value v must not be ignored by callers of this function.



 __typefix(ctype) v :

     Value v should be treated as an instance of ctype, rather than its declared type.



 __override f :

     Specify C#-style 'override' behaviour for overriding virtual methods.



 __callback f :

     Function f can be used as a function pointer.



 __format_string p :

     Pointer p is a string that contains % markers in the style of printf.



 __blocksOn(resource) f :

     Function f blocks on the resource 'resource'.



 __fallthrough :

     Annotates switch statement labels where fall-through is desired, to distinguish

     from forgotten break statements.



 -------------------------------------------------------------------------------

 Advanced Annotation Examples



 __success(return == TRUE) LWSTDAPI_(BOOL) 

 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :

    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.



 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.



 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be

     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.



 -------------------------------------------------------------------------------

*/
# 1488 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
#define __specstrings 
# 1497 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
#define __nothrow 




/*

 -------------------------------------------------------------------------------

 Helper Macro Definitions



 These express behavior common to many of the high-level annotations.

 DO NOT USE THESE IN YOUR CODE.

 -------------------------------------------------------------------------------

*/
# 1511 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
/*

The helper annotations are only understood by the compiler version used by various

defect detection tools. When the regular compiler is running, they are defined into

nothing, and do not affect the compiled code.

*/
# 1721 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
#define __null 
#define __notnull 
#define __maybenull 
#define __readonly 
#define __notreadonly 
#define __maybereadonly 
#define __valid 
#define __notvalid 
#define __maybevalid 
#define __readableTo(extent) 
#define __elem_readableTo(size) 
#define __byte_readableTo(size) 
#define __writableTo(size) 
#define __elem_writableTo(size) 
#define __byte_writableTo(size) 
#define __deref 
#define __pre 
#define __post 
#define __precond(expr) 
#define __postcond(expr) 
#define __exceptthat 
#define __execeptthat 
#define __inner_success(expr) 
#define __inner_checkReturn 
#define __inner_typefix(ctype) 
#define __inner_override 
#define __inner_callback 
#define __inner_blocksOn(resource) 
#define __inner_fallthrough_dec 
#define __inner_fallthrough 
#define __refparam 
#define __inner_control_entrypoint(category) 
#define __inner_data_entrypoint(category) 


/* 

-------------------------------------------------------------------------------

Buffer Annotation Definitions



Any of these may be used to directly annotate functions, but only one should

be used for each parameter. To determine which annotation to use for a given

buffer, use the table in the buffer annotations section.

-------------------------------------------------------------------------------

*/
# 1766 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
#define __ecount(size) __notnull __elem_writableTo(size)
#define __bcount(size) __notnull __byte_writableTo(size)
#define __in __pre __valid __pre __deref __readonly
#define __in_ecount(size) __in __pre __elem_readableTo(size)
#define __in_bcount(size) __in __pre __byte_readableTo(size)
#define __in_z __in __pre __nullterminated
#define __in_ecount_z(size) __in_ecount(size) __pre __nullterminated
#define __in_bcount_z(size) __in_bcount(size) __pre __nullterminated
#define __in_nz __in
#define __in_ecount_nz(size) __in_ecount(size)
#define __in_bcount_nz(size) __in_bcount(size)
#define __out __ecount(1) __post __valid __refparam
#define __out_ecount(size) __ecount(size) __post __valid __refparam
#define __out_bcount(size) __bcount(size) __post __valid __refparam
#define __out_ecount_part(size,length) __out_ecount(size) __post __elem_readableTo(length)
#define __out_bcount_part(size,length) __out_bcount(size) __post __byte_readableTo(length)
#define __out_ecount_full(size) __out_ecount_part(size,size)
#define __out_bcount_full(size) __out_bcount_part(size,size)
#define __out_z __post __valid __refparam __post __nullterminated
#define __out_z_opt __post __valid __refparam __post __nullterminated __exceptthat __maybenull
#define __out_ecount_z(size) __ecount(size) __post __valid __refparam __post __nullterminated
#define __out_bcount_z(size) __bcount(size) __post __valid __refparam __post __nullterminated
#define __out_ecount_part_z(size,length) __out_ecount_part(size,length) __post __nullterminated
#define __out_bcount_part_z(size,length) __out_bcount_part(size,length) __post __nullterminated
#define __out_ecount_full_z(size) __out_ecount_full(size) __post __nullterminated
#define __out_bcount_full_z(size) __out_bcount_full(size) __post __nullterminated
#define __out_nz __post __valid __refparam __post
#define __out_nz_opt __post __valid __refparam __post __exceptthat __maybenull
#define __out_ecount_nz(size) __ecount(size) __post __valid __refparam
#define __out_bcount_nz(size) __bcount(size) __post __valid __refparam
#define __inout __pre __valid __post __valid __refparam
#define __inout_ecount(size) __out_ecount(size) __pre __valid
#define __inout_bcount(size) __out_bcount(size) __pre __valid
#define __inout_ecount_part(size,length) __out_ecount_part(size,length) __pre __valid __pre __elem_readableTo(length)
#define __inout_bcount_part(size,length) __out_bcount_part(size,length) __pre __valid __pre __byte_readableTo(length)
#define __inout_ecount_full(size) __inout_ecount_part(size,size)
#define __inout_bcount_full(size) __inout_bcount_part(size,size)
#define __inout_z __inout __pre __nullterminated __post __nullterminated
#define __inout_ecount_z(size) __inout_ecount(size) __pre __nullterminated __post __nullterminated
#define __inout_bcount_z(size) __inout_bcount(size) __pre __nullterminated __post __nullterminated
#define __inout_nz __inout
#define __inout_ecount_nz(size) __inout_ecount(size)
#define __inout_bcount_nz(size) __inout_bcount(size)
#define __ecount_opt(size) __ecount(size) __exceptthat __maybenull
#define __bcount_opt(size) __bcount(size) __exceptthat __maybenull
#define __in_opt __in __exceptthat __maybenull
#define __in_ecount_opt(size) __in_ecount(size) __exceptthat __maybenull
#define __in_bcount_opt(size) __in_bcount(size) __exceptthat __maybenull
#define __in_z_opt __in_opt __pre __nullterminated
#define __in_ecount_z_opt(size) __in_ecount_opt(size) __pre __nullterminated
#define __in_bcount_z_opt(size) __in_bcount_opt(size) __pre __nullterminated
#define __in_nz_opt __in_opt
#define __in_ecount_nz_opt(size) __in_ecount_opt(size)
#define __in_bcount_nz_opt(size) __in_bcount_opt(size)
#define __out_opt __out __exceptthat __maybenull
#define __out_ecount_opt(size) __out_ecount(size) __exceptthat __maybenull
#define __out_bcount_opt(size) __out_bcount(size) __exceptthat __maybenull
#define __out_ecount_part_opt(size,length) __out_ecount_part(size,length) __exceptthat __maybenull
#define __out_bcount_part_opt(size,length) __out_bcount_part(size,length) __exceptthat __maybenull
#define __out_ecount_full_opt(size) __out_ecount_full(size) __exceptthat __maybenull
#define __out_bcount_full_opt(size) __out_bcount_full(size) __exceptthat __maybenull
#define __out_ecount_z_opt(size) __out_ecount_opt(size) __post __nullterminated
#define __out_bcount_z_opt(size) __out_bcount_opt(size) __post __nullterminated
#define __out_ecount_part_z_opt(size,length) __out_ecount_part_opt(size,length) __post __nullterminated
#define __out_bcount_part_z_opt(size,length) __out_bcount_part_opt(size,length) __post __nullterminated
#define __out_ecount_full_z_opt(size) __out_ecount_full_opt(size) __post __nullterminated
#define __out_bcount_full_z_opt(size) __out_bcount_full_opt(size) __post __nullterminated
#define __out_ecount_nz_opt(size) __out_ecount_opt(size) __post __nullterminated
#define __out_bcount_nz_opt(size) __out_bcount_opt(size) __post __nullterminated
#define __inout_opt __inout __exceptthat __maybenull
#define __inout_ecount_opt(size) __inout_ecount(size) __exceptthat __maybenull
#define __inout_bcount_opt(size) __inout_bcount(size) __exceptthat __maybenull
#define __inout_ecount_part_opt(size,length) __inout_ecount_part(size,length) __exceptthat __maybenull
#define __inout_bcount_part_opt(size,length) __inout_bcount_part(size,length) __exceptthat __maybenull
#define __inout_ecount_full_opt(size) __inout_ecount_full(size) __exceptthat __maybenull
#define __inout_bcount_full_opt(size) __inout_bcount_full(size) __exceptthat __maybenull
#define __inout_z_opt __inout_opt __pre __nullterminated __post __nullterminated
#define __inout_ecount_z_opt(size) __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated
#define __inout_ecount_z_opt(size) __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated
#define __inout_bcount_z_opt(size) __inout_bcount_opt(size)
#define __inout_nz_opt __inout_opt
#define __inout_ecount_nz_opt(size) __inout_ecount_opt(size)
#define __inout_bcount_nz_opt(size) __inout_bcount_opt(size)
#define __deref_ecount(size) __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __elem_writableTo(size)
#define __deref_bcount(size) __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __byte_writableTo(size)
#define __deref_out __deref_ecount(1) __post __deref __valid __refparam
#define __deref_out_ecount(size) __deref_ecount(size) __post __deref __valid __refparam
#define __deref_out_bcount(size) __deref_bcount(size) __post __deref __valid __refparam
#define __deref_out_ecount_part(size,length) __deref_out_ecount(size) __post __deref __elem_readableTo(length)
#define __deref_out_bcount_part(size,length) __deref_out_bcount(size) __post __deref __byte_readableTo(length)
#define __deref_out_ecount_full(size) __deref_out_ecount_part(size,size)
#define __deref_out_bcount_full(size) __deref_out_bcount_part(size,size)
#define __deref_out_z __post __deref __valid __refparam __post __deref __nullterminated
#define __deref_out_ecount_z(size) __deref_out_ecount(size) __post __deref __nullterminated
#define __deref_out_bcount_z(size) __deref_out_ecount(size) __post __deref __nullterminated
#define __deref_out_nz __deref_out
#define __deref_out_ecount_nz(size) __deref_out_ecount(size)
#define __deref_out_bcount_nz(size) __deref_out_ecount(size)
#define __deref_inout __notnull __elem_readableTo(1) __pre __deref __valid __post __deref __valid __refparam
#define __deref_inout_z __deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount(size) __deref_inout __pre __deref __elem_writableTo(size) __post __deref __elem_writableTo(size)
#define __deref_inout_bcount(size) __deref_inout __pre __deref __byte_writableTo(size) __post __deref __byte_writableTo(size)
#define __deref_inout_ecount_part(size,length) __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length)
#define __deref_inout_bcount_part(size,length) __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length)
#define __deref_inout_ecount_full(size) __deref_inout_ecount_part(size,size)
#define __deref_inout_bcount_full(size) __deref_inout_bcount_part(size,size)
#define __deref_inout_z __deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount_z(size) __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_bcount_z(size) __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_nz __deref_inout
#define __deref_inout_ecount_nz(size) __deref_inout_ecount(size)
#define __deref_inout_bcount_nz(size) __deref_inout_ecount(size)
#define __deref_ecount_opt(size) __deref_ecount(size) __post __deref __exceptthat __maybenull
#define __deref_bcount_opt(size) __deref_bcount(size) __post __deref __exceptthat __maybenull
#define __deref_out_opt __deref_out __post __deref __exceptthat __maybenull
#define __deref_out_ecount_opt(size) __deref_out_ecount(size) __post __deref __exceptthat __maybenull
#define __deref_out_bcount_opt(size) __deref_out_bcount(size) __post __deref __exceptthat __maybenull
#define __deref_out_ecount_part_opt(size,length) __deref_out_ecount_part(size,length) __post __deref __exceptthat __maybenull
#define __deref_out_bcount_part_opt(size,length) __deref_out_bcount_part(size,length) __post __deref __exceptthat __maybenull
#define __deref_out_ecount_full_opt(size) __deref_out_ecount_full(size) __post __deref __exceptthat __maybenull
#define __deref_out_bcount_full_opt(size) __deref_out_bcount_full(size) __post __deref __exceptthat __maybenull
#define __deref_out_z_opt __post __deref __valid __refparam __execeptthat __maybenull __post __deref __nullterminated
#define __deref_out_ecount_z_opt(size) __deref_out_ecount_opt(size) __post __deref __nullterminated
#define __deref_out_bcount_z_opt(size) __deref_out_bcount_opt(size) __post __deref __nullterminated
#define __deref_out_nz_opt __deref_out_opt
#define __deref_out_ecount_nz_opt(size) __deref_out_ecount_opt(size)
#define __deref_out_bcount_nz_opt(size) __deref_out_bcount_opt(size)
#define __deref_inout_opt __deref_inout __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_opt(size) __deref_inout_ecount(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_opt(size) __deref_inout_bcount(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_part_opt(size,length) __deref_inout_ecount_part(size,length) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_part_opt(size,length) __deref_inout_bcount_part(size,length) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_full_opt(size) __deref_inout_ecount_full(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_full_opt(size) __deref_inout_bcount_full(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_z_opt __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_ecount_z_opt(size) __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_bcount_z_opt(size) __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_inout_nz_opt __deref_inout_opt
#define __deref_inout_ecount_nz_opt(size) __deref_inout_ecount_opt(size)
#define __deref_inout_bcount_nz_opt(size) __deref_inout_bcount_opt(size)
#define __deref_opt_ecount(size) __deref_ecount(size) __exceptthat __maybenull
#define __deref_opt_bcount(size) __deref_bcount(size) __exceptthat __maybenull
#define __deref_opt_out __deref_out __exceptthat __maybenull
#define __deref_opt_out_z __deref_opt_out __post __deref __nullterminated
#define __deref_opt_out_ecount(size) __deref_out_ecount(size) __exceptthat __maybenull
#define __deref_opt_out_bcount(size) __deref_out_bcount(size) __exceptthat __maybenull
#define __deref_opt_out_ecount_part(size,length) __deref_out_ecount_part(size,length) __exceptthat __maybenull
#define __deref_opt_out_bcount_part(size,length) __deref_out_bcount_part(size,length) __exceptthat __maybenull
#define __deref_opt_out_ecount_full(size) __deref_out_ecount_full(size) __exceptthat __maybenull
#define __deref_opt_out_bcount_full(size) __deref_out_bcount_full(size) __exceptthat __maybenull
#define __deref_opt_inout __deref_inout __exceptthat __maybenull
#define __deref_opt_inout_ecount(size) __deref_inout_ecount(size) __exceptthat __maybenull
#define __deref_opt_inout_bcount(size) __deref_inout_bcount(size) __exceptthat __maybenull
#define __deref_opt_inout_ecount_part(size,length) __deref_inout_ecount_part(size,length) __exceptthat __maybenull
#define __deref_opt_inout_bcount_part(size,length) __deref_inout_bcount_part(size,length) __exceptthat __maybenull
#define __deref_opt_inout_ecount_full(size) __deref_inout_ecount_full(size) __exceptthat __maybenull
#define __deref_opt_inout_bcount_full(size) __deref_inout_bcount_full(size) __exceptthat __maybenull
#define __deref_opt_inout_z __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_ecount_z(size) __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_bcount_z(size) __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_nz __deref_opt_inout
#define __deref_opt_inout_ecount_nz(size) __deref_opt_inout_ecount(size)
#define __deref_opt_inout_bcount_nz(size) __deref_opt_inout_bcount(size)
#define __deref_opt_ecount_opt(size) __deref_ecount_opt(size) __exceptthat __maybenull
#define __deref_opt_bcount_opt(size) __deref_bcount_opt(size) __exceptthat __maybenull
#define __deref_opt_out_opt __deref_out_opt __exceptthat __maybenull
#define __deref_opt_out_ecount_opt(size) __deref_out_ecount_opt(size) __exceptthat __maybenull
#define __deref_opt_out_bcount_opt(size) __deref_out_bcount_opt(size) __exceptthat __maybenull
#define __deref_opt_out_ecount_part_opt(size,length) __deref_out_ecount_part_opt(size,length) __exceptthat __maybenull
#define __deref_opt_out_bcount_part_opt(size,length) __deref_out_bcount_part_opt(size,length) __exceptthat __maybenull
#define __deref_opt_out_ecount_full_opt(size) __deref_out_ecount_full_opt(size) __exceptthat __maybenull
#define __deref_opt_out_bcount_full_opt(size) __deref_out_bcount_full_opt(size) __exceptthat __maybenull
#define __deref_opt_out_z_opt __post __deref __valid __refparam __exceptthat __maybenull __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull __post __deref __nullterminated
#define __deref_opt_out_ecount_z_opt(size) __deref_opt_out_ecount_opt(size) __post __deref __nullterminated
#define __deref_opt_out_bcount_z_opt(size) __deref_opt_out_bcount_opt(size) __post __deref __nullterminated
#define __deref_opt_out_nz_opt __deref_opt_out_opt
#define __deref_opt_out_ecount_nz_opt(size) __deref_opt_out_ecount_opt(size)
#define __deref_opt_out_bcount_nz_opt(size) __deref_opt_out_bcount_opt(size)
#define __deref_opt_inout_opt __deref_inout_opt __exceptthat __maybenull
#define __deref_opt_inout_ecount_opt(size) __deref_inout_ecount_opt(size) __exceptthat __maybenull
#define __deref_opt_inout_bcount_opt(size) __deref_inout_bcount_opt(size) __exceptthat __maybenull
#define __deref_opt_inout_ecount_part_opt(size,length) __deref_inout_ecount_part_opt(size,length) __exceptthat __maybenull
#define __deref_opt_inout_bcount_part_opt(size,length) __deref_inout_bcount_part_opt(size,length) __exceptthat __maybenull
#define __deref_opt_inout_ecount_full_opt(size) __deref_inout_ecount_full_opt(size) __exceptthat __maybenull
#define __deref_opt_inout_bcount_full_opt(size) __deref_inout_bcount_full_opt(size) __exceptthat __maybenull
#define __deref_opt_inout_z_opt __deref_opt_inout_opt __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_ecount_z_opt(size) __deref_opt_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_bcount_z_opt(size) __deref_opt_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __deref_opt_inout_nz_opt __deref_opt_inout_opt
#define __deref_opt_inout_ecount_nz_opt(size) __deref_opt_inout_ecount_opt(size)
#define __deref_opt_inout_bcount_nz_opt(size) __deref_opt_inout_bcount_opt(size)

/*

-------------------------------------------------------------------------------

Advanced Annotation Definitions



Any of these may be used to directly annotate functions, and may be used in

combination with each other or with regular buffer macros. For an explanation

of each annotation, see the advanced annotations section.

-------------------------------------------------------------------------------

*/
# 1968 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/sal.h"
#define __success(expr) __inner_success(expr)
#define __nullterminated __readableTo(sentinel(0))
#define __nullnullterminated 
#define __reserved __pre __null
#define __checkReturn __inner_checkReturn
#define __typefix(ctype) __inner_typefix(ctype)
#define __override __inner_override
#define __callback __inner_callback
#define __format_string 
#define __blocksOn(resource) __inner_blocksOn(resource)
#define __control_entrypoint(category) __inner_control_entrypoint(category)
#define __data_entrypoint(category) __inner_data_entrypoint(category)


   
#define __fallthrough __inner_fallthrough






#define __analysis_assume(expr) 
# 57 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 2

#undef _CRT_PACKING
#define _CRT_PACKING 8

#pragma pack(push,_CRT_PACKING)

# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h" 1
/***

*vadefs.h - defines helper macros for stdarg.h

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This is a helper file for stdarg.h

*

*       [Public]

*

****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
       


#define _INC_VADEFS 






/*

 * Currently, all MS C compilers for Win32 platforms default to 8 byte

 * alignment.

 */
# 27 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
#undef _CRT_PACKING
#define _CRT_PACKING 8
#pragma pack(push,_CRT_PACKING)
# 40 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
#define _W64 





typedef unsigned __int64 uintptr_t;



#define _UINTPTR_T_DEFINED 






typedef char * va_list;

#define _VA_LIST_DEFINED 





#define _ADDRESSOF(v) ( &(v) )
# 79 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
#define _SLOTSIZEOF(t) (sizeof(t))
#define _APALIGN(t,ap) (__alignof(t))
# 132 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/vadefs.h"
/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define _crt_va_start(ap,v) ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define _crt_va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _crt_va_end(ap) ( ap = (va_list)0 )







#pragma pack(pop)
# 64 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 2





/* preprocessor string helpers */

#define __CRT_STRINGIZE(_Value) #_Value
#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)



#define __CRT_WIDE(_String) L ## _String
#define _CRT_WIDE(_String) __CRT_WIDE(_String)



#define __CRT_APPEND(_Value1,_Value2) _Value1 ## _Value2
#define _CRT_APPEND(_Value1,_Value2) __CRT_APPEND(_Value1, _Value2)
# 94 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Define _CRTIMP_NOIA64 */




#define _CRTIMP_NOIA64 _CRTIMP



/* Define _CRTIMP2 */





#define _CRTIMP2 



/* Define _CRTIMP_ALTERNATIVE */
# 124 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRTIMP_ALTERNATIVE 



/* Define _MRTIMP */


#define _MRTIMP __declspec(dllimport)


/* Define _MRTIMP2 */






#define _MRTIMP2 
# 151 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _MCRTIMP 







#define __CLR_OR_THIS_CALL 







#define __CLRCALL_OR_CDECL __cdecl







#define _CRTIMP_PURE _CRTIMP
# 187 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _PGLOBAL 







#define _AGLOBAL 



/* define a specific constant for mixed mode */






/* Define __STDC_SECURE_LIB__ */
#define __STDC_SECURE_LIB__ 200411L

/* Retain__GOT_SECURE_LIB__ for back-compat */
#define __GOT_SECURE_LIB__ __STDC_SECURE_LIB__

/* Default value for __STDC_WANT_SECURE_LIB__ is 1 */

#define __STDC_WANT_SECURE_LIB__ 1


/* Turn off warnings if __STDC_WANT_SECURE_LIB__ is 0 */




/* See note on use of deprecate at the top of this file */
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

/* Define _CRT_INSECURE_DEPRECATE */
/* See note on use of deprecate at the top of this file */
# 235 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT("This function or variable may be unsafe. Consider using " #_Replacement " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")



/* Define _CRT_INSECURE_DEPRECATE_MEMORY */
/* See note on use of deprecate at the top of this file */






#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) 





/* Define _CRT_INSECURE_DEPRECATE_GLOBALS */
/* See note on use of deprecate at the top of this file */
# 268 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement) _CRT_INSECURE_DEPRECATE(_Replacement)




/* Define _CRT_MANAGED_HEAP_DEPRECATE */
/* See note on use of deprecate at the top of this file */
# 289 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_MANAGED_HEAP_DEPRECATE 




/* Change the __FILL_BUFFER_PATTERN to 0xFE to fix security function buffer overrun detection bug */
#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE

/* obsolete stuff */

/* Define _CRT_OBSOLETE */
/* See note on use of deprecate at the top of this file */
# 309 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_OBSOLETE(_NewItem) _CRT_DEPRECATE_TEXT("This function or variable has been superceded by newer library or operating system functionality. Consider using " #_NewItem " instead. See online help for details.")




/* jit64 instrinsic stuff */





#define _CRT_JIT_INTRINSIC 



/* Define overload switches */


#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
# 337 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
  /* _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0 */
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
# 349 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
# 362 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
# 372 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
# 381 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_SECURE_CPP_NOTHROW throw()


/* Define _CRT_NONSTDC_DEPRECATE */
/* See note on use of deprecate at the top of this file */
# 394 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_NONSTDC_DEPRECATE(_NewName) _CRT_DEPRECATE_TEXT("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " #_NewName ". See online help for details.")





typedef unsigned __int64 size_t;



#define _SIZE_T_DEFINED 




typedef size_t rsize_t;
#define _RSIZE_T_DEFINED 





typedef __int64 intptr_t;



#define _INTPTR_T_DEFINED 
# 434 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
typedef __int64 ptrdiff_t;



#define _PTRDIFF_T_DEFINED 



typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED 



typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED 
# 468 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _ERRNO_T_DEFINED 
typedef int errno_t;



typedef long __time32_t; /* 32-bit time value */
#define _TIME32_T_DEFINED 



typedef __int64 __time64_t; /* 64-bit time value */
#define _TIME64_T_DEFINED 






typedef __time64_t time_t; /* time value */

#define _TIME_T_DEFINED 







#define _CONST_RETURN 







#define UNALIGNED 







#define _CRT_ALIGN(x) __declspec(align(x))



/* Define _CRTNOALIAS, _CRTRESTRICT */


#define _CRTNOALIAS __declspec(noalias)



#define _CRTRESTRICT __declspec(restrict)






#define __CRTDECL __cdecl



/* error reporting helpers */
#define __STR2WSTR(str) L ##str
#define _STR2WSTR(str) __STR2WSTR(str)

#define __FILEW__ _STR2WSTR(__FILE__)
#define __FUNCTIONW__ _STR2WSTR(__FUNCTION__)

/* invalid_parameter */



 void __attribute__((__cdecl__)) _invalid_parameter_noinfo(void);
 __attribute__((noreturn)) void __attribute__((__cdecl__)) _invalid_parameter_noinfo_noreturn(void);


 __attribute__((noreturn))
void __attribute__((__cdecl__)) _invoke_watson( const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);






 /* By default, _CRT_SECURE_INVALID_PARAMETER in retail invokes _invalid_parameter_noinfo_noreturn(),

  * which is marked __declspec(noreturn) and does not return control to the application. Even if 

  * _set_invalid_parameter_handler() is used to set a new invalid parameter handler which does return

  * control to the application, _invalid_parameter_noinfo_noreturn() will terminate the application and

  * invoke Watson. You can overwrite the definition of _CRT_SECURE_INVALID_PARAMETER if you need.

  *

  * _CRT_SECURE_INVALID_PARAMETER is used in the Standard C++ Libraries and the SafeInt library.

  */
# 566 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_SECURE_INVALID_PARAMETER(expr) ::_invalid_parameter_noinfo_noreturn()




#define _ARGMAX 100

/* _TRUNCATE */

#define _TRUNCATE ((size_t)-1)


/* helper macros for cpp overloads */
# 726 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType,_FuncName,_DstType,_Dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_DstType,_Dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType,_FuncName,_DstType,_Src) 




#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _VFuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
# 1808 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define __RETURN_POLICY_SAME(_FunctionCall) 
#define __RETURN_POLICY_DST(_FunctionCall) 
#define __RETURN_POLICY_VOID(_FunctionCall) 
#define __EMPTY_DECLSPEC 

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SecureVFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);



#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 




struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
#define _TAGLC_ID_DEFINED 



typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; /* LCID */
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;
#define _THREADLOCALEINFO 
# 2010 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _Check_return_opt_ 





#define _Check_return_wat_ 





#define __crt_typefix(ctype) 
# 2033 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
#define _CRT_UNUSED(x) (void)x


#pragma pack(pop)
# 21 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h" 2

/*

 * Currently, all MS C compilers for Win32 platforms default to 8 byte

 * alignment.

 */
# 26 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
#pragma pack(push,_CRT_PACKING)





/*

 * Exception disposition return values.

 */
# 35 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*

 * Prototype for SEH support function.

 */
# 93 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
/*

 * Keywords and intrinsics for SEH

 */
# 97 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
#define GetExceptionCode _exception_code
#define exception_code _exception_code
#define GetExceptionInformation (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination _abnormal_termination
#define abnormal_termination _abnormal_termination

unsigned long __attribute__((__cdecl__)) _exception_code(void);
void * __attribute__((__cdecl__)) _exception_info(void);
int __attribute__((__cdecl__)) _abnormal_termination(void);


/*

 * Legal values for expression in except().

 */
# 113 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/excpt.h"
#define EXCEPTION_EXECUTE_HANDLER 1
#define EXCEPTION_CONTINUE_SEARCH 0
#define EXCEPTION_CONTINUE_EXECUTION -1







#pragma pack(pop)
# 152 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/stdarg.h" 1
/***

*stdarg.h - defines ANSI-style macros for variable argument functions

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This file defines ANSI-style macros for accessing arguments

*       of functions which take a variable number of arguments.

*       [ANSI]

*

*       [Public]

*

****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/stdarg.h"
       


#define _INC_STDARG 
# 27 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/stdarg.h"
#define va_start _crt_va_start
#define va_arg _crt_va_arg
#define va_end _crt_va_end
# 153 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h" 1
/****************************************************************************

*                                                                           *

* windef.h -- Basic Windows Type Definitions                                *

*                                                                           *

* Copyright (c) Microsoft Corporation. All rights reserved.                 *

*                                                                           *

****************************************************************************/
# 11 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
#define _WINDEF_ 
       



#define STRICT 1



// Win32 defines _WIN32 automatically,
// but Macintosh doesn't, so if we are using
// Win32 Functions, we must do it here
# 42 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
/*

 * BASETYPES is defined in ntdef.h if these types are already defined

 */
#define BASETYPES 
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;


#define MAX_PATH 260





#define NULL ((void *)0)




#define FALSE 0



#define TRUE 1



#define IN 



#define OUT 



#define OPTIONAL 


#undef far
#undef near
#undef pascal

#define far 
#define near 



#define pascal 
# 105 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
#define cdecl 

#define CDECL 
# 130 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
#define CALLBACK 
#define WINAPI 
#define WINAPIV 
#define APIENTRY WINAPI
#define APIPRIVATE 
#define PASCAL pascal





#define WINAPI_INLINE WINAPI


#undef FAR
#undef NEAR
#define FAR far
#define NEAR near

#define CONST const


typedef unsigned long DWORD;
typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef float FLOAT;
typedef FLOAT *PFLOAT;
typedef BOOL *PBOOL;
typedef BOOL *LPBOOL;
typedef BYTE *PBYTE;
typedef BYTE *LPBYTE;
typedef int *PINT;
typedef int *LPINT;
typedef WORD *PWORD;
typedef WORD *LPWORD;
typedef long *LPLONG;
typedef DWORD *PDWORD;
typedef DWORD *LPDWORD;
typedef void *LPVOID;
typedef const void *LPCVOID;

typedef int INT;
typedef unsigned int UINT;
typedef unsigned int *PUINT;


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 1
/*++ BUILD Version: 0091     Increment this if a change has global effects



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    winnt.h



Abstract:



    This module defines the 32-Bit Windows types and constants that are

    defined by NT, but exposed through the Win32 API.



Revision History:



--*/
# 19 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define _WINNT_ 




#pragma warning(disable:4201)
#pragma warning(disable:4214)





# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h" 1
/***

*ctype.h - character conversion macros and ctype macros

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       Defines macros for character classification/conversion.

*       [ANSI/System V]

*

*       [Public]

*

****/
# 14 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
       


#define _INC_CTYPE 

# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***

*crtdefs.h - definitions/declarations common to all CRT

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This file has mostly defines used by the entire CRT.

*

*       [Public]

*

****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */

/* Define _CRTIMP */
# 20 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h" 2






#define WEOF (wint_t)(0xFFFF)



#define _CRT_CTYPEDATA_DEFINED 






#define __PCTYPE_FUNC __pctype_func()



 const unsigned short * __attribute__((__cdecl__)) __pctype_func(void);

 extern const unsigned short *_pctype;







#define _CRT_WCTYPEDATA_DEFINED 


 extern const unsigned short _wctype[];


 const wctype_t * __attribute__((__cdecl__)) __pwctype_func(void);

 extern const wctype_t *_pwctype;
# 72 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
/* set bit masks for the possible character types */

#define _UPPER 0x1
#define _LOWER 0x2
#define _DIGIT 0x4
#define _SPACE 0x8
                                /* vertical tab or form feed */
#define _PUNCT 0x10
#define _CONTROL 0x20
#define _BLANK 0x40
#define _HEX 0x80

#define _LEADBYTE 0x8000
#define _ALPHA (0x0100|_UPPER|_LOWER)


/* character classification function prototypes */



 int __attribute__((__cdecl__)) _isctype( int _C, int _Type);
 int __attribute__((__cdecl__)) _isctype_l( int _C, int _Type, _locale_t _Locale);
 int __attribute__((__cdecl__)) isalpha( int _C);
 int __attribute__((__cdecl__)) _isalpha_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isupper( int _C);
 int __attribute__((__cdecl__)) _isupper_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) islower( int _C);
 int __attribute__((__cdecl__)) _islower_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isdigit( int _C);
 int __attribute__((__cdecl__)) _isdigit_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isxdigit( int _C);
 int __attribute__((__cdecl__)) _isxdigit_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isspace( int _C);
 int __attribute__((__cdecl__)) _isspace_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) ispunct( int _C);
 int __attribute__((__cdecl__)) _ispunct_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isalnum( int _C);
 int __attribute__((__cdecl__)) _isalnum_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isprint( int _C);
 int __attribute__((__cdecl__)) _isprint_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) isgraph( int _C);
 int __attribute__((__cdecl__)) _isgraph_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iscntrl( int _C);
 int __attribute__((__cdecl__)) _iscntrl_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) toupper( int _C);
 int __attribute__((__cdecl__)) tolower( int _C);
 int __attribute__((__cdecl__)) _tolower( int _C);
 int __attribute__((__cdecl__)) _tolower_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) _toupper( int _C);
 int __attribute__((__cdecl__)) _toupper_l( int _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) __isascii( int _C);
 int __attribute__((__cdecl__)) __toascii( int _C);
 int __attribute__((__cdecl__)) __iscsymf( int _C);
 int __attribute__((__cdecl__)) __iscsym( int _C);
#define _CTYPE_DEFINED 




/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

 int __attribute__((__cdecl__)) iswalpha( wint_t _C);
 int __attribute__((__cdecl__)) _iswalpha_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswupper( wint_t _C);
 int __attribute__((__cdecl__)) _iswupper_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswlower( wint_t _C);
 int __attribute__((__cdecl__)) _iswlower_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswdigit( wint_t _C);
 int __attribute__((__cdecl__)) _iswdigit_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswxdigit( wint_t _C);
 int __attribute__((__cdecl__)) _iswxdigit_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswspace( wint_t _C);
 int __attribute__((__cdecl__)) _iswspace_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswpunct( wint_t _C);
 int __attribute__((__cdecl__)) _iswpunct_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswalnum( wint_t _C);
 int __attribute__((__cdecl__)) _iswalnum_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswprint( wint_t _C);
 int __attribute__((__cdecl__)) _iswprint_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswgraph( wint_t _C);
 int __attribute__((__cdecl__)) _iswgraph_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswcntrl( wint_t _C);
 int __attribute__((__cdecl__)) _iswcntrl_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswascii( wint_t _C);
 int __attribute__((__cdecl__)) isleadbyte( int _C);
 int __attribute__((__cdecl__)) _isleadbyte_l( int _C, _locale_t _Locale);

 wint_t __attribute__((__cdecl__)) towupper( wint_t _C);
 wint_t __attribute__((__cdecl__)) _towupper_l( wint_t _C, _locale_t _Locale);
 wint_t __attribute__((__cdecl__)) towlower( wint_t _C);
 wint_t __attribute__((__cdecl__)) _towlower_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) iswctype( wint_t _C, wctype_t _Type);
 int __attribute__((__cdecl__)) _iswctype_l( wint_t _C, wctype_t _Type, _locale_t _Locale);

 int __attribute__((__cdecl__)) __iswcsymf( wint_t _C);
 int __attribute__((__cdecl__)) _iswcsymf_l( wint_t _C, _locale_t _Locale);
 int __attribute__((__cdecl__)) __iswcsym( wint_t _C);
 int __attribute__((__cdecl__)) _iswcsym_l( wint_t _C, _locale_t _Locale);

__attribute__((deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "iswctype" " instead. See online help for details."))) int __attribute__((__cdecl__)) is_wctype( wint_t _C, wctype_t _Type);

#define _WCTYPE_DEFINED 


/* the character classification macro definitions */



/*

 * Maximum number of bytes in multi-byte character in the current locale

 * (also defined in stdlib.h).

 */


#define MB_CUR_MAX ___mb_cur_max_func()


/* No data exports in pure code */
 extern int __mb_cur_max;



 int __attribute__((__cdecl__)) ___mb_cur_max_func(void);
 int __attribute__((__cdecl__)) ___mb_cur_max_l_func(_locale_t);


/* Introduced to detect error when character testing functions are called

 * with illegal input of integer.

 */


#define __chvalidchk(a,b) (__PCTYPE_FUNC[(a)] & (b))
# 262 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
#define _chvalidchk_l(_Char,_Flag,_Locale) (_Locale==NULL ? __chvalidchk(_Char, _Flag) : ((_locale_t)_Locale)->locinfo->pctype[_Char] & (_Flag))



#define _ischartype_l(_Char,_Flag,_Locale) ( ((_Locale)!=NULL && (((_locale_t)(_Locale))->locinfo->mb_cur_max) > 1) ? _isctype_l(_Char, (_Flag), _Locale) : _chvalidchk_l(_Char,_Flag,_Locale))
#define _isalpha_l(_Char,_Locale) _ischartype_l(_Char, _ALPHA, _Locale)
#define _isupper_l(_Char,_Locale) _ischartype_l(_Char, _UPPER, _Locale)
#define _islower_l(_Char,_Locale) _ischartype_l(_Char, _LOWER, _Locale)
#define _isdigit_l(_Char,_Locale) _ischartype_l(_Char, _DIGIT, _Locale)
#define _isxdigit_l(_Char,_Locale) _ischartype_l(_Char, _HEX, _Locale)
#define _isspace_l(_Char,_Locale) _ischartype_l(_Char, _SPACE, _Locale)
#define _ispunct_l(_Char,_Locale) _ischartype_l(_Char, _PUNCT, _Locale)
#define _isalnum_l(_Char,_Locale) _ischartype_l(_Char, _ALPHA|_DIGIT, _Locale)
#define _isprint_l(_Char,_Locale) _ischartype_l(_Char, _BLANK|_PUNCT|_ALPHA|_DIGIT, _Locale)
#define _isgraph_l(_Char,_Locale) _ischartype_l(_Char, _PUNCT|_ALPHA|_DIGIT, _Locale)
#define _iscntrl_l(_Char,_Locale) _ischartype_l(_Char, _CONTROL, _Locale)

#define _tolower(_Char) ( (_Char)-'A'+'a' )
#define _toupper(_Char) ( (_Char)-'a'+'A' )

#define __isascii(_Char) ( (unsigned)(_Char) < 0x80 )
#define __toascii(_Char) ( (_Char) & 0x7f )



#undef _CRT_WCTYPE_NOINLINE


#define iswalpha(_c) ( iswctype(_c,_ALPHA) )
#define iswupper(_c) ( iswctype(_c,_UPPER) )
#define iswlower(_c) ( iswctype(_c,_LOWER) )
#define iswdigit(_c) ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c) ( iswctype(_c,_HEX) )
#define iswspace(_c) ( iswctype(_c,_SPACE) )
#define iswpunct(_c) ( iswctype(_c,_PUNCT) )
#define iswalnum(_c) ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c) ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c) ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c) ( iswctype(_c,_CONTROL) )
#define iswascii(_c) ( (unsigned)(_c) < 0x80 )

#define _iswalpha_l(_c,_p) ( iswctype(_c,_ALPHA) )
#define _iswupper_l(_c,_p) ( iswctype(_c,_UPPER) )
#define _iswlower_l(_c,_p) ( iswctype(_c,_LOWER) )
#define _iswdigit_l(_c,_p) ( iswctype(_c,_DIGIT) )
#define _iswxdigit_l(_c,_p) ( iswctype(_c,_HEX) )
#define _iswspace_l(_c,_p) ( iswctype(_c,_SPACE) )
#define _iswpunct_l(_c,_p) ( iswctype(_c,_PUNCT) )
#define _iswalnum_l(_c,_p) ( iswctype(_c,_ALPHA|_DIGIT) )
#define _iswprint_l(_c,_p) ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define _iswgraph_l(_c,_p) ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define _iswcntrl_l(_c,_p) ( iswctype(_c,_CONTROL) )
# 342 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/ctype.h"
#define _WCTYPE_INLINE_DEFINED 


/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c) (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c) (isalnum(_c) || ((_c) == '_'))
#define __iswcsymf(_c) (iswalpha(_c) || ((_c) == '_'))
#define __iswcsym(_c) (iswalnum(_c) || ((_c) == '_'))

#define _iscsymf_l(_c,_p) (_isalpha_l(_c, _p) || ((_c) == '_'))
#define _iscsym_l(_c,_p) (_isalnum_l(_c, _p) || ((_c) == '_'))
#define _iswcsymf_l(_c,_p) (iswalpha(_c) || ((_c) == '_'))
#define _iswcsym_l(_c,_p) (iswalnum(_c) || ((_c) == '_'))
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
#define ANYSIZE_ARRAY 1

//
// For compilers that don't support nameless unions/structs
//


#define DUMMYUNIONNAME u
#define DUMMYUNIONNAME2 u2
#define DUMMYUNIONNAME3 u3
#define DUMMYUNIONNAME4 u4
#define DUMMYUNIONNAME5 u5
#define DUMMYUNIONNAME6 u6
#define DUMMYUNIONNAME7 u7
#define DUMMYUNIONNAME8 u8
#define DUMMYUNIONNAME9 u9
# 63 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define DUMMYSTRUCTNAME s
#define DUMMYSTRUCTNAME2 s2
#define DUMMYSTRUCTNAME3 s3
#define DUMMYSTRUCTNAME4 s4
#define DUMMYSTRUCTNAME5 s5
# 77 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 1

#define SPECSTRINGS_H 
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sal_supp.h" 1
// A temporary header to supplement sal.h with things that currently 
// cannot be put into sal.h.
// This is designed to be included at the beginning of a compilation unit
// (via force-include) if necessary.


#define SAL_SUPP_H 
# 53 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sal_supp.h"
#define __ANNOTATION(fun) 
#define __PRIMOP(type,fun) 
#define __AuToQuOtE 
#define __deferTypecheck 
#define __useHeader 
# 4 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_supp.h" 1
// A temporary header to supplement specstrings.h with things that currently 
// cannot be put into specstrings.h.
// This is designed to be included at the beginning of a compilation unit
// (via force-include) if necessary.


#define SPECSTRING_SUPP_H 
# 74 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_supp.h"
#define __failure(x) 
#define __static_context(ctx,annotes) 
#define __applyTo_return(annotes) 
#define __on_failure(annotes) 
#define __failureDefault(kind) 
#define __valueUndefined 
# 5 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2
/*************************************************************************

* See specstrings_strict.h for documentation of all user visible macros.

*************************************************************************/




#define __SAL_H_FULL_VER 140050727






/* version specific fixes to bring sal.h upto date */
# 35 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
#define __inexpressible_readableTo(size) 
#define __inexpressible_writableTo(size) 
#define __inner_bound 
#define __inner_range(lb,ub) 
#define __inner_assume_bound_dec 
#define __inner_assume_bound(i) 
#define __inner_allocator 


#define __xcount(size) __notnull __inexpressible_writableTo(size)
#define __in_xcount(size) __in __pre __inexpressible_readableTo(size)
#define __out_xcount(size) __xcount(size) __post __valid __refparam
#define __out_xcount_part(size,length) __out_xcount(size) __post __inexpressible_readableTo(length)
#define __out_xcount_full(size) __out_xcount_part(size,size)
#define __inout_xcount(size) __out_xcount(size) __pre __valid
#define __inout_xcount_part(size,length) __out_xcount_part(size,length) __pre __valid __pre __inexpressible_readableTo(length)
#define __inout_xcount_full(size) __inout_xcount_part(size,size)
#define __xcount_opt(size) __xcount(size) __exceptthat __maybenull
#define __in_xcount_opt(size) __in_xcount(size) __exceptthat __maybenull
#define __out_xcount_opt(size) __out_xcount(size) __exceptthat __maybenull
#define __out_xcount_part_opt(size,length) __out_xcount_part(size,length) __exceptthat __maybenull
#define __out_xcount_full_opt(size) __out_xcount_full(size) __exceptthat __maybenull
#define __inout_xcount_opt(size) __inout_xcount(size) __exceptthat __maybenull
#define __inout_xcount_part_opt(size,length) __inout_xcount_part(size,length) __exceptthat __maybenull
#define __inout_xcount_full_opt(size) __inout_xcount_full(size) __exceptthat __maybenull
#define __deref_xcount(size) __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size)
#define __deref_in __in __pre __deref __deref __readonly
#define __deref_in_ecount(size) __deref_in __pre __deref __elem_readableTo(size)
#define __deref_in_bcount(size) __deref_in __pre __deref __byte_readableTo(size)
#define __deref_in_xcount(size) __deref_in __pre __deref __inexpressible_readableTo(size)
#define __deref_out_xcount(size) __deref_xcount(size) __post __deref __valid __refparam
#define __deref_out_xcount_part(size,length) __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length)
#define __deref_out_xcount_full(size) __deref_out_xcount_part(size,size)
#define __deref_out_xcount(size) __deref_xcount(size) __post __deref __valid __refparam
#define __inout_xcount_opt(size) __inout_xcount(size) __exceptthat __maybenull
#define __inout_xcount_part_opt(size,length) __inout_xcount_part(size,length) __exceptthat __maybenull
#define __inout_xcount_full_opt(size) __inout_xcount_full(size) __exceptthat __maybenull
#define __deref_xcount(size) __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __inexpressible_writableTo(size)
#define __deref_in __in __pre __deref __deref __readonly
#define __deref_in_ecount(size) __deref_in __pre __deref __elem_readableTo(size)
#define __deref_in_bcount(size) __deref_in __pre __deref __byte_readableTo(size)
#define __deref_in_xcount(size) __deref_in __pre __deref __inexpressible_readableTo(size)
#define __deref_out_xcount(size) __deref_xcount(size) __post __deref __valid __refparam
#define __deref_out_xcount_part(size,length) __deref_out_xcount(size) __post __deref __inexpressible_readableTo(length)
#define __deref_out_xcount_full(size) __deref_out_xcount_part(size,size)
#define __deref_out_xcount(size) __deref_xcount(size) __post __deref __valid __refparam
#define __deref_inout_xcount(size) __deref_inout __pre __deref __inexpressible_writableTo(size) __post __deref __inexpressible_writableTo(size)
#define __deref_inout_xcount_part(size,length) __deref_inout_xcount(size) __pre __deref __inexpressible_readableTo(length) __post __deref __inexpressible_readableTo(length)
#define __deref_inout_xcount_full(size) __deref_inout_xcount_part(size,size)
#define __deref_xcount_opt(size) __deref_xcount(size) __post __deref __exceptthat __maybenull
#define __deref_in_opt __deref_in __pre __deref __exceptthat __maybenull
#define __deref_in_opt_out __deref_inout __pre __deref __exceptthat __maybenull __post __deref __notnull
#define __deref_in_ecount_opt(size) __deref_in_ecount(size) __pre __deref __exceptthat __maybenull
#define __deref_in_bcount_opt(size) __deref_in_bcount(size) __pre __deref __exceptthat __maybenull
#define __deref_in_xcount_opt(size) __deref_in_xcount(size) __pre __deref __exceptthat __maybenull
#define __deref_out_xcount_opt(size) __deref_out_xcount(size) __post __deref __exceptthat __maybenull
#define __deref_out_xcount_part_opt(size,length) __deref_out_xcount_part(size,length) __post __deref __exceptthat __maybenull
#define __deref_out_xcount_full_opt(size) __deref_out_xcount_full(size) __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_opt(size) __deref_inout_xcount(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_part_opt(size,length) __deref_inout_xcount_part(size,length) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_xcount_full_opt(size) __deref_inout_xcount_full(size) __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_opt_xcount(size) __deref_xcount(size) __exceptthat __maybenull
#define __deref_opt_in __deref_in __exceptthat __maybenull
#define __deref_opt_in_ecount(size) __deref_in_ecount(size) __exceptthat __maybenull
#define __deref_opt_in_bcount(size) __deref_in_bcount(size) __exceptthat __maybenull
#define __deref_opt_in_xcount(size) __deref_in_xcount(size) __exceptthat __maybenull
#define __deref_opt_out_xcount(size) __deref_out_xcount(size) __exceptthat __maybenull
#define __deref_opt_out_xcount_part(size,length) __deref_out_xcount_part(size,length) __exceptthat __maybenull
#define __deref_opt_out_xcount_full(size) __deref_out_xcount_full(size) __exceptthat __maybenull
#define __deref_opt_inout_xcount(size) __deref_inout_xcount(size) __exceptthat __maybenull
#define __deref_opt_inout_xcount_part(size,length) __deref_inout_xcount_part(size,length) __exceptthat __maybenull
#define __deref_opt_inout_xcount_full(size) __deref_inout_xcount_full(size) __exceptthat __maybenull
#define __deref_opt_xcount_opt(size) __deref_xcount_opt(size) __exceptthat __maybenull
#define __deref_opt_in_opt __deref_in_opt __exceptthat __maybenull
#define __deref_opt_in_ecount_opt(size) __deref_in_ecount_opt(size) __exceptthat __maybenull
#define __deref_opt_in_bcount_opt(size) __deref_in_bcount_opt(size) __exceptthat __maybenull
#define __deref_opt_in_xcount_opt(size) __deref_in_xcount_opt(size) __exceptthat __maybenull
#define __deref_opt_out_xcount_opt(size) __deref_out_xcount_opt(size) __exceptthat __maybenull
#define __deref_opt_out_xcount_part_opt(size,length) __deref_out_xcount_part_opt(size,length) __exceptthat __maybenull
#define __deref_opt_out_xcount_full_opt(size) __deref_out_xcount_full_opt(size) __exceptthat __maybenull
#define __deref_opt_inout_xcount_opt(size) __deref_inout_xcount_opt(size) __exceptthat __maybenull
#define __deref_opt_inout_xcount_part_opt(size,length) __deref_inout_xcount_part_opt(size,length) __exceptthat __maybenull
#define __deref_opt_inout_xcount_full_opt(size) __deref_inout_xcount_full_opt(size) __exceptthat __maybenull
/* Must protect redfinitions of macros to workaround rc.exe issues. */

#undef __nullnullterminated
#define __nullnullterminated __inexpressible_readableTo("string terminated by two nulls") __nullterminated
#undef __checkReturn
#define __checkReturn __post __inner_checkReturn



/************************************************************************

 New extensions to sal.h follow here.

*************************************************************************/
# 164 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
#define __file_parser(typ) 
#define __file_parser_class(typ) 
#define __file_parser_library(typ) 
#define __source_code_content(typ) 
#define __class_code_content(typ) 
#define __analysis_assert(e) 
#define __analysis_hint(hint) 
#define __analysis_noreturn 
/* Internal defintions */
#define __inner_data_source(src_raw) 
#define __inner_this_data_source(src_raw) 
#define __inner_out_validated(typ_raw) 
#define __inner_this_out_validated(typ_raw) 
#define __inner_assume_validated_dec 
#define __inner_assume_validated(p) 
#define __inner_transfer(formal) 
#define __inner_encoded 
#define __inner_adt_prop(adt,prop) 
#define __inner_adt_add_prop(adt,prop) 
#define __inner_adt_remove_prop(adt,prop) 
#define __inner_adt_transfer_prop(arg) 
#define __inner_adt_type_props(typ) 
#define __inner_volatile 
#define __inner_nonvolatile 
#define __inner_possibly_notnullterminated 
#define __inner_analysis_assume_nullterminated_dec 
#define __inner_analysis_assume_nullterminated(x) 


#define __field_ecount(size) __notnull __elem_writableTo(size)
#define __field_bcount(size) __notnull __byte_writableTo(size)
#define __field_xcount(size) __notnull __inexpressible_writableTo(size)

#define __field_ecount_opt(size) __maybenull __elem_writableTo(size)
#define __field_bcount_opt(size) __maybenull __byte_writableTo(size)
#define __field_xcount_opt(size) __maybenull __inexpressible_writableTo(size)

#define __field_ecount_part(size,init) __notnull __elem_writableTo(size) __elem_readableTo(init)
#define __field_bcount_part(size,init) __notnull __byte_writableTo(size) __byte_readableTo(init)
#define __field_xcount_part(size,init) __notnull __inexpressible_writableTo(size) __inexpressible_readableTo(init)

#define __field_ecount_part_opt(size,init) __maybenull __elem_writableTo(size) __elem_readableTo(init)
#define __field_bcount_part_opt(size,init) __maybenull __byte_writableTo(size) __byte_readableTo(init)
#define __field_xcount_part_opt(size,init) __maybenull __inexpressible_writableTo(size) __inexpressible_readableTo(init)

#define __field_ecount_full(size) __field_ecount_part(size,size)
#define __field_bcount_full(size) __field_bcount_part(size,size)
#define __field_xcount_full(size) __field_xcount_part(size,size)

#define __field_ecount_full_opt(size) __field_ecount_part_opt(size,size)
#define __field_bcount_full_opt(size) __field_bcount_part_opt(size,size)
#define __field_xcount_full_opt(size) __field_xcount_part_opt(size,size)

#define __field_nullterminated __nullterminated

#define __struct_bcount(size) __byte_writableTo(size)
#define __struct_xcount(size) __inexpressible_writableTo(size)

#define __out_awcount(expr,size) __pre __notnull __byte_writableTo((expr) ? (size) : (size) * 2) __post __valid __refparam


#define __in_awcount(expr,size) __pre __valid __pre __deref __readonly __byte_readableTo((expr) ? (size) : (size) * 2)


#define __post_invalid __post __notvalid
/* integer related macros */
#define __allocator __inner_allocator
#define __deallocate(kind) __pre __notnull __post_invalid
#define __deallocate_opt(kind) __pre __maybenull __post_invalid
#define __bound __inner_bound
#define __range(lb,ub) __inner_range(lb,ub)
#define __in_bound __pre __inner_bound
#define __out_bound __post __inner_bound
#define __deref_out_bound __post __deref __inner_bound
#define __in_range(lb,ub) __pre __inner_range(lb,ub)
#define __out_range(lb,ub) __post __inner_range(lb,ub)
#define __deref_in_range(lb,ub) __pre __deref __inner_range(lb,ub)
#define __deref_out_range(lb,ub) __post __deref __inner_range(lb,ub)
#define __deref_inout_range(lb,ub) __deref_in_range(lb,ub) __deref_out_range(lb,ub)
#define __field_range(lb,ub) __range(lb,ub)
#define __field_data_source(src_sym) __inner_data_source(#src_sym)

#define __range_max(a,b) __range(>=,a) __range(>=,b)
#define __range_min(a,b) __range(<=,a) __range(<=,b)

/* Penetration review macros */
#define __in_data_source(src_sym) __pre __inner_data_source(#src_sym)
#define __out_data_source(src_sym) __post __inner_data_source(#src_sym)
#define __out_validated(typ_sym) __inner_out_validated(#typ_sym)
#define __this_out_data_source(src_sym) __inner_this_data_source(#src_sym)
#define __this_out_validated(typ_sym) __inner_this_out_validated(#typ_sym)
#define __transfer(formal) __post __inner_transfer(formal)
#define __rpc_entry __inner_control_entrypoint(RPC)
#define __kernel_entry __inner_control_entrypoint(UserToKernel)
#define __gdi_entry __inner_control_entrypoint(GDI)
#define __encoded_pointer __inner_encoded
#define __encoded_array __inner_encoded
#define __field_encoded_pointer __inner_encoded
#define __field_encoded_array __inner_encoded
# 277 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
#define __out_has_type_adt_props(typ) 

#define __deref_volatile __deref __volatile
#define __deref_nonvolatile __deref __nonvolatile

/* declare stub functions for macros */



#define __analysis_assume_nullterminated(x) __inner_analysis_assume_nullterminated(x)
#define __assume_validated(p) __inner_assume_validated(p)
#define __assume_bound(i) __inner_assume_bound(i)
# 315 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
/**************************************************************************

* This include should always be the last thing in this file.

* Must avoid redfinitions of macros to workaround rc.exe issues.

***************************************************************************/
# 320 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_strict.h" 1
/************************************************************************* 

*  This file documents all the macros approved for use in windows source

*  code. It includes some experimental macros which should only be used by

*  experts.

*

*  DO NOT include this file directly.  This file is include after

*  specstrings.h. So we can undefine every possible old definition including

*  private internal macros people should not be using, as well as macros from

*  sal.h.  Macros are redefined here in a way to cause syntax errors when used

*  incorrectly during a normal build when specstrings.h is included and

*  __SPECSTRINGS_STRICT_LEVEL is defined.

*

*  There are several levels of strictness, each level includes the behavior of

*  all previous levels.

*

*  0 - Disable strict checking 

*  1 - Break on unapproved macros and misuse of statement 

*      macros such as __fallthrough (default)

*  2 - Deprecated some old macros that should not be used

*  3 - Use VS 2005 Source Annotation to make sure every macro 

*      is used in the right context. For example placing __in on a return 

*      parameter will result in an error.

************************************************************************/
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings_strict.h"
#define __SPECSTRINGS_STRICT_LEVEL 1

/************************************************************************

*  Introduction

*

*  specstrings.h provides a set of annotations to describe how a function uses

*  its parameters - the assumptions it makes about them, and the guarantees it

*  makes upon finishing.

* 

*  Annotations must be placed before a function parameter's type or its return

*  type. There are two basic classes of common annotations buffer annotations

*  and advanced annotations.  Buffer annotations describe how functions use

*  their pointer parameters, and advanced annotations either describe

*  complex/unusual buffer behavior, or provide additional information about a

*  parameter that is not otherwise expressible.

* 

*  Buffer Annotations

* 

*  The most important annotations in SpecStrings.h provide a consistent way to

*  annotate buffer parameters or return values for a function. Each of these

*  annotations describes a single buffer (which could be a string, a

*  fixed-length or variable-length array, or just a pointer) that the function

*  interacts with: where it is, how large it is, how much is initialized, and

*  what the function does with it.

* 

*  The appropriate macro for a given buffer can be constructed using the table

*  below.  Just pick the appropriate values from each category, and combine

*  them together with a leading underscore. Some combinations of values do not

*  make sense as buffer annotations. Only meaningful annotations can be added

*  to your code; for a list of these, see the buffer annotation definitions

*  section.

* 

*  Only a single buffer annotation should be used for each parameter.

* 

*  |------------|------------|---------|--------|----------|---------------|

*  |   Level    |   Usage    |  Size   | Output | Optional |  Parameters   |

*  |------------|------------|---------|--------|----------|---------------|

*  | <>         | <>         | <>      | <>     | <>       | <>            |

*  | _deref     | _in        | _ecount | _full  | _opt     | (size)        |

*  | _deref_opt | _out       | _bcount | _part  |          | (size,length) |

*  |            | _inout     |         |        |          |               |

*  |            |            |         |        |          |               |

*  |------------|------------|---------|--------|----------|---------------|

*

*  Note: "<>" represents the empty string.

* 

*  Level: Describes the buffer pointer's level of indirection from the

*  parameter or return value 'p'.

* 

*  <>         : p is the buffer pointer.

*  _deref     : *p is the buffer pointer. p must not be NULL.

*  _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the 

*               rest of the annotation is ignored.

* 

*  Usage: Describes how the function uses the buffer.

* 

*  <> : The buffer is not accessed. If used on the return value or with

*  _deref, the function will provide the buffer, and it will be uninitialized

*  at exit.  Otherwise, the caller must provide the buffer. This should only

*  be used for alloc and free functions.

*

*  _in : The function will only read from the buffer. The caller must provide

*  the buffer and initialize it.

*

*  _out : The function will only write to the buffer. If used on the return

*  value or with _deref, the function will provide the buffer and initialize

*  it.  Otherwise, the caller must provide the buffer, and the function will

*  initialize it.

*

*  _inout : The function may freely read from and write to the buffer. The

*  caller must provide the buffer and initialize it. If used with _deref, the

*  buffer may be reallocated by the function.

*

*  Size: Describes the total size of the buffer. This may be less than the

*  space actually allocated for the buffer, in which case it describes the

*  accessible amount.

* 

*  <> : No buffer size is given. If the type specifies the buffer size (such

*  as with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is

*  one element long. Must be used with _in, _out, or _inout.

*

*  _ecount : The buffer size is an explicit element count.

*

*  _bcount : The buffer size is an explicit byte count.

* 

*  Output: Describes how much of the buffer will be initialized by the

*  function. For _inout buffers, this also describes how much is initialized

*  at entry. Omit this category for _in buffers; they must be fully

*  initialized by the caller.

* 

*  <> : The type specifies how much is initialized. For instance, a function

*  initializing an LPWSTR must NULL-terminate the string.

*

*  _full : The function initializes the entire buffer.

*

*  _part : The function initializes part of the buffer, and explicitly

*  indicates how much.

* 

*  Optional: Describes if the buffer itself is optional.

* 

*  <>   : The pointer to the buffer must not be NULL.

*

*  _opt : The pointer to the buffer might be NULL. It will be checked before

*  being dereferenced.

* 

*  Parameters: Gives explicit counts for the size and length of the buffer.

* 

*  <> : There is no explicit count. Use when neither _ecount nor _bcount is

*  used.

*

*  (size) : Only the buffer's total size is given. Use with _ecount or _bcount

*  but not _part.

*

*  (size,length) : The buffer's total size and initialized length are

*  given. Use with _ecount_part and _bcount_part.

* 

*  ----------------------------------------------------------------------------

*  Buffer Annotation Examples

* 

*  LWSTDAPI_(BOOL) StrToIntExA(

*      LPCSTR pszString,  //  No annotation required, const implies __in.

*      DWORD dwFlags,

*      __out int *piRet   // A pointer whose dereference will be filled in.

*  );

* 

*  void MyPaintingFunction(

*      __in HWND hwndControl,     //  An initialized read-only parameter.

*      __in_opt HDC hdcOptional,  //  An initialized read-only parameter that 

*                                 //  might be NULL.

*      __inout IPropertyStore *ppsStore // An initialized parameter that 

*                                       // may be freely used and modified.

*  );

* 

*  LWSTDAPI_(BOOL) PathCompactPathExA(

*      __out_ecount(cchMax) LPSTR pszOut, //  A string buffer with cch elements

*                                         //  that will be '\0' terminated 

*                                         //  on exit.

*      LPCSTR pszSrc,                     //  No annotation required, 

*                                         //  const implies __in.

*      UINT cchMax,                              

*      DWORD dwFlags

*  );

* 

*  HRESULT SHLocalAllocBytes(

*      size_t cb,

*      __deref_bcount(cb) T **ppv //  A pointer whose dereference will be set

*                                 //  to an uninitialized buffer with cb bytes.

*  );

* 

*  __inout_bcount_full(cb) : A buffer with cb elements that is fully

*  initialized at entry and exit, and may be written to by this function.

* 

*  __out_ecount_part(count, *countOut) : A buffer with count elements that

*  will be partially initialized by this function. The function indicates how

*  much it initialized by setting *countOut.

* 

************************************************************************/
# 321 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h" 1
/******************************************************************************                                                                             *
 *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *

*                 See also <SpecStrings.h>                                    *

*                                                                             *

* Version 1.2.10                                                              *

*                                                                             *

* Copyright (c) Microsoft Corporation. All rights reserved.                   *

*                                                                             *

\*****************************************************************************/
# 12 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
/****************************************************************************** NOTE																		  *
 *
* NOTE																		  *

* NOTE																		  *

*   The macro bodies in this file are subject to change without notice.       *

*   Attempting to use the annotations in the macro bodies directly is not     *

*   supported.																  *

* NOTE																		  *

* NOTE																		  *

* NOTE																		  *

\*****************************************************************************/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
/****************************************************************************** The annotations described by KernelSpecs.h and DriverSpecs.h, taken together,
r,
* are used to annotate drivers.  Many of the annotations are applicable to

* user space code (including subsystems) as well as to drivers.

*

* DriverSpecs.h contains those annotations which are appropriate to userspace

* code, or which might appear in headers that are shared between user space

* and kernel space.  In the case of annotations which might appear in such a

* shared header, but which are meaningless in user space, the annotations are

* #defined to nothing in DriverSpecs.h.

*

* KernelSpecs.h contains those annotations which either will only appear in

* kernel code or headers; or which might appear in shared headers.  In the

* latter case, it is assumed that DriverSpecs.h has been #included, and

* the anntoations are re-defined (using #undef) to give them a meaningful

* value.  In general, documentation for the shared-header annotations appears

* in DriverSpecs.h.

*

* Many annotations are context dependent.  They only apply to certain versions

* of Windows, or only to certain classes of driver.  These rules can be written

* using something like __drv_when(NTDDI_VERSION >= NTDDI_WINXP, ...)

* which causes the rule only to apply to Windows XP and later.  Many of these

* symbols are already defined in various Windows headers.

*

* To facilitate using this sort of conditional rule, we collect here the

* various known symbols that are (or reasonably might) be used in such

* a conditional annotation.  Some are speculative in that the symbol has

* not yet been defined because there are no known uses of it yet.

*

* Where the symbol already exists its relevant header is

* noted below (excluding the "really well known" ones).

*

* Each symbol is listed with the currently known possible values.

*

* Some symbols are marked as #define symbols -- they are used with #ifdef

* operators only.  To use them in __drv_when, use something like

* __drv_when(__drv_defined(NT), ...).

*

* WDK Version (copied for convenience from sdkddkver.h)

*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3 

*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2 

*					 NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA

*     The WDK version is taken as the WDM version as well.

*

* OS Version: (copied for convenience from sdkddkver.h)

*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP 

*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN

*     WINVER: 0x030B 0x0400 0x0500 0x0600

*     NT (#define symbol)

* (sdkddkver.h also defines symbols for IE versions should they be needed.)

*

* Compiler Version:

*	  _MSC_VER: too many to list.

*	  _MSC_FULL_VER: too many to list.

*

* KMDF Version:  (Currently defined/used only in makefiles.)

*     KMDF_VERSION_MAJOR: 1     

*

* UMDF Version:  (Currently defined/used only in makefiles.)

*     UMDF_VERSION_MAJOR: 1     

*

* Architecture kinds:

*     __WIN64 (#define symbols)

*     _X86_

*     _AMD64_

*     _IA64_ 

*

* Machine Architectures:

*     _M_IX86

*     _M_AMD64

*     _M_IA64

*

* Driver Kind (NYI: "not yet implemented")

*   Typically these will be defined in the most-common header for a 

*   particular driver (or in individual source files if appropriate).

*   These are not intended to necessarily be orthogonal: more than one might 

*   apply to a particular driver.

*     _DRIVER_TYPE_BUS: 1                // NYI

*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI

*     _DRIVER_TYPE_MINIPORT: 1           // NYI

*     _DRIVER_TYPE_STORAGE: 1            // NYI

*     _DRIVER_TYPE_DISPLAY: 1            // NYI

*     _DRIVER_TYPE_FILESYSTEM: 1

*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1

*

* NDIS driver version: (see ndis.h for much more detail.)

*   These can be used to both identify an NDIS driver and to check the version.

*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)

*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0

*     And many others in ndis.h (including MINIPORT)

*

\*****************************************************************************/
# 118 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
#define DRIVERSPECS_H 

// In case driverspecs.h is included directly (and w/o specstrings.h)




# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/sdv_driverspecs.h" 1

// general purpose save 
//-----------------------
#define __sdv_save_request(r) 
// general purpose retrieve 
//-----------------------
#define __sdv_retrieve_request(r) 

// NDIS AdapterContext save 
//-----------------------
#define __sdv_save_adapter_context(c) 
# 126 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h" 2
# 141 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
#define __drv_declspec(x) 
#define __$drv_group(x) 
# 251 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
#define __internal_kernel_driver 
#define __kernel_code 
#define __kernel_driver 
#define __user_driver 
#define __user_code 
#define __drv_Mode_impl(x) 
#define __drv_WDM 
#define __drv_KMDF 
#define __drv_NDIS 
#define __prefast_operator_new_throws 
#define __prefast_operator_new_null 




 // core macros: these provide syntatic wrappers to make other uses
 // simpler.
 // (Note: right now we can't safely use the ellipsis (...) macro
 // syntax.  If we could then '##__drv_nop(annotes)' below could be 
 // simply 'annotes', and we could code __$drv_group as __$drv_group(...) 
 // in the "expands to nothing" case.)
 //
 // For example:
 //	 __drv_in(__drv_nonconstant __setsIRQL)

#define __drv_deref(annotes) __deref __$drv_group( ##__drv_nop(annotes))
#define __drv_in(annotes) __pre __$drv_group( ##__drv_nop(annotes))
#define __drv_in_deref(annotes) __pre __deref __$drv_group( ##__drv_nop(annotes))
#define __drv_out(annotes) __post __$drv_group( ##__drv_nop(annotes))
#define __drv_out_deref(annotes) __post __deref __$drv_group( ##__drv_nop(annotes))
#define __drv_when(cond,annotes) __drv_declspec("SAL_when(" SPECSTRINGIZE(cond) ")") __$drv_group( ##__drv_nop(annotes))

#define __drv_at(expr,annotes) __drv_declspec("SAL_at(" SPECSTRINGIZE(expr) ")") __$drv_group( ##__drv_nop(annotes))


#define __drv_fun(annotes) __drv_at(return, ##__drv_nop(annotes))
#define __drv_ret(annotes) __drv_at(return, ##__drv_nop(annotes))
#define __drv_arg(expr,annotes) __drv_at(expr, ##__drv_nop(annotes))
#define __drv_unit(p) typedef int __$drv_unit_ ##p $GENSYM(__prefast_flag_kernel_driver_mode);



 // Internal macros for convenience
#define __$drv_unit_internal_kernel_driver __drv_declspec("SAL_internal_kernel_driver")


 //
 // __drv_unit
 //
 // Flags for compilation units that indicated specifically what kind of
 // code it is.
 // These should be coded as early as possible in any compilation unit
 // (.c/.cpp file) that doesn't get the correct default.	 Whether before
 // or after __internal_kernel_driver is immaterial as long as it will
 // successfully parse.
 //
 // Indicate that the code is kernel, but not driver, code.
#define __$drv_unit_kernel_code __drv_declspec("SAL_kernel") __drv_declspec("SAL_nodriver")


 // Indicate that the code is kernel, driver, code.
#define __$drv_unit_kernel_driver __drv_declspec("SAL_kernel") __drv_declspec("SAL_driver")


 // Indicate that the code is a user mode driver.
#define __$drv_unit_user_driver __drv_declspec("SAL_nokernel") __drv_declspec("SAL_driver")


 // Indicate that the code is ordinary user mode code.
#define __$drv_unit_user_code __drv_declspec("SAL_nokernel") __drv_declspec("SAL_nodriver")



 // These are needed for backwards compatability.
# 335 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
 // ---------------------------------------------------------------------
 // Syntatic utilities:
 // 
 // Needed to make the annotations convenient to use.
 //
 // So we can use a macro name that might be used in #ifdef context,
 // where it's defined with no value.  
 // This should only be used inside a __drv_when condition.
 //
#define __drv_defined(x) macroDefined$( #x )

 // ---------------------------------------------------------------------
 // Callback properties:
 //
 // __drv_functionClass(x)
 //
 // Flag that the  the annotated function
 // is a member of that function class.	Some class names are recognized
 // by PREfast itself for special treatment.
 // This can be tested by the condition function inFunctionClass$()
 //

#define __drv_functionClass(x) __drv_out(__drv_declspec("SAL_functionClass(\""#x"\")"))


 // ---------------------------------------------------------------------
 // Resources:
 // 
 // __drv_acquiresResource(kind)
 // __drv_releasesResource(kind)
 // __drv_acquiresResourceGlobal(kind,param)
 // __drv_releasesResourceGlobal(kind,param)
 // __drv_mustHold(kind)
 // __drv_neverHold(kind)
 // __drv_mustHoldGlobal(kind,param)
 // __drv_neverHoldGlobal(kind,param)
 //
 // Flag that the annotated parameter acquires a resource of type kind.
 //

#define __drv_acquiresResource(kind) __post __drv_declspec("SAL_acquire(\"" #kind "\")")


 //
 // Flag that the annotated parameter releases a resource of type kind.
 //

#define __drv_releasesResource(kind) __post __drv_declspec("SAL_release(\"" #kind "\")")


 //
 // Flag that the annotated object acquires a global (otherwise anonymous)
 // resource of type kind named by param.
 //

#define __drv_innerAcquiresGlobal(kind,param) __post __drv_declspec("SAL_acquireGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")")


#define __drv_acquiresResourceGlobal(kind,param) __drv_innerAcquiresGlobal(kind, param)

 //
 // Flag that the annotated object acquires a global (otherwise anonymous)
 // resource of type kind named by param.
 //

#define __drv_innerReleasesGlobal(kind,param) __post __drv_declspec("SAL_releaseGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")")


#define __drv_releasesResourceGlobal(kind,param) __drv_innerReleasesGlobal(kind, param)


 //
 // Flag that the annotated parameter must hold a resource of type kind
 //

#define __drv_mustHold(kind) __pre __drv_declspec("SAL_mustHold(\""#kind"\")")


 //
 // Flag that the annotated object must hold a global resource
 // of type kind named by param.
 //

#define __drv_innerMustHoldGlobal(kind,param) __pre __drv_declspec("SAL_mustHoldGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")")


#define __drv_mustHoldGlobal(kind,param) __drv_innerMustHoldGlobal(kind, param)


 //
 // Flag that the annotated parameter must never hold a resource of type kind
 //

#define __drv_neverHold(kind) __pre __drv_declspec("SAL_neverHold(\"" #kind "\")")


 //
 // Flag that the annotated object must never hold a global resource
 // of type kind named by param.
 //

#define __drv_innerNeverHoldGlobal(kind,param) __pre __drv_declspec("SAL_neverHoldGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")")


#define __drv_neverHoldGlobal(kind,param) __drv_innerNeverHoldGlobal(kind, param)


 // Predicates to determine if a resource is held



 // ---------------------------------------------------------------------
 // Maintenance of IRQL values
 //
 // __drv_setsIRQL(irql)
 // __drv_raisesIRQL(irql)
 // __drv_requiresIRQL(irql)
 // __drv_maxIRQL(irql)
 // __drv_minIRQL(irql)
 // __drv_savesIRQL
 // __drv_restoresIRQL
 // __drv_savesIRQLGlobal(kind,param)
 // __drv_restoresIRQLGlobal(kind,param)
 // __drv_minFunctionIRQL(irql)
 // __drv_maxFunctionIRQL(irql)
 // __drv_useCancelIRQL
 // __drv_sameIRQL

 // 
 // The funciton exits at IRQL irql
 //
#define __drv_setsIRQL(irql) 

 // 
 // The funciton exits at IRQL irql, but this may only raise the irql.
 //
#define __drv_raisesIRQL(irql) 

 // 
 // The called function must be entered at IRQL level
 //
#define __drv_requiresIRQL(irql) 


 // 
 // The maximum IRQL at which the function may be called.
 //
#define __drv_maxIRQL(irql) 

 // 
 // The minimum IRQL at which the function may be called.
 //
#define __drv_minIRQL(irql) 

 // 
 // The current IRQL is saved in the annotated parameter
 //
#define __drv_savesIRQL 

 // 
 // The current IRQL is saved in the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
#define __drv_savesIRQLGlobal(kind,param) 

 // 
 // The current IRQL is restored from the annotated parameter
 //
#define __drv_restoresIRQL 

 // 
 // The current IRQL is restored from the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
#define __drv_restoresIRQLGlobal(kind,param) 

 // The minimum IRQL to which the function can lower itself.	 The IRQL
 // at entry is assumed to be that value unless overridden.
#define __drv_minFunctionIRQL(irql) 

 // The maximum IRQL to which the function can raise itself.
#define __drv_maxFunctionIRQL(irql) 

 // The function must exit with the same IRQL it was entered with.
 // (It may change it but it must restore it.)
#define __drv_sameIRQL 

 // The annotated parameter contains the cancelIRQL, which will be restored
 // by the called function.

#define __drv_useCancelIRQL 

 // ---------------------------------------------------------------------
 // Specific function behaviors

    // The annotated function clears the requirement that DoInitializeing
 // is cleared (or not).

#define __drv_clearDoInit(yesNo) __post __drv_declspec("SAL_clearDoInit(" SPECSTRINGIZE(yesNo) ")")


 // This is (or is like) IoGetDmaAdapter: look for misuse of DMA pointers

#define __drv_IoGetDmaAdapter __post __drv_declspec("SAL_IoGetDmaAdapter")


 // ---------------------------------------------------------------------
 // Function and out parameter return values.
 //
 // __drv_valueIs(<list>)
 //
 // The function being annotated will return each of the specified values
 // during simulation.  The items in the list are <relational op><constant>,
 // e.g. ==0 or <0.
 // This is a ; separated list of values.  The internal parser will accept
 // a comma-separated list.  In the future __VA_ARGS__ could be used.
 // See the documentation for use of this.
 //


#define __drv_valueIs(arglist) __post __drv_declspec("SAL_return("SPECSTRINGIZE(arglist)")")


 // ---------------------------------------------------------------------
 // Additional parameter checking.
 //
 // __drv_constant
 // __drv_nonConstant
 // __drv_strictTypeMatch(mode)
 // __drv_strictType(type,mode)
 //
 // The actual parameter must evaluate to a constant (not a const).
 //

#define __drv_constant __pre __drv_declspec("SAL_constant(__yes)")

 //
 // The actual parameter may never evaluate to a numeric constant 
 // (exclusive of a const symbol).
 //
#define __drv_nonConstant __pre __drv_declspec("SAL_constant(__no)")

 //
 // The actual parameter must match the type of the annotated formal
 // within the specifications set by mode.
 //

#define __drv_strictTypeMatch(mode) __pre __drv_declspec("SAL_strictTypeMatch("SPECSTRINGIZE(mode)")")


 //
 // The actual parameter must match the type of typename (below) 
 // within the specifications set by mode.
 //
 // currently 1/2 args
#define __drv_strictType(typename,mode) __pre __drv_declspec("SAL_strictType("SPECSTRINGIZE(typename)"," SPECSTRINGIZE(mode)")")


 //
 //    The following modes are defined:
#define __drv_typeConst 0
#define __drv_typeCond 1
#define __drv_typeBitset 2
#define __drv_typeExpr 3
 // 
 // The actual parameter must be data (not a pointer).  Used to
 // prevent passing pointers to pointers when pointers to structures
 // are needed (because &pXXX is a common error when pXXX is 
 // intended).

#define __drv_notPointer __pre __drv_declspec("SAL_mayBePointer(__no)")
 //
 // Convenience for the most common form of the above.
#define __drv_isObjectPointer __drv_deref(__drv_notPointer)

 // ---------------------------------------------------------------------
 // Memory management
 //
 // __drv_aliasesMem
 // __drv_allocatesMem
 // __drv_freesMem
 //
 // The annotated parameter is "kept" by the function, creating an
 // alias, and relieving any obligation to free the object.
 //

#define __drv_aliasesMem __post __drv_declspec("SAL_IsAliased")

 //
 // Allocate/release memory-like objects.
 // Kind is unused, but should be "mem" for malloc/free
 // and "object" for new/delete.

#define __drv_allocatesMem(kind) __post __drv_declspec("SAL_NeedsRelease(__yes)")

#define __drv_freesMem(kind) __post __drv_declspec("SAL_NeedsRelease(__no)")

 // ---------------------------------------------------------------------
 // Additional diagnostics
 //
 // __drv_preferredFunction
 // __drv_reportError
 //
 //
 // Function 'func' should be used for reason 'why'.	 Often used
 // conditionally.
 //

#define __drv_preferredFunction(func,why) __pre __drv_declspec( "SAL_preferredFunction(" SPECSTRINGIZE(func) "," SPECSTRINGIZE(why) ")")




 //
 // The error given by 'why' was detected.  Used conditionally.
 //

#define __drv_reportError(why) __pre __drv_declspec("SAL_error(" SPECSTRINGIZE(why) ")")


 // ---------------------------------------------------------------------
 // Floating point save/restore:
 //
 // __drv_floatSaved
 // __drv_floatRestored
 // __drv_floatUsed
 //
 // The floating point hardware was saved (available to kernel)

#define __drv_floatSaved __post __drv_declspec("SAL_floatSaved")

 //
 // The floating point hardware was restored (no longer available)

#define __drv_floatRestored __post __drv_declspec("SAL_floatRestored")

 //
 // The function uses floating point.  Functions with floating point
 // in their type signature get this automatically.

#define __drv_floatUsed __post __drv_declspec("SAL_floatUsed")

 // ---------------------------------------------------------------------
 // Usage:
 // 
 // __drv_interlocked
 // __drv_inTry
 // __drv_notInTry
 //
 // The parameter is used for interlocked instructions.

#define __drv_interlocked __pre __drv_declspec("SAL_interlocked")

 // The function must be called inside a try block

#define __drv_inTry __pre __drv_declspec("SAL_inTry(__yes)")

 // The function must not be called inside a try block
#define __drv_notInTry __pre __drv_declspec("SAL_inTry(__no)")

 // ---------------------------------------------------------------------
 // FormatString:
 //
 // kind can be "printf", "scanf", "strftime" or "FormatMessage".

#define __drv_formatString(kind) __drv_declspec("SAL_IsFormatString(\"" #kind "\")")


 // ---------------------------------------------------------------------
 // SDV support: see the SDV documentation for details

 // Identify dispatch callback types

#define __drv_dispatchType(kindlist) __pre __drv_declspec("SAL_dispatchType(" SPECSTRINGIZE(kindlist) ")" )



 // Identify dispatch callback types - special case
#define __drv_dispatchType_other __drv_dispatchType(-1)


 // Identify completion callback types
 
#define __drv_completionType(kindlist) __drv_declspec("SAL_completionType(" #kindlist ")" )




 // Identify callback types (FDO or PDO)
#define __drv_callbackType(kind) __drv_declspec("SAL_callbackType(" #kind ")" )


 // ---------------------------------------------------------------------
 // Composite:
# 811 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/driverspecs.h"
#define __drv_acquiresExclusiveResource(kind) 
#define __drv_releasesExclusiveResource(kind) 
#define __drv_acquiresExclusiveResourceGlobal(kind,param) 
#define __drv_releasesExclusiveResourceGlobal(kind,param) 
#define __drv_acquiresCancelSpinLock 
#define __drv_releasesCancelSpinLock 
#define __drv_mustHoldCancelSpinLock 
#define __drv_holdsCancelSpinLock() 
#define __drv_neverHoldCancelSpinLock 
#define __drv_acquiresCriticalRegion 
#define __drv_releasesCriticalRegion 
#define __drv_mustHoldCriticalRegion 
#define __drv_neverHoldCriticalRegion 
#define __drv_holdsCriticalRegion() 
#define __drv_acquiresPriorityRegion 
#define __drv_releasesPriorityRegion 
#define __drv_mustHoldPriorityRegion 
#define __drv_neverHoldPriorityRegion 
#define __drv_holdsPriorityRegion() 



 // Passing the cancel Irql to a utility function
#define __drv_isCancelIRQL 

   

 // Check if this is kernel or driver code


# 324 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/specstrings.h" 2
# 78 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h" 1
/******************************************************************************                                                                             *
 *
* KernelSpecs.h - markers for documenting the semantics of driver APIs        *

*                 See DriverSpecs.h for detailed comments                     *

*                 See also <SpecStrings.h>                                    *

*                                                                             *

* Version 1.2.00                                                              *

*                                                                             *

* Copyright (c) Microsoft Corporation. All rights reserved.                   *

*                                                                             *

\*****************************************************************************/
# 13 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
/****************************************************************************** NOTE																		  *
 *
* NOTE																		  *

* NOTE																		  *

*   The macro bodies in this file are subject to change without notice.       *

*   Attempting to use the annotations in the macro bodies directly is not     *

*   supported.																  *

* NOTE																		  *

* NOTE																		  *

* NOTE																		  *

\*****************************************************************************/
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
/****************************************************************************** As noted in DriverSpecs.h, this header contains "real" definitions for
or
* annotations that either never appear in user space, or which are meaningles

* in user space and are #defined to nothing by DriverSpecs.h.

*

* Further commentary appears in DriverSpecs.h.

\*****************************************************************************/
# 33 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/DriverSpecs.h" 1
/******************************************************************************                                                                             *
 *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *

*                 See also <SpecStrings.h>                                    *

*                                                                             *

* Version 1.2.10                                                              *

*                                                                             *

* Copyright (c) Microsoft Corporation. All rights reserved.                   *

*                                                                             *

\*****************************************************************************/
# 12 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/DriverSpecs.h"
/****************************************************************************** NOTE																		  *
 *
* NOTE																		  *

* NOTE																		  *

*   The macro bodies in this file are subject to change without notice.       *

*   Attempting to use the annotations in the macro bodies directly is not     *

*   supported.																  *

* NOTE																		  *

* NOTE																		  *

* NOTE																		  *

\*****************************************************************************/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/DriverSpecs.h"
/****************************************************************************** The annotations described by KernelSpecs.h and DriverSpecs.h, taken together,
r,
* are used to annotate drivers.  Many of the annotations are applicable to

* user space code (including subsystems) as well as to drivers.

*

* DriverSpecs.h contains those annotations which are appropriate to userspace

* code, or which might appear in headers that are shared between user space

* and kernel space.  In the case of annotations which might appear in such a

* shared header, but which are meaningless in user space, the annotations are

* #defined to nothing in DriverSpecs.h.

*

* KernelSpecs.h contains those annotations which either will only appear in

* kernel code or headers; or which might appear in shared headers.  In the

* latter case, it is assumed that DriverSpecs.h has been #included, and

* the anntoations are re-defined (using #undef) to give them a meaningful

* value.  In general, documentation for the shared-header annotations appears

* in DriverSpecs.h.

*

* Many annotations are context dependent.  They only apply to certain versions

* of Windows, or only to certain classes of driver.  These rules can be written

* using something like __drv_when(NTDDI_VERSION >= NTDDI_WINXP, ...)

* which causes the rule only to apply to Windows XP and later.  Many of these

* symbols are already defined in various Windows headers.

*

* To facilitate using this sort of conditional rule, we collect here the

* various known symbols that are (or reasonably might) be used in such

* a conditional annotation.  Some are speculative in that the symbol has

* not yet been defined because there are no known uses of it yet.

*

* Where the symbol already exists its relevant header is

* noted below (excluding the "really well known" ones).

*

* Each symbol is listed with the currently known possible values.

*

* Some symbols are marked as #define symbols -- they are used with #ifdef

* operators only.  To use them in __drv_when, use something like

* __drv_when(__drv_defined(NT), ...).

*

* WDK Version (copied for convenience from sdkddkver.h)

*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3 

*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2 

*					 NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA

*     The WDK version is taken as the WDM version as well.

*

* OS Version: (copied for convenience from sdkddkver.h)

*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP 

*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN

*     WINVER: 0x030B 0x0400 0x0500 0x0600

*     NT (#define symbol)

* (sdkddkver.h also defines symbols for IE versions should they be needed.)

*

* Compiler Version:

*	  _MSC_VER: too many to list.

*	  _MSC_FULL_VER: too many to list.

*

* KMDF Version:  (Currently defined/used only in makefiles.)

*     KMDF_VERSION_MAJOR: 1     

*

* UMDF Version:  (Currently defined/used only in makefiles.)

*     UMDF_VERSION_MAJOR: 1     

*

* Architecture kinds:

*     __WIN64 (#define symbols)

*     _X86_

*     _AMD64_

*     _IA64_ 

*

* Machine Architectures:

*     _M_IX86

*     _M_AMD64

*     _M_IA64

*

* Driver Kind (NYI: "not yet implemented")

*   Typically these will be defined in the most-common header for a 

*   particular driver (or in individual source files if appropriate).

*   These are not intended to necessarily be orthogonal: more than one might 

*   apply to a particular driver.

*     _DRIVER_TYPE_BUS: 1                // NYI

*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI

*     _DRIVER_TYPE_MINIPORT: 1           // NYI

*     _DRIVER_TYPE_STORAGE: 1            // NYI

*     _DRIVER_TYPE_DISPLAY: 1            // NYI

*     _DRIVER_TYPE_FILESYSTEM: 1

*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1

*

* NDIS driver version: (see ndis.h for much more detail.)

*   These can be used to both identify an NDIS driver and to check the version.

*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)

*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0

*     And many others in ndis.h (including MINIPORT)

*

\*****************************************************************************/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h" 2
# 43 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/kernelspecs.h"
 // ---------------------------------------------------------------------
 // The symbolic IRQL values can sometimes end up undefined, so define
 // the usual ones here, for PREfast purposes only.

#define DISPATCH_LEVEL 2
#define APC_LEVEL 1
#define PASSIVE_LEVEL 0

 // ---------------------------------------------------------------------
 // Maintenance of IRQL values
 //
 // __drv_setsIRQL(irql)
 // __drv_raisesIRQL(irql)
 // __drv_requiresIRQL(irql)
 // __drv_maxIRQL(irql)
 // __drv_minIRQL(irql)
 // __drv_savesIRQL
 // __drv_restoresIRQL
 // __drv_savesIRQLGlobal(kind,param)
 // __drv_restoresIRQLGlobal(kind,param)
 // __drv_minFunctionIRQL(irql)
 // __drv_maxFunctionIRQL(irql)
 // __drv_useCancelIRQL
 // __drv_sameIRQL

 // 
 // The funciton exits at IRQL irql
 //
 // ';' inside the parens to keep MIDL happy

#undef __drv_setsIRQL
#define __drv_setsIRQL(irql) __post __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")


 // 
 // The funciton exits at IRQL irql, but this may only raise the irql.
 //
#undef __drv_raisesIRQL

#define __drv_raisesIRQL(irql) __post __drv_declspec("SAL_raiseIRQL("SPECSTRINGIZE(irql)")")


 // 
 // The called function must be entered at IRQL level
 //
#undef __drv_requiresIRQL

#define __drv_requiresIRQL(irql) __pre __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")



 // 
 // The maximum IRQL at which the function may be called.
 //
#undef __drv_maxIRQL

#define __drv_maxIRQL(irql) __pre __drv_declspec("SAL_maxIRQL("SPECSTRINGIZE(irql)")")

 // 
 // The minimum IRQL at which the function may be called.
 //
#undef __drv_minIRQL

#define __drv_minIRQL(irql) __pre __drv_declspec("SAL_minIRQL("SPECSTRINGIZE(irql)")")


 // 
 // The current IRQL is saved in the annotated parameter
 //
#undef __drv_savesIRQL

#define __drv_savesIRQL __post __drv_declspec("SAL_saveIRQL")

 // 
 // The current IRQL is saved in the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
#undef __drv_savesIRQLGlobal

#define __drv_savesIRQLGlobal(kind,param) __post __drv_declspec("SAL_saveIRQLGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")")



 // 
 // The current IRQL is restored from the annotated parameter
 //
#undef __drv_restoresIRQL

#define __drv_restoresIRQL __post __drv_declspec("SAL_restoreIRQL")

 // 
 // The current IRQL is restored from the (otherwise anonymous) global object
 // identified by kind and further refined by param.
 //
#undef __drv_restoresIRQLGlobal

#define __drv_restoresIRQLGlobal(kind,param) __post __drv_declspec("SAL_restoreIRQLGlobal(\"" #kind "\"," SPECSTRINGIZE(param\t)")")



 // The minimum IRQL to which the function can lower itself.	 The IRQL
 // at entry is assumed to be that value unless overridden.
#undef __drv_minFunctionIRQL

#define __drv_minFunctionIRQL(irql) __pre __drv_declspec("SAL_minFunctionIrql(" SPECSTRINGIZE(irql) ")")



 // The maximum IRQL to which the function can raise itself.
#undef __drv_maxFunctionIRQL

#define __drv_maxFunctionIRQL(irql) __pre __drv_declspec("SAL_maxFunctionIrql(" SPECSTRINGIZE(irql) ")")


 // The function must exit with the same IRQL it was entered with.
 // (It may change it but it must restore it.)
#undef __drv_sameIRQL

#define __drv_sameIRQL __post __drv_declspec("SAL_sameIRQL")


 // The annotated parameter contains the cancelIRQL, which will be restored
 // by the called function.

#undef __drv_useCancelIRQL

#define __drv_useCancelIRQL __post __drv_declspec("SAL_UseCancelIrql")
# 79 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
# 87 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define RESTRICTED_POINTER 
# 99 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#undef ALIGNMENT_MACHINE
#define UNALIGNED 
#define UNALIGNED64 




#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16





//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//






#define TYPE_ALIGNMENT(t) FIELD_OFFSET( struct { char x; t test; }, test )
# 138 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define PROBE_ALIGNMENT32(_s) TYPE_ALIGNMENT( DWORD )







//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//


#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]




# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    basetsd.h



Abstract:



    Type definitions for the basic sized types.



Author:



Revision History:



--*/
# 20 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
#define _BASETSD_H_ 
# 38 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
#define POINTER_64 

  typedef unsigned long POINTER_64_INT;

#define POINTER_32 





#define FIRMWARE_PTR POINTER_32


//
// A compiler with support for __sptr and __uptr is in qualification.  To
// participate in qualification, remove the "0 &&" term below and also
// enable warning 4826 in warning.w
// 





#define POINTER_SIGNED 
#define POINTER_UNSIGNED 


#define SPOINTER_32 POINTER_SIGNED POINTER_32
#define UPOINTER_32 POINTER_UNSIGNED POINTER_32
# 76 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
typedef signed char INT8, *PINT8;
typedef signed short INT16, *PINT16;
typedef signed int INT32, *PINT32;
typedef signed __int64 INT64, *PINT64;
typedef unsigned char UINT8, *PUINT8;
typedef unsigned short UINT16, *PUINT16;
typedef unsigned int UINT32, *PUINT32;
typedef unsigned __int64 UINT64, *PUINT64;

//
// The following types are guaranteed to be signed and 32 bits wide.
//

typedef signed int LONG32, *PLONG32;

//
// The following types are guaranteed to be unsigned and 32 bits wide.
//

typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
# 106 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
//
// The INT_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. UINT_PTR is
// the unsigned variation.
//
// __int3264 is intrinsic to 64b MIDL but not to old MIDL or to C compiler.
//
# 123 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
// old midl and C++ compiler


    typedef __int64 INT_PTR, *PINT_PTR;
    typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

    typedef __int64 LONG_PTR, *PLONG_PTR;
    typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

#define __int3264 __int64
# 146 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
//
// HALF_PTR is half the size of a pointer it intended for use with
// within structures which contain a pointer and two small fields.
// UHALF_PTR is the unsigned variation.
//



#define ADDRESS_TAG_BIT 0x40000000000UI64

typedef __int64 SHANDLE_PTR;
typedef unsigned __int64 HANDLE_PTR;
typedef unsigned int UHALF_PTR, *PUHALF_PTR;
typedef int HALF_PTR, *PHALF_PTR;


__inline
unsigned long
HandleToULong(
    const void *h
    )
{
    return((unsigned long) (ULONG_PTR) h );
}

__inline
long
HandleToLong(
    const void *h
    )
{
    return((long) (LONG_PTR) h );
}

__inline
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}


__inline
void *
LongToHandle(
    const long h
    )
{
    return((void *) (INT_PTR) h );
}


__inline
unsigned long
PtrToUlong(
    const void *p
    )
{
    return((unsigned long) (ULONG_PTR) p );
}

__inline
unsigned int
PtrToUint(
    const void *p
    )
{
    return((unsigned int) (UINT_PTR) p );
}

__inline
unsigned short
PtrToUshort(
    const void *p
    )
{
    return((unsigned short) (unsigned long) (ULONG_PTR) p );
}

__inline
long
PtrToLong(
    const void *p
    )
{
    return((long) (LONG_PTR) p );
}

__inline
int
PtrToInt(
    const void *p
    )
{
    return((int) (INT_PTR) p );
}

__inline
short
PtrToShort(
    const void *p
    )
{
    return((short) (long) (LONG_PTR) p );
}

__inline
void *
IntToPtr(
    const int i
    )
// Caution: IntToPtr() sign-extends the int value.
{
    return( (void *)(INT_PTR)i );
}

__inline
void *
UIntToPtr(
    const unsigned int ui
    )
// Caution: UIntToPtr() zero-extends the unsigned int value.
{
    return( (void *)(UINT_PTR)ui );
}

__inline
void *
LongToPtr(
    const long l
    )
// Caution: LongToPtr() sign-extends the long value.
{
    return( (void *)(LONG_PTR)l );
}

__inline
void *
ULongToPtr(
    const unsigned long ul
    )
// Caution: ULongToPtr() zero-extends the unsigned long value.
{
    return( (void *)(ULONG_PTR)ul );
}

#define PtrToPtr64(p) ((void * POINTER_64) p)
#define Ptr64ToPtr(p) ((void *) p)
#define HandleToHandle64(h) (PtrToPtr64( h ))
#define Handle64ToHandle(h) (Ptr64ToPtr( h ))

__inline
void *
Ptr32ToPtr(
    const void * p
    )
{
    return((void *) (ULONG_PTR) (unsigned long) p);
}

__inline
void *
Handle32ToHandle(
    const void * h
    )
{
    return((void *) (LONG_PTR) (long) h);
}

__inline
void *
PtrToPtr32(
    const void *p
    )
{
    return((void * ) (unsigned long) (ULONG_PTR) p);
}

#define HandleToHandle32(h) (PtrToPtr32( h ))
# 399 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/basetsd.h"
#define HandleToUlong(h) HandleToULong(h)
#define UlongToHandle(ul) ULongToHandle(ul)
#define UlongToPtr(ul) ULongToPtr(ul)
#define UintToPtr(ui) UIntToPtr(ui)

#define MAXUINT_PTR (~((UINT_PTR)0))
#define MAXINT_PTR ((INT_PTR)(MAXUINT_PTR >> 1))
#define MININT_PTR (~MAXINT_PTR)

#define MAXULONG_PTR (~((ULONG_PTR)0))
#define MAXLONG_PTR ((LONG_PTR)(MAXULONG_PTR >> 1))
#define MINLONG_PTR (~MAXLONG_PTR)

#define MAXUHALF_PTR ((UHALF_PTR)~0)
#define MAXHALF_PTR ((HALF_PTR)(MAXUHALF_PTR >> 1))
#define MINHALF_PTR (~MAXHALF_PTR)

//
// SIZE_T used for counts or ranges which need to span the range of
// of a pointer.  SSIZE_T is the signed variation.
//

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;



#define MAXUINT8 ((UINT8)~((UINT8)0))
#define MAXINT8 ((INT8)(MAXUINT8 >> 1))
#define MININT8 ((INT8)~MAXINT8)

#define MAXUINT16 ((UINT16)~((UINT16)0))
#define MAXINT16 ((INT16)(MAXUINT16 >> 1))
#define MININT16 ((INT16)~MAXINT16)

#define MAXUINT32 ((UINT32)~((UINT32)0))
#define MAXINT32 ((INT32)(MAXUINT32 >> 1))
#define MININT32 ((INT32)~MAXINT32)

#define MAXUINT64 ((UINT64)~((UINT64)0))
#define MAXINT64 ((INT64)(MAXUINT64 >> 1))
#define MININT64 ((INT64)~MAXINT64)

#define MAXULONG32 ((ULONG32)~((ULONG32)0))
#define MAXLONG32 ((LONG32)(MAXULONG32 >> 1))
#define MINLONG32 ((LONG32)~MAXLONG32)

#define MAXULONG64 ((ULONG64)~((ULONG64)0))
#define MAXLONG64 ((LONG64)(MAXULONG64 >> 1))
#define MINLONG64 ((LONG64)~MAXLONG64)

#define MAXULONGLONG ((ULONGLONG)~((ULONGLONG)0))
#define MINLONGLONG ((LONGLONG)~MAXLONGLONG)

#define MAXSIZE_T ((SIZE_T)~((SIZE_T)0))
#define MAXSSIZE_T ((SSIZE_T)(MAXSIZE_T >> 1))
#define MINSSIZE_T ((SSIZE_T)~MAXSSIZE_T)

#define MAXUINT ((UINT)~((UINT)0))
#define MAXINT ((INT)(MAXUINT >> 1))
#define MININT ((INT)~MAXINT)

#define MAXDWORD32 ((DWORD32)~((DWORD32)0))
#define MAXDWORD64 ((DWORD64)~((DWORD64)0))



//
// Add Windows flavor DWORD_PTR types
//

typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

//
// The following types are guaranteed to be signed and 64 bits wide.
//

typedef __int64 LONG64, *PLONG64;


//
// The following types are guaranteed to be unsigned and 64 bits wide.
//

typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;

//
// Legacy thread affinity.
//

typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;
# 160 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2





#define DECLSPEC_IMPORT 






#define DECLSPEC_NORETURN 







#define DECLSPEC_NOTHROW 







#define DECLSPEC_ALIGN(x) 







#define SYSTEM_CACHE_ALIGNMENT_SIZE 128




#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(SYSTEM_CACHE_ALIGNMENT_SIZE)






#define DECLSPEC_UUID(x) 







#define DECLSPEC_NOVTABLE 







#define DECLSPEC_SELECTANY 







#define NOP_FUNCTION (void)0







#define DECLSPEC_ADDRSAFE 







#define DECLSPEC_NOINLINE 







#define FORCEINLINE __inline
# 265 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define DECLSPEC_DEPRECATED 
#undef DEPRECATE_SUPPORTED
# 281 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define DECLSPEC_DEPRECATED_DDK 
#define PRAGMA_DEPRECATED_DDK 0


//
// Void
//

typedef void *PVOID;
typedef void * PVOID64;





#define _cdecl 
#define __cdecl 
#define NTAPI 



#define NTAPI_INLINE NTAPI




//
// Define API decoration for direct importing system DLL references.
//


#define NTSYSAPI DECLSPEC_IMPORT
#define NTSYSCALLAPI DECLSPEC_IMPORT
# 325 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Basics
//


#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;

typedef int INT;



//
// UNICODE (Wide Character) types
//


typedef wchar_t WCHAR; // wc,   16-bit UNICODE character





typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;

typedef WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef PWSTR *PZPWSTR;
typedef const PWSTR *PCZPWSTR;
typedef WCHAR *LPUWSTR, *PUWSTR;
typedef const WCHAR *LPCWSTR, *PCWSTR;
typedef PCWSTR *PZPCWSTR;
typedef const WCHAR *LPCUWSTR, *PCUWSTR;

typedef WCHAR *PZZWSTR;
typedef const WCHAR *PCZZWSTR;
typedef WCHAR *PUZZWSTR;
typedef const WCHAR *PCUZZWSTR;

typedef __possibly_notnullterminated WCHAR *PNZWCH;
typedef __possibly_notnullterminated const WCHAR *PCNZWCH;
typedef __possibly_notnullterminated WCHAR *PUNZWCH;
typedef __possibly_notnullterminated const WCHAR *PCUNZWCH;



typedef const WCHAR *LPCWCHAR, *PCWCHAR;
typedef const WCHAR *LPCUWCHAR, *PCUWCHAR;

//
//  UCS (Universal Character Set) types
//

typedef unsigned long UCSCHAR;

//
//  Even pre-Unicode agreement, UCS values are always in the
//  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
//  value.

#define UCSCHAR_INVALID_CHARACTER (0xffffffff)

#define MIN_UCSCHAR (0)

//
//  We'll assume here that the ISO-10646 / Unicode agreement
//  not to assign code points after U+0010FFFF holds so that
//  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
//  types.
//

#define MAX_UCSCHAR (0x0010FFFF)

typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR *PCUUCSSTR;

typedef UCSCHAR *PUUCSCHAR;
typedef const UCSCHAR *PCUUCSCHAR;




//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;

typedef CHAR *NPSTR, *LPSTR, *PSTR;
typedef PSTR *PZPSTR;
typedef const PSTR *PCZPSTR;
typedef const CHAR *LPCSTR, *PCSTR;
typedef PCSTR *PZPCSTR;

typedef CHAR *PZZSTR;
typedef const CHAR *PCZZSTR;

typedef __possibly_notnullterminated CHAR *PNZCH;
typedef __possibly_notnullterminated const CHAR *PCNZCH;

//
// Neutral ANSI/UNICODE types and macros
//
# 464 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED 


typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;
#define __TEXT(quote) quote


#define TEXT(quote) __TEXT(quote)


typedef SHORT *PSHORT;
typedef LONG *PLONG;

#define ALL_PROCESSOR_GROUPS 0xffff

//
// Structure to represent a system wide processor number. It contains a
// group number and relative processor number within the group.
//

typedef struct _PROCESSOR_NUMBER {
    WORD Group;
    BYTE Number;
    BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;

//
// Structure to represent a group-specific affinity, such as that of a
// thread.  Specifies the group number and the affinity within that group.
//

typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD Group;
    WORD Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;

//
// Handle to an Object
//


typedef void *HANDLE;



#define DECLARE_HANDLE(name) struct name ##__{int unused;}; typedef struct name ##__ *name





typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef BYTE FCHAR;
typedef WORD FSHORT;
typedef DWORD FLONG;

// Component Object Model defines, and macros


#define _HRESULT_DEFINED 



typedef long HRESULT;






#define EXTERN_C extern




// Win32 doesn't support __export




#define STDMETHODCALLTYPE __stdcall

#define STDMETHODVCALLTYPE __cdecl

#define STDAPICALLTYPE __stdcall
#define STDAPIVCALLTYPE __cdecl
# 577 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define STDAPI EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type) EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type) type STDMETHODCALLTYPE

#define STDOVERRIDEMETHODIMP __override STDMETHODIMP
#define STDOVERRIDEMETHODIMP_(type) __override STDMETHODIMP_(type)

#define IFACEMETHODIMP __override STDMETHODIMP
#define IFACEMETHODIMP_(type) __override STDMETHODIMP_(type)

// The 'V' versions allow Variable Argument lists.

#define STDAPIV EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type) EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type) type STDMETHODVCALLTYPE

#define STDOVERRIDEMETHODIMPV __override STDMETHODIMPV
#define STDOVERRIDEMETHODIMPV_(type) __override STDMETHODIMPV_(type)

#define IFACEMETHODIMPV __override STDMETHODIMPV
#define IFACEMETHODIMPV_(type) __override STDMETHODIMPV_(type)

typedef char CCHAR;
typedef DWORD LCID;
typedef PDWORD PLCID;
typedef WORD LANGID;
#define APPLICATION_ERROR_MASK 0x20000000
#define ERROR_SEVERITY_SUCCESS 0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING 0x80000000
#define ERROR_SEVERITY_ERROR 0xC0000000

//
// _M_IX86 included so that EM CONTEXT structure compiles with
// x86 programs. *** TBD should this be for all architectures?
//

//
// 16 byte aligned type for 128 bit floats
//

//
// For we define a 128 bit structure and use __declspec(align(16)) pragma to
// align to 128 bits.
//




typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_ 

typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG (0x7fffffffffffffff)
# 667 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;




typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    } s;
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;

    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;




typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } s;
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;

    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;

// end_ntminiport end_ntndis end_ntminitape


//
// Locally Unique Identifier
//

typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;

#define _DWORDLONG_ 
typedef ULONGLONG DWORDLONG;
typedef DWORDLONG *PDWORDLONG;


//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//
# 855 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Define rotate intrinsics.
//
# 955 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define ANSI_NULL ((CHAR)0)
#define UNICODE_NULL ((WCHAR)0)
#define UNICODE_STRING_MAX_BYTES ((WORD ) 65534)
#define UNICODE_STRING_MAX_CHARS (32767)
typedef BYTE BOOLEAN;
typedef BOOLEAN *PBOOLEAN;
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;


//
// These are needed for portable debugger support.
//

typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h" 1
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------


#define GUID_DEFINED 
# 22 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
typedef struct _GUID {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
} GUID;
# 64 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
#define DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) EXTERN_C const GUID FAR name



#define DEFINE_OLEGUID(name,l,w1,w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


#define _GUIDDEF_H_ 


#define __LPGUID_DEFINED__ 
typedef GUID *LPGUID;



#define __LPCGUID_DEFINED__ 
typedef const GUID *LPCGUID;



#define __IID_DEFINED__ 

typedef GUID IID;
typedef IID *LPIID;
#define IID_NULL GUID_NULL
#define IsEqualIID(riid1,riid2) IsEqualGUID(riid1, riid2)
typedef GUID CLSID;
typedef CLSID *LPCLSID;
#define CLSID_NULL GUID_NULL
#define IsEqualCLSID(rclsid1,rclsid2) IsEqualGUID(rclsid1, rclsid2)
typedef GUID FMTID;
typedef FMTID *LPFMTID;
#define FMTID_NULL GUID_NULL
#define IsEqualFMTID(rfmtid1,rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)




#define __MIDL_CONST const



#define _REFGUID_DEFINED 



#define REFGUID const GUID * __MIDL_CONST




#define _REFIID_DEFINED 



#define REFIID const IID * __MIDL_CONST




#define _REFCLSID_DEFINED 



#define REFCLSID const IID * __MIDL_CONST




#define _REFFMTID_DEFINED 



#define REFFMTID const IID * __MIDL_CONST







#define _SYS_GUID_OPERATORS_ 
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h" 1
/***

*string.h - declarations for string manipulation functions

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This file contains the function declarations for the string

*       manipulation functions.

*       [ANSI/System V]

*

*       [Public]

*

****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
       


#define _INC_STRING 

# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***

*crtdefs.h - definitions/declarations common to all CRT

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This file has mostly defines used by the entire CRT.

*

*       [Public]

*

****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */

/* Define _CRTIMP */
# 21 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h" 2






#define _NLSCMPERROR 2147483647
#define _NLSCMP_DEFINED 


/* Define NULL pointer value */
# 40 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
/* For backwards compatibility */
#define _WConst_return _CONST_RETURN

/* Function prototypes */

#define _CRT_MEMORY_DEFINED 
 void * _memccpy( void * _Dst, const void * _Src, int _Val, size_t _MaxCount);
 void * memchr( const void * _Buf , int _Val, size_t _MaxCount);
 int _memicmp( const void * _Buf1, const void * _Buf2, size_t _Size);
 int _memicmp_l( const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale);
        int memcmp( const void * _Buf1, const void * _Buf2, size_t _Size);
        void * memcpy( void * _Dst, const void * _Src, size_t _Size);

 errno_t memcpy_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);
# 88 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
        void * memset( void * _Dst, int _Val, size_t _Size);
# 98 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
 errno_t _strset_s( char * _Dst, size_t _DstSize, int _Value);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strset( char *_Dest, int _Value);

 errno_t strcpy_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src);


__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strcpy( char *_Dest, const char * _Source);

 errno_t strcat_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src);


__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strcat( char *_Dest, const char * _Source);
        int strcmp( const char * _Str1, const char * _Str2);
        size_t strlen( const char * _Str);
 size_t strnlen( const char * _Str, size_t _MaxCount);

 static __inline size_t strnlen_s( const char * _Str, size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}


 errno_t memmove_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);





 void * memmove( void * _Dst, const void * _Src, size_t _Size);







 char * _strdup( const char * _Src);





 char * strchr( const char * _Str, int _Val);
 int _stricmp( const char * _Str1, const char * _Str2);
 int _strcmpi( const char * _Str1, const char * _Str2);
 int _stricmp_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
 int strcoll( const char * _Str1, const char * _Str2);
 int _strcoll_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
 int _stricoll( const char * _Str1, const char * _Str2);
 int _stricoll_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
 int _strncoll ( const char * _Str1, const char * _Str2, size_t _MaxCount);
 int _strncoll_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);
 int _strnicoll ( const char * _Str1, const char * _Str2, size_t _MaxCount);
 int _strnicoll_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);
 size_t strcspn( const char * _Str, const char * _Control);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strerror( const char * _ErrMsg);
 errno_t _strerror_s( char * _Buf, size_t _SizeInBytes, const char * _ErrMsg);

 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strerror( int);

 errno_t strerror_s( char * _Buf, size_t _SizeInBytes, int _ErrNum);


 errno_t _strlwr_s( char * _Str, size_t _Size);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strlwr( char *_String);
 errno_t _strlwr_s_l( char * _Str, size_t _Size, _locale_t _Locale);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strlwr_l( char *_String, _locale_t _Locale);

 errno_t strncat_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount);


#pragma warning(push)
#pragma warning(disable:6059)
/* prefast noise VSW 489802 */
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strncat( char *_Dest, const char * _Source, size_t _Count);
#pragma warning(pop)



 int strncmp( const char * _Str1, const char * _Str2, size_t _MaxCount);

 int _strnicmp( const char * _Str1, const char * _Str2, size_t _MaxCount);
 int _strnicmp_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);

 errno_t strncpy_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount);


__attribute__((deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strncpy( char *_Dest, const char * _Source, size_t _Count);
 errno_t _strnset_s( char * _Str, size_t _SizeInBytes, int _Val, size_t _MaxCount);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strnset( char *_Dest, int _Val, size_t _Count);
 char * strpbrk( const char * _Str, const char * _Control);
 char * strrchr( const char * _Str, int _Ch);
 char * _strrev( char * _Str);
 size_t strspn( const char * _Str, const char * _Control);
 char * strstr( const char * _Str, const char * _SubStr);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * strtok( char * _Str, const char * _Delim);

 char * strtok_s( char * _Str, const char * _Delim, char ** _Context);

 errno_t _strupr_s( char * _Str, size_t _Size);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strupr( char *_String);
 errno_t _strupr_s_l( char * _Str, size_t _Size, _locale_t _Locale);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) char * _strupr_l( char *_String, _locale_t _Locale);
 size_t strxfrm ( char * _Dst, const char * _Src, size_t _MaxCount);
 size_t _strxfrm_l( char * _Dst, const char * _Src, size_t _MaxCount, _locale_t _Locale);
# 259 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
/* wide function prototypes, also declared in wchar.h  */






 wchar_t * _wcsdup( const wchar_t * _Str);






 errno_t wcscat_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src);


__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcscat( wchar_t *_Dest, const wchar_t * _Source);
 wchar_t * wcschr( const wchar_t * _Str, wchar_t _Ch);
 int wcscmp( const wchar_t * _Str1, const wchar_t * _Str2);

 errno_t wcscpy_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src);


__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcscpy( wchar_t *_Dest, const wchar_t * _Source);
 size_t wcscspn( const wchar_t * _Str, const wchar_t * _Control);
 size_t wcslen( const wchar_t * _Str);
 size_t wcsnlen( const wchar_t * _Src, size_t _MaxCount);

 static __inline size_t wcsnlen_s( const wchar_t * _Src, size_t _MaxCount)
{
    return (_Src == ((void *)0)) ? 0 : wcsnlen(_Src, _MaxCount);
}


 errno_t wcsncat_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src, rsize_t _MaxCount);


#pragma warning(push)
#pragma warning(disable:6059)
__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcsncat( wchar_t *_Dest, const wchar_t * _Source, size_t _Count);
#pragma warning(pop)
 int wcsncmp( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);

 errno_t wcsncpy_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src, rsize_t _MaxCount);


__attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcsncpy( wchar_t *_Dest, const wchar_t * _Source, size_t _Count);
 wchar_t * wcspbrk( const wchar_t * _Str, const wchar_t * _Control);
 wchar_t * wcsrchr( const wchar_t * _Str, wchar_t _Ch);
 size_t wcsspn( const wchar_t * _Str, const wchar_t * _Control);
 wchar_t * wcsstr( const wchar_t * _Str, const wchar_t * _SubStr);
 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * wcstok( wchar_t * _Str, const wchar_t * _Delim);

 wchar_t * wcstok_s( wchar_t * _Str, const wchar_t * _Delim, wchar_t ** _Context);

 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcserror( int _ErrNum);
 errno_t _wcserror_s( wchar_t * _Buf, size_t _SizeInWords, int _ErrNum);

 __attribute__((deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * __wcserror( const wchar_t * _Str);
 errno_t __wcserror_s( wchar_t * _Buffer, size_t _SizeInWords, const wchar_t * _ErrMsg);


 int _wcsicmp( const wchar_t * _Str1, const wchar_t * _Str2);
 int _wcsicmp_l( const wchar_t * _Str1, const wchar_t * _Str2, _locale_t _Locale);
 int _wcsnicmp( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
 int _wcsnicmp_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
 errno_t _wcsnset_s( wchar_t * _Dst, size_t _SizeInWords, wchar_t _Val, size_t _MaxCount);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsnset( wchar_t *_Str, wchar_t _Val, size_t _MaxCount);
 wchar_t * _wcsrev( wchar_t * _Str);
 errno_t _wcsset_s( wchar_t * _Dst, size_t _SizeInWords, wchar_t _Value);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsset( wchar_t *_Str, wchar_t _Val);

 errno_t _wcslwr_s( wchar_t * _Str, size_t _SizeInWords);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcslwr( wchar_t *_String);
 errno_t _wcslwr_s_l( wchar_t * _Str, size_t _SizeInWords, _locale_t _Locale);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcslwr_l( wchar_t *_String, _locale_t _Locale);
 errno_t _wcsupr_s( wchar_t * _Str, size_t _Size);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsupr( wchar_t *_String);
 errno_t _wcsupr_s_l( wchar_t * _Str, size_t _Size, _locale_t _Locale);

__attribute__((deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."))) wchar_t * _wcsupr_l( wchar_t *_String, _locale_t _Locale);
 size_t wcsxfrm( wchar_t * _Dst, const wchar_t * _Src, size_t _MaxCount);
 size_t _wcsxfrm_l( wchar_t * _Dst, const wchar_t *_Src, size_t _MaxCount, _locale_t _Locale);
 int wcscoll( const wchar_t * _Str1, const wchar_t * _Str2);
 int _wcscoll_l( const wchar_t * _Str1, const wchar_t * _Str2, _locale_t _Locale);
 int _wcsicoll( const wchar_t * _Str1, const wchar_t * _Str2);
 int _wcsicoll_l( const wchar_t * _Str1, const wchar_t *_Str2, _locale_t _Locale);
 int _wcsncoll( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
 int _wcsncoll_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
 int _wcsnicoll( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
 int _wcsnicoll_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
# 401 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/string.h"
#define _WSTRING_DEFINED 
# 147 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h" 2

// Faster (but makes code fatter) inline version...use sparingly
# 166 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
#define InlineIsEqualGUID(rguid1,rguid2) (((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] && ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] && ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] && ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3])





#define IsEqualGUID(rguid1,rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
# 181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/guiddef.h"
// Same type, different name

#define IsEqualIID(riid1,riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1,rclsid2) IsEqualGUID(rclsid1, rclsid2)



#define _SYS_GUID_OPERATOR_EQ_ 
// A couple of C++ helpers
# 999 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2


#define __OBJECTID_DEFINED 

typedef struct _OBJECTID { // size is 20
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;


#define MINCHAR 0x80
#define MAXCHAR 0x7f
#define MINSHORT 0x8000
#define MAXSHORT 0x7fff
#define MINLONG 0x80000000
#define MAXLONG 0x7fffffff
#define MAXBYTE 0xff
#define MAXWORD 0xffff
#define MAXDWORD 0xffffffff
//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type,field) ((LONG)(LONG_PTR)&(((type *)0)->field))

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type,field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type,field) (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))


//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct,Size,Field) ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )


//
// Return the number of elements in a statically sized array.
//   DWORD Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF_V1(A) (sizeof(A)/sizeof((A)[0]))
# 1125 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define RTL_NUMBER_OF_V2(A) RTL_NUMBER_OF_V1(A)





#define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V1(A)


//
// ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
// it regardless of ENABLE_RTL_NUMBER_OF_V2
//
// _ARRAYSIZE is a version useful for anonymous types
//
#define ARRAYSIZE(A) RTL_NUMBER_OF_V2(A)
#define _ARRAYSIZE(A) RTL_NUMBER_OF_V1(A)

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type,field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type,field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   DWORD Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T,F1,F2) ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))




// RTL_ to avoid collisions in the global namespace.



#define RTL_CONST_CAST(type) (type)



// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type,field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address,type,field) ((type *)( (PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))



// end_ntminiport end_ntndis

//
// Exception handler routine definition.
//



typedef


EXCEPTION_DISPOSITION

EXCEPTION_ROUTINE (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    PVOID EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    PVOID DispatcherContext
    );

typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;


#define VER_SERVER_NT 0x80000000
#define VER_WORKSTATION_NT 0x40000000
#define VER_SUITE_SMALLBUSINESS 0x00000001
#define VER_SUITE_ENTERPRISE 0x00000002
#define VER_SUITE_BACKOFFICE 0x00000004
#define VER_SUITE_COMMUNICATIONS 0x00000008
#define VER_SUITE_TERMINAL 0x00000010
#define VER_SUITE_SMALLBUSINESS_RESTRICTED 0x00000020
#define VER_SUITE_EMBEDDEDNT 0x00000040
#define VER_SUITE_DATACENTER 0x00000080
#define VER_SUITE_SINGLEUSERTS 0x00000100
#define VER_SUITE_PERSONAL 0x00000200
#define VER_SUITE_BLADE 0x00000400
#define VER_SUITE_EMBEDDED_RESTRICTED 0x00000800
#define VER_SUITE_SECURITY_APPLIANCE 0x00001000
#define VER_SUITE_STORAGE_SERVER 0x00002000
#define VER_SUITE_COMPUTE_SERVER 0x00004000
#define VER_SUITE_WH_SERVER 0x00008000


//
// Product types
// This list grows with each OS release.
//
// There is no ordering of values to ensure callers
// do an equality test i.e. greater-than and less-than
// comparisons are not useful.
//
// NOTE: Values in this list should never be deleted.
//       When a product-type 'X' gets dropped from a
//       OS release onwards, the value of 'X' continues
//       to be used in the mapping table of GetProductInfo.
//

#define PRODUCT_UNDEFINED 0x00000000

#define PRODUCT_ULTIMATE 0x00000001
#define PRODUCT_HOME_BASIC 0x00000002
#define PRODUCT_HOME_PREMIUM 0x00000003
#define PRODUCT_ENTERPRISE 0x00000004
#define PRODUCT_HOME_BASIC_N 0x00000005
#define PRODUCT_BUSINESS 0x00000006
#define PRODUCT_STANDARD_SERVER 0x00000007
#define PRODUCT_DATACENTER_SERVER 0x00000008
#define PRODUCT_SMALLBUSINESS_SERVER 0x00000009
#define PRODUCT_ENTERPRISE_SERVER 0x0000000A
#define PRODUCT_STARTER 0x0000000B
#define PRODUCT_DATACENTER_SERVER_CORE 0x0000000C
#define PRODUCT_STANDARD_SERVER_CORE 0x0000000D
#define PRODUCT_ENTERPRISE_SERVER_CORE 0x0000000E
#define PRODUCT_ENTERPRISE_SERVER_IA64 0x0000000F
#define PRODUCT_BUSINESS_N 0x00000010
#define PRODUCT_WEB_SERVER 0x00000011
#define PRODUCT_CLUSTER_SERVER 0x00000012
#define PRODUCT_HOME_SERVER 0x00000013
#define PRODUCT_STORAGE_EXPRESS_SERVER 0x00000014
#define PRODUCT_STORAGE_STANDARD_SERVER 0x00000015
#define PRODUCT_STORAGE_WORKGROUP_SERVER 0x00000016
#define PRODUCT_STORAGE_ENTERPRISE_SERVER 0x00000017
#define PRODUCT_SERVER_FOR_SMALLBUSINESS 0x00000018
#define PRODUCT_SMALLBUSINESS_SERVER_PREMIUM 0x00000019
#define PRODUCT_HOME_PREMIUM_N 0x0000001A
#define PRODUCT_ENTERPRISE_N 0x0000001B
#define PRODUCT_ULTIMATE_N 0x0000001C
#define PRODUCT_WEB_SERVER_CORE 0x0000001D
#define PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT 0x0000001E
#define PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY 0x0000001F
#define PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING 0x00000020
#define PRODUCT_SERVER_FOUNDATION 0x00000021
#define PRODUCT_HOME_PREMIUM_SERVER 0x00000022
#define PRODUCT_SERVER_FOR_SMALLBUSINESS_V 0x00000023
#define PRODUCT_STANDARD_SERVER_V 0x00000024
#define PRODUCT_DATACENTER_SERVER_V 0x00000025
#define PRODUCT_ENTERPRISE_SERVER_V 0x00000026
#define PRODUCT_DATACENTER_SERVER_CORE_V 0x00000027
#define PRODUCT_STANDARD_SERVER_CORE_V 0x00000028
#define PRODUCT_ENTERPRISE_SERVER_CORE_V 0x00000029
#define PRODUCT_HYPERV 0x0000002A
#define PRODUCT_STORAGE_EXPRESS_SERVER_CORE 0x0000002B
#define PRODUCT_STORAGE_STANDARD_SERVER_CORE 0x0000002C
#define PRODUCT_STORAGE_WORKGROUP_SERVER_CORE 0x0000002D
#define PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE 0x0000002E
#define PRODUCT_STARTER_N 0x0000002F
#define PRODUCT_PROFESSIONAL 0x00000030
#define PRODUCT_PROFESSIONAL_N 0x00000031
#define PRODUCT_SB_SOLUTION_SERVER 0x00000032
#define PRODUCT_SERVER_FOR_SB_SOLUTIONS 0x00000033
#define PRODUCT_STANDARD_SERVER_SOLUTIONS 0x00000034
#define PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE 0x00000035
#define PRODUCT_SB_SOLUTION_SERVER_EM 0x00000036
#define PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM 0x00000037
#define PRODUCT_SOLUTION_EMBEDDEDSERVER 0x00000038
#define PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE 0x00000039
#define PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE 0x0000003F
#define PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT 0x0000003B
#define PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL 0x0000003C
#define PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC 0x0000003D
#define PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC 0x0000003E
#define PRODUCT_CLUSTER_SERVER_V 0x00000040
#define PRODUCT_EMBEDDED 0x00000041
#define PRODUCT_STARTER_E 0x00000042
#define PRODUCT_HOME_BASIC_E 0x00000043
#define PRODUCT_HOME_PREMIUM_E 0x00000044
#define PRODUCT_PROFESSIONAL_E 0x00000045
#define PRODUCT_ENTERPRISE_E 0x00000046
#define PRODUCT_ULTIMATE_E 0x00000047

#define PRODUCT_UNLICENSED 0xABCDABCD



//
//  Language IDs.
//
//  Note that the named locale APIs (eg GetLocaleInfoEx) are preferred.
//
//  Not all locales have unique Language IDs
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//    LANG_INVARIANT        SUBLANG_NEUTRAL     Invariant locale
//
//  It is recommended that applications test for locale names instead of
//  Language IDs / LCIDs.

//
//  Primary language IDs.
//
//  WARNING: These aren't always unique.  Bosnian, Serbian & Croation for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
#define LANG_NEUTRAL 0x00
#define LANG_INVARIANT 0x7f

#define LANG_AFRIKAANS 0x36
#define LANG_ALBANIAN 0x1c
#define LANG_ALSATIAN 0x84
#define LANG_AMHARIC 0x5e
#define LANG_ARABIC 0x01
#define LANG_ARMENIAN 0x2b
#define LANG_ASSAMESE 0x4d
#define LANG_AZERI 0x2c
#define LANG_BASHKIR 0x6d
#define LANG_BASQUE 0x2d
#define LANG_BELARUSIAN 0x23
#define LANG_BENGALI 0x45
#define LANG_BRETON 0x7e
#define LANG_BOSNIAN 0x1a
#define LANG_BOSNIAN_NEUTRAL 0x781a
#define LANG_BULGARIAN 0x02
#define LANG_CATALAN 0x03
#define LANG_CHINESE 0x04
#define LANG_CHINESE_SIMPLIFIED 0x04
#define LANG_CHINESE_TRADITIONAL 0x7c04
#define LANG_CORSICAN 0x83
#define LANG_CROATIAN 0x1a
#define LANG_CZECH 0x05
#define LANG_DANISH 0x06
#define LANG_DARI 0x8c
#define LANG_DIVEHI 0x65
#define LANG_DUTCH 0x13
#define LANG_ENGLISH 0x09
#define LANG_ESTONIAN 0x25
#define LANG_FAEROESE 0x38
#define LANG_FARSI 0x29
#define LANG_FILIPINO 0x64
#define LANG_FINNISH 0x0b
#define LANG_FRENCH 0x0c
#define LANG_FRISIAN 0x62
#define LANG_GALICIAN 0x56
#define LANG_GEORGIAN 0x37
#define LANG_GERMAN 0x07
#define LANG_GREEK 0x08
#define LANG_GREENLANDIC 0x6f
#define LANG_GUJARATI 0x47
#define LANG_HAUSA 0x68
#define LANG_HEBREW 0x0d
#define LANG_HINDI 0x39
#define LANG_HUNGARIAN 0x0e
#define LANG_ICELANDIC 0x0f
#define LANG_IGBO 0x70
#define LANG_INDONESIAN 0x21
#define LANG_INUKTITUT 0x5d
#define LANG_IRISH 0x3c
#define LANG_ITALIAN 0x10
#define LANG_JAPANESE 0x11
#define LANG_KANNADA 0x4b
#define LANG_KASHMIRI 0x60
#define LANG_KAZAK 0x3f
#define LANG_KHMER 0x53
#define LANG_KICHE 0x86
#define LANG_KINYARWANDA 0x87
#define LANG_KONKANI 0x57
#define LANG_KOREAN 0x12
#define LANG_KYRGYZ 0x40
#define LANG_LAO 0x54
#define LANG_LATVIAN 0x26
#define LANG_LITHUANIAN 0x27
#define LANG_LOWER_SORBIAN 0x2e
#define LANG_LUXEMBOURGISH 0x6e
#define LANG_MACEDONIAN 0x2f
#define LANG_MALAY 0x3e
#define LANG_MALAYALAM 0x4c
#define LANG_MALTESE 0x3a
#define LANG_MANIPURI 0x58
#define LANG_MAORI 0x81
#define LANG_MAPUDUNGUN 0x7a
#define LANG_MARATHI 0x4e
#define LANG_MOHAWK 0x7c
#define LANG_MONGOLIAN 0x50
#define LANG_NEPALI 0x61
#define LANG_NORWEGIAN 0x14
#define LANG_OCCITAN 0x82
#define LANG_ORIYA 0x48
#define LANG_PASHTO 0x63
#define LANG_PERSIAN 0x29
#define LANG_POLISH 0x15
#define LANG_PORTUGUESE 0x16
#define LANG_PUNJABI 0x46
#define LANG_QUECHUA 0x6b
#define LANG_ROMANIAN 0x18
#define LANG_ROMANSH 0x17
#define LANG_RUSSIAN 0x19
#define LANG_SAMI 0x3b
#define LANG_SANSKRIT 0x4f
#define LANG_SCOTTISH_GAELIC 0x91
#define LANG_SERBIAN 0x1a
#define LANG_SERBIAN_NEUTRAL 0x7c1a
#define LANG_SINDHI 0x59
#define LANG_SINHALESE 0x5b
#define LANG_SLOVAK 0x1b
#define LANG_SLOVENIAN 0x24
#define LANG_SOTHO 0x6c
#define LANG_SPANISH 0x0a
#define LANG_SWAHILI 0x41
#define LANG_SWEDISH 0x1d
#define LANG_SYRIAC 0x5a
#define LANG_TAJIK 0x28
#define LANG_TAMAZIGHT 0x5f
#define LANG_TAMIL 0x49
#define LANG_TATAR 0x44
#define LANG_TELUGU 0x4a
#define LANG_THAI 0x1e
#define LANG_TIBETAN 0x51
#define LANG_TIGRIGNA 0x73
#define LANG_TSWANA 0x32
#define LANG_TURKISH 0x1f
#define LANG_TURKMEN 0x42
#define LANG_UIGHUR 0x80
#define LANG_UKRAINIAN 0x22
#define LANG_UPPER_SORBIAN 0x2e
#define LANG_URDU 0x20
#define LANG_UZBEK 0x43
#define LANG_VIETNAMESE 0x2a
#define LANG_WELSH 0x52
#define LANG_WOLOF 0x88
#define LANG_XHOSA 0x34
#define LANG_YAKUT 0x85
#define LANG_YI 0x78
#define LANG_YORUBA 0x6a
#define LANG_ZULU 0x35

//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//

#define SUBLANG_NEUTRAL 0x00
#define SUBLANG_DEFAULT 0x01
#define SUBLANG_SYS_DEFAULT 0x02
#define SUBLANG_CUSTOM_DEFAULT 0x03
#define SUBLANG_CUSTOM_UNSPECIFIED 0x04
#define SUBLANG_UI_CUSTOM_DEFAULT 0x05


#define SUBLANG_AFRIKAANS_SOUTH_AFRICA 0x01
#define SUBLANG_ALBANIAN_ALBANIA 0x01
#define SUBLANG_ALSATIAN_FRANCE 0x01
#define SUBLANG_AMHARIC_ETHIOPIA 0x01
#define SUBLANG_ARABIC_SAUDI_ARABIA 0x01
#define SUBLANG_ARABIC_IRAQ 0x02
#define SUBLANG_ARABIC_EGYPT 0x03
#define SUBLANG_ARABIC_LIBYA 0x04
#define SUBLANG_ARABIC_ALGERIA 0x05
#define SUBLANG_ARABIC_MOROCCO 0x06
#define SUBLANG_ARABIC_TUNISIA 0x07
#define SUBLANG_ARABIC_OMAN 0x08
#define SUBLANG_ARABIC_YEMEN 0x09
#define SUBLANG_ARABIC_SYRIA 0x0a
#define SUBLANG_ARABIC_JORDAN 0x0b
#define SUBLANG_ARABIC_LEBANON 0x0c
#define SUBLANG_ARABIC_KUWAIT 0x0d
#define SUBLANG_ARABIC_UAE 0x0e
#define SUBLANG_ARABIC_BAHRAIN 0x0f
#define SUBLANG_ARABIC_QATAR 0x10
#define SUBLANG_ARMENIAN_ARMENIA 0x01
#define SUBLANG_ASSAMESE_INDIA 0x01
#define SUBLANG_AZERI_LATIN 0x01
#define SUBLANG_AZERI_CYRILLIC 0x02
#define SUBLANG_BASHKIR_RUSSIA 0x01
#define SUBLANG_BASQUE_BASQUE 0x01
#define SUBLANG_BELARUSIAN_BELARUS 0x01
#define SUBLANG_BENGALI_INDIA 0x01
#define SUBLANG_BENGALI_BANGLADESH 0x02
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN 0x05
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x08
#define SUBLANG_BRETON_FRANCE 0x01
#define SUBLANG_BULGARIAN_BULGARIA 0x01
#define SUBLANG_CATALAN_CATALAN 0x01
#define SUBLANG_CHINESE_TRADITIONAL 0x01
#define SUBLANG_CHINESE_SIMPLIFIED 0x02
#define SUBLANG_CHINESE_HONGKONG 0x03
#define SUBLANG_CHINESE_SINGAPORE 0x04
#define SUBLANG_CHINESE_MACAU 0x05
#define SUBLANG_CORSICAN_FRANCE 0x01
#define SUBLANG_CZECH_CZECH_REPUBLIC 0x01
#define SUBLANG_CROATIAN_CROATIA 0x01
#define SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN 0x04
#define SUBLANG_DANISH_DENMARK 0x01
#define SUBLANG_DARI_AFGHANISTAN 0x01
#define SUBLANG_DIVEHI_MALDIVES 0x01
#define SUBLANG_DUTCH 0x01
#define SUBLANG_DUTCH_BELGIAN 0x02
#define SUBLANG_ENGLISH_US 0x01
#define SUBLANG_ENGLISH_UK 0x02
#define SUBLANG_ENGLISH_AUS 0x03
#define SUBLANG_ENGLISH_CAN 0x04
#define SUBLANG_ENGLISH_NZ 0x05
#define SUBLANG_ENGLISH_EIRE 0x06
#define SUBLANG_ENGLISH_SOUTH_AFRICA 0x07
#define SUBLANG_ENGLISH_JAMAICA 0x08
#define SUBLANG_ENGLISH_CARIBBEAN 0x09
#define SUBLANG_ENGLISH_BELIZE 0x0a
#define SUBLANG_ENGLISH_TRINIDAD 0x0b
#define SUBLANG_ENGLISH_ZIMBABWE 0x0c
#define SUBLANG_ENGLISH_PHILIPPINES 0x0d
#define SUBLANG_ENGLISH_INDIA 0x10
#define SUBLANG_ENGLISH_MALAYSIA 0x11
#define SUBLANG_ENGLISH_SINGAPORE 0x12
#define SUBLANG_ESTONIAN_ESTONIA 0x01
#define SUBLANG_FAEROESE_FAROE_ISLANDS 0x01
#define SUBLANG_FILIPINO_PHILIPPINES 0x01
#define SUBLANG_FINNISH_FINLAND 0x01
#define SUBLANG_FRENCH 0x01
#define SUBLANG_FRENCH_BELGIAN 0x02
#define SUBLANG_FRENCH_CANADIAN 0x03
#define SUBLANG_FRENCH_SWISS 0x04
#define SUBLANG_FRENCH_LUXEMBOURG 0x05
#define SUBLANG_FRENCH_MONACO 0x06
#define SUBLANG_FRISIAN_NETHERLANDS 0x01
#define SUBLANG_GALICIAN_GALICIAN 0x01
#define SUBLANG_GEORGIAN_GEORGIA 0x01
#define SUBLANG_GERMAN 0x01
#define SUBLANG_GERMAN_SWISS 0x02
#define SUBLANG_GERMAN_AUSTRIAN 0x03
#define SUBLANG_GERMAN_LUXEMBOURG 0x04
#define SUBLANG_GERMAN_LIECHTENSTEIN 0x05
#define SUBLANG_GREEK_GREECE 0x01
#define SUBLANG_GREENLANDIC_GREENLAND 0x01
#define SUBLANG_GUJARATI_INDIA 0x01
#define SUBLANG_HAUSA_NIGERIA_LATIN 0x01
#define SUBLANG_HEBREW_ISRAEL 0x01
#define SUBLANG_HINDI_INDIA 0x01
#define SUBLANG_HUNGARIAN_HUNGARY 0x01
#define SUBLANG_ICELANDIC_ICELAND 0x01
#define SUBLANG_IGBO_NIGERIA 0x01
#define SUBLANG_INDONESIAN_INDONESIA 0x01
#define SUBLANG_INUKTITUT_CANADA 0x01
#define SUBLANG_INUKTITUT_CANADA_LATIN 0x02
#define SUBLANG_IRISH_IRELAND 0x02
#define SUBLANG_ITALIAN 0x01
#define SUBLANG_ITALIAN_SWISS 0x02
#define SUBLANG_JAPANESE_JAPAN 0x01
#define SUBLANG_KANNADA_INDIA 0x01
#define SUBLANG_KASHMIRI_SASIA 0x02
#define SUBLANG_KASHMIRI_INDIA 0x02
#define SUBLANG_KAZAK_KAZAKHSTAN 0x01
#define SUBLANG_KHMER_CAMBODIA 0x01
#define SUBLANG_KICHE_GUATEMALA 0x01
#define SUBLANG_KINYARWANDA_RWANDA 0x01
#define SUBLANG_KONKANI_INDIA 0x01
#define SUBLANG_KOREAN 0x01
#define SUBLANG_KYRGYZ_KYRGYZSTAN 0x01
#define SUBLANG_LAO_LAO 0x01
#define SUBLANG_LATVIAN_LATVIA 0x01
#define SUBLANG_LITHUANIAN 0x01
#define SUBLANG_LOWER_SORBIAN_GERMANY 0x02
#define SUBLANG_LUXEMBOURGISH_LUXEMBOURG 0x01
#define SUBLANG_MACEDONIAN_MACEDONIA 0x01
#define SUBLANG_MALAY_MALAYSIA 0x01
#define SUBLANG_MALAY_BRUNEI_DARUSSALAM 0x02
#define SUBLANG_MALAYALAM_INDIA 0x01
#define SUBLANG_MALTESE_MALTA 0x01
#define SUBLANG_MAORI_NEW_ZEALAND 0x01
#define SUBLANG_MAPUDUNGUN_CHILE 0x01
#define SUBLANG_MARATHI_INDIA 0x01
#define SUBLANG_MOHAWK_MOHAWK 0x01
#define SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA 0x01
#define SUBLANG_MONGOLIAN_PRC 0x02
#define SUBLANG_NEPALI_INDIA 0x02
#define SUBLANG_NEPALI_NEPAL 0x01
#define SUBLANG_NORWEGIAN_BOKMAL 0x01
#define SUBLANG_NORWEGIAN_NYNORSK 0x02
#define SUBLANG_OCCITAN_FRANCE 0x01
#define SUBLANG_ORIYA_INDIA 0x01
#define SUBLANG_PASHTO_AFGHANISTAN 0x01
#define SUBLANG_PERSIAN_IRAN 0x01
#define SUBLANG_POLISH_POLAND 0x01
#define SUBLANG_PORTUGUESE 0x02
#define SUBLANG_PORTUGUESE_BRAZILIAN 0x01
#define SUBLANG_PUNJABI_INDIA 0x01
#define SUBLANG_QUECHUA_BOLIVIA 0x01
#define SUBLANG_QUECHUA_ECUADOR 0x02
#define SUBLANG_QUECHUA_PERU 0x03
#define SUBLANG_ROMANIAN_ROMANIA 0x01
#define SUBLANG_ROMANSH_SWITZERLAND 0x01
#define SUBLANG_RUSSIAN_RUSSIA 0x01
#define SUBLANG_SAMI_NORTHERN_NORWAY 0x01
#define SUBLANG_SAMI_NORTHERN_SWEDEN 0x02
#define SUBLANG_SAMI_NORTHERN_FINLAND 0x03
#define SUBLANG_SAMI_LULE_NORWAY 0x04
#define SUBLANG_SAMI_LULE_SWEDEN 0x05
#define SUBLANG_SAMI_SOUTHERN_NORWAY 0x06
#define SUBLANG_SAMI_SOUTHERN_SWEDEN 0x07
#define SUBLANG_SAMI_SKOLT_FINLAND 0x08
#define SUBLANG_SAMI_INARI_FINLAND 0x09
#define SUBLANG_SANSKRIT_INDIA 0x01
#define SUBLANG_SCOTTISH_GAELIC 0x01
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN 0x06
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x07
#define SUBLANG_SERBIAN_MONTENEGRO_LATIN 0x0b
#define SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC 0x0c
#define SUBLANG_SERBIAN_SERBIA_LATIN 0x09
#define SUBLANG_SERBIAN_SERBIA_CYRILLIC 0x0a
#define SUBLANG_SERBIAN_CROATIA 0x01
#define SUBLANG_SERBIAN_LATIN 0x02
#define SUBLANG_SERBIAN_CYRILLIC 0x03
#define SUBLANG_SINDHI_INDIA 0x01
#define SUBLANG_SINDHI_PAKISTAN 0x02
#define SUBLANG_SINDHI_AFGHANISTAN 0x02
#define SUBLANG_SINHALESE_SRI_LANKA 0x01
#define SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA 0x01
#define SUBLANG_SLOVAK_SLOVAKIA 0x01
#define SUBLANG_SLOVENIAN_SLOVENIA 0x01
#define SUBLANG_SPANISH 0x01
#define SUBLANG_SPANISH_MEXICAN 0x02
#define SUBLANG_SPANISH_MODERN 0x03
#define SUBLANG_SPANISH_GUATEMALA 0x04
#define SUBLANG_SPANISH_COSTA_RICA 0x05
#define SUBLANG_SPANISH_PANAMA 0x06
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07
#define SUBLANG_SPANISH_VENEZUELA 0x08
#define SUBLANG_SPANISH_COLOMBIA 0x09
#define SUBLANG_SPANISH_PERU 0x0a
#define SUBLANG_SPANISH_ARGENTINA 0x0b
#define SUBLANG_SPANISH_ECUADOR 0x0c
#define SUBLANG_SPANISH_CHILE 0x0d
#define SUBLANG_SPANISH_URUGUAY 0x0e
#define SUBLANG_SPANISH_PARAGUAY 0x0f
#define SUBLANG_SPANISH_BOLIVIA 0x10
#define SUBLANG_SPANISH_EL_SALVADOR 0x11
#define SUBLANG_SPANISH_HONDURAS 0x12
#define SUBLANG_SPANISH_NICARAGUA 0x13
#define SUBLANG_SPANISH_PUERTO_RICO 0x14
#define SUBLANG_SPANISH_US 0x15
#define SUBLANG_SWAHILI_KENYA 0x01
#define SUBLANG_SWEDISH 0x01
#define SUBLANG_SWEDISH_FINLAND 0x02
#define SUBLANG_SYRIAC_SYRIA 0x01
#define SUBLANG_TAJIK_TAJIKISTAN 0x01
#define SUBLANG_TAMAZIGHT_ALGERIA_LATIN 0x02
#define SUBLANG_TAMIL_INDIA 0x01
#define SUBLANG_TATAR_RUSSIA 0x01
#define SUBLANG_TELUGU_INDIA 0x01
#define SUBLANG_THAI_THAILAND 0x01
#define SUBLANG_TIBETAN_PRC 0x01
#define SUBLANG_TIGRIGNA_ERITREA 0x02
#define SUBLANG_TSWANA_SOUTH_AFRICA 0x01
#define SUBLANG_TURKISH_TURKEY 0x01
#define SUBLANG_TURKMEN_TURKMENISTAN 0x01
#define SUBLANG_UIGHUR_PRC 0x01
#define SUBLANG_UKRAINIAN_UKRAINE 0x01
#define SUBLANG_UPPER_SORBIAN_GERMANY 0x01
#define SUBLANG_URDU_PAKISTAN 0x01
#define SUBLANG_URDU_INDIA 0x02
#define SUBLANG_UZBEK_LATIN 0x01
#define SUBLANG_UZBEK_CYRILLIC 0x02
#define SUBLANG_VIETNAMESE_VIETNAM 0x01
#define SUBLANG_WELSH_UNITED_KINGDOM 0x01
#define SUBLANG_WOLOF_SENEGAL 0x01
#define SUBLANG_XHOSA_SOUTH_AFRICA 0x01
#define SUBLANG_YAKUT_RUSSIA 0x01
#define SUBLANG_YI_PRC 0x01
#define SUBLANG_YORUBA_NIGERIA 0x01
#define SUBLANG_ZULU_SOUTH_AFRICA 0x01




//
//  Sorting IDs.
//
//  Note that the named locale APIs (eg CompareStringExEx) are recommended.
//

#define SORT_DEFAULT 0x0

#define SORT_INVARIANT_MATH 0x1

#define SORT_JAPANESE_XJIS 0x0
#define SORT_JAPANESE_UNICODE 0x1
#define SORT_JAPANESE_RADICALSTROKE 0x4

#define SORT_CHINESE_BIG5 0x0
#define SORT_CHINESE_PRCP 0x0
#define SORT_CHINESE_UNICODE 0x1
#define SORT_CHINESE_PRC 0x2
#define SORT_CHINESE_BOPOMOFO 0x3
#define SORT_CHINESE_RADICALSTROKE 0x4

#define SORT_KOREAN_KSC 0x0
#define SORT_KOREAN_UNICODE 0x1

#define SORT_GERMAN_PHONE_BOOK 0x1

#define SORT_HUNGARIAN_DEFAULT 0x0
#define SORT_HUNGARIAN_TECHNICAL 0x1

#define SORT_GEORGIAN_TRADITIONAL 0x0
#define SORT_GEORGIAN_MODERN 0x1

// end_r_winnt

//
//  A language ID is a 16 bit value which is the combination of a
//  primary language ID and a secondary language ID.  The bits are
//  allocated as follows:
//
//       +-----------------------+-------------------------+
//       |     Sublanguage ID    |   Primary Language ID   |
//       +-----------------------+-------------------------+
//        15                   10 9                       0   bit
//
//  WARNING:  This pattern isn't always follows, Serbina, Bosnian & Croation
//            for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Language ID creation/extraction macros:
//
//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//    PRIMARYLANGID - extract primary language id from a language id.
//    SUBLANGID     - extract sublanguage id from a language id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  Language IDs do not exist for all locales
//
#define MAKELANGID(p,s) ((((WORD )(s)) << 10) | (WORD )(p))
#define PRIMARYLANGID(lgid) ((WORD )(lgid) & 0x3ff)
#define SUBLANGID(lgid) ((WORD )(lgid) >> 10)


//
//  A locale ID is a 32 bit value which is the combination of a
//  language ID, a sort ID, and a reserved area.  The bits are
//  allocated as follows:
//
//       +-------------+---------+-------------------------+
//       |   Reserved  | Sort ID |      Language ID        |
//       +-------------+---------+-------------------------+
//        31         20 19     16 15                      0   bit
//
//  WARNING: This pattern isn't always followed (es-ES_tradnl vs es-ES for example)
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Locale ID creation/extraction macros:
//
//    MAKELCID            - construct the locale id from a language id and a sort id.
//    MAKESORTLCID        - construct the locale id from a language id, sort id, and sort version.
//    LANGIDFROMLCID      - extract the language id from a locale id.
//    SORTIDFROMLCID      - extract the sort id from a locale id.
//    SORTVERSIONFROMLCID - extract the sort version from a locale id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  LCIDs do not exist for all locales.
//
#define NLS_VALID_LOCALE_MASK 0x000fffff

#define MAKELCID(lgid,srtid) ((DWORD)((((DWORD)((WORD )(srtid))) << 16) | ((DWORD)((WORD )(lgid)))))

#define MAKESORTLCID(lgid,srtid,ver) ((DWORD)((MAKELCID(lgid, srtid)) | (((DWORD)((WORD )(ver))) << 20)))


#define LANGIDFROMLCID(lcid) ((WORD )(lcid))
#define SORTIDFROMLCID(lcid) ((WORD )((((DWORD)(lcid)) >> 16) & 0xf))
#define SORTVERSIONFROMLCID(lcid) ((WORD )((((DWORD)(lcid)) >> 20) & 0xf))

// 8 characters for language
// 8 characters for region
// 64 characters for suffix (script)
// 2 characters for '-' separators
// 2 characters for prefix like "i-" or "x-"
// 1 null termination
#define LOCALE_NAME_MAX_LENGTH 85

//
//  Default System and User IDs for language and locale.
//  Locale names such as LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_NAME_USER_DEFAULT,
//  and LOCALE_NAME_INVARIANT are preferred.
//

#define LANG_SYSTEM_DEFAULT (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT))
#define LANG_USER_DEFAULT (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))

#define LOCALE_SYSTEM_DEFAULT (MAKELCID(LANG_SYSTEM_DEFAULT, SORT_DEFAULT))
#define LOCALE_USER_DEFAULT (MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT))

//
//  Other special IDs for language and locale.
//
#define LOCALE_CUSTOM_DEFAULT (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_DEFAULT), SORT_DEFAULT))


#define LOCALE_CUSTOM_UNSPECIFIED (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_UNSPECIFIED), SORT_DEFAULT))


#define LOCALE_CUSTOM_UI_DEFAULT (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_UI_CUSTOM_DEFAULT), SORT_DEFAULT))


#define LOCALE_NEUTRAL (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT))


#define LOCALE_INVARIANT (MAKELCID(MAKELANGID(LANG_INVARIANT, SUBLANG_NEUTRAL), SORT_DEFAULT))


// begin_ntminiport begin_ntndis begin_ntminitape

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//


#define UNREFERENCED_PARAMETER(P) (P)
#define DBG_UNREFERENCED_PARAMETER(P) (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)
# 1923 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//





//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE 
# 1967 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE) 


// Compile-time macros for initializing flag values in const data.
// 
// When using DEFINE_ENUM_FLAG_OPERATORS for enum values you should use the macros below
// when you need to initialize global const data.  Without these macros the inline operators 
// from DEFINE_ENUM_FLAG_OPERATORS force a runtime initialization rather than a
// compile time initialization.  This applies even if you have declared the data as const.
#define COMPILETIME_OR_2FLAGS(a,b) ((UINT)(a)|(UINT)(b))
#define COMPILETIME_OR_3FLAGS(a,b,c) ((UINT)(a)|(UINT)(b)|(UINT)(c))
#define COMPILETIME_OR_4FLAGS(a,b,c,d) ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d))
#define COMPILETIME_OR_5FLAGS(a,b,c,d,e) ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d)|(UINT)(e))


/*lint -save -e767 */
#define STATUS_WAIT_0 ((DWORD )0x00000000L)
#define STATUS_ABANDONED_WAIT_0 ((DWORD )0x00000080L)
#define STATUS_USER_APC ((DWORD )0x000000C0L)
#define STATUS_TIMEOUT ((DWORD )0x00000102L)
#define STATUS_PENDING ((DWORD )0x00000103L)
#define DBG_EXCEPTION_HANDLED ((DWORD )0x00010001L)
#define DBG_CONTINUE ((DWORD )0x00010002L)
#define STATUS_SEGMENT_NOTIFICATION ((DWORD )0x40000005L)
#define DBG_TERMINATE_THREAD ((DWORD )0x40010003L)
#define DBG_TERMINATE_PROCESS ((DWORD )0x40010004L)
#define DBG_CONTROL_C ((DWORD )0x40010005L)
#define DBG_PRINTEXCEPTION_C ((DWORD )0x40010006L)
#define DBG_RIPEXCEPTION ((DWORD )0x40010007L)
#define DBG_CONTROL_BREAK ((DWORD )0x40010008L)
#define DBG_COMMAND_EXCEPTION ((DWORD )0x40010009L)
#define STATUS_GUARD_PAGE_VIOLATION ((DWORD )0x80000001L)
#define STATUS_DATATYPE_MISALIGNMENT ((DWORD )0x80000002L)
#define STATUS_BREAKPOINT ((DWORD )0x80000003L)
#define STATUS_SINGLE_STEP ((DWORD )0x80000004L)
#define STATUS_LONGJUMP ((DWORD )0x80000026L)
#define STATUS_UNWIND_CONSOLIDATE ((DWORD )0x80000029L)
#define DBG_EXCEPTION_NOT_HANDLED ((DWORD )0x80010001L)
#define STATUS_ACCESS_VIOLATION ((DWORD )0xC0000005L)
#define STATUS_IN_PAGE_ERROR ((DWORD )0xC0000006L)
#define STATUS_INVALID_HANDLE ((DWORD )0xC0000008L)
#define STATUS_INVALID_PARAMETER ((DWORD )0xC000000DL)
#define STATUS_NO_MEMORY ((DWORD )0xC0000017L)
#define STATUS_ILLEGAL_INSTRUCTION ((DWORD )0xC000001DL)
#define STATUS_NONCONTINUABLE_EXCEPTION ((DWORD )0xC0000025L)
#define STATUS_INVALID_DISPOSITION ((DWORD )0xC0000026L)
#define STATUS_ARRAY_BOUNDS_EXCEEDED ((DWORD )0xC000008CL)
#define STATUS_FLOAT_DENORMAL_OPERAND ((DWORD )0xC000008DL)
#define STATUS_FLOAT_DIVIDE_BY_ZERO ((DWORD )0xC000008EL)
#define STATUS_FLOAT_INEXACT_RESULT ((DWORD )0xC000008FL)
#define STATUS_FLOAT_INVALID_OPERATION ((DWORD )0xC0000090L)
#define STATUS_FLOAT_OVERFLOW ((DWORD )0xC0000091L)
#define STATUS_FLOAT_STACK_CHECK ((DWORD )0xC0000092L)
#define STATUS_FLOAT_UNDERFLOW ((DWORD )0xC0000093L)
#define STATUS_INTEGER_DIVIDE_BY_ZERO ((DWORD )0xC0000094L)
#define STATUS_INTEGER_OVERFLOW ((DWORD )0xC0000095L)
#define STATUS_PRIVILEGED_INSTRUCTION ((DWORD )0xC0000096L)
#define STATUS_STACK_OVERFLOW ((DWORD )0xC00000FDL)
#define STATUS_DLL_NOT_FOUND ((DWORD )0xC0000135L)
#define STATUS_ORDINAL_NOT_FOUND ((DWORD )0xC0000138L)
#define STATUS_ENTRYPOINT_NOT_FOUND ((DWORD )0xC0000139L)
#define STATUS_CONTROL_C_EXIT ((DWORD )0xC000013AL)
#define STATUS_DLL_INIT_FAILED ((DWORD )0xC0000142L)
#define STATUS_FLOAT_MULTIPLE_FAULTS ((DWORD )0xC00002B4L)
#define STATUS_FLOAT_MULTIPLE_TRAPS ((DWORD )0xC00002B5L)
#define STATUS_REG_NAT_CONSUMPTION ((DWORD )0xC00002C9L)
#define STATUS_STACK_BUFFER_OVERRUN ((DWORD )0xC0000409L)
#define STATUS_INVALID_CRUNTIME_PARAMETER ((DWORD )0xC0000417L)
#define STATUS_ASSERTION_FAILURE ((DWORD )0xC0000420L)

#define STATUS_SXS_EARLY_DEACTIVATION ((DWORD )0xC015000FL)
#define STATUS_SXS_INVALID_DEACTIVATION ((DWORD )0xC0150010L)

/*lint -restore */

#define MAXIMUM_WAIT_OBJECTS 64

#define MAXIMUM_SUSPEND_COUNT MAXCHAR

typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;


//
// Define 128-bit 16-byte aligned xmm register type.
//

typedef struct _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;

//
// Format of data for (F)XSAVE/(F)XRSTOR instruction
//

typedef struct _XSAVE_FORMAT {
    WORD ControlWord;
    WORD StatusWord;
    BYTE TagWord;
    BYTE Reserved1;
    WORD ErrorOpcode;
    DWORD ErrorOffset;
    WORD ErrorSelector;
    WORD Reserved2;
    DWORD DataOffset;
    WORD DataSelector;
    WORD Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];



    M128A XmmRegisters[16];
    BYTE Reserved4[96];
# 2100 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
} XSAVE_FORMAT, *PXSAVE_FORMAT;

typedef struct _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 Reserved[7];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
    PXSAVE_AREA Area;





    PVOID Buffer;





} XSTATE_CONTEXT, *PXSTATE_CONTEXT;


#define XSAVE_ALIGN 64
#define MINIMAL_XSTATE_AREA_LENGTH sizeof(XSAVE_AREA)


//
// This structure specifies an offset (from the beginning of CONTEXT_EX
// structure) and size of a single chunk of an extended context structure.
//
// N.B. Offset may be negative.
//

typedef struct _CONTEXT_CHUNK {
    LONG Offset;
    DWORD Length;
} CONTEXT_CHUNK, *PCONTEXT_CHUNK;

//
// CONTEXT_EX structure is an extension to CONTEXT structure. It defines
// a context record as a set of disjoint variable-sized buffers (chunks)
// each containing a portion of processor state. Currently there are only
// two buffers (chunks) are defined:
//
//   - Legacy, that stores traditional CONTEXT structure;
//   - XState, that stores XSAVE save area buffer starting from
//     XSAVE_AREA_HEADER, i.e. without the first 512 bytes.
//
// There a few assumptions exists that simplify conversion of PCONTEXT
// pointer to PCONTEXT_EX pointer.
//
// 1. APIs that work with PCONTEXT pointers assume that CONTEXT_EX is
//    stored right after the CONTEXT structure. It is also assumed that
//    CONTEXT_EX is present if and only if corresponding CONTEXT_XXX
//    flags are set in CONTEXT.ContextFlags.
//
// 2. CONTEXT_EX.Legacy is always present if CONTEXT_EX structure is
//    present. All other chunks are optional.
//
// 3. CONTEXT.ContextFlags unambigiously define which chunks are
//    present. I.e. if CONTEXT_XSTATE is set CONTEXT_EX.XState is valid.
//

typedef struct _CONTEXT_EX {

    //
    // The total length of the structure starting from the chunk with
    // the smallest offset. N.B. that the offset may be negative.
    //

    CONTEXT_CHUNK All;

    //
    // Wrapper for the traditional CONTEXT structure. N.B. the size of
    // the chunk may be less than sizeof(CONTEXT) is some cases (when
    // CONTEXT_EXTENDED_REGISTERS is not set on x86 for instance).
    //

    CONTEXT_CHUNK Legacy;

    //
    // CONTEXT_XSTATE: Extended processor state chunk. The state is
    // stored in the same format XSAVE operation strores it with
    // exception of the first 512 bytes, i.e. staring from
    // XSAVE_AREA_HEADER. The lower two bits corresponding FP and
    // SSE state must be zero.
    //

    CONTEXT_CHUNK XState;

} CONTEXT_EX, *PCONTEXT_EX;

#define CONTEXT_EX_LENGTH ALIGN_UP_BY(sizeof(CONTEXT_EX), STACK_ALIGN)

//
// These macros make context chunks manupulations easier.
//

#define RTL_CONTEXT_EX_OFFSET(ContextEx,Chunk) ((ContextEx)->Chunk.Offset)


#define RTL_CONTEXT_EX_LENGTH(ContextEx,Chunk) ((ContextEx)->Chunk.Length)


#define RTL_CONTEXT_EX_CHUNK(Base,Layout,Chunk) ((PVOID)((PCHAR)(Base) + RTL_CONTEXT_EX_OFFSET(Layout, Chunk)))


#define RTL_CONTEXT_OFFSET(Context,Chunk) RTL_CONTEXT_EX_OFFSET((PCONTEXT_EX)(Context + 1), Chunk)


#define RTL_CONTEXT_LENGTH(Context,Chunk) RTL_CONTEXT_EX_LENGTH((PCONTEXT_EX)(Context + 1), Chunk)


#define RTL_CONTEXT_CHUNK(Context,Chunk) RTL_CONTEXT_EX_CHUNK((PCONTEXT_EX)(Context + 1), (PCONTEXT_EX)(Context + 1), Chunk)







//
// XSAVE/XRSTOR save area should be aligned on 64 byte boundary
//

typedef char __C_ASSERT__[((sizeof(XSAVE_FORMAT) & (64 - 1)) == 0)?1:-1];
typedef char __C_ASSERT__[((((LONG)(LONG_PTR)&(((XSAVE_AREA *)0)->Header)) & (64 - 1)) == 0)?1:-1];

// XSAVE_AREA structure must be sized uniformly on all architectures
typedef char __C_ASSERT__[(sizeof(XSAVE_AREA) == 512 + 64)?1:-1];
# 4288 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define _LDT_ENTRY_DEFINED 

typedef struct _LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1; // Declare as bytes to avoid alignment
            BYTE Flags2; // Problems.
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;
# 6143 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define WOW64_CONTEXT_i386 0x00010000
#define WOW64_CONTEXT_i486 0x00010000

#define WOW64_CONTEXT_CONTROL (WOW64_CONTEXT_i386 | 0x00000001L)
#define WOW64_CONTEXT_INTEGER (WOW64_CONTEXT_i386 | 0x00000002L)
#define WOW64_CONTEXT_SEGMENTS (WOW64_CONTEXT_i386 | 0x00000004L)
#define WOW64_CONTEXT_FLOATING_POINT (WOW64_CONTEXT_i386 | 0x00000008L)
#define WOW64_CONTEXT_DEBUG_REGISTERS (WOW64_CONTEXT_i386 | 0x00000010L)
#define WOW64_CONTEXT_EXTENDED_REGISTERS (WOW64_CONTEXT_i386 | 0x00000020L)

#define WOW64_CONTEXT_FULL (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS)

#define WOW64_CONTEXT_ALL (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS | WOW64_CONTEXT_FLOATING_POINT | WOW64_CONTEXT_DEBUG_REGISTERS | WOW64_CONTEXT_EXTENDED_REGISTERS)



#define WOW64_CONTEXT_XSTATE (WOW64_CONTEXT_i386 | 0x00000040L)



//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define WOW64_SIZE_OF_80387_REGISTERS 80

#define WOW64_MAXIMUM_SUPPORTED_EXTENSION 512

typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack4.h



Abstract:



    This file turns 4 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 6186 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _WOW64_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    WOW64_FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs; // MUST BE SANITIZED
    DWORD EFlags; // MUST BE SANITIZED
    DWORD Esp;
    DWORD SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE ExtendedRegisters[512];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 6286 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2


typedef struct _WOW64_LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1; // Declare as bytes to avoid alignment
            BYTE Flags2; // Problems.
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;

#define EXCEPTION_NONCONTINUABLE 0x1
#define EXCEPTION_MAXIMUM_PARAMETERS 15

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

//
// Typedef for pointer returned by exception_info()
//

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

// end_wdm


void

RtlUnwind (
    PVOID TargetFrame,
    PVOID TargetIp,
    PEXCEPTION_RECORD ExceptionRecord,
    PVOID ReturnValue
    );
# 6421 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef PVOID PSID;
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//

// begin_wdm
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_wdm
//
//  The following are masks for the predefined standard access types
//

#define DELETE (0x00010000L)
#define READ_CONTROL (0x00020000L)
#define WRITE_DAC (0x00040000L)
#define WRITE_OWNER (0x00080000L)
#define SYNCHRONIZE (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED (0x000F0000L)

#define STANDARD_RIGHTS_READ (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE (READ_CONTROL)

#define STANDARD_RIGHTS_ALL (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ (0x80000000L)
#define GENERIC_WRITE (0x40000000L)
#define GENERIC_EXECUTE (0x20000000L)
#define GENERIC_ALL (0x10000000L)


//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack4.h



Abstract:



    This file turns 4 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 6541 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 6550 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2


////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//


// begin_ntifs


#define SID_IDENTIFIER_AUTHORITY_DEFINED 
typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;




#define SID_DEFINED 
typedef struct _SID {
   BYTE Revision;
   BYTE SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;



   DWORD SubAuthority[1];

} SID, *PISID;


#define SID_REVISION (1)
#define SID_MAX_SUB_AUTHORITIES (15)
#define SID_RECOMMENDED_SUB_AUTHORITIES (1)

                                                // in a future release.

#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))




typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {



    PSID Sid;

    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;

#define SID_HASH_SIZE 32
typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define SECURITY_NULL_SID_AUTHORITY {0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY {0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY {0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY {0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY {0,0,0,0,0,4}
#define SECURITY_RESOURCE_MANAGER_AUTHORITY {0,0,0,0,0,9}


#define SECURITY_NULL_RID (0x00000000L)
#define SECURITY_WORLD_RID (0x00000000L)
#define SECURITY_LOCAL_RID (0x00000000L)
#define SECURITY_LOCAL_LOGON_RID (0x00000001L)

#define SECURITY_CREATOR_OWNER_RID (0x00000000L)
#define SECURITY_CREATOR_GROUP_RID (0x00000001L)

#define SECURITY_CREATOR_OWNER_SERVER_RID (0x00000002L)
#define SECURITY_CREATOR_GROUP_SERVER_RID (0x00000003L)

#define SECURITY_CREATOR_OWNER_RIGHTS_RID (0x00000004L)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// NT well-known SIDs                                                        //
//                                                                           //
//     NT Authority            S-1-5                                         //
//     Dialup                  S-1-5-1                                       //
//                                                                           //
//     Network                 S-1-5-2                                       //
//     Batch                   S-1-5-3                                       //
//     Interactive             S-1-5-4                                       //
//     (Logon IDs)             S-1-5-5-X-Y                                   //
//     Service                 S-1-5-6                                       //
//     AnonymousLogon          S-1-5-7       (aka null logon session)        //
//     Proxy                   S-1-5-8                                       //
//     Enterprise DC (EDC)     S-1-5-9       (aka domain controller account) //
//     Self                    S-1-5-10      (self RID)                      //
//     Authenticated User      S-1-5-11      (Authenticated user somewhere)  //
//     Restricted Code         S-1-5-12      (Running restricted code)       //
//     Terminal Server         S-1-5-13      (Running on Terminal Server)    //
//     Remote Logon            S-1-5-14      (Remote Interactive Logon)      //
//     This Organization       S-1-5-15                                      //
//                                                                           //
//     IUser                   S-1-5-17
//     Local System            S-1-5-18                                      //
//     Local Service           S-1-5-19                                      //
//     Network Service         S-1-5-20                                      //
//                                                                           //
//     (NT non-unique IDs)     S-1-5-0x15-... (NT Domain Sids)               //
//                                                                           //
//     (Built-in domain)       S-1-5-0x20                                    //
//                                                                           //
//     (Security Package IDs)  S-1-5-0x40                                    //
//     NTLM Authentication     S-1-5-0x40-10                                 //
//     SChannel Authentication S-1-5-0x40-14                                 //
//     Digest Authentication   S-1-5-0x40-21                                 //
//                                                                           //
//     Other Organization      S-1-5-1000    (>=1000 can not be filtered)    //
//                                                                           //
//                                                                           //
// NOTE: the relative identifier values (RIDs) determine which security      //
//       boundaries the SID is allowed to cross.  Before adding new RIDs,    //
//       a determination needs to be made regarding which range they should  //
//       be added to in order to ensure proper "SID filtering"               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define SECURITY_NT_AUTHORITY {0,0,0,0,0,5}

#define SECURITY_DIALUP_RID (0x00000001L)
#define SECURITY_NETWORK_RID (0x00000002L)
#define SECURITY_BATCH_RID (0x00000003L)
#define SECURITY_INTERACTIVE_RID (0x00000004L)
#define SECURITY_LOGON_IDS_RID (0x00000005L)
#define SECURITY_LOGON_IDS_RID_COUNT (3L)
#define SECURITY_SERVICE_RID (0x00000006L)
#define SECURITY_ANONYMOUS_LOGON_RID (0x00000007L)
#define SECURITY_PROXY_RID (0x00000008L)
#define SECURITY_ENTERPRISE_CONTROLLERS_RID (0x00000009L)
#define SECURITY_SERVER_LOGON_RID SECURITY_ENTERPRISE_CONTROLLERS_RID
#define SECURITY_PRINCIPAL_SELF_RID (0x0000000AL)
#define SECURITY_AUTHENTICATED_USER_RID (0x0000000BL)
#define SECURITY_RESTRICTED_CODE_RID (0x0000000CL)
#define SECURITY_TERMINAL_SERVER_RID (0x0000000DL)
#define SECURITY_REMOTE_LOGON_RID (0x0000000EL)
#define SECURITY_THIS_ORGANIZATION_RID (0x0000000FL)
#define SECURITY_IUSER_RID (0x00000011L)
#define SECURITY_LOCAL_SYSTEM_RID (0x00000012L)
#define SECURITY_LOCAL_SERVICE_RID (0x00000013L)
#define SECURITY_NETWORK_SERVICE_RID (0x00000014L)

#define SECURITY_NT_NON_UNIQUE (0x00000015L)
#define SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT (3L)

#define SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID (0x00000016L)

#define SECURITY_BUILTIN_DOMAIN_RID (0x00000020L)
#define SECURITY_WRITE_RESTRICTED_CODE_RID (0x00000021L)


#define SECURITY_PACKAGE_BASE_RID (0x00000040L)
#define SECURITY_PACKAGE_RID_COUNT (2L)
#define SECURITY_PACKAGE_NTLM_RID (0x0000000AL)
#define SECURITY_PACKAGE_SCHANNEL_RID (0x0000000EL)
#define SECURITY_PACKAGE_DIGEST_RID (0x00000015L)

#define SECURITY_CRED_TYPE_BASE_RID (0x00000041L)
#define SECURITY_CRED_TYPE_RID_COUNT (2L)
#define SECURITY_CRED_TYPE_THIS_ORG_CERT_RID (0x00000001L)

#define SECURITY_MIN_BASE_RID (0x00000050L)

#define SECURITY_SERVICE_ID_BASE_RID (0x00000050L)
#define SECURITY_SERVICE_ID_RID_COUNT (6L)

#define SECURITY_RESERVED_ID_BASE_RID (0x00000051L)

#define SECURITY_APPPOOL_ID_BASE_RID (0x00000052L)
#define SECURITY_APPPOOL_ID_RID_COUNT (6L)

#define SECURITY_VIRTUALSERVER_ID_BASE_RID (0x00000053L)
#define SECURITY_VIRTUALSERVER_ID_RID_COUNT (6L)

#define SECURITY_USERMODEDRIVERHOST_ID_BASE_RID (0x00000054L)
#define SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT (6L)

#define SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID (0x00000055L)
#define SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT (6L)

#define SECURITY_WMIHOST_ID_BASE_RID (0x00000056L)
#define SECURITY_WMIHOST_ID_RID_COUNT (6L)

#define SECURITY_TASK_ID_BASE_RID (0x00000057L)

#define SECURITY_NFS_ID_BASE_RID (0x00000058L)

#define SECURITY_COM_ID_BASE_RID (0x00000059L)

#define SECURITY_VIRTUALACCOUNT_ID_RID_COUNT (6L)

#define SECURITY_MAX_BASE_RID (0x0000006FL)
#define SECURITY_MAX_ALWAYS_FILTERED (0x000003E7L)
#define SECURITY_MIN_NEVER_FILTERED (0x000003E8L)

#define SECURITY_OTHER_ORGANIZATION_RID (0x000003E8L)

//
//Service SID type RIDs are in the range 0x50- 0x6F.  Therefore, we are giving  the next available RID to Windows Mobile team.
//
#define SECURITY_WINDOWSMOBILE_ID_BASE_RID (0x00000070L)


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////



#define DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS (0x000001F2L)

#define FOREST_USER_RID_MAX (0x000001F3L)

// Well-known users ...

#define DOMAIN_USER_RID_ADMIN (0x000001F4L)
#define DOMAIN_USER_RID_GUEST (0x000001F5L)
#define DOMAIN_USER_RID_KRBTGT (0x000001F6L)

#define DOMAIN_USER_RID_MAX (0x000003E7L)


// well-known groups ...

#define DOMAIN_GROUP_RID_ADMINS (0x00000200L)
#define DOMAIN_GROUP_RID_USERS (0x00000201L)
#define DOMAIN_GROUP_RID_GUESTS (0x00000202L)
#define DOMAIN_GROUP_RID_COMPUTERS (0x00000203L)
#define DOMAIN_GROUP_RID_CONTROLLERS (0x00000204L)
#define DOMAIN_GROUP_RID_CERT_ADMINS (0x00000205L)
#define DOMAIN_GROUP_RID_SCHEMA_ADMINS (0x00000206L)
#define DOMAIN_GROUP_RID_ENTERPRISE_ADMINS (0x00000207L)
#define DOMAIN_GROUP_RID_POLICY_ADMINS (0x00000208L)
#define DOMAIN_GROUP_RID_READONLY_CONTROLLERS (0x00000209L)

// well-known aliases ...

#define DOMAIN_ALIAS_RID_ADMINS (0x00000220L)
#define DOMAIN_ALIAS_RID_USERS (0x00000221L)
#define DOMAIN_ALIAS_RID_GUESTS (0x00000222L)
#define DOMAIN_ALIAS_RID_POWER_USERS (0x00000223L)

#define DOMAIN_ALIAS_RID_ACCOUNT_OPS (0x00000224L)
#define DOMAIN_ALIAS_RID_SYSTEM_OPS (0x00000225L)
#define DOMAIN_ALIAS_RID_PRINT_OPS (0x00000226L)
#define DOMAIN_ALIAS_RID_BACKUP_OPS (0x00000227L)

#define DOMAIN_ALIAS_RID_REPLICATOR (0x00000228L)
#define DOMAIN_ALIAS_RID_RAS_SERVERS (0x00000229L)
#define DOMAIN_ALIAS_RID_PREW2KCOMPACCESS (0x0000022AL)
#define DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS (0x0000022BL)
#define DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS (0x0000022CL)
#define DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS (0x0000022DL)

#define DOMAIN_ALIAS_RID_MONITORING_USERS (0x0000022EL)
#define DOMAIN_ALIAS_RID_LOGGING_USERS (0x0000022FL)
#define DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS (0x00000230L)
#define DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS (0x00000231L)
#define DOMAIN_ALIAS_RID_DCOM_USERS (0x00000232L)
#define DOMAIN_ALIAS_RID_IUSERS (0x00000238L)
#define DOMAIN_ALIAS_RID_CRYPTO_OPERATORS (0x00000239L)
#define DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP (0x0000023BL)
#define DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP (0x0000023CL)
#define DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP (0x0000023DL)
#define DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP (0x0000023EL)


#define SECURITY_MANDATORY_LABEL_AUTHORITY {0,0,0,0,0,16}
#define SECURITY_MANDATORY_UNTRUSTED_RID (0x00000000L)
#define SECURITY_MANDATORY_LOW_RID (0x00001000L)
#define SECURITY_MANDATORY_MEDIUM_RID (0x00002000L)
#define SECURITY_MANDATORY_MEDIUM_PLUS_RID (SECURITY_MANDATORY_MEDIUM_RID + 0x100)
#define SECURITY_MANDATORY_HIGH_RID (0x00003000L)
#define SECURITY_MANDATORY_SYSTEM_RID (0x00004000L)
#define SECURITY_MANDATORY_PROTECTED_PROCESS_RID (0x00005000L)

//
// SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
// can be set by a usermode caller.
//

#define SECURITY_MANDATORY_MAXIMUM_USER_RID SECURITY_MANDATORY_SYSTEM_RID

#define MANDATORY_LEVEL_TO_MANDATORY_RID(IL) (IL * 0x1000)



//
// Well known SID definitions for lookup.
//

typedef enum {

    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
} WELL_KNOWN_SID_TYPE;

//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3e7 = 999)
//

#define SYSTEM_LUID { 0x3e7, 0x0 }
#define ANONYMOUS_LOGON_LUID { 0x3e6, 0x0 }
#define LOCALSERVICE_LUID { 0x3e5, 0x0 }
#define NETWORKSERVICE_LUID { 0x3e4, 0x0 }
#define IUSER_LUID { 0x3e3, 0x0 }

// end_ntifs

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Group attributes
//

#define SE_GROUP_MANDATORY (0x00000001L)
#define SE_GROUP_ENABLED_BY_DEFAULT (0x00000002L)
#define SE_GROUP_ENABLED (0x00000004L)
#define SE_GROUP_OWNER (0x00000008L)
#define SE_GROUP_USE_FOR_DENY_ONLY (0x00000010L)
#define SE_GROUP_INTEGRITY (0x00000020L)
#define SE_GROUP_INTEGRITY_ENABLED (0x00000040L)
#define SE_GROUP_LOGON_ID (0xC0000000L)
#define SE_GROUP_RESOURCE (0x20000000L)

#define SE_GROUP_VALID_ATTRIBUTES (SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED | SE_GROUP_OWNER | SE_GROUP_USE_FOR_DENY_ONLY | SE_GROUP_LOGON_ID | SE_GROUP_RESOURCE | SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED)
# 7039 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// User attributes
//

// (None yet defined.)




////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//

// begin_wdm
// This is the *current* ACL revision

#define ACL_REVISION (2)
#define ACL_REVISION_DS (4)

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated

#define ACL_REVISION1 (1)
#define MIN_ACL_REVISION ACL_REVISION2
#define ACL_REVISION2 (2)
#define ACL_REVISION3 (3)
#define ACL_REVISION4 (4)
#define MAX_ACL_REVISION ACL_REVISION4

typedef struct _ACL {
    BYTE AclRevision;
    BYTE Sbz1;
    WORD AclSize;
    WORD AceCount;
    WORD Sbz2;
} ACL;
typedef ACL *PACL;

// end_wdm
// begin_ntifs

//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.

typedef struct _ACE_HEADER {
    BYTE AceType;
    BYTE AceFlags;
    WORD AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;

//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//

#define ACCESS_MIN_MS_ACE_TYPE (0x0)
#define ACCESS_ALLOWED_ACE_TYPE (0x0)
#define ACCESS_DENIED_ACE_TYPE (0x1)
#define SYSTEM_AUDIT_ACE_TYPE (0x2)
#define SYSTEM_ALARM_ACE_TYPE (0x3)
#define ACCESS_MAX_MS_V2_ACE_TYPE (0x3)

#define ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)
#define ACCESS_MAX_MS_V3_ACE_TYPE (0x4)

#define ACCESS_MIN_MS_OBJECT_ACE_TYPE (0x5)
#define ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)
#define ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)
#define SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)
#define SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)
#define ACCESS_MAX_MS_OBJECT_ACE_TYPE (0x8)

#define ACCESS_MAX_MS_V4_ACE_TYPE (0x8)
#define ACCESS_MAX_MS_ACE_TYPE (0x8)

#define ACCESS_ALLOWED_CALLBACK_ACE_TYPE (0x9)
#define ACCESS_DENIED_CALLBACK_ACE_TYPE (0xA)
#define ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE (0xB)
#define ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE (0xC)
#define SYSTEM_AUDIT_CALLBACK_ACE_TYPE (0xD)
#define SYSTEM_ALARM_CALLBACK_ACE_TYPE (0xE)
#define SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE (0xF)
#define SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE (0x10)

#define SYSTEM_MANDATORY_LABEL_ACE_TYPE (0x11)
#define ACCESS_MAX_MS_V5_ACE_TYPE (0x11)


//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//

#define OBJECT_INHERIT_ACE (0x1)
#define CONTAINER_INHERIT_ACE (0x2)
#define NO_PROPAGATE_INHERIT_ACE (0x4)
#define INHERIT_ONLY_ACE (0x8)
#define INHERITED_ACE (0x10)
#define VALID_INHERIT_FLAGS (0x1F)


//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//

//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//

#define SUCCESSFUL_ACCESS_ACE_FLAG (0x40)
#define FAILED_ACCESS_ACE_FLAG (0x80)


//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//

//  The following are the four predefined ACE types.

//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.


typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

#define SYSTEM_MANDATORY_LABEL_NO_WRITE_UP 0x1
#define SYSTEM_MANDATORY_LABEL_NO_READ_UP 0x2
#define SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP 0x4

#define SYSTEM_MANDATORY_LABEL_VALID_MASK (SYSTEM_MANDATORY_LABEL_NO_WRITE_UP | SYSTEM_MANDATORY_LABEL_NO_READ_UP | SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP)


// end_ntifs


typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;

//
// Callback ace support in post Win2000.
// Resource managers can put their own data after Sidstart + Length of the sid
//

typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    // Opaque resouce manager specific data
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;

//
// Currently define Flags for "OBJECT" ACE types.
//

#define ACE_OBJECT_TYPE_PRESENT 0x1
#define ACE_INHERITED_OBJECT_TYPE_PRESENT 0x2


//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//

typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;

//
//  This record is returned/sent if the user is requesting/setting the
//  AclRevisionInformation
//

typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;

//
//  This record is returned if the user is requesting AclSizeInformation
//

typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//

// begin_wdm
//
// Current security descriptor revision value
//

#define SECURITY_DESCRIPTOR_REVISION (1)
#define SECURITY_DESCRIPTOR_REVISION1 (1)

// end_wdm
// begin_ntifs

#define SECURITY_DESCRIPTOR_MIN_LENGTH (sizeof(SECURITY_DESCRIPTOR))


typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

#define SE_OWNER_DEFAULTED (0x0001)
#define SE_GROUP_DEFAULTED (0x0002)
#define SE_DACL_PRESENT (0x0004)
#define SE_DACL_DEFAULTED (0x0008)
#define SE_SACL_PRESENT (0x0010)
#define SE_SACL_DEFAULTED (0x0020)
#define SE_DACL_AUTO_INHERIT_REQ (0x0100)
#define SE_SACL_AUTO_INHERIT_REQ (0x0200)
#define SE_DACL_AUTO_INHERITED (0x0400)
#define SE_SACL_AUTO_INHERITED (0x0800)
#define SE_DACL_PROTECTED (0x1000)
#define SE_SACL_PROTECTED (0x2000)
#define SE_RM_CONTROL_VALID (0x4000)
#define SE_SELF_RELATIVE (0x8000)

//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//

typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE Revision;
   BYTE Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

// end_ntifs

// Where:
//
//     Revision - Contains the revision level of the security
//         descriptor.  This allows this structure to be passed between
//         systems or stored on disk even though it is expected to
//         change in the future.
//
//     Control - A set of flags which qualify the meaning of the
//         security descriptor or individual fields of the security
//         descriptor.
//
//     Owner - is a pointer to an SID representing an object's owner.
//         If this field is null, then no owner SID is present in the
//         security descriptor.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Group - is a pointer to an SID representing an object's primary
//         group.  If this field is null, then no primary group SID is
//         present in the security descriptor.  If the security descriptor
//         is in self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Sacl - is a pointer to a system ACL.  This field value is only
//         valid if the DaclPresent control flag is set.  If the
//         SaclPresent flag is set and this field is null, then a null
//         ACL  is specified.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the ACL, rather than a pointer.
//
//     Dacl - is a pointer to a discretionary ACL.  This field value is
//         only valid if the DaclPresent control flag is set.  If the
//         DaclPresent flag is set and this field is null, then a null
//         ACL (unconditionally granting access) is specified.  If the
//         security descriptor is in self-relative form, then this field
//         contains an offset to the ACL, rather than a pointer.
//




////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Object Type list for AccessCheckByType               //
//                                                                    //
////////////////////////////////////////////////////////////////////////

typedef struct _OBJECT_TYPE_LIST {
    WORD Level;
    WORD Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;

//
// DS values for Level
//

#define ACCESS_OBJECT_GUID 0
#define ACCESS_PROPERTY_SET_GUID 1
#define ACCESS_PROPERTY_GUID 2

#define ACCESS_MAX_LEVEL 4

//
// Parameters to NtAccessCheckByTypeAndAditAlarm
//

typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;

#define AUDIT_ALLOW_NO_PRIVILEGE 0x1

//
// DS values for Source and ObjectTypeName
//

#define ACCESS_DS_SOURCE_A "DS"
#define ACCESS_DS_SOURCE_W L"DS"
#define ACCESS_DS_OBJECT_TYPE_NAME_A "Directory Service Object"
#define ACCESS_DS_OBJECT_TYPE_NAME_W L"Directory Service Object"

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////

// end_ntifs
// begin_wdm
//
// Privilege attributes
//

#define SE_PRIVILEGE_ENABLED_BY_DEFAULT (0x00000001L)
#define SE_PRIVILEGE_ENABLED (0x00000002L)
#define SE_PRIVILEGE_REMOVED (0X00000004L)
#define SE_PRIVILEGE_USED_FOR_ACCESS (0x80000000L)

#define SE_PRIVILEGE_VALID_ATTRIBUTES (SE_PRIVILEGE_ENABLED_BY_DEFAULT | SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_REMOVED | SE_PRIVILEGE_USED_FOR_ACCESS)





//
// Privilege Set Control flags
//

#define PRIVILEGE_SET_ALL_NECESSARY (1)

//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;




//
// Values for different access granted\denied reasons:
// AccessReasonAceN = AccessReasonAce + N.
// AccessReasonPrivilegeN = AccessReasonPrivilege + N.
//

#define ACCESS_REASON_TYPE_MASK 0xffff0000
#define ACCESS_REASON_DATA_MASK 0x0000ffff

typedef enum _ACCESS_REASON_TYPE{

    AccessReasonNone = 0x00000000, // Indicate no reason for the bit. The bit may not be checked, or just no known reason.

    //
    // The lowest 2 bytes store the index of the ACE that grant/deny this bit.
    // If the corresponding access maskt is zero, then it is deny ACE; otherwise,
    // it is allow ACE.
    //
    AccessReasonAllowedAce = 0x00010000, // Granted a permission.
    AccessReasonDeniedAce = 0x00020000, // Denied a permission.

    AccessReasonAllowedParentAce = 0x00030000, // Granted a permission from parent ACE
    AccessReasonDeniedParentAce = 0x00040000, // Denied a permission from parent ACE

    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,


    AccessReasonIntegrityLevel = 0x00300000,

    AccessReasonOwnership = 0x00400000,

    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,

    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000 // this access bit is not granted by any ACE.
} ACCESS_REASON_TYPE;

 //
// Structure to hold access denied\granted reason for every bit of ACCESS_MASK.
// There are 32-bits in ACCESS_MASK and only 27-bits are actually valid on
// return from AccessCheck because MAXIMUM_ALLOWED, GENERIC_READ,
// GENERIC_WRITE, GENERIC_EXECUTE, and GENERIC_ALL are never returned.
//
// The content in Data fields depends on the Access Reason, for example,
// if the reason is AccessReasonAce, the Data will be the ACE ID.
// If there are more than one reason (more than one bit is set), the array size
// of the Data is equal to the number of bits set (or number of reasons).
// The Data could be null for a particular reason.
//

typedef DWORD ACCESS_REASON;

typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;


/*

The following data structures are defined to consolidate various falvors of

access check functions. In particular for Windows 7, the new access check

function will enable security attribute check, plus returning the reason

for a access check result.



The new access check function based on these data structures will

form the foundation to reimplement other flavors of access check

functions.



*/
# 7765 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Structure to hold pointer to security descriptor and its unique id, which
// can be used for caching access check results.
// (NOTE NOTE) The cache key can be constructed by SecurityDescriptorId, Token and
// PrincipalSelfSid. Watch how GenericMapping affects the cache results.
//
#define SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE 0x00000001
#define SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE 0x00000002
#define SE_SECURITY_DESCRIPTOR_VALID_FLAGS 0x00000003

typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid; // Need to watch how this field affects the cache.
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;


typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount; // Indicate the array size of GrantedAccess and AccessStatus, it only can be either 1 or ObjectTypeListCount.
    PACCESS_MASK GrantedAccess;
    PDWORD AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#define SE_CREATE_TOKEN_NAME TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME TEXT("SeRemoteShutdownPrivilege")
#define SE_UNDOCK_NAME TEXT("SeUndockPrivilege")
#define SE_SYNC_AGENT_NAME TEXT("SeSyncAgentPrivilege")
#define SE_ENABLE_DELEGATION_NAME TEXT("SeEnableDelegationPrivilege")
#define SE_MANAGE_VOLUME_NAME TEXT("SeManageVolumePrivilege")
#define SE_IMPERSONATE_NAME TEXT("SeImpersonatePrivilege")
#define SE_CREATE_GLOBAL_NAME TEXT("SeCreateGlobalPrivilege")
#define SE_TRUSTED_CREDMAN_ACCESS_NAME TEXT("SeTrustedCredManAccessPrivilege")
#define SE_RELABEL_NAME TEXT("SeRelabelPrivilege")
#define SE_INC_WORKING_SET_NAME TEXT("SeIncreaseWorkingSetPrivilege")
#define SE_TIME_ZONE_NAME TEXT("SeTimeZonePrivilege")
#define SE_CREATE_SYMBOLIC_LINK_NAME TEXT("SeCreateSymbolicLinkPrivilege")



////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_wdm
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;

#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation
#define SECURITY_MIN_IMPERSONATION_LEVEL SecurityAnonymous
#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation
#define VALID_IMPERSONATION_LEVEL(L) (((L) >= SECURITY_MIN_IMPERSONATION_LEVEL) && ((L) <= SECURITY_MAX_IMPERSONATION_LEVEL))


////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////


//
// Token Specific Access Rights.
//

#define TOKEN_ASSIGN_PRIMARY (0x0001)
#define TOKEN_DUPLICATE (0x0002)
#define TOKEN_IMPERSONATE (0x0004)
#define TOKEN_QUERY (0x0008)
#define TOKEN_QUERY_SOURCE (0x0010)
#define TOKEN_ADJUST_PRIVILEGES (0x0020)
#define TOKEN_ADJUST_GROUPS (0x0040)
#define TOKEN_ADJUST_DEFAULT (0x0080)
#define TOKEN_ADJUST_SESSIONID (0x0100)

#define TOKEN_ALL_ACCESS_P (STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT )
# 7912 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define TOKEN_ALL_ACCESS (TOKEN_ALL_ACCESS_P | TOKEN_ADJUST_SESSIONID )





#define TOKEN_READ (STANDARD_RIGHTS_READ | TOKEN_QUERY)



#define TOKEN_WRITE (STANDARD_RIGHTS_WRITE | TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT)




#define TOKEN_EXECUTE (STANDARD_RIGHTS_EXECUTE)

//
//
// Token Types
//

typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;

//
// Token elevation values describe the relative strength of a given token.
// A full token is a token with all groups and privileges to which the principal
// is authorized.  A limited token is one with some groups or privileges removed.
//

typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;

//
// Token Information Classes.
//


typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    MaxTokenInfoClass // MaxTokenInfoClass should always be the last enum
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

//
// Token information class structures
//


typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;

typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;



    SID_AND_ATTRIBUTES Groups[1];

} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;

#define TOKEN_MANDATORY_POLICY_OFF 0x0
#define TOKEN_MANDATORY_POLICY_NO_WRITE_UP 0x1
#define TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN 0x2

#define TOKEN_MANDATORY_POLICY_VALID_MASK (TOKEN_MANDATORY_POLICY_NO_WRITE_UP | TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN)


typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;

//
// Valid bits for each TOKEN_AUDIT_POLICY policy mask field.
//

#define POLICY_AUDIT_SUBCATEGORY_COUNT (53)

typedef struct _TOKEN_AUDIT_POLICY {
    BYTE PerUserPolicy[(((53)) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;

#define TOKEN_SOURCE_LENGTH 8

typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;


typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;




//
// Security Tracking Mode
//

#define SECURITY_DYNAMIC_TRACKING (TRUE)
#define SECURITY_STATIC_TRACKING (FALSE)

typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;

#define DISABLE_MAX_PRIVILEGE 0x1
#define SANDBOX_INERT 0x2
#define LUA_TOKEN 0x4
#define WRITE_RESTRICTED 0x8

typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;

#define OWNER_SECURITY_INFORMATION (0x00000001L)
#define GROUP_SECURITY_INFORMATION (0x00000002L)
#define DACL_SECURITY_INFORMATION (0x00000004L)
#define SACL_SECURITY_INFORMATION (0x00000008L)
#define LABEL_SECURITY_INFORMATION (0x00000010L)

#define PROTECTED_DACL_SECURITY_INFORMATION (0x80000000L)
#define PROTECTED_SACL_SECURITY_INFORMATION (0x40000000L)
#define UNPROTECTED_DACL_SECURITY_INFORMATION (0x20000000L)
#define UNPROTECTED_SACL_SECURITY_INFORMATION (0x10000000L)

#define PROCESS_TERMINATE (0x0001)
#define PROCESS_CREATE_THREAD (0x0002)
#define PROCESS_SET_SESSIONID (0x0004)
#define PROCESS_VM_OPERATION (0x0008)
#define PROCESS_VM_READ (0x0010)
#define PROCESS_VM_WRITE (0x0020)
#define PROCESS_DUP_HANDLE (0x0040)
#define PROCESS_CREATE_PROCESS (0x0080)
#define PROCESS_SET_QUOTA (0x0100)
#define PROCESS_SET_INFORMATION (0x0200)
#define PROCESS_QUERY_INFORMATION (0x0400)
#define PROCESS_SUSPEND_RESUME (0x0800)
#define PROCESS_QUERY_LIMITED_INFORMATION (0x1000)

#define PROCESS_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF)
# 8209 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define MAXIMUM_PROC_PER_GROUP 64







#define MAXIMUM_PROCESSORS MAXIMUM_PROC_PER_GROUP

#define THREAD_TERMINATE (0x0001)
#define THREAD_SUSPEND_RESUME (0x0002)
#define THREAD_GET_CONTEXT (0x0008)
#define THREAD_SET_CONTEXT (0x0010)
#define THREAD_QUERY_INFORMATION (0x0040)
#define THREAD_SET_INFORMATION (0x0020)
#define THREAD_SET_THREAD_TOKEN (0x0080)
#define THREAD_IMPERSONATE (0x0100)
#define THREAD_DIRECT_IMPERSONATION (0x0200)
// begin_wdm
#define THREAD_SET_LIMITED_INFORMATION (0x0400)
#define THREAD_QUERY_LIMITED_INFORMATION (0x0800)

#define THREAD_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFFF)





#define JOB_OBJECT_ASSIGN_PROCESS (0x0001)
#define JOB_OBJECT_SET_ATTRIBUTES (0x0002)
#define JOB_OBJECT_QUERY (0x0004)
#define JOB_OBJECT_TERMINATE (0x0008)
#define JOB_OBJECT_SET_SECURITY_ATTRIBUTES (0x0010)
#define JOB_OBJECT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1F )


typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle; // Handle to job object to insert
    DWORD MemberLevel; // Level of this job in the set. Must be > 0. Can be sparse.
    DWORD Flags; // Unused. Must be zero
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;






    PVOID FiberData;

    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;

//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;







    DWORD FiberData;


    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
# 8308 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
    DWORD64 FiberData;


    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;



#define THREAD_BASE_PRIORITY_LOWRT 15
#define THREAD_BASE_PRIORITY_MAX 2
#define THREAD_BASE_PRIORITY_MIN (-2)
#define THREAD_BASE_PRIORITY_IDLE (-15)

typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {
    DWORD UmsVersion;
        PVOID UmsContext;
        PVOID UmsCompletionList;
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES;

typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;

#define QUOTA_LIMITS_HARDWS_MIN_ENABLE 0x00000001
#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 0x00000002
#define QUOTA_LIMITS_HARDWS_MAX_ENABLE 0x00000004
#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 0x00000008
#define QUOTA_LIMITS_USE_DEFAULT_LIMITS 0x00000010

typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0 : 25;
    } s;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit; // Limit expressed in pages
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit; // Limit expressed in pages
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;

#define MAX_HW_COUNTERS 16
#define THREAD_PROFILING_FLAG_DISPATCH 0x00000001

typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;

typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;

//
// N.B. The JOBOBJECT_SECURITY_LIMIT_INFORMATION information class is no longer supported.
//

typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

#define JOB_OBJECT_TERMINATE_AT_END_OF_JOB 0
#define JOB_OBJECT_POST_AT_END_OF_JOB 1

//
// Completion Port Messages for job objects
//
// These values are returned via the lpNumberOfBytesTransferred parameter
//

#define JOB_OBJECT_MSG_END_OF_JOB_TIME 1
#define JOB_OBJECT_MSG_END_OF_PROCESS_TIME 2
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT 3
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO 4
#define JOB_OBJECT_MSG_NEW_PROCESS 6
#define JOB_OBJECT_MSG_EXIT_PROCESS 7
#define JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS 8
#define JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT 9
#define JOB_OBJECT_MSG_JOB_MEMORY_LIMIT 10

//
// Basic Limits
//
#define JOB_OBJECT_LIMIT_WORKINGSET 0x00000001
#define JOB_OBJECT_LIMIT_PROCESS_TIME 0x00000002
#define JOB_OBJECT_LIMIT_JOB_TIME 0x00000004
#define JOB_OBJECT_LIMIT_ACTIVE_PROCESS 0x00000008
#define JOB_OBJECT_LIMIT_AFFINITY 0x00000010
#define JOB_OBJECT_LIMIT_PRIORITY_CLASS 0x00000020
#define JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME 0x00000040
#define JOB_OBJECT_LIMIT_SCHEDULING_CLASS 0x00000080

//
// Extended Limits
//
#define JOB_OBJECT_LIMIT_PROCESS_MEMORY 0x00000100
#define JOB_OBJECT_LIMIT_JOB_MEMORY 0x00000200
#define JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION 0x00000400
#define JOB_OBJECT_LIMIT_BREAKAWAY_OK 0x00000800
#define JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK 0x00001000
#define JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE 0x00002000

#define JOB_OBJECT_LIMIT_SUBSET_AFFINITY 0x00004000
#define JOB_OBJECT_LIMIT_RESERVED3 0x00008000
#define JOB_OBJECT_LIMIT_RESERVED4 0x00010000
#define JOB_OBJECT_LIMIT_RESERVED5 0x00020000
#define JOB_OBJECT_LIMIT_RESERVED6 0x00040000


#define JOB_OBJECT_LIMIT_VALID_FLAGS 0x0007ffff

#define JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS 0x000000ff
#define JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS 0x00007fff
#define JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS 0x0007ffff

//
// UI restrictions for jobs
//

#define JOB_OBJECT_UILIMIT_NONE 0x00000000

#define JOB_OBJECT_UILIMIT_HANDLES 0x00000001
#define JOB_OBJECT_UILIMIT_READCLIPBOARD 0x00000002
#define JOB_OBJECT_UILIMIT_WRITECLIPBOARD 0x00000004
#define JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS 0x00000008
#define JOB_OBJECT_UILIMIT_DISPLAYSETTINGS 0x00000010
#define JOB_OBJECT_UILIMIT_GLOBALATOMS 0x00000020
#define JOB_OBJECT_UILIMIT_DESKTOP 0x00000040
#define JOB_OBJECT_UILIMIT_EXITWINDOWS 0x00000080

#define JOB_OBJECT_UILIMIT_ALL 0x000000FF

#define JOB_OBJECT_UI_VALID_FLAGS 0x000000FF

#define JOB_OBJECT_SECURITY_NO_ADMIN 0x00000001
#define JOB_OBJECT_SECURITY_RESTRICTED_TOKEN 0x00000002
#define JOB_OBJECT_SECURITY_ONLY_TOKEN 0x00000004
#define JOB_OBJECT_SECURITY_FILTER_TOKENS 0x00000008

#define JOB_OBJECT_SECURITY_VALID_FLAGS 0x0000000f

typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation, // deprecated
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    MaxJobObjectInfoClass
    } JOBOBJECTINFOCLASS;

//
#define EVENT_MODIFY_STATE 0x0002
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

#define MUTANT_QUERY_STATE 0x0001

#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE| MUTANT_QUERY_STATE)


#define SEMAPHORE_MODIFY_STATE 0x0002
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

//
// Timer Specific Access Rights.
//

#define TIMER_QUERY_STATE 0x0001
#define TIMER_MODIFY_STATE 0x0002

#define TIMER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE| TIMER_QUERY_STATE|TIMER_MODIFY_STATE)



#define TIME_ZONE_ID_UNKNOWN 0
#define TIME_ZONE_ID_STANDARD 1
#define TIME_ZONE_ID_DAYLIGHT 2


typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;

#define LTP_PC_SMT 0x1

typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;

#define CACHE_FULLY_ASSOCIATIVE 0xFF

typedef struct _CACHE_DESCRIPTOR {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG Reserved[2];
    } u;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE Flags;
    BYTE Reserved[21];
    WORD GroupCount;
    GROUP_AFFINITY GroupMask[1];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
    BYTE MaximumProcessorCount;
    BYTE ActiveProcessorCount;
    BYTE Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
    WORD MaximumGroupCount;
    WORD ActiveGroupCount;
    BYTE Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

 struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    } u;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

// end_wdm end_ntminiport

typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;


#define PROCESSOR_INTEL_386 386
#define PROCESSOR_INTEL_486 486
#define PROCESSOR_INTEL_PENTIUM 586
#define PROCESSOR_INTEL_IA64 2200
#define PROCESSOR_AMD_X8664 8664
#define PROCESSOR_MIPS_R4000 4000
#define PROCESSOR_ALPHA_21064 21064
#define PROCESSOR_PPC_601 601
#define PROCESSOR_PPC_603 603
#define PROCESSOR_PPC_604 604
#define PROCESSOR_PPC_620 620
#define PROCESSOR_HITACHI_SH3 10003
#define PROCESSOR_HITACHI_SH3E 10004
#define PROCESSOR_HITACHI_SH4 10005
#define PROCESSOR_MOTOROLA_821 821
#define PROCESSOR_SHx_SH3 103
#define PROCESSOR_SHx_SH4 104
#define PROCESSOR_STRONGARM 2577
#define PROCESSOR_ARM720 1824
#define PROCESSOR_ARM820 2080
#define PROCESSOR_ARM920 2336
#define PROCESSOR_ARM_7TDMI 70001
#define PROCESSOR_OPTIL 0x494f

#define PROCESSOR_ARCHITECTURE_INTEL 0
#define PROCESSOR_ARCHITECTURE_MIPS 1
#define PROCESSOR_ARCHITECTURE_ALPHA 2
#define PROCESSOR_ARCHITECTURE_PPC 3
#define PROCESSOR_ARCHITECTURE_SHX 4
#define PROCESSOR_ARCHITECTURE_ARM 5
#define PROCESSOR_ARCHITECTURE_IA64 6
#define PROCESSOR_ARCHITECTURE_ALPHA64 7
#define PROCESSOR_ARCHITECTURE_MSIL 8
#define PROCESSOR_ARCHITECTURE_AMD64 9
#define PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 10

#define PROCESSOR_ARCHITECTURE_UNKNOWN 0xFFFF

#define PF_FLOATING_POINT_PRECISION_ERRATA 0
#define PF_FLOATING_POINT_EMULATED 1
#define PF_COMPARE_EXCHANGE_DOUBLE 2
#define PF_MMX_INSTRUCTIONS_AVAILABLE 3
#define PF_PPC_MOVEMEM_64BIT_OK 4
#define PF_ALPHA_BYTE_INSTRUCTIONS 5
#define PF_XMMI_INSTRUCTIONS_AVAILABLE 6
#define PF_3DNOW_INSTRUCTIONS_AVAILABLE 7
#define PF_RDTSC_INSTRUCTION_AVAILABLE 8
#define PF_PAE_ENABLED 9
#define PF_XMMI64_INSTRUCTIONS_AVAILABLE 10
#define PF_SSE_DAZ_MODE_AVAILABLE 11
#define PF_NX_ENABLED 12
#define PF_SSE3_INSTRUCTIONS_AVAILABLE 13
#define PF_COMPARE_EXCHANGE128 14
#define PF_COMPARE64_EXCHANGE128 15
#define PF_CHANNELS_ENABLED 16
#define PF_XSAVE_ENABLED 17

//
// Known extended CPU state feature IDs
//

#define XSTATE_LEGACY_FLOATING_POINT 0
#define XSTATE_LEGACY_SSE 1
#define XSTATE_GSSE 2

#define XSTATE_MASK_LEGACY_FLOATING_POINT (1i64 << (XSTATE_LEGACY_FLOATING_POINT))
#define XSTATE_MASK_LEGACY_SSE (1i64 << (XSTATE_LEGACY_SSE))
#define XSTATE_MASK_LEGACY (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE)
#define XSTATE_MASK_GSSE (1i64 << (XSTATE_GSSE))

#define MAXIMUM_XSTATE_FEATURES 64

//
// Extended processor state configuration
//

typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
    // Mask of enabled features
    DWORD64 EnabledFeatures;

    // Total size of the save area
    DWORD Size;

    DWORD OptimizedSave : 1;

    // List of features (
    XSTATE_FEATURE Features[64];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;


typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD AllocationProtect;
    DWORD __alignment1;
    ULONGLONG RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
    DWORD __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;

#define SECTION_QUERY 0x0001
#define SECTION_MAP_WRITE 0x0002
#define SECTION_MAP_READ 0x0004
#define SECTION_MAP_EXECUTE 0x0008
#define SECTION_EXTEND_SIZE 0x0010
#define SECTION_MAP_EXECUTE_EXPLICIT 0x0020

#define SECTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY| SECTION_MAP_WRITE | SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_EXTEND_SIZE)





#define SESSION_QUERY_ACCESS 0x0001
#define SESSION_MODIFY_ACCESS 0x0002

#define SESSION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SESSION_QUERY_ACCESS | SESSION_MODIFY_ACCESS)



#define PAGE_NOACCESS 0x01
#define PAGE_READONLY 0x02
#define PAGE_READWRITE 0x04
#define PAGE_WRITECOPY 0x08
#define PAGE_EXECUTE 0x10
#define PAGE_EXECUTE_READ 0x20
#define PAGE_EXECUTE_READWRITE 0x40
#define PAGE_EXECUTE_WRITECOPY 0x80
#define PAGE_GUARD 0x100
#define PAGE_NOCACHE 0x200
#define PAGE_WRITECOMBINE 0x400
#define MEM_COMMIT 0x1000
#define MEM_RESERVE 0x2000
#define MEM_DECOMMIT 0x4000
#define MEM_RELEASE 0x8000
#define MEM_FREE 0x10000
#define MEM_PRIVATE 0x20000
#define MEM_MAPPED 0x40000
#define MEM_RESET 0x80000
#define MEM_TOP_DOWN 0x100000
#define MEM_WRITE_WATCH 0x200000
#define MEM_PHYSICAL 0x400000
#define MEM_ROTATE 0x800000
#define MEM_LARGE_PAGES 0x20000000
#define MEM_4MB_PAGES 0x80000000
#define SEC_FILE 0x800000
#define SEC_IMAGE 0x1000000
#define SEC_PROTECTED_IMAGE 0x2000000
#define SEC_RESERVE 0x4000000
#define SEC_COMMIT 0x8000000
#define SEC_NOCACHE 0x10000000
#define SEC_WRITECOMBINE 0x40000000
#define SEC_LARGE_PAGES 0x80000000
#define MEM_IMAGE SEC_IMAGE
#define WRITE_WATCH_FLAG_RESET 0x01

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

#define FILE_READ_DATA ( 0x0001 )
#define FILE_LIST_DIRECTORY ( 0x0001 )

#define FILE_WRITE_DATA ( 0x0002 )
#define FILE_ADD_FILE ( 0x0002 )

#define FILE_APPEND_DATA ( 0x0004 )
#define FILE_ADD_SUBDIRECTORY ( 0x0004 )
#define FILE_CREATE_PIPE_INSTANCE ( 0x0004 )


#define FILE_READ_EA ( 0x0008 )

#define FILE_WRITE_EA ( 0x0010 )

#define FILE_EXECUTE ( 0x0020 )
#define FILE_TRAVERSE ( 0x0020 )

#define FILE_DELETE_CHILD ( 0x0040 )

#define FILE_READ_ATTRIBUTES ( 0x0080 )

#define FILE_WRITE_ATTRIBUTES ( 0x0100 )

#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF)

#define FILE_GENERIC_READ (STANDARD_RIGHTS_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE)






#define FILE_GENERIC_WRITE (STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE)







#define FILE_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE | FILE_READ_ATTRIBUTES | FILE_EXECUTE | SYNCHRONIZE)




#define FILE_SHARE_READ 0x00000001
#define FILE_SHARE_WRITE 0x00000002
#define FILE_SHARE_DELETE 0x00000004
#define FILE_ATTRIBUTE_READONLY 0x00000001
#define FILE_ATTRIBUTE_HIDDEN 0x00000002
#define FILE_ATTRIBUTE_SYSTEM 0x00000004
#define FILE_ATTRIBUTE_DIRECTORY 0x00000010
#define FILE_ATTRIBUTE_ARCHIVE 0x00000020
#define FILE_ATTRIBUTE_DEVICE 0x00000040
#define FILE_ATTRIBUTE_NORMAL 0x00000080
#define FILE_ATTRIBUTE_TEMPORARY 0x00000100
#define FILE_ATTRIBUTE_SPARSE_FILE 0x00000200
#define FILE_ATTRIBUTE_REPARSE_POINT 0x00000400
#define FILE_ATTRIBUTE_COMPRESSED 0x00000800
#define FILE_ATTRIBUTE_OFFLINE 0x00001000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED 0x00004000
#define FILE_ATTRIBUTE_VIRTUAL 0x00010000
#define FILE_NOTIFY_CHANGE_FILE_NAME 0x00000001
#define FILE_NOTIFY_CHANGE_DIR_NAME 0x00000002
#define FILE_NOTIFY_CHANGE_ATTRIBUTES 0x00000004
#define FILE_NOTIFY_CHANGE_SIZE 0x00000008
#define FILE_NOTIFY_CHANGE_LAST_WRITE 0x00000010
#define FILE_NOTIFY_CHANGE_LAST_ACCESS 0x00000020
#define FILE_NOTIFY_CHANGE_CREATION 0x00000040
#define FILE_NOTIFY_CHANGE_SECURITY 0x00000100
#define FILE_ACTION_ADDED 0x00000001
#define FILE_ACTION_REMOVED 0x00000002
#define FILE_ACTION_MODIFIED 0x00000003
#define FILE_ACTION_RENAMED_OLD_NAME 0x00000004
#define FILE_ACTION_RENAMED_NEW_NAME 0x00000005
#define MAILSLOT_NO_MESSAGE ((DWORD)-1)
#define MAILSLOT_WAIT_FOREVER ((DWORD)-1)
#define FILE_CASE_SENSITIVE_SEARCH 0x00000001
#define FILE_CASE_PRESERVED_NAMES 0x00000002
#define FILE_UNICODE_ON_DISK 0x00000004
#define FILE_PERSISTENT_ACLS 0x00000008
#define FILE_FILE_COMPRESSION 0x00000010
#define FILE_VOLUME_QUOTAS 0x00000020
#define FILE_SUPPORTS_SPARSE_FILES 0x00000040
#define FILE_SUPPORTS_REPARSE_POINTS 0x00000080
#define FILE_SUPPORTS_REMOTE_STORAGE 0x00000100
#define FILE_VOLUME_IS_COMPRESSED 0x00008000
#define FILE_SUPPORTS_OBJECT_IDS 0x00010000
#define FILE_SUPPORTS_ENCRYPTION 0x00020000
#define FILE_NAMED_STREAMS 0x00040000
#define FILE_READ_ONLY_VOLUME 0x00080000
#define FILE_SEQUENTIAL_WRITE_ONCE 0x00100000
#define FILE_SUPPORTS_TRANSACTIONS 0x00200000
#define FILE_SUPPORTS_HARD_LINKS 0x00400000
#define FILE_SUPPORTS_EXTENDED_ATTRIBUTES 0x00800000
#define FILE_SUPPORTS_OPEN_BY_FILE_ID 0x01000000
#define FILE_SUPPORTS_USN_JOURNAL 0x02000000

//
// Define the file notification information structure
//

typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;


//
// Define segement buffer structure for scatter/gather read/write.
//

typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;

//
// The reparse GUID structure is used by all 3rd party layered drivers to
// store data in a reparse point. For non-Microsoft tags, The GUID field
// cannot be GUID_NULL.
// The constraints on reparse tags are defined below.
// Microsoft tags can also be used with this format of the reparse point buffer.
//

typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD ReparseTag;
    WORD ReparseDataLength;
    WORD Reserved;
    GUID ReparseGuid;
    struct {
        BYTE DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;

#define REPARSE_GUID_DATA_BUFFER_HEADER_SIZE FIELD_OFFSET(REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer)



//
// Maximum allowed size of the reparse data.
//

#define MAXIMUM_REPARSE_DATA_BUFFER_SIZE ( 16 * 1024 )

//
// Predefined reparse tags.
// These tags need to avoid conflicting with IO_REMOUNT defined in ntos\inc\io.h
//

#define IO_REPARSE_TAG_RESERVED_ZERO (0)
#define IO_REPARSE_TAG_RESERVED_ONE (1)

//
// The value of the following constant needs to satisfy the following conditions:
//  (1) Be at least as large as the largest of the reserved tags.
//  (2) Be strictly smaller than all the tags in use.
//

#define IO_REPARSE_TAG_RESERVED_RANGE IO_REPARSE_TAG_RESERVED_ONE

//
// The reparse tags are a DWORD. The 32 bits are laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-----------------------+-------------------------------+
//  |M|R|N|R|     Reserved bits     |       Reparse Tag Value       |
//  +-+-+-+-+-----------------------+-------------------------------+
//
// M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
//   All ISVs must use a tag with a 0 in this position.
//   Note: If a Microsoft tag is used by non-Microsoft software, the
//   behavior is not defined.
//
// R is reserved.  Must be zero for non-Microsoft tags.
//
// N is name surrogate. When set to 1, the file represents another named
//   entity in the system.
//
// The M and N bits are OR-able.
// The following macros check for the M and N bit values:
//

//
// Macro to determine whether a reparse point tag corresponds to a tag
// owned by Microsoft.
//

#define IsReparseTagMicrosoft(_tag) ( ((_tag) & 0x80000000) )



//
// Macro to determine whether a reparse point tag is a name surrogate
//

#define IsReparseTagNameSurrogate(_tag) ( ((_tag) & 0x20000000) )



#define IO_REPARSE_TAG_MOUNT_POINT (0xA0000003L)
#define IO_REPARSE_TAG_HSM (0xC0000004L)
#define IO_REPARSE_TAG_HSM2 (0x80000006L)
#define IO_REPARSE_TAG_SIS (0x80000007L)
#define IO_REPARSE_TAG_WIM (0x80000008L)
#define IO_REPARSE_TAG_CSV (0x80000009L)
#define IO_REPARSE_TAG_DFS (0x8000000AL)
#define IO_REPARSE_TAG_SYMLINK (0xA000000CL)
#define IO_REPARSE_TAG_DFSR (0x80000012L)

//
// I/O Completion Specific Access Rights.
//

#define IO_COMPLETION_MODIFY_STATE 0x0002
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

//
// Object Manager Symbolic Link Specific Access Rights.
//

#define DUPLICATE_CLOSE_SOURCE 0x00000001
#define DUPLICATE_SAME_ACCESS 0x00000002

//
// =========================================
// Define GUIDs which represent well-known power schemes
// =========================================
//

//
// Maximum Power Savings - indicates that very aggressive power savings measures will be used to help
//                         stretch battery life.
//
// {a1841308-3541-4fab-bc81-f71556f20b4a}
//
extern const GUID GUID_MAX_POWER_SAVINGS;

//
// No Power Savings - indicates that almost no power savings measures will be used.
//
// {8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}
//
extern const GUID GUID_MIN_POWER_SAVINGS;

//
// Typical Power Savings - indicates that fairly aggressive power savings measures will be used.
//
// {381b4222-f694-41f0-9685-ff5bb260df2e}
//
extern const GUID GUID_TYPICAL_POWER_SAVINGS;

//
// This is a special GUID that represents "no subgroup" of settings.  That is, it indicates
// that settings that are in the root of the power policy hierarchy as opposed to settings
// that are buried under a subgroup of settings.  This should be used when querying for
// power settings that may not fall into a subgroup.
//
extern const GUID NO_SUBGROUP_GUID;

//
// This is a special GUID that represents "every power scheme".  That is, it indicates
// that any write to this power scheme should be reflected to every scheme present.
// This allows users to write a single setting once and have it apply to all schemes.  They
// can then apply custom settings to specific power schemes that they care about.
//
extern const GUID ALL_POWERSCHEMES_GUID;

//
// This is a special GUID that represents a 'personality' that each power scheme will have.
// In other words, each power scheme will have this key indicating "I'm most like *this* base
// power scheme."  This individual setting will have one of three settings:
// GUID_MAX_POWER_SAVINGS
// GUID_MIN_POWER_SAVINGS
// GUID_TYPICAL_POWER_SAVINGS
//
// This allows several features:
// 1. Drivers and applications can register for notification of this GUID.  So when this power
//    scheme is activiated, this GUID's setting will be sent across the system and drivers/applications
//    can see "GUID_MAX_POWER_SAVINGS" which will tell them in a generic fashion "get real aggressive
//    about conserving power".
// 2. UserB may install a driver or application which creates power settings, and UserB may modify
//    those power settings.  Now UserA logs in.  How does he see those settings?  They simply don't
//    exist in his private power key.  Well they do exist over in the system power key.  When we
//    enumerate all the power settings in this system power key and don't find a corresponding entry
//    in the user's private power key, then we can go look at this "personality" key in the users
//    power scheme.  We can then go get a default value for the power setting, depending on which
//    "personality" power scheme is being operated on.  Here's an example:
//    A. UserB installs an application that creates a power setting Seetting1
//    B. UserB changes Setting1 to have a value of 50 because that's one of the possible settings
//       available for setting1.
//    C. UserB logs out
//    D. UserA logs in and his active power scheme is some custom scheme that was derived from
//       the GUID_TYPICAL_POWER_SAVINGS.  But remember that UserA has no setting1 in his
//       private power key.
//    E. When activating UserA's selected power scheme, all power settings in the system power key will
//       be enumerated (including Setting1).
//    F. The power manager will see that UserA has no Setting1 power setting in his private power scheme.
//    G. The power manager will query UserA's power scheme for its personality and retrieve
//       GUID_TYPICAL_POWER_SAVINGS.
//    H. The power manager then looks in Setting1 in the system power key and looks in its set of default
//       values for the corresponding value for GUID_TYPICAL_POWER_SAVINGS power schemes.
//    I. This derived power setting is applied.
extern const GUID GUID_POWERSCHEME_PERSONALITY;

//
// Define a special GUID which will be used to define the active power scheme.
// User will register for this power setting GUID, and when the active power
// scheme changes, they'll get a callback where the payload is the GUID
// representing the active powerscheme.
// ( 31F9F286-5084-42FE-B720-2B0264993763 }
//
extern const GUID GUID_ACTIVE_POWERSCHEME;

//
// =========================================
// Define GUIDs which represent well-known power settings
// =========================================
//

// Video settings
// --------------
//
// Specifies the subgroup which will contain all of the video
// settings for a single policy.
//
extern const GUID GUID_VIDEO_SUBGROUP;

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we power off the video.
//
extern const GUID GUID_VIDEO_POWERDOWN_TIMEOUT;

//
// Specifies whether adaptive display dimming is turned on or off.
// 82DBCF2D-CD67-40C5-BFDC-9F1A5CCD4663
//
extern const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT;

//
// Specifies how much adaptive dim time out will be increased by.
// EED904DF-B142-4183-B10B-5A1197A37864
//
extern const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we dim the video.
//
extern const GUID GUID_VIDEO_DIM_TIMEOUT;

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the video,
//
extern const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN;

//
// Specifies if the monitor is currently being powered or not.
// 02731015-4510-4526-99E6-E5A17EBD1AEA
//
extern const GUID GUID_MONITOR_POWER_ON;

//
// Monitor brightness policy when in normal state
// {aded5e82-b909-4619-9949-f5d71dac0bcb}
extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;

//
//
// Monitor brightness policy when in dim state
// {f1fbfde2-a960-4165-9f88-50667911ce96}
extern const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;

//
// Current Monitor brightness
// {8ffee2c6-2d01-46be-adb9-398addc5b4ff}
extern const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;


//
// Specifies if the operating system should use ambient light sensor to change
// disply brightness adatively.
// {FBD9AA66-9553-4097-BA44-ED6E9D65EAB8}
extern const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;

//
// Specifies a change in the session's display state.
// 73A5E93A-5BB1-4F93-895B-DBD0DA855967
//
// N.B. This is a session-specific notification, sent only to interactive
//      session registrants. Session 0 and kernel mode consumers do not receive
//      this notification.
extern const GUID GUID_SESSION_DISPLAY_STATE;

//
// Specifies a change in the current monitor's display state.
// 6fe69556-704a-47a0-8f24-c28d936fda47
//
extern const GUID GUID_CONSOLE_DISPLAY_STATE;

//
// Defines a guid for enabling/disabling the ability to create display required 
// power requests.
//
// {A9CEB8DA-CD46-44FB-A98B-02AF69DE4623}
//
extern const GUID GUID_ALLOW_DISPLAY_REQUIRED;

// Harddisk settings
// -----------------
//
// Specifies the subgroup which will contain all of the harddisk
// settings for a single policy.
//
extern const GUID GUID_DISK_SUBGROUP;

//
// Specifies (in seconds) how long we wait after the last disk access
// before we power off the disk.
//
extern const GUID GUID_DISK_POWERDOWN_TIMEOUT;

//
// Specifies the amount of contiguous disk activity time to ignore when
// calculating disk idleness.
//
// 80e3c60e-bb94-4ad8-bbe0-0d3195efc663
//

extern const GUID GUID_DISK_BURST_IGNORE_THRESHOLD;

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the disk,
//
extern const GUID GUID_DISK_ADAPTIVE_POWERDOWN;

// System sleep settings
// ---------------------
//
// Specifies the subgroup which will contain all of the sleep
// settings for a single policy.
// { 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 }
//
extern const GUID GUID_SLEEP_SUBGROUP;

//
// Specifies an idle treshold percentage (0-100). The system must be this idle
// over a period of time in order to idle to sleep.
//
// N.B. DEPRECATED IN WINDOWS 6.1
//
extern const GUID GUID_SLEEP_IDLE_THRESHOLD;

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to standby (S1, S2 or S3).
//
extern const GUID GUID_STANDBY_TIMEOUT;

//
// Specifies (in seconds) how long the system should go back to sleep after
// waking unattended. 0 indicates that the standard standby/hibernate idle
// policy should be used instead.
//
// {7bc4a2f9-d8fc-4469-b07b-33eb785aaca0}
//
extern const GUID GUID_UNATTEND_SLEEP_TIMEOUT;

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to hibernate (S4).
//
extern const GUID GUID_HIBERNATE_TIMEOUT;

//
// Specifies whether or not Fast S4 should be enabled if the system supports it
// 94AC6D29-73CE-41A6-809F-6363BA21B47E
//
extern const GUID GUID_HIBERNATE_FASTS4_POLICY;

//
// Define a GUID for controlling the criticality of sleep state transitions.
// Critical sleep transitions do not query applications, services or drivers
// before transitioning the platform to a sleep state.
//
// {B7A27025-E569-46c2-A504-2B96CAD225A1}
//
extern const GUID GUID_CRITICAL_POWER_TRANSITION;

//
// Specifies if the system is entering or exiting 'away mode'.
// 98A7F580-01F7-48AA-9C0F-44352C29E5C0
//
extern const GUID GUID_SYSTEM_AWAYMODE;

// Specify whether away mode is allowed
//
// {25DFA149-5DD1-4736-B5AB-E8A37B5B8187}
//
extern const GUID GUID_ALLOW_AWAYMODE;

//
// Defines a guid for enabling/disabling standby (S1-S3) states. This does not
// affect hibernation (S4).
//
// {abfc2519-3608-4c2a-94ea-171b0ed546ab}
//
extern const GUID GUID_ALLOW_STANDBY_STATES;

//
// Defines a guid for enabling/disabling the ability to wake via RTC.
//
// {BD3B718A-0680-4D9D-8AB2-E1D2B4AC806D}
//
extern const GUID GUID_ALLOW_RTC_WAKE;

//
// Defines a guid for enabling/disabling the ability to create system required 
// power requests.
//
// {A4B195F5-8225-47D8-8012-9D41369786E2}
//
extern const GUID GUID_ALLOW_SYSTEM_REQUIRED;

// System button actions
// ---------------------
//
//
// Specifies the subgroup which will contain all of the system button
// settings for a single policy.
//
extern const GUID GUID_SYSTEM_BUTTON_SUBGROUP;

// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system power button is pressed.
//
extern const GUID GUID_POWERBUTTON_ACTION;
extern const GUID GUID_POWERBUTTON_ACTION_FLAGS;

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
//
extern const GUID GUID_SLEEPBUTTON_ACTION;
extern const GUID GUID_SLEEPBUTTON_ACTION_FLAGS;

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
// { A7066653-8D6C-40A8-910E-A1F54B84C7E5 }
//
extern const GUID GUID_USERINTERFACEBUTTON_ACTION;

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system lid is closed.
//
extern const GUID GUID_LIDCLOSE_ACTION;
extern const GUID GUID_LIDCLOSE_ACTION_FLAGS;
extern const GUID GUID_LIDOPEN_POWERSTATE;


// Battery Discharge Settings
// --------------------------
//
// Specifies the subgroup which will contain all of the battery discharge
// settings for a single policy.
//
extern const GUID GUID_BATTERY_SUBGROUP;

//
// 4 battery discharge alarm settings.
//
// GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take.  It is a value
//                                   of type POWER_ACTION
// GUID_BATTERY_DISCHARGE_LEVEL_x  - This is the battery level (%)
// GUID_BATTERY_DISCHARGE_FLAGS_x  - Flags defined below:
//                                   POWER_ACTION_POLICY->EventCode flags
//                                   BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
//                                   BATTERY_DISCHARGE_FLAGS_ENABLE
extern const GUID GUID_BATTERY_DISCHARGE_ACTION_0;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_0;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_0;

extern const GUID GUID_BATTERY_DISCHARGE_ACTION_1;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_1;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_1;

extern const GUID GUID_BATTERY_DISCHARGE_ACTION_2;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_2;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_2;

extern const GUID GUID_BATTERY_DISCHARGE_ACTION_3;
extern const GUID GUID_BATTERY_DISCHARGE_LEVEL_3;
extern const GUID GUID_BATTERY_DISCHARGE_FLAGS_3;

// Processor power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the processor
// settings for a single policy.
//
extern const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP;

//
// Specifies various attributes that control processor performance/throttle
// states.
// 
extern const GUID GUID_PROCESSOR_THROTTLE_POLICY;

#define PERFSTATE_POLICY_CHANGE_IDEAL 0
#define PERFSTATE_POLICY_CHANGE_SINGLE 1
#define PERFSTATE_POLICY_CHANGE_ROCKET 2
#define PERFSTATE_POLICY_CHANGE_MAX PERFSTATE_POLICY_CHANGE_ROCKET

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above.  For example, if this value is set to 80, then
// the processor frequency will never be throttled above 80 percent of its
// maximum frequency by the system.
//
extern const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM;

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below.  For example, if this value is set to 50, then the
// processor frequency will never be throttled below 50 percent of its
// maximum frequency by the system.
//
extern const GUID GUID_PROCESSOR_THROTTLE_MINIMUM;

//
// Specifies whether throttle states are allowed to be used even when
// performance states are available.
//
// {3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb}
//
extern const GUID GUID_PROCESSOR_ALLOW_THROTTLING;

//
// Specifies processor power settings for CState policy data
// {68F262A7-F621-4069-B9A5-4874169BE23C}
//
extern const GUID GUID_PROCESSOR_IDLESTATE_POLICY;

//
// Specifies processor power settings for PerfState policy data
// {BBDC3814-18E9-4463-8A55-D197327C45C0}
//
extern const GUID GUID_PROCESSOR_PERFSTATE_POLICY;

//
// Specifies the increase busy percentage threshold that must be met before
// increasing the processor performance state.
//
// {06cadf0e-64ed-448a-8927-ce7bf90eb35d}
//
extern const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;

//
// Specifies the decrease busy percentage threshold that must be met before
// decreasing the processor performance state.
//
// {12a0ab44-fe28-4fa9-b3bd-4b64f44960a6}
//
extern const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when increasing the processor performance state.
//
// {465E1F50-B610-473a-AB58-00D1077DC418}
//
extern const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY;

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when decreasing the processor performance state.
//
// {40FBEFC7-2E9D-4d25-A185-0CFD8574BAC6}
//
extern const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY;

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {984CF492-3BED-4488-A8F9-4286C97BF5AA}
//
extern const GUID GUID_PROCESSOR_PERF_INCREASE_TIME;

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {D8EDEB9B-95CF-4f95-A73C-B061973693C8}
//
extern const GUID GUID_PROCESSOR_PERF_DECREASE_TIME;

//
// Specifies the time, in milliseconds, that must expire before considering
// a change in the processor performance states or parked core set.
//
// {4D2B0152-7D5C-498b-88E2-34345392A2C5}
//
extern const GUID GUID_PROCESSOR_PERF_TIME_CHECK;

//
// Specifies whether a processor may opportunistically increase frequency above
// the maximum when operating contitions allow it to do so safely.
//
// {45BCC044-D885-43e2-8605-EE0EC6E96B59}
//
extern const GUID GUID_PROCESSOR_PERF_BOOST_POLICY
                                                                         ;

#define PROCESSOR_PERF_BOOST_POLICY_DISABLED 0
#define PROCESSOR_PERF_BOOST_POLICY_MAX 100

//
// Specifies if idle state promotion and demotion values should be scaled based
// on the current peformance state.
//
// {6C2993B0-8F48-481f-BCC6-00DD2742AA06}
//
extern const GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING;

//
// Specifies if idle states should be disabled.
//
// {5D76A2CA-E8C0-402f-A133-2158492D58AD}
//
extern const GUID GUID_PROCESSOR_IDLE_DISABLE;

//
// Specifies the time that elapsed since the last idle state promotion or
// demotion before idle states may be promoted or demoted again (in 
// microseconds).
//
// {C4581C31-89AB-4597-8E2B-9C9CAB440E6B}
//
extern const GUID GUID_PROCESSOR_IDLE_TIME_CHECK;


//
// Specifies the upper busy threshold that must be met before demoting the
// processor to a lighter idle state (in percentage).
//
// {4B92D758-5A24-4851-A470-815D78AEE119}
//
extern const GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;

//
// Specifies the lower busy threshold that must be met before promoting the 
// processor to a deeper idle state (in percentage).
//
// {7B224883-B3CC-4d79-819F-8374152CBE7C}
//
extern const GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;

//
// Specifies the utilization threshold in percent that must be crossed in order to un-park cores.
// 
// {df142941-20f3-4edf-9a4a-9c83d3d717d1}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;

//
// Specifies the utilization threshold in percent that must be crossed in order to park cores.
// 
// {68dd2f27-a4ce-4e11-8487-3794e4135dfa}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;

//
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be unparked.
// 
// {c7be0679-2817-4d69-9d02-519a537ed0c6}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;

#define CORE_PARKING_POLICY_CHANGE_IDEAL 0
#define CORE_PARKING_POLICY_CHANGE_SINGLE 1
#define CORE_PARKING_POLICY_CHANGE_ROCKET 2
#define CORE_PARKING_POLICY_CHANGE_MAX CORE_PARKING_POLICY_CHANGE_ROCKET

// 
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be parked.
// 
// {71021b41-c749-4d21-be74-a00f335d582b}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;

//
// Specifies, on a per processor group basis, the maximum number of cores that can be kept unparked. 
// 
// {ea062031-0e34-4ff1-9b6d-eb1059334028}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES;

//
// Specifies, on a per processor group basis, the minimum number of cores that must be kept unparked.
// 
// {0cc5b647-c1df-4637-891a-dec35c318583}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES;

//
// Specifies, in milliseconds, the minimum amount of time a core must be parked before it can be unparked.
// 
// {2ddd5a84-5a71-437e-912a-db0b8c788732}
//
extern const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;

//
// Specifies, in milliseconds, the minimum amount of time a core must be unparked before it can be parked.
// 
// {dfd10d17-d5eb-45dd-877a-9a34ddd15c82}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;

//
// Specifies the factor by which to decrease affinity history on each core after each check.
// 
// {8f7b45e3-c393-480a-878c-f67ac3d07082}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;

//
// Specifies the threshold above which a core is considered to have had significant affinitized work scheduled to it while parked.
// 
// {5b33697b-e89d-4d38-aa46-9e7dfb7cd2f9}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;

//
// Specifies the weighting given to each occurence where affinitized work was scheduled to a parked core.
// 
// {e70867f1-fa2f-4f4e-aea1-4d8a0ba23b20}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;

//
// Specifies the factor by which to decrease the over utilization history on each core after the current performance check.
// 
// {1299023c-bc28-4f0a-81ec-d3295a8d815d}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;

//
// Specifies the threshold above which a core is considered to have been recently over utilized while parked.
// 
// {9ac18e92-aa3c-4e27-b307-01ae37307129}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;

//
// Specifies the weighting given to each occurence where a parked core is found to be over utilized.
// 
// {8809c2d8-b155-42d4-bcda-0d345651b1db}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;

//
// Specifies, in percentage, the busy threshold that must be met before a parked core is considered over utilized.
// 
// {943c8cb6-6f93-4227-ad87-e9a3feec08d1}
// 
extern const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;

//
// Specifies if at least one processor per core should always remain unparked.
// 
// {a55612aa-f624-42c6-a443-7397d064c04f}
// 

extern const GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE;

//
// Specifies what performance state a processor should enter when first parked.
// 
// {447235c7-6a8d-4cc0-8e24-9eaf70b96e2b}
// 

extern const GUID GUID_PROCESSOR_PARKING_PERF_STATE;

//
// Specifies the number of perf time check intervals to average utility over.
//
// {7d24baa7-0b84-480f-840c-1b0743c00f5f}
//
extern const GUID GUID_PROCESSOR_PERF_HISTORY;

//
// Specifies active vs passive cooling.  Although not directly related to
// processor settings, it is the processor that gets throttled if we're doing
// passive cooling, so it is fairly strongly related.
// {94D3A615-A899-4AC5-AE2B-E4D8F634367F}
//
extern const GUID GUID_SYSTEM_COOLING_POLICY;

// Lock Console on Wake
// --------------------
//

// Specifies the behavior of the system when we wake from standby or
// hibernate.  If this is set, then we will cause the console to lock
// after we resume.
//
extern const GUID GUID_LOCK_CONSOLE_ON_WAKE;

// Device idle characteristics
// ---------------------------
//
// Specifies whether to use the "performance" or "conservative" timeouts for
// device idle management.
//
// 4faab71a-92e5-4726-b531-224559672d19
//
extern const GUID GUID_DEVICE_IDLE_POLICY;

#define POWER_DEVICE_IDLE_POLICY_PERFORMANCE 0
#define POWER_DEVICE_IDLE_POLICY_CONSERVATIVE 1

// AC/DC power source
// ------------------
//

// Specifies the power source for the system.  consumers may register for
// notification when the power source changes and will be notified with
// one of 3 values:
// 0 - Indicates the system is being powered by an AC power source.
// 1 - Indicates the system is being powered by a DC power source.
// 2 - Indicates the system is being powered by a short-term DC power
//     source.  For example, this would be the case if the system is
//     being powed by a short-term battery supply in a backing UPS
//     system.  When this value is recieved, the consumer should make
//     preparations for either a system hibernate or system shutdown.
//
// { 5D3E9A59-E9D5-4B00-A6BD-FF34FF516548 }
extern const GUID GUID_ACDC_POWER_SOURCE;

// Lid state changes
// -----------------
//
// Specifies the current state of the lid (open or closed). The callback won't
// be called at all until a lid device is found and its current state is known.
//
// Values:
//
// 0 - closed
// 1 - opened
//
// { BA3E0F4D-B817-4094-A2D1-D56379E6A0F3 }
//

extern const GUID GUID_LIDSWITCH_STATE_CHANGE;

// Battery life remaining
// ----------------------
//

// Specifies the percentage of battery life remaining.  The consumer
// may register for notification in order to track battery life in
// a fine-grained manner.
//
// Once registered, the consumer can expect to be notified as the battery
// life percentage changes.
//
// The consumer will recieve a value between 0 and 100 (inclusive) which
// indicates percent battery life remaining.
//
// { A7AD8041-B45A-4CAE-87A3-EECBB468A9E1 }
extern const GUID GUID_BATTERY_PERCENTAGE_REMAINING;


// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
extern const GUID GUID_IDLE_BACKGROUND_TASK;

// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
// { CF23F240-2A54-48D8-B114-DE1518FF052E }
extern const GUID GUID_BACKGROUND_TASK_NOTIFICATION;

// Define a GUID that will represent the action of a direct experience button
// on the platform.  Users will register for this DPPE setting and recieve
// notification when the h/w button is pressed.
//
// { 1A689231-7399-4E9A-8F99-B71F999DB3FA }
//
extern const GUID GUID_APPLAUNCH_BUTTON;

// PCI Express power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the PCI Express
// settings for a single policy.
//
// {501a4d13-42af-4429-9fd1-a8218c268e20}
//
extern const GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP;

// Specifies the PCI Express ASPM power policy.
//
// {ee12f906-d277-404b-b6da-e5fa1a576df5}
//
extern const GUID GUID_PCIEXPRESS_ASPM_POLICY;

// POWER Shutdown settings
// ------------------------
//

// Specifies if forced shutdown should be used for all button and lid initiated
// shutdown actions.
//
// {833a6b62-dfa4-46d1-82f8-e09e34d029d6}
//

extern const GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;


typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;

#define POWER_SYSTEM_MAXIMUM 7

typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;


#define ES_SYSTEM_REQUIRED ((DWORD)0x00000001)
#define ES_DISPLAY_REQUIRED ((DWORD)0x00000002)
#define ES_USER_PRESENT ((DWORD)0x00000004)
#define ES_AWAYMODE_REQUIRED ((DWORD)0x00000040)
#define ES_CONTINUOUS ((DWORD)0x80000000)

typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;



#define DIAGNOSTIC_REASON_VERSION 0

#define DIAGNOSTIC_REASON_SIMPLE_STRING 0x00000001
#define DIAGNOSTIC_REASON_DETAILED_STRING 0x00000002
#define DIAGNOSTIC_REASON_NOT_SPECIFIED 0x80000000
#define DIAGNOSTIC_REASON_INVALID_FLAGS (~0x80000003)



//
// Defines for power request APIs
//

#define POWER_REQUEST_CONTEXT_VERSION 0

#define POWER_REQUEST_CONTEXT_SIMPLE_STRING 0x00000001
#define POWER_REQUEST_CONTEXT_DETAILED_STRING 0x00000002

//
// N.B. The maximum is a macro (rather than part of enum) for cgen to be able
// to parse power.h correctly. When a new power request type is added, the
// PowerRequestMaximum should be manually incremented.
//

typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;

#define PowerRequestMaximum 3

// end_ntminiport



//-----------------------------------------------------------------------------
// Device Power Information
// Accessable via CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
//-----------------------------------------------------------------------------

#define PDCAP_D0_SUPPORTED 0x00000001
#define PDCAP_D1_SUPPORTED 0x00000002
#define PDCAP_D2_SUPPORTED 0x00000004
#define PDCAP_D3_SUPPORTED 0x00000008
#define PDCAP_WAKE_FROM_D0_SUPPORTED 0x00000010
#define PDCAP_WAKE_FROM_D1_SUPPORTED 0x00000020
#define PDCAP_WAKE_FROM_D2_SUPPORTED 0x00000040
#define PDCAP_WAKE_FROM_D3_SUPPORTED 0x00000080
#define PDCAP_WARM_EJECT_SUPPORTED 0x00000100

typedef struct CM_Power_Data_s {
    DWORD PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    DWORD PD_Capabilities;
    DWORD PD_D1Latency;
    DWORD PD_D2Latency;
    DWORD PD_D3Latency;
    DEVICE_POWER_STATE PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;



// begin_wdm

typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime, // Compare with KeQueryInterruptTime()
    LastSleepTime, // Compare with KeQueryInterruptTime()
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    PowerInformationLevelUnused1,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;

//
// Power Setting definitions
//

typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {

    //
    // Version of this structure.  Currently should be set to
    // POWER_SETTING_VALUE_VERSION.
    //
    DWORD Version;


    //
    // GUID representing the power setting being applied.
    //
    GUID Guid;


    //
    // What power state should this setting be applied to?  E.g.
    // AC, DC, thermal, ...
    //
    SYSTEM_POWER_CONDITION PowerCondition;

    //
    // Length (in bytes) of the 'Data' member.
    //
    DWORD DataLength;

    //
    // Data which contains the actual setting value.
    //
    BYTE Data[1];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;

#define POWER_SETTING_VALUE_VERSION (0x1)

typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;

//
// Package definition for an experience button device notification.  When
// someone registers for GUID_EXPERIENCE_BUTTON, this is the definition of
// the setting data they'll get.
//
typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {

    //
    // System time when the most recent button press ocurred.  Note that this is
    // specified in 100ns internvals since January 1, 1601.
    //
    LARGE_INTEGER ActivationTime;

    //
    // Reserved for internal use.
    //
    DWORD Flags;

    //
    // which instance of this device was pressed?
    //
    DWORD ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;

//
// define platform roles
//

typedef enum {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE;

//
// System power manager capabilities
//


typedef struct {
    DWORD Granularity;
    DWORD Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;


//

typedef struct {
    DWORD Frequency;
    DWORD Flags;
    DWORD PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE PromotePercent;
    BYTE DemotePercent;
    BYTE StateType;
    BYTE Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1; // reserved for future use
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState; // current idle state
    DWORD OldState; // previous idle state
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState; // current idle state
    DWORD OldState; // previous idle state
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

typedef struct {
    DWORD Frequency; // in Mhz
    DWORD Power; // in milliwatts
    BYTE PercentFrequency;
    BYTE IncreaseLevel; // goto higher state
    BYTE DecreaseLevel; // goto lower state
    BYTE Type; // performance or throttle
    DWORD IncreaseTime; // in tick counts
    DWORD DecreaseTime; // in tick counts
    DWORD64 Control; // control value
    DWORD64 Status; // control value
    DWORD HitCount;
    DWORD Reserved1; // reserved for future use
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState; // current state
    DWORD MaxPerfState; // fastest state considering policy restrictions
    DWORD MinPerfState; // slowest state considering policy restrictions
    DWORD LowestPerfState; // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType; // domain coordination
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors; // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState; // current state
    DWORD MaxPerfState; // fastest state considering policy restrictions
    DWORD MinPerfState; // slowest state considering policy restrictions
    DWORD LowestPerfState; // slowest perf state, fixed, aka the "knee"
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType; // domain coordination
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors; // domain affinity
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;

//
// Legacy processor idle accounting.
//

#define PROC_IDLE_BUCKET_COUNT 6

typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;

//
// Processor idle accounting.
//

#define PROC_IDLE_BUCKET_COUNT_EX 16

typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING_EX State[1];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;

//
// Definitions of coordination types for _PSD, _TSD, and _CSD BIOS objects from
// the Acpi 3.0 specification
//

#define ACPI_PPM_SOFTWARE_ALL 0xFC
#define ACPI_PPM_SOFTWARE_ANY 0xFD
#define ACPI_PPM_HARDWARE_ALL 0xFE

//
// Definition of Microsoft PPM coordination types.
//

#define MS_PPM_SOFTWARE_ALL 0x1

//
// Processor firmware rundown feature bit definitions.
//

#define PPM_FIRMWARE_ACPI1C2 0x00000001
#define PPM_FIRMWARE_ACPI1C3 0x00000002
#define PPM_FIRMWARE_ACPI1TSTATES 0x00000004
#define PPM_FIRMWARE_CST 0x00000008
#define PPM_FIRMWARE_CSD 0x00000010
#define PPM_FIRMWARE_PCT 0x00000020
#define PPM_FIRMWARE_PSS 0x00000040
#define PPM_FIRMWARE_XPSS 0x00000080
#define PPM_FIRMWARE_PPC 0x00000100
#define PPM_FIRMWARE_PSD 0x00000200
#define PPM_FIRMWARE_PTC 0x00000400
#define PPM_FIRMWARE_TSS 0x00000800
#define PPM_FIRMWARE_TPC 0x00001000
#define PPM_FIRMWARE_TSD 0x00002000
#define PPM_FIRMWARE_PCCH 0x00004000
#define PPM_FIRMWARE_PCCP 0x00008000

//
// Processor Power Management WMI interface.
//

// {A5B32DDD-7F39-4abc-B892-900E43B59EBB}
extern const GUID PPM_PERFSTATE_CHANGE_GUID
                                                                          ;

// {995e6b7f-d653-497a-b978-36a30c29bf01}
extern const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID
                                                                         ;

// {4838fe4f-f71c-4e51-9ecc-8430a7ac4c6c}
extern const GUID PPM_IDLESTATE_CHANGE_GUID
                                                                           ;

// {5708cc20-7d40-4bf4-b4aa-2b01338d0126}
extern const GUID PPM_PERFSTATES_DATA_GUID
                                                                           ;

// {ba138e10-e250-4ad7-8616-cf1a7ad410e7}
extern const GUID PPM_IDLESTATES_DATA_GUID
                                                                           ;

// {e2a26f78-ae07-4ee0-a30f-ce354f5a94cd}
extern const GUID PPM_IDLE_ACCOUNTING_GUID
                                                                           ;

// {d67abd39-81f8-4a5e-8152-72e31ec912ee}
extern const GUID PPM_IDLE_ACCOUNTING_EX_GUID
                                                                           ;

// {a852c2c8-1a4c-423b-8c2c-f30d82931a88}
extern const GUID PPM_THERMALCONSTRAINT_GUID
                                                                           ;

// {7fd18652-0cfe-40d2-b0a1-0b066a87759e}
extern const GUID PPM_PERFMON_PERFSTATE_GUID
                                                                        ;

// {48f377b8-6880-4c7b-8bdc-380176c6654d}
extern const GUID PPM_THERMAL_POLICY_CHANGE_GUID
                                                                          ;


typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable:4121)

typedef struct {
    BYTE Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)

// Power Policy Management interfaces
//

typedef struct {
    POWER_ACTION Action;
    DWORD Flags;
    DWORD EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;

// POWER_ACTION_POLICY->Flags:
#define POWER_ACTION_QUERY_ALLOWED 0x00000001
#define POWER_ACTION_UI_ALLOWED 0x00000002
#define POWER_ACTION_OVERRIDE_APPS 0x00000004
#define POWER_ACTION_PSEUDO_TRANSITION 0x08000000
#define POWER_ACTION_LIGHTEST_FIRST 0x10000000
#define POWER_ACTION_LOCK_CONSOLE 0x20000000
#define POWER_ACTION_DISABLE_WAKES 0x40000000
#define POWER_ACTION_CRITICAL 0x80000000

// POWER_ACTION_POLICY->EventCode flags
#define POWER_LEVEL_USER_NOTIFY_TEXT 0x00000001
#define POWER_LEVEL_USER_NOTIFY_SOUND 0x00000002
#define POWER_LEVEL_USER_NOTIFY_EXEC 0x00000004
#define POWER_USER_NOTIFY_BUTTON 0x00000008
#define POWER_USER_NOTIFY_SHUTDOWN 0x00000010
#define POWER_USER_NOTIFY_FORCED_SHUTDOWN 0x00000020
#define POWER_FORCE_TRIGGER_RESET 0x80000000

// Note: for battery alarm EventCodes, the ID of the battery alarm << 16 is ORed
// into the flags.  For example: DISCHARGE_POLICY_LOW << 16

//
// The GUID_BATTERY_DISCHARGE_FLAGS_x power settings use a subset of EventCode
// flags.  The POWER_FORCE_TRIGGER_RESET flag doesn't make sense for a battery
// alarm so it is overloaded for other purposes (gerneral enable/disable).
#define BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK 0x00000007
#define BATTERY_DISCHARGE_FLAGS_ENABLE 0x80000000

// system battery drain policies
typedef struct {
    BOOLEAN Enable;
    BYTE Spare[3];
    DWORD BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;

// Discharge policy constants
#define NUM_DISCHARGE_POLICIES 4
#define DISCHARGE_POLICY_CRITICAL 0
#define DISCHARGE_POLICY_LOW 1


// system power policies
typedef struct _SYSTEM_POWER_POLICY {
    DWORD Revision; // 1

    // events
    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE LidOpenWake;
    DWORD Reserved;

    // "system idle" detection
    POWER_ACTION_POLICY Idle;
    DWORD IdleTimeout;
    BYTE IdleSensitivity;

    BYTE DynamicThrottle;
    BYTE Spare2[2];

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    SYSTEM_POWER_STATE ReducedLatencySleep;
    DWORD WinLogonFlags;

    DWORD Spare3;

    // parameters for dozing
    //
    DWORD DozeS4Timeout;

    // battery policies
    DWORD BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy[4];

    // video policies
    DWORD VideoTimeout;
    BOOLEAN VideoDimDisplay;
    DWORD VideoReserved[3];

    // hard disk policies
    DWORD SpindownTimeout;

    // processor policies
    BOOLEAN OptimizeForPower;
    BYTE FanThrottleTolerance;
    BYTE ForcedThrottle;
    BYTE MinThrottle;
    POWER_ACTION_POLICY OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;


// processor power policy state

//
// Processor Idle State Policy.
//

#define PROCESSOR_IDLESTATE_POLICY_COUNT 0x3

typedef struct {
    DWORD TimeCheck;
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    WORD Revision;
    union {
        WORD AsWORD ;
        struct {
            WORD AllowScaling : 1;
            WORD Disabled : 1;
            WORD Reserved : 14;
        } s;
    } Flags;

    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;

//
// Legacy Processor Policy.  This is only provided to allow legacy
// applications to compile.  New applications must use
// PROCESSOR_IDLESTATE_POLICY.
//

#define PO_THROTTLE_NONE 0
#define PO_THROTTLE_CONSTANT 1
#define PO_THROTTLE_DEGRADE 2
#define PO_THROTTLE_ADAPTIVE 3
#define PO_THROTTLE_MAXIMUM 4


typedef struct _PROCESSOR_POWER_POLICY_INFO {

    // Time based information (will be converted to kernel units)
    DWORD TimeCheck; // in US
    DWORD DemoteLimit; // in US
    DWORD PromoteLimit; // in US

    // Percentage based information
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];

    // Flags
    DWORD AllowDemotion:1;
    DWORD AllowPromotion:1;
    DWORD Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;

// processor power policy
typedef struct _PROCESSOR_POWER_POLICY {
    DWORD Revision; // 1

    // Dynamic Throttling Policy
    BYTE DynamicThrottle;
    BYTE Spare[3];

    // Flags
    DWORD DisableCStates:1;
    DWORD Reserved:31;

    // System policy information
    // The Array is last, in case it needs to be grown and the structure
    // revision incremented.
    DWORD PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;

//
// Processor Perf State Policy.
//

typedef struct {
    DWORD Revision;
    BYTE MaxThrottle;
    BYTE MinThrottle;
    BYTE BusyAdjThreshold;
    union {
        BYTE Spare;
        union {
            BYTE AsBYTE ;
            struct {
                BYTE NoDomainAccounting : 1;
                BYTE IncreasePolicy: 2;
                BYTE DecreasePolicy: 2;
                BYTE Reserved : 3;
            } s;
        } Flags;
    } u;

    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;

// administrator power policy overrides
typedef struct _ADMINISTRATOR_POWER_POLICY {

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;

    // video policies
    DWORD MinVideoTimeout;
    DWORD MaxVideoTimeout;

    // disk policies
    DWORD MinSpindownTimeout;
    DWORD MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef struct {
    // Misc supported system features
    BOOLEAN PowerButtonPresent;
    BOOLEAN SleepButtonPresent;
    BOOLEAN LidPresent;
    BOOLEAN SystemS1;
    BOOLEAN SystemS2;
    BOOLEAN SystemS3;
    BOOLEAN SystemS4; // hibernate
    BOOLEAN SystemS5; // off
    BOOLEAN HiberFilePresent;
    BOOLEAN FullWake;
    BOOLEAN VideoDimPresent;
    BOOLEAN ApmPresent;
    BOOLEAN UpsPresent;

    // Processors
    BOOLEAN ThermalControl;
    BOOLEAN ProcessorThrottle;
    BYTE ProcessorMinThrottle;





    BYTE ProcessorMaxThrottle;
    BOOLEAN FastSystemS4;
    BYTE spare2[3];


    // Disk
    BOOLEAN DiskSpinDown;
    BYTE spare3[8];

    // System Battery
    BOOLEAN SystemBatteriesPresent;
    BOOLEAN BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];

    // Wake
    SYSTEM_POWER_STATE AcOnLineWake;
    SYSTEM_POWER_STATE SoftLidWake;
    SYSTEM_POWER_STATE RtcWake;
    SYSTEM_POWER_STATE MinDeviceWakeState; // note this may change on driver load
    SYSTEM_POWER_STATE DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN AcOnLine;
    BOOLEAN BatteryPresent;
    BOOLEAN Charging;
    BOOLEAN Discharging;
    BOOLEAN Spare1[4];

    DWORD MaxCapacity;
    DWORD RemainingCapacity;
    DWORD Rate;
    DWORD EstimatedTime;

    DWORD DefaultAlert1;
    DWORD DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;



//
// Image Format
//




# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack4.h



Abstract:



    This file turns 4 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 10774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

#define IMAGE_DOS_SIGNATURE 0x5A4D
#define IMAGE_OS2_SIGNATURE 0x454E
#define IMAGE_OS2_SIGNATURE_LE 0x454C
#define IMAGE_VXD_SIGNATURE 0x454C
#define IMAGE_NT_SIGNATURE 0x00004550

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack2.h



Abstract:



    This file turns 2 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 10782 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2
# 10793 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header
    WORD e_magic; // Magic number
    WORD e_cblp; // Bytes on last page of file
    WORD e_cp; // Pages in file
    WORD e_crlc; // Relocations
    WORD e_cparhdr; // Size of header in paragraphs
    WORD e_minalloc; // Minimum extra paragraphs needed
    WORD e_maxalloc; // Maximum extra paragraphs needed
    WORD e_ss; // Initial (relative) SS value
    WORD e_sp; // Initial SP value
    WORD e_csum; // Checksum
    WORD e_ip; // Initial IP value
    WORD e_cs; // Initial (relative) CS value
    WORD e_lfarlc; // File address of relocation table
    WORD e_ovno; // Overlay number
    WORD e_res[4]; // Reserved words
    WORD e_oemid; // OEM identifier (for e_oeminfo)
    WORD e_oeminfo; // OEM information; e_oemid specific
    WORD e_res2[10]; // Reserved words
    LONG e_lfanew; // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER { // OS/2 .EXE header
    WORD ne_magic; // Magic number
    CHAR ne_ver; // Version number
    CHAR ne_rev; // Revision number
    WORD ne_enttab; // Offset of Entry Table
    WORD ne_cbenttab; // Number of bytes in Entry Table
    LONG ne_crc; // Checksum of whole file
    WORD ne_flags; // Flag word
    WORD ne_autodata; // Automatic data segment number
    WORD ne_heap; // Initial heap allocation
    WORD ne_stack; // Initial stack allocation
    LONG ne_csip; // Initial CS:IP setting
    LONG ne_sssp; // Initial SS:SP setting
    WORD ne_cseg; // Count of file segments
    WORD ne_cmod; // Entries in Module Reference Table
    WORD ne_cbnrestab; // Size of non-resident name table
    WORD ne_segtab; // Offset of Segment Table
    WORD ne_rsrctab; // Offset of Resource Table
    WORD ne_restab; // Offset of resident name table
    WORD ne_modtab; // Offset of Module Reference Table
    WORD ne_imptab; // Offset of Imported Names Table
    LONG ne_nrestab; // Offset of Non-resident Names Table
    WORD ne_cmovent; // Count of movable entries
    WORD ne_align; // Segment alignment shift count
    WORD ne_cres; // Count of resource segments
    BYTE ne_exetyp; // Target Operating system
    BYTE ne_flagsothers; // Other .EXE flags
    WORD ne_pretthunks; // offset to return thunks
    WORD ne_psegrefbytes; // offset to segment ref. bytes
    WORD ne_swaparea; // Minimum code swap area size
    WORD ne_expver; // Expected Windows version number
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER { // Windows VXD header
    WORD e32_magic; // Magic number
    BYTE e32_border; // The byte ordering for the VXD
    BYTE e32_worder; // The word ordering for the VXD
    DWORD e32_level; // The EXE format level for now = 0
    WORD e32_cpu; // The CPU type
    WORD e32_os; // The OS type
    DWORD e32_ver; // Module version
    DWORD e32_mflags; // Module flags
    DWORD e32_mpages; // Module # pages
    DWORD e32_startobj; // Object # for instruction pointer
    DWORD e32_eip; // Extended instruction pointer
    DWORD e32_stackobj; // Object # for stack pointer
    DWORD e32_esp; // Extended stack pointer
    DWORD e32_pagesize; // VXD page size
    DWORD e32_lastpagesize; // Last page size in VXD
    DWORD e32_fixupsize; // Fixup section size
    DWORD e32_fixupsum; // Fixup section checksum
    DWORD e32_ldrsize; // Loader section size
    DWORD e32_ldrsum; // Loader section checksum
    DWORD e32_objtab; // Object table offset
    DWORD e32_objcnt; // Number of objects in module
    DWORD e32_objmap; // Object page map offset
    DWORD e32_itermap; // Object iterated data map offset
    DWORD e32_rsrctab; // Offset of Resource Table
    DWORD e32_rsrccnt; // Number of resource entries
    DWORD e32_restab; // Offset of resident name table
    DWORD e32_enttab; // Offset of Entry Table
    DWORD e32_dirtab; // Offset of Module Directive Table
    DWORD e32_dircnt; // Number of module directives
    DWORD e32_fpagetab; // Offset of Fixup Page Table
    DWORD e32_frectab; // Offset of Fixup Record Table
    DWORD e32_impmod; // Offset of Import Module Name Table
    DWORD e32_impmodcnt; // Number of entries in Import Module Name Table
    DWORD e32_impproc; // Offset of Import Procedure Name Table
    DWORD e32_pagesum; // Offset of Per-Page Checksum Table
    DWORD e32_datapage; // Offset of Enumerated Data Pages
    DWORD e32_preload; // Number of preload pages
    DWORD e32_nrestab; // Offset of Non-resident Names Table
    DWORD e32_cbnrestab; // Size of Non-resident Name Table
    DWORD e32_nressum; // Non-resident Name Table Checksum
    DWORD e32_autodata; // Object # for automatic data object
    DWORD e32_debuginfo; // Offset of the debugging information
    DWORD e32_debuglen; // The length of the debugging info. in bytes
    DWORD e32_instpreload; // Number of instance pages in preload section of VXD file
    DWORD e32_instdemand; // Number of instance pages in demand load section of VXD file
    DWORD e32_heapsize; // Size of heap - for 16-bit apps
    BYTE e32_res3[12]; // Reserved words
    DWORD e32_winresoff;
    DWORD e32_winreslen;
    WORD e32_devid; // Device ID for VxD
    WORD e32_ddkver; // DDK version for VxD
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 10904 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2


//
// File header format.
//

typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER 20

#define IMAGE_FILE_RELOCS_STRIPPED 0x0001
#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002
#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008
#define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010
#define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020
#define IMAGE_FILE_BYTES_REVERSED_LO 0x0080
#define IMAGE_FILE_32BIT_MACHINE 0x0100
#define IMAGE_FILE_DEBUG_STRIPPED 0x0200
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400
#define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800
#define IMAGE_FILE_SYSTEM 0x1000
#define IMAGE_FILE_DLL 0x2000
#define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000
#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000

#define IMAGE_FILE_MACHINE_UNKNOWN 0
#define IMAGE_FILE_MACHINE_I386 0x014c
#define IMAGE_FILE_MACHINE_R3000 0x0162
#define IMAGE_FILE_MACHINE_R4000 0x0166
#define IMAGE_FILE_MACHINE_R10000 0x0168
#define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169
#define IMAGE_FILE_MACHINE_ALPHA 0x0184
#define IMAGE_FILE_MACHINE_SH3 0x01a2
#define IMAGE_FILE_MACHINE_SH3DSP 0x01a3
#define IMAGE_FILE_MACHINE_SH3E 0x01a4
#define IMAGE_FILE_MACHINE_SH4 0x01a6
#define IMAGE_FILE_MACHINE_SH5 0x01a8
#define IMAGE_FILE_MACHINE_ARM 0x01c0
#define IMAGE_FILE_MACHINE_THUMB 0x01c2
#define IMAGE_FILE_MACHINE_AM33 0x01d3
#define IMAGE_FILE_MACHINE_POWERPC 0x01F0
#define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1
#define IMAGE_FILE_MACHINE_IA64 0x0200
#define IMAGE_FILE_MACHINE_MIPS16 0x0266
#define IMAGE_FILE_MACHINE_ALPHA64 0x0284
#define IMAGE_FILE_MACHINE_MIPSFPU 0x0366
#define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466
#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64
#define IMAGE_FILE_MACHINE_TRICORE 0x0520
#define IMAGE_FILE_MACHINE_CEF 0x0CEF
#define IMAGE_FILE_MACHINE_EBC 0x0EBC
#define IMAGE_FILE_MACHINE_AMD64 0x8664
#define IMAGE_FILE_MACHINE_M32R 0x9041
#define IMAGE_FILE_MACHINE_CEE 0xC0EE

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;

    //
    // NT additional fields.
    //

    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD BaseOfBss;
    DWORD GprMask;
    DWORD CprMask[4];
    DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107


typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;
#define IMAGE_NT_OPTIONAL_HDR_MAGIC IMAGE_NT_OPTIONAL_HDR64_MAGIC






typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;


typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;





// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is the same either way.

#define IMAGE_FIRST_SECTION(ntheader) ((PIMAGE_SECTION_HEADER) ((ULONG_PTR)(ntheader) + FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) + ((ntheader))->FileHeader.SizeOfOptionalHeader ))





// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN 0
#define IMAGE_SUBSYSTEM_NATIVE 1
#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2
#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3
#define IMAGE_SUBSYSTEM_OS2_CUI 5
#define IMAGE_SUBSYSTEM_POSIX_CUI 7
#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS 8
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9
#define IMAGE_SUBSYSTEM_EFI_APPLICATION 10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER 12
#define IMAGE_SUBSYSTEM_EFI_ROM 13
#define IMAGE_SUBSYSTEM_XBOX 14
#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16

// DllCharacteristics Entries

//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.
//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.
//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.
//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040
#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY 0x0080
#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT 0x0100
#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200
#define IMAGE_DLLCHARACTERISTICS_NO_SEH 0x0400
#define IMAGE_DLLCHARACTERISTICS_NO_BIND 0x0800
//                                            0x1000     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER 0x2000
//                                            0x4000     // Reserved.
#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000

// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT 0
#define IMAGE_DIRECTORY_ENTRY_IMPORT 1
#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3
#define IMAGE_DIRECTORY_ENTRY_SECURITY 4
#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5
#define IMAGE_DIRECTORY_ENTRY_DEBUG 6
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8
#define IMAGE_DIRECTORY_ENTRY_TLS 9
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11
#define IMAGE_DIRECTORY_ENTRY_IAT 12
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14

//
// Non-COFF Object file header
//

typedef struct ANON_OBJECT_HEADER {
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be 0xffff
    WORD Version; // >= 1 (implies the CLSID field is present)
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID; // Used to invoke CoCreateInstance
    DWORD SizeOfData; // Size of data that follows the header
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be 0xffff
    WORD Version; // >= 2 (implies the Flags field is present - otherwise V1)
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID; // Used to invoke CoCreateInstance
    DWORD SizeOfData; // Size of data that follows the header
    DWORD Flags; // 0x1 -> contains metadata
    DWORD MetaDataSize; // Size of CLR metadata
    DWORD MetaDataOffset; // Offset of CLR metadata
} ANON_OBJECT_HEADER_V2;

typedef struct ANON_OBJECT_HEADER_BIGOBJ {
   /* same as ANON_OBJECT_HEADER_V2 */
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be 0xffff
    WORD Version; // >= 2 (implies the Flags field is present)
    WORD Machine; // Actual machine - IMAGE_FILE_MACHINE_xxx
    DWORD TimeDateStamp;
    CLSID ClassID; // {D1BAA1C7-BAEE-4ba9-AF20-FAF66AA4DCB8}
    DWORD SizeOfData; // Size of data that follows the header
    DWORD Flags; // 0x1 -> contains metadata
    DWORD MetaDataSize; // Size of CLR metadata
    DWORD MetaDataOffset; // Offset of CLR metadata

    /* bigobj specifics */
    DWORD NumberOfSections; // extended from WORD
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME 8

typedef struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union {
            DWORD PhysicalAddress;
            DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER 40

//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
#define IMAGE_SCN_TYPE_NO_PAD 0x00000008
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE 0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080

#define IMAGE_SCN_LNK_OTHER 0x00000100
#define IMAGE_SCN_LNK_INFO 0x00000200
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
#define IMAGE_SCN_LNK_REMOVE 0x00000800
#define IMAGE_SCN_LNK_COMDAT 0x00001000
//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
#define IMAGE_SCN_NO_DEFER_SPEC_EXC 0x00004000
#define IMAGE_SCN_GPREL 0x00008000
#define IMAGE_SCN_MEM_FARDATA 0x00008000
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
#define IMAGE_SCN_MEM_PURGEABLE 0x00020000
#define IMAGE_SCN_MEM_16BIT 0x00020000
#define IMAGE_SCN_MEM_LOCKED 0x00040000
#define IMAGE_SCN_MEM_PRELOAD 0x00080000

#define IMAGE_SCN_ALIGN_1BYTES 0x00100000
#define IMAGE_SCN_ALIGN_2BYTES 0x00200000
#define IMAGE_SCN_ALIGN_4BYTES 0x00300000
#define IMAGE_SCN_ALIGN_8BYTES 0x00400000
#define IMAGE_SCN_ALIGN_16BYTES 0x00500000
#define IMAGE_SCN_ALIGN_32BYTES 0x00600000
#define IMAGE_SCN_ALIGN_64BYTES 0x00700000
#define IMAGE_SCN_ALIGN_128BYTES 0x00800000
#define IMAGE_SCN_ALIGN_256BYTES 0x00900000
#define IMAGE_SCN_ALIGN_512BYTES 0x00A00000
#define IMAGE_SCN_ALIGN_1024BYTES 0x00B00000
#define IMAGE_SCN_ALIGN_2048BYTES 0x00C00000
#define IMAGE_SCN_ALIGN_4096BYTES 0x00D00000
#define IMAGE_SCN_ALIGN_8192BYTES 0x00E00000
// Unused                                    0x00F00000
#define IMAGE_SCN_ALIGN_MASK 0x00F00000

#define IMAGE_SCN_LNK_NRELOC_OVFL 0x01000000
#define IMAGE_SCN_MEM_DISCARDABLE 0x02000000
#define IMAGE_SCN_MEM_NOT_CACHED 0x04000000
#define IMAGE_SCN_MEM_NOT_PAGED 0x08000000
#define IMAGE_SCN_MEM_SHARED 0x10000000
#define IMAGE_SCN_MEM_EXECUTE 0x20000000
#define IMAGE_SCN_MEM_READ 0x40000000
#define IMAGE_SCN_MEM_WRITE 0x80000000

//
// TLS Chaacteristic Flags
//
#define IMAGE_SCN_SCALE_INDEX 0x00000001


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack2.h



Abstract:



    This file turns 2 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 11308 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2


//
// Symbol format.
//

typedef struct _IMAGE_SYMBOL {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short; // if 0, use LongName
            DWORD Long; // offset into string table
        } Name;
        DWORD LongName[2]; // PBYTE [2]
    } N;
    DWORD Value;
    SHORT SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL *PIMAGE_SYMBOL;

#define IMAGE_SIZEOF_SYMBOL 18

typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short; // if 0, use LongName
            DWORD Long; // offset into string table
        } Name;
        DWORD LongName[2]; // PBYTE  [2]
    } N;
    DWORD Value;
    LONG SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX *PIMAGE_SYMBOL_EX;

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

#define IMAGE_SYM_UNDEFINED (SHORT)0
#define IMAGE_SYM_ABSOLUTE (SHORT)-1
#define IMAGE_SYM_DEBUG (SHORT)-2
#define IMAGE_SYM_SECTION_MAX 0xFEFF
#define IMAGE_SYM_SECTION_MAX_EX MAXLONG

//
// Type (fundamental) values.
//

#define IMAGE_SYM_TYPE_NULL 0x0000
#define IMAGE_SYM_TYPE_VOID 0x0001
#define IMAGE_SYM_TYPE_CHAR 0x0002
#define IMAGE_SYM_TYPE_SHORT 0x0003
#define IMAGE_SYM_TYPE_INT 0x0004
#define IMAGE_SYM_TYPE_LONG 0x0005
#define IMAGE_SYM_TYPE_FLOAT 0x0006
#define IMAGE_SYM_TYPE_DOUBLE 0x0007
#define IMAGE_SYM_TYPE_STRUCT 0x0008
#define IMAGE_SYM_TYPE_UNION 0x0009
#define IMAGE_SYM_TYPE_ENUM 0x000A
#define IMAGE_SYM_TYPE_MOE 0x000B
#define IMAGE_SYM_TYPE_BYTE 0x000C
#define IMAGE_SYM_TYPE_WORD 0x000D
#define IMAGE_SYM_TYPE_UINT 0x000E
#define IMAGE_SYM_TYPE_DWORD 0x000F
#define IMAGE_SYM_TYPE_PCODE 0x8000
//
// Type (derived) values.
//

#define IMAGE_SYM_DTYPE_NULL 0
#define IMAGE_SYM_DTYPE_POINTER 1
#define IMAGE_SYM_DTYPE_FUNCTION 2
#define IMAGE_SYM_DTYPE_ARRAY 3

//
// Storage classes.
//
#define IMAGE_SYM_CLASS_END_OF_FUNCTION (BYTE )-1
#define IMAGE_SYM_CLASS_NULL 0x0000
#define IMAGE_SYM_CLASS_AUTOMATIC 0x0001
#define IMAGE_SYM_CLASS_EXTERNAL 0x0002
#define IMAGE_SYM_CLASS_STATIC 0x0003
#define IMAGE_SYM_CLASS_REGISTER 0x0004
#define IMAGE_SYM_CLASS_EXTERNAL_DEF 0x0005
#define IMAGE_SYM_CLASS_LABEL 0x0006
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL 0x0007
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 0x0008
#define IMAGE_SYM_CLASS_ARGUMENT 0x0009
#define IMAGE_SYM_CLASS_STRUCT_TAG 0x000A
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION 0x000B
#define IMAGE_SYM_CLASS_UNION_TAG 0x000C
#define IMAGE_SYM_CLASS_TYPE_DEFINITION 0x000D
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC 0x000E
#define IMAGE_SYM_CLASS_ENUM_TAG 0x000F
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM 0x0010
#define IMAGE_SYM_CLASS_REGISTER_PARAM 0x0011
#define IMAGE_SYM_CLASS_BIT_FIELD 0x0012

#define IMAGE_SYM_CLASS_FAR_EXTERNAL 0x0044

#define IMAGE_SYM_CLASS_BLOCK 0x0064
#define IMAGE_SYM_CLASS_FUNCTION 0x0065
#define IMAGE_SYM_CLASS_END_OF_STRUCT 0x0066
#define IMAGE_SYM_CLASS_FILE 0x0067
// new
#define IMAGE_SYM_CLASS_SECTION 0x0068
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL 0x0069

#define IMAGE_SYM_CLASS_CLR_TOKEN 0x006B

// type packing constants

#define N_BTMASK 0x000F
#define N_TMASK 0x0030
#define N_TMASK1 0x00C0
#define N_TMASK2 0x00F0
#define N_BTSHFT 4
#define N_TSHIFT 2
// MACROS

// Basic Type of  x
#define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?

#define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))


// Is x a function?

#define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))


// Is x an array?


#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))


// Is x a structure, union, or enumeration TAG?

#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)



#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))


#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack2.h



Abstract:



    This file turns 2 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 11471 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE bAuxType; // IMAGE_AUX_SYMBOL_TYPE
    BYTE bReserved; // Must be 0
    DWORD SymbolTableIndex;
    BYTE rgbReserved[12]; // Must be 0
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF *PIMAGE_AUX_SYMBOL_TOKEN_DEF;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 11482 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

//
// Auxiliary entry format.
//

typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD TagIndex; // struct, union, or enum tag index
        union {
            struct {
                WORD Linenumber; // declaration line number
                WORD Size; // size of struct, union, or enum
            } LnSz;
           DWORD TotalSize;
        } Misc;
        union {
            struct { // if ISFCN, tag, or .bb
                DWORD PointerToLinenumber;
                DWORD PointerToNextFunction;
            } Function;
            struct { // if ISARY, up to 4 dimen.
                WORD Dimension[4];
            } Array;
        } FcnAry;
        WORD TvIndex; // tv index
    } Sym;
    struct {
        BYTE Name[18];
    } File;
    struct {
        DWORD Length; // section length
        WORD NumberOfRelocations; // number of relocation entries
        WORD NumberOfLinenumbers; // number of line numbers
        DWORD CheckSum; // checksum for communal
        SHORT Number; // section number to associate with
        BYTE Selection; // communal selection type
 BYTE bReserved;
 SHORT HighNumber; // high bits of the section number
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOL;

typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD WeakDefaultSymIndex; // the weak extern default symbol index
        DWORD WeakSearchType;
        BYTE rgbReserved[12];
    } Sym;
    struct {
        BYTE Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD Length; // section length
        WORD NumberOfRelocations; // number of relocation entries
        WORD NumberOfLinenumbers; // number of line numbers
        DWORD CheckSum; // checksum for communal
        SHORT Number; // section number to associate with
        BYTE Selection; // communal selection type
        BYTE bReserved;
        SHORT HighNumber; // high bits of the section number
        BYTE rgbReserved[2];
    } Section;
    struct{
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE rgbReserved[2];
    };
    struct {
        DWORD crc;
        BYTE rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX *PIMAGE_AUX_SYMBOL_EX;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;


//
// Communal selection types.
//

#define IMAGE_COMDAT_SELECT_NODUPLICATES 1
#define IMAGE_COMDAT_SELECT_ANY 2
#define IMAGE_COMDAT_SELECT_SAME_SIZE 3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH 4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE 5
#define IMAGE_COMDAT_SELECT_LARGEST 6
#define IMAGE_COMDAT_SELECT_NEWEST 7

#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY 1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY 2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS 3

//
// Relocation format.
//

typedef struct _IMAGE_RELOCATION {
    union {
        DWORD VirtualAddress;
        DWORD RelocCount; // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
    } u;
    DWORD SymbolTableIndex;
    WORD Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION *PIMAGE_RELOCATION;

//
// I386 relocation types.
//
#define IMAGE_REL_I386_ABSOLUTE 0x0000
#define IMAGE_REL_I386_DIR16 0x0001
#define IMAGE_REL_I386_REL16 0x0002
#define IMAGE_REL_I386_DIR32 0x0006
#define IMAGE_REL_I386_DIR32NB 0x0007
#define IMAGE_REL_I386_SEG12 0x0009
#define IMAGE_REL_I386_SECTION 0x000A
#define IMAGE_REL_I386_SECREL 0x000B
#define IMAGE_REL_I386_TOKEN 0x000C
#define IMAGE_REL_I386_SECREL7 0x000D
#define IMAGE_REL_I386_REL32 0x0014

//
// MIPS relocation types.
//
#define IMAGE_REL_MIPS_ABSOLUTE 0x0000
#define IMAGE_REL_MIPS_REFHALF 0x0001
#define IMAGE_REL_MIPS_REFWORD 0x0002
#define IMAGE_REL_MIPS_JMPADDR 0x0003
#define IMAGE_REL_MIPS_REFHI 0x0004
#define IMAGE_REL_MIPS_REFLO 0x0005
#define IMAGE_REL_MIPS_GPREL 0x0006
#define IMAGE_REL_MIPS_LITERAL 0x0007
#define IMAGE_REL_MIPS_SECTION 0x000A
#define IMAGE_REL_MIPS_SECREL 0x000B
#define IMAGE_REL_MIPS_SECRELLO 0x000C
#define IMAGE_REL_MIPS_SECRELHI 0x000D
#define IMAGE_REL_MIPS_TOKEN 0x000E
#define IMAGE_REL_MIPS_JMPADDR16 0x0010
#define IMAGE_REL_MIPS_REFWORDNB 0x0022
#define IMAGE_REL_MIPS_PAIR 0x0025

//
// Alpha Relocation types.
//
#define IMAGE_REL_ALPHA_ABSOLUTE 0x0000
#define IMAGE_REL_ALPHA_REFLONG 0x0001
#define IMAGE_REL_ALPHA_REFQUAD 0x0002
#define IMAGE_REL_ALPHA_GPREL32 0x0003
#define IMAGE_REL_ALPHA_LITERAL 0x0004
#define IMAGE_REL_ALPHA_LITUSE 0x0005
#define IMAGE_REL_ALPHA_GPDISP 0x0006
#define IMAGE_REL_ALPHA_BRADDR 0x0007
#define IMAGE_REL_ALPHA_HINT 0x0008
#define IMAGE_REL_ALPHA_INLINE_REFLONG 0x0009
#define IMAGE_REL_ALPHA_REFHI 0x000A
#define IMAGE_REL_ALPHA_REFLO 0x000B
#define IMAGE_REL_ALPHA_PAIR 0x000C
#define IMAGE_REL_ALPHA_MATCH 0x000D
#define IMAGE_REL_ALPHA_SECTION 0x000E
#define IMAGE_REL_ALPHA_SECREL 0x000F
#define IMAGE_REL_ALPHA_REFLONGNB 0x0010
#define IMAGE_REL_ALPHA_SECRELLO 0x0011
#define IMAGE_REL_ALPHA_SECRELHI 0x0012
#define IMAGE_REL_ALPHA_REFQ3 0x0013
#define IMAGE_REL_ALPHA_REFQ2 0x0014
#define IMAGE_REL_ALPHA_REFQ1 0x0015
#define IMAGE_REL_ALPHA_GPRELLO 0x0016
#define IMAGE_REL_ALPHA_GPRELHI 0x0017

//
// IBM PowerPC relocation types.
//
#define IMAGE_REL_PPC_ABSOLUTE 0x0000
#define IMAGE_REL_PPC_ADDR64 0x0001
#define IMAGE_REL_PPC_ADDR32 0x0002
#define IMAGE_REL_PPC_ADDR24 0x0003
#define IMAGE_REL_PPC_ADDR16 0x0004
#define IMAGE_REL_PPC_ADDR14 0x0005
#define IMAGE_REL_PPC_REL24 0x0006
#define IMAGE_REL_PPC_REL14 0x0007
#define IMAGE_REL_PPC_TOCREL16 0x0008
#define IMAGE_REL_PPC_TOCREL14 0x0009

#define IMAGE_REL_PPC_ADDR32NB 0x000A
#define IMAGE_REL_PPC_SECREL 0x000B
#define IMAGE_REL_PPC_SECTION 0x000C
#define IMAGE_REL_PPC_IFGLUE 0x000D
#define IMAGE_REL_PPC_IMGLUE 0x000E
#define IMAGE_REL_PPC_SECREL16 0x000F
#define IMAGE_REL_PPC_REFHI 0x0010
#define IMAGE_REL_PPC_REFLO 0x0011
#define IMAGE_REL_PPC_PAIR 0x0012
#define IMAGE_REL_PPC_SECRELLO 0x0013
#define IMAGE_REL_PPC_SECRELHI 0x0014
#define IMAGE_REL_PPC_GPREL 0x0015
#define IMAGE_REL_PPC_TOKEN 0x0016

#define IMAGE_REL_PPC_TYPEMASK 0x00FF

// Flag bits in IMAGE_RELOCATION.TYPE

#define IMAGE_REL_PPC_NEG 0x0100
#define IMAGE_REL_PPC_BRTAKEN 0x0200
#define IMAGE_REL_PPC_BRNTAKEN 0x0400
#define IMAGE_REL_PPC_TOCDEFN 0x0800

//
// Hitachi SH3 relocation types.
//
#define IMAGE_REL_SH3_ABSOLUTE 0x0000
#define IMAGE_REL_SH3_DIRECT16 0x0001
#define IMAGE_REL_SH3_DIRECT32 0x0002
#define IMAGE_REL_SH3_DIRECT8 0x0003
#define IMAGE_REL_SH3_DIRECT8_WORD 0x0004
#define IMAGE_REL_SH3_DIRECT8_LONG 0x0005
#define IMAGE_REL_SH3_DIRECT4 0x0006
#define IMAGE_REL_SH3_DIRECT4_WORD 0x0007
#define IMAGE_REL_SH3_DIRECT4_LONG 0x0008
#define IMAGE_REL_SH3_PCREL8_WORD 0x0009
#define IMAGE_REL_SH3_PCREL8_LONG 0x000A
#define IMAGE_REL_SH3_PCREL12_WORD 0x000B
#define IMAGE_REL_SH3_STARTOF_SECTION 0x000C
#define IMAGE_REL_SH3_SIZEOF_SECTION 0x000D
#define IMAGE_REL_SH3_SECTION 0x000E
#define IMAGE_REL_SH3_SECREL 0x000F
#define IMAGE_REL_SH3_DIRECT32_NB 0x0010
#define IMAGE_REL_SH3_GPREL4_LONG 0x0011
#define IMAGE_REL_SH3_TOKEN 0x0012
#define IMAGE_REL_SHM_PCRELPT 0x0013
                                                //  instruction in longwords
                                                //  if not NOMODE, insert the
                                                //  inverse of the low bit at
                                                //  bit 32 to select PTA/PTB
#define IMAGE_REL_SHM_REFLO 0x0014
#define IMAGE_REL_SHM_REFHALF 0x0015
#define IMAGE_REL_SHM_RELLO 0x0016
#define IMAGE_REL_SHM_RELHALF 0x0017
#define IMAGE_REL_SHM_PAIR 0x0018

#define IMAGE_REL_SH_NOMODE 0x8000


#define IMAGE_REL_ARM_ABSOLUTE 0x0000
#define IMAGE_REL_ARM_ADDR32 0x0001
#define IMAGE_REL_ARM_ADDR32NB 0x0002
#define IMAGE_REL_ARM_BRANCH24 0x0003
#define IMAGE_REL_ARM_BRANCH11 0x0004
#define IMAGE_REL_ARM_TOKEN 0x0005
#define IMAGE_REL_ARM_GPREL12 0x0006
#define IMAGE_REL_ARM_GPREL7 0x0007
#define IMAGE_REL_ARM_BLX24 0x0008
#define IMAGE_REL_ARM_BLX11 0x0009
#define IMAGE_REL_ARM_SECTION 0x000E
#define IMAGE_REL_ARM_SECREL 0x000F

#define IMAGE_REL_AM_ABSOLUTE 0x0000
#define IMAGE_REL_AM_ADDR32 0x0001
#define IMAGE_REL_AM_ADDR32NB 0x0002
#define IMAGE_REL_AM_CALL32 0x0003
#define IMAGE_REL_AM_FUNCINFO 0x0004
#define IMAGE_REL_AM_REL32_1 0x0005
#define IMAGE_REL_AM_REL32_2 0x0006
#define IMAGE_REL_AM_SECREL 0x0007
#define IMAGE_REL_AM_SECTION 0x0008
#define IMAGE_REL_AM_TOKEN 0x0009

//
// x64 relocations
//
#define IMAGE_REL_AMD64_ABSOLUTE 0x0000
#define IMAGE_REL_AMD64_ADDR64 0x0001
#define IMAGE_REL_AMD64_ADDR32 0x0002
#define IMAGE_REL_AMD64_ADDR32NB 0x0003
#define IMAGE_REL_AMD64_REL32 0x0004
#define IMAGE_REL_AMD64_REL32_1 0x0005
#define IMAGE_REL_AMD64_REL32_2 0x0006
#define IMAGE_REL_AMD64_REL32_3 0x0007
#define IMAGE_REL_AMD64_REL32_4 0x0008
#define IMAGE_REL_AMD64_REL32_5 0x0009
#define IMAGE_REL_AMD64_SECTION 0x000A
#define IMAGE_REL_AMD64_SECREL 0x000B
#define IMAGE_REL_AMD64_SECREL7 0x000C
#define IMAGE_REL_AMD64_TOKEN 0x000D
#define IMAGE_REL_AMD64_SREL32 0x000E
#define IMAGE_REL_AMD64_PAIR 0x000F
#define IMAGE_REL_AMD64_SSPAN32 0x0010

//
// IA64 relocation types.
//
#define IMAGE_REL_IA64_ABSOLUTE 0x0000
#define IMAGE_REL_IA64_IMM14 0x0001
#define IMAGE_REL_IA64_IMM22 0x0002
#define IMAGE_REL_IA64_IMM64 0x0003
#define IMAGE_REL_IA64_DIR32 0x0004
#define IMAGE_REL_IA64_DIR64 0x0005
#define IMAGE_REL_IA64_PCREL21B 0x0006
#define IMAGE_REL_IA64_PCREL21M 0x0007
#define IMAGE_REL_IA64_PCREL21F 0x0008
#define IMAGE_REL_IA64_GPREL22 0x0009
#define IMAGE_REL_IA64_LTOFF22 0x000A
#define IMAGE_REL_IA64_SECTION 0x000B
#define IMAGE_REL_IA64_SECREL22 0x000C
#define IMAGE_REL_IA64_SECREL64I 0x000D
#define IMAGE_REL_IA64_SECREL32 0x000E
//
#define IMAGE_REL_IA64_DIR32NB 0x0010
#define IMAGE_REL_IA64_SREL14 0x0011
#define IMAGE_REL_IA64_SREL22 0x0012
#define IMAGE_REL_IA64_SREL32 0x0013
#define IMAGE_REL_IA64_UREL32 0x0014
#define IMAGE_REL_IA64_PCREL60X 0x0015
#define IMAGE_REL_IA64_PCREL60B 0x0016
#define IMAGE_REL_IA64_PCREL60F 0x0017
#define IMAGE_REL_IA64_PCREL60I 0x0018
#define IMAGE_REL_IA64_PCREL60M 0x0019
#define IMAGE_REL_IA64_IMMGPREL64 0x001A
#define IMAGE_REL_IA64_TOKEN 0x001B
#define IMAGE_REL_IA64_GPREL32 0x001C
#define IMAGE_REL_IA64_ADDEND 0x001F

//
// CEF relocation types.
//
#define IMAGE_REL_CEF_ABSOLUTE 0x0000
#define IMAGE_REL_CEF_ADDR32 0x0001
#define IMAGE_REL_CEF_ADDR64 0x0002
#define IMAGE_REL_CEF_ADDR32NB 0x0003
#define IMAGE_REL_CEF_SECTION 0x0004
#define IMAGE_REL_CEF_SECREL 0x0005
#define IMAGE_REL_CEF_TOKEN 0x0006

//
// clr relocation types.
//
#define IMAGE_REL_CEE_ABSOLUTE 0x0000
#define IMAGE_REL_CEE_ADDR32 0x0001
#define IMAGE_REL_CEE_ADDR64 0x0002
#define IMAGE_REL_CEE_ADDR32NB 0x0003
#define IMAGE_REL_CEE_SECTION 0x0004
#define IMAGE_REL_CEE_SECREL 0x0005
#define IMAGE_REL_CEE_TOKEN 0x0006


#define IMAGE_REL_M32R_ABSOLUTE 0x0000
#define IMAGE_REL_M32R_ADDR32 0x0001
#define IMAGE_REL_M32R_ADDR32NB 0x0002
#define IMAGE_REL_M32R_ADDR24 0x0003
#define IMAGE_REL_M32R_GPREL16 0x0004
#define IMAGE_REL_M32R_PCREL24 0x0005
#define IMAGE_REL_M32R_PCREL16 0x0006
#define IMAGE_REL_M32R_PCREL8 0x0007
#define IMAGE_REL_M32R_REFHALF 0x0008
#define IMAGE_REL_M32R_REFHI 0x0009
#define IMAGE_REL_M32R_REFLO 0x000A
#define IMAGE_REL_M32R_PAIR 0x000B
#define IMAGE_REL_M32R_SECTION 0x000C
#define IMAGE_REL_M32R_SECREL32 0x000D
#define IMAGE_REL_M32R_TOKEN 0x000E

#define IMAGE_REL_EBC_ABSOLUTE 0x0000
#define IMAGE_REL_EBC_ADDR32NB 0x0001
#define IMAGE_REL_EBC_REL32 0x0002
#define IMAGE_REL_EBC_SECTION 0x0003
#define IMAGE_REL_EBC_SECREL 0x0004

#define EXT_IMM64(Value,Address,Size,InstPos,ValPos) Value |= (((ULONGLONG)((*(Address) >> InstPos) & (((ULONGLONG)1 << Size) - 1))) << ValPos)


#define INS_IMM64(Value,Address,Size,InstPos,ValPos) *(PDWORD)Address = (*(PDWORD)Address & ~(((1 << Size) - 1) << InstPos)) | ((DWORD)((((ULONGLONG)Value >> ValPos) & (((ULONGLONG)1 << Size) - 1))) << InstPos)



#define EMARCH_ENC_I17_IMM7B_INST_WORD_X 3
#define EMARCH_ENC_I17_IMM7B_SIZE_X 7
#define EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X 4
#define EMARCH_ENC_I17_IMM7B_VAL_POS_X 0

#define EMARCH_ENC_I17_IMM9D_INST_WORD_X 3
#define EMARCH_ENC_I17_IMM9D_SIZE_X 9
#define EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X 18
#define EMARCH_ENC_I17_IMM9D_VAL_POS_X 7

#define EMARCH_ENC_I17_IMM5C_INST_WORD_X 3
#define EMARCH_ENC_I17_IMM5C_SIZE_X 5
#define EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X 13
#define EMARCH_ENC_I17_IMM5C_VAL_POS_X 16

#define EMARCH_ENC_I17_IC_INST_WORD_X 3
#define EMARCH_ENC_I17_IC_SIZE_X 1
#define EMARCH_ENC_I17_IC_INST_WORD_POS_X 12
#define EMARCH_ENC_I17_IC_VAL_POS_X 21

#define EMARCH_ENC_I17_IMM41a_INST_WORD_X 1
#define EMARCH_ENC_I17_IMM41a_SIZE_X 10
#define EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X 14
#define EMARCH_ENC_I17_IMM41a_VAL_POS_X 22

#define EMARCH_ENC_I17_IMM41b_INST_WORD_X 1
#define EMARCH_ENC_I17_IMM41b_SIZE_X 8
#define EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X 24
#define EMARCH_ENC_I17_IMM41b_VAL_POS_X 32

#define EMARCH_ENC_I17_IMM41c_INST_WORD_X 2
#define EMARCH_ENC_I17_IMM41c_SIZE_X 23
#define EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X 0
#define EMARCH_ENC_I17_IMM41c_VAL_POS_X 40

#define EMARCH_ENC_I17_SIGN_INST_WORD_X 3
#define EMARCH_ENC_I17_SIGN_SIZE_X 1
#define EMARCH_ENC_I17_SIGN_INST_WORD_POS_X 27
#define EMARCH_ENC_I17_SIGN_VAL_POS_X 63

#define X3_OPCODE_INST_WORD_X 3
#define X3_OPCODE_SIZE_X 4
#define X3_OPCODE_INST_WORD_POS_X 28
#define X3_OPCODE_SIGN_VAL_POS_X 0

#define X3_I_INST_WORD_X 3
#define X3_I_SIZE_X 1
#define X3_I_INST_WORD_POS_X 27
#define X3_I_SIGN_VAL_POS_X 59

#define X3_D_WH_INST_WORD_X 3
#define X3_D_WH_SIZE_X 3
#define X3_D_WH_INST_WORD_POS_X 24
#define X3_D_WH_SIGN_VAL_POS_X 0

#define X3_IMM20_INST_WORD_X 3
#define X3_IMM20_SIZE_X 20
#define X3_IMM20_INST_WORD_POS_X 4
#define X3_IMM20_SIGN_VAL_POS_X 0

#define X3_IMM39_1_INST_WORD_X 2
#define X3_IMM39_1_SIZE_X 23
#define X3_IMM39_1_INST_WORD_POS_X 0
#define X3_IMM39_1_SIGN_VAL_POS_X 36

#define X3_IMM39_2_INST_WORD_X 1
#define X3_IMM39_2_SIZE_X 16
#define X3_IMM39_2_INST_WORD_POS_X 16
#define X3_IMM39_2_SIGN_VAL_POS_X 20

#define X3_P_INST_WORD_X 3
#define X3_P_SIZE_X 4
#define X3_P_INST_WORD_POS_X 0
#define X3_P_SIGN_VAL_POS_X 0

#define X3_TMPLT_INST_WORD_X 0
#define X3_TMPLT_SIZE_X 4
#define X3_TMPLT_INST_WORD_POS_X 0
#define X3_TMPLT_SIGN_VAL_POS_X 0

#define X3_BTYPE_QP_INST_WORD_X 2
#define X3_BTYPE_QP_SIZE_X 9
#define X3_BTYPE_QP_INST_WORD_POS_X 23
#define X3_BTYPE_QP_INST_VAL_POS_X 0

#define X3_EMPTY_INST_WORD_X 1
#define X3_EMPTY_SIZE_X 2
#define X3_EMPTY_INST_WORD_POS_X 14
#define X3_EMPTY_INST_VAL_POS_X 0

//
// Line number format.
//

typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD SymbolTableIndex; // Symbol table index of function name if Linenumber is 0.
        DWORD VirtualAddress; // Virtual address of line number.
    } Type;
    WORD Linenumber; // Line number.
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER *PIMAGE_LINENUMBER;


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 11967 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2


//
// Based relocation format.
//

typedef struct _IMAGE_BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
//  WORD    TypeOffset[1];
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION * PIMAGE_BASE_RELOCATION;

//
// Based relocation types.
//

#define IMAGE_REL_BASED_ABSOLUTE 0
#define IMAGE_REL_BASED_HIGH 1
#define IMAGE_REL_BASED_LOW 2
#define IMAGE_REL_BASED_HIGHLOW 3
#define IMAGE_REL_BASED_HIGHADJ 4
#define IMAGE_REL_BASED_MIPS_JMPADDR 5
#define IMAGE_REL_BASED_MIPS_JMPADDR16 9
#define IMAGE_REL_BASED_IA64_IMM64 9
#define IMAGE_REL_BASED_DIR64 10


//
// Archive format.
//

#define IMAGE_ARCHIVE_START_SIZE 8
#define IMAGE_ARCHIVE_START "!<arch>\n"
#define IMAGE_ARCHIVE_END "`\n"
#define IMAGE_ARCHIVE_PAD "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER "/               "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER "//              "

typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE Name[16]; // File member name - `/' terminated.
    BYTE Date[12]; // File member date - decimal.
    BYTE UserID[6]; // File member user id - decimal.
    BYTE GroupID[6]; // File member group id - decimal.
    BYTE Mode[8]; // File member mode - octal.
    BYTE Size[10]; // File member size - decimal.
    BYTE EndHeader[2]; // String to end header.
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60

//
// DLL support.
//

//
// Export Format
//

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions; // RVA from base of image
    DWORD AddressOfNames; // RVA from base of image
    DWORD AddressOfNameOrdinals; // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    BYTE Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack8.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack8.h



Abstract:



    This file turns 8 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack8.h"
#pragma pack(8)
# 12050 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString; // PBYTE 
        ULONGLONG Function; // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 12062 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString; // PBYTE 
        DWORD Function; // PDWORD
        DWORD Ordinal;
        DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000
#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)

//
// Thread Local Storage
//

typedef void
( *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex; // PDWORD
    ULONGLONG AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *;
    DWORD SizeOfZeroFill;
    DWORD Characteristics;
} IMAGE_TLS_DIRECTORY64;
typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD StartAddressOfRawData;
    DWORD EndAddressOfRawData;
    DWORD AddressOfIndex; // PDWORD
    DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *
    DWORD SizeOfZeroFill;
    DWORD Characteristics;
} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;


#define IMAGE_ORDINAL_FLAG IMAGE_ORDINAL_FLAG64
#define IMAGE_ORDINAL(Ordinal) IMAGE_ORDINAL64(Ordinal)
typedef IMAGE_THUNK_DATA64 IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA64 PIMAGE_THUNK_DATA;
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) IMAGE_SNAP_BY_ORDINAL64(Ordinal)
typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;
# 12129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics; // 0 for terminating null import descriptor
        DWORD OriginalFirstThunk; // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } u;
    DWORD TimeDateStamp; // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD ForwarderChain; // -1 if no forwarders
    DWORD Name;
    DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR *PIMAGE_IMPORT_DESCRIPTOR;

//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//

typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    WORD NumberOfNamedEntries;
    WORD NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#define IMAGE_RESOURCE_NAME_IS_STRING 0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY 0x80000000
//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } s;
        DWORD Name;
        WORD Id;
    } u;
    union {
        DWORD OffsetToData;
        struct {
            DWORD OffsetToDirectory:31;
            DWORD DataIsDirectory:1;
        } s2;
    } u2;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD Length;
    CHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD Length;
    WCHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//

typedef struct {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    DWORD DeCommitFreeBlockThreshold;
    DWORD DeCommitTotalFreeThreshold;
    DWORD LockPrefixTable; // VA
    DWORD MaximumAllocationSize;
    DWORD VirtualMemoryThreshold;
    DWORD ProcessHeapFlags;
    DWORD ProcessAffinityMask;
    WORD CSDVersion;
    WORD Reserved1;
    DWORD EditList; // VA
    DWORD SecurityCookie; // VA
    DWORD SEHandlerTable; // VA
    DWORD SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    ULONGLONG DeCommitFreeBlockThreshold;
    ULONGLONG DeCommitTotalFreeThreshold;
    ULONGLONG LockPrefixTable; // VA
    ULONGLONG MaximumAllocationSize;
    ULONGLONG VirtualMemoryThreshold;
    ULONGLONG ProcessAffinityMask;
    DWORD ProcessHeapFlags;
    WORD CSDVersion;
    WORD Reserved1;
    ULONGLONG EditList; // VA
    ULONGLONG SecurityCookie; // VA
    ULONGLONG SEHandlerTable; // VA
    ULONGLONG SEHandlerCount;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;


typedef IMAGE_LOAD_CONFIG_DIRECTORY64 IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY64 PIMAGE_LOAD_CONFIG_DIRECTORY;





//
// WIN CE Exception table format
//

//
// Function table entry format.  Function table is pointed to by the
// IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
//

typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD UnwindInfoAddress;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
# 12376 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;



//
// Debug Format
//

typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Type;
    DWORD SizeOfData;
    DWORD AddressOfRawData;
    DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

#define IMAGE_DEBUG_TYPE_UNKNOWN 0
#define IMAGE_DEBUG_TYPE_COFF 1
#define IMAGE_DEBUG_TYPE_CODEVIEW 2
#define IMAGE_DEBUG_TYPE_FPO 3
#define IMAGE_DEBUG_TYPE_MISC 4
#define IMAGE_DEBUG_TYPE_EXCEPTION 5
#define IMAGE_DEBUG_TYPE_FIXUP 6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC 7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC 8
#define IMAGE_DEBUG_TYPE_BORLAND 9
#define IMAGE_DEBUG_TYPE_RESERVED10 10
#define IMAGE_DEBUG_TYPE_CLSID 11


typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD NumberOfSymbols;
    DWORD LvaToFirstSymbol;
    DWORD NumberOfLinenumbers;
    DWORD LvaToFirstLinenumber;
    DWORD RvaToFirstByteOfCode;
    DWORD RvaToLastByteOfCode;
    DWORD RvaToFirstByteOfData;
    DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;

#define FRAME_FPO 0
#define FRAME_TRAP 1
#define FRAME_TSS 2
#define FRAME_NONFPO 3

typedef struct _FPO_DATA {
    DWORD ulOffStart; // offset 1st byte of function code
    DWORD cbProcSize; // # bytes in function
    DWORD cdwLocals; // # bytes in locals/4
    WORD cdwParams; // # bytes in params/4
    WORD cbProlog : 8; // # bytes in prolog
    WORD cbRegs : 3; // # regs saved
    WORD fHasSEH : 1; // TRUE if SEH in func
    WORD fUseBP : 1; // TRUE if EBP has been allocated
    WORD reserved : 1; // reserved for future use
    WORD cbFrame : 2; // frame type
} FPO_DATA, *PFPO_DATA;
#define SIZEOF_RFPO_DATA 16


#define IMAGE_DEBUG_MISC_EXENAME 1

typedef struct _IMAGE_DEBUG_MISC {
    DWORD DataType; // type of misc data, see defines
    DWORD Length; // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN Unicode; // TRUE if data is unicode string
    BYTE Reserved[ 3 ];
    BYTE Data[ 1 ]; // Actual data
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;


//
// Function table extracted from MIPS/ALPHA/IA64 images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//

typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG StartingAddress;
    ULONGLONG EndingAddress;
    union {
        ULONGLONG EndOfPrologue;
        ULONGLONG UnwindInfoAddress;
    } u;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;

//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD Signature;
    WORD Flags;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;
    DWORD NumberOfSections;
    DWORD ExportedNamesSize;
    DWORD DebugDirectorySize;
    DWORD SectionAlignment;
    DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

typedef struct _NON_PAGED_DEBUG_INFO {
    WORD Signature;
    WORD Flags;
    DWORD Size;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD SizeOfImage;
    ULONGLONG ImageBase;
    //DebugDirectorySize
    //IMAGE_DEBUG_DIRECTORY
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;


#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944
#define NON_PAGED_DEBUG_SIGNATURE 0x494E





#define IMAGE_SEPARATE_DEBUG_FLAGS_MASK 0x8000
#define IMAGE_SEPARATE_DEBUG_MISMATCH 0x8000
                                                // old checksum didn't match.

//
//  The .arch section is made up of headers, each describing an amask position/value
//  pointing to an array of IMAGE_ARCHITECTURE_ENTRY's.  Each "array" (both the header
//  and entry arrays) are terminiated by a quadword of 0xffffffffL.
//
//  NOTE: There may be quadwords of 0 sprinkled around and must be skipped.
//

typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1; // 1 -> code section depends on mask bit
                                                // 0 -> new instruction depends on mask bit
    int :7; // MBZ
    unsigned int AmaskShift: 8; // Amask bit in question for this fixup
    int :16; // MBZ
    DWORD FirstEntryRVA; // RVA into .arch section to array of ARCHITECTURE_ENTRY's
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA; // RVA of instruction to fixup
    DWORD NewInst; // fixup instruction (see alphaops.h)
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 12559 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

// The following structure defines the new import object.  Note the values of the first two fields,
// which must be set as stated in order to differentiate old and new import members.
// Following this structure, the linker emits two null-terminated strings used to recreate the
// import at the time of use.  The first string is the import's name, the second is the dll's name.

#define IMPORT_OBJECT_HDR_SIG2 0xffff

typedef struct IMPORT_OBJECT_HEADER {
    WORD Sig1; // Must be IMAGE_FILE_MACHINE_UNKNOWN
    WORD Sig2; // Must be IMPORT_OBJECT_HDR_SIG2.
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp; // Time/date stamp
    DWORD SizeOfData; // particularly useful for incremental links

    union {
        WORD Ordinal; // if grf & IMPORT_OBJECT_ORDINAL
        WORD Hint;
    } u;

    WORD Type : 2; // IMPORT_TYPE
    WORD NameType : 3; // IMPORT_NAME_TYPE
    WORD Reserved : 11; // Reserved. Must be zero.
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0, // Import by ordinal
    IMPORT_OBJECT_NAME = 1, // Import name == public symbol name.
    IMPORT_OBJECT_NAME_NO_PREFIX = 2, // Import name == public symbol name skipping leading ?, @, or optionally _.
    IMPORT_OBJECT_NAME_UNDECORATE = 3, // Import name == public symbol name skipping leading ?, @, or optionally _
                                        // and truncating at first @
} IMPORT_OBJECT_NAME_TYPE;



#define __IMAGE_COR20_HEADER_DEFINED__ 

typedef enum ReplacesCorHdrNumericDefines
{
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA =0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2 =2,
    COR_VERSION_MAJOR =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR =0,
    COR_DELETED_NAME_LENGTH =8,
    COR_VTABLEGAP_NAME_LENGTH =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA =0x01,
    IMAGE_COR_MIH_EHRVA =0x02,
    IMAGE_COR_MIH_BASICBLOCK =0x08,

// V-table constants
    COR_VTABLE_32BIT =0x01, // V-table slots are 32-bits in size.
    COR_VTABLE_64BIT =0x02, // V-table slots are 64-bits in size.
    COR_VTABLE_FROM_UNMANAGED =0x04, // If set, transition from unmanaged.
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN =0x08, // If set, transition from unmanaged with keeping the current appdomain.
    COR_VTABLE_CALL_MOST_DERIVED =0x10, // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE =32, // Size of a jump thunk reserved range.

// Max name lengths
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME =1024,
    MAX_PACKAGE_NAME =1024,
} ReplacesCorHdrNumericDefines;

// CLR 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    DWORD cb;
    WORD MajorRuntimeVersion;
    WORD MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY MetaData;
    DWORD Flags;

    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.
    union {
        DWORD EntryPointToken;
        DWORD EntryPointRVA;
    } u;

    // Binding information
    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY CodeManagerTable;
    IMAGE_DATA_DIRECTORY VTableFixups;
    IMAGE_DATA_DIRECTORY ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;



//
// End Image Format
//

//
// for move macros
//
# 12699 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define _SLIST_HEADER_ 



//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

#pragma warning(push)
#pragma warning(disable:4324)
typedef struct _SLIST_ENTRY *PSLIST_ENTRY;
typedef struct _SLIST_ENTRY {
    PSLIST_ENTRY Next;
} SLIST_ENTRY;
#pragma warning(pop)

typedef struct _SLIST_ENTRY32 {
    DWORD Next;
} SLIST_ENTRY32, *PSLIST_ENTRY32;
# 12736 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
typedef union _SLIST_HEADER {
    struct { // original struct
        ULONGLONG Alignment;
        ULONGLONG Region;
    } s;
    struct { // 8-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:9;
        ULONGLONG NextEntry:39;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1; // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:59;
        ULONGLONG Region:3;
    } Header8;
    struct { // ia64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Init:1; // 0: uninitialized; 1: initialized
        ULONGLONG Reserved:2;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } Header16;
    struct { // x64 16-byte header
        ULONGLONG Depth:16;
        ULONGLONG Sequence:48;
        ULONGLONG HeaderType:1; // 0: 8-byte; 1: 16-byte
        ULONGLONG Reserved:3;
        ULONGLONG NextEntry:60; // last 4 bits are always 0's
    } HeaderX64;
} SLIST_HEADER, *PSLIST_HEADER;

typedef union _SLIST_HEADER32{
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY32 Next;
        WORD Depth;
        WORD Sequence;
    } s;
} SLIST_HEADER32, *PSLIST_HEADER32;
# 12794 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"

void

RtlInitializeSListHead (
    PSLIST_HEADER ListHead
    );



PSLIST_ENTRY

RtlFirstEntrySList (
    const SLIST_HEADER *ListHead
    );


PSLIST_ENTRY

RtlInterlockedPopEntrySList (
    PSLIST_HEADER ListHead
    );


PSLIST_ENTRY

RtlInterlockedPushEntrySList (
    PSLIST_HEADER ListHead,
    PSLIST_ENTRY ListEntry
    );


PSLIST_ENTRY

RtlInterlockedFlushSList (
    PSLIST_HEADER ListHead
    );


WORD

RtlQueryDepthSList (
    PSLIST_HEADER ListHead
    );
# 12849 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
// begin_ntddk


#define _RTL_RUN_ONCE_DEF 

//
// Run once
//

#define RTL_RUN_ONCE_INIT {0}

//
// Run once flags
//

#define RTL_RUN_ONCE_CHECK_ONLY 0x00000001UL
#define RTL_RUN_ONCE_ASYNC 0x00000002UL
#define RTL_RUN_ONCE_INIT_FAILED 0x00000004UL

//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//

#define RTL_RUN_ONCE_CTX_RESERVED_BITS 2

typedef union _RTL_RUN_ONCE {
    PVOID Ptr;
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;

typedef


DWORD /* LOGICAL */

RTL_RUN_ONCE_INIT_FN (
    PRTL_RUN_ONCE RunOnce,
    PVOID Parameter,
    PVOID *Context
    );
typedef RTL_RUN_ONCE_INIT_FN *PRTL_RUN_ONCE_INIT_FN;







void

RtlRunOnceInitialize (
    PRTL_RUN_ONCE RunOnce
    );




DWORD

RtlRunOnceExecuteOnce (
    PRTL_RUN_ONCE RunOnce,
    PRTL_RUN_ONCE_INIT_FN InitFn,
    PVOID Parameter,
    PVOID *Context
    );




DWORD

RtlRunOnceBeginInitialize (
    PRTL_RUN_ONCE RunOnce,
    DWORD Flags,
    PVOID *Context
    );



DWORD

RtlRunOnceComplete (
    PRTL_RUN_ONCE RunOnce,
    DWORD Flags,
    PVOID Context
    );



#define HEAP_NO_SERIALIZE 0x00000001
#define HEAP_GROWABLE 0x00000002
#define HEAP_GENERATE_EXCEPTIONS 0x00000004
#define HEAP_ZERO_MEMORY 0x00000008
#define HEAP_REALLOC_IN_PLACE_ONLY 0x00000010
#define HEAP_TAIL_CHECKING_ENABLED 0x00000020
#define HEAP_FREE_CHECKING_ENABLED 0x00000040
#define HEAP_DISABLE_COALESCE_ON_FREE 0x00000080
#define HEAP_CREATE_ALIGN_16 0x00010000
#define HEAP_CREATE_ENABLE_TRACING 0x00020000
#define HEAP_CREATE_ENABLE_EXECUTE 0x00040000
#define HEAP_MAXIMUM_TAG 0x0FFF
#define HEAP_PSEUDO_TAG_FLAG 0x8000
#define HEAP_TAG_SHIFT 18

__inline
DWORD
HEAP_MAKE_TAG_FLAGS (
    DWORD TagBase,
    DWORD Tag
    )

{
    ;
    return ((DWORD)((TagBase) + ((Tag) << 18)));
}




WORD

RtlCaptureStackBackTrace(
    DWORD FramesToSkip,
    DWORD FramesToCapture,
    PVOID *BackTrace,
    PDWORD BackTraceHash
   );




void

RtlCaptureContext (
    PCONTEXT ContextRecord
    );



#define IS_TEXT_UNICODE_ASCII16 0x0001
#define IS_TEXT_UNICODE_REVERSE_ASCII16 0x0010

#define IS_TEXT_UNICODE_STATISTICS 0x0002
#define IS_TEXT_UNICODE_REVERSE_STATISTICS 0x0020

#define IS_TEXT_UNICODE_CONTROLS 0x0004
#define IS_TEXT_UNICODE_REVERSE_CONTROLS 0x0040

#define IS_TEXT_UNICODE_SIGNATURE 0x0008
#define IS_TEXT_UNICODE_REVERSE_SIGNATURE 0x0080

#define IS_TEXT_UNICODE_ILLEGAL_CHARS 0x0100
#define IS_TEXT_UNICODE_ODD_LENGTH 0x0200
#define IS_TEXT_UNICODE_DBCS_LEADBYTE 0x0400
#define IS_TEXT_UNICODE_NULL_BYTES 0x1000

#define IS_TEXT_UNICODE_UNICODE_MASK 0x000F
#define IS_TEXT_UNICODE_REVERSE_MASK 0x00F0
#define IS_TEXT_UNICODE_NOT_UNICODE_MASK 0x0F00
#define IS_TEXT_UNICODE_NOT_ASCII_MASK 0xF000

#define COMPRESSION_FORMAT_NONE (0x0000)
#define COMPRESSION_FORMAT_DEFAULT (0x0001)
#define COMPRESSION_FORMAT_LZNT1 (0x0002)
#define COMPRESSION_ENGINE_STANDARD (0x0000)
#define COMPRESSION_ENGINE_MAXIMUM (0x0100)
#define COMPRESSION_ENGINE_HIBER (0x0200)
# 13042 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"


SIZE_T

RtlCompareMemory (
    const void *Source1,
    const void *Source2,
    SIZE_T Length
    );



#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))




__inline
PVOID
RtlSecureZeroMemory(
    PVOID ptr,
    SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;







    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }



    return ptr;
}




#define SEF_DACL_AUTO_INHERIT 0x01
#define SEF_SACL_AUTO_INHERIT 0x02
#define SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT 0x04
#define SEF_AVOID_PRIVILEGE_CHECK 0x08
#define SEF_AVOID_OWNER_CHECK 0x10
#define SEF_DEFAULT_OWNER_FROM_PARENT 0x20
#define SEF_DEFAULT_GROUP_FROM_PARENT 0x40
#define SEF_MACL_NO_WRITE_UP 0x100
#define SEF_MACL_NO_READ_UP 0x200
#define SEF_MACL_NO_EXECUTE_UP 0x400
#define SEF_AVOID_OWNER_RESTRICTION 0x1000

#define SEF_MACL_VALID_FLAGS (SEF_MACL_NO_WRITE_UP | SEF_MACL_NO_READ_UP | SEF_MACL_NO_EXECUTE_UP)




typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD Length;
    WORD Flags;
    BYTE Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

#define MESSAGE_RESOURCE_UNICODE 0x0001

typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;



PVOID

RtlPcToFileHeader(
    PVOID PcValue,
    PVOID *BaseOfImage
    );

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;





typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;


typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;





typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;


//
// RtlVerifyVersionInfo() conditions
//

#define VER_EQUAL 1
#define VER_GREATER 2
#define VER_GREATER_EQUAL 3
#define VER_LESS 4
#define VER_LESS_EQUAL 5
#define VER_AND 6
#define VER_OR 7

#define VER_CONDITION_MASK 7
#define VER_NUM_BITS_PER_CONDITION_MASK 3

//
// RtlVerifyVersionInfo() type mask bits
//

#define VER_MINORVERSION 0x0000001
#define VER_MAJORVERSION 0x0000002
#define VER_BUILDNUMBER 0x0000004
#define VER_PLATFORMID 0x0000008
#define VER_SERVICEPACKMINOR 0x0000010
#define VER_SERVICEPACKMAJOR 0x0000020
#define VER_SUITENAME 0x0000040
#define VER_PRODUCT_TYPE 0x0000080

//
// RtlVerifyVersionInfo() os product type values
//

#define VER_NT_WORKSTATION 0x0000001
#define VER_NT_DOMAIN_CONTROLLER 0x0000002
#define VER_NT_SERVER 0x0000003

//
// dwPlatformId defines:
//

#define VER_PLATFORM_WIN32s 0
#define VER_PLATFORM_WIN32_WINDOWS 1
#define VER_PLATFORM_WIN32_NT 2


//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//

#define VER_SET_CONDITION(_m_,_t_,_c_) ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)))




ULONGLONG

VerSetConditionMask(
    ULONGLONG ConditionMask,
    DWORD TypeMask,
    BYTE Condition
    );


//




BOOLEAN

RtlGetProductInfo(
    DWORD OSMajorVersion,
    DWORD OSMinorVersion,
    DWORD SpMajorVersion,
    DWORD SpMinorVersion,
    PDWORD ReturnedProductType
    );



#define RTL_UMS_VERSION (0x0100)

typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;

typedef

void

RTL_UMS_SCHEDULER_ENTRY_POINT(
    RTL_UMS_SCHEDULER_REASON Reason,
    ULONG_PTR ActivationPayload,
    PVOID SchedulerParam
    );

typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;






DWORD

RtlCopyExtendedContext (
    PCONTEXT_EX Destination,
    DWORD ContextFlags,
    PCONTEXT_EX Source
    );


DWORD

RtlInitializeExtendedContext (
    PVOID Context,
    DWORD ContextFlags,
    PCONTEXT_EX* ContextEx
    );


DWORD64

RtlGetEnabledExtendedFeatures (
    DWORD64 FeatureMask
    );



DWORD

RtlGetExtendedContextLength (
    DWORD ContextFlags,
    PDWORD ContextLength
    );


DWORD64

RtlGetExtendedFeaturesMask (
    PCONTEXT_EX ContextEx
    );


PVOID

RtlLocateExtendedFeature (
    PCONTEXT_EX ContextEx,
    DWORD FeatureId,
    PDWORD Length
    );


PCONTEXT

RtlLocateLegacyContext (
    PCONTEXT_EX ContextEx,
    PDWORD Length
    );


void

RtlSetExtendedFeaturesMask (
    PCONTEXT_EX ContextEx,
    DWORD64 FeatureMask
    );




typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;

#define RTL_CRITSECT_TYPE 0
#define RTL_RESOURCE_TYPE 1

//
// These flags define the upper byte of the critical section SpinCount field
//
#define RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO 0x01000000
#define RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN 0x02000000
#define RTL_CRITICAL_SECTION_FLAG_STATIC_INIT 0x04000000
#define RTL_CRITICAL_SECTION_ALL_FLAG_BITS 0xFF000000
#define RTL_CRITICAL_SECTION_FLAG_RESERVED (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & (~(RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO | RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN | RTL_CRITICAL_SECTION_FLAG_STATIC_INIT)))

//
// These flags define possible values stored in the Flags field of a critsec debuginfo.
//
#define RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT 0x00000001

#pragma pack(push, 8)

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread; // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount; // force size on 64-bit systems when packed
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

typedef struct _RTL_SRWLOCK {
        PVOID Ptr;
} RTL_SRWLOCK, *PRTL_SRWLOCK;
#define RTL_SRWLOCK_INIT {0}
typedef struct _RTL_CONDITION_VARIABLE {
        PVOID Ptr;
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;
#define RTL_CONDITION_VARIABLE_INIT {0}
#define RTL_CONDITION_VARIABLE_LOCKMODE_SHARED 0x1
typedef
void
( *PAPCFUNC)(
    ULONG_PTR Parameter
    );
typedef LONG ( *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation,
    HeapEnableTerminationOnCorruption


} HEAP_INFORMATION_CLASS;


#define WT_EXECUTEDEFAULT 0x00000000
#define WT_EXECUTEINIOTHREAD 0x00000001
#define WT_EXECUTEINUITHREAD 0x00000002
#define WT_EXECUTEINWAITTHREAD 0x00000004
#define WT_EXECUTEONLYONCE 0x00000008
#define WT_EXECUTEINTIMERTHREAD 0x00000020
#define WT_EXECUTELONGFUNCTION 0x00000010
#define WT_EXECUTEINPERSISTENTIOTHREAD 0x00000040
#define WT_EXECUTEINPERSISTENTTHREAD 0x00000080
#define WT_TRANSFER_IMPERSONATION 0x00000100
#define WT_SET_MAX_THREADPOOL_THREADS(Flags,Limit) ((Flags) |= (Limit)<<16)
typedef void ( * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
typedef void ( * WORKERCALLBACKFUNC) (PVOID );
typedef void ( * APC_CALLBACK_FUNCTION) (DWORD , PVOID, PVOID);
typedef
void
( *PFLS_CALLBACK_FUNCTION) (
    PVOID lpFlsData
    );

typedef
BOOLEAN
( *PSECURE_MEMORY_CACHE_CALLBACK) (
    PVOID Addr,
    SIZE_T Range
    );

#define WT_EXECUTEINLONGTHREAD 0x00000010
#define WT_EXECUTEDELETEWAIT 0x00000008

typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass,

    //
    // compatibility with old names
    //
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4
} ACTIVATION_CONTEXT_INFO_CLASS;

#define ACTIVATIONCONTEXTINFOCLASS ACTIVATION_CONTEXT_INFO_CLASS


typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;


#define ACTIVATION_CONTEXT_PATH_TYPE_NONE (1)
#define ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE (2)
#define ACTIVATION_CONTEXT_PATH_TYPE_URL (3)
#define ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF (4)

typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;

    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;

//
// compatibility with old names
// The new names use "file" consistently.
//
#define _ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION _ASSEMBLY_FILE_DETAILED_INFORMATION
#define ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION ASSEMBLY_FILE_DETAILED_INFORMATION
#define PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION PASSEMBLY_FILE_DETAILED_INFORMATION
#define PCASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION PCASSEMBLY_FILE_DETAILED_INFORMATION

typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength; // in bytes
    DWORD ulManifestPathType; // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulManifestPathLength; // in bytes
    LARGE_INTEGER liManifestLastWriteTime; // FILETIME
    DWORD ulPolicyPathType; // ACTIVATION_CONTEXT_PATH_TYPE_*
    DWORD ulPolicyPathLength; // in bytes
    LARGE_INTEGER liPolicyLastWriteTime; // FILETIME
    DWORD ulMetadataSatelliteRosterIndex;

    DWORD ulManifestVersionMajor; // 1
    DWORD ulManifestVersionMinor; // 0
    DWORD ulPolicyVersionMajor; // 0
    DWORD ulPolicyVersionMinor; // 0
    DWORD ulAssemblyDirectoryNameLength; // in bytes

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;

typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;

#pragma warning(push)
#pragma warning(disable:4200)

typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#pragma warning(pop)

typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#define MAX_SUPPORTED_OS_NUM (4)
#define INVALID_OS_COUNT (0xffff)

typedef struct _SUPPORTED_OS_INFO {
    WORD OsCount;
    WORD MitigationExist;
    WORD OsList[(4)];
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;

#define PERFORMANCE_DATA_VERSION 1

typedef struct _PERFORMANCE_DATA {
    WORD Size;
    BYTE Version;
    BYTE HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;

#define READ_THREAD_PROFILING_FLAG_DISPATCHING 0x00000001
#define READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS 0x00000002
#define DLL_PROCESS_ATTACH 1
#define DLL_THREAD_ATTACH 2
#define DLL_THREAD_DETACH 3
#define DLL_PROCESS_DETACH 0

//
// Defines for the READ flags for Eventlogging
//
#define EVENTLOG_SEQUENTIAL_READ 0x0001
#define EVENTLOG_SEEK_READ 0x0002
#define EVENTLOG_FORWARDS_READ 0x0004
#define EVENTLOG_BACKWARDS_READ 0x0008

//
// The types of events that can be logged.
//
#define EVENTLOG_SUCCESS 0x0000
#define EVENTLOG_ERROR_TYPE 0x0001
#define EVENTLOG_WARNING_TYPE 0x0002
#define EVENTLOG_INFORMATION_TYPE 0x0004
#define EVENTLOG_AUDIT_SUCCESS 0x0008
#define EVENTLOG_AUDIT_FAILURE 0x0010

//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//

#define EVENTLOG_START_PAIRED_EVENT 0x0001
#define EVENTLOG_END_PAIRED_EVENT 0x0002
#define EVENTLOG_END_ALL_PAIRED_EVENTS 0x0004
#define EVENTLOG_PAIRED_EVENT_ACTIVE 0x0008
#define EVENTLOG_PAIRED_EVENT_INACTIVE 0x0010

//
// Structure that defines the header of the Eventlog record. This is the
// fixed-sized portion before all the variable-length strings, binary
// data and pad bytes.
//
// TimeGenerated is the time it was generated at the client.
// TimeWritten is the time it was put into the log at the server end.
//

typedef struct _EVENTLOGRECORD {
    DWORD Length; // Length of full record
    DWORD Reserved; // Used by the service
    DWORD RecordNumber; // Absolute record number
    DWORD TimeGenerated; // Seconds since 1-1-1970
    DWORD TimeWritten; // Seconds since 1-1-1970
    DWORD EventID;
    WORD EventType;
    WORD NumStrings;
    WORD EventCategory;
    WORD ReservedFlags; // For use with paired events (auditing)
    DWORD ClosingRecordNumber; // For use with paired events (auditing)
    DWORD StringOffset; // Offset from beginning of record
    DWORD UserSidLength;
    DWORD UserSidOffset;
    DWORD DataLength;
    DWORD DataOffset; // Offset from beginning of record
    //
    // Then follow:
    //
    // WCHAR SourceName[]
    // WCHAR Computername[]
    // SID   UserSid
    // WCHAR Strings[]
    // BYTE  Data[]
    // CHAR  Pad[]
    // DWORD Length;
    //
} EVENTLOGRECORD, *PEVENTLOGRECORD;

//SS: start of changes to support clustering
//SS: ideally the
#define MAXLOGICALLOGNAMESIZE 256




#pragma warning(disable : 4200)

struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;
# 13774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#pragma warning(default : 4200)

//SS: end of changes to support clustering
//

// begin_wdm 
//
// Registry Specific Access Rights.
//

#define KEY_QUERY_VALUE (0x0001)
#define KEY_SET_VALUE (0x0002)
#define KEY_CREATE_SUB_KEY (0x0004)
#define KEY_ENUMERATE_SUB_KEYS (0x0008)
#define KEY_NOTIFY (0x0010)
#define KEY_CREATE_LINK (0x0020)
#define KEY_WOW64_32KEY (0x0200)
#define KEY_WOW64_64KEY (0x0100)
#define KEY_WOW64_RES (0x0300)

#define KEY_READ ((STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY) & (~SYNCHRONIZE))







#define KEY_WRITE ((STANDARD_RIGHTS_WRITE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY) & (~SYNCHRONIZE))





#define KEY_EXECUTE ((KEY_READ) & (~SYNCHRONIZE))



#define KEY_ALL_ACCESS ((STANDARD_RIGHTS_ALL | KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_NOTIFY | KEY_CREATE_LINK) & (~SYNCHRONIZE))
# 13822 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
//
// Open/Create Options
//

#define REG_OPTION_RESERVED (0x00000000L)

#define REG_OPTION_NON_VOLATILE (0x00000000L)
                                                    // when system is rebooted

#define REG_OPTION_VOLATILE (0x00000001L)
                                                    // when system is rebooted

#define REG_OPTION_CREATE_LINK (0x00000002L)
                                                    // symbolic link

#define REG_OPTION_BACKUP_RESTORE (0x00000004L)
                                                    // special access rules
                                                    // privilege required

#define REG_OPTION_OPEN_LINK (0x00000008L)

#define REG_LEGAL_OPTION (REG_OPTION_RESERVED | REG_OPTION_NON_VOLATILE | REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK | REG_OPTION_BACKUP_RESTORE | REG_OPTION_OPEN_LINK)







#define REG_OPEN_LEGAL_OPTION (REG_OPTION_RESERVED | REG_OPTION_BACKUP_RESTORE | REG_OPTION_OPEN_LINK)




//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY (0x00000001L)
#define REG_OPENED_EXISTING_KEY (0x00000002L)

//
// hive format to be used by Reg(Nt)SaveKeyEx
//
#define REG_STANDARD_FORMAT 1
#define REG_LATEST_FORMAT 2
#define REG_NO_COMPRESSION 4

//
// Key restore & hive load flags
//

#define REG_WHOLE_HIVE_VOLATILE (0x00000001L)
#define REG_REFRESH_HIVE (0x00000002L)
#define REG_NO_LAZY_FLUSH (0x00000004L)
#define REG_FORCE_RESTORE (0x00000008L)
#define REG_APP_HIVE (0x00000010L)
#define REG_PROCESS_PRIVATE (0x00000020L)
#define REG_START_JOURNAL (0x00000040L)
#define REG_HIVE_EXACT_FILE_GROWTH (0x00000080L)
#define REG_HIVE_NO_RM (0x00000100L)
#define REG_HIVE_SINGLE_LOG (0x00000200L)
#define REG_BOOT_HIVE (0x00000400L)

//
// Unload Flags
//
#define REG_FORCE_UNLOAD 1

//
// Notify filter values
//

#define REG_NOTIFY_CHANGE_NAME (0x00000001L)
#define REG_NOTIFY_CHANGE_ATTRIBUTES (0x00000002L)
#define REG_NOTIFY_CHANGE_LAST_SET (0x00000004L)
#define REG_NOTIFY_CHANGE_SECURITY (0x00000008L)

#define REG_LEGAL_CHANGE_FILTER (REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES | REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY)





// end_wdm 

//
//
// Predefined Value Types.
//

#define REG_NONE ( 0 )
#define REG_SZ ( 1 )
#define REG_EXPAND_SZ ( 2 )
                                            // (with environment variable references)
#define REG_BINARY ( 3 )
#define REG_DWORD ( 4 )
#define REG_DWORD_LITTLE_ENDIAN ( 4 )
#define REG_DWORD_BIG_ENDIAN ( 5 )
#define REG_LINK ( 6 )
#define REG_MULTI_SZ ( 7 )
#define REG_RESOURCE_LIST ( 8 )
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )
#define REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
#define REG_QWORD ( 11 )
#define REG_QWORD_LITTLE_ENDIAN ( 11 )

// end_wdm

// begin_wdm
//
// Service Types (Bit Mask)
//
#define SERVICE_KERNEL_DRIVER 0x00000001
#define SERVICE_FILE_SYSTEM_DRIVER 0x00000002
#define SERVICE_ADAPTER 0x00000004
#define SERVICE_RECOGNIZER_DRIVER 0x00000008

#define SERVICE_DRIVER (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_RECOGNIZER_DRIVER)



#define SERVICE_WIN32_OWN_PROCESS 0x00000010
#define SERVICE_WIN32_SHARE_PROCESS 0x00000020
#define SERVICE_WIN32 (SERVICE_WIN32_OWN_PROCESS | SERVICE_WIN32_SHARE_PROCESS)


#define SERVICE_INTERACTIVE_PROCESS 0x00000100

#define SERVICE_TYPE_ALL (SERVICE_WIN32 | SERVICE_ADAPTER | SERVICE_DRIVER | SERVICE_INTERACTIVE_PROCESS)




//
// Start Type
//

#define SERVICE_BOOT_START 0x00000000
#define SERVICE_SYSTEM_START 0x00000001
#define SERVICE_AUTO_START 0x00000002
#define SERVICE_DEMAND_START 0x00000003
#define SERVICE_DISABLED 0x00000004

//
// Error control type
//
#define SERVICE_ERROR_IGNORE 0x00000000
#define SERVICE_ERROR_NORMAL 0x00000001
#define SERVICE_ERROR_SEVERE 0x00000002
#define SERVICE_ERROR_CRITICAL 0x00000003

//
//
// Define the registry driver node enumerations
//

typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType = 0x00000001,
    FileSystemType = 0x00000002,
    Win32ServiceOwnProcess = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType = 0x00000004,
    RecognizerType = 0x00000008
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad = 0x00000000,
    SystemLoad = 0x00000001,
    AutoLoad = 0x00000002,
    DemandLoad = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError = 0x00000000,
    NormalError = 0x00000001,
    SevereError = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;

//
// Service node Flags. These flags are used by the OS loader to promote
// a driver's start type to boot start if the system is booting using
// the specified mechanism. The flags should be set in the driver's
// registry configuration.
//
// CM_SERVICE_NETWORK_BOOT_LOAD - Specified if a driver should be
// promoted on network boot.
//
// CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD - Specified if a driver should be
// promoted on booting from a VHD.
//
// CM_SERVICE_USB_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from a USB disk.
//

#define CM_SERVICE_NETWORK_BOOT_LOAD 0x00000001
#define CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD 0x00000002
#define CM_SERVICE_USB_DISK_BOOT_LOAD 0x00000004

//
// Mask defining the legal promotion flag values.
//

#define CM_SERVICE_VALID_PROMOTION_MASK (CM_SERVICE_NETWORK_BOOT_LOAD | CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD | CM_SERVICE_USB_DISK_BOOT_LOAD)





//
// IOCTL_TAPE_ERASE definitions
//

#define TAPE_ERASE_SHORT 0L
#define TAPE_ERASE_LONG 1L

typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//

#define TAPE_LOAD 0L
#define TAPE_UNLOAD 1L
#define TAPE_TENSION 2L
#define TAPE_LOCK 3L
#define TAPE_UNLOCK 4L
#define TAPE_FORMAT 5L

typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//

#define TAPE_SETMARKS 0L
#define TAPE_FILEMARKS 1L
#define TAPE_SHORT_FILEMARKS 2L
#define TAPE_LONG_FILEMARKS 3L

typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//

#define TAPE_ABSOLUTE_POSITION 0L
#define TAPE_LOGICAL_POSITION 1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L

typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//

#define TAPE_REWIND 0L
#define TAPE_ABSOLUTE_BLOCK 1L
#define TAPE_LOGICAL_BLOCK 2L
#define TAPE_PSEUDO_LOGICAL_BLOCK 3L
#define TAPE_SPACE_END_OF_DATA 4L
#define TAPE_SPACE_RELATIVE_BLOCKS 5L
#define TAPE_SPACE_FILEMARKS 6L
#define TAPE_SPACE_SEQUENTIAL_FMKS 7L
#define TAPE_SPACE_SETMARKS 8L
#define TAPE_SPACE_SEQUENTIAL_SMKS 9L

typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

#define TAPE_DRIVE_FIXED 0x00000001
#define TAPE_DRIVE_SELECT 0x00000002
#define TAPE_DRIVE_INITIATOR 0x00000004

#define TAPE_DRIVE_ERASE_SHORT 0x00000010
#define TAPE_DRIVE_ERASE_LONG 0x00000020
#define TAPE_DRIVE_ERASE_BOP_ONLY 0x00000040
#define TAPE_DRIVE_ERASE_IMMEDIATE 0x00000080

#define TAPE_DRIVE_TAPE_CAPACITY 0x00000100
#define TAPE_DRIVE_TAPE_REMAINING 0x00000200
#define TAPE_DRIVE_FIXED_BLOCK 0x00000400
#define TAPE_DRIVE_VARIABLE_BLOCK 0x00000800

#define TAPE_DRIVE_WRITE_PROTECT 0x00001000
#define TAPE_DRIVE_EOT_WZ_SIZE 0x00002000

#define TAPE_DRIVE_ECC 0x00010000
#define TAPE_DRIVE_COMPRESSION 0x00020000
#define TAPE_DRIVE_PADDING 0x00040000
#define TAPE_DRIVE_REPORT_SMKS 0x00080000

#define TAPE_DRIVE_GET_ABSOLUTE_BLK 0x00100000
#define TAPE_DRIVE_GET_LOGICAL_BLK 0x00200000
#define TAPE_DRIVE_SET_EOT_WZ_SIZE 0x00400000

#define TAPE_DRIVE_EJECT_MEDIA 0x01000000
#define TAPE_DRIVE_CLEAN_REQUESTS 0x02000000
#define TAPE_DRIVE_SET_CMP_BOP_ONLY 0x04000000

#define TAPE_DRIVE_RESERVED_BIT 0x80000000
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

#define TAPE_DRIVE_LOAD_UNLOAD 0x80000001
#define TAPE_DRIVE_TENSION 0x80000002
#define TAPE_DRIVE_LOCK_UNLOCK 0x80000004
#define TAPE_DRIVE_REWIND_IMMEDIATE 0x80000008

#define TAPE_DRIVE_SET_BLOCK_SIZE 0x80000010
#define TAPE_DRIVE_LOAD_UNLD_IMMED 0x80000020
#define TAPE_DRIVE_TENSION_IMMED 0x80000040
#define TAPE_DRIVE_LOCK_UNLK_IMMED 0x80000080

#define TAPE_DRIVE_SET_ECC 0x80000100
#define TAPE_DRIVE_SET_COMPRESSION 0x80000200
#define TAPE_DRIVE_SET_PADDING 0x80000400
#define TAPE_DRIVE_SET_REPORT_SMKS 0x80000800

#define TAPE_DRIVE_ABSOLUTE_BLK 0x80001000
#define TAPE_DRIVE_ABS_BLK_IMMED 0x80002000
#define TAPE_DRIVE_LOGICAL_BLK 0x80004000
#define TAPE_DRIVE_LOG_BLK_IMMED 0x80008000

#define TAPE_DRIVE_END_OF_DATA 0x80010000
#define TAPE_DRIVE_RELATIVE_BLKS 0x80020000
#define TAPE_DRIVE_FILEMARKS 0x80040000
#define TAPE_DRIVE_SEQUENTIAL_FMKS 0x80080000

#define TAPE_DRIVE_SETMARKS 0x80100000
#define TAPE_DRIVE_SEQUENTIAL_SMKS 0x80200000
#define TAPE_DRIVE_REVERSE_POSITION 0x80400000
#define TAPE_DRIVE_SPACE_IMMEDIATE 0x80800000

#define TAPE_DRIVE_WRITE_SETMARKS 0x81000000
#define TAPE_DRIVE_WRITE_FILEMARKS 0x82000000
#define TAPE_DRIVE_WRITE_SHORT_FMKS 0x84000000
#define TAPE_DRIVE_WRITE_LONG_FMKS 0x88000000

#define TAPE_DRIVE_WRITE_MARK_IMMED 0x90000000
#define TAPE_DRIVE_FORMAT 0xA0000000
#define TAPE_DRIVE_FORMAT_IMMEDIATE 0xC0000000
#define TAPE_DRIVE_HIGH_FEATURES 0x80000000

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

#define TAPE_FIXED_PARTITIONS 0L
#define TAPE_SELECT_PARTITIONS 1L
#define TAPE_INITIATOR_PARTITIONS 2L

typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;


//
// WMI Methods
//
#define TAPE_QUERY_DRIVE_PARAMETERS 0L
#define TAPE_QUERY_MEDIA_CAPACITY 1L
#define TAPE_CHECK_FOR_DRIVE_PROBLEM 2L
#define TAPE_QUERY_IO_ERROR_DATA 3L
#define TAPE_QUERY_DEVICE_ERROR_DATA 4L

typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;

//
// Type of drive errors
//
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;


#define _NTTMAPI_ 







# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ktmtypes.h" 1
/*++



Copyright (c) 2000  Microsoft Corporation



Module Name:



    ktmtypes.h



Abstract:



    Common types for KTM exposed at both the Nt- and Win32-layer.



Revision History:



--*/
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ktmtypes.h"
// begin_wdm begin_winnt

#define _KTMTYPES_ 







typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;

//
// Define the TransactionManager option values
//

#define TRANSACTION_MANAGER_VOLATILE 0x00000001
#define TRANSACTION_MANAGER_COMMIT_DEFAULT 0x00000000
#define TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME 0x00000002
#define TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES 0x00000004
#define TRANSACTION_MANAGER_COMMIT_LOWEST 0x00000008
#define TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY 0x00000010
#define TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS 0x00000020
#define TRANSACTION_MANAGER_MAXIMUM_OPTION 0x0000003F


//
// Define the Transaction option values
//

#define TRANSACTION_DO_NOT_PROMOTE 0x00000001
#define TRANSACTION_MAXIMUM_OPTION 0x00000001


//
// Define the ResourceManager option values
//

#define RESOURCE_MANAGER_VOLATILE 0x00000001
#define RESOURCE_MANAGER_COMMUNICATION 0x00000002
#define RESOURCE_MANAGER_MAXIMUM_OPTION 0x00000003


//
// Define the RegisterProtocol option values
//

#define CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY 0x00000001
#define CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO 0x00000002
#define CRM_PROTOCOL_MAXIMUM_OPTION 0x00000003


//
// Define the Enlistment option values
//

#define ENLISTMENT_SUPERIOR 0x00000001
#define ENLISTMENT_MAXIMUM_OPTION 0x00000001


typedef ULONG NOTIFICATION_MASK;
#define TRANSACTION_NOTIFY_MASK 0x3FFFFFFF
#define TRANSACTION_NOTIFY_PREPREPARE 0x00000001
#define TRANSACTION_NOTIFY_PREPARE 0x00000002
#define TRANSACTION_NOTIFY_COMMIT 0x00000004
#define TRANSACTION_NOTIFY_ROLLBACK 0x00000008
#define TRANSACTION_NOTIFY_PREPREPARE_COMPLETE 0x00000010
#define TRANSACTION_NOTIFY_PREPARE_COMPLETE 0x00000020
#define TRANSACTION_NOTIFY_COMMIT_COMPLETE 0x00000040
#define TRANSACTION_NOTIFY_ROLLBACK_COMPLETE 0x00000080
#define TRANSACTION_NOTIFY_RECOVER 0x00000100
#define TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT 0x00000200
#define TRANSACTION_NOTIFY_DELEGATE_COMMIT 0x00000400
#define TRANSACTION_NOTIFY_RECOVER_QUERY 0x00000800
#define TRANSACTION_NOTIFY_ENLIST_PREPREPARE 0x00001000
#define TRANSACTION_NOTIFY_LAST_RECOVER 0x00002000
#define TRANSACTION_NOTIFY_INDOUBT 0x00004000
#define TRANSACTION_NOTIFY_PROPAGATE_PULL 0x00008000
#define TRANSACTION_NOTIFY_PROPAGATE_PUSH 0x00010000
#define TRANSACTION_NOTIFY_MARSHAL 0x00020000
#define TRANSACTION_NOTIFY_ENLIST_MASK 0x00040000
#define TRANSACTION_NOTIFY_RM_DISCONNECTED 0x01000000
#define TRANSACTION_NOTIFY_TM_ONLINE 0x02000000
#define TRANSACTION_NOTIFY_COMMIT_REQUEST 0x04000000
#define TRANSACTION_NOTIFY_PROMOTE 0x08000000
#define TRANSACTION_NOTIFY_PROMOTE_NEW 0x10000000
#define TRANSACTION_NOTIFY_REQUEST_OUTCOME 0x20000000
//
//  Note that this flag is not included in the TRANSACTION_NOTIFY_MASK.
//  The reason being that KTM does not understand this flag yet. This
//  flag is strictly for the use of filter manager. In fact we mask it
//  out before enlisting in any transaction.
//
#define TRANSACTION_NOTIFY_COMMIT_FINALIZE 0x40000000

//
// Path to the transaction manager objects in the NT
// object namespace.
//
#define TRANSACTIONMANAGER_OBJECT_PATH L"\\TransactionManager\\"
#define TRANSACTION_OBJECT_PATH L"\\Transaction\\"
#define ENLISTMENT_OBJECT_PATH L"\\Enlistment\\"
#define RESOURCE_MANAGER_OBJECT_PATH L"\\ResourceManager\\"

//
// The following three defines are here to ease the allocation
// of string buffers which are to contain a fully qualified 
// transaction manager object name, e.g., \Transaction\{GUID}
//
#define TRANSACTIONMANAGER_OBJECT_NAME_LENGTH_IN_BYTES (sizeof(TRANSACTIONMANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define TRANSACTION_OBJECT_NAME_LENGTH_IN_BYTES (sizeof(TRANSACTION_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define ENLISTMENT_OBJECT_NAME_LENGTH_IN_BYTES (sizeof(ENLISTMENT_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define RESOURCE_MANAGER_OBJECT_NAME_LENGTH_IN_BYTES (sizeof(RESOURCE_MANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))

// TODO: warning, duplicated def in tm.h.
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID TransactionKey;
    ULONG TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID EnlistmentId;
    UOW UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;

#define TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED 0x1

typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID UOW;
    GUID TmIdentity;
    ULONG BufferLength;
    // Bufferlength bytes of Buffer follow
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;

#define KTM_MARSHAL_BLOB_VERSION_MAJOR 1
#define KTM_MARSHAL_BLOB_VERSION_MINOR 1

#define MAX_TRANSACTION_DESCRIPTION_LENGTH 64
#define MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH 64

typedef struct _KCRM_MARSHAL_HEADER {
    ULONG VersionMajor;
    ULONG VersionMinor;
    ULONG NumProtocols;
    ULONG Unused; // for alignment purposes
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, * PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW UOW;
    GUID TmIdentity;
    ULONG IsolationLevel;
    ULONG IsolationFlags;
    ULONG Timeout;
    WCHAR Description[64];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, * PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID ProtocolId;
    ULONG StaticInfoLength;
    ULONG TransactionIdInfoLength; //??? ProtocolDynamicInfoLength;
    ULONG Unused1; // for alignment purposes
    ULONG Unused2; // for alignment purposes
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, * PRKCRM_PROTOCOL_BLOB;
# 14297 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h" 2

//
// Types for Nt level TM calls
//

//
// KTM Tm object rights
//
#define TRANSACTIONMANAGER_QUERY_INFORMATION ( 0x0001 )
#define TRANSACTIONMANAGER_SET_INFORMATION ( 0x0002 )
#define TRANSACTIONMANAGER_RECOVER ( 0x0004 )
#define TRANSACTIONMANAGER_RENAME ( 0x0008 )
#define TRANSACTIONMANAGER_CREATE_RM ( 0x0010 )

// The following right is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
#define TRANSACTIONMANAGER_BIND_TRANSACTION ( 0x0020 )

//
// Generic mappings for transaction manager rights.
//

#define TRANSACTIONMANAGER_GENERIC_READ (STANDARD_RIGHTS_READ | TRANSACTIONMANAGER_QUERY_INFORMATION)


#define TRANSACTIONMANAGER_GENERIC_WRITE (STANDARD_RIGHTS_WRITE | TRANSACTIONMANAGER_SET_INFORMATION | TRANSACTIONMANAGER_RECOVER | TRANSACTIONMANAGER_RENAME | TRANSACTIONMANAGER_CREATE_RM)





#define TRANSACTIONMANAGER_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE)

#define TRANSACTIONMANAGER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | TRANSACTIONMANAGER_GENERIC_READ | TRANSACTIONMANAGER_GENERIC_WRITE | TRANSACTIONMANAGER_GENERIC_EXECUTE | TRANSACTIONMANAGER_BIND_TRANSACTION)






//
// KTM transaction object rights.
//
#define TRANSACTION_QUERY_INFORMATION ( 0x0001 )
#define TRANSACTION_SET_INFORMATION ( 0x0002 )
#define TRANSACTION_ENLIST ( 0x0004 )
#define TRANSACTION_COMMIT ( 0x0008 )
#define TRANSACTION_ROLLBACK ( 0x0010 )
#define TRANSACTION_PROPAGATE ( 0x0020 )
#define TRANSACTION_RIGHT_RESERVED1 ( 0x0040 )

//
// Generic mappings for transaction rights.
// Resource managers, when enlisting, should generally use the macro
// TRANSACTION_RESOURCE_MANAGER_RIGHTS when opening a transaction.
// It's the same as generic read and write except that it does not allow
// a commit decision to be made.
//

#define TRANSACTION_GENERIC_READ (STANDARD_RIGHTS_READ | TRANSACTION_QUERY_INFORMATION | SYNCHRONIZE)



#define TRANSACTION_GENERIC_WRITE (STANDARD_RIGHTS_WRITE | TRANSACTION_SET_INFORMATION | TRANSACTION_COMMIT | TRANSACTION_ENLIST | TRANSACTION_ROLLBACK | TRANSACTION_PROPAGATE | SYNCHRONIZE)







#define TRANSACTION_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE | TRANSACTION_COMMIT | TRANSACTION_ROLLBACK | SYNCHRONIZE)




#define TRANSACTION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | TRANSACTION_GENERIC_READ | TRANSACTION_GENERIC_WRITE | TRANSACTION_GENERIC_EXECUTE)




#define TRANSACTION_RESOURCE_MANAGER_RIGHTS (TRANSACTION_GENERIC_READ | STANDARD_RIGHTS_WRITE | TRANSACTION_SET_INFORMATION | TRANSACTION_ENLIST | TRANSACTION_ROLLBACK | TRANSACTION_PROPAGATE | SYNCHRONIZE)







//
// KTM resource manager object rights.
//
#define RESOURCEMANAGER_QUERY_INFORMATION ( 0x0001 )
#define RESOURCEMANAGER_SET_INFORMATION ( 0x0002 )
#define RESOURCEMANAGER_RECOVER ( 0x0004 )
#define RESOURCEMANAGER_ENLIST ( 0x0008 )
#define RESOURCEMANAGER_GET_NOTIFICATION ( 0x0010 )
#define RESOURCEMANAGER_REGISTER_PROTOCOL ( 0x0020 )
#define RESOURCEMANAGER_COMPLETE_PROPAGATION ( 0x0040 )

//
// Generic mappings for resource manager rights.
//
#define RESOURCEMANAGER_GENERIC_READ (STANDARD_RIGHTS_READ | RESOURCEMANAGER_QUERY_INFORMATION | SYNCHRONIZE)



#define RESOURCEMANAGER_GENERIC_WRITE (STANDARD_RIGHTS_WRITE | RESOURCEMANAGER_SET_INFORMATION | RESOURCEMANAGER_RECOVER | RESOURCEMANAGER_ENLIST | RESOURCEMANAGER_GET_NOTIFICATION | RESOURCEMANAGER_REGISTER_PROTOCOL | RESOURCEMANAGER_COMPLETE_PROPAGATION | SYNCHRONIZE)
# 14413 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define RESOURCEMANAGER_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE | RESOURCEMANAGER_RECOVER | RESOURCEMANAGER_ENLIST | RESOURCEMANAGER_GET_NOTIFICATION | RESOURCEMANAGER_COMPLETE_PROPAGATION | SYNCHRONIZE)






#define RESOURCEMANAGER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | RESOURCEMANAGER_GENERIC_READ | RESOURCEMANAGER_GENERIC_WRITE | RESOURCEMANAGER_GENERIC_EXECUTE)





//
// KTM enlistment object rights.
//
#define ENLISTMENT_QUERY_INFORMATION ( 0x0001 )
#define ENLISTMENT_SET_INFORMATION ( 0x0002 )
#define ENLISTMENT_RECOVER ( 0x0004 )
#define ENLISTMENT_SUBORDINATE_RIGHTS ( 0x0008 )
#define ENLISTMENT_SUPERIOR_RIGHTS ( 0x0010 )

//
// Generic mappings for enlistment rights.
//
#define ENLISTMENT_GENERIC_READ (STANDARD_RIGHTS_READ | ENLISTMENT_QUERY_INFORMATION)


#define ENLISTMENT_GENERIC_WRITE (STANDARD_RIGHTS_WRITE | ENLISTMENT_SET_INFORMATION | ENLISTMENT_RECOVER | ENLISTMENT_SUBORDINATE_RIGHTS | ENLISTMENT_SUPERIOR_RIGHTS)





#define ENLISTMENT_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE | ENLISTMENT_RECOVER | ENLISTMENT_SUBORDINATE_RIGHTS | ENLISTMENT_SUPERIOR_RIGHTS)




#define ENLISTMENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | ENLISTMENT_GENERIC_READ | ENLISTMENT_GENERIC_WRITE | ENLISTMENT_GENERIC_EXECUTE)





//
// Transaction outcomes.
//
// TODO: warning, must match values in KTRANSACTION_OUTCOME duplicated def 
// in tm.h.
//

typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID TransactionId;
    DWORD State;
    DWORD Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
    WCHAR LogPath[1]; // Variable size
//  Data[1];                                        // Variable size data not declared
} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;


// end_wdm
typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;
// begin_wdm


typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD IsolationLevel;
    DWORD IsolationFlags;
    LARGE_INTEGER Timeout;
    DWORD Outcome;
    DWORD DescriptionLength;
    WCHAR Description[1]; // Variable size
//          Data[1];            // Variable size data not declared
} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;

// The following info-class is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID EnlistmentId;
    GUID ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1]; // Variable size
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID ResourceManagerId;
    DWORD DescriptionLength;
    WCHAR Description[1]; // Variable size
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;

// end_wdm

// begin_wdm
typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation
// end_wdm
    ,
// The following info-classes are intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
    TransactionBindInformation, // private and deprecated
    TransactionDTCPrivateInformation // private and deprecated
    ,
// begin_wdm
} TRANSACTION_INFORMATION_CLASS;

// begin_wdm
typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4
// end_wdm
    ,
// The following info-classes are intended for internal use only; they
// are considered deprecated, and no one else should take a dependency
// on them.
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5
// end_wdm

// begin_wdm
} TRANSACTIONMANAGER_INFORMATION_CLASS;


// begin_wdm
typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;


// begin_wdm
typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1]; // Var size
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;


//
// Types of objects known to the kernel transaction manager.
//

typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;


//
// KTMOBJECT_CURSOR
//
// Used by NtEnumerateTransactionObject to enumerate a transaction
// object namespace (e.g. enlistments in a resource manager).
//

typedef struct _KTMOBJECT_CURSOR {

    //
    // The last GUID enumerated; zero if beginning enumeration.
    // 

    GUID LastQuery;

    //
    // A count of GUIDs filled in by this last enumeration.
    // 

    DWORD ObjectIdCount;

    //
    // ObjectIdCount GUIDs from the namespace specified.
    // 

    GUID ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;

// begin_wdm






typedef DWORD TP_VERSION, *PTP_VERSION;

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef void ( *PTP_SIMPLE_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context
    );

typedef struct _TP_POOL TP_POOL, *PTP_POOL;

typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;

typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;

typedef void ( *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
    PVOID ObjectContext,
    PVOID CleanupContext
    );

//
// Do not manipulate this structure directly!  Allocate space for it
// and use the inline interfaces below.
//



typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION Version;
    PTP_POOL Pool;
    PTP_CLEANUP_GROUP CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
    PVOID RaceDll;
    struct _ACTIVATION_CONTEXT *ActivationContext;
    PTP_SIMPLE_CALLBACK FinalizationCallback;
    union {
        DWORD Flags;
        struct {
            DWORD LongFunction : 1;
            DWORD Persistent : 1;
            DWORD Private : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY CallbackPriority;
    DWORD Size;
} TP_CALLBACK_ENVIRON_V3;

typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;
# 14764 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
__inline
void
TpInitializeCallbackEnviron(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{



    CallbackEnviron->Version = 3;







    CallbackEnviron->Pool = ((void *)0);
    CallbackEnviron->CleanupGroup = ((void *)0);
    CallbackEnviron->CleanupGroupCancelCallback = ((void *)0);
    CallbackEnviron->RaceDll = ((void *)0);
    CallbackEnviron->ActivationContext = ((void *)0);
    CallbackEnviron->FinalizationCallback = ((void *)0);
    CallbackEnviron->u.Flags = 0;



    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);



}

__inline
void
TpSetCallbackThreadpool(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_POOL Pool
    )
{
    CallbackEnviron->Pool = Pool;
}

__inline
void
TpSetCallbackCleanupGroup(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_CLEANUP_GROUP CleanupGroup,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}

__inline
void
TpSetCallbackActivationContext(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}

__inline
void
TpSetCallbackNoActivationContext(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1; // INVALID_ACTIVATION_CONTEXT
}

__inline
void
TpSetCallbackLongFunction(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}

__inline
void
TpSetCallbackRaceWithDll(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PVOID DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}

__inline
void
TpSetCallbackFinalizationCallback(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    PTP_SIMPLE_CALLBACK FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}



__inline
void
TpSetCallbackPriority(
    PTP_CALLBACK_ENVIRON CallbackEnviron,
    TP_CALLBACK_PRIORITY Priority
    )
{
    CallbackEnviron->CallbackPriority = Priority;
}



__inline
void
TpSetCallbackPersistent(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}


__inline
void
TpDestroyCallbackEnviron(
    PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    //
    // For the current version of the callback environment, no actions
    // need to be taken to tear down an initialized structure.  This
    // may change in a future release.
    //

    (CallbackEnviron);
}




typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef void ( *PTP_WORK_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_WORK Work
    );

typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

typedef void ( *PTP_TIMER_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_TIMER Timer
    );

typedef DWORD TP_WAIT_RESULT;

typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

typedef void ( *PTP_WAIT_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PTP_WAIT Wait,
    TP_WAIT_RESULT WaitResult
    );

typedef struct _TP_IO TP_IO, *PTP_IO;
# 15005 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#define ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION (1)
#define ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION (2)
#define ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION (3)
#define ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION (4)
#define ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION (5)
#define ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION (6)
#define ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION (7)
#define ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE (8)
#define ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES (9)
#define ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS (10)
#define ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO (11)
# 15025 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnt.h"
#pragma warning(default:4201)
#pragma warning(default:4214)
# 178 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h" 2




/* Types use for passing & returning polymorphic values */
typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;




#define max(a,b) (((a) > (b)) ? (a) : (b))



#define min(a,b) (((a) < (b)) ? (a) : (b))




#define MAKEWORD(a,b) ((WORD)(((BYTE)(((DWORD_PTR)(a)) & 0xff)) | ((WORD)((BYTE)(((DWORD_PTR)(b)) & 0xff))) << 8))
#define MAKELONG(a,b) ((LONG)(((WORD)(((DWORD_PTR)(a)) & 0xffff)) | ((DWORD)((WORD)(((DWORD_PTR)(b)) & 0xffff))) << 16))
#define LOWORD(l) ((WORD)(((DWORD_PTR)(l)) & 0xffff))
#define HIWORD(l) ((WORD)((((DWORD_PTR)(l)) >> 16) & 0xffff))
#define LOBYTE(w) ((BYTE)(((DWORD_PTR)(w)) & 0xff))
#define HIBYTE(w) ((BYTE)((((DWORD_PTR)(w)) >> 8) & 0xff))



struct HWND__{int unused;}; typedef struct HWND__ *HWND;
struct HHOOK__{int unused;}; typedef struct HHOOK__ *HHOOK;





typedef WORD ATOM;

typedef HANDLE *SPHANDLE;
typedef HANDLE *LPHANDLE;
typedef HANDLE HGLOBAL;
typedef HANDLE HLOCAL;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;



typedef INT_PTR ( *FARPROC)();
typedef INT_PTR ( *NEARPROC)();
typedef INT_PTR ( *PROC)();
# 247 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windef.h"
typedef void * HGDIOBJ;





struct HKEY__{int unused;}; typedef struct HKEY__ *HKEY;
typedef HKEY *PHKEY;


struct HACCEL__{int unused;}; typedef struct HACCEL__ *HACCEL;


struct HBITMAP__{int unused;}; typedef struct HBITMAP__ *HBITMAP;
struct HBRUSH__{int unused;}; typedef struct HBRUSH__ *HBRUSH;


struct HCOLORSPACE__{int unused;}; typedef struct HCOLORSPACE__ *HCOLORSPACE;


struct HDC__{int unused;}; typedef struct HDC__ *HDC;

struct HGLRC__{int unused;}; typedef struct HGLRC__ *HGLRC; // OpenGL
struct HDESK__{int unused;}; typedef struct HDESK__ *HDESK;
struct HENHMETAFILE__{int unused;}; typedef struct HENHMETAFILE__ *HENHMETAFILE;

struct HFONT__{int unused;}; typedef struct HFONT__ *HFONT;

struct HICON__{int unused;}; typedef struct HICON__ *HICON;

struct HMENU__{int unused;}; typedef struct HMENU__ *HMENU;

struct HMETAFILE__{int unused;}; typedef struct HMETAFILE__ *HMETAFILE;
struct HINSTANCE__{int unused;}; typedef struct HINSTANCE__ *HINSTANCE;
typedef HINSTANCE HMODULE; /* HMODULEs can be used in place of HINSTANCEs */

struct HPALETTE__{int unused;}; typedef struct HPALETTE__ *HPALETTE;
struct HPEN__{int unused;}; typedef struct HPEN__ *HPEN;

struct HRGN__{int unused;}; typedef struct HRGN__ *HRGN;
struct HRSRC__{int unused;}; typedef struct HRSRC__ *HRSRC;
struct HSPRITE__{int unused;}; typedef struct HSPRITE__ *HSPRITE;
struct HLSURF__{int unused;}; typedef struct HLSURF__ *HLSURF;
struct HSTR__{int unused;}; typedef struct HSTR__ *HSTR;
struct HTASK__{int unused;}; typedef struct HTASK__ *HTASK;
struct HWINSTA__{int unused;}; typedef struct HWINSTA__ *HWINSTA;
struct HKL__{int unused;}; typedef struct HKL__ *HKL;


struct HWINEVENTHOOK__{int unused;}; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK;




struct HMONITOR__{int unused;}; typedef struct HMONITOR__ *HMONITOR;

struct HUMPD__{int unused;}; typedef struct HUMPD__ *HUMPD;



typedef int HFILE;
typedef HICON HCURSOR; /* HICONs & HCURSORs are polymorphic */





typedef DWORD COLORREF;
typedef DWORD *LPCOLORREF;

#define HFILE_ERROR ((HFILE)-1)

typedef struct tagRECT
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT, *PRECT, *NPRECT, *LPRECT;

typedef const RECT * LPCRECT;

typedef struct _RECTL /* rcl */
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL * LPCRECTL;

typedef struct tagPOINT
{
    LONG x;
    LONG y;
} POINT, *PPOINT, *NPPOINT, *LPPOINT;

typedef struct _POINTL /* ptl  */
{
    LONG x;
    LONG y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG cx;
    LONG cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE SIZEL;
typedef SIZE *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{

    SHORT x;
    SHORT y;




} POINTS, *PPOINTS, *LPPOINTS;

//
//  File System time stamps are represented with the following structure:
//

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;
#define _FILETIME_ 


/* mode selections for the device mode function */
#define DM_UPDATE 1
#define DM_COPY 2
#define DM_PROMPT 4
#define DM_MODIFY 8

#define DM_IN_BUFFER DM_MODIFY
#define DM_IN_PROMPT DM_PROMPT
#define DM_OUT_BUFFER DM_COPY
#define DM_OUT_DEFAULT DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS 1
#define DC_PAPERS 2
#define DC_PAPERSIZE 3
#define DC_MINEXTENT 4
#define DC_MAXEXTENT 5
#define DC_BINS 6
#define DC_DUPLEX 7
#define DC_SIZE 8
#define DC_EXTRA 9
#define DC_VERSION 10
#define DC_DRIVER 11
#define DC_BINNAMES 12
#define DC_ENUMRESOLUTIONS 13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE 15
#define DC_PAPERNAMES 16
#define DC_ORIENTATION 17
#define DC_COPIES 18
# 156 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h" 1
/************************************************************************

*                                                                       *

*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *

*                                                                       *

*   Copyright (c) Microsoft Corp. All rights reserved.                  *

*                                                                       *

************************************************************************/
# 9 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#define _WINBASE_ 
# 20 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
//
// Define API decoration for direct importing of DLL references.
//


#define WINADVAPI DECLSPEC_IMPORT





#define WINBASEAPI DECLSPEC_IMPORT





#define ZAWPROXYAPI DECLSPEC_IMPORT
# 46 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
/*

 * Compatibility macros

 */
# 50 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#define DefineHandleTable(w) ((w),TRUE)
#define LimitEmsPages(dw) 
#define SetSwapAreaSize(w) (w)
#define LockSegment(w) GlobalFix((HANDLE)(w))
#define UnlockSegment(w) GlobalUnfix((HANDLE)(w))
#define GetCurrentTime() GetTickCount()

#define Yield() 

#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)

#define FILE_BEGIN 0
#define FILE_CURRENT 1
#define FILE_END 2

#define TIME_ZONE_ID_INVALID ((DWORD)0xFFFFFFFF)

#define WAIT_FAILED ((DWORD)0xFFFFFFFF)
#define WAIT_OBJECT_0 ((STATUS_WAIT_0 ) + 0 )

#define WAIT_ABANDONED ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_ABANDONED_0 ((STATUS_ABANDONED_WAIT_0 ) + 0 )

#define WAIT_IO_COMPLETION STATUS_USER_APC
#define STILL_ACTIVE STATUS_PENDING
#define EXCEPTION_ACCESS_VIOLATION STATUS_ACCESS_VIOLATION
#define EXCEPTION_DATATYPE_MISALIGNMENT STATUS_DATATYPE_MISALIGNMENT
#define EXCEPTION_BREAKPOINT STATUS_BREAKPOINT
#define EXCEPTION_SINGLE_STEP STATUS_SINGLE_STEP
#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED STATUS_ARRAY_BOUNDS_EXCEEDED
#define EXCEPTION_FLT_DENORMAL_OPERAND STATUS_FLOAT_DENORMAL_OPERAND
#define EXCEPTION_FLT_DIVIDE_BY_ZERO STATUS_FLOAT_DIVIDE_BY_ZERO
#define EXCEPTION_FLT_INEXACT_RESULT STATUS_FLOAT_INEXACT_RESULT
#define EXCEPTION_FLT_INVALID_OPERATION STATUS_FLOAT_INVALID_OPERATION
#define EXCEPTION_FLT_OVERFLOW STATUS_FLOAT_OVERFLOW
#define EXCEPTION_FLT_STACK_CHECK STATUS_FLOAT_STACK_CHECK
#define EXCEPTION_FLT_UNDERFLOW STATUS_FLOAT_UNDERFLOW
#define EXCEPTION_INT_DIVIDE_BY_ZERO STATUS_INTEGER_DIVIDE_BY_ZERO
#define EXCEPTION_INT_OVERFLOW STATUS_INTEGER_OVERFLOW
#define EXCEPTION_PRIV_INSTRUCTION STATUS_PRIVILEGED_INSTRUCTION
#define EXCEPTION_IN_PAGE_ERROR STATUS_IN_PAGE_ERROR
#define EXCEPTION_ILLEGAL_INSTRUCTION STATUS_ILLEGAL_INSTRUCTION
#define EXCEPTION_NONCONTINUABLE_EXCEPTION STATUS_NONCONTINUABLE_EXCEPTION
#define EXCEPTION_STACK_OVERFLOW STATUS_STACK_OVERFLOW
#define EXCEPTION_INVALID_DISPOSITION STATUS_INVALID_DISPOSITION
#define EXCEPTION_GUARD_PAGE STATUS_GUARD_PAGE_VIOLATION
#define EXCEPTION_INVALID_HANDLE STATUS_INVALID_HANDLE
#define EXCEPTION_POSSIBLE_DEADLOCK STATUS_POSSIBLE_DEADLOCK
#define CONTROL_C_EXIT STATUS_CONTROL_C_EXIT

#define MoveMemory RtlMoveMemory
#define CopyMemory RtlCopyMemory
#define FillMemory RtlFillMemory
#define ZeroMemory RtlZeroMemory
#define SecureZeroMemory RtlSecureZeroMemory
#define CaptureStackBackTrace RtlCaptureStackBackTrace

//
// File creation flags must start at the high end since they
// are combined with the attributes
//

#define FILE_FLAG_WRITE_THROUGH 0x80000000
#define FILE_FLAG_OVERLAPPED 0x40000000
#define FILE_FLAG_NO_BUFFERING 0x20000000
#define FILE_FLAG_RANDOM_ACCESS 0x10000000
#define FILE_FLAG_SEQUENTIAL_SCAN 0x08000000
#define FILE_FLAG_DELETE_ON_CLOSE 0x04000000
#define FILE_FLAG_BACKUP_SEMANTICS 0x02000000
#define FILE_FLAG_POSIX_SEMANTICS 0x01000000
#define FILE_FLAG_OPEN_REPARSE_POINT 0x00200000
#define FILE_FLAG_OPEN_NO_RECALL 0x00100000
#define FILE_FLAG_FIRST_PIPE_INSTANCE 0x00080000

#define CREATE_NEW 1
#define CREATE_ALWAYS 2
#define OPEN_EXISTING 3
#define OPEN_ALWAYS 4
#define TRUNCATE_EXISTING 5


//
// Define possible return codes from the CopyFileEx callback routine
//

#define PROGRESS_CONTINUE 0
#define PROGRESS_CANCEL 1
#define PROGRESS_STOP 2
#define PROGRESS_QUIET 3

//
// Define CopyFileEx callback routine state change values
//

#define CALLBACK_CHUNK_FINISHED 0x00000000
#define CALLBACK_STREAM_SWITCH 0x00000001

//
// Define CopyFileEx option flags
//

#define COPY_FILE_FAIL_IF_EXISTS 0x00000001
#define COPY_FILE_RESTARTABLE 0x00000002
#define COPY_FILE_OPEN_SOURCE_FOR_WRITE 0x00000004
#define COPY_FILE_ALLOW_DECRYPTED_DESTINATION 0x00000008

//
//  Gap for private copyfile flags
//


#define COPY_FILE_COPY_SYMLINK 0x00000800
#define COPY_FILE_NO_BUFFERING 0x00001000




//
// Define ReplaceFile option flags
//

#define REPLACEFILE_WRITE_THROUGH 0x00000001
#define REPLACEFILE_IGNORE_MERGE_ERRORS 0x00000002


#define REPLACEFILE_IGNORE_ACL_ERRORS 0x00000004




//
// Define the NamedPipe definitions
//


//
// Define the dwOpenMode values for CreateNamedPipe
//

#define PIPE_ACCESS_INBOUND 0x00000001
#define PIPE_ACCESS_OUTBOUND 0x00000002
#define PIPE_ACCESS_DUPLEX 0x00000003

//
// Define the Named Pipe End flags for GetNamedPipeInfo
//

#define PIPE_CLIENT_END 0x00000000
#define PIPE_SERVER_END 0x00000001

//
// Define the dwPipeMode values for CreateNamedPipe
//

#define PIPE_WAIT 0x00000000
#define PIPE_NOWAIT 0x00000001
#define PIPE_READMODE_BYTE 0x00000000
#define PIPE_READMODE_MESSAGE 0x00000002
#define PIPE_TYPE_BYTE 0x00000000
#define PIPE_TYPE_MESSAGE 0x00000004
#define PIPE_ACCEPT_REMOTE_CLIENTS 0x00000000
#define PIPE_REJECT_REMOTE_CLIENTS 0x00000008

//
// Define the well known values for CreateNamedPipe nMaxInstances
//

#define PIPE_UNLIMITED_INSTANCES 255

//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//

#define SECURITY_ANONYMOUS ( SecurityAnonymous << 16 )
#define SECURITY_IDENTIFICATION ( SecurityIdentification << 16 )
#define SECURITY_IMPERSONATION ( SecurityImpersonation << 16 )
#define SECURITY_DELEGATION ( SecurityDelegation << 16 )

#define SECURITY_CONTEXT_TRACKING 0x00040000
#define SECURITY_EFFECTIVE_ONLY 0x00080000

#define SECURITY_SQOS_PRESENT 0x00100000
#define SECURITY_VALID_SQOS_FLAGS 0x001F0000

//
//  File structures
//

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } s;
        PVOID Pointer;
    } u;

    HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

//
//  File System time stamps are represented with the following structure:
//
# 289 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
//
// System time is represented with the following structure:
//


typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef DWORD ( *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;


typedef void ( *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;


typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;



//
// Define one-time initialization primitive
//

typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;

#define INIT_ONCE_STATIC_INIT RTL_RUN_ONCE_INIT

//
// Run once flags
//

#define INIT_ONCE_CHECK_ONLY RTL_RUN_ONCE_CHECK_ONLY
#define INIT_ONCE_ASYNC RTL_RUN_ONCE_ASYNC
#define INIT_ONCE_INIT_FAILED RTL_RUN_ONCE_INIT_FAILED

//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//

#define INIT_ONCE_CTX_RESERVED_BITS RTL_RUN_ONCE_CTX_RESERVED_BITS

//
// FailFast Exception Flags
//

#define FAIL_FAST_GENERATE_EXCEPTION_ADDRESS 0x1
#define FAIL_FAST_NO_HARD_ERROR_DLG 0x2

typedef
BOOL
( *PINIT_ONCE_FN) (
    PINIT_ONCE InitOnce,
    PVOID Parameter,
    PVOID *Context
    );


void

InitOnceInitialize (
    PINIT_ONCE InitOnce
    );


BOOL

InitOnceExecuteOnce (
    PINIT_ONCE InitOnce,
    PINIT_ONCE_FN InitFn,
    PVOID Parameter,
    LPVOID *Context
    );


BOOL

InitOnceBeginInitialize (
    LPINIT_ONCE lpInitOnce,
    DWORD dwFlags,
    PBOOL fPending,
    LPVOID *lpContext
    );


BOOL

InitOnceComplete (
    LPINIT_ONCE lpInitOnce,
    DWORD dwFlags,
    LPVOID lpContext
    );



//
// Define the slim r/w lock
//

typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#define SRWLOCK_INIT RTL_SRWLOCK_INIT


void

InitializeSRWLock (
     PSRWLOCK SRWLock
     );


void

ReleaseSRWLockExclusive (
     PSRWLOCK SRWLock
     );


void

ReleaseSRWLockShared (
     PSRWLOCK SRWLock
     );


void

AcquireSRWLockExclusive (
     PSRWLOCK SRWLock
     );


void

AcquireSRWLockShared (
     PSRWLOCK SRWLock
     );


BOOLEAN

TryAcquireSRWLockExclusive (
    PSRWLOCK SRWLock
    );


BOOLEAN

TryAcquireSRWLockShared (
    PSRWLOCK SRWLock
    );

//
// Define condition variable
//

typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;


void

InitializeConditionVariable (
    PCONDITION_VARIABLE ConditionVariable
    );


void

WakeConditionVariable (
    PCONDITION_VARIABLE ConditionVariable
    );


void

WakeAllConditionVariable (
    PCONDITION_VARIABLE ConditionVariable
    );


BOOL

SleepConditionVariableCS (
    PCONDITION_VARIABLE ConditionVariable,
    PCRITICAL_SECTION CriticalSection,
    DWORD dwMilliseconds
    );


BOOL

SleepConditionVariableSRW (
    PCONDITION_VARIABLE ConditionVariable,
    PSRWLOCK SRWLock,
    DWORD dwMilliseconds,
    ULONG Flags
    );

//
// Static initializer for the condition variable
//

#define CONDITION_VARIABLE_INIT RTL_CONDITION_VARIABLE_INIT

//
// Flags for condition variables
//
#define CONDITION_VARIABLE_LOCKMODE_SHARED RTL_CONDITION_VARIABLE_LOCKMODE_SHARED




PVOID

EncodePointer (
    PVOID Ptr
    );



PVOID

DecodePointer (
    PVOID Ptr
    );



PVOID

EncodeSystemPointer (
    PVOID Ptr
    );



PVOID

DecodeSystemPointer (
    PVOID Ptr
    );




typedef LPVOID LPLDT_ENTRY;


#define MUTEX_MODIFY_STATE MUTANT_QUERY_STATE
#define MUTEX_ALL_ACCESS MUTANT_ALL_ACCESS

//
// Serial provider type.
//

#define SP_SERIALCOMM ((DWORD)0x00000001)

//
// Provider SubTypes
//

#define PST_UNSPECIFIED ((DWORD)0x00000000)
#define PST_RS232 ((DWORD)0x00000001)
#define PST_PARALLELPORT ((DWORD)0x00000002)
#define PST_RS422 ((DWORD)0x00000003)
#define PST_RS423 ((DWORD)0x00000004)
#define PST_RS449 ((DWORD)0x00000005)
#define PST_MODEM ((DWORD)0x00000006)
#define PST_FAX ((DWORD)0x00000021)
#define PST_SCANNER ((DWORD)0x00000022)
#define PST_NETWORK_BRIDGE ((DWORD)0x00000100)
#define PST_LAT ((DWORD)0x00000101)
#define PST_TCPIP_TELNET ((DWORD)0x00000102)
#define PST_X25 ((DWORD)0x00000103)


//
// Provider capabilities flags.
//

#define PCF_DTRDSR ((DWORD)0x0001)
#define PCF_RTSCTS ((DWORD)0x0002)
#define PCF_RLSD ((DWORD)0x0004)
#define PCF_PARITY_CHECK ((DWORD)0x0008)
#define PCF_XONXOFF ((DWORD)0x0010)
#define PCF_SETXCHAR ((DWORD)0x0020)
#define PCF_TOTALTIMEOUTS ((DWORD)0x0040)
#define PCF_INTTIMEOUTS ((DWORD)0x0080)
#define PCF_SPECIALCHARS ((DWORD)0x0100)
#define PCF_16BITMODE ((DWORD)0x0200)

//
// Comm provider settable parameters.
//

#define SP_PARITY ((DWORD)0x0001)
#define SP_BAUD ((DWORD)0x0002)
#define SP_DATABITS ((DWORD)0x0004)
#define SP_STOPBITS ((DWORD)0x0008)
#define SP_HANDSHAKING ((DWORD)0x0010)
#define SP_PARITY_CHECK ((DWORD)0x0020)
#define SP_RLSD ((DWORD)0x0040)

//
// Settable baud rates in the provider.
//

#define BAUD_075 ((DWORD)0x00000001)
#define BAUD_110 ((DWORD)0x00000002)
#define BAUD_134_5 ((DWORD)0x00000004)
#define BAUD_150 ((DWORD)0x00000008)
#define BAUD_300 ((DWORD)0x00000010)
#define BAUD_600 ((DWORD)0x00000020)
#define BAUD_1200 ((DWORD)0x00000040)
#define BAUD_1800 ((DWORD)0x00000080)
#define BAUD_2400 ((DWORD)0x00000100)
#define BAUD_4800 ((DWORD)0x00000200)
#define BAUD_7200 ((DWORD)0x00000400)
#define BAUD_9600 ((DWORD)0x00000800)
#define BAUD_14400 ((DWORD)0x00001000)
#define BAUD_19200 ((DWORD)0x00002000)
#define BAUD_38400 ((DWORD)0x00004000)
#define BAUD_56K ((DWORD)0x00008000)
#define BAUD_128K ((DWORD)0x00010000)
#define BAUD_115200 ((DWORD)0x00020000)
#define BAUD_57600 ((DWORD)0x00040000)
#define BAUD_USER ((DWORD)0x10000000)

//
// Settable Data Bits
//

#define DATABITS_5 ((WORD)0x0001)
#define DATABITS_6 ((WORD)0x0002)
#define DATABITS_7 ((WORD)0x0004)
#define DATABITS_8 ((WORD)0x0008)
#define DATABITS_16 ((WORD)0x0010)
#define DATABITS_16X ((WORD)0x0020)

//
// Settable Stop and Parity bits.
//

#define STOPBITS_10 ((WORD)0x0001)
#define STOPBITS_15 ((WORD)0x0002)
#define STOPBITS_20 ((WORD)0x0004)
#define PARITY_NONE ((WORD)0x0100)
#define PARITY_ODD ((WORD)0x0200)
#define PARITY_EVEN ((WORD)0x0400)
#define PARITY_MARK ((WORD)0x0800)
#define PARITY_SPACE ((WORD)0x1000)

typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;

//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//
#define COMMPROP_INITIALIZED ((DWORD)0xE73CF52E)

typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;

//
// DTR Control Flow Values.
//
#define DTR_CONTROL_DISABLE 0x00
#define DTR_CONTROL_ENABLE 0x01
#define DTR_CONTROL_HANDSHAKE 0x02

//
// RTS Control Flow Values
//
#define RTS_CONTROL_DISABLE 0x00
#define RTS_CONTROL_ENABLE 0x01
#define RTS_CONTROL_HANDSHAKE 0x02
#define RTS_CONTROL_TOGGLE 0x03

typedef struct _DCB {
    DWORD DCBlength; /* sizeof(DCB)                     */
    DWORD BaudRate; /* Baudrate at which running       */
    DWORD fBinary: 1; /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1; /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2; /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1; /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1; /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1; /* Enable Err Replacement          */
    DWORD fNull: 1; /* Enable Null stripping           */
    DWORD fRtsControl:2; /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17; /* Reserved                        */
    WORD wReserved; /* Not currently used              */
    WORD XonLim; /* Transmit X-ON threshold         */
    WORD XoffLim; /* Transmit X-OFF threshold        */
    BYTE ByteSize; /* Number of bits/byte, 4-8        */
    BYTE Parity; /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits; /* 0,1,2 = 1, 1.5, 2               */
    char XonChar; /* Tx and Rx X-ON character        */
    char XoffChar; /* Tx and Rx X-OFF character       */
    char ErrorChar; /* Error replacement char          */
    char EofChar; /* End of Input character          */
    char EvtChar; /* Received Event character        */
    WORD wReserved1; /* Fill for now.                   */
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout; /* Maximum time between read chars. */
    DWORD ReadTotalTimeoutMultiplier; /* Multiplier of characters.        */
    DWORD ReadTotalTimeoutConstant; /* Constant in milliseconds.        */
    DWORD WriteTotalTimeoutMultiplier; /* Multiplier of characters.        */
    DWORD WriteTotalTimeoutConstant; /* Constant in milliseconds.        */
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize; /* Size of the entire struct */
    WORD wVersion; /* version of the structure */
    WORD wReserved; /* alignment */
    DCB dcb; /* device control block */
    DWORD dwProviderSubType; /* ordinal value for identifying

                                   provider-defined data structure format*/
# 764 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
    DWORD dwProviderOffset; /* Specifies the offset of provider specific

                                   data field in bytes from the start */
# 766 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
    DWORD dwProviderSize; /* size of the provider-specific data field */
    WCHAR wcProviderData[1]; /* provider-specific data */
} COMMCONFIG,*LPCOMMCONFIG;

typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId; // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } s;
    } u;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

//
//


#define FreeModule(hLibModule) FreeLibrary((hLibModule))
#define MakeProcInstance(lpProc,hInstance) (lpProc)
#define FreeProcInstance(lpProc) (lpProc)

/* Global Memory Flags */
#define GMEM_FIXED 0x0000
#define GMEM_MOVEABLE 0x0002
#define GMEM_NOCOMPACT 0x0010
#define GMEM_NODISCARD 0x0020
#define GMEM_ZEROINIT 0x0040
#define GMEM_MODIFY 0x0080
#define GMEM_DISCARDABLE 0x0100
#define GMEM_NOT_BANKED 0x1000
#define GMEM_SHARE 0x2000
#define GMEM_DDESHARE 0x2000
#define GMEM_NOTIFY 0x4000
#define GMEM_LOWER GMEM_NOT_BANKED
#define GMEM_VALID_FLAGS 0x7F72
#define GMEM_INVALID_HANDLE 0x8000

#define GHND (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalLRUNewest(h) ((HANDLE)(h))
#define GlobalLRUOldest(h) ((HANDLE)(h))
#define GlobalDiscard(h) GlobalReAlloc( (h), 0, GMEM_MOVEABLE )

/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED 0x4000
#define GMEM_LOCKCOUNT 0x00FF

typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;

/* Local Memory Flags */
#define LMEM_FIXED 0x0000
#define LMEM_MOVEABLE 0x0002
#define LMEM_NOCOMPACT 0x0010
#define LMEM_NODISCARD 0x0020
#define LMEM_ZEROINIT 0x0040
#define LMEM_MODIFY 0x0080
#define LMEM_DISCARDABLE 0x0F00
#define LMEM_VALID_FLAGS 0x0F72
#define LMEM_INVALID_HANDLE 0x8000

#define LHND (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND (LMEM_MOVEABLE)
#define NONZEROLPTR (LMEM_FIXED)

#define LocalDiscard(h) LocalReAlloc( (h), 0, LMEM_MOVEABLE )

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED 0x4000
#define LMEM_LOCKCOUNT 0x00FF

//
// NUMA values
//
#define NUMA_NO_PREFERRED_NODE ((DWORD) -1)

//
// Process dwCreationFlag values
//

#define DEBUG_PROCESS 0x00000001
#define DEBUG_ONLY_THIS_PROCESS 0x00000002
#define CREATE_SUSPENDED 0x00000004
#define DETACHED_PROCESS 0x00000008

#define CREATE_NEW_CONSOLE 0x00000010
#define NORMAL_PRIORITY_CLASS 0x00000020
#define IDLE_PRIORITY_CLASS 0x00000040
#define HIGH_PRIORITY_CLASS 0x00000080

#define REALTIME_PRIORITY_CLASS 0x00000100
#define CREATE_NEW_PROCESS_GROUP 0x00000200
#define CREATE_UNICODE_ENVIRONMENT 0x00000400
#define CREATE_SEPARATE_WOW_VDM 0x00000800

#define CREATE_SHARED_WOW_VDM 0x00001000
#define CREATE_FORCEDOS 0x00002000
#define BELOW_NORMAL_PRIORITY_CLASS 0x00004000
#define ABOVE_NORMAL_PRIORITY_CLASS 0x00008000

#define INHERIT_PARENT_AFFINITY 0x00010000
#define INHERIT_CALLER_PRIORITY 0x00020000
#define CREATE_PROTECTED_PROCESS 0x00040000
#define EXTENDED_STARTUPINFO_PRESENT 0x00080000

#define PROCESS_MODE_BACKGROUND_BEGIN 0x00100000
#define PROCESS_MODE_BACKGROUND_END 0x00200000

#define CREATE_BREAKAWAY_FROM_JOB 0x01000000
#define CREATE_PRESERVE_CODE_AUTHZ_LEVEL 0x02000000
#define CREATE_DEFAULT_ERROR_MODE 0x04000000
#define CREATE_NO_WINDOW 0x08000000

#define PROFILE_USER 0x10000000
#define PROFILE_KERNEL 0x20000000
#define PROFILE_SERVER 0x40000000
#define CREATE_IGNORE_SYSTEM_DEFAULT 0x80000000

//
// Thread dwCreationFlag values
//

//#define CREATE_SUSPENDED                  0x00000004

#define STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000

//
// Priority flags
//

#define THREAD_PRIORITY_LOWEST THREAD_BASE_PRIORITY_MIN
#define THREAD_PRIORITY_BELOW_NORMAL (THREAD_PRIORITY_LOWEST+1)
#define THREAD_PRIORITY_NORMAL 0
#define THREAD_PRIORITY_HIGHEST THREAD_BASE_PRIORITY_MAX
#define THREAD_PRIORITY_ABOVE_NORMAL (THREAD_PRIORITY_HIGHEST-1)
#define THREAD_PRIORITY_ERROR_RETURN (MAXLONG)

#define THREAD_PRIORITY_TIME_CRITICAL THREAD_BASE_PRIORITY_LOWRT
#define THREAD_PRIORITY_IDLE THREAD_BASE_PRIORITY_IDLE

#define THREAD_MODE_BACKGROUND_BEGIN 0x00010000
#define THREAD_MODE_BACKGROUND_END 0x00020000

//
// GetFinalPathNameByHandle
//

#define VOLUME_NAME_DOS 0x0
#define VOLUME_NAME_GUID 0x1
#define VOLUME_NAME_NT 0x2
#define VOLUME_NAME_NONE 0x4

#define FILE_NAME_NORMALIZED 0x0
#define FILE_NAME_OPENED 0x8

//
// Debug APIs
//
#define EXCEPTION_DEBUG_EVENT 1
#define CREATE_THREAD_DEBUG_EVENT 2
#define CREATE_PROCESS_DEBUG_EVENT 3
#define EXIT_THREAD_DEBUG_EVENT 4
#define EXIT_PROCESS_DEBUG_EVENT 5
#define LOAD_DLL_DEBUG_EVENT 6
#define UNLOAD_DLL_DEBUG_EVENT 7
#define OUTPUT_DEBUG_STRING_EVENT 8
#define RIP_EVENT 9

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;

//
// JIT Debugging Info. This structure is defined to have constant size in
// both the emulated and native environment.
//

typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;


typedef PCONTEXT LPCONTEXT;
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;


#define DRIVE_UNKNOWN 0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED 3
#define DRIVE_REMOTE 4
#define DRIVE_CDROM 5
#define DRIVE_RAMDISK 6



#define GetFreeSpace(w) (0x100000L)





#define FILE_TYPE_UNKNOWN 0x0000
#define FILE_TYPE_DISK 0x0001
#define FILE_TYPE_CHAR 0x0002
#define FILE_TYPE_PIPE 0x0003
#define FILE_TYPE_REMOTE 0x8000


#define STD_INPUT_HANDLE ((DWORD)-10)
#define STD_OUTPUT_HANDLE ((DWORD)-11)
#define STD_ERROR_HANDLE ((DWORD)-12)

#define NOPARITY 0
#define ODDPARITY 1
#define EVENPARITY 2
#define MARKPARITY 3
#define SPACEPARITY 4

#define ONESTOPBIT 0
#define ONE5STOPBITS 1
#define TWOSTOPBITS 2

#define IGNORE 0
#define INFINITE 0xFFFFFFFF

//
// Baud rates at which the communication device operates
//

#define CBR_110 110
#define CBR_300 300
#define CBR_600 600
#define CBR_1200 1200
#define CBR_2400 2400
#define CBR_4800 4800
#define CBR_9600 9600
#define CBR_14400 14400
#define CBR_19200 19200
#define CBR_38400 38400
#define CBR_56000 56000
#define CBR_57600 57600
#define CBR_115200 115200
#define CBR_128000 128000
#define CBR_256000 256000

//
// Error Flags
//

#define CE_RXOVER 0x0001
#define CE_OVERRUN 0x0002
#define CE_RXPARITY 0x0004
#define CE_FRAME 0x0008
#define CE_BREAK 0x0010
#define CE_TXFULL 0x0100
#define CE_PTO 0x0200
#define CE_IOE 0x0400
#define CE_DNS 0x0800
#define CE_OOP 0x1000
#define CE_MODE 0x8000

#define IE_BADID (-1)
#define IE_OPEN (-2)
#define IE_NOPEN (-3)
#define IE_MEMORY (-4)
#define IE_DEFAULT (-5)
#define IE_HARDWARE (-10)
#define IE_BYTESIZE (-11)
#define IE_BAUDRATE (-12)

//
// Events
//

#define EV_RXCHAR 0x0001
#define EV_RXFLAG 0x0002
#define EV_TXEMPTY 0x0004
#define EV_CTS 0x0008
#define EV_DSR 0x0010
#define EV_RLSD 0x0020
#define EV_BREAK 0x0040
#define EV_ERR 0x0080
#define EV_RING 0x0100
#define EV_PERR 0x0200
#define EV_RX80FULL 0x0400
#define EV_EVENT1 0x0800
#define EV_EVENT2 0x1000

//
// Escape Functions
//

#define SETXOFF 1
#define SETXON 2
#define SETRTS 3
#define CLRRTS 4
#define SETDTR 5
#define CLRDTR 6
#define RESETDEV 7
#define SETBREAK 8
#define CLRBREAK 9

//
// PURGE function flags.
//
#define PURGE_TXABORT 0x0001
#define PURGE_RXABORT 0x0002
#define PURGE_TXCLEAR 0x0004
#define PURGE_RXCLEAR 0x0008

#define LPTx 0x80

//
// Modem Status Flags
//
#define MS_CTS_ON ((DWORD)0x0010)
#define MS_DSR_ON ((DWORD)0x0020)
#define MS_RING_ON ((DWORD)0x0040)
#define MS_RLSD_ON ((DWORD)0x0080)

//
// WaitSoundState() Constants
//

#define S_QUEUEEMPTY 0
#define S_THRESHOLD 1
#define S_ALLTHRESHOLD 2

//
// Accent Modes
//

#define S_NORMAL 0
#define S_LEGATO 1
#define S_STACCATO 2

//
// SetSoundNoise() Sources
//

#define S_PERIOD512 0
#define S_PERIOD1024 1
#define S_PERIOD2048 2
#define S_PERIODVOICE 3
#define S_WHITE512 4
#define S_WHITE1024 5
#define S_WHITE2048 6
#define S_WHITEVOICE 7

#define S_SERDVNA (-1)
#define S_SEROFM (-2)
#define S_SERMACT (-3)
#define S_SERQFUL (-4)
#define S_SERBDNT (-5)
#define S_SERDLN (-6)
#define S_SERDCC (-7)
#define S_SERDTP (-8)
#define S_SERDVL (-9)
#define S_SERDMD (-10)
#define S_SERDSH (-11)
#define S_SERDPT (-12)
#define S_SERDFQ (-13)
#define S_SERDDR (-14)
#define S_SERDSR (-15)
#define S_SERDST (-16)

#define NMPWAIT_WAIT_FOREVER 0xffffffff
#define NMPWAIT_NOWAIT 0x00000001
#define NMPWAIT_USE_DEFAULT_WAIT 0x00000000

#define FS_CASE_IS_PRESERVED FILE_CASE_PRESERVED_NAMES
#define FS_CASE_SENSITIVE FILE_CASE_SENSITIVE_SEARCH
#define FS_UNICODE_STORED_ON_DISK FILE_UNICODE_ON_DISK
#define FS_PERSISTENT_ACLS FILE_PERSISTENT_ACLS
#define FS_VOL_IS_COMPRESSED FILE_VOLUME_IS_COMPRESSED
#define FS_FILE_COMPRESSION FILE_FILE_COMPRESSION
#define FS_FILE_ENCRYPTION FILE_SUPPORTS_ENCRYPTION

#define FILE_MAP_COPY SECTION_QUERY
#define FILE_MAP_WRITE SECTION_MAP_WRITE
#define FILE_MAP_READ SECTION_MAP_READ
#define FILE_MAP_ALL_ACCESS SECTION_ALL_ACCESS
#define FILE_MAP_EXECUTE SECTION_MAP_EXECUTE_EXPLICIT

#define OF_READ 0x00000000
#define OF_WRITE 0x00000001
#define OF_READWRITE 0x00000002
#define OF_SHARE_COMPAT 0x00000000
#define OF_SHARE_EXCLUSIVE 0x00000010
#define OF_SHARE_DENY_WRITE 0x00000020
#define OF_SHARE_DENY_READ 0x00000030
#define OF_SHARE_DENY_NONE 0x00000040
#define OF_PARSE 0x00000100
#define OF_DELETE 0x00000200
#define OF_VERIFY 0x00000400
#define OF_CANCEL 0x00000800
#define OF_CREATE 0x00001000
#define OF_PROMPT 0x00002000
#define OF_EXIST 0x00004000
#define OF_REOPEN 0x00008000

#define OFS_MAXPATHNAME 128
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;
# 2283 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

LONG

InterlockedIncrement (
    LONG volatile *lpAddend
    );


LONG

InterlockedDecrement (
    LONG volatile *lpAddend
    );


LONG

InterlockedExchange (
    LONG volatile *Target,
    LONG Value
    );

#define InterlockedExchangePointer(Target,Value) (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))



LONG

InterlockedExchangeAdd (
    LONG volatile *Addend,
    LONG Value
    );


LONG

InterlockedCompareExchange (
    LONG volatile *Destination,
    LONG Exchange,
    LONG Comperand
    );




LONGLONG

InterlockedCompareExchange64 (
    LONGLONG volatile *Destination,
    LONGLONG Exchange,
    LONGLONG Comperand
    );







__inline
LONGLONG
InterlockedAnd64 (
    LONGLONG volatile *Destination,
    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

__inline
LONGLONG
InterlockedOr64 (
    LONGLONG volatile *Destination,
    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

__inline
LONGLONG
InterlockedXor64 (
    LONGLONG volatile *Destination,
    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

__inline
LONGLONG
InterlockedIncrement64 (
    LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + 1,
                                          Old) != Old);

    return Old + 1;
}

__inline
LONGLONG
InterlockedDecrement64 (
    LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old - 1,
                                          Old) != Old);

    return Old - 1;
}

__inline
LONGLONG
InterlockedExchange64 (
    LONGLONG volatile *Target,
    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Target;
    } while (InterlockedCompareExchange64(Target,
                                          Value,
                                          Old) != Old);

    return Old;
}

__inline
LONGLONG
InterlockedExchangeAdd64(
    LONGLONG volatile *Addend,
    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);

    return Old;
}






//
// Use a function for C++ so X86 will generate the same errors as RISC.
//
# 2495 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#define InterlockedCompareExchangePointer(Destination,ExChange,Comperand) (PVOID)(LONG_PTR)InterlockedCompareExchange((LONG volatile *)(Destination), (LONG)(LONG_PTR)(ExChange), (LONG)(LONG_PTR)(Comperand))




#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64
#define InterlockedCompareExchangePointerAcquire InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease InterlockedCompareExchangePointer






void

InitializeSListHead (
    PSLIST_HEADER ListHead
    );


PSLIST_ENTRY

InterlockedPopEntrySList (
    PSLIST_HEADER ListHead
    );


PSLIST_ENTRY

InterlockedPushEntrySList (
    PSLIST_HEADER ListHead,
    PSLIST_ENTRY ListEntry
    );


PSLIST_ENTRY

InterlockedFlushSList (
    PSLIST_HEADER ListHead
    );


USHORT

QueryDepthSList (
    PSLIST_HEADER ListHead
    );








BOOL

FreeResource(
    HGLOBAL hResData
    );


LPVOID

LockResource(
    HGLOBAL hResData
    );

#define UnlockResource(hResData) ((hResData), 0)
#define MAXINTATOM 0xC000
#define MAKEINTATOM(i) (LPTSTR)((ULONG_PTR)((WORD)(i)))
#define INVALID_ATOM ((ATOM)0)

int









WinMain (
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    );

int





wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR lpCmdLine,
    int nShowCmd
    );


BOOL

FreeLibrary (
    HMODULE hLibModule
    );




void

FreeLibraryAndExitThread (
    HMODULE hLibModule,
    DWORD dwExitCode
    );


BOOL

DisableThreadLibraryCalls (
    HMODULE hLibModule
    );


FARPROC

GetProcAddress (
    HMODULE hModule,
    LPCSTR lpProcName
    );


DWORD

GetVersion (
    void
    );



HGLOBAL

GlobalAlloc (
    UINT uFlags,
    SIZE_T dwBytes
    );



HGLOBAL

GlobalReAlloc (
    HGLOBAL hMem,
    SIZE_T dwBytes,
    UINT uFlags
    );


SIZE_T

GlobalSize (
    HGLOBAL hMem
    );


UINT

GlobalFlags (
    HGLOBAL hMem
    );



LPVOID

GlobalLock (
    HGLOBAL hMem
    );



HGLOBAL

GlobalHandle (
    LPCVOID pMem
    );


BOOL

GlobalUnlock(
    HGLOBAL hMem
    );



HGLOBAL

GlobalFree(
    HGLOBAL hMem
    );


SIZE_T

GlobalCompact(
    DWORD dwMinFree
    );


void

GlobalFix(
    HGLOBAL hMem
    );


void

GlobalUnfix(
    HGLOBAL hMem
    );



LPVOID

GlobalWire(
    HGLOBAL hMem
    );


BOOL

GlobalUnWire(
    HGLOBAL hMem
    );


void

GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    );

typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;


BOOL

GlobalMemoryStatusEx(
    LPMEMORYSTATUSEX lpBuffer
    );



HLOCAL

LocalAlloc(
    UINT uFlags,
    SIZE_T uBytes
    );



HLOCAL

LocalReAlloc(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    );



LPVOID

LocalLock(
    HLOCAL hMem
    );



HLOCAL

LocalHandle(
    LPCVOID pMem
    );


BOOL

LocalUnlock(
    HLOCAL hMem
    );


SIZE_T

LocalSize(
    HLOCAL hMem
    );


UINT

LocalFlags(
    HLOCAL hMem
    );


HLOCAL

LocalFree(
    HLOCAL hMem
    );


SIZE_T

LocalShrink(
    HLOCAL hMem,
    UINT cbNewSize
    );


SIZE_T

LocalCompact(
    UINT uMinFree
    );


BOOL

FlushInstructionCache(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    SIZE_T dwSize
    );




void

FlushProcessWriteBuffers(
    void
    );


BOOL

QueryThreadCycleTime (
    HANDLE ThreadHandle,
    PULONG64 CycleTime
    );


BOOL

QueryProcessCycleTime (
    HANDLE ProcessHandle,
    PULONG64 CycleTime
    );


BOOL

QueryIdleProcessorCycleTime (
    PULONG BufferLength,
    PULONG64 ProcessorIdleCycleTime
    );






BOOL

QueryIdleProcessorCycleTimeEx (
    USHORT Group,
    PULONG BufferLength,
    PULONG64 ProcessorIdleCycleTime
    );


BOOL

QueryUnbiasedInterruptTime (
    PULONGLONG UnbiasedTime
    );


BOOL

GetProcessorSystemCycleTime (
    USHORT Group,
    PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
    PDWORD ReturnedLength
    );





LPVOID

VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );










BOOL

VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    );


BOOL

VirtualProtect(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );


SIZE_T

VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    );



LPVOID

VirtualAllocEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );





LPVOID

VirtualAllocExNuma(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect,
    DWORD nndPreferred
    );




UINT

GetWriteWatch(
    DWORD dwFlags,
    PVOID lpBaseAddress,
    SIZE_T dwRegionSize,
    PVOID *lpAddresses,
    ULONG_PTR *lpdwCount,
    PULONG lpdwGranularity
    );


UINT

ResetWriteWatch(
    LPVOID lpBaseAddress,
    SIZE_T dwRegionSize
    );


SIZE_T

GetLargePageMinimum(
    void
    );


UINT

EnumSystemFirmwareTables(
    DWORD FirmwareTableProviderSignature,
    PVOID pFirmwareTableEnumBuffer,
    DWORD BufferSize
    );


UINT

GetSystemFirmwareTable(
    DWORD FirmwareTableProviderSignature,
    DWORD FirmwareTableID,
    PVOID pFirmwareTableBuffer,
    DWORD BufferSize
    );


BOOL

GetPhysicallyInstalledSystemMemory(
    PULONGLONG TotalMemoryInKilobytes
    );













BOOL

VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    );


BOOL

VirtualProtectEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    );


SIZE_T

VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    );



HANDLE

HeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    );


BOOL

HeapDestroy(
    HANDLE hHeap
    );



LPVOID

HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    SIZE_T dwBytes
    );



LPVOID

HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    SIZE_T dwBytes
    );


BOOL

HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );


SIZE_T

HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );


BOOL

HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );


SIZE_T

HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    );



HANDLE

GetProcessHeap( void );


DWORD

GetProcessHeaps(
    DWORD NumberOfHeaps,
    PHANDLE ProcessHeaps
    );

typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    } u;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;

#define PROCESS_HEAP_REGION 0x0001
#define PROCESS_HEAP_UNCOMMITTED_RANGE 0x0002
#define PROCESS_HEAP_ENTRY_BUSY 0x0004
#define PROCESS_HEAP_ENTRY_MOVEABLE 0x0010
#define PROCESS_HEAP_ENTRY_DDESHARE 0x0020


BOOL

HeapLock(
    HANDLE hHeap
    );


BOOL

HeapUnlock(
    HANDLE hHeap
    );



BOOL

HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    );


BOOL

HeapSetInformation (
    HANDLE HeapHandle,
    HEAP_INFORMATION_CLASS HeapInformationClass,
    PVOID HeapInformation,
    SIZE_T HeapInformationLength
    );


BOOL

HeapQueryInformation (
    HANDLE HeapHandle,
    HEAP_INFORMATION_CLASS HeapInformationClass,
    PVOID HeapInformation,
    SIZE_T HeapInformationLength,
    PSIZE_T ReturnLength
    );

// GetBinaryType return values.

#define SCS_32BIT_BINARY 0
#define SCS_DOS_BINARY 1
#define SCS_WOW_BINARY 2
#define SCS_PIF_BINARY 3
#define SCS_POSIX_BINARY 4
#define SCS_OS216_BINARY 5
#define SCS_64BIT_BINARY 6


#define SCS_THIS_PLATFORM_BINARY SCS_64BIT_BINARY





BOOL

GetBinaryTypeA(
    LPCSTR lpApplicationName,
    LPDWORD lpBinaryType
    );

BOOL

GetBinaryTypeW(
    LPCWSTR lpApplicationName,
    LPDWORD lpBinaryType
    );



#define GetBinaryType GetBinaryTypeA



DWORD

GetShortPathNameA(
    LPCSTR lpszLongPath,
    LPSTR lpszShortPath,
    DWORD cchBuffer
    );

DWORD

GetShortPathNameW(
    LPCWSTR lpszLongPath,
    LPWSTR lpszShortPath,
    DWORD cchBuffer
    );



#define GetShortPathName GetShortPathNameA



DWORD

GetLongPathNameA(
    LPCSTR lpszShortPath,
    LPSTR lpszLongPath,
    DWORD cchBuffer
    );

DWORD

GetLongPathNameW(
    LPCWSTR lpszShortPath,
    LPWSTR lpszLongPath,
    DWORD cchBuffer
    );



#define GetLongPathName GetLongPathNameA





DWORD

GetLongPathNameTransactedA(
    LPCSTR lpszShortPath,
    LPSTR lpszLongPath,
    DWORD cchBuffer,
    HANDLE hTransaction
    );

DWORD

GetLongPathNameTransactedW(
    LPCWSTR lpszShortPath,
    LPWSTR lpszLongPath,
    DWORD cchBuffer,
    HANDLE hTransaction
    );



#define GetLongPathNameTransacted GetLongPathNameTransactedA





BOOL

GetProcessAffinityMask(
    HANDLE hProcess,
    PDWORD_PTR lpProcessAffinityMask,
    PDWORD_PTR lpSystemAffinityMask
    );


BOOL

SetProcessAffinityMask(
    HANDLE hProcess,
    DWORD_PTR dwProcessAffinityMask
    );



BOOL

GetProcessGroupAffinity(
    HANDLE hProcess,
    PUSHORT GroupCount,
    PUSHORT GroupArray
    );






BOOL

GetProcessHandleCount(
    HANDLE hProcess,
    PDWORD pdwHandleCount
    );




BOOL

GetProcessTimes(
    HANDLE hProcess,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );


BOOL

GetProcessIoCounters(
    HANDLE hProcess,
    PIO_COUNTERS lpIoCounters
    );


BOOL

GetProcessWorkingSetSize(
    HANDLE hProcess,
    PSIZE_T lpMinimumWorkingSetSize,
    PSIZE_T lpMaximumWorkingSetSize
    );


BOOL

GetProcessWorkingSetSizeEx(
    HANDLE hProcess,
    PSIZE_T lpMinimumWorkingSetSize,
    PSIZE_T lpMaximumWorkingSetSize,
    PDWORD Flags
    );


BOOL

SetProcessWorkingSetSize(
    HANDLE hProcess,
    SIZE_T dwMinimumWorkingSetSize,
    SIZE_T dwMaximumWorkingSetSize
    );


BOOL

SetProcessWorkingSetSizeEx(
    HANDLE hProcess,
    SIZE_T dwMinimumWorkingSetSize,
    SIZE_T dwMaximumWorkingSetSize,
    DWORD Flags
    );



#define PROCESS_AFFINITY_ENABLE_AUTO_UPDATE 0x00000001UL


BOOL

SetProcessAffinityUpdateMode(
    HANDLE hProcess,
    DWORD dwFlags
    );


BOOL

QueryProcessAffinityUpdateMode(
    HANDLE hProcess,
    LPDWORD lpdwFlags
    );




HANDLE

OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    );



HANDLE

GetCurrentProcess(
    void
    );


DWORD

GetCurrentProcessId(
    void
    );



void

ExitProcess(
    UINT uExitCode
    );


BOOL

TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    );


BOOL

GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    );


void

FatalExit(
    int ExitCode
    );




LPCH

GetEnvironmentStrings(
    void
    );




LPWCH

GetEnvironmentStringsW(
    void
    );




#define GetEnvironmentStringsA GetEnvironmentStrings



BOOL

SetEnvironmentStringsA(
    LPCH NewEnvironment
    );

BOOL

SetEnvironmentStringsW(
    LPWCH NewEnvironment
    );



#define SetEnvironmentStrings SetEnvironmentStringsA



BOOL

FreeEnvironmentStringsA(
    LPCH
    );

BOOL

FreeEnvironmentStringsW(
    LPWCH
    );



#define FreeEnvironmentStrings FreeEnvironmentStringsA



void

RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    const ULONG_PTR *lpArguments
    );


void

RaiseFailFastException(
    PEXCEPTION_RECORD pExceptionRecord,
    PCONTEXT pContextRecord,
    DWORD dwFlags
    );



LONG

UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef LONG ( *PTOP_LEVEL_EXCEPTION_FILTER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;


LPTOP_LEVEL_EXCEPTION_FILTER

SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );



//
// Fiber creation flags
//

#define FIBER_FLAG_FLOAT_SWITCH 0x1



LPVOID

CreateFiber(
    SIZE_T dwStackSize,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );



LPVOID

CreateFiberEx(
    SIZE_T dwStackCommitSize,
    SIZE_T dwStackReserveSize,
    DWORD dwFlags,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );


void

DeleteFiber(
    LPVOID lpFiber
    );



LPVOID

ConvertThreadToFiber(
    LPVOID lpParameter
    );



LPVOID

ConvertThreadToFiberEx(
    LPVOID lpParameter,
    DWORD dwFlags
    );




BOOL

ConvertFiberToThread(
    void
    );






BOOL

IsThreadAFiber(
    void
    );




void

SwitchToFiber(
    LPVOID lpFiber
    );


BOOL

SwitchToThread(
    void
    );

//
// UMS begin
//



#define UMS_VERSION RTL_UMS_VERSION

typedef void *PUMS_CONTEXT;

typedef void *PUMS_COMPLETION_LIST;

typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;

typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;

typedef struct _UMS_SCHEDULER_STARTUP_INFO {

    //
    // UMS Version the application was built to. Should be set to UMS_VERSION
    //
    ULONG UmsVersion;

    //
    // Completion List to associate the new User Scheduler to.
    //
    PUMS_COMPLETION_LIST CompletionList;

    //
    // A pointer to the application-defined function that represents the starting
    // address of the Sheduler.
    //
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;

    //
    // pointer to a variable to be passed to the scheduler uppon first activation.
    //
    PVOID SchedulerParam;

} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;



BOOL

CreateUmsCompletionList(
    PUMS_COMPLETION_LIST* UmsCompletionList
    );


BOOL

DequeueUmsCompletionListItems(
    PUMS_COMPLETION_LIST UmsCompletionList,
    DWORD WaitTimeOut,
    PUMS_CONTEXT* UmsThreadList
    );


BOOL

GetUmsCompletionListEvent(
    PUMS_COMPLETION_LIST UmsCompletionList,
    PHANDLE UmsCompletionEvent
    );


BOOL

ExecuteUmsThread(
    PUMS_CONTEXT UmsThread
    );


BOOL

UmsThreadYield(
    PVOID SchedulerParam
    );


BOOL

DeleteUmsCompletionList(
    PUMS_COMPLETION_LIST UmsCompletionList
    );


PUMS_CONTEXT

GetCurrentUmsThread(
    void
    );


PUMS_CONTEXT

GetNextUmsListItem(
    PUMS_CONTEXT UmsContext
    );


BOOL

QueryUmsThreadInformation(
    PUMS_CONTEXT UmsThread,
    UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
    PVOID UmsThreadInformation,
    ULONG UmsThreadInformationLength,
    PULONG ReturnLength
    );


BOOL

SetUmsThreadInformation(
    PUMS_CONTEXT UmsThread,
    UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
    PVOID UmsThreadInformation,
    ULONG UmsThreadInformationLength
    );


BOOL

DeleteUmsThreadContext(
    PUMS_CONTEXT UmsThread
    );


BOOL

CreateUmsThreadContext(
    PUMS_CONTEXT *lpUmsThread
    );


BOOL

EnterUmsSchedulingMode(
    PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
    );



//
// UMS end
//



typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;



HANDLE

CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );



HANDLE

CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    );



HANDLE

CreateRemoteThreadEx(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    LPDWORD lpThreadId
    );



HANDLE

GetCurrentThread(
    void
    );


DWORD

GetCurrentThreadId(
    void
    );


BOOL

SetThreadStackGuarantee (
    PULONG StackSizeInBytes
    );


DWORD

GetProcessIdOfThread(
    HANDLE Thread
    );




DWORD

GetThreadId(
    HANDLE Thread
    );




DWORD

GetProcessId(
    HANDLE Process
    );


DWORD

GetCurrentProcessorNumber(
    void
    );



void

GetCurrentProcessorNumberEx(
    PPROCESSOR_NUMBER ProcNumber
    );




BOOL

GetThreadGroupAffinity(
    HANDLE hThread,
    PGROUP_AFFINITY GroupAffinity
    );



DWORD_PTR

SetThreadAffinityMask(
    HANDLE hThread,
    DWORD_PTR dwThreadAffinityMask
    );



BOOL

SetThreadGroupAffinity(
    HANDLE hThread,
    const GROUP_AFFINITY *GroupAffinity,
    PGROUP_AFFINITY PreviousGroupAffinity
    );


BOOL

SetThreadIdealProcessorEx (
    HANDLE hThread,
    PPROCESSOR_NUMBER lpIdealProcessor,
    PPROCESSOR_NUMBER lpPreviousIdealProcessor
    );


BOOL

GetThreadIdealProcessorEx (
    HANDLE hThread,
    PPROCESSOR_NUMBER lpIdealProcessor
    );





DWORD

SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD dwIdealProcessor
    );




#define PROCESS_DEP_ENABLE 0x00000001
#define PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION 0x00000002


BOOL

SetProcessDEPPolicy(
    DWORD dwFlags
    );


BOOL

GetProcessDEPPolicy(
    HANDLE hProcess,
    LPDWORD lpFlags,
    PBOOL lpPermanent
    );




BOOL

SetProcessPriorityBoost(
    HANDLE hProcess,
    BOOL bDisablePriorityBoost
    );


BOOL

GetProcessPriorityBoost(
    HANDLE hProcess,
    PBOOL pDisablePriorityBoost
    );


BOOL

RequestWakeupLatency(
    LATENCY_TIME latency
    );


BOOL

IsSystemResumeAutomatic(
    void
    );



HANDLE

OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    );


BOOL

SetThreadPriority(
    HANDLE hThread,
    int nPriority
    );


BOOL

SetThreadPriorityBoost(
    HANDLE hThread,
    BOOL bDisablePriorityBoost
    );


BOOL

GetThreadPriorityBoost(
    HANDLE hThread,
    PBOOL pDisablePriorityBoost
    );


int

GetThreadPriority(
    HANDLE hThread
    );


BOOL

GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );




BOOL

GetThreadIOPendingFlag(
    HANDLE hThread,
    PBOOL lpIOIsPending
    );





void

ExitThread(
    DWORD dwExitCode
    );


BOOL

TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    );



BOOL

GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    );


BOOL

GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    );


EXECUTION_STATE

SetThreadExecutionState(
    EXECUTION_STATE esFlags
    );



typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;

        } Detailed;

        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;

//
// Power Request APIs
//

typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;


HANDLE

PowerCreateRequest (
    PREASON_CONTEXT Context
    );


BOOL

PowerSetRequest (
    HANDLE PowerRequest,
    POWER_REQUEST_TYPE RequestType
    );


BOOL

PowerClearRequest (
    HANDLE PowerRequest,
    POWER_REQUEST_TYPE RequestType
    );








DWORD

GetLastError(
    void
    );



void

SetLastError(
    DWORD dwErrCode
    );


//#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)
# 4286 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#define HasOverlappedIoCompleted(lpOverlapped) (((DWORD)(lpOverlapped)->Internal) != STATUS_PENDING)


BOOL

GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    );



HANDLE

CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    ULONG_PTR CompletionKey,
    DWORD NumberOfConcurrentThreads
    );


BOOL

GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    );




BOOL

GetQueuedCompletionStatusEx(
    HANDLE CompletionPort,
    LPOVERLAPPED_ENTRY lpCompletionPortEntries,
    ULONG ulCount,
    PULONG ulNumEntriesRemoved,
    DWORD dwMilliseconds,
    BOOL fAlertable
    );




BOOL

PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    ULONG_PTR dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    );



//
// The following flags allows an application to change
// the semantics of IO completion notification.
//

//
// Don't queue an entry to an associated completion port if returning success
// synchronously.
//
#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS 0x1

//
// Don't set the file handle event on IO completion.
//
#define FILE_SKIP_SET_EVENT_ON_HANDLE 0x2


BOOL

SetFileCompletionNotificationModes(
    HANDLE FileHandle,
    UCHAR Flags
    );


BOOL

SetFileIoOverlappedRange(
    HANDLE FileHandle,
    PUCHAR OverlappedRangeStart,
    ULONG Length
    );



#define SEM_FAILCRITICALERRORS 0x0001
#define SEM_NOGPFAULTERRORBOX 0x0002
#define SEM_NOALIGNMENTFAULTEXCEPT 0x0004
#define SEM_NOOPENFILEERRORBOX 0x8000


UINT

GetErrorMode(
    void
    );


UINT

SetErrorMode(
    UINT uMode
    );

//
// Thread error mode support
//


DWORD

GetThreadErrorMode(
    void
    );


BOOL

SetThreadErrorMode(
    DWORD dwNewMode,
    LPDWORD lpOldMode
    );


BOOL

ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T * lpNumberOfBytesRead
    );


BOOL

WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T * lpNumberOfBytesWritten
    );



BOOL

GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    );


BOOL

SetThreadContext(
    HANDLE hThread,
    const CONTEXT *lpContext
    );


BOOL

Wow64GetThreadContext(
    HANDLE hThread,
    PWOW64_CONTEXT lpContext
    );




BOOL

Wow64GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    PWOW64_LDT_ENTRY lpSelectorEntry
    );




BOOL

Wow64SetThreadContext(
    HANDLE hThread,
    const WOW64_CONTEXT *lpContext
    );




DWORD

SuspendThread(
    HANDLE hThread
    );


DWORD

Wow64SuspendThread(
    HANDLE hThread
    );


DWORD

ResumeThread(
    HANDLE hThread
    );





DWORD

QueueUserAPC(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
    );





BOOL

IsDebuggerPresent(
    void
    );





BOOL

CheckRemoteDebuggerPresent(
    HANDLE hProcess,
    PBOOL pbDebuggerPresent
    );




void

DebugBreak(
    void
    );


BOOL

WaitForDebugEvent(
    LPDEBUG_EVENT lpDebugEvent,
    DWORD dwMilliseconds
    );


BOOL

ContinueDebugEvent(
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwContinueStatus
    );


BOOL

DebugActiveProcess(
    DWORD dwProcessId
    );


BOOL

DebugActiveProcessStop(
    DWORD dwProcessId
    );


BOOL

DebugSetProcessKillOnExit(
    BOOL KillOnExit
    );


BOOL

DebugBreakProcess (
    HANDLE Process
    );





void

InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );


void

EnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );


void

LeaveCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );


#define CRITICAL_SECTION_NO_DEBUG_INFO RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO


BOOL

InitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    );


BOOL

InitializeCriticalSectionEx(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount,
    DWORD Flags
    );


DWORD

SetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    );




BOOL

TryEnterCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );



void

DeleteCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );


BOOL

SetEvent(
    HANDLE hEvent
    );


BOOL

ResetEvent(
    HANDLE hEvent
    );


BOOL

PulseEvent(
    HANDLE hEvent
    );


BOOL

ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    );


BOOL

ReleaseMutex(
    HANDLE hMutex
    );


DWORD

WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    );


DWORD

WaitForMultipleObjects(
    DWORD nCount,
    const HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    );


void

Sleep(
    DWORD dwMilliseconds
    );



HGLOBAL

LoadResource(
    HMODULE hModule,
    HRSRC hResInfo
    );


DWORD

SizeofResource(
    HMODULE hModule,
    HRSRC hResInfo
    );



ATOM

GlobalDeleteAtom(
    ATOM nAtom
    );


BOOL

InitAtomTable(
    DWORD nSize
    );


ATOM

DeleteAtom(
    ATOM nAtom
    );


UINT

SetHandleCount(
    UINT uNumber
    );


DWORD

GetLogicalDrives(
    void
    );


BOOL

LockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh
    );


BOOL

UnlockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh
    );


BOOL

LockFileEx(
    HANDLE hFile,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped
    );

#define LOCKFILE_FAIL_IMMEDIATELY 0x00000001
#define LOCKFILE_EXCLUSIVE_LOCK 0x00000002


BOOL

UnlockFileEx(
    HANDLE hFile,
    DWORD dwReserved,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh,
    LPOVERLAPPED lpOverlapped
    );

typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;


BOOL

GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );


DWORD

GetFileType(
    HANDLE hFile
    );


DWORD

GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    );


BOOL

GetFileSizeEx(
    HANDLE hFile,
    PLARGE_INTEGER lpFileSize
    );



HANDLE

GetStdHandle(
    DWORD nStdHandle
    );


BOOL

SetStdHandle(
    DWORD nStdHandle,
    HANDLE hHandle
    );




BOOL

SetStdHandleEx(
    DWORD nStdHandle,
    HANDLE hHandle,
    PHANDLE phPrevValue
    );




BOOL

WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    );


BOOL

ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    );


BOOL

FlushFileBuffers(
    HANDLE hFile
    );


BOOL

DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    );


BOOL

RequestDeviceWakeup(
    HANDLE hDevice
    );


BOOL

CancelDeviceWakeupRequest(
    HANDLE hDevice
    );


BOOL

GetDevicePowerState(
    HANDLE hDevice,
    BOOL *pfOn
    );


BOOL

SetMessageWaitingIndicator(
    HANDLE hMsgIndicator,
    ULONG ulMsgCount
    );


BOOL

SetEndOfFile(
    HANDLE hFile
    );


DWORD

SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    );


BOOL

SetFilePointerEx(
    HANDLE hFile,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER lpNewFilePointer,
    DWORD dwMoveMethod
    );


BOOL

FindClose(
    HANDLE hFindFile
    );


BOOL

GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    );


BOOL

SetFileTime(
    HANDLE hFile,
    const FILETIME *lpCreationTime,
    const FILETIME *lpLastAccessTime,
    const FILETIME *lpLastWriteTime
    );





BOOL

SetFileValidData(
    HANDLE hFile,
    LONGLONG ValidDataLength
    );





BOOL

SetFileShortNameA(
    HANDLE hFile,
    LPCSTR lpShortName
    );

BOOL

SetFileShortNameW(
    HANDLE hFile,
    LPCWSTR lpShortName
    );



#define SetFileShortName SetFileShortNameA



BOOL

CloseHandle(
    HANDLE hObject
    );


BOOL

DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    );


BOOL

GetHandleInformation(
    HANDLE hObject,
    LPDWORD lpdwFlags
    );


BOOL

SetHandleInformation(
    HANDLE hObject,
    DWORD dwMask,
    DWORD dwFlags
    );

#define HANDLE_FLAG_INHERIT 0x00000001
#define HANDLE_FLAG_PROTECT_FROM_CLOSE 0x00000002

#define HINSTANCE_ERROR 32


DWORD

LoadModule(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    );




UINT

WinExec(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    );


BOOL

ClearCommBreak(
    HANDLE hFile
    );


BOOL

ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    );


BOOL

SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    );


BOOL

EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    );



BOOL

GetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );


BOOL

GetCommMask(
    HANDLE hFile,
    LPDWORD lpEvtMask
    );


BOOL

GetCommProperties(
    HANDLE hFile,
    LPCOMMPROP lpCommProp
    );


BOOL

GetCommModemStatus(
    HANDLE hFile,
    LPDWORD lpModemStat
    );


BOOL

GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );


BOOL

GetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );


BOOL

PurgeComm(
    HANDLE hFile,
    DWORD dwFlags
    );


BOOL

SetCommBreak(
    HANDLE hFile
    );


BOOL

SetCommConfig(
    HANDLE hCommDev,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );


BOOL

SetCommMask(
    HANDLE hFile,
    DWORD dwEvtMask
    );


BOOL

SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    );


BOOL

SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    );


BOOL

TransmitCommChar(
    HANDLE hFile,
    char cChar
    );


BOOL

WaitCommEvent(
    HANDLE hFile,
    LPDWORD lpEvtMask,
    LPOVERLAPPED lpOverlapped
    );



DWORD

SetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionMethod,
    DWORD dwPartition,
    DWORD dwOffsetLow,
    DWORD dwOffsetHigh,
    BOOL bImmediate
    );


DWORD

GetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionType,
    LPDWORD lpdwPartition,
    LPDWORD lpdwOffsetLow,
    LPDWORD lpdwOffsetHigh
    );


DWORD

PrepareTape(
    HANDLE hDevice,
    DWORD dwOperation,
    BOOL bImmediate
    );


DWORD

EraseTape(
    HANDLE hDevice,
    DWORD dwEraseType,
    BOOL bImmediate
    );


DWORD

CreateTapePartition(
    HANDLE hDevice,
    DWORD dwPartitionMethod,
    DWORD dwCount,
    DWORD dwSize
    );


DWORD

WriteTapemark(
    HANDLE hDevice,
    DWORD dwTapemarkType,
    DWORD dwTapemarkCount,
    BOOL bImmediate
    );


DWORD

GetTapeStatus(
    HANDLE hDevice
    );


DWORD

GetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPDWORD lpdwSize,
    LPVOID lpTapeInformation
    );

#define GET_TAPE_MEDIA_INFORMATION 0
#define GET_TAPE_DRIVE_INFORMATION 1


DWORD

SetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPVOID lpTapeInformation
    );

#define SET_TAPE_MEDIA_INFORMATION 0
#define SET_TAPE_DRIVE_INFORMATION 1


BOOL

Beep(
    DWORD dwFreq,
    DWORD dwDuration
    );


int

MulDiv(
    int nNumber,
    int nNumerator,
    int nDenominator
    );


void

GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    );


void

GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    );


BOOL

SetSystemTime(
    const SYSTEMTIME *lpSystemTime
    );


void

GetLocalTime(
    LPSYSTEMTIME lpSystemTime
    );


BOOL

SetLocalTime(
    const SYSTEMTIME *lpSystemTime
    );


void

GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );

typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;


DEP_SYSTEM_POLICY_TYPE

GetSystemDEPPolicy(
    void
    );



#define FILE_CACHE_FLAGS_DEFINED 

#define FILE_CACHE_MAX_HARD_ENABLE 0x00000001
#define FILE_CACHE_MAX_HARD_DISABLE 0x00000002
#define FILE_CACHE_MIN_HARD_ENABLE 0x00000004
#define FILE_CACHE_MIN_HARD_DISABLE 0x00000008


BOOL

SetSystemFileCacheSize (
    SIZE_T MinimumFileCacheSize,
    SIZE_T MaximumFileCacheSize,
    DWORD Flags
    );


BOOL

GetSystemFileCacheSize (
    PSIZE_T lpMinimumFileCacheSize,
    PSIZE_T lpMaximumFileCacheSize,
    PDWORD lpFlags
    );






BOOL

GetSystemRegistryQuota(
    PDWORD pdwQuotaAllowed,
    PDWORD pdwQuotaUsed
    );

BOOL

GetSystemTimes(
    LPFILETIME lpIdleTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    );





void

GetNativeSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );



BOOL

IsProcessorFeaturePresent(
    DWORD ProcessorFeature
    );

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;



BOOL

SystemTimeToTzSpecificLocalTime(
    const TIME_ZONE_INFORMATION *lpTimeZoneInformation,
    const SYSTEMTIME *lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    );


BOOL

TzSpecificLocalTimeToSystemTime(
    const TIME_ZONE_INFORMATION *lpTimeZoneInformation,
    const SYSTEMTIME *lpLocalTime,
    LPSYSTEMTIME lpUniversalTime
    );

BOOL

GetTimeZoneInformationForYear(
    USHORT wYear,
    PDYNAMIC_TIME_ZONE_INFORMATION pdtzi,
    LPTIME_ZONE_INFORMATION ptzi
    );


DWORD

GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );


BOOL

SetTimeZoneInformation(
    const TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );


DWORD

GetDynamicTimeZoneInformation(
    PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );


BOOL

SetDynamicTimeZoneInformation(
    const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );



//
// Routines to convert back and forth between system time and file time
//


BOOL

SystemTimeToFileTime(
    const SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    );


BOOL

FileTimeToLocalFileTime(
    const FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    );


BOOL

LocalFileTimeToFileTime(
    const FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    );


BOOL

FileTimeToSystemTime(
    const FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    );


LONG

CompareFileTime(
    const FILETIME *lpFileTime1,
    const FILETIME *lpFileTime2
    );


BOOL

FileTimeToDosDateTime(
    const FILETIME *lpFileTime,
    LPWORD lpFatDate,
    LPWORD lpFatTime
    );


BOOL

DosDateTimeToFileTime(
    WORD wFatDate,
    WORD wFatTime,
    LPFILETIME lpFileTime
    );



DWORD

GetTickCount(
    void
    );




ULONGLONG

GetTickCount64(
    void
    );




BOOL

SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL bTimeAdjustmentDisabled
    );


BOOL

GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL lpTimeAdjustmentDisabled
    );



DWORD

FormatMessageA(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );

DWORD

FormatMessageW(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );



#define FormatMessage FormatMessageA
# 5745 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#define FORMAT_MESSAGE_ALLOCATE_BUFFER 0x00000100
#define FORMAT_MESSAGE_IGNORE_INSERTS 0x00000200
#define FORMAT_MESSAGE_FROM_STRING 0x00000400
#define FORMAT_MESSAGE_FROM_HMODULE 0x00000800
#define FORMAT_MESSAGE_FROM_SYSTEM 0x00001000
#define FORMAT_MESSAGE_ARGUMENT_ARRAY 0x00002000
#define FORMAT_MESSAGE_MAX_WIDTH_MASK 0x000000FF




BOOL

CreatePipe(
    PHANDLE hReadPipe,
    PHANDLE hWritePipe,
    LPSECURITY_ATTRIBUTES lpPipeAttributes,
    DWORD nSize
    );


BOOL

ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    );


BOOL

DisconnectNamedPipe(
    HANDLE hNamedPipe
    );


BOOL

SetNamedPipeHandleState(
    HANDLE hNamedPipe,
    LPDWORD lpMode,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout
    );


BOOL

GetNamedPipeInfo(
    HANDLE hNamedPipe,
    LPDWORD lpFlags,
    LPDWORD lpOutBufferSize,
    LPDWORD lpInBufferSize,
    LPDWORD lpMaxInstances
    );


BOOL

PeekNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpBuffer,
    DWORD nBufferSize,
    LPDWORD lpBytesRead,
    LPDWORD lpTotalBytesAvail,
    LPDWORD lpBytesLeftThisMessage
    );


BOOL

TransactNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    LPOVERLAPPED lpOverlapped
    );



HANDLE

CreateMailslotA(
    LPCSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );


HANDLE

CreateMailslotW(
    LPCWSTR lpName,
    DWORD nMaxMessageSize,
    DWORD lReadTimeout,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );



#define CreateMailslot CreateMailslotA



BOOL

GetMailslotInfo(
    HANDLE hMailslot,
    LPDWORD lpMaxMessageSize,
    LPDWORD lpNextSize,
    LPDWORD lpMessageCount,
    LPDWORD lpReadTimeout
    );


BOOL

SetMailslotInfo(
    HANDLE hMailslot,
    DWORD lReadTimeout
    );



LPVOID

MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap
    );


BOOL

FlushViewOfFile(
    LPCVOID lpBaseAddress,
    SIZE_T dwNumberOfBytesToFlush
    );


BOOL

UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );

//
// File Encryption API
//


BOOL

EncryptFileA(
    LPCSTR lpFileName
    );

BOOL

EncryptFileW(
    LPCWSTR lpFileName
    );



#define EncryptFile EncryptFileA



BOOL

DecryptFileA(
    LPCSTR lpFileName,
    DWORD dwReserved
    );

BOOL

DecryptFileW(
    LPCWSTR lpFileName,
    DWORD dwReserved
    );



#define DecryptFile DecryptFileA


//
//  Encryption Status Value
//

#define FILE_ENCRYPTABLE 0
#define FILE_IS_ENCRYPTED 1
#define FILE_SYSTEM_ATTR 2
#define FILE_ROOT_DIR 3
#define FILE_SYSTEM_DIR 4
#define FILE_UNKNOWN 5
#define FILE_SYSTEM_NOT_SUPPORT 6
#define FILE_USER_DISALLOWED 7
#define FILE_READ_ONLY 8
#define FILE_DIR_DISALLOWED 9


BOOL

FileEncryptionStatusA(
    LPCSTR lpFileName,
    LPDWORD lpStatus
    );

BOOL

FileEncryptionStatusW(
    LPCWSTR lpFileName,
    LPDWORD lpStatus
    );



#define FileEncryptionStatus FileEncryptionStatusA


//
// Currently defined recovery flags
//

#define EFS_USE_RECOVERY_KEYS (0x1)

typedef
DWORD
( *PFE_EXPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    ULONG ulLength
    );

typedef
DWORD
( *PFE_IMPORT_FUNC)(
    PBYTE pbData,
    PVOID pvCallbackContext,
    PULONG ulLength
    );


//
//  OpenRaw flag values
//

#define CREATE_FOR_IMPORT (1)
#define CREATE_FOR_DIR (2)
#define OVERWRITE_HIDDEN (4)
#define EFSRPC_SECURE_ONLY (8)



DWORD

OpenEncryptedFileRawA(
    LPCSTR lpFileName,
    ULONG ulFlags,
    PVOID *pvContext
    );

DWORD

OpenEncryptedFileRawW(
    LPCWSTR lpFileName,
    ULONG ulFlags,
    PVOID *pvContext
    );



#define OpenEncryptedFileRaw OpenEncryptedFileRawA



DWORD

ReadEncryptedFileRaw(
    PFE_EXPORT_FUNC pfExportCallback,
    PVOID pvCallbackContext,
    PVOID pvContext
    );


DWORD

WriteEncryptedFileRaw(
    PFE_IMPORT_FUNC pfImportCallback,
    PVOID pvCallbackContext,
    PVOID pvContext
    );


void

CloseEncryptedFileRaw(
    PVOID pvContext
    );

//
// _l Compat Functions
//


int

lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );

int

lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );



#define lstrcmp lstrcmpA



int

lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );

int

lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );



#define lstrcmpi lstrcmpiA




LPSTR

lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    );


LPWSTR

lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );



#define lstrcpyn lstrcpynA









LPSTR

lstrcpyA(
    LPSTR lpString1, // deprecated: annotation is as good as it gets
    LPCSTR lpString2
    );


LPWSTR

lstrcpyW(
    LPWSTR lpString1, // deprecated: annotation is as good as it gets
    LPCWSTR lpString2
    );



#define lstrcpy lstrcpyA




LPSTR

lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    );


LPWSTR

lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );



#define lstrcat lstrcatA







int

lstrlenA(
    LPCSTR lpString
    );

int

lstrlenW(
    LPCWSTR lpString
    );



#define lstrlen lstrlenA



HFILE

OpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    );


HFILE

_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    );


HFILE

_lcreat(
    LPCSTR lpPathName,
    int iAttribute
    );


UINT

_lread(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT uBytes
    );


UINT

_lwrite(
    HFILE hFile,
    LPCCH lpBuffer,
    UINT uBytes
    );


long

_hread(
    HFILE hFile,
    LPVOID lpBuffer,
    long lBytes
    );


long

_hwrite(
    HFILE hFile,
    LPCCH lpBuffer,
    long lBytes
    );


HFILE

_lclose(
    HFILE hFile
    );


LONG

_llseek(
    HFILE hFile,
    LONG lOffset,
    int iOrigin
    );


BOOL

IsTextUnicode(
    const void* lpv,
    int iSize,
    LPINT lpiResult
    );

#define FLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)


DWORD

FlsAlloc(
    PFLS_CALLBACK_FUNCTION lpCallback
    );


PVOID

FlsGetValue(
    DWORD dwFlsIndex
    );


BOOL

FlsSetValue(
    DWORD dwFlsIndex,
    PVOID lpFlsData
    );


BOOL

FlsFree(
    DWORD dwFlsIndex
    );

#define TLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)


DWORD

TlsAlloc(
    void
    );


LPVOID

TlsGetValue(
    DWORD dwTlsIndex
    );


BOOL

TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    );


BOOL

TlsFree(
    DWORD dwTlsIndex
    );

typedef
void
( *LPOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );


DWORD

SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    );


DWORD

WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );


DWORD

WaitForMultipleObjectsEx(
    DWORD nCount,
    const HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );



DWORD

SignalObjectAndWait(
    HANDLE hObjectToSignal,
    HANDLE hObjectToWaitOn,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );



BOOL

ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


BOOL

WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


BOOL

BackupRead(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );


BOOL

BackupSeek(
    HANDLE hFile,
    DWORD dwLowBytesToSeek,
    DWORD dwHighBytesToSeek,
    LPDWORD lpdwLowByteSeeked,
    LPDWORD lpdwHighByteSeeked,
    LPVOID *lpContext
    );


BOOL

BackupWrite(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );

//
//  Stream id structure
//
typedef struct _WIN32_STREAM_ID {
        DWORD dwStreamId ;
        DWORD dwStreamAttributes ;
        LARGE_INTEGER Size ;
        DWORD dwStreamNameSize ;
        WCHAR cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;

//
//  Stream Ids
//

#define BACKUP_INVALID 0x00000000
#define BACKUP_DATA 0x00000001
#define BACKUP_EA_DATA 0x00000002
#define BACKUP_SECURITY_DATA 0x00000003
#define BACKUP_ALTERNATE_DATA 0x00000004
#define BACKUP_LINK 0x00000005
#define BACKUP_PROPERTY_DATA 0x00000006
#define BACKUP_OBJECT_ID 0x00000007
#define BACKUP_REPARSE_DATA 0x00000008
#define BACKUP_SPARSE_BLOCK 0x00000009
#define BACKUP_TXFS_DATA 0x0000000a


//
//  Stream Attributes
//

#define STREAM_NORMAL_ATTRIBUTE 0x00000000
#define STREAM_MODIFIED_WHEN_READ 0x00000001
#define STREAM_CONTAINS_SECURITY 0x00000002
#define STREAM_CONTAINS_PROPERTIES 0x00000004
#define STREAM_SPARSE_ATTRIBUTE 0x00000008


BOOL

ReadFileScatter(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray[],
    DWORD nNumberOfBytesToRead,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    );


BOOL

WriteFileGather(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray[],
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    );

//
// Dual Mode API below this line. Dual Mode Structures also included.
//

#define STARTF_USESHOWWINDOW 0x00000001
#define STARTF_USESIZE 0x00000002
#define STARTF_USEPOSITION 0x00000004
#define STARTF_USECOUNTCHARS 0x00000008
#define STARTF_USEFILLATTRIBUTE 0x00000010
#define STARTF_RUNFULLSCREEN 0x00000020
#define STARTF_FORCEONFEEDBACK 0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USESTDHANDLES 0x00000100



#define STARTF_USEHOTKEY 0x00000200
#define STARTF_TITLEISLINKNAME 0x00000800
#define STARTF_TITLEISAPPID 0x00001000
#define STARTF_PREVENTPINNING 0x00002000


typedef struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;




typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;




typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;




typedef STARTUPINFOEXA STARTUPINFOEX;
typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;




#define SHUTDOWN_NORETRY 0x00000001

typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR cFileName[ 260 ];
    CHAR cAlternateFileName[ 14 ];





} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR cFileName[ 260 ];
    WCHAR cAlternateFileName[ 14 ];





} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;





typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;


typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

//
// Synchronization APIs
//



HANDLE

CreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    );


HANDLE

CreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );



#define CreateMutex CreateMutexA




HANDLE

OpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );


HANDLE

OpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );



#define OpenMutex OpenMutexA




HANDLE

CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );


HANDLE

CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );



#define CreateEvent CreateEventA




HANDLE

OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );


HANDLE

OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );



#define OpenEvent OpenEventA




HANDLE

CreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    );


HANDLE

CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );



#define CreateSemaphore CreateSemaphoreA




HANDLE

OpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );


HANDLE

OpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );



#define OpenSemaphore OpenSemaphoreA



typedef
void
( *PTIMERAPCROUTINE)(
    LPVOID lpArgToCompletionRoutine,
    DWORD dwTimerLowValue,
    DWORD dwTimerHighValue
    );



HANDLE

CreateWaitableTimerA(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    );


HANDLE

CreateWaitableTimerW(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCWSTR lpTimerName
    );



#define CreateWaitableTimer CreateWaitableTimerA




HANDLE

OpenWaitableTimerA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpTimerName
    );


HANDLE

OpenWaitableTimerW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpTimerName
    );



#define OpenWaitableTimer OpenWaitableTimerA




BOOL

SetWaitableTimerEx(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    PREASON_CONTEXT WakeContext,
    ULONG TolerableDelay
    );




BOOL

SetWaitableTimer(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );


BOOL

CancelWaitableTimer(
    HANDLE hTimer
    );



#define CREATE_MUTEX_INITIAL_OWNER 0x00000001



HANDLE

CreateMutexExA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    LPCSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );


HANDLE

CreateMutexExW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    LPCWSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );



#define CreateMutexEx CreateMutexExA


#define CREATE_EVENT_MANUAL_RESET 0x00000001
#define CREATE_EVENT_INITIAL_SET 0x00000002



HANDLE

CreateEventExA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    LPCSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );


HANDLE

CreateEventExW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    LPCWSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );



#define CreateEventEx CreateEventExA




HANDLE

CreateSemaphoreExA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );


HANDLE

CreateSemaphoreExW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );



#define CreateSemaphoreEx CreateSemaphoreExA


#define CREATE_WAITABLE_TIMER_MANUAL_RESET 0x00000001



HANDLE

CreateWaitableTimerExA(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    LPCSTR lpTimerName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );


HANDLE

CreateWaitableTimerExW(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    LPCWSTR lpTimerName,
    DWORD dwFlags,
    DWORD dwDesiredAccess
    );



#define CreateWaitableTimerEx CreateWaitableTimerExA








HANDLE

CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );


HANDLE

CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );



#define CreateFileMapping CreateFileMappingA






HANDLE

CreateFileMappingNumaA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName,
    DWORD nndPreferred
    );


HANDLE

CreateFileMappingNumaW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName,
    DWORD nndPreferred
    );



#define CreateFileMappingNuma CreateFileMappingNumaA






HANDLE

OpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );


HANDLE

OpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );



#define OpenFileMapping OpenFileMappingA



DWORD

GetLogicalDriveStringsA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

DWORD

GetLogicalDriveStringsW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );



#define GetLogicalDriveStrings GetLogicalDriveStringsA




typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;



HANDLE

CreateMemoryResourceNotification(
    MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );


BOOL

QueryMemoryResourceNotification(
    HANDLE ResourceNotificationHandle,
    PBOOL ResourceState
    );






HMODULE

LoadLibraryA(
    LPCSTR lpLibFileName
    );


HMODULE

LoadLibraryW(
    LPCWSTR lpLibFileName
    );



#define LoadLibrary LoadLibraryA




HMODULE

LoadLibraryExA(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );


HMODULE

LoadLibraryExW(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );



#define LoadLibraryEx LoadLibraryExA


#define DONT_RESOLVE_DLL_REFERENCES 0x00000001
#define LOAD_LIBRARY_AS_DATAFILE 0x00000002
#define LOAD_WITH_ALTERED_SEARCH_PATH 0x00000008
#define LOAD_IGNORE_CODE_AUTHZ_LEVEL 0x00000010
#define LOAD_LIBRARY_AS_IMAGE_RESOURCE 0x00000020
#define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 0x00000040
#define LOAD_LIBRARY_REQUIRE_SIGNED_TARGET 0x00000080


DWORD

GetModuleFileNameA(
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD

GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );



#define GetModuleFileName GetModuleFileNameA




HMODULE

GetModuleHandleA(
    LPCSTR lpModuleName
    );


HMODULE

GetModuleHandleW(
    LPCWSTR lpModuleName
    );



#define GetModuleHandle GetModuleHandleA





#define GET_MODULE_HANDLE_EX_FLAG_PIN (0x00000001)
#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT (0x00000002)
#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS (0x00000004)

typedef
BOOL
(*
PGET_MODULE_HANDLE_EXA)(
    DWORD dwFlags,
    LPCSTR lpModuleName,
    HMODULE* phModule
    );
typedef
BOOL
(*
PGET_MODULE_HANDLE_EXW)(
    DWORD dwFlags,
    LPCWSTR lpModuleName,
    HMODULE* phModule
    );



#define PGET_MODULE_HANDLE_EX PGET_MODULE_HANDLE_EXA



BOOL

GetModuleHandleExA(
    DWORD dwFlags,
    LPCSTR lpModuleName,
    HMODULE* phModule
    );

BOOL

GetModuleHandleExW(
    DWORD dwFlags,
    LPCWSTR lpModuleName,
    HMODULE* phModule
    );



#define GetModuleHandleEx GetModuleHandleExA








BOOL

NeedCurrentDirectoryForExePathA(
    LPCSTR ExeName
    );

BOOL

NeedCurrentDirectoryForExePathW(
    LPCWSTR ExeName
    );



#define NeedCurrentDirectoryForExePath NeedCurrentDirectoryForExePathA






#define PROCESS_NAME_NATIVE 0x00000001


BOOL

QueryFullProcessImageNameA(
    HANDLE hProcess,
    DWORD dwFlags,
    LPSTR lpExeName,
    PDWORD lpdwSize
    );

BOOL

QueryFullProcessImageNameW(
    HANDLE hProcess,
    DWORD dwFlags,
    LPWSTR lpExeName,
    PDWORD lpdwSize
    );



#define QueryFullProcessImageName QueryFullProcessImageNameA






//
// Extended process and thread attribute support
//

#define PROC_THREAD_ATTRIBUTE_NUMBER 0x0000FFFF
#define PROC_THREAD_ATTRIBUTE_THREAD 0x00010000
#define PROC_THREAD_ATTRIBUTE_INPUT 0x00020000
#define PROC_THREAD_ATTRIBUTE_ADDITIVE 0x00040000

typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeExtendedFlags,
    ProcThreadAttributeHandleList,
    ProcThreadAttributeGroupAffinity,
    ProcThreadAttributePreferredNode,
    ProcThreadAttributeIdealProcessor,
    ProcThreadAttributeUmsThread,
    ProcThreadAttributeMitigationPolicy,
    ProcThreadAttributeMax
} PROC_THREAD_ATTRIBUTE_NUM;

#define ProcThreadAttributeValue(Number,Thread,Input,Additive) (((Number) & PROC_THREAD_ATTRIBUTE_NUMBER) | ((Thread != FALSE) ? PROC_THREAD_ATTRIBUTE_THREAD : 0) | ((Input != FALSE) ? PROC_THREAD_ATTRIBUTE_INPUT : 0) | ((Additive != FALSE) ? PROC_THREAD_ATTRIBUTE_ADDITIVE : 0))





#define PROC_THREAD_ATTRIBUTE_PARENT_PROCESS ProcThreadAttributeValue (ProcThreadAttributeParentProcess, FALSE, TRUE, FALSE)

#define PROC_THREAD_ATTRIBUTE_EXTENDED_FLAGS ProcThreadAttributeValue (ProcThreadAttributeExtendedFlags, FALSE, TRUE, TRUE)

#define PROC_THREAD_ATTRIBUTE_HANDLE_LIST ProcThreadAttributeValue (ProcThreadAttributeHandleList, FALSE, TRUE, FALSE)

#define PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY ProcThreadAttributeValue (ProcThreadAttributeGroupAffinity, TRUE, TRUE, FALSE)

#define PROC_THREAD_ATTRIBUTE_PREFERRED_NODE ProcThreadAttributeValue (ProcThreadAttributePreferredNode, FALSE, TRUE, FALSE)

#define PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR ProcThreadAttributeValue (ProcThreadAttributeIdealProcessor, TRUE, TRUE, FALSE)

#define PROC_THREAD_ATTRIBUTE_UMS_THREAD ProcThreadAttributeValue (ProcThreadAttributeUmsThread, TRUE, TRUE, FALSE)

#define PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY ProcThreadAttributeValue (ProcThreadAttributeMitigationPolicy, FALSE, TRUE, FALSE)



#define PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE 0x01
#define PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE 0x02
#define PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE 0x04


BOOL

InitializeProcThreadAttributeList(
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    DWORD dwAttributeCount,
    DWORD dwFlags,
    PSIZE_T lpSize
    );


void

DeleteProcThreadAttributeList(
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );

#define PROC_THREAD_ATTRIBUTE_REPLACE_VALUE 0x00000001


BOOL

UpdateProcThreadAttribute(
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    DWORD dwFlags,
    DWORD_PTR Attribute,
    PVOID lpValue,
    SIZE_T cbSize,
    PVOID lpPreviousValue,
    PSIZE_T lpReturnSize
    );





BOOL

CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

BOOL

CreateProcessW(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );



#define CreateProcess CreateProcessA





BOOL

SetProcessShutdownParameters(
    DWORD dwLevel,
    DWORD dwFlags
    );


BOOL

GetProcessShutdownParameters(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    );


DWORD

GetProcessVersion(
    DWORD ProcessId
    );


void

FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText
    );

void

FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText
    );



#define FatalAppExit FatalAppExitA



void

GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo
    );

void

GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo
    );



#define GetStartupInfo GetStartupInfoA




LPSTR

GetCommandLineA(
    void
    );


LPWSTR

GetCommandLineW(
    void
    );



#define GetCommandLine GetCommandLineA





DWORD

GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );



DWORD

GetEnvironmentVariableW(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    );



#define GetEnvironmentVariable GetEnvironmentVariableA
# 7609 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    );

BOOL

SetEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpValue
    );



#define SetEnvironmentVariable SetEnvironmentVariableA
# 7649 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"



DWORD

ExpandEnvironmentStringsA(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    );



DWORD

ExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );



#define ExpandEnvironmentStrings ExpandEnvironmentStringsA



DWORD

GetFirmwareEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpGuid,
    PVOID pBuffer,
    DWORD nSize
    );

DWORD

GetFirmwareEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpGuid,
    PVOID pBuffer,
    DWORD nSize
    );



#define GetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariableA



BOOL

SetFirmwareEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpGuid,
    PVOID pValue,
    DWORD nSize
    );

BOOL

SetFirmwareEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpGuid,
    PVOID pValue,
    DWORD nSize
    );



#define SetFirmwareEnvironmentVariable SetFirmwareEnvironmentVariableA




void

OutputDebugStringA(
    LPCSTR lpOutputString
    );

void

OutputDebugStringW(
    LPCWSTR lpOutputString
    );



#define OutputDebugString OutputDebugStringA




HRSRC

FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    );


HRSRC

FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    );



#define FindResource FindResourceA




HRSRC

FindResourceExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD wLanguage
    );


HRSRC

FindResourceExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD wLanguage
    );



#define FindResourceEx FindResourceExA



typedef BOOL (* ENUMRESTYPEPROCA)( HMODULE hModule, LPSTR lpType,
 LONG_PTR lParam);
typedef BOOL (* ENUMRESTYPEPROCW)( HMODULE hModule, LPWSTR lpType,
 LONG_PTR lParam);



#define ENUMRESTYPEPROC ENUMRESTYPEPROCA

typedef BOOL (* ENUMRESNAMEPROCA)( HMODULE hModule, LPCSTR lpType,
 LPSTR lpName, LONG_PTR lParam);
typedef BOOL (* ENUMRESNAMEPROCW)( HMODULE hModule, LPCWSTR lpType,
 LPWSTR lpName, LONG_PTR lParam);



#define ENUMRESNAMEPROC ENUMRESNAMEPROCA

typedef BOOL (* ENUMRESLANGPROCA)( HMODULE hModule, LPCSTR lpType,
 LPCSTR lpName, WORD wLanguage, LONG_PTR lParam);
typedef BOOL (* ENUMRESLANGPROCW)( HMODULE hModule, LPCWSTR lpType,
 LPCWSTR lpName, WORD wLanguage, LONG_PTR lParam);



#define ENUMRESLANGPROC ENUMRESLANGPROCA
# 7844 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

EnumResourceTypesA(
    HMODULE hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    LONG_PTR lParam
    );

BOOL

EnumResourceTypesW(
    HMODULE hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    LONG_PTR lParam
    );



#define EnumResourceTypes EnumResourceTypesA



BOOL

EnumResourceNamesA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    LONG_PTR lParam
    );

BOOL

EnumResourceNamesW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    LONG_PTR lParam
    );



#define EnumResourceNames EnumResourceNamesA



BOOL

EnumResourceLanguagesA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    LONG_PTR lParam
    );

BOOL

EnumResourceLanguagesW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    LONG_PTR lParam
    );



#define EnumResourceLanguages EnumResourceLanguagesA


#define RESOURCE_ENUM_LN (0x0001)
#define RESOURCE_ENUM_MUI (0x0002)
#define RESOURCE_ENUM_MUI_SYSTEM (0x0004)
#define RESOURCE_ENUM_VALIDATE (0x0008)
#define RESOURCE_ENUM_MODULE_EXACT (0x0010)


BOOL

EnumResourceTypesExA(
    HMODULE hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

BOOL

EnumResourceTypesExW(
    HMODULE hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );



#define EnumResourceTypesEx EnumResourceTypesExA




BOOL

EnumResourceNamesExA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

BOOL

EnumResourceNamesExW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );



#define EnumResourceNamesEx EnumResourceNamesExA



BOOL

EnumResourceLanguagesExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

BOOL

EnumResourceLanguagesExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );



#define EnumResourceLanguagesEx EnumResourceLanguagesExA



HANDLE

BeginUpdateResourceA(
    LPCSTR pFileName,
    BOOL bDeleteExistingResources
    );

HANDLE

BeginUpdateResourceW(
    LPCWSTR pFileName,
    BOOL bDeleteExistingResources
    );



#define BeginUpdateResource BeginUpdateResourceA



BOOL

UpdateResourceA(
    HANDLE hUpdate,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD wLanguage,
    LPVOID lpData,
    DWORD cb
    );

BOOL

UpdateResourceW(
    HANDLE hUpdate,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD wLanguage,
    LPVOID lpData,
    DWORD cb
    );



#define UpdateResource UpdateResourceA



BOOL

EndUpdateResourceA(
    HANDLE hUpdate,
    BOOL fDiscard
    );

BOOL

EndUpdateResourceW(
    HANDLE hUpdate,
    BOOL fDiscard
    );



#define EndUpdateResource EndUpdateResourceA




ATOM

GlobalAddAtomA(
    LPCSTR lpString
    );

ATOM

GlobalAddAtomW(
    LPCWSTR lpString
    );



#define GlobalAddAtom GlobalAddAtomA



ATOM

GlobalFindAtomA(
    LPCSTR lpString
    );

ATOM

GlobalFindAtomW(
    LPCWSTR lpString
    );



#define GlobalFindAtom GlobalFindAtomA



UINT

GlobalGetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );

UINT

GlobalGetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );



#define GlobalGetAtomName GlobalGetAtomNameA



ATOM

AddAtomA(
    LPCSTR lpString
    );

ATOM

AddAtomW(
    LPCWSTR lpString
    );



#define AddAtom AddAtomA



ATOM

FindAtomA(
    LPCSTR lpString
    );

ATOM

FindAtomW(
    LPCWSTR lpString
    );



#define FindAtom FindAtomA



UINT

GetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );

UINT

GetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );



#define GetAtomName GetAtomNameA



UINT

GetProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault
    );

UINT

GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );



#define GetProfileInt GetProfileIntA



DWORD

GetProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize
    );

DWORD

GetProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
    );



#define GetProfileString GetProfileStringA



BOOL

WriteProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString
    );

BOOL

WriteProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    );



#define WriteProfileString WriteProfileStringA



DWORD

GetProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize
    );

DWORD

GetProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize
    );



#define GetProfileSection GetProfileSectionA



BOOL

WriteProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString
    );

BOOL

WriteProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString
    );



#define WriteProfileSection WriteProfileSectionA



UINT

GetPrivateProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    );

UINT

GetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    );



#define GetPrivateProfileInt GetPrivateProfileIntA
# 8352 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

DWORD

GetPrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );

DWORD

GetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );



#define GetPrivateProfileString GetPrivateProfileStringA
# 8408 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

WritePrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );

BOOL

WritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );



#define WritePrivateProfileString WritePrivateProfileStringA



DWORD

GetPrivateProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );

DWORD

GetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );



#define GetPrivateProfileSection GetPrivateProfileSectionA
# 8480 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

WritePrivateProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );

BOOL

WritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );



#define WritePrivateProfileSection WritePrivateProfileSectionA




DWORD

GetPrivateProfileSectionNamesA(
    LPSTR lpszReturnBuffer,
    DWORD nSize,
    LPCSTR lpFileName
    );

DWORD

GetPrivateProfileSectionNamesW(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    );



#define GetPrivateProfileSectionNames GetPrivateProfileSectionNamesA
# 8547 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

GetPrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    );

BOOL

GetPrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    );



#define GetPrivateProfileStruct GetPrivateProfileStructA
# 8599 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

WritePrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    );

BOOL

WritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    );



#define WritePrivateProfileStruct WritePrivateProfileStructA




UINT

GetDriveTypeA(
    LPCSTR lpRootPathName
    );

UINT

GetDriveTypeW(
    LPCWSTR lpRootPathName
    );



#define GetDriveType GetDriveTypeA



UINT

GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT

GetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );



#define GetSystemDirectory GetSystemDirectoryA



DWORD

GetTempPathA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

DWORD

GetTempPathW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );



#define GetTempPath GetTempPathA



UINT

GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );

UINT

GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );



#define GetTempFileName GetTempFileNameA
# 8732 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

UINT

GetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT

GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );



#define GetWindowsDirectory GetWindowsDirectoryA



UINT

GetSystemWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT

GetSystemWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );



#define GetSystemWindowsDirectory GetSystemWindowsDirectoryA






UINT

GetSystemWow64DirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT

GetSystemWow64DirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );



#define GetSystemWow64Directory GetSystemWow64DirectoryA



BOOLEAN

Wow64EnableWow64FsRedirection (
    BOOLEAN Wow64FsEnableRedirection
    );


BOOL

Wow64DisableWow64FsRedirection (
    PVOID *OldValue
    );


BOOL

Wow64RevertWow64FsRedirection (
    PVOID OlValue
    );


//
// for GetProcAddress
//
typedef UINT (* PGET_SYSTEM_WOW64_DIRECTORY_A)( LPSTR lpBuffer, UINT uSize);
typedef UINT (* PGET_SYSTEM_WOW64_DIRECTORY_W)( LPWSTR lpBuffer, UINT uSize);

//
// GetProcAddress only accepts GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A,
// GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A.
// The others are if you want to use the strings in some other way.
//
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A "GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W L"GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T TEXT("GetSystemWow64DirectoryA")
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A "GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W L"GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T TEXT("GetSystemWow64DirectoryW")






#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T






BOOL

SetCurrentDirectoryA(
    LPCSTR lpPathName
    );

BOOL

SetCurrentDirectoryW(
    LPCWSTR lpPathName
    );



#define SetCurrentDirectory SetCurrentDirectoryA
# 8884 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

DWORD

GetCurrentDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

DWORD

GetCurrentDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );



#define GetCurrentDirectory GetCurrentDirectoryA
# 8926 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

SetDllDirectoryA(
    LPCSTR lpPathName
    );

BOOL

SetDllDirectoryW(
    LPCWSTR lpPathName
    );



#define SetDllDirectory SetDllDirectoryA



DWORD

GetDllDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

DWORD

GetDllDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );



#define GetDllDirectory GetDllDirectoryA




#define BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE 0x1
#define BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE 0x10000
#define BASE_SEARCH_PATH_PERMANENT 0x8000
#define BASE_SEARCH_PATH_INVALID_FLAGS ~0x18001


BOOL

SetSearchPathMode (
    DWORD Flags
    );


BOOL

GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );

BOOL

GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );



#define GetDiskFreeSpace GetDiskFreeSpaceA



BOOL

GetDiskFreeSpaceExA(
    LPCSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

BOOL

GetDiskFreeSpaceExW(
    LPCWSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );



#define GetDiskFreeSpaceEx GetDiskFreeSpaceExA



BOOL

CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL

CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );



#define CreateDirectory CreateDirectoryA
# 9068 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

CreateDirectoryExA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL

CreateDirectoryExW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );



#define CreateDirectoryEx CreateDirectoryExA





BOOL

CreateDirectoryTransactedA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );

BOOL

CreateDirectoryTransactedW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );



#define CreateDirectoryTransacted CreateDirectoryTransactedA





BOOL

RemoveDirectoryA(
    LPCSTR lpPathName
    );

BOOL

RemoveDirectoryW(
    LPCWSTR lpPathName
    );



#define RemoveDirectory RemoveDirectoryA





BOOL

RemoveDirectoryTransactedA(
    LPCSTR lpPathName,
    HANDLE hTransaction
    );

BOOL

RemoveDirectoryTransactedW(
    LPCWSTR lpPathName,
    HANDLE hTransaction
    );



#define RemoveDirectoryTransacted RemoveDirectoryTransactedA





DWORD

GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

DWORD

GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );



#define GetFullPathName GetFullPathNameA




DWORD

GetFullPathNameTransactedA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart,
    HANDLE hTransaction
    );

DWORD

GetFullPathNameTransactedW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart,
    HANDLE hTransaction
    );



#define GetFullPathNameTransacted GetFullPathNameTransactedA




#define DDD_RAW_TARGET_PATH 0x00000001
#define DDD_REMOVE_DEFINITION 0x00000002
#define DDD_EXACT_MATCH_ON_REMOVE 0x00000004
#define DDD_NO_BROADCAST_SYSTEM 0x00000008
#define DDD_LUID_BROADCAST_DRIVE 0x00000010


BOOL

DefineDosDeviceA(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPCSTR lpTargetPath
    );

BOOL

DefineDosDeviceW(
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPCWSTR lpTargetPath
    );



#define DefineDosDevice DefineDosDeviceA



DWORD

QueryDosDeviceA(
    LPCSTR lpDeviceName,
    LPSTR lpTargetPath,
    DWORD ucchMax
    );

DWORD

QueryDosDeviceW(
    LPCWSTR lpDeviceName,
    LPWSTR lpTargetPath,
    DWORD ucchMax
    );



#define QueryDosDevice QueryDosDeviceA


#define EXPAND_LOCAL_DRIVES 



HANDLE

CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );


HANDLE

CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );



#define CreateFile CreateFileA






HANDLE

CreateFileTransactedA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    HANDLE hTransaction,
    PUSHORT pusMiniVersion,
    PVOID lpExtendedParameter
    );


HANDLE

CreateFileTransactedW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    HANDLE hTransaction,
    PUSHORT pusMiniVersion,
    PVOID lpExtendedParameter
    );



#define CreateFileTransacted CreateFileTransactedA









HANDLE

ReOpenFile(
    HANDLE hOriginalFile,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    DWORD dwFlagsAndAttributes
    );




BOOL

SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );

BOOL

SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );



#define SetFileAttributes SetFileAttributesA



DWORD

GetFileAttributesA(
    LPCSTR lpFileName
    );

DWORD

GetFileAttributesW(
    LPCWSTR lpFileName
    );



#define GetFileAttributes GetFileAttributesA





BOOL

SetFileAttributesTransactedA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes,
    HANDLE hTransaction
    );

BOOL

SetFileAttributesTransactedW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes,
    HANDLE hTransaction
    );



#define SetFileAttributesTransacted SetFileAttributesTransactedA




typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;




BOOL

GetFileAttributesTransactedA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation,
    HANDLE hTransaction
    );

BOOL

GetFileAttributesTransactedW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation,
    HANDLE hTransaction
    );



#define GetFileAttributesTransacted GetFileAttributesTransactedA





BOOL

GetFileAttributesExA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );

BOOL

GetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );



#define GetFileAttributesEx GetFileAttributesExA



DWORD

GetCompressedFileSizeA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );

DWORD

GetCompressedFileSizeW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );



#define GetCompressedFileSize GetCompressedFileSizeA





DWORD

GetCompressedFileSizeTransactedA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh,
    HANDLE hTransaction
    );

DWORD

GetCompressedFileSizeTransactedW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh,
    HANDLE hTransaction
    );



#define GetCompressedFileSizeTransacted GetCompressedFileSizeTransactedA





BOOL

DeleteFileA(
    LPCSTR lpFileName
    );

BOOL

DeleteFileW(
    LPCWSTR lpFileName
    );



#define DeleteFile DeleteFileA





BOOL

DeleteFileTransactedA(
    LPCSTR lpFileName,
    HANDLE hTransaction
    );

BOOL

DeleteFileTransactedW(
    LPCWSTR lpFileName,
    HANDLE hTransaction
    );



#define DeleteFileTransacted DeleteFileTransactedA
# 9583 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

CheckNameLegalDOS8Dot3A(
    LPCSTR lpName,
    LPSTR lpOemName,
    DWORD OemNameSize,
    PBOOL pbNameContainsSpaces ,
    PBOOL pbNameLegal
    );

BOOL

CheckNameLegalDOS8Dot3W(
    LPCWSTR lpName,
    LPSTR lpOemName,
    DWORD OemNameSize,
    PBOOL pbNameContainsSpaces ,
    PBOOL pbNameLegal
    );



#define CheckNameLegalDOS8Dot3 CheckNameLegalDOS8Dot3A





typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;

typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;

#define FIND_FIRST_EX_CASE_SENSITIVE 0x00000001
#define FIND_FIRST_EX_LARGE_FETCH 0x00000002



HANDLE

FindFirstFileExA(
    LPCSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    );


HANDLE

FindFirstFileExW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    );



#define FindFirstFileEx FindFirstFileExA






HANDLE

FindFirstFileTransactedA(
    LPCSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags,
    HANDLE hTransaction
    );


HANDLE

FindFirstFileTransactedW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags,
    HANDLE hTransaction
    );



#define FindFirstFileTransacted FindFirstFileTransactedA








HANDLE

FindFirstFileA(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    );


HANDLE

FindFirstFileW(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );



#define FindFirstFile FindFirstFileA



BOOL

FindNextFileA(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    );

BOOL

FindNextFileW(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    );



#define FindNextFile FindNextFileA




DWORD

SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

DWORD

SearchPathW(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );



#define SearchPath SearchPathA



BOOL

CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    );

BOOL

CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    );



#define CopyFile CopyFileA
# 9812 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
typedef
DWORD
( *LPPROGRESS_ROUTINE)(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData
    );


BOOL

CopyFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags
    );

BOOL

CopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags
    );



#define CopyFileEx CopyFileExA





BOOL

CopyFileTransactedA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags,
    HANDLE hTransaction
    );

BOOL

CopyFileTransactedW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    LPBOOL pbCancel,
    DWORD dwCopyFlags,
    HANDLE hTransaction
    );



#define CopyFileTransacted CopyFileTransactedA






BOOL

MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );

BOOL

MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    );



#define MoveFile MoveFileA
# 9929 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    );

BOOL

MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );



#define MoveFileEx MoveFileExA




BOOL

MoveFileWithProgressA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags
    );

BOOL

MoveFileWithProgressW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags
    );



#define MoveFileWithProgress MoveFileWithProgressA





BOOL

MoveFileTransactedA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags,
    HANDLE hTransaction
    );

BOOL

MoveFileTransactedW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData,
    DWORD dwFlags,
    HANDLE hTransaction
    );



#define MoveFileTransacted MoveFileTransactedA



#define MOVEFILE_REPLACE_EXISTING 0x00000001
#define MOVEFILE_COPY_ALLOWED 0x00000002
#define MOVEFILE_DELAY_UNTIL_REBOOT 0x00000004
#define MOVEFILE_WRITE_THROUGH 0x00000008

#define MOVEFILE_CREATE_HARDLINK 0x00000010
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE 0x00000020







BOOL

ReplaceFileA(
    LPCSTR lpReplacedFileName,
    LPCSTR lpReplacementFileName,
    LPCSTR lpBackupFileName,
    DWORD dwReplaceFlags,
    LPVOID lpExclude,
    LPVOID lpReserved
    );

BOOL

ReplaceFileW(
    LPCWSTR lpReplacedFileName,
    LPCWSTR lpReplacementFileName,
    LPCWSTR lpBackupFileName,
    DWORD dwReplaceFlags,
    LPVOID lpExclude,
    LPVOID lpReserved
    );



#define ReplaceFile ReplaceFileA





//
// API call to create hard links.
//


BOOL

CreateHardLinkA(
    LPCSTR lpFileName,
    LPCSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL

CreateHardLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );



#define CreateHardLink CreateHardLinkA





//
// API call to create hard links.
//


BOOL

CreateHardLinkTransactedA(
    LPCSTR lpFileName,
    LPCSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );

BOOL

CreateHardLinkTransactedW(
    LPCWSTR lpFileName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    HANDLE hTransaction
    );



#define CreateHardLinkTransacted CreateHardLinkTransactedA







//
// API call to enumerate for streams within a file
//

typedef enum _STREAM_INFO_LEVELS {

    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel

} STREAM_INFO_LEVELS;

typedef struct _WIN32_FIND_STREAM_DATA {

    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ 260 + 36 ];

} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;



HANDLE

FindFirstStreamW(
    LPCWSTR lpFileName,
    STREAM_INFO_LEVELS InfoLevel,
    LPVOID lpFindStreamData,
    DWORD dwFlags
    );



HANDLE

FindFirstStreamTransactedW (
    LPCWSTR lpFileName,
    STREAM_INFO_LEVELS InfoLevel,
    LPVOID lpFindStreamData,
    DWORD dwFlags,
    HANDLE hTransaction
    );



BOOL

FindNextStreamW(
    HANDLE hFindStream,
    LPVOID lpFindStreamData
    );





HANDLE

FindFirstFileNameW (
    LPCWSTR lpFileName,
    DWORD dwFlags,
    LPDWORD StringLength,
    PWCHAR LinkName
    );


BOOL

FindNextFileNameW (
    HANDLE hFindStream,
    LPDWORD StringLength,
    PWCHAR LinkName
    );


HANDLE

FindFirstFileNameTransactedW (
    LPCWSTR lpFileName,
    DWORD dwFlags,
    LPDWORD StringLength,
    PWCHAR LinkName,
    HANDLE hTransaction
    );






HANDLE

CreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );


HANDLE

CreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );



#define CreateNamedPipe CreateNamedPipeA



BOOL

GetNamedPipeHandleStateA(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPSTR lpUserName,
    DWORD nMaxUserNameSize
    );

BOOL

GetNamedPipeHandleStateW(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    );



#define GetNamedPipeHandleState GetNamedPipeHandleStateA



BOOL

CallNamedPipeA(
    LPCSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );

BOOL

CallNamedPipeW(
    LPCWSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );



#define CallNamedPipe CallNamedPipeA



BOOL

WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    );

BOOL

WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    );



#define WaitNamedPipe WaitNamedPipeA


typedef enum {
    PipeAttribute,
    PipeConnectionAttribute,
    PipeHandleAttribute
} PIPE_ATTRIBUTE_TYPE;


BOOL

GetNamedPipeAttribute(
    HANDLE Pipe,
    PIPE_ATTRIBUTE_TYPE AttributeType,
    PSTR AttributeName,
    PVOID AttributeValue,
    PSIZE_T AttributeValueLength
    );


BOOL

SetNamedPipeAttribute(
    HANDLE Pipe,
    PIPE_ATTRIBUTE_TYPE AttributeType,
    PSTR AttributeName,
    PVOID AttributeValue,
    SIZE_T AttributeValueLength
    );


BOOL

GetNamedPipeClientComputerNameA(
    HANDLE Pipe,
    LPSTR ClientComputerName,
    ULONG ClientComputerNameLength
    );

BOOL

GetNamedPipeClientComputerNameW(
    HANDLE Pipe,
    LPWSTR ClientComputerName,
    ULONG ClientComputerNameLength
    );



#define GetNamedPipeClientComputerName GetNamedPipeClientComputerNameA



BOOL

GetNamedPipeClientProcessId(
    HANDLE Pipe,
    PULONG ClientProcessId
    );


BOOL

GetNamedPipeClientSessionId(
    HANDLE Pipe,
    PULONG ClientSessionId
    );


BOOL

GetNamedPipeServerProcessId(
    HANDLE Pipe,
    PULONG ServerProcessId
    );


BOOL

GetNamedPipeServerSessionId(
    HANDLE Pipe,
    PULONG ServerSessionId
    );


BOOL

SetVolumeLabelA(
    LPCSTR lpRootPathName,
    LPCSTR lpVolumeName
    );

BOOL

SetVolumeLabelW(
    LPCWSTR lpRootPathName,
    LPCWSTR lpVolumeName
    );



#define SetVolumeLabel SetVolumeLabelA



void

SetFileApisToOEM( void );


void

SetFileApisToANSI( void );


BOOL

AreFileApisANSI( void );


BOOL

GetVolumeInformationA(
    LPCSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );

BOOL

GetVolumeInformationW(
    LPCWSTR lpRootPathName,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );



#define GetVolumeInformation GetVolumeInformationA




BOOL

GetVolumeInformationByHandleW(
    HANDLE hFile,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );



BOOL

CancelSynchronousIo(
    HANDLE hThread
    );


BOOL

CancelIoEx(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped
    );


BOOL

CancelIo(
    HANDLE hFile
    );


BOOL

SetFileBandwidthReservation(
    HANDLE hFile,
    DWORD nPeriodMilliseconds,
    DWORD nBytesPerPeriod,
    BOOL bDiscardable,
    LPDWORD lpTransferSize,
    LPDWORD lpNumOutstandingRequests
    );


BOOL

GetFileBandwidthReservation(
    HANDLE hFile,
    LPDWORD lpPeriodMilliseconds,
    LPDWORD lpBytesPerPeriod,
    LPBOOL pDiscardable,
    LPDWORD lpTransferSize,
    LPDWORD lpNumOutstandingRequests
    );

//
// Event logging APIs
//


BOOL

ClearEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );

BOOL

ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );



#define ClearEventLog ClearEventLogA



BOOL

BackupEventLogA (
    HANDLE hEventLog,
    LPCSTR lpBackupFileName
    );

BOOL

BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR lpBackupFileName
    );



#define BackupEventLog BackupEventLogA



BOOL

CloseEventLog (
    HANDLE hEventLog
    );


BOOL

DeregisterEventSource (
    HANDLE hEventLog
    );


BOOL

NotifyChangeEventLog(
    HANDLE hEventLog,
    HANDLE hEvent
    );


BOOL

GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    );


BOOL

GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    );



HANDLE

OpenEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );


HANDLE

OpenEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );



#define OpenEventLog OpenEventLogA




HANDLE

RegisterEventSourceA (
    LPCSTR lpUNCServerName,
    LPCSTR lpSourceName
    );


HANDLE

RegisterEventSourceW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpSourceName
    );



#define RegisterEventSource RegisterEventSourceA




HANDLE

OpenBackupEventLogA (
    LPCSTR lpUNCServerName,
    LPCSTR lpFileName
    );


HANDLE

OpenBackupEventLogW (
    LPCWSTR lpUNCServerName,
    LPCWSTR lpFileName
    );



#define OpenBackupEventLog OpenBackupEventLogA



BOOL

ReadEventLogA (
    HANDLE hEventLog,
    DWORD dwReadFlags,
    DWORD dwRecordOffset,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    DWORD *pnBytesRead,
    DWORD *pnMinNumberOfBytesNeeded
    );

BOOL

ReadEventLogW (
    HANDLE hEventLog,
    DWORD dwReadFlags,
    DWORD dwRecordOffset,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    DWORD *pnBytesRead,
    DWORD *pnMinNumberOfBytesNeeded
    );



#define ReadEventLog ReadEventLogA



BOOL

ReportEventA (
    HANDLE hEventLog,
    WORD wType,
    WORD wCategory,
    DWORD dwEventID,
    PSID lpUserSid,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCSTR *lpStrings,
    LPVOID lpRawData
    );

BOOL

ReportEventW (
    HANDLE hEventLog,
    WORD wType,
    WORD wCategory,
    DWORD dwEventID,
    PSID lpUserSid,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCWSTR *lpStrings,
    LPVOID lpRawData
    );



#define ReportEvent ReportEventA



#define EVENTLOG_FULL_INFO 0

typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;


BOOL

GetEventLogInformation (
    HANDLE hEventLog,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );

//
//
// Security APIs
//



BOOL

DuplicateToken(
    HANDLE ExistingTokenHandle,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    PHANDLE DuplicateTokenHandle
    );


BOOL

GetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );


BOOL

ImpersonateNamedPipeClient(
    HANDLE hNamedPipe
    );


BOOL

ImpersonateSelf(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );



BOOL

RevertToSelf (
    void
    );


BOOL

SetThreadToken (
    PHANDLE Thread,
    HANDLE Token
    );


BOOL

AccessCheck (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    );



BOOL

AccessCheckByType (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    );


BOOL

AccessCheckByTypeResultList (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID PrincipalSelfSid,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList
    );




BOOL

OpenProcessToken (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    );



BOOL

OpenThreadToken (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    );



BOOL

GetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    );



BOOL

SetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength
    );



BOOL

AdjustTokenPrivileges (
    HANDLE TokenHandle,
    BOOL DisableAllPrivileges,
    PTOKEN_PRIVILEGES NewState,
    DWORD BufferLength,
    PTOKEN_PRIVILEGES PreviousState,
    PDWORD ReturnLength
    );



BOOL

AdjustTokenGroups (
    HANDLE TokenHandle,
    BOOL ResetToDefault,
    PTOKEN_GROUPS NewState,
    DWORD BufferLength,
    PTOKEN_GROUPS PreviousState,
    PDWORD ReturnLength
    );



BOOL

PrivilegeCheck (
    HANDLE ClientToken,
    PPRIVILEGE_SET RequiredPrivileges,
    LPBOOL pfResult
    );



BOOL

AccessCheckAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );

BOOL

AccessCheckAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );



#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmA





BOOL

AccessCheckByTypeAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );

BOOL

AccessCheckByTypeAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );



#define AccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmA



BOOL

AccessCheckByTypeResultListAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );

BOOL

AccessCheckByTypeResultListAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );



#define AccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmA



BOOL

AccessCheckByTypeResultListAndAuditAlarmByHandleA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );

BOOL

AccessCheckByTypeResultListAndAuditAlarmByHandleW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    );



#define AccessCheckByTypeResultListAndAuditAlarmByHandle AccessCheckByTypeResultListAndAuditAlarmByHandleA





BOOL

ObjectOpenAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );

BOOL

ObjectOpenAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );



#define ObjectOpenAuditAlarm ObjectOpenAuditAlarmA




BOOL

ObjectPrivilegeAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );

BOOL

ObjectPrivilegeAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );



#define ObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmA




BOOL

ObjectCloseAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );

BOOL

ObjectCloseAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );



#define ObjectCloseAuditAlarm ObjectCloseAuditAlarmA




BOOL

ObjectDeleteAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );

BOOL

ObjectDeleteAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );



#define ObjectDeleteAuditAlarm ObjectDeleteAuditAlarmA




BOOL

PrivilegedServiceAuditAlarmA (
    LPCSTR SubsystemName,
    LPCSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );

BOOL

PrivilegedServiceAuditAlarmW (
    LPCWSTR SubsystemName,
    LPCWSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );



#define PrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmA








BOOL

IsWellKnownSid (
    PSID pSid,
    WELL_KNOWN_SID_TYPE WellKnownSidType
    );


 BOOL

CreateWellKnownSid(
    WELL_KNOWN_SID_TYPE WellKnownSidType,
    PSID DomainSid,
    PSID pSid,
    DWORD *cbSid
    );


 BOOL

EqualDomainSid(
    PSID pSid1,
    PSID pSid2,
    BOOL *pfEqual
    );


 BOOL

GetWindowsAccountDomainSid(
    PSID pSid,
    PSID pDomainSid,
    DWORD* cbDomainSid
    );




BOOL

IsValidSid (
    PSID pSid
    );



BOOL

EqualSid (
    PSID pSid1,
    PSID pSid2
    );



BOOL

EqualPrefixSid (
    PSID pSid1,
    PSID pSid2
    );



DWORD

GetSidLengthRequired (
    UCHAR nSubAuthorityCount
    );



BOOL

AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    );


PVOID

FreeSid(
    PSID pSid
    );


BOOL

InitializeSid (
    PSID Sid,
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount
    );




PSID_IDENTIFIER_AUTHORITY

GetSidIdentifierAuthority (
    PSID pSid
    );




PDWORD

GetSidSubAuthority (
    PSID pSid,
    DWORD nSubAuthority
    );




PUCHAR

GetSidSubAuthorityCount (
    PSID pSid
    );



DWORD

GetLengthSid (
    PSID pSid
    );



BOOL

CopySid (
    DWORD nDestinationSidLength,
    PSID pDestinationSid,
    PSID pSourceSid
    );



BOOL

AreAllAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );



BOOL

AreAnyAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );



void

MapGenericMask (
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping
    );



BOOL

IsValidAcl (
    PACL pAcl
    );



BOOL

InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    );



BOOL

GetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );



BOOL

SetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );



BOOL

AddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    LPVOID pAceList,
    DWORD nAceListLength
    );



BOOL

DeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    );



BOOL

GetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    LPVOID *pAce
    );



BOOL

AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );



BOOL

AddAccessAllowedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    );




BOOL

AddMandatoryAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD MandatoryPolicy,
    PSID pLabelSid
    );




BOOL

AddConditionalAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    UCHAR AceType,
    DWORD AccessMask,
    PSID pSid,
    PWCHAR ConditionStr,
    DWORD *ReturnLength
    );



BOOL

AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );



BOOL

AddAccessDeniedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    );



BOOL

AddAuditAccessAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );



BOOL

AddAuditAccessAceEx(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );


BOOL

AddAccessAllowedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    );


BOOL

AddAccessDeniedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    );


BOOL

AddAuditAccessObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );



BOOL

FindFirstFreeAce (
    PACL pAcl,
    LPVOID *pAce
    );



BOOL

InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    );



BOOL

IsValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


BOOL

IsValidRelativeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    SECURITY_INFORMATION RequiredInformation
    );


DWORD

GetSecurityDescriptorLength (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );



BOOL

GetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL pControl,
    LPDWORD lpdwRevision
    );



BOOL

SetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );



BOOL

SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl,
    BOOL bDaclDefaulted
    );



BOOL

GetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbDaclPresent,
    PACL *pDacl,
    LPBOOL lpbDaclDefaulted
    );



BOOL

SetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bSaclPresent,
    PACL pSacl,
    BOOL bSaclDefaulted
    );



BOOL

GetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbSaclPresent,
    PACL *pSacl,
    LPBOOL lpbSaclDefaulted
    );



BOOL

SetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pOwner,
    BOOL bOwnerDefaulted
    );



BOOL

GetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pOwner,
    LPBOOL lpbOwnerDefaulted
    );



BOOL

SetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pGroup,
    BOOL bGroupDefaulted
    );



BOOL

GetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pGroup,
    LPBOOL lpbGroupDefaulted
    );



DWORD

SetSecurityDescriptorRMControl(
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PUCHAR RMControl
    );


DWORD

GetSecurityDescriptorRMControl(
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PUCHAR RMControl
    );


BOOL

CreatePrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    BOOL IsDirectoryObject,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );



BOOL

ConvertToAutoInheritPrivateObjectSecurity(
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    GUID *ObjectType,
    BOOLEAN IsDirectoryObject,
    PGENERIC_MAPPING GenericMapping
    );


BOOL

CreatePrivateObjectSecurityEx (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID *ObjectType,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );


BOOL

CreatePrivateObjectSecurityWithMultipleInheritance (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID **ObjectTypes,
    ULONG GuidCount,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );



BOOL

SetPrivateObjectSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );



BOOL

SetPrivateObjectSecurityEx (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    ULONG AutoInheritFlags,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );



 BOOL

GetPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ObjectDescriptor,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ResultantDescriptor,
    DWORD DescriptorLength,
    PDWORD ReturnLength
    );



BOOL

DestroyPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    );



 BOOL

MakeSelfRelativeSD (
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferLength
    );



 BOOL

MakeAbsoluteSD (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    PACL pDacl,
    LPDWORD lpdwDaclSize,
    PACL pSacl,
    LPDWORD lpdwSaclSize,
    PSID pOwner,
    LPDWORD lpdwOwnerSize,
    PSID pPrimaryGroup,
    LPDWORD lpdwPrimaryGroupSize
    );



 BOOL

MakeAbsoluteSD2 (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferSize
    );


void

QuerySecurityAccessMask(
    SECURITY_INFORMATION SecurityInformation,
    LPDWORD DesiredAccess
    );


void

SetSecurityAccessMask(
    SECURITY_INFORMATION SecurityInformation,
    LPDWORD DesiredAccess
    );


BOOL

SetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL

SetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );



#define SetFileSecurity SetFileSecurityA




BOOL

GetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );

BOOL

GetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );



#define GetFileSecurity GetFileSecurityA




BOOL

SetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );



HANDLE

FindFirstChangeNotificationA(
    LPCSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );


HANDLE

FindFirstChangeNotificationW(
    LPCWSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );



#define FindFirstChangeNotification FindFirstChangeNotificationA



BOOL

FindNextChangeNotification(
    HANDLE hChangeHandle
    );


BOOL

FindCloseChangeNotification(
    HANDLE hChangeHandle
    );



BOOL

ReadDirectoryChangesW(
    HANDLE hDirectory,
    LPVOID lpBuffer,
    DWORD nBufferLength,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );



BOOL

VirtualLock(
    LPVOID lpAddress,
    SIZE_T dwSize
    );


BOOL

VirtualUnlock(
    LPVOID lpAddress,
    SIZE_T dwSize
    );



LPVOID

MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    );





LPVOID

MapViewOfFileExNuma(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap,
    LPVOID lpBaseAddress,
    DWORD nndPreferred
    );




BOOL

SetPriorityClass(
    HANDLE hProcess,
    DWORD dwPriorityClass
    );


DWORD

GetPriorityClass(
    HANDLE hProcess
    );


BOOL

IsBadReadPtr(
    const void *lp,
    UINT_PTR ucb
    );


BOOL

IsBadWritePtr(
    LPVOID lp,
    UINT_PTR ucb
    );


BOOL

IsBadHugeReadPtr(
    const void *lp,
    UINT_PTR ucb
    );


BOOL

IsBadHugeWritePtr(
    LPVOID lp,
    UINT_PTR ucb
    );


BOOL

IsBadCodePtr(
    FARPROC lpfn
    );


BOOL

IsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR ucchMax
    );

BOOL

IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR ucchMax
    );



#define IsBadStringPtr IsBadStringPtrA



 BOOL

LookupAccountSidA(
    LPCSTR lpSystemName,
    PSID Sid,
    LPSTR Name,
    LPDWORD cchName,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );

 BOOL

LookupAccountSidW(
    LPCWSTR lpSystemName,
    PSID Sid,
    LPWSTR Name,
    LPDWORD cchName,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );



#define LookupAccountSid LookupAccountSidA



 BOOL

LookupAccountSidLocalA(
    PSID Sid,
    LPSTR Name,
    LPDWORD cchName,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );

 BOOL

LookupAccountSidLocalW(
    PSID Sid,
    LPWSTR Name,
    LPDWORD cchName,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );



#define LookupAccountSidLocal LookupAccountSidLocalA



 BOOL

LookupAccountNameA(
    LPCSTR lpSystemName,
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );

 BOOL

LookupAccountNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );



#define LookupAccountName LookupAccountNameA



 BOOL

LookupAccountNameLocalA(
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );

 BOOL

LookupAccountNameLocalW(
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    );



#define LookupAccountNameLocal LookupAccountNameLocalA



BOOL

LookupPrivilegeValueA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    PLUID lpLuid
    );

BOOL

LookupPrivilegeValueW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID lpLuid
    );



#define LookupPrivilegeValue LookupPrivilegeValueA



 BOOL

LookupPrivilegeNameA(
    LPCSTR lpSystemName,
    PLUID lpLuid,
    LPSTR lpName,
    LPDWORD cchName
    );

 BOOL

LookupPrivilegeNameW(
    LPCWSTR lpSystemName,
    PLUID lpLuid,
    LPWSTR lpName,
    LPDWORD cchName
    );



#define LookupPrivilegeName LookupPrivilegeNameA



 BOOL

LookupPrivilegeDisplayNameA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    LPSTR lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    );

 BOOL

LookupPrivilegeDisplayNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    LPWSTR lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    );



#define LookupPrivilegeDisplayName LookupPrivilegeDisplayNameA



BOOL

AllocateLocallyUniqueId(
    PLUID Luid
    );


BOOL

BuildCommDCBA(
    LPCSTR lpDef,
    LPDCB lpDCB
    );

BOOL

BuildCommDCBW(
    LPCWSTR lpDef,
    LPDCB lpDCB
    );



#define BuildCommDCB BuildCommDCBA



BOOL

BuildCommDCBAndTimeoutsA(
    LPCSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );

BOOL

BuildCommDCBAndTimeoutsW(
    LPCWSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );



#define BuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsA



BOOL

CommConfigDialogA(
    LPCSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );

BOOL

CommConfigDialogW(
    LPCWSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );



#define CommConfigDialog CommConfigDialogA



BOOL

GetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );

BOOL

GetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );



#define GetDefaultCommConfig GetDefaultCommConfigA



BOOL

SetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );

BOOL

SetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );



#define SetDefaultCommConfig SetDefaultCommConfigA



#define MAX_COMPUTERNAME_LENGTH 15






BOOL

GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );


BOOL

GetComputerNameW (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );



#define GetComputerName GetComputerNameA



BOOL

SetComputerNameA (
    LPCSTR lpComputerName
    );

BOOL

SetComputerNameW (
    LPCWSTR lpComputerName
    );



#define SetComputerName SetComputerNameA





typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;



BOOL

GetComputerNameExA (
    COMPUTER_NAME_FORMAT NameType,
    LPSTR lpBuffer,
    LPDWORD nSize
    );


BOOL

GetComputerNameExW (
    COMPUTER_NAME_FORMAT NameType,
    LPWSTR lpBuffer,
    LPDWORD nSize
    );



#define GetComputerNameEx GetComputerNameExA



BOOL

SetComputerNameExA (
    COMPUTER_NAME_FORMAT NameType,
    LPCSTR lpBuffer
    );

BOOL

SetComputerNameExW (
    COMPUTER_NAME_FORMAT NameType,
    LPCWSTR lpBuffer
    );



#define SetComputerNameEx SetComputerNameExA





BOOL

DnsHostnameToComputerNameA (
    LPCSTR Hostname,
    LPSTR ComputerName,
    LPDWORD nSize
    );


BOOL

DnsHostnameToComputerNameW (
    LPCWSTR Hostname,
    LPWSTR ComputerName,
    LPDWORD nSize
    );



#define DnsHostnameToComputerName DnsHostnameToComputerNameA





BOOL

GetUserNameA (
    LPSTR lpBuffer,
    LPDWORD pcbBuffer
    );

BOOL

GetUserNameW (
    LPWSTR lpBuffer,
    LPDWORD pcbBuffer
    );



#define GetUserName GetUserNameA


//
// Logon Support APIs
//

#define LOGON32_LOGON_INTERACTIVE 2
#define LOGON32_LOGON_NETWORK 3
#define LOGON32_LOGON_BATCH 4
#define LOGON32_LOGON_SERVICE 5
#define LOGON32_LOGON_UNLOCK 7

#define LOGON32_LOGON_NETWORK_CLEARTEXT 8
#define LOGON32_LOGON_NEW_CREDENTIALS 9


#define LOGON32_PROVIDER_DEFAULT 0
#define LOGON32_PROVIDER_WINNT35 1

#define LOGON32_PROVIDER_WINNT40 2


#define LOGON32_PROVIDER_WINNT50 3


#define LOGON32_PROVIDER_VIRTUAL 4





BOOL

LogonUserA (
    LPCSTR lpszUsername,
    LPCSTR lpszDomain,
    LPCSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );

BOOL

LogonUserW (
    LPCWSTR lpszUsername,
    LPCWSTR lpszDomain,
    LPCWSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );



#define LogonUser LogonUserA



BOOL

LogonUserExA (
    LPCSTR lpszUsername,
    LPCSTR lpszDomain,
    LPCSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken,
    PSID *ppLogonSid,
    PVOID *ppProfileBuffer,
    LPDWORD pdwProfileLength,
    PQUOTA_LIMITS pQuotaLimits
    );

BOOL

LogonUserExW (
    LPCWSTR lpszUsername,
    LPCWSTR lpszDomain,
    LPCWSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken,
    PSID *ppLogonSid,
    PVOID *ppProfileBuffer,
    LPDWORD pdwProfileLength,
    PQUOTA_LIMITS pQuotaLimits
    );



#define LogonUserEx LogonUserExA
# 12774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"

BOOL

ImpersonateLoggedOnUser(
    HANDLE hToken
    );


BOOL

CreateProcessAsUserA (
    HANDLE hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

BOOL

CreateProcessAsUserW (
    HANDLE hToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );



#define CreateProcessAsUser CreateProcessAsUserA





//
// LogonFlags
//
#define LOGON_WITH_PROFILE 0x00000001
#define LOGON_NETCREDENTIALS_ONLY 0x00000002
#define LOGON_ZERO_PASSWORD_BUFFER 0x80000000


 BOOL

CreateProcessWithLogonW(
    LPCWSTR lpUsername,
    LPCWSTR lpDomain,
    LPCWSTR lpPassword,
    DWORD dwLogonFlags,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
      );


 BOOL

CreateProcessWithTokenW(
    HANDLE hToken,
    DWORD dwLogonFlags,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
      );




BOOL

ImpersonateAnonymousToken(
    HANDLE ThreadHandle
    );


BOOL

DuplicateTokenEx(
    HANDLE hExistingToken,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpTokenAttributes,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    TOKEN_TYPE TokenType,
    PHANDLE phNewToken);


BOOL

CreateRestrictedToken(
    HANDLE ExistingTokenHandle,
    DWORD Flags,
    DWORD DisableSidCount,
    PSID_AND_ATTRIBUTES SidsToDisable,
    DWORD DeletePrivilegeCount,
    PLUID_AND_ATTRIBUTES PrivilegesToDelete,
    DWORD RestrictedSidCount,
    PSID_AND_ATTRIBUTES SidsToRestrict,
    PHANDLE NewTokenHandle
    );



BOOL

IsTokenRestricted(
    HANDLE TokenHandle
    );


BOOL

IsTokenUntrusted(
    HANDLE TokenHandle
    );


BOOL

CheckTokenMembership(
    HANDLE TokenHandle,
    PSID SidToCheck,
    PBOOL IsMember
    );

//
// Thread pool API's
//



typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;


BOOL

RegisterWaitForSingleObject(
    PHANDLE phNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );


HANDLE

RegisterWaitForSingleObjectEx(
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );



BOOL

UnregisterWait(
    HANDLE WaitHandle
    );



BOOL

UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent
    );


BOOL

QueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    ULONG Flags
    );


BOOL

BindIoCompletionCallback (
    HANDLE FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    ULONG Flags
    );



HANDLE

CreateTimerQueue(
    void
    );


BOOL

CreateTimerQueueTimer(
    PHANDLE phNewTimer,
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    ULONG Flags
    ) ;



BOOL

ChangeTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    ULONG DueTime,
    ULONG Period
    );



BOOL

DeleteTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    HANDLE CompletionEvent
    );



BOOL

DeleteTimerQueueEx(
    HANDLE TimerQueue,
    HANDLE CompletionEvent
    );


HANDLE

SetTimerQueueTimer(
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    BOOL PreferIo
    );



BOOL

CancelTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer
    );



BOOL

DeleteTimerQueue(
    HANDLE TimerQueue
    );



typedef void ( *PTP_WIN32_IO_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance,
    PVOID Context,
    PVOID Overlapped,
    ULONG IoResult,
    ULONG_PTR NumberOfBytesTransferred,
    PTP_IO Io
    );




PTP_POOL

CreateThreadpool(
    PVOID reserved
    );


void

SetThreadpoolThreadMaximum(
    PTP_POOL ptpp,
    DWORD cthrdMost
    );


BOOL

SetThreadpoolThreadMinimum(
    PTP_POOL ptpp,
    DWORD cthrdMic
    );


BOOL

SetThreadpoolStackInformation(
    PTP_POOL ptpp,
    PTP_POOL_STACK_INFORMATION ptpsi
    );


BOOL

QueryThreadpoolStackInformation(
    PTP_POOL ptpp,
    PTP_POOL_STACK_INFORMATION ptpsi
    );


void

CloseThreadpool(
    PTP_POOL ptpp
    );




PTP_CLEANUP_GROUP

CreateThreadpoolCleanupGroup(
    void
    );


void

CloseThreadpoolCleanupGroupMembers(
    PTP_CLEANUP_GROUP ptpcg,
    BOOL fCancelPendingCallbacks,
    PVOID pvCleanupContext
    );


void

CloseThreadpoolCleanupGroup(
    PTP_CLEANUP_GROUP ptpcg
    );



__inline
void
InitializeThreadpoolEnvironment(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}

__inline
void
SetThreadpoolCallbackPool(
    PTP_CALLBACK_ENVIRON pcbe,
    PTP_POOL ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}

__inline
void
SetThreadpoolCallbackCleanupGroup(
    PTP_CALLBACK_ENVIRON pcbe,
    PTP_CLEANUP_GROUP ptpcg,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}

__inline
void
SetThreadpoolCallbackRunsLong(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}

__inline
void
SetThreadpoolCallbackLibrary(
    PTP_CALLBACK_ENVIRON pcbe,
    PVOID mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}



__inline
void
SetThreadpoolCallbackPriority(
    PTP_CALLBACK_ENVIRON pcbe,
    TP_CALLBACK_PRIORITY Priority
    )
{
    TpSetCallbackPriority(pcbe, Priority);
}



__inline
void
SetThreadpoolCallbackPersistent(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}

__inline
void
DestroyThreadpoolEnvironment(
    PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}




void

SetEventWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE evt
    );


void

ReleaseSemaphoreWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE sem,
    DWORD crel
    );


void

ReleaseMutexWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HANDLE mut
    );


void

LeaveCriticalSectionWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    PCRITICAL_SECTION pcs
    );


void

FreeLibraryWhenCallbackReturns(
    PTP_CALLBACK_INSTANCE pci,
    HMODULE mod
    );


BOOL

CallbackMayRunLong(
    PTP_CALLBACK_INSTANCE pci
    );


void

DisassociateCurrentThreadFromCallback(
    PTP_CALLBACK_INSTANCE pci
    );



BOOL

TrySubmitThreadpoolCallback(
    PTP_SIMPLE_CALLBACK pfns,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );




PTP_WORK

CreateThreadpoolWork(
    PTP_WORK_CALLBACK pfnwk,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );


void

SubmitThreadpoolWork(
    PTP_WORK pwk
    );


void

WaitForThreadpoolWorkCallbacks(
    PTP_WORK pwk,
    BOOL fCancelPendingCallbacks
    );


void

CloseThreadpoolWork(
    PTP_WORK pwk
    );




PTP_TIMER

CreateThreadpoolTimer(
    PTP_TIMER_CALLBACK pfnti,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );


void

SetThreadpoolTimer(
    PTP_TIMER pti,
    PFILETIME pftDueTime,
    DWORD msPeriod,
    DWORD msWindowLength
    );


BOOL

IsThreadpoolTimerSet(
    PTP_TIMER pti
    );


void

WaitForThreadpoolTimerCallbacks(
    PTP_TIMER pti,
    BOOL fCancelPendingCallbacks
    );


void

CloseThreadpoolTimer(
    PTP_TIMER pti
    );




PTP_WAIT

CreateThreadpoolWait(
    PTP_WAIT_CALLBACK pfnwa,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );


void

SetThreadpoolWait(
    PTP_WAIT pwa,
    HANDLE h,
    PFILETIME pftTimeout
    );


void

WaitForThreadpoolWaitCallbacks(
    PTP_WAIT pwa,
    BOOL fCancelPendingCallbacks
    );


void

CloseThreadpoolWait(
    PTP_WAIT pwa
    );




PTP_IO

CreateThreadpoolIo(
    HANDLE fl,
    PTP_WIN32_IO_CALLBACK pfnio,
    PVOID pv,
    PTP_CALLBACK_ENVIRON pcbe
    );


void

StartThreadpoolIo(
    PTP_IO pio
    );


void

CancelThreadpoolIo(
    PTP_IO pio
    );


void

WaitForThreadpoolIoCallbacks(
    PTP_IO pio,
    BOOL fCancelPendingCallbacks
    );


void

CloseThreadpoolIo(
    PTP_IO pio
    );

//
//  Private Namespaces support
//



HANDLE

CreatePrivateNamespaceA(
    LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    LPVOID lpBoundaryDescriptor,
    LPCSTR lpAliasPrefix
    );


HANDLE

CreatePrivateNamespaceW(
    LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    LPVOID lpBoundaryDescriptor,
    LPCWSTR lpAliasPrefix
    );



#define CreatePrivateNamespace CreatePrivateNamespaceA




HANDLE

OpenPrivateNamespaceA(
    LPVOID lpBoundaryDescriptor,
    LPCSTR lpAliasPrefix
    );


HANDLE

OpenPrivateNamespaceW(
    LPVOID lpBoundaryDescriptor,
    LPCWSTR lpAliasPrefix
    );



#define OpenPrivateNamespace OpenPrivateNamespaceA



#define PRIVATE_NAMESPACE_FLAG_DESTROY 0x00000001


BOOLEAN

ClosePrivateNamespace(
    HANDLE Handle,
    ULONG Flags
    );


//
//  Boundary descriptors support
//



HANDLE

CreateBoundaryDescriptorA(
    LPCSTR Name,
    ULONG Flags
    );


HANDLE

CreateBoundaryDescriptorW(
    LPCWSTR Name,
    ULONG Flags
    );



#define CreateBoundaryDescriptor CreateBoundaryDescriptorA



BOOL

AddSIDToBoundaryDescriptor(
    HANDLE * BoundaryDescriptor,
    PSID RequiredSid
    );


BOOL

AddIntegrityLabelToBoundaryDescriptor(
    HANDLE * BoundaryDescriptor,
    PSID IntegrityLabel
    );



void

DeleteBoundaryDescriptor(
    HANDLE BoundaryDescriptor
    );
# 13571 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
//
// Plug-and-Play API's
//

#define HW_PROFILE_GUIDLEN 39
#define MAX_PROFILE_LEN 80

#define DOCKINFO_UNDOCKED (0x1)
#define DOCKINFO_DOCKED (0x2)
#define DOCKINFO_USER_SUPPLIED (0x4)
#define DOCKINFO_USER_UNDOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED)
#define DOCKINFO_USER_DOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED)

typedef struct tagHW_PROFILE_INFOA {
    DWORD dwDockInfo;
    CHAR szHwProfileGuid[39];
    CHAR szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD dwDockInfo;
    WCHAR szHwProfileGuid[39];
    WCHAR szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;




typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;




BOOL

GetCurrentHwProfileA (
    LPHW_PROFILE_INFOA lpHwProfileInfo
    );

BOOL

GetCurrentHwProfileW (
    LPHW_PROFILE_INFOW lpHwProfileInfo
    );



#define GetCurrentHwProfile GetCurrentHwProfileA



//
// Performance counter API's
//


BOOL

QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    );


BOOL

QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    );




BOOL

GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    );

BOOL

GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    );



#define GetVersionEx GetVersionExA





BOOL

VerifyVersionInfoA(
    LPOSVERSIONINFOEXA lpVersionInformation,
    DWORD dwTypeMask,
    DWORDLONG dwlConditionMask
    );

BOOL

VerifyVersionInfoW(
    LPOSVERSIONINFOEXW lpVersionInformation,
    DWORD dwTypeMask,
    DWORDLONG dwlConditionMask
    );



#define VerifyVersionInfo VerifyVersionInfoA





BOOL

GetProductInfo(
    DWORD dwOSMajorVersion,
    DWORD dwOSMinorVersion,
    DWORD dwSpMajorVersion,
    DWORD dwSpMinorVersion,
    PDWORD pdwReturnedProductType
    );



// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h" 1
/************************************************************************

*                                                                       *

*   winerror.h --  error code definitions for the Win32 API functions   *

*                                                                       *

*   Copyright (c) Microsoft Corp. All rights reserved.                  *

*                                                                       *

************************************************************************/
# 10 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
#define _WINERROR_ 
# 26 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
//  Note: There is a slightly modified layout for HRESULT values below,
//        after the heading "COM Error Codes".
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_XPS 82
#define FACILITY_WINRM 51
#define FACILITY_WINDOWSUPDATE 36
#define FACILITY_WINDOWS_DEFENDER 80
#define FACILITY_WINDOWS_CE 24
#define FACILITY_WINDOWS 8
#define FACILITY_USERMODE_VOLMGR 56
#define FACILITY_USERMODE_VIRTUALIZATION 55
#define FACILITY_USERMODE_VHD 58
#define FACILITY_URT 19
#define FACILITY_UMI 22
#define FACILITY_UI 42
#define FACILITY_TPM_SOFTWARE 41
#define FACILITY_TPM_SERVICES 40
#define FACILITY_SXS 23
#define FACILITY_STORAGE 3
#define FACILITY_STATE_MANAGEMENT 34
#define FACILITY_SSPI 9
#define FACILITY_SCARD 16
#define FACILITY_SHELL 39
#define FACILITY_SETUPAPI 15
#define FACILITY_SECURITY 9
#define FACILITY_SDIAG 60
#define FACILITY_RPC 1
#define FACILITY_RAS 83
#define FACILITY_PLA 48
#define FACILITY_OPC 81
#define FACILITY_WIN32 7
#define FACILITY_CONTROL 10
#define FACILITY_WEBSERVICES 61
#define FACILITY_NULL 0
#define FACILITY_NDIS 52
#define FACILITY_METADIRECTORY 35
#define FACILITY_MSMQ 14
#define FACILITY_MEDIASERVER 13
#define FACILITY_MBN 84
#define FACILITY_INTERNET 12
#define FACILITY_ITF 4
#define FACILITY_USERMODE_HYPERVISOR 53
#define FACILITY_HTTP 25
#define FACILITY_GRAPHICS 38
#define FACILITY_FWP 50
#define FACILITY_FVE 49
#define FACILITY_USERMODE_FILTER_MANAGER 31
#define FACILITY_DPLAY 21
#define FACILITY_DISPATCH 2
#define FACILITY_DIRECTORYSERVICE 37
#define FACILITY_CONFIGURATION 33
#define FACILITY_COMPLUS 17
#define FACILITY_USERMODE_COMMONLOG 26
#define FACILITY_CMI 54
#define FACILITY_CERT 11
#define FACILITY_BCD 57
#define FACILITY_BACKGROUNDCOPY 32
#define FACILITY_ACS 20
#define FACILITY_AAF 18


//
// Define the severity codes
//


//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
// The operation completed successfully.
//
#define ERROR_SUCCESS 0L

#define NO_ERROR 0L
#define SEC_E_OK ((HRESULT)0x00000000L)

//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
// Incorrect function.
//
#define ERROR_INVALID_FUNCTION 1L

//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.
//
#define ERROR_FILE_NOT_FOUND 2L

//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
// The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND 3L

//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
// The system cannot open the file.
//
#define ERROR_TOO_MANY_OPEN_FILES 4L

//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
#define ERROR_ACCESS_DENIED 5L

//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
// The handle is invalid.
//
#define ERROR_INVALID_HANDLE 6L

//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
// The storage control blocks were destroyed.
//
#define ERROR_ARENA_TRASHED 7L

//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
// Not enough storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_MEMORY 8L

//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
// The storage control block address is invalid.
//
#define ERROR_INVALID_BLOCK 9L

//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
// The environment is incorrect.
//
#define ERROR_BAD_ENVIRONMENT 10L

//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
// An attempt was made to load a program with an incorrect format.
//
#define ERROR_BAD_FORMAT 11L

//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
// The access code is invalid.
//
#define ERROR_INVALID_ACCESS 12L

//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
// The data is invalid.
//
#define ERROR_INVALID_DATA 13L

//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
// Not enough storage is available to complete this operation.
//
#define ERROR_OUTOFMEMORY 14L

//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
// The system cannot find the drive specified.
//
#define ERROR_INVALID_DRIVE 15L

//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
// The directory cannot be removed.
//
#define ERROR_CURRENT_DIRECTORY 16L

//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
// The system cannot move the file to a different disk drive.
//
#define ERROR_NOT_SAME_DEVICE 17L

//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
// There are no more files.
//
#define ERROR_NO_MORE_FILES 18L

//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
// The media is write protected.
//
#define ERROR_WRITE_PROTECT 19L

//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
// The system cannot find the device specified.
//
#define ERROR_BAD_UNIT 20L

//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
// The device is not ready.
//
#define ERROR_NOT_READY 21L

//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
// The device does not recognize the command.
//
#define ERROR_BAD_COMMAND 22L

//
// MessageId: ERROR_CRC
//
// MessageText:
//
// Data error (cyclic redundancy check).
//
#define ERROR_CRC 23L

//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
// The program issued a command but the command length is incorrect.
//
#define ERROR_BAD_LENGTH 24L

//
// MessageId: ERROR_SEEK
//
// MessageText:
//
// The drive cannot locate a specific area or track on the disk.
//
#define ERROR_SEEK 25L

//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
// The specified disk or diskette cannot be accessed.
//
#define ERROR_NOT_DOS_DISK 26L

//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
// The drive cannot find the sector requested.
//
#define ERROR_SECTOR_NOT_FOUND 27L

//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
// The printer is out of paper.
//
#define ERROR_OUT_OF_PAPER 28L

//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
// The system cannot write to the specified device.
//
#define ERROR_WRITE_FAULT 29L

//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
// The system cannot read from the specified device.
//
#define ERROR_READ_FAULT 30L

//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
// A device attached to the system is not functioning.
//
#define ERROR_GEN_FAILURE 31L

//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
// The process cannot access the file because it is being used by another process.
//
#define ERROR_SHARING_VIOLATION 32L

//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
// The process cannot access the file because another process has locked a portion of the file.
//
#define ERROR_LOCK_VIOLATION 33L

//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
// The wrong diskette is in the drive.
// Insert %2 (Volume Serial Number: %3) into drive %1.
//
#define ERROR_WRONG_DISK 34L

//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
// Too many files opened for sharing.
//
#define ERROR_SHARING_BUFFER_EXCEEDED 36L

//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
// Reached the end of the file.
//
#define ERROR_HANDLE_EOF 38L

//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
// The disk is full.
//
#define ERROR_HANDLE_DISK_FULL 39L

//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
// The request is not supported.
//
#define ERROR_NOT_SUPPORTED 50L

//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
// Windows cannot find the network path. Verify that the network path is correct and the destination computer is not busy or turned off. If Windows still cannot find the network path, contact your network administrator.
//
#define ERROR_REM_NOT_LIST 51L

//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
// You were not connected because a duplicate name exists on the network. If joining a domain, go to System in Control Panel to change the computer name and try again. If joining a workgroup, choose another workgroup name.
//
#define ERROR_DUP_NAME 52L

//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
// The network path was not found.
//
#define ERROR_BAD_NETPATH 53L

//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
// The network is busy.
//
#define ERROR_NETWORK_BUSY 54L

//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
// The specified network resource or device is no longer available.
//
#define ERROR_DEV_NOT_EXIST 55L

//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
// The network BIOS command limit has been reached.
//
#define ERROR_TOO_MANY_CMDS 56L

//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
// A network adapter hardware error occurred.
//
#define ERROR_ADAP_HDW_ERR 57L

//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
// The specified server cannot perform the requested operation.
//
#define ERROR_BAD_NET_RESP 58L

//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
// An unexpected network error occurred.
//
#define ERROR_UNEXP_NET_ERR 59L

//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
// The remote adapter is not compatible.
//
#define ERROR_BAD_REM_ADAP 60L

//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
// The printer queue is full.
//
#define ERROR_PRINTQ_FULL 61L

//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
// Space to store the file waiting to be printed is not available on the server.
//
#define ERROR_NO_SPOOL_SPACE 62L

//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
// Your file waiting to be printed was deleted.
//
#define ERROR_PRINT_CANCELLED 63L

//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
// The specified network name is no longer available.
//
#define ERROR_NETNAME_DELETED 64L

//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
// Network access is denied.
//
#define ERROR_NETWORK_ACCESS_DENIED 65L

//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
// The network resource type is not correct.
//
#define ERROR_BAD_DEV_TYPE 66L

//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
// The network name cannot be found.
//
#define ERROR_BAD_NET_NAME 67L

//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
// The name limit for the local computer network adapter card was exceeded.
//
#define ERROR_TOO_MANY_NAMES 68L

//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
// The network BIOS session limit was exceeded.
//
#define ERROR_TOO_MANY_SESS 69L

//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
// The remote server has been paused or is in the process of being started.
//
#define ERROR_SHARING_PAUSED 70L

//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
// No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.
//
#define ERROR_REQ_NOT_ACCEP 71L

//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
// The specified printer or disk device has been paused.
//
#define ERROR_REDIR_PAUSED 72L

//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
// The file exists.
//
#define ERROR_FILE_EXISTS 80L

//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
// The directory or file cannot be created.
//
#define ERROR_CANNOT_MAKE 82L

//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
// Fail on INT 24.
//
#define ERROR_FAIL_I24 83L

//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
// Storage to process this request is not available.
//
#define ERROR_OUT_OF_STRUCTURES 84L

//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
// The local device name is already in use.
//
#define ERROR_ALREADY_ASSIGNED 85L

//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
// The specified network password is not correct.
//
#define ERROR_INVALID_PASSWORD 86L

//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
#define ERROR_INVALID_PARAMETER 87L

//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
// A write fault occurred on the network.
//
#define ERROR_NET_WRITE_FAULT 88L

//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
// The system cannot start another process at this time.
//
#define ERROR_NO_PROC_SLOTS 89L

//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
// Cannot create another system semaphore.
//
#define ERROR_TOO_MANY_SEMAPHORES 100L

//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
// The exclusive semaphore is owned by another process.
//
#define ERROR_EXCL_SEM_ALREADY_OWNED 101L

//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
// The semaphore is set and cannot be closed.
//
#define ERROR_SEM_IS_SET 102L

//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
// The semaphore cannot be set again.
//
#define ERROR_TOO_MANY_SEM_REQUESTS 103L

//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
// Cannot request exclusive semaphores at interrupt time.
//
#define ERROR_INVALID_AT_INTERRUPT_TIME 104L

//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
// The previous ownership of this semaphore has ended.
//
#define ERROR_SEM_OWNER_DIED 105L

//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
// Insert the diskette for drive %1.
//
#define ERROR_SEM_USER_LIMIT 106L

//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
// The program stopped because an alternate diskette was not inserted.
//
#define ERROR_DISK_CHANGE 107L

//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
// The disk is in use or locked by another process.
//
#define ERROR_DRIVE_LOCKED 108L

//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
// The pipe has been ended.
//
#define ERROR_BROKEN_PIPE 109L

//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
// The system cannot open the device or file specified.
//
#define ERROR_OPEN_FAILED 110L

//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
// The file name is too long.
//
#define ERROR_BUFFER_OVERFLOW 111L

//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
// There is not enough space on the disk.
//
#define ERROR_DISK_FULL 112L

//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
// No more internal file identifiers available.
//
#define ERROR_NO_MORE_SEARCH_HANDLES 113L

//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
// The target internal file identifier is incorrect.
//
#define ERROR_INVALID_TARGET_HANDLE 114L

//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
// The IOCTL call made by the application program is not correct.
//
#define ERROR_INVALID_CATEGORY 117L

//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
// The verify-on-write switch parameter value is not correct.
//
#define ERROR_INVALID_VERIFY_SWITCH 118L

//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
// The system does not support the command requested.
//
#define ERROR_BAD_DRIVER_LEVEL 119L

//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
// This function is not supported on this system.
//
#define ERROR_CALL_NOT_IMPLEMENTED 120L

//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
// The semaphore timeout period has expired.
//
#define ERROR_SEM_TIMEOUT 121L

//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The data area passed to a system call is too small.
//
#define ERROR_INSUFFICIENT_BUFFER 122L

//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
// The filename, directory name, or volume label syntax is incorrect.
//
#define ERROR_INVALID_NAME 123L

//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
// The system call level is not correct.
//
#define ERROR_INVALID_LEVEL 124L

//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
// The disk has no volume label.
//
#define ERROR_NO_VOLUME_LABEL 125L

//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
// The specified module could not be found.
//
#define ERROR_MOD_NOT_FOUND 126L

//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
// The specified procedure could not be found.
//
#define ERROR_PROC_NOT_FOUND 127L

//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
// There are no child processes to wait for.
//
#define ERROR_WAIT_NO_CHILDREN 128L

//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
// The %1 application cannot be run in Win32 mode.
//
#define ERROR_CHILD_NOT_COMPLETE 129L

//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
// Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.
//
#define ERROR_DIRECT_ACCESS_HANDLE 130L

//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
// An attempt was made to move the file pointer before the beginning of the file.
//
#define ERROR_NEGATIVE_SEEK 131L

//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
// The file pointer cannot be set on the specified device or file.
//
#define ERROR_SEEK_ON_DEVICE 132L

//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
// A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.
//
#define ERROR_IS_JOIN_TARGET 133L

//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
// An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.
//
#define ERROR_IS_JOINED 134L

//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
// An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.
//
#define ERROR_IS_SUBSTED 135L

//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
// The system tried to delete the JOIN of a drive that is not joined.
//
#define ERROR_NOT_JOINED 136L

//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
// The system tried to delete the substitution of a drive that is not substituted.
//
#define ERROR_NOT_SUBSTED 137L

//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
// The system tried to join a drive to a directory on a joined drive.
//
#define ERROR_JOIN_TO_JOIN 138L

//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
// The system tried to substitute a drive to a directory on a substituted drive.
//
#define ERROR_SUBST_TO_SUBST 139L

//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
// The system tried to join a drive to a directory on a substituted drive.
//
#define ERROR_JOIN_TO_SUBST 140L

//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
// The system tried to SUBST a drive to a directory on a joined drive.
//
#define ERROR_SUBST_TO_JOIN 141L

//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
// The system cannot perform a JOIN or SUBST at this time.
//
#define ERROR_BUSY_DRIVE 142L

//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
// The system cannot join or substitute a drive to or for a directory on the same drive.
//
#define ERROR_SAME_DRIVE 143L

//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
// The directory is not a subdirectory of the root directory.
//
#define ERROR_DIR_NOT_ROOT 144L

//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
// The directory is not empty.
//
#define ERROR_DIR_NOT_EMPTY 145L

//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
// The path specified is being used in a substitute.
//
#define ERROR_IS_SUBST_PATH 146L

//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
// Not enough resources are available to process this command.
//
#define ERROR_IS_JOIN_PATH 147L

//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
// The path specified cannot be used at this time.
//
#define ERROR_PATH_BUSY 148L

//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
// An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.
//
#define ERROR_IS_SUBST_TARGET 149L

//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
// System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.
//
#define ERROR_SYSTEM_TRACE 150L

//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
// The number of specified semaphore events for DosMuxSemWait is not correct.
//
#define ERROR_INVALID_EVENT_COUNT 151L

//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
// DosMuxSemWait did not execute; too many semaphores are already set.
//
#define ERROR_TOO_MANY_MUXWAITERS 152L

//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
// The DosMuxSemWait list is not correct.
//
#define ERROR_INVALID_LIST_FORMAT 153L

//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
// The volume label you entered exceeds the label character limit of the target file system.
//
#define ERROR_LABEL_TOO_LONG 154L

//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
// Cannot create another thread.
//
#define ERROR_TOO_MANY_TCBS 155L

//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
// The recipient process has refused the signal.
//
#define ERROR_SIGNAL_REFUSED 156L

//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
// The segment is already discarded and cannot be locked.
//
#define ERROR_DISCARDED 157L

//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
// The segment is already unlocked.
//
#define ERROR_NOT_LOCKED 158L

//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
// The address for the thread ID is not correct.
//
#define ERROR_BAD_THREADID_ADDR 159L

//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
// One or more arguments are not correct.
//
#define ERROR_BAD_ARGUMENTS 160L

//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
// The specified path is invalid.
//
#define ERROR_BAD_PATHNAME 161L

//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
// A signal is already pending.
//
#define ERROR_SIGNAL_PENDING 162L

//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
// No more threads can be created in the system.
//
#define ERROR_MAX_THRDS_REACHED 164L

//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
// Unable to lock a region of a file.
//
#define ERROR_LOCK_FAILED 167L

//
// MessageId: ERROR_BUSY
//
// MessageText:
//
// The requested resource is in use.
//
#define ERROR_BUSY 170L

//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
// A lock request was not outstanding for the supplied cancel region.
//
#define ERROR_CANCEL_VIOLATION 173L

//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
// The file system does not support atomic changes to the lock type.
//
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174L

//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
// The system detected a segment number that was not correct.
//
#define ERROR_INVALID_SEGMENT_NUMBER 180L

//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_INVALID_ORDINAL 182L

//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
// Cannot create a file when that file already exists.
//
#define ERROR_ALREADY_EXISTS 183L

//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
// The flag passed is not correct.
//
#define ERROR_INVALID_FLAG_NUMBER 186L

//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
// The specified system semaphore name was not found.
//
#define ERROR_SEM_NOT_FOUND 187L

//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_INVALID_STARTING_CODESEG 188L

//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_INVALID_STACKSEG 189L

//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_INVALID_MODULETYPE 190L

//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
// Cannot run %1 in Win32 mode.
//
#define ERROR_INVALID_EXE_SIGNATURE 191L

//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_EXE_MARKED_INVALID 192L

//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
// %1 is not a valid Win32 application.
//
#define ERROR_BAD_EXE_FORMAT 193L

//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_ITERATED_DATA_EXCEEDS_64k 194L

//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_INVALID_MINALLOCSIZE 195L

//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
// The operating system cannot run this application program.
//
#define ERROR_DYNLINK_FROM_INVALID_RING 196L

//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
// The operating system is not presently configured to run this application.
//
#define ERROR_IOPL_NOT_ENABLED 197L

//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_INVALID_SEGDPL 198L

//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
// The operating system cannot run this application program.
//
#define ERROR_AUTODATASEG_EXCEEDS_64k 199L

//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
// The code segment cannot be greater than or equal to 64K.
//
#define ERROR_RING2SEG_MUST_BE_MOVABLE 200L

//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM 201L

//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
// The operating system cannot run %1.
//
#define ERROR_INFLOOP_IN_RELOC_CHAIN 202L

//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
// The system could not find the environment option that was entered.
//
#define ERROR_ENVVAR_NOT_FOUND 203L

//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
// No process in the command subtree has a signal handler.
//
#define ERROR_NO_SIGNAL_SENT 205L

//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
// The filename or extension is too long.
//
#define ERROR_FILENAME_EXCED_RANGE 206L

//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
// The ring 2 stack is in use.
//
#define ERROR_RING2_STACK_IN_USE 207L

//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
// The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.
//
#define ERROR_META_EXPANSION_TOO_LONG 208L

//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
// The signal being posted is not correct.
//
#define ERROR_INVALID_SIGNAL_NUMBER 209L

//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
// The signal handler cannot be set.
//
#define ERROR_THREAD_1_INACTIVE 210L

//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
// The segment is locked and cannot be reallocated.
//
#define ERROR_LOCKED 212L

//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
// Too many dynamic-link modules are attached to this program or dynamic-link module.
//
#define ERROR_TOO_MANY_MODULES 214L

//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
// Cannot nest calls to LoadModule.
//
#define ERROR_NESTING_NOT_ALLOWED 215L

//
// MessageId: ERROR_EXE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
// This version of %1 is not compatible with the version of Windows you're running. Check your computer's system information to see whether you need a x86 (32-bit) or x64 (64-bit) version of the program, and then contact the software publisher.
//
#define ERROR_EXE_MACHINE_TYPE_MISMATCH 216L

//
// MessageId: ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY
//
// MessageText:
//
// The image file %1 is signed, unable to modify.
//
#define ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY 217L

//
// MessageId: ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY
//
// MessageText:
//
// The image file %1 is strong signed, unable to modify.
//
#define ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY 218L

//
// MessageId: ERROR_FILE_CHECKED_OUT
//
// MessageText:
//
// This file is checked out or locked for editing by another user.
//
#define ERROR_FILE_CHECKED_OUT 220L

//
// MessageId: ERROR_CHECKOUT_REQUIRED
//
// MessageText:
//
// The file must be checked out before saving changes.
//
#define ERROR_CHECKOUT_REQUIRED 221L

//
// MessageId: ERROR_BAD_FILE_TYPE
//
// MessageText:
//
// The file type being saved or retrieved has been blocked.
//
#define ERROR_BAD_FILE_TYPE 222L

//
// MessageId: ERROR_FILE_TOO_LARGE
//
// MessageText:
//
// The file size exceeds the limit allowed and cannot be saved.
//
#define ERROR_FILE_TOO_LARGE 223L

//
// MessageId: ERROR_FORMS_AUTH_REQUIRED
//
// MessageText:
//
// Access Denied. Before opening files in this location, you must first add the web site to your trusted sites list, browse to the web site, and select the option to login automatically.
//
#define ERROR_FORMS_AUTH_REQUIRED 224L

//
// MessageId: ERROR_VIRUS_INFECTED
//
// MessageText:
//
// Operation did not complete successfully because the file contains a virus.
//
#define ERROR_VIRUS_INFECTED 225L

//
// MessageId: ERROR_VIRUS_DELETED
//
// MessageText:
//
// This file contains a virus and cannot be opened. Due to the nature of this virus, the file has been removed from this location.
//
#define ERROR_VIRUS_DELETED 226L

//
// MessageId: ERROR_PIPE_LOCAL
//
// MessageText:
//
// The pipe is local.
//
#define ERROR_PIPE_LOCAL 229L

//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
// The pipe state is invalid.
//
#define ERROR_BAD_PIPE 230L

//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
// All pipe instances are busy.
//
#define ERROR_PIPE_BUSY 231L

//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
// The pipe is being closed.
//
#define ERROR_NO_DATA 232L

//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
// No process is on the other end of the pipe.
//
#define ERROR_PIPE_NOT_CONNECTED 233L

//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
// More data is available.
//
#define ERROR_MORE_DATA 234L

//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
// The session was canceled.
//
#define ERROR_VC_DISCONNECTED 240L

//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
// The specified extended attribute name was invalid.
//
#define ERROR_INVALID_EA_NAME 254L

//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
// The extended attributes are inconsistent.
//
#define ERROR_EA_LIST_INCONSISTENT 255L

//
// MessageId: WAIT_TIMEOUT
//
// MessageText:
//
// The wait operation timed out.
//
#define WAIT_TIMEOUT 258L

//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
// No more data is available.
//
#define ERROR_NO_MORE_ITEMS 259L

//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
// The copy functions cannot be used.
//
#define ERROR_CANNOT_COPY 266L

//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
// The directory name is invalid.
//
#define ERROR_DIRECTORY 267L

//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
// The extended attributes did not fit in the buffer.
//
#define ERROR_EAS_DIDNT_FIT 275L

//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
// The extended attribute file on the mounted file system is corrupt.
//
#define ERROR_EA_FILE_CORRUPT 276L

//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
// The extended attribute table file is full.
//
#define ERROR_EA_TABLE_FULL 277L

//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
// The specified extended attribute handle is invalid.
//
#define ERROR_INVALID_EA_HANDLE 278L

//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
// The mounted file system does not support extended attributes.
//
#define ERROR_EAS_NOT_SUPPORTED 282L

//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
// Attempt to release mutex not owned by caller.
//
#define ERROR_NOT_OWNER 288L

//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
// Too many posts were made to a semaphore.
//
#define ERROR_TOO_MANY_POSTS 298L

//
// MessageId: ERROR_PARTIAL_COPY
//
// MessageText:
//
// Only part of a ReadProcessMemory or WriteProcessMemory request was completed.
//
#define ERROR_PARTIAL_COPY 299L

//
// MessageId: ERROR_OPLOCK_NOT_GRANTED
//
// MessageText:
//
// The oplock request is denied.
//
#define ERROR_OPLOCK_NOT_GRANTED 300L

//
// MessageId: ERROR_INVALID_OPLOCK_PROTOCOL
//
// MessageText:
//
// An invalid oplock acknowledgment was received by the system.
//
#define ERROR_INVALID_OPLOCK_PROTOCOL 301L

//
// MessageId: ERROR_DISK_TOO_FRAGMENTED
//
// MessageText:
//
// The volume is too fragmented to complete this operation.
//
#define ERROR_DISK_TOO_FRAGMENTED 302L

//
// MessageId: ERROR_DELETE_PENDING
//
// MessageText:
//
// The file cannot be opened because it is in the process of being deleted.
//
#define ERROR_DELETE_PENDING 303L

//
// MessageId: ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING
//
// MessageText:
//
// Short name settings may not be changed on this volume due to the global registry setting.
//
#define ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING 304L

//
// MessageId: ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME
//
// MessageText:
//
// Short names are not enabled on this volume.
//
#define ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME 305L

//
// MessageId: ERROR_SECURITY_STREAM_IS_INCONSISTENT
//
// MessageText:
//
// The security stream for the given volume is in an inconsistent state.
// Please run CHKDSK on the volume.
//
#define ERROR_SECURITY_STREAM_IS_INCONSISTENT 306L

//
// MessageId: ERROR_INVALID_LOCK_RANGE
//
// MessageText:
//
// A requested file lock operation cannot be processed due to an invalid byte range.
//
#define ERROR_INVALID_LOCK_RANGE 307L

//
// MessageId: ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT
//
// MessageText:
//
// The subsystem needed to support the image type is not present.
//
#define ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT 308L

//
// MessageId: ERROR_NOTIFICATION_GUID_ALREADY_DEFINED
//
// MessageText:
//
// The specified file already has a notification GUID associated with it.
//
#define ERROR_NOTIFICATION_GUID_ALREADY_DEFINED 309L

//
// Available SYSTEM error code
//
//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
// The system cannot find message text for message number 0x%1 in the message file for %2.
//
#define ERROR_MR_MID_NOT_FOUND 317L

//
// MessageId: ERROR_SCOPE_NOT_FOUND
//
// MessageText:
//
// The scope specified was not found.
//
#define ERROR_SCOPE_NOT_FOUND 318L

//
// MessageId: ERROR_FAIL_NOACTION_REBOOT
//
// MessageText:
//
// No action was taken as a system reboot is required.
//
#define ERROR_FAIL_NOACTION_REBOOT 350L

//
// MessageId: ERROR_FAIL_SHUTDOWN
//
// MessageText:
//
// The shutdown operation failed.
//
#define ERROR_FAIL_SHUTDOWN 351L

//
// MessageId: ERROR_FAIL_RESTART
//
// MessageText:
//
// The restart operation failed.
//
#define ERROR_FAIL_RESTART 352L

//
// MessageId: ERROR_MAX_SESSIONS_REACHED
//
// MessageText:
//
// The maximum number of sessions has been reached.
//
#define ERROR_MAX_SESSIONS_REACHED 353L

//
// MessageId: ERROR_THREAD_MODE_ALREADY_BACKGROUND
//
// MessageText:
//
// The thread is already in background processing mode.
//
#define ERROR_THREAD_MODE_ALREADY_BACKGROUND 400L

//
// MessageId: ERROR_THREAD_MODE_NOT_BACKGROUND
//
// MessageText:
//
// The thread is not in background processing mode.
//
#define ERROR_THREAD_MODE_NOT_BACKGROUND 401L

//
// MessageId: ERROR_PROCESS_MODE_ALREADY_BACKGROUND
//
// MessageText:
//
// The process is already in background processing mode.
//
#define ERROR_PROCESS_MODE_ALREADY_BACKGROUND 402L

//
// MessageId: ERROR_PROCESS_MODE_NOT_BACKGROUND
//
// MessageText:
//
// The process is not in background processing mode.
//
#define ERROR_PROCESS_MODE_NOT_BACKGROUND 403L

//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
// Attempt to access invalid address.
//
#define ERROR_INVALID_ADDRESS 487L

//
// MessageId: ERROR_USER_PROFILE_LOAD
//
// MessageText:
//
// User profile cannot be loaded.
//
#define ERROR_USER_PROFILE_LOAD 500L

//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
// Arithmetic result exceeded 32 bits.
//
#define ERROR_ARITHMETIC_OVERFLOW 534L

//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
// There is a process on other end of the pipe.
//
#define ERROR_PIPE_CONNECTED 535L

//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
// Waiting for a process to open the other end of the pipe.
//
#define ERROR_PIPE_LISTENING 536L

//
// MessageId: ERROR_VERIFIER_STOP
//
// MessageText:
//
// Application verifier has found an error in the current process.
//
#define ERROR_VERIFIER_STOP 537L

//
// MessageId: ERROR_ABIOS_ERROR
//
// MessageText:
//
// An error occurred in the ABIOS subsystem.
//
#define ERROR_ABIOS_ERROR 538L

//
// MessageId: ERROR_WX86_WARNING
//
// MessageText:
//
// A warning occurred in the WX86 subsystem.
//
#define ERROR_WX86_WARNING 539L

//
// MessageId: ERROR_WX86_ERROR
//
// MessageText:
//
// An error occurred in the WX86 subsystem.
//
#define ERROR_WX86_ERROR 540L

//
// MessageId: ERROR_TIMER_NOT_CANCELED
//
// MessageText:
//
// An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.
//
#define ERROR_TIMER_NOT_CANCELED 541L

//
// MessageId: ERROR_UNWIND
//
// MessageText:
//
// Unwind exception code.
//
#define ERROR_UNWIND 542L

//
// MessageId: ERROR_BAD_STACK
//
// MessageText:
//
// An invalid or unaligned stack was encountered during an unwind operation.
//
#define ERROR_BAD_STACK 543L

//
// MessageId: ERROR_INVALID_UNWIND_TARGET
//
// MessageText:
//
// An invalid unwind target was encountered during an unwind operation.
//
#define ERROR_INVALID_UNWIND_TARGET 544L

//
// MessageId: ERROR_INVALID_PORT_ATTRIBUTES
//
// MessageText:
//
// Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort
//
#define ERROR_INVALID_PORT_ATTRIBUTES 545L

//
// MessageId: ERROR_PORT_MESSAGE_TOO_LONG
//
// MessageText:
//
// Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.
//
#define ERROR_PORT_MESSAGE_TOO_LONG 546L

//
// MessageId: ERROR_INVALID_QUOTA_LOWER
//
// MessageText:
//
// An attempt was made to lower a quota limit below the current usage.
//
#define ERROR_INVALID_QUOTA_LOWER 547L

//
// MessageId: ERROR_DEVICE_ALREADY_ATTACHED
//
// MessageText:
//
// An attempt was made to attach to a device that was already attached to another device.
//
#define ERROR_DEVICE_ALREADY_ATTACHED 548L

//
// MessageId: ERROR_INSTRUCTION_MISALIGNMENT
//
// MessageText:
//
// An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.
//
#define ERROR_INSTRUCTION_MISALIGNMENT 549L

//
// MessageId: ERROR_PROFILING_NOT_STARTED
//
// MessageText:
//
// Profiling not started.
//
#define ERROR_PROFILING_NOT_STARTED 550L

//
// MessageId: ERROR_PROFILING_NOT_STOPPED
//
// MessageText:
//
// Profiling not stopped.
//
#define ERROR_PROFILING_NOT_STOPPED 551L

//
// MessageId: ERROR_COULD_NOT_INTERPRET
//
// MessageText:
//
// The passed ACL did not contain the minimum required information.
//
#define ERROR_COULD_NOT_INTERPRET 552L

//
// MessageId: ERROR_PROFILING_AT_LIMIT
//
// MessageText:
//
// The number of active profiling objects is at the maximum and no more may be started.
//
#define ERROR_PROFILING_AT_LIMIT 553L

//
// MessageId: ERROR_CANT_WAIT
//
// MessageText:
//
// Used to indicate that an operation cannot continue without blocking for I/O.
//
#define ERROR_CANT_WAIT 554L

//
// MessageId: ERROR_CANT_TERMINATE_SELF
//
// MessageText:
//
// Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NULL) and it was the last thread in the current process.
//
#define ERROR_CANT_TERMINATE_SELF 555L

//
// MessageId: ERROR_UNEXPECTED_MM_CREATE_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//
#define ERROR_UNEXPECTED_MM_CREATE_ERR 556L

//
// MessageId: ERROR_UNEXPECTED_MM_MAP_ERROR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//
#define ERROR_UNEXPECTED_MM_MAP_ERROR 557L

//
// MessageId: ERROR_UNEXPECTED_MM_EXTEND_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter.
// In this case information is lost, however, the filter correctly handles the exception.
//
#define ERROR_UNEXPECTED_MM_EXTEND_ERR 558L

//
// MessageId: ERROR_BAD_FUNCTION_TABLE
//
// MessageText:
//
// A malformed function table was encountered during an unwind operation.
//
#define ERROR_BAD_FUNCTION_TABLE 559L

//
// MessageId: ERROR_NO_GUID_TRANSLATION
//
// MessageText:
//
// Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system.
// This causes the protection attempt to fail, which may cause a file creation attempt to fail.
//
#define ERROR_NO_GUID_TRANSLATION 560L

//
// MessageId: ERROR_INVALID_LDT_SIZE
//
// MessageText:
//
// Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.
//
#define ERROR_INVALID_LDT_SIZE 561L

//
// MessageId: ERROR_INVALID_LDT_OFFSET
//
// MessageText:
//
// Indicates that the starting value for the LDT information was not an integral multiple of the selector size.
//
#define ERROR_INVALID_LDT_OFFSET 563L

//
// MessageId: ERROR_INVALID_LDT_DESCRIPTOR
//
// MessageText:
//
// Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.
//
#define ERROR_INVALID_LDT_DESCRIPTOR 564L

//
// MessageId: ERROR_TOO_MANY_THREADS
//
// MessageText:
//
// Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.
//
#define ERROR_TOO_MANY_THREADS 565L

//
// MessageId: ERROR_THREAD_NOT_IN_PROCESS
//
// MessageText:
//
// An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.
//
#define ERROR_THREAD_NOT_IN_PROCESS 566L

//
// MessageId: ERROR_PAGEFILE_QUOTA_EXCEEDED
//
// MessageText:
//
// Page file quota was exceeded.
//
#define ERROR_PAGEFILE_QUOTA_EXCEEDED 567L

//
// MessageId: ERROR_LOGON_SERVER_CONFLICT
//
// MessageText:
//
// The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.
//
#define ERROR_LOGON_SERVER_CONFLICT 568L

//
// MessageId: ERROR_SYNCHRONIZATION_REQUIRED
//
// MessageText:
//
// The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.
//
#define ERROR_SYNCHRONIZATION_REQUIRED 569L

//
// MessageId: ERROR_NET_OPEN_FAILED
//
// MessageText:
//
// The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.
//
#define ERROR_NET_OPEN_FAILED 570L

//
// MessageId: ERROR_IO_PRIVILEGE_FAILED
//
// MessageText:
//
// {Privilege Failed}
// The I/O permissions for the process could not be changed.
//
#define ERROR_IO_PRIVILEGE_FAILED 571L

//
// MessageId: ERROR_CONTROL_C_EXIT
//
// MessageText:
//
// {Application Exit by CTRL+C}
// The application terminated as a result of a CTRL+C.
//
#define ERROR_CONTROL_C_EXIT 572L

//
// MessageId: ERROR_MISSING_SYSTEMFILE
//
// MessageText:
//
// {Missing System File}
// The required system file %hs is bad or missing.
//
#define ERROR_MISSING_SYSTEMFILE 573L

//
// MessageId: ERROR_UNHANDLED_EXCEPTION
//
// MessageText:
//
// {Application Error}
// The exception %s (0x%08lx) occurred in the application at location 0x%08lx.
//
#define ERROR_UNHANDLED_EXCEPTION 574L

//
// MessageId: ERROR_APP_INIT_FAILURE
//
// MessageText:
//
// {Application Error}
// The application was unable to start correctly (0x%lx). Click OK to close the application.
//
#define ERROR_APP_INIT_FAILURE 575L

//
// MessageId: ERROR_PAGEFILE_CREATE_FAILED
//
// MessageText:
//
// {Unable to Create Paging File}
// The creation of the paging file %hs failed (%lx). The requested size was %ld.
//
#define ERROR_PAGEFILE_CREATE_FAILED 576L

//
// MessageId: ERROR_INVALID_IMAGE_HASH
//
// MessageText:
//
// Windows cannot verify the digital signature for this file. A recent hardware or software change might have installed a file that is signed incorrectly or damaged, or that might be malicious software from an unknown source.
//
#define ERROR_INVALID_IMAGE_HASH 577L

//
// MessageId: ERROR_NO_PAGEFILE
//
// MessageText:
//
// {No Paging File Specified}
// No paging file was specified in the system configuration.
//
#define ERROR_NO_PAGEFILE 578L

//
// MessageId: ERROR_ILLEGAL_FLOAT_CONTEXT
//
// MessageText:
//
// {EXCEPTION}
// A real-mode application issued a floating-point instruction and floating-point hardware is not present.
//
#define ERROR_ILLEGAL_FLOAT_CONTEXT 579L

//
// MessageId: ERROR_NO_EVENT_PAIR
//
// MessageText:
//
// An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.
//
#define ERROR_NO_EVENT_PAIR 580L

//
// MessageId: ERROR_DOMAIN_CTRLR_CONFIG_ERROR
//
// MessageText:
//
// A Windows Server has an incorrect configuration.
//
#define ERROR_DOMAIN_CTRLR_CONFIG_ERROR 581L

//
// MessageId: ERROR_ILLEGAL_CHARACTER
//
// MessageText:
//
// An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.
//
#define ERROR_ILLEGAL_CHARACTER 582L

//
// MessageId: ERROR_UNDEFINED_CHARACTER
//
// MessageText:
//
// The Unicode character is not defined in the Unicode character set installed on the system.
//
#define ERROR_UNDEFINED_CHARACTER 583L

//
// MessageId: ERROR_FLOPPY_VOLUME
//
// MessageText:
//
// The paging file cannot be created on a floppy diskette.
//
#define ERROR_FLOPPY_VOLUME 584L

//
// MessageId: ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT
//
// MessageText:
//
// The system BIOS failed to connect a system interrupt to the device or bus for which the device is connected.
//
#define ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT 585L

//
// MessageId: ERROR_BACKUP_CONTROLLER
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//
#define ERROR_BACKUP_CONTROLLER 586L

//
// MessageId: ERROR_MUTANT_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to acquire a mutant such that its maximum count would have been exceeded.
//
#define ERROR_MUTANT_LIMIT_EXCEEDED 587L

//
// MessageId: ERROR_FS_DRIVER_REQUIRED
//
// MessageText:
//
// A volume has been accessed for which a file system driver is required that has not yet been loaded.
//
#define ERROR_FS_DRIVER_REQUIRED 588L

//
// MessageId: ERROR_CANNOT_LOAD_REGISTRY_FILE
//
// MessageText:
//
// {Registry File Failure}
// The registry cannot load the hive (file):
// %hs
// or its log or alternate.
// It is corrupt, absent, or not writable.
//
#define ERROR_CANNOT_LOAD_REGISTRY_FILE 589L

//
// MessageId: ERROR_DEBUG_ATTACH_FAILED
//
// MessageText:
//
// {Unexpected Failure in DebugActiveProcess}
// An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.
//
#define ERROR_DEBUG_ATTACH_FAILED 590L

//
// MessageId: ERROR_SYSTEM_PROCESS_TERMINATED
//
// MessageText:
//
// {Fatal System Error}
// The %hs system process terminated unexpectedly with a status of 0x%08x (0x%08x 0x%08x).
// The system has been shut down.
//
#define ERROR_SYSTEM_PROCESS_TERMINATED 591L

//
// MessageId: ERROR_DATA_NOT_ACCEPTED
//
// MessageText:
//
// {Data Not Accepted}
// The TDI client could not handle the data received during an indication.
//
#define ERROR_DATA_NOT_ACCEPTED 592L

//
// MessageId: ERROR_VDM_HARD_ERROR
//
// MessageText:
//
// NTVDM encountered a hard error.
//
#define ERROR_VDM_HARD_ERROR 593L

//
// MessageId: ERROR_DRIVER_CANCEL_TIMEOUT
//
// MessageText:
//
// {Cancel Timeout}
// The driver %hs failed to complete a cancelled I/O request in the allotted time.
//
#define ERROR_DRIVER_CANCEL_TIMEOUT 594L

//
// MessageId: ERROR_REPLY_MESSAGE_MISMATCH
//
// MessageText:
//
// {Reply Message Mismatch}
// An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.
//
#define ERROR_REPLY_MESSAGE_MISMATCH 595L

//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs. The data has been lost.
// This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
#define ERROR_LOST_WRITEBEHIND_DATA 596L

//
// MessageId: ERROR_CLIENT_SERVER_PARAMETERS_INVALID
//
// MessageText:
//
// The parameter(s) passed to the server in the client/server shared memory window were invalid. Too much data may have been put in the shared memory window.
//
#define ERROR_CLIENT_SERVER_PARAMETERS_INVALID 597L

//
// MessageId: ERROR_NOT_TINY_STREAM
//
// MessageText:
//
// The stream is not a tiny stream.
//
#define ERROR_NOT_TINY_STREAM 598L

//
// MessageId: ERROR_STACK_OVERFLOW_READ
//
// MessageText:
//
// The request must be handled by the stack overflow code.
//
#define ERROR_STACK_OVERFLOW_READ 599L

//
// MessageId: ERROR_CONVERT_TO_LARGE
//
// MessageText:
//
// Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing onode is moved or the extent stream is converted to a large stream.
//
#define ERROR_CONVERT_TO_LARGE 600L

//
// MessageId: ERROR_FOUND_OUT_OF_SCOPE
//
// MessageText:
//
// The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.
//
#define ERROR_FOUND_OUT_OF_SCOPE 601L

//
// MessageId: ERROR_ALLOCATE_BUCKET
//
// MessageText:
//
// The bucket array must be grown. Retry transaction after doing so.
//
#define ERROR_ALLOCATE_BUCKET 602L

//
// MessageId: ERROR_MARSHALL_OVERFLOW
//
// MessageText:
//
// The user/kernel marshalling buffer has overflowed.
//
#define ERROR_MARSHALL_OVERFLOW 603L

//
// MessageId: ERROR_INVALID_VARIANT
//
// MessageText:
//
// The supplied variant structure contains invalid data.
//
#define ERROR_INVALID_VARIANT 604L

//
// MessageId: ERROR_BAD_COMPRESSION_BUFFER
//
// MessageText:
//
// The specified buffer contains ill-formed data.
//
#define ERROR_BAD_COMPRESSION_BUFFER 605L

//
// MessageId: ERROR_AUDIT_FAILED
//
// MessageText:
//
// {Audit Failed}
// An attempt to generate a security audit failed.
//
#define ERROR_AUDIT_FAILED 606L

//
// MessageId: ERROR_TIMER_RESOLUTION_NOT_SET
//
// MessageText:
//
// The timer resolution was not previously set by the current process.
//
#define ERROR_TIMER_RESOLUTION_NOT_SET 607L

//
// MessageId: ERROR_INSUFFICIENT_LOGON_INFO
//
// MessageText:
//
// There is insufficient account information to log you on.
//
#define ERROR_INSUFFICIENT_LOGON_INFO 608L

//
// MessageId: ERROR_BAD_DLL_ENTRYPOINT
//
// MessageText:
//
// {Invalid DLL Entrypoint}
// The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state.
// The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue execution. Selecting NO may cause the application to operate incorrectly.
//
#define ERROR_BAD_DLL_ENTRYPOINT 609L

//
// MessageId: ERROR_BAD_SERVICE_ENTRYPOINT
//
// MessageText:
//
// {Invalid Service Callback Entrypoint}
// The %hs service is not written correctly. The stack pointer has been left in an inconsistent state.
// The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the service to continue operation. However, the service process may operate incorrectly.
//
#define ERROR_BAD_SERVICE_ENTRYPOINT 610L

//
// MessageId: ERROR_IP_ADDRESS_CONFLICT1
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//
#define ERROR_IP_ADDRESS_CONFLICT1 611L

//
// MessageId: ERROR_IP_ADDRESS_CONFLICT2
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//
#define ERROR_IP_ADDRESS_CONFLICT2 612L

//
// MessageId: ERROR_REGISTRY_QUOTA_LIMIT
//
// MessageText:
//
// {Low On Registry Space}
// The system has reached the maximum size allowed for the system part of the registry. Additional storage requests will be ignored.
//
#define ERROR_REGISTRY_QUOTA_LIMIT 613L

//
// MessageId: ERROR_NO_CALLBACK_ACTIVE
//
// MessageText:
//
// A callback return system service cannot be executed when no callback is active.
//
#define ERROR_NO_CALLBACK_ACTIVE 614L

//
// MessageId: ERROR_PWD_TOO_SHORT
//
// MessageText:
//
// The password provided is too short to meet the policy of your user account.
// Please choose a longer password.
//
#define ERROR_PWD_TOO_SHORT 615L

//
// MessageId: ERROR_PWD_TOO_RECENT
//
// MessageText:
//
// The policy of your user account does not allow you to change passwords too frequently.
// This is done to prevent users from changing back to a familiar, but potentially discovered, password.
// If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned.
//
#define ERROR_PWD_TOO_RECENT 616L

//
// MessageId: ERROR_PWD_HISTORY_CONFLICT
//
// MessageText:
//
// You have attempted to change your password to one that you have used in the past.
// The policy of your user account does not allow this. Please select a password that you have not previously used.
//
#define ERROR_PWD_HISTORY_CONFLICT 617L

//
// MessageId: ERROR_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
// The specified compression format is unsupported.
//
#define ERROR_UNSUPPORTED_COMPRESSION 618L

//
// MessageId: ERROR_INVALID_HW_PROFILE
//
// MessageText:
//
// The specified hardware profile configuration is invalid.
//
#define ERROR_INVALID_HW_PROFILE 619L

//
// MessageId: ERROR_INVALID_PLUGPLAY_DEVICE_PATH
//
// MessageText:
//
// The specified Plug and Play registry device path is invalid.
//
#define ERROR_INVALID_PLUGPLAY_DEVICE_PATH 620L

//
// MessageId: ERROR_QUOTA_LIST_INCONSISTENT
//
// MessageText:
//
// The specified quota list is internally inconsistent with its descriptor.
//
#define ERROR_QUOTA_LIST_INCONSISTENT 621L

//
// MessageId: ERROR_EVALUATION_EXPIRATION
//
// MessageText:
//
// {Windows Evaluation Notification}
// The evaluation period for this installation of Windows has expired. This system will shutdown in 1 hour. To restore access to this installation of Windows, please upgrade this installation using a licensed distribution of this product.
//
#define ERROR_EVALUATION_EXPIRATION 622L

//
// MessageId: ERROR_ILLEGAL_DLL_RELOCATION
//
// MessageText:
//
// {Illegal System DLL Relocation}
// The system DLL %hs was relocated in memory. The application will not run properly.
// The relocation occurred because the DLL %hs occupied an address range reserved for Windows system DLLs. The vendor supplying the DLL should be contacted for a new DLL.
//
#define ERROR_ILLEGAL_DLL_RELOCATION 623L

//
// MessageId: ERROR_DLL_INIT_FAILED_LOGOFF
//
// MessageText:
//
// {DLL Initialization Failed}
// The application failed to initialize because the window station is shutting down.
//
#define ERROR_DLL_INIT_FAILED_LOGOFF 624L

//
// MessageId: ERROR_VALIDATE_CONTINUE
//
// MessageText:
//
// The validation process needs to continue on to the next step.
//
#define ERROR_VALIDATE_CONTINUE 625L

//
// MessageId: ERROR_NO_MORE_MATCHES
//
// MessageText:
//
// There are no more matches for the current index enumeration.
//
#define ERROR_NO_MORE_MATCHES 626L

//
// MessageId: ERROR_RANGE_LIST_CONFLICT
//
// MessageText:
//
// The range could not be added to the range list because of a conflict.
//
#define ERROR_RANGE_LIST_CONFLICT 627L

//
// MessageId: ERROR_SERVER_SID_MISMATCH
//
// MessageText:
//
// The server process is running under a SID different than that required by client.
//
#define ERROR_SERVER_SID_MISMATCH 628L

//
// MessageId: ERROR_CANT_ENABLE_DENY_ONLY
//
// MessageText:
//
// A group marked use for deny only cannot be enabled.
//
#define ERROR_CANT_ENABLE_DENY_ONLY 629L

//
// MessageId: ERROR_FLOAT_MULTIPLE_FAULTS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point faults.
//
#define ERROR_FLOAT_MULTIPLE_FAULTS 630L

//
// MessageId: ERROR_FLOAT_MULTIPLE_TRAPS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point traps.
//
#define ERROR_FLOAT_MULTIPLE_TRAPS 631L

//
// MessageId: ERROR_NOINTERFACE
//
// MessageText:
//
// The requested interface is not supported.
//
#define ERROR_NOINTERFACE 632L

//
// MessageId: ERROR_DRIVER_FAILED_SLEEP
//
// MessageText:
//
// {System Standby Failed}
// The driver %hs does not support standby mode. Updating this driver may allow the system to go to standby mode.
//
#define ERROR_DRIVER_FAILED_SLEEP 633L

//
// MessageId: ERROR_CORRUPT_SYSTEM_FILE
//
// MessageText:
//
// The system file %1 has become corrupt and has been replaced.
//
#define ERROR_CORRUPT_SYSTEM_FILE 634L

//
// MessageId: ERROR_COMMITMENT_MINIMUM
//
// MessageText:
//
// {Virtual Memory Minimum Too Low}
// Your system is low on virtual memory. Windows is increasing the size of your virtual memory paging file.
// During this process, memory requests for some applications may be denied. For more information, see Help.
//
#define ERROR_COMMITMENT_MINIMUM 635L

//
// MessageId: ERROR_PNP_RESTART_ENUMERATION
//
// MessageText:
//
// A device was removed so enumeration must be restarted.
//
#define ERROR_PNP_RESTART_ENUMERATION 636L

//
// MessageId: ERROR_SYSTEM_IMAGE_BAD_SIGNATURE
//
// MessageText:
//
// {Fatal System Error}
// The system image %s is not properly signed.
// The file has been replaced with the signed file.
// The system has been shut down.
//
#define ERROR_SYSTEM_IMAGE_BAD_SIGNATURE 637L

//
// MessageId: ERROR_PNP_REBOOT_REQUIRED
//
// MessageText:
//
// Device will not start without a reboot.
//
#define ERROR_PNP_REBOOT_REQUIRED 638L

//
// MessageId: ERROR_INSUFFICIENT_POWER
//
// MessageText:
//
// There is not enough power to complete the requested operation.
//
#define ERROR_INSUFFICIENT_POWER 639L

//
// MessageId: ERROR_MULTIPLE_FAULT_VIOLATION
//
// MessageText:
//
//  ERROR_MULTIPLE_FAULT_VIOLATION
//
#define ERROR_MULTIPLE_FAULT_VIOLATION 640L

//
// MessageId: ERROR_SYSTEM_SHUTDOWN
//
// MessageText:
//
// The system is in the process of shutting down.
//
#define ERROR_SYSTEM_SHUTDOWN 641L

//
// MessageId: ERROR_PORT_NOT_SET
//
// MessageText:
//
// An attempt to remove a processes DebugPort was made, but a port was not already associated with the process.
//
#define ERROR_PORT_NOT_SET 642L

//
// MessageId: ERROR_DS_VERSION_CHECK_FAILURE
//
// MessageText:
//
// This version of Windows is not compatible with the behavior version of directory forest, domain or domain controller.
//
#define ERROR_DS_VERSION_CHECK_FAILURE 643L

//
// MessageId: ERROR_RANGE_NOT_FOUND
//
// MessageText:
//
// The specified range could not be found in the range list.
//
#define ERROR_RANGE_NOT_FOUND 644L

//
// MessageId: ERROR_NOT_SAFE_MODE_DRIVER
//
// MessageText:
//
// The driver was not loaded because the system is booting into safe mode.
//
#define ERROR_NOT_SAFE_MODE_DRIVER 646L

//
// MessageId: ERROR_FAILED_DRIVER_ENTRY
//
// MessageText:
//
// The driver was not loaded because it failed it's initialization call.
//
#define ERROR_FAILED_DRIVER_ENTRY 647L

//
// MessageId: ERROR_DEVICE_ENUMERATION_ERROR
//
// MessageText:
//
// The "%hs" encountered an error while applying power or reading the device configuration.
// This may be caused by a failure of your hardware or by a poor connection.
//
#define ERROR_DEVICE_ENUMERATION_ERROR 648L

//
// MessageId: ERROR_MOUNT_POINT_NOT_RESOLVED
//
// MessageText:
//
// The create operation failed because the name contained at least one mount point which resolves to a volume to which the specified device object is not attached.
//
#define ERROR_MOUNT_POINT_NOT_RESOLVED 649L

//
// MessageId: ERROR_INVALID_DEVICE_OBJECT_PARAMETER
//
// MessageText:
//
// The device object parameter is either not a valid device object or is not attached to the volume specified by the file name.
//
#define ERROR_INVALID_DEVICE_OBJECT_PARAMETER 650L

//
// MessageId: ERROR_MCA_OCCURED
//
// MessageText:
//
// A Machine Check Error has occurred. Please check the system eventlog for additional information.
//
#define ERROR_MCA_OCCURED 651L

//
// MessageId: ERROR_DRIVER_DATABASE_ERROR
//
// MessageText:
//
// There was error [%2] processing the driver database.
//
#define ERROR_DRIVER_DATABASE_ERROR 652L

//
// MessageId: ERROR_SYSTEM_HIVE_TOO_LARGE
//
// MessageText:
//
// System hive size has exceeded its limit.
//
#define ERROR_SYSTEM_HIVE_TOO_LARGE 653L

//
// MessageId: ERROR_DRIVER_FAILED_PRIOR_UNLOAD
//
// MessageText:
//
// The driver could not be loaded because a previous version of the driver is still in memory.
//
#define ERROR_DRIVER_FAILED_PRIOR_UNLOAD 654L

//
// MessageId: ERROR_VOLSNAP_PREPARE_HIBERNATE
//
// MessageText:
//
// {Volume Shadow Copy Service}
// Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.
//
#define ERROR_VOLSNAP_PREPARE_HIBERNATE 655L

//
// MessageId: ERROR_HIBERNATION_FAILURE
//
// MessageText:
//
// The system has failed to hibernate (The error code is %hs). Hibernation will be disabled until the system is restarted.
//
#define ERROR_HIBERNATION_FAILURE 656L

//
// MessageId: ERROR_FILE_SYSTEM_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a file system limitation
//
#define ERROR_FILE_SYSTEM_LIMITATION 665L

//
// MessageId: ERROR_ASSERTION_FAILURE
//
// MessageText:
//
// An assertion failure has occurred.
//
#define ERROR_ASSERTION_FAILURE 668L

//
// MessageId: ERROR_ACPI_ERROR
//
// MessageText:
//
// An error occurred in the ACPI subsystem.
//
#define ERROR_ACPI_ERROR 669L

//
// MessageId: ERROR_WOW_ASSERTION
//
// MessageText:
//
// WOW Assertion Error.
//
#define ERROR_WOW_ASSERTION 670L

//
// MessageId: ERROR_PNP_BAD_MPS_TABLE
//
// MessageText:
//
// A device is missing in the system BIOS MPS table. This device will not be used.
// Please contact your system vendor for system BIOS update.
//
#define ERROR_PNP_BAD_MPS_TABLE 671L

//
// MessageId: ERROR_PNP_TRANSLATION_FAILED
//
// MessageText:
//
// A translator failed to translate resources.
//
#define ERROR_PNP_TRANSLATION_FAILED 672L

//
// MessageId: ERROR_PNP_IRQ_TRANSLATION_FAILED
//
// MessageText:
//
// A IRQ translator failed to translate resources.
//
#define ERROR_PNP_IRQ_TRANSLATION_FAILED 673L

//
// MessageId: ERROR_PNP_INVALID_ID
//
// MessageText:
//
// Driver %2 returned invalid ID for a child device (%3).
//
#define ERROR_PNP_INVALID_ID 674L

//
// MessageId: ERROR_WAKE_SYSTEM_DEBUGGER
//
// MessageText:
//
// {Kernel Debugger Awakened}
// the system debugger was awakened by an interrupt.
//
#define ERROR_WAKE_SYSTEM_DEBUGGER 675L

//
// MessageId: ERROR_HANDLES_CLOSED
//
// MessageText:
//
// {Handles Closed}
// Handles to objects have been automatically closed as a result of the requested operation.
//
#define ERROR_HANDLES_CLOSED 676L

//
// MessageId: ERROR_EXTRANEOUS_INFORMATION
//
// MessageText:
//
// {Too Much Information}
// The specified access control list (ACL) contained more information than was expected.
//
#define ERROR_EXTRANEOUS_INFORMATION 677L

//
// MessageId: ERROR_RXACT_COMMIT_NECESSARY
//
// MessageText:
//
// This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
// The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired).
//
#define ERROR_RXACT_COMMIT_NECESSARY 678L

//
// MessageId: ERROR_MEDIA_CHECK
//
// MessageText:
//
// {Media Changed}
// The media may have changed.
//
#define ERROR_MEDIA_CHECK 679L

//
// MessageId: ERROR_GUID_SUBSTITUTION_MADE
//
// MessageText:
//
// {GUID Substitution}
// During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found.
// A substitute prefix was used, which will not compromise system security. However, this may provide a more restrictive access than intended.
//
#define ERROR_GUID_SUBSTITUTION_MADE 680L

//
// MessageId: ERROR_STOPPED_ON_SYMLINK
//
// MessageText:
//
// The create operation stopped after reaching a symbolic link
//
#define ERROR_STOPPED_ON_SYMLINK 681L

//
// MessageId: ERROR_LONGJUMP
//
// MessageText:
//
// A long jump has been executed.
//
#define ERROR_LONGJUMP 682L

//
// MessageId: ERROR_PLUGPLAY_QUERY_VETOED
//
// MessageText:
//
// The Plug and Play query operation was not successful.
//
#define ERROR_PLUGPLAY_QUERY_VETOED 683L

//
// MessageId: ERROR_UNWIND_CONSOLIDATE
//
// MessageText:
//
// A frame consolidation has been executed.
//
#define ERROR_UNWIND_CONSOLIDATE 684L

//
// MessageId: ERROR_REGISTRY_HIVE_RECOVERED
//
// MessageText:
//
// {Registry Hive Recovered}
// Registry hive (file):
// %hs
// was corrupted and it has been recovered. Some data might have been lost.
//
#define ERROR_REGISTRY_HIVE_RECOVERED 685L

//
// MessageId: ERROR_DLL_MIGHT_BE_INSECURE
//
// MessageText:
//
// The application is attempting to run executable code from the module %hs. This may be insecure. An alternative, %hs, is available. Should the application use the secure module %hs?
//
#define ERROR_DLL_MIGHT_BE_INSECURE 686L

//
// MessageId: ERROR_DLL_MIGHT_BE_INCOMPATIBLE
//
// MessageText:
//
// The application is loading executable code from the module %hs. This is secure, but may be incompatible with previous releases of the operating system. An alternative, %hs, is available. Should the application use the secure module %hs?
//
#define ERROR_DLL_MIGHT_BE_INCOMPATIBLE 687L

//
// MessageId: ERROR_DBG_EXCEPTION_NOT_HANDLED
//
// MessageText:
//
// Debugger did not handle the exception.
//
#define ERROR_DBG_EXCEPTION_NOT_HANDLED 688L

//
// MessageId: ERROR_DBG_REPLY_LATER
//
// MessageText:
//
// Debugger will reply later.
//
#define ERROR_DBG_REPLY_LATER 689L

//
// MessageId: ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE
//
// MessageText:
//
// Debugger cannot provide handle.
//
#define ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE 690L

//
// MessageId: ERROR_DBG_TERMINATE_THREAD
//
// MessageText:
//
// Debugger terminated thread.
//
#define ERROR_DBG_TERMINATE_THREAD 691L

//
// MessageId: ERROR_DBG_TERMINATE_PROCESS
//
// MessageText:
//
// Debugger terminated process.
//
#define ERROR_DBG_TERMINATE_PROCESS 692L

//
// MessageId: ERROR_DBG_CONTROL_C
//
// MessageText:
//
// Debugger got control C.
//
#define ERROR_DBG_CONTROL_C 693L

//
// MessageId: ERROR_DBG_PRINTEXCEPTION_C
//
// MessageText:
//
// Debugger printed exception on control C.
//
#define ERROR_DBG_PRINTEXCEPTION_C 694L

//
// MessageId: ERROR_DBG_RIPEXCEPTION
//
// MessageText:
//
// Debugger received RIP exception.
//
#define ERROR_DBG_RIPEXCEPTION 695L

//
// MessageId: ERROR_DBG_CONTROL_BREAK
//
// MessageText:
//
// Debugger received control break.
//
#define ERROR_DBG_CONTROL_BREAK 696L

//
// MessageId: ERROR_DBG_COMMAND_EXCEPTION
//
// MessageText:
//
// Debugger command communication exception.
//
#define ERROR_DBG_COMMAND_EXCEPTION 697L

//
// MessageId: ERROR_OBJECT_NAME_EXISTS
//
// MessageText:
//
// {Object Exists}
// An attempt was made to create an object and the object name already existed.
//
#define ERROR_OBJECT_NAME_EXISTS 698L

//
// MessageId: ERROR_THREAD_WAS_SUSPENDED
//
// MessageText:
//
// {Thread Suspended}
// A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.
//
#define ERROR_THREAD_WAS_SUSPENDED 699L

//
// MessageId: ERROR_IMAGE_NOT_AT_BASE
//
// MessageText:
//
// {Image Relocated}
// An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.
//
#define ERROR_IMAGE_NOT_AT_BASE 700L

//
// MessageId: ERROR_RXACT_STATE_CREATED
//
// MessageText:
//
// This informational level status indicates that a specified registry sub-tree transaction state did not yet exist and had to be created.
//
#define ERROR_RXACT_STATE_CREATED 701L

//
// MessageId: ERROR_SEGMENT_NOTIFICATION
//
// MessageText:
//
// {Segment Load}
// A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS or Win16 program segment image.
// An exception is raised so a debugger can load, unload or track symbols and breakpoints within these 16-bit segments.
//
#define ERROR_SEGMENT_NOTIFICATION 702L

//
// MessageId: ERROR_BAD_CURRENT_DIRECTORY
//
// MessageText:
//
// {Invalid Current Directory}
// The process cannot switch to the startup current directory %hs.
// Select OK to set current directory to %hs, or select CANCEL to exit.
//
#define ERROR_BAD_CURRENT_DIRECTORY 703L

//
// MessageId: ERROR_FT_READ_RECOVERY_FROM_BACKUP
//
// MessageText:
//
// {Redundant Read}
// To satisfy a read request, the NT fault-tolerant file system successfully read the requested data from a redundant copy.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was unable to reassign the failing area of the device.
//
#define ERROR_FT_READ_RECOVERY_FROM_BACKUP 704L

//
// MessageId: ERROR_FT_WRITE_RECOVERY
//
// MessageText:
//
// {Redundant Write}
// To satisfy a write request, the NT fault-tolerant file system successfully wrote a redundant copy of the information.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was not able to reassign the failing area of the device.
//
#define ERROR_FT_WRITE_RECOVERY 705L

//
// MessageId: ERROR_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//
#define ERROR_IMAGE_MACHINE_TYPE_MISMATCH 706L

//
// MessageId: ERROR_RECEIVE_PARTIAL
//
// MessageText:
//
// {Partial Data Received}
// The network transport returned partial data to its client. The remaining data will be sent later.
//
#define ERROR_RECEIVE_PARTIAL 707L

//
// MessageId: ERROR_RECEIVE_EXPEDITED
//
// MessageText:
//
// {Expedited Data Received}
// The network transport returned data to its client that was marked as expedited by the remote system.
//
#define ERROR_RECEIVE_EXPEDITED 708L

//
// MessageId: ERROR_RECEIVE_PARTIAL_EXPEDITED
//
// MessageText:
//
// {Partial Expedited Data Received}
// The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.
//
#define ERROR_RECEIVE_PARTIAL_EXPEDITED 709L

//
// MessageId: ERROR_EVENT_DONE
//
// MessageText:
//
// {TDI Event Done}
// The TDI indication has completed successfully.
//
#define ERROR_EVENT_DONE 710L

//
// MessageId: ERROR_EVENT_PENDING
//
// MessageText:
//
// {TDI Event Pending}
// The TDI indication has entered the pending state.
//
#define ERROR_EVENT_PENDING 711L

//
// MessageId: ERROR_CHECKING_FILE_SYSTEM
//
// MessageText:
//
// Checking file system on %wZ
//
#define ERROR_CHECKING_FILE_SYSTEM 712L

//
// MessageId: ERROR_FATAL_APP_EXIT
//
// MessageText:
//
// {Fatal Application Exit}
// %hs
//
#define ERROR_FATAL_APP_EXIT 713L

//
// MessageId: ERROR_PREDEFINED_HANDLE
//
// MessageText:
//
// The specified registry key is referenced by a predefined handle.
//
#define ERROR_PREDEFINED_HANDLE 714L

//
// MessageId: ERROR_WAS_UNLOCKED
//
// MessageText:
//
// {Page Unlocked}
// The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.
//
#define ERROR_WAS_UNLOCKED 715L

//
// MessageId: ERROR_SERVICE_NOTIFICATION
//
// MessageText:
//
// %hs
//
#define ERROR_SERVICE_NOTIFICATION 716L

//
// MessageId: ERROR_WAS_LOCKED
//
// MessageText:
//
// {Page Locked}
// One of the pages to lock was already locked.
//
#define ERROR_WAS_LOCKED 717L

//
// MessageId: ERROR_LOG_HARD_ERROR
//
// MessageText:
//
// Application popup: %1 : %2
//
#define ERROR_LOG_HARD_ERROR 718L

//
// MessageId: ERROR_ALREADY_WIN32
//
// MessageText:
//
//  ERROR_ALREADY_WIN32
//
#define ERROR_ALREADY_WIN32 719L

//
// MessageId: ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine.
//
#define ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE 720L

//
// MessageId: ERROR_NO_YIELD_PERFORMED
//
// MessageText:
//
// A yield execution was performed and no thread was available to run.
//
#define ERROR_NO_YIELD_PERFORMED 721L

//
// MessageId: ERROR_TIMER_RESUME_IGNORED
//
// MessageText:
//
// The resumable flag to a timer API was ignored.
//
#define ERROR_TIMER_RESUME_IGNORED 722L

//
// MessageId: ERROR_ARBITRATION_UNHANDLED
//
// MessageText:
//
// The arbiter has deferred arbitration of these resources to its parent
//
#define ERROR_ARBITRATION_UNHANDLED 723L

//
// MessageId: ERROR_CARDBUS_NOT_SUPPORTED
//
// MessageText:
//
// The inserted CardBus device cannot be started because of a configuration error on "%hs".
//
#define ERROR_CARDBUS_NOT_SUPPORTED 724L

//
// MessageId: ERROR_MP_PROCESSOR_MISMATCH
//
// MessageText:
//
// The CPUs in this multiprocessor system are not all the same revision level. To use all processors the operating system restricts itself to the features of the least capable processor in the system. Should problems occur with this system, contact the CPU manufacturer to see if this mix of processors is supported.
//
#define ERROR_MP_PROCESSOR_MISMATCH 725L

//
// MessageId: ERROR_HIBERNATED
//
// MessageText:
//
// The system was put into hibernation.
//
#define ERROR_HIBERNATED 726L

//
// MessageId: ERROR_RESUME_HIBERNATION
//
// MessageText:
//
// The system was resumed from hibernation.
//
#define ERROR_RESUME_HIBERNATION 727L

//
// MessageId: ERROR_FIRMWARE_UPDATED
//
// MessageText:
//
// Windows has detected that the system firmware (BIOS) was updated [previous firmware date = %2, current firmware date %3].
//
#define ERROR_FIRMWARE_UPDATED 728L

//
// MessageId: ERROR_DRIVERS_LEAKING_LOCKED_PAGES
//
// MessageText:
//
// A device driver is leaking locked I/O pages causing system degradation. The system has automatically enabled tracking code in order to try and catch the culprit.
//
#define ERROR_DRIVERS_LEAKING_LOCKED_PAGES 729L

//
// MessageId: ERROR_WAKE_SYSTEM
//
// MessageText:
//
// The system has awoken
//
#define ERROR_WAKE_SYSTEM 730L

//
// MessageId: ERROR_WAIT_1
//
// MessageText:
//
//  ERROR_WAIT_1
//
#define ERROR_WAIT_1 731L

//
// MessageId: ERROR_WAIT_2
//
// MessageText:
//
//  ERROR_WAIT_2
//
#define ERROR_WAIT_2 732L

//
// MessageId: ERROR_WAIT_3
//
// MessageText:
//
//  ERROR_WAIT_3
//
#define ERROR_WAIT_3 733L

//
// MessageId: ERROR_WAIT_63
//
// MessageText:
//
//  ERROR_WAIT_63
//
#define ERROR_WAIT_63 734L

//
// MessageId: ERROR_ABANDONED_WAIT_0
//
// MessageText:
//
//  ERROR_ABANDONED_WAIT_0
//
#define ERROR_ABANDONED_WAIT_0 735L

//
// MessageId: ERROR_ABANDONED_WAIT_63
//
// MessageText:
//
//  ERROR_ABANDONED_WAIT_63
//
#define ERROR_ABANDONED_WAIT_63 736L

//
// MessageId: ERROR_USER_APC
//
// MessageText:
//
//  ERROR_USER_APC
//
#define ERROR_USER_APC 737L

//
// MessageId: ERROR_KERNEL_APC
//
// MessageText:
//
//  ERROR_KERNEL_APC
//
#define ERROR_KERNEL_APC 738L

//
// MessageId: ERROR_ALERTED
//
// MessageText:
//
//  ERROR_ALERTED
//
#define ERROR_ALERTED 739L

//
// MessageId: ERROR_ELEVATION_REQUIRED
//
// MessageText:
//
// The requested operation requires elevation.
//
#define ERROR_ELEVATION_REQUIRED 740L

//
// MessageId: ERROR_REPARSE
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
#define ERROR_REPARSE 741L

//
// MessageId: ERROR_OPLOCK_BREAK_IN_PROGRESS
//
// MessageText:
//
// An open/create operation completed while an oplock break is underway.
//
#define ERROR_OPLOCK_BREAK_IN_PROGRESS 742L

//
// MessageId: ERROR_VOLUME_MOUNTED
//
// MessageText:
//
// A new volume has been mounted by a file system.
//
#define ERROR_VOLUME_MOUNTED 743L

//
// MessageId: ERROR_RXACT_COMMITTED
//
// MessageText:
//
// This success level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
// The commit has now been completed.
//
#define ERROR_RXACT_COMMITTED 744L

//
// MessageId: ERROR_NOTIFY_CLEANUP
//
// MessageText:
//
// This indicates that a notify change request has been completed due to closing the handle which made the notify change request.
//
#define ERROR_NOTIFY_CLEANUP 745L

//
// MessageId: ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
// {Connect Failure on Primary Transport}
// An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed.
// The computer WAS able to connect on a secondary transport.
//
#define ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED 746L

//
// MessageId: ERROR_PAGE_FAULT_TRANSITION
//
// MessageText:
//
// Page fault was a transition fault.
//
#define ERROR_PAGE_FAULT_TRANSITION 747L

//
// MessageId: ERROR_PAGE_FAULT_DEMAND_ZERO
//
// MessageText:
//
// Page fault was a demand zero fault.
//
#define ERROR_PAGE_FAULT_DEMAND_ZERO 748L

//
// MessageId: ERROR_PAGE_FAULT_COPY_ON_WRITE
//
// MessageText:
//
// Page fault was a demand zero fault.
//
#define ERROR_PAGE_FAULT_COPY_ON_WRITE 749L

//
// MessageId: ERROR_PAGE_FAULT_GUARD_PAGE
//
// MessageText:
//
// Page fault was a demand zero fault.
//
#define ERROR_PAGE_FAULT_GUARD_PAGE 750L

//
// MessageId: ERROR_PAGE_FAULT_PAGING_FILE
//
// MessageText:
//
// Page fault was satisfied by reading from a secondary storage device.
//
#define ERROR_PAGE_FAULT_PAGING_FILE 751L

//
// MessageId: ERROR_CACHE_PAGE_LOCKED
//
// MessageText:
//
// Cached page was locked during operation.
//
#define ERROR_CACHE_PAGE_LOCKED 752L

//
// MessageId: ERROR_CRASH_DUMP
//
// MessageText:
//
// Crash dump exists in paging file.
//
#define ERROR_CRASH_DUMP 753L

//
// MessageId: ERROR_BUFFER_ALL_ZEROS
//
// MessageText:
//
// Specified buffer contains all zeros.
//
#define ERROR_BUFFER_ALL_ZEROS 754L

//
// MessageId: ERROR_REPARSE_OBJECT
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
#define ERROR_REPARSE_OBJECT 755L

//
// MessageId: ERROR_RESOURCE_REQUIREMENTS_CHANGED
//
// MessageText:
//
// The device has succeeded a query-stop and its resource requirements have changed.
//
#define ERROR_RESOURCE_REQUIREMENTS_CHANGED 756L

//
// MessageId: ERROR_TRANSLATION_COMPLETE
//
// MessageText:
//
// The translator has translated these resources into the global space and no further translations should be performed.
//
#define ERROR_TRANSLATION_COMPLETE 757L

//
// MessageId: ERROR_NOTHING_TO_TERMINATE
//
// MessageText:
//
// A process being terminated has no threads to terminate.
//
#define ERROR_NOTHING_TO_TERMINATE 758L

//
// MessageId: ERROR_PROCESS_NOT_IN_JOB
//
// MessageText:
//
// The specified process is not part of a job.
//
#define ERROR_PROCESS_NOT_IN_JOB 759L

//
// MessageId: ERROR_PROCESS_IN_JOB
//
// MessageText:
//
// The specified process is part of a job.
//
#define ERROR_PROCESS_IN_JOB 760L

//
// MessageId: ERROR_VOLSNAP_HIBERNATE_READY
//
// MessageText:
//
// {Volume Shadow Copy Service}
// The system is now ready for hibernation.
//
#define ERROR_VOLSNAP_HIBERNATE_READY 761L

//
// MessageId: ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY
//
// MessageText:
//
// A file system or file system filter driver has successfully completed an FsFilter operation.
//
#define ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY 762L

//
// MessageId: ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED
//
// MessageText:
//
// The specified interrupt vector was already connected.
//
#define ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED 763L

//
// MessageId: ERROR_INTERRUPT_STILL_CONNECTED
//
// MessageText:
//
// The specified interrupt vector is still connected.
//
#define ERROR_INTERRUPT_STILL_CONNECTED 764L

//
// MessageId: ERROR_WAIT_FOR_OPLOCK
//
// MessageText:
//
// An operation is blocked waiting for an oplock.
//
#define ERROR_WAIT_FOR_OPLOCK 765L

//
// MessageId: ERROR_DBG_EXCEPTION_HANDLED
//
// MessageText:
//
// Debugger handled exception
//
#define ERROR_DBG_EXCEPTION_HANDLED 766L

//
// MessageId: ERROR_DBG_CONTINUE
//
// MessageText:
//
// Debugger continued
//
#define ERROR_DBG_CONTINUE 767L

//
// MessageId: ERROR_CALLBACK_POP_STACK
//
// MessageText:
//
// An exception occurred in a user mode callback and the kernel callback frame should be removed.
//
#define ERROR_CALLBACK_POP_STACK 768L

//
// MessageId: ERROR_COMPRESSION_DISABLED
//
// MessageText:
//
// Compression is disabled for this volume.
//
#define ERROR_COMPRESSION_DISABLED 769L

//
// MessageId: ERROR_CANTFETCHBACKWARDS
//
// MessageText:
//
// The data provider cannot fetch backwards through a result set.
//
#define ERROR_CANTFETCHBACKWARDS 770L

//
// MessageId: ERROR_CANTSCROLLBACKWARDS
//
// MessageText:
//
// The data provider cannot scroll backwards through a result set.
//
#define ERROR_CANTSCROLLBACKWARDS 771L

//
// MessageId: ERROR_ROWSNOTRELEASED
//
// MessageText:
//
// The data provider requires that previously fetched data is released before asking for more data.
//
#define ERROR_ROWSNOTRELEASED 772L

//
// MessageId: ERROR_BAD_ACCESSOR_FLAGS
//
// MessageText:
//
// The data provider was not able to interpret the flags set for a column binding in an accessor.
//
#define ERROR_BAD_ACCESSOR_FLAGS 773L

//
// MessageId: ERROR_ERRORS_ENCOUNTERED
//
// MessageText:
//
// One or more errors occurred while processing the request.
//
#define ERROR_ERRORS_ENCOUNTERED 774L

//
// MessageId: ERROR_NOT_CAPABLE
//
// MessageText:
//
// The implementation is not capable of performing the request.
//
#define ERROR_NOT_CAPABLE 775L

//
// MessageId: ERROR_REQUEST_OUT_OF_SEQUENCE
//
// MessageText:
//
// The client of a component requested an operation which is not valid given the state of the component instance.
//
#define ERROR_REQUEST_OUT_OF_SEQUENCE 776L

//
// MessageId: ERROR_VERSION_PARSE_ERROR
//
// MessageText:
//
// A version number could not be parsed.
//
#define ERROR_VERSION_PARSE_ERROR 777L

//
// MessageId: ERROR_BADSTARTPOSITION
//
// MessageText:
//
// The iterator's start position is invalid.
//
#define ERROR_BADSTARTPOSITION 778L

//
// MessageId: ERROR_MEMORY_HARDWARE
//
// MessageText:
//
// The hardware has reported an uncorrectable memory error.
//
#define ERROR_MEMORY_HARDWARE 779L

//
// MessageId: ERROR_DISK_REPAIR_DISABLED
//
// MessageText:
//
// The attempted operation required self healing to be enabled.
//
#define ERROR_DISK_REPAIR_DISABLED 780L

//
// MessageId: ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE
//
// MessageText:
//
// The Desktop heap encountered an error while allocating session memory. There is more information in the system event log.
//
#define ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE 781L

//
// MessageId: ERROR_SYSTEM_POWERSTATE_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3.
//
#define ERROR_SYSTEM_POWERSTATE_TRANSITION 782L

//
// MessageId: ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3 but could enter %4.
//
#define ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION 783L

//
// MessageId: ERROR_MCA_EXCEPTION
//
// MessageText:
//
// A thread is getting dispatched with MCA EXCEPTION because of MCA.
//
#define ERROR_MCA_EXCEPTION 784L

//
// MessageId: ERROR_ACCESS_AUDIT_BY_POLICY
//
// MessageText:
//
// Access to %1 is monitored by policy rule %2.
//
#define ERROR_ACCESS_AUDIT_BY_POLICY 785L

//
// MessageId: ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by policy rule %2.
//
#define ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY 786L

//
// MessageId: ERROR_ABANDON_HIBERFILE
//
// MessageText:
//
// A valid hibernation file has been invalidated and should be abandoned.
//
#define ERROR_ABANDON_HIBERFILE 787L

//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error may be caused by network connectivity issues. Please try to save this file elsewhere.
//
#define ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED 788L

//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error was returned by the server on which the file exists. Please try to save this file elsewhere.
//
#define ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR 789L

//
// MessageId: ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs; the data has been lost.
// This error may be caused if the device has been removed or the media is write-protected.
//
#define ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR 790L

//
// MessageId: ERROR_BAD_MCFG_TABLE
//
// MessageText:
//
// The resources required for this device conflict with the MCFG table.
//
#define ERROR_BAD_MCFG_TABLE 791L

//
// MessageId: ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE
//
// MessageText:
//
// The oplock that was associated with this handle is now associated with a different handle.
//
#define ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE 800L

//
// MessageId: ERROR_CANNOT_GRANT_REQUESTED_OPLOCK
//
// MessageText:
//
// An oplock of the requested level cannot be granted.  An oplock of a lower level may be available.
//
#define ERROR_CANNOT_GRANT_REQUESTED_OPLOCK 801L

//
// MessageId: ERROR_CANNOT_BREAK_OPLOCK
//
// MessageText:
//
// The operation did not complete successfully because it would cause an oplock to be broken. The caller has requested that existing oplocks not be broken.
//
#define ERROR_CANNOT_BREAK_OPLOCK 802L

//
// MessageId: ERROR_OPLOCK_HANDLE_CLOSED
//
// MessageText:
//
// The handle with which this oplock was associated has been closed.  The oplock is now broken.
//
#define ERROR_OPLOCK_HANDLE_CLOSED 803L

//
// MessageId: ERROR_NO_ACE_CONDITION
//
// MessageText:
//
// The specified access control entry (ACE) does not contain a condition.
//
#define ERROR_NO_ACE_CONDITION 804L

//
// MessageId: ERROR_INVALID_ACE_CONDITION
//
// MessageText:
//
// The specified access control entry (ACE) contains an invalid condition.
//
#define ERROR_INVALID_ACE_CONDITION 805L

//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
// Access to the extended attribute was denied.
//
#define ERROR_EA_ACCESS_DENIED 994L

//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
// The I/O operation has been aborted because of either a thread exit or an application request.
//
#define ERROR_OPERATION_ABORTED 995L

//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
// Overlapped I/O event is not in a signaled state.
//
#define ERROR_IO_INCOMPLETE 996L

//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
// Overlapped I/O operation is in progress.
//
#define ERROR_IO_PENDING 997L

//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
// Invalid access to memory location.
//
#define ERROR_NOACCESS 998L

//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
// Error performing inpage operation.
//
#define ERROR_SWAPERROR 999L

//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
// Recursion too deep; the stack overflowed.
//
#define ERROR_STACK_OVERFLOW 1001L

//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
// The window cannot act on the sent message.
//
#define ERROR_INVALID_MESSAGE 1002L

//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
// Cannot complete this function.
//
#define ERROR_CAN_NOT_COMPLETE 1003L

//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
// Invalid flags.
//
#define ERROR_INVALID_FLAGS 1004L

//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
// The volume does not contain a recognized file system.
// Please make sure that all required file system drivers are loaded and that the volume is not corrupted.
//
#define ERROR_UNRECOGNIZED_VOLUME 1005L

//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
// The volume for a file has been externally altered so that the opened file is no longer valid.
//
#define ERROR_FILE_INVALID 1006L

//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
// The requested operation cannot be performed in full-screen mode.
//
#define ERROR_FULLSCREEN_MODE 1007L

//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
// An attempt was made to reference a token that does not exist.
//
#define ERROR_NO_TOKEN 1008L

//
// MessageId: ERROR_BADDB
//
// MessageText:
//
// The configuration registry database is corrupt.
//
#define ERROR_BADDB 1009L

//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
// The configuration registry key is invalid.
//
#define ERROR_BADKEY 1010L

//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
// The configuration registry key could not be opened.
//
#define ERROR_CANTOPEN 1011L

//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
// The configuration registry key could not be read.
//
#define ERROR_CANTREAD 1012L

//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
// The configuration registry key could not be written.
//
#define ERROR_CANTWRITE 1013L

//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
// One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.
//
#define ERROR_REGISTRY_RECOVERED 1014L

//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
// The registry is corrupted. The structure of one of the files containing registry data is corrupted, or the system's memory image of the file is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.
//
#define ERROR_REGISTRY_CORRUPT 1015L

//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
// An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.
//
#define ERROR_REGISTRY_IO_FAILED 1016L

//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
// The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.
//
#define ERROR_NOT_REGISTRY_FILE 1017L

//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
// Illegal operation attempted on a registry key that has been marked for deletion.
//
#define ERROR_KEY_DELETED 1018L

//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
// System could not allocate the required space in a registry log.
//
#define ERROR_NO_LOG_SPACE 1019L

//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
// Cannot create a symbolic link in a registry key that already has subkeys or values.
//
#define ERROR_KEY_HAS_CHILDREN 1020L

//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
// Cannot create a stable subkey under a volatile parent key.
//
#define ERROR_CHILD_MUST_BE_VOLATILE 1021L

//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
// A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.
//
#define ERROR_NOTIFY_ENUM_DIR 1022L

//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
// A stop control has been sent to a service that other running services are dependent on.
//
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051L

//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
// The requested control is not valid for this service.
//
#define ERROR_INVALID_SERVICE_CONTROL 1052L

//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
// The service did not respond to the start or control request in a timely fashion.
//
#define ERROR_SERVICE_REQUEST_TIMEOUT 1053L

//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
// A thread could not be created for the service.
//
#define ERROR_SERVICE_NO_THREAD 1054L

//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
// The service database is locked.
//
#define ERROR_SERVICE_DATABASE_LOCKED 1055L

//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
// An instance of the service is already running.
//
#define ERROR_SERVICE_ALREADY_RUNNING 1056L

//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
// The account name is invalid or does not exist, or the password is invalid for the account name specified.
//
#define ERROR_INVALID_SERVICE_ACCOUNT 1057L

//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
// The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.
//
#define ERROR_SERVICE_DISABLED 1058L

//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
// Circular service dependency was specified.
//
#define ERROR_CIRCULAR_DEPENDENCY 1059L

//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
// The specified service does not exist as an installed service.
//
#define ERROR_SERVICE_DOES_NOT_EXIST 1060L

//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
// The service cannot accept control messages at this time.
//
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061L

//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
// The service has not been started.
//
#define ERROR_SERVICE_NOT_ACTIVE 1062L

//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
// The service process could not connect to the service controller.
//
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063L

//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
// An exception occurred in the service when handling the control request.
//
#define ERROR_EXCEPTION_IN_SERVICE 1064L

//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
// The database specified does not exist.
//
#define ERROR_DATABASE_DOES_NOT_EXIST 1065L

//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
// The service has returned a service-specific error code.
//
#define ERROR_SERVICE_SPECIFIC_ERROR 1066L

//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
// The process terminated unexpectedly.
//
#define ERROR_PROCESS_ABORTED 1067L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
// The dependency service or group failed to start.
//
#define ERROR_SERVICE_DEPENDENCY_FAIL 1068L

//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
// The service did not start due to a logon failure.
//
#define ERROR_SERVICE_LOGON_FAILED 1069L

//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
// After starting, the service hung in a start-pending state.
//
#define ERROR_SERVICE_START_HANG 1070L

//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
// The specified service database lock is invalid.
//
#define ERROR_INVALID_SERVICE_LOCK 1071L

//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
// The specified service has been marked for deletion.
//
#define ERROR_SERVICE_MARKED_FOR_DELETE 1072L

//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
// The specified service already exists.
//
#define ERROR_SERVICE_EXISTS 1073L

//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
// The system is currently running with the last-known-good configuration.
//
#define ERROR_ALREADY_RUNNING_LKG 1074L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
// The dependency service does not exist or has been marked for deletion.
//
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075L

//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
// The current boot has already been accepted for use as the last-known-good control set.
//
#define ERROR_BOOT_ALREADY_ACCEPTED 1076L

//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
// No attempts to start the service have been made since the last boot.
//
#define ERROR_SERVICE_NEVER_STARTED 1077L

//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
// The name is already in use as either a service name or a service display name.
//
#define ERROR_DUPLICATE_SERVICE_NAME 1078L

//
// MessageId: ERROR_DIFFERENT_SERVICE_ACCOUNT
//
// MessageText:
//
// The account specified for this service is different from the account specified for other services running in the same process.
//
#define ERROR_DIFFERENT_SERVICE_ACCOUNT 1079L

//
// MessageId: ERROR_CANNOT_DETECT_DRIVER_FAILURE
//
// MessageText:
//
// Failure actions can only be set for Win32 services, not for drivers.
//
#define ERROR_CANNOT_DETECT_DRIVER_FAILURE 1080L

//
// MessageId: ERROR_CANNOT_DETECT_PROCESS_ABORT
//
// MessageText:
//
// This service runs in the same process as the service control manager.
// Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.
//
#define ERROR_CANNOT_DETECT_PROCESS_ABORT 1081L

//
// MessageId: ERROR_NO_RECOVERY_PROGRAM
//
// MessageText:
//
// No recovery program has been configured for this service.
//
#define ERROR_NO_RECOVERY_PROGRAM 1082L

//
// MessageId: ERROR_SERVICE_NOT_IN_EXE
//
// MessageText:
//
// The executable program that this service is configured to run in does not implement the service.
//
#define ERROR_SERVICE_NOT_IN_EXE 1083L

//
// MessageId: ERROR_NOT_SAFEBOOT_SERVICE
//
// MessageText:
//
// This service cannot be started in Safe Mode
//
#define ERROR_NOT_SAFEBOOT_SERVICE 1084L

//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
// The physical end of the tape has been reached.
//
#define ERROR_END_OF_MEDIA 1100L

//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
// A tape access reached a filemark.
//
#define ERROR_FILEMARK_DETECTED 1101L

//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
// The beginning of the tape or a partition was encountered.
//
#define ERROR_BEGINNING_OF_MEDIA 1102L

//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
// A tape access reached the end of a set of files.
//
#define ERROR_SETMARK_DETECTED 1103L

//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
// No more data is on the tape.
//
#define ERROR_NO_DATA_DETECTED 1104L

//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
// Tape could not be partitioned.
//
#define ERROR_PARTITION_FAILURE 1105L

//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
// When accessing a new tape of a multivolume partition, the current block size is incorrect.
//
#define ERROR_INVALID_BLOCK_LENGTH 1106L

//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
// Tape partition information could not be found when loading a tape.
//
#define ERROR_DEVICE_NOT_PARTITIONED 1107L

//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
// Unable to lock the media eject mechanism.
//
#define ERROR_UNABLE_TO_LOCK_MEDIA 1108L

//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
// Unable to unload the media.
//
#define ERROR_UNABLE_TO_UNLOAD_MEDIA 1109L

//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
// The media in the drive may have changed.
//
#define ERROR_MEDIA_CHANGED 1110L

//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
// The I/O bus was reset.
//
#define ERROR_BUS_RESET 1111L

//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
// No media in drive.
//
#define ERROR_NO_MEDIA_IN_DRIVE 1112L

//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
// No mapping for the Unicode character exists in the target multi-byte code page.
//
#define ERROR_NO_UNICODE_TRANSLATION 1113L

//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
// A dynamic link library (DLL) initialization routine failed.
//
#define ERROR_DLL_INIT_FAILED 1114L

//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//
#define ERROR_SHUTDOWN_IN_PROGRESS 1115L

//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// Unable to abort the system shutdown because no shutdown was in progress.
//
#define ERROR_NO_SHUTDOWN_IN_PROGRESS 1116L

//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
// The request could not be performed because of an I/O device error.
//
#define ERROR_IO_DEVICE 1117L

//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
// No serial device was successfully initialized. The serial driver will unload.
//
#define ERROR_SERIAL_NO_DEVICE 1118L

//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
// Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.
//
#define ERROR_IRQ_BUSY 1119L

//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
// A serial I/O operation was completed by another write to the serial port.
// (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
#define ERROR_MORE_WRITES 1120L

//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
// A serial I/O operation completed because the timeout period expired.
// (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//
#define ERROR_COUNTER_TIMEOUT 1121L

//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
// No ID address mark was found on the floppy disk.
//
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND 1122L

//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
// Mismatch between the floppy disk sector ID field and the floppy disk controller track address.
//
#define ERROR_FLOPPY_WRONG_CYLINDER 1123L

//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
// The floppy disk controller reported an error that is not recognized by the floppy disk driver.
//
#define ERROR_FLOPPY_UNKNOWN_ERROR 1124L

//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
// The floppy disk controller returned inconsistent results in its registers.
//
#define ERROR_FLOPPY_BAD_REGISTERS 1125L

//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
// While accessing the hard disk, a recalibrate operation failed, even after retries.
//
#define ERROR_DISK_RECALIBRATE_FAILED 1126L

//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
// While accessing the hard disk, a disk operation failed even after retries.
//
#define ERROR_DISK_OPERATION_FAILED 1127L

//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
// While accessing the hard disk, a disk controller reset was needed, but even that failed.
//
#define ERROR_DISK_RESET_FAILED 1128L

//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
// Physical end of tape encountered.
//
#define ERROR_EOM_OVERFLOW 1129L

//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
// Not enough server storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_SERVER_MEMORY 1130L

//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
// A potential deadlock condition has been detected.
//
#define ERROR_POSSIBLE_DEADLOCK 1131L

//
// MessageId: ERROR_MAPPED_ALIGNMENT
//
// MessageText:
//
// The base address or the file offset specified does not have the proper alignment.
//
#define ERROR_MAPPED_ALIGNMENT 1132L

//
// MessageId: ERROR_SET_POWER_STATE_VETOED
//
// MessageText:
//
// An attempt to change the system power state was vetoed by another application or driver.
//
#define ERROR_SET_POWER_STATE_VETOED 1140L

//
// MessageId: ERROR_SET_POWER_STATE_FAILED
//
// MessageText:
//
// The system BIOS failed an attempt to change the system power state.
//
#define ERROR_SET_POWER_STATE_FAILED 1141L

//
// MessageId: ERROR_TOO_MANY_LINKS
//
// MessageText:
//
// An attempt was made to create more links on a file than the file system supports.
//
#define ERROR_TOO_MANY_LINKS 1142L

//
// MessageId: ERROR_OLD_WIN_VERSION
//
// MessageText:
//
// The specified program requires a newer version of Windows.
//
#define ERROR_OLD_WIN_VERSION 1150L

//
// MessageId: ERROR_APP_WRONG_OS
//
// MessageText:
//
// The specified program is not a Windows or MS-DOS program.
//
#define ERROR_APP_WRONG_OS 1151L

//
// MessageId: ERROR_SINGLE_INSTANCE_APP
//
// MessageText:
//
// Cannot start more than one instance of the specified program.
//
#define ERROR_SINGLE_INSTANCE_APP 1152L

//
// MessageId: ERROR_RMODE_APP
//
// MessageText:
//
// The specified program was written for an earlier version of Windows.
//
#define ERROR_RMODE_APP 1153L

//
// MessageId: ERROR_INVALID_DLL
//
// MessageText:
//
// One of the library files needed to run this application is damaged.
//
#define ERROR_INVALID_DLL 1154L

//
// MessageId: ERROR_NO_ASSOCIATION
//
// MessageText:
//
// No application is associated with the specified file for this operation.
//
#define ERROR_NO_ASSOCIATION 1155L

//
// MessageId: ERROR_DDE_FAIL
//
// MessageText:
//
// An error occurred in sending the command to the application.
//
#define ERROR_DDE_FAIL 1156L

//
// MessageId: ERROR_DLL_NOT_FOUND
//
// MessageText:
//
// One of the library files needed to run this application cannot be found.
//
#define ERROR_DLL_NOT_FOUND 1157L

//
// MessageId: ERROR_NO_MORE_USER_HANDLES
//
// MessageText:
//
// The current process has used all of its system allowance of handles for Window Manager objects.
//
#define ERROR_NO_MORE_USER_HANDLES 1158L

//
// MessageId: ERROR_MESSAGE_SYNC_ONLY
//
// MessageText:
//
// The message can be used only with synchronous operations.
//
#define ERROR_MESSAGE_SYNC_ONLY 1159L

//
// MessageId: ERROR_SOURCE_ELEMENT_EMPTY
//
// MessageText:
//
// The indicated source element has no media.
//
#define ERROR_SOURCE_ELEMENT_EMPTY 1160L

//
// MessageId: ERROR_DESTINATION_ELEMENT_FULL
//
// MessageText:
//
// The indicated destination element already contains media.
//
#define ERROR_DESTINATION_ELEMENT_FULL 1161L

//
// MessageId: ERROR_ILLEGAL_ELEMENT_ADDRESS
//
// MessageText:
//
// The indicated element does not exist.
//
#define ERROR_ILLEGAL_ELEMENT_ADDRESS 1162L

//
// MessageId: ERROR_MAGAZINE_NOT_PRESENT
//
// MessageText:
//
// The indicated element is part of a magazine that is not present.
//
#define ERROR_MAGAZINE_NOT_PRESENT 1163L

//
// MessageId: ERROR_DEVICE_REINITIALIZATION_NEEDED
//
// MessageText:
//
// The indicated device requires reinitialization due to hardware errors.
//
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L

//
// MessageId: ERROR_DEVICE_REQUIRES_CLEANING
//
// MessageText:
//
// The device has indicated that cleaning is required before further operations are attempted.
//
#define ERROR_DEVICE_REQUIRES_CLEANING 1165L

//
// MessageId: ERROR_DEVICE_DOOR_OPEN
//
// MessageText:
//
// The device has indicated that its door is open.
//
#define ERROR_DEVICE_DOOR_OPEN 1166L

//
// MessageId: ERROR_DEVICE_NOT_CONNECTED
//
// MessageText:
//
// The device is not connected.
//
#define ERROR_DEVICE_NOT_CONNECTED 1167L

//
// MessageId: ERROR_NOT_FOUND
//
// MessageText:
//
// Element not found.
//
#define ERROR_NOT_FOUND 1168L

//
// MessageId: ERROR_NO_MATCH
//
// MessageText:
//
// There was no match for the specified key in the index.
//
#define ERROR_NO_MATCH 1169L

//
// MessageId: ERROR_SET_NOT_FOUND
//
// MessageText:
//
// The property set specified does not exist on the object.
//
#define ERROR_SET_NOT_FOUND 1170L

//
// MessageId: ERROR_POINT_NOT_FOUND
//
// MessageText:
//
// The point passed to GetMouseMovePoints is not in the buffer.
//
#define ERROR_POINT_NOT_FOUND 1171L

//
// MessageId: ERROR_NO_TRACKING_SERVICE
//
// MessageText:
//
// The tracking (workstation) service is not running.
//
#define ERROR_NO_TRACKING_SERVICE 1172L

//
// MessageId: ERROR_NO_VOLUME_ID
//
// MessageText:
//
// The Volume ID could not be found.
//
#define ERROR_NO_VOLUME_ID 1173L

//
// MessageId: ERROR_UNABLE_TO_REMOVE_REPLACED
//
// MessageText:
//
// Unable to remove the file to be replaced.
//
#define ERROR_UNABLE_TO_REMOVE_REPLACED 1175L

//
// MessageId: ERROR_UNABLE_TO_MOVE_REPLACEMENT
//
// MessageText:
//
// Unable to move the replacement file to the file to be replaced. The file to be replaced has retained its original name.
//
#define ERROR_UNABLE_TO_MOVE_REPLACEMENT 1176L

//
// MessageId: ERROR_UNABLE_TO_MOVE_REPLACEMENT_2
//
// MessageText:
//
// Unable to move the replacement file to the file to be replaced. The file to be replaced has been renamed using the backup name.
//
#define ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 1177L

//
// MessageId: ERROR_JOURNAL_DELETE_IN_PROGRESS
//
// MessageText:
//
// The volume change journal is being deleted.
//
#define ERROR_JOURNAL_DELETE_IN_PROGRESS 1178L

//
// MessageId: ERROR_JOURNAL_NOT_ACTIVE
//
// MessageText:
//
// The volume change journal is not active.
//
#define ERROR_JOURNAL_NOT_ACTIVE 1179L

//
// MessageId: ERROR_POTENTIAL_FILE_FOUND
//
// MessageText:
//
// A file was found, but it may not be the correct file.
//
#define ERROR_POTENTIAL_FILE_FOUND 1180L

//
// MessageId: ERROR_JOURNAL_ENTRY_DELETED
//
// MessageText:
//
// The journal entry has been deleted from the journal.
//
#define ERROR_JOURNAL_ENTRY_DELETED 1181L

//
// MessageId: ERROR_SHUTDOWN_IS_SCHEDULED
//
// MessageText:
//
// A system shutdown has already been scheduled.
//
#define ERROR_SHUTDOWN_IS_SCHEDULED 1190L

//
// MessageId: ERROR_SHUTDOWN_USERS_LOGGED_ON
//
// MessageText:
//
// The system shutdown cannot be initiated because there are other users logged on to the computer.
//
#define ERROR_SHUTDOWN_USERS_LOGGED_ON 1191L

//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
// The specified device name is invalid.
//
#define ERROR_BAD_DEVICE 1200L

//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
// The device is not currently connected but it is a remembered connection.
//
#define ERROR_CONNECTION_UNAVAIL 1201L

//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
// The local device name has a remembered connection to another network resource.
//
#define ERROR_DEVICE_ALREADY_REMEMBERED 1202L

//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
// The network path was either typed incorrectly, does not exist, or the network provider is not currently available. Please try retyping the path or contact your network administrator.
//
#define ERROR_NO_NET_OR_BAD_PATH 1203L

//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
// The specified network provider name is invalid.
//
#define ERROR_BAD_PROVIDER 1204L

//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
// Unable to open the network connection profile.
//
#define ERROR_CANNOT_OPEN_PROFILE 1205L

//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
// The network connection profile is corrupted.
//
#define ERROR_BAD_PROFILE 1206L

//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
// Cannot enumerate a noncontainer.
//
#define ERROR_NOT_CONTAINER 1207L

//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
// An extended error has occurred.
//
#define ERROR_EXTENDED_ERROR 1208L

//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
// The format of the specified group name is invalid.
//
#define ERROR_INVALID_GROUPNAME 1209L

//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
// The format of the specified computer name is invalid.
//
#define ERROR_INVALID_COMPUTERNAME 1210L

//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
// The format of the specified event name is invalid.
//
#define ERROR_INVALID_EVENTNAME 1211L

//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
// The format of the specified domain name is invalid.
//
#define ERROR_INVALID_DOMAINNAME 1212L

//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
// The format of the specified service name is invalid.
//
#define ERROR_INVALID_SERVICENAME 1213L

//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
// The format of the specified network name is invalid.
//
#define ERROR_INVALID_NETNAME 1214L

//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
// The format of the specified share name is invalid.
//
#define ERROR_INVALID_SHARENAME 1215L

//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
// The format of the specified password is invalid.
//
#define ERROR_INVALID_PASSWORDNAME 1216L

//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
// The format of the specified message name is invalid.
//
#define ERROR_INVALID_MESSAGENAME 1217L

//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
// The format of the specified message destination is invalid.
//
#define ERROR_INVALID_MESSAGEDEST 1218L

//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
// Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again.
//
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219L

//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.
//
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220L

//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
// The workgroup or domain name is already in use by another computer on the network.
//
#define ERROR_DUP_DOMAINNAME 1221L

//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
// The network is not present or not started.
//
#define ERROR_NO_NETWORK 1222L

//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
// The operation was canceled by the user.
//
#define ERROR_CANCELLED 1223L

//
// MessageId: ERROR_USER_MAPPED_FILE
//
// MessageText:
//
// The requested operation cannot be performed on a file with a user-mapped section open.
//
#define ERROR_USER_MAPPED_FILE 1224L

//
// MessageId: ERROR_CONNECTION_REFUSED
//
// MessageText:
//
// The remote computer refused the network connection.
//
#define ERROR_CONNECTION_REFUSED 1225L

//
// MessageId: ERROR_GRACEFUL_DISCONNECT
//
// MessageText:
//
// The network connection was gracefully closed.
//
#define ERROR_GRACEFUL_DISCONNECT 1226L

//
// MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
// The network transport endpoint already has an address associated with it.
//
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227L

//
// MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
// An address has not yet been associated with the network endpoint.
//
#define ERROR_ADDRESS_NOT_ASSOCIATED 1228L

//
// MessageId: ERROR_CONNECTION_INVALID
//
// MessageText:
//
// An operation was attempted on a nonexistent network connection.
//
#define ERROR_CONNECTION_INVALID 1229L

//
// MessageId: ERROR_CONNECTION_ACTIVE
//
// MessageText:
//
// An invalid operation was attempted on an active network connection.
//
#define ERROR_CONNECTION_ACTIVE 1230L

//
// MessageId: ERROR_NETWORK_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//
#define ERROR_NETWORK_UNREACHABLE 1231L

//
// MessageId: ERROR_HOST_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//
#define ERROR_HOST_UNREACHABLE 1232L

//
// MessageId: ERROR_PROTOCOL_UNREACHABLE
//
// MessageText:
//
// The network location cannot be reached. For information about network troubleshooting, see Windows Help.
//
#define ERROR_PROTOCOL_UNREACHABLE 1233L

//
// MessageId: ERROR_PORT_UNREACHABLE
//
// MessageText:
//
// No service is operating at the destination network endpoint on the remote system.
//
#define ERROR_PORT_UNREACHABLE 1234L

//
// MessageId: ERROR_REQUEST_ABORTED
//
// MessageText:
//
// The request was aborted.
//
#define ERROR_REQUEST_ABORTED 1235L

//
// MessageId: ERROR_CONNECTION_ABORTED
//
// MessageText:
//
// The network connection was aborted by the local system.
//
#define ERROR_CONNECTION_ABORTED 1236L

//
// MessageId: ERROR_RETRY
//
// MessageText:
//
// The operation could not be completed. A retry should be performed.
//
#define ERROR_RETRY 1237L

//
// MessageId: ERROR_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
// A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.
//
#define ERROR_CONNECTION_COUNT_LIMIT 1238L

//
// MessageId: ERROR_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
// Attempting to log in during an unauthorized time of day for this account.
//
#define ERROR_LOGIN_TIME_RESTRICTION 1239L

//
// MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
// The account is not authorized to log in from this station.
//
#define ERROR_LOGIN_WKSTA_RESTRICTION 1240L

//
// MessageId: ERROR_INCORRECT_ADDRESS
//
// MessageText:
//
// The network address could not be used for the operation requested.
//
#define ERROR_INCORRECT_ADDRESS 1241L

//
// MessageId: ERROR_ALREADY_REGISTERED
//
// MessageText:
//
// The service is already registered.
//
#define ERROR_ALREADY_REGISTERED 1242L

//
// MessageId: ERROR_SERVICE_NOT_FOUND
//
// MessageText:
//
// The specified service does not exist.
//
#define ERROR_SERVICE_NOT_FOUND 1243L

//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
// The operation being requested was not performed because the user has not been authenticated.
//
#define ERROR_NOT_AUTHENTICATED 1244L

//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
// The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.
//
#define ERROR_NOT_LOGGED_ON 1245L

//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
// Continue with work in progress.
//
#define ERROR_CONTINUE 1246L

//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
// An attempt was made to perform an initialization operation when initialization has already been completed.
//
#define ERROR_ALREADY_INITIALIZED 1247L

//
// MessageId: ERROR_NO_MORE_DEVICES
//
// MessageText:
//
// No more local devices.
//
#define ERROR_NO_MORE_DEVICES 1248L

//
// MessageId: ERROR_NO_SUCH_SITE
//
// MessageText:
//
// The specified site does not exist.
//
#define ERROR_NO_SUCH_SITE 1249L

//
// MessageId: ERROR_DOMAIN_CONTROLLER_EXISTS
//
// MessageText:
//
// A domain controller with the specified name already exists.
//
#define ERROR_DOMAIN_CONTROLLER_EXISTS 1250L

//
// MessageId: ERROR_ONLY_IF_CONNECTED
//
// MessageText:
//
// This operation is supported only when you are connected to the server.
//
#define ERROR_ONLY_IF_CONNECTED 1251L

//
// MessageId: ERROR_OVERRIDE_NOCHANGES
//
// MessageText:
//
// The group policy framework should call the extension even if there are no changes.
//
#define ERROR_OVERRIDE_NOCHANGES 1252L

//
// MessageId: ERROR_BAD_USER_PROFILE
//
// MessageText:
//
// The specified user does not have a valid profile.
//
#define ERROR_BAD_USER_PROFILE 1253L

//
// MessageId: ERROR_NOT_SUPPORTED_ON_SBS
//
// MessageText:
//
// This operation is not supported on a computer running Windows Server 2003 for Small Business Server
//
#define ERROR_NOT_SUPPORTED_ON_SBS 1254L

//
// MessageId: ERROR_SERVER_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// The server machine is shutting down.
//
#define ERROR_SERVER_SHUTDOWN_IN_PROGRESS 1255L

//
// MessageId: ERROR_HOST_DOWN
//
// MessageText:
//
// The remote system is not available. For information about network troubleshooting, see Windows Help.
//
#define ERROR_HOST_DOWN 1256L

//
// MessageId: ERROR_NON_ACCOUNT_SID
//
// MessageText:
//
// The security identifier provided is not from an account domain.
//
#define ERROR_NON_ACCOUNT_SID 1257L

//
// MessageId: ERROR_NON_DOMAIN_SID
//
// MessageText:
//
// The security identifier provided does not have a domain component.
//
#define ERROR_NON_DOMAIN_SID 1258L

//
// MessageId: ERROR_APPHELP_BLOCK
//
// MessageText:
//
// AppHelp dialog canceled thus preventing the application from starting.
//
#define ERROR_APPHELP_BLOCK 1259L

//
// MessageId: ERROR_ACCESS_DISABLED_BY_POLICY
//
// MessageText:
//
// This program is blocked by group policy. For more information, contact your system administrator.
//
#define ERROR_ACCESS_DISABLED_BY_POLICY 1260L

//
// MessageId: ERROR_REG_NAT_CONSUMPTION
//
// MessageText:
//
// A program attempt to use an invalid register value. Normally caused by an uninitialized register. This error is Itanium specific.
//
#define ERROR_REG_NAT_CONSUMPTION 1261L

//
// MessageId: ERROR_CSCSHARE_OFFLINE
//
// MessageText:
//
// The share is currently offline or does not exist.
//
#define ERROR_CSCSHARE_OFFLINE 1262L

//
// MessageId: ERROR_PKINIT_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while validating the KDC certificate during smartcard logon. There is more information in the system event log.
//
#define ERROR_PKINIT_FAILURE 1263L

//
// MessageId: ERROR_SMARTCARD_SUBSYSTEM_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.
//
#define ERROR_SMARTCARD_SUBSYSTEM_FAILURE 1264L

//
// MessageId: ERROR_DOWNGRADE_DETECTED
//
// MessageText:
//
// The system detected a possible attempt to compromise security. Please ensure that you can contact the server that authenticated you.
//
#define ERROR_DOWNGRADE_DETECTED 1265L

//
// Do not use ID's 1266 - 1270 as the symbolicNames have been moved to SEC_E_*
//
//
// MessageId: ERROR_MACHINE_LOCKED
//
// MessageText:
//
// The machine is locked and cannot be shut down without the force option.
//
#define ERROR_MACHINE_LOCKED 1271L

//
// MessageId: ERROR_CALLBACK_SUPPLIED_INVALID_DATA
//
// MessageText:
//
// An application-defined callback gave invalid data when called.
//
#define ERROR_CALLBACK_SUPPLIED_INVALID_DATA 1273L

//
// MessageId: ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED
//
// MessageText:
//
// The group policy framework should call the extension in the synchronous foreground policy refresh.
//
#define ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED 1274L

//
// MessageId: ERROR_DRIVER_BLOCKED
//
// MessageText:
//
// This driver has been blocked from loading
//
#define ERROR_DRIVER_BLOCKED 1275L

//
// MessageId: ERROR_INVALID_IMPORT_OF_NON_DLL
//
// MessageText:
//
// A dynamic link library (DLL) referenced a module that was neither a DLL nor the process's executable image.
//
#define ERROR_INVALID_IMPORT_OF_NON_DLL 1276L

//
// MessageId: ERROR_ACCESS_DISABLED_WEBBLADE
//
// MessageText:
//
// Windows cannot open this program since it has been disabled.
//
#define ERROR_ACCESS_DISABLED_WEBBLADE 1277L

//
// MessageId: ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER
//
// MessageText:
//
// Windows cannot open this program because the license enforcement system has been tampered with or become corrupted.
//
#define ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER 1278L

//
// MessageId: ERROR_RECOVERY_FAILURE
//
// MessageText:
//
// A transaction recover failed.
//
#define ERROR_RECOVERY_FAILURE 1279L

//
// MessageId: ERROR_ALREADY_FIBER
//
// MessageText:
//
// The current thread has already been converted to a fiber.
//
#define ERROR_ALREADY_FIBER 1280L

//
// MessageId: ERROR_ALREADY_THREAD
//
// MessageText:
//
// The current thread has already been converted from a fiber.
//
#define ERROR_ALREADY_THREAD 1281L

//
// MessageId: ERROR_STACK_BUFFER_OVERRUN
//
// MessageText:
//
// The system detected an overrun of a stack-based buffer in this application. This overrun could potentially allow a malicious user to gain control of this application.
//
#define ERROR_STACK_BUFFER_OVERRUN 1282L

//
// MessageId: ERROR_PARAMETER_QUOTA_EXCEEDED
//
// MessageText:
//
// Data present in one of the parameters is more than the function can operate on.
//
#define ERROR_PARAMETER_QUOTA_EXCEEDED 1283L

//
// MessageId: ERROR_DEBUGGER_INACTIVE
//
// MessageText:
//
// An attempt to do an operation on a debug object failed because the object is in the process of being deleted.
//
#define ERROR_DEBUGGER_INACTIVE 1284L

//
// MessageId: ERROR_DELAY_LOAD_FAILED
//
// MessageText:
//
// An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.
//
#define ERROR_DELAY_LOAD_FAILED 1285L

//
// MessageId: ERROR_VDM_DISALLOWED
//
// MessageText:
//
// %1 is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.
//
#define ERROR_VDM_DISALLOWED 1286L

//
// MessageId: ERROR_UNIDENTIFIED_ERROR
//
// MessageText:
//
// Insufficient information exists to identify the cause of failure.
//
#define ERROR_UNIDENTIFIED_ERROR 1287L

//
// MessageId: ERROR_INVALID_CRUNTIME_PARAMETER
//
// MessageText:
//
// The parameter passed to a C runtime function is incorrect.
//
#define ERROR_INVALID_CRUNTIME_PARAMETER 1288L

//
// MessageId: ERROR_BEYOND_VDL
//
// MessageText:
//
// The operation occurred beyond the valid data length of the file.
//
#define ERROR_BEYOND_VDL 1289L

//
// MessageId: ERROR_INCOMPATIBLE_SERVICE_SID_TYPE
//
// MessageText:
//
// The service start failed since one or more services in the same process have an incompatible service SID type setting. A service with restricted service SID type can only coexist in the same process with other services with a restricted SID type. If the service SID type for this service was just configured, the hosting process must be restarted in order to start this service.
//
#define ERROR_INCOMPATIBLE_SERVICE_SID_TYPE 1290L

//
// MessageId: ERROR_DRIVER_PROCESS_TERMINATED
//
// MessageText:
//
// The process hosting the driver for this device has been terminated.
//
#define ERROR_DRIVER_PROCESS_TERMINATED 1291L

//
// MessageId: ERROR_IMPLEMENTATION_LIMIT
//
// MessageText:
//
// An operation attempted to exceed an implementation-defined limit.
//
#define ERROR_IMPLEMENTATION_LIMIT 1292L

//
// MessageId: ERROR_PROCESS_IS_PROTECTED
//
// MessageText:
//
// Either the target process, or the target thread's containing process, is a protected process.
//
#define ERROR_PROCESS_IS_PROTECTED 1293L

//
// MessageId: ERROR_SERVICE_NOTIFY_CLIENT_LAGGING
//
// MessageText:
//
// The service notification client is lagging too far behind the current state of services in the machine.
//
#define ERROR_SERVICE_NOTIFY_CLIENT_LAGGING 1294L

//
// MessageId: ERROR_DISK_QUOTA_EXCEEDED
//
// MessageText:
//
// The requested file operation failed because the storage quota was exceeded.
// To free up disk space, move files to a different location or delete unnecessary files. For more information, contact your system administrator.
//
#define ERROR_DISK_QUOTA_EXCEEDED 1295L

//
// MessageId: ERROR_CONTENT_BLOCKED
//
// MessageText:
//
// The requested file operation failed because the storage policy blocks that type of file. For more information, contact your system administrator.
//
#define ERROR_CONTENT_BLOCKED 1296L

//
// MessageId: ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE
//
// MessageText:
//
// A privilege that the service requires to function properly does not exist in the service account configuration.
// You may use the Services Microsoft Management Console (MMC) snap-in (services.msc) and the Local Security Settings MMC snap-in (secpol.msc) to view the service configuration and the account configuration.
//
#define ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE 1297L

//
// MessageId: ERROR_APP_HANG
//
// MessageText:
//
// A thread involved in this operation appears to be unresponsive.
//
#define ERROR_APP_HANG 1298L


///////////////////////////////////////////////////
//                                               //
//             SECURITY Error codes              //
//                                               //
//                 1299 to 1399                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_LABEL
//
// MessageText:
//
// Indicates a particular Security ID may not be assigned as the label of an object.
//
#define ERROR_INVALID_LABEL 1299L

//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
// Not all privileges or groups referenced are assigned to the caller.
//
#define ERROR_NOT_ALL_ASSIGNED 1300L

//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
// Some mapping between account names and security IDs was not done.
//
#define ERROR_SOME_NOT_MAPPED 1301L

//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
// No system quota limits are specifically set for this account.
//
#define ERROR_NO_QUOTAS_FOR_ACCOUNT 1302L

//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
// No encryption key is available. A well-known encryption key was returned.
//
#define ERROR_LOCAL_USER_SESSION_KEY 1303L

//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
// The password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.
//
#define ERROR_NULL_LM_PASSWORD 1304L

//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
// The revision level is unknown.
//
#define ERROR_UNKNOWN_REVISION 1305L

//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
// Indicates two revision levels are incompatible.
//
#define ERROR_REVISION_MISMATCH 1306L

//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
// This security ID may not be assigned as the owner of this object.
//
#define ERROR_INVALID_OWNER 1307L

//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
// This security ID may not be assigned as the primary group of an object.
//
#define ERROR_INVALID_PRIMARY_GROUP 1308L

//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
// An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.
//
#define ERROR_NO_IMPERSONATION_TOKEN 1309L

//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
// The group may not be disabled.
//
#define ERROR_CANT_DISABLE_MANDATORY 1310L

//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
// There are currently no logon servers available to service the logon request.
//
#define ERROR_NO_LOGON_SERVERS 1311L

//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
// A specified logon session does not exist. It may already have been terminated.
//
#define ERROR_NO_SUCH_LOGON_SESSION 1312L

//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
// A specified privilege does not exist.
//
#define ERROR_NO_SUCH_PRIVILEGE 1313L

//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
// A required privilege is not held by the client.
//
#define ERROR_PRIVILEGE_NOT_HELD 1314L

//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
// The name provided is not a properly formed account name.
//
#define ERROR_INVALID_ACCOUNT_NAME 1315L

//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
// The specified account already exists.
//
#define ERROR_USER_EXISTS 1316L

//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
// The specified account does not exist.
//
#define ERROR_NO_SUCH_USER 1317L

//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
// The specified group already exists.
//
#define ERROR_GROUP_EXISTS 1318L

//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
// The specified group does not exist.
//
#define ERROR_NO_SUCH_GROUP 1319L

//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
// Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.
//
#define ERROR_MEMBER_IN_GROUP 1320L

//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
// The specified user account is not a member of the specified group account.
//
#define ERROR_MEMBER_NOT_IN_GROUP 1321L

//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
// The last remaining administration account cannot be disabled or deleted.
//
#define ERROR_LAST_ADMIN 1322L

//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
// Unable to update the password. The value provided as the current password is incorrect.
//
#define ERROR_WRONG_PASSWORD 1323L

//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
// Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.
//
#define ERROR_ILL_FORMED_PASSWORD 1324L

//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
// Unable to update the password. The value provided for the new password does not meet the length, complexity, or history requirements of the domain.
//
#define ERROR_PASSWORD_RESTRICTION 1325L

//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
// Logon failure: unknown user name or bad password.
//
#define ERROR_LOGON_FAILURE 1326L

//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
// Logon failure: user account restriction. Possible reasons are blank passwords not allowed, logon hour restrictions, or a policy restriction has been enforced.
//
#define ERROR_ACCOUNT_RESTRICTION 1327L

//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
// Logon failure: account logon time restriction violation.
//
#define ERROR_INVALID_LOGON_HOURS 1328L

//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
// Logon failure: user not allowed to log on to this computer.
//
#define ERROR_INVALID_WORKSTATION 1329L

//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
// Logon failure: the specified account password has expired.
//
#define ERROR_PASSWORD_EXPIRED 1330L

//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
// Logon failure: account currently disabled.
//
#define ERROR_ACCOUNT_DISABLED 1331L

//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
// No mapping between account names and security IDs was done.
//
#define ERROR_NONE_MAPPED 1332L

//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
// Too many local user identifiers (LUIDs) were requested at one time.
//
#define ERROR_TOO_MANY_LUIDS_REQUESTED 1333L

//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
// No more local user identifiers (LUIDs) are available.
//
#define ERROR_LUIDS_EXHAUSTED 1334L

//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
// The subauthority part of a security ID is invalid for this particular use.
//
#define ERROR_INVALID_SUB_AUTHORITY 1335L

//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
// The access control list (ACL) structure is invalid.
//
#define ERROR_INVALID_ACL 1336L

//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
// The security ID structure is invalid.
//
#define ERROR_INVALID_SID 1337L

//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
// The security descriptor structure is invalid.
//
#define ERROR_INVALID_SECURITY_DESCR 1338L

//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
// The inherited access control list (ACL) or access control entry (ACE) could not be built.
//
#define ERROR_BAD_INHERITANCE_ACL 1340L

//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
// The server is currently disabled.
//
#define ERROR_SERVER_DISABLED 1341L

//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
// The server is currently enabled.
//
#define ERROR_SERVER_NOT_DISABLED 1342L

//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
// The value provided was an invalid value for an identifier authority.
//
#define ERROR_INVALID_ID_AUTHORITY 1343L

//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
// No more memory is available for security information updates.
//
#define ERROR_ALLOTTED_SPACE_EXCEEDED 1344L

//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
// The specified attributes are invalid, or incompatible with the attributes for the group as a whole.
//
#define ERROR_INVALID_GROUP_ATTRIBUTES 1345L

//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
// Either a required impersonation level was not provided, or the provided impersonation level is invalid.
//
#define ERROR_BAD_IMPERSONATION_LEVEL 1346L

//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
// Cannot open an anonymous level security token.
//
#define ERROR_CANT_OPEN_ANONYMOUS 1347L

//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
// The validation information class requested was invalid.
//
#define ERROR_BAD_VALIDATION_CLASS 1348L

//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
// The type of the token is inappropriate for its attempted use.
//
#define ERROR_BAD_TOKEN_TYPE 1349L

//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
// Unable to perform a security operation on an object that has no associated security.
//
#define ERROR_NO_SECURITY_ON_OBJECT 1350L

//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
// Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.
//
#define ERROR_CANT_ACCESS_DOMAIN_INFO 1351L

//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
// The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.
//
#define ERROR_INVALID_SERVER_STATE 1352L

//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
// The domain was in the wrong state to perform the security operation.
//
#define ERROR_INVALID_DOMAIN_STATE 1353L

//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//
#define ERROR_INVALID_DOMAIN_ROLE 1354L

//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
// The specified domain either does not exist or could not be contacted.
//
#define ERROR_NO_SUCH_DOMAIN 1355L

//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
// The specified domain already exists.
//
#define ERROR_DOMAIN_EXISTS 1356L

//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to exceed the limit on the number of domains per server.
//
#define ERROR_DOMAIN_LIMIT_EXCEEDED 1357L

//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
// Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.
//
#define ERROR_INTERNAL_DB_CORRUPTION 1358L

//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred.
//
#define ERROR_INTERNAL_ERROR 1359L

//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
// Generic access types were contained in an access mask which should already be mapped to nongeneric types.
//
#define ERROR_GENERIC_NOT_MAPPED 1360L

//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
// A security descriptor is not in the right format (absolute or self-relative).
//
#define ERROR_BAD_DESCRIPTOR_FORMAT 1361L

//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
// The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.
//
#define ERROR_NOT_LOGON_PROCESS 1362L

//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
// Cannot start a new logon session with an ID that is already in use.
//
#define ERROR_LOGON_SESSION_EXISTS 1363L

//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
// A specified authentication package is unknown.
//
#define ERROR_NO_SUCH_PACKAGE 1364L

//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
// The logon session is not in a state that is consistent with the requested operation.
//
#define ERROR_BAD_LOGON_SESSION_STATE 1365L

//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
// The logon session ID is already in use.
//
#define ERROR_LOGON_SESSION_COLLISION 1366L

//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
// A logon request contained an invalid logon type value.
//
#define ERROR_INVALID_LOGON_TYPE 1367L

//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
// Unable to impersonate using a named pipe until data has been read from that pipe.
//
#define ERROR_CANNOT_IMPERSONATE 1368L

//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
// The transaction state of a registry subtree is incompatible with the requested operation.
//
#define ERROR_RXACT_INVALID_STATE 1369L

//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
// An internal security database corruption has been encountered.
//
#define ERROR_RXACT_COMMIT_FAILURE 1370L

//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
// Cannot perform this operation on built-in accounts.
//
#define ERROR_SPECIAL_ACCOUNT 1371L

//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
// Cannot perform this operation on this built-in special group.
//
#define ERROR_SPECIAL_GROUP 1372L

//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
// Cannot perform this operation on this built-in special user.
//
#define ERROR_SPECIAL_USER 1373L

//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
// The user cannot be removed from a group because the group is currently the user's primary group.
//
#define ERROR_MEMBERS_PRIMARY_GROUP 1374L

//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
// The token is already in use as a primary token.
//
#define ERROR_TOKEN_ALREADY_IN_USE 1375L

//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
// The specified local group does not exist.
//
#define ERROR_NO_SUCH_ALIAS 1376L

//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
// The specified account name is not a member of the group.
//
#define ERROR_MEMBER_NOT_IN_ALIAS 1377L

//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
// The specified account name is already a member of the group.
//
#define ERROR_MEMBER_IN_ALIAS 1378L

//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
// The specified local group already exists.
//
#define ERROR_ALIAS_EXISTS 1379L

//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
// Logon failure: the user has not been granted the requested logon type at this computer.
//
#define ERROR_LOGON_NOT_GRANTED 1380L

//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
// The maximum number of secrets that may be stored in a single system has been exceeded.
//
#define ERROR_TOO_MANY_SECRETS 1381L

//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
// The length of a secret exceeds the maximum length allowed.
//
#define ERROR_SECRET_TOO_LONG 1382L

//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
// The local security authority database contains an internal inconsistency.
//
#define ERROR_INTERNAL_DB_ERROR 1383L

//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
// During a logon attempt, the user's security context accumulated too many security IDs.
//
#define ERROR_TOO_MANY_CONTEXT_IDS 1384L

//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
// Logon failure: the user has not been granted the requested logon type at this computer.
//
#define ERROR_LOGON_TYPE_NOT_GRANTED 1385L

//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// A cross-encrypted password is necessary to change a user password.
//
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386L

//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
// A member could not be added to or removed from the local group because the member does not exist.
//
#define ERROR_NO_SUCH_MEMBER 1387L

//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
// A new member could not be added to a local group because the member has the wrong account type.
//
#define ERROR_INVALID_MEMBER 1388L

//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
// Too many security IDs have been specified.
//
#define ERROR_TOO_MANY_SIDS 1389L

//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// A cross-encrypted password is necessary to change this user password.
//
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390L

//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
// Indicates an ACL contains no inheritable components.
//
#define ERROR_NO_INHERITANCE 1391L

//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
// The file or directory is corrupted and unreadable.
//
#define ERROR_FILE_CORRUPT 1392L

//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
// The disk structure is corrupted and unreadable.
//
#define ERROR_DISK_CORRUPT 1393L

//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
// There is no user session key for the specified logon session.
//
#define ERROR_NO_USER_SESSION_KEY 1394L

//
// MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
// The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.
//
#define ERROR_LICENSE_QUOTA_EXCEEDED 1395L

//
// MessageId: ERROR_WRONG_TARGET_NAME
//
// MessageText:
//
// Logon Failure: The target account name is incorrect.
//
#define ERROR_WRONG_TARGET_NAME 1396L

//
// MessageId: ERROR_MUTUAL_AUTH_FAILED
//
// MessageText:
//
// Mutual Authentication failed. The server's password is out of date at the domain controller.
//
#define ERROR_MUTUAL_AUTH_FAILED 1397L

//
// MessageId: ERROR_TIME_SKEW
//
// MessageText:
//
// There is a time and/or date difference between the client and server.
//
#define ERROR_TIME_SKEW 1398L

//
// MessageId: ERROR_CURRENT_DOMAIN_NOT_ALLOWED
//
// MessageText:
//
// This operation cannot be performed on the current domain.
//
#define ERROR_CURRENT_DOMAIN_NOT_ALLOWED 1399L


///////////////////////////////////////////////////
//                                               //
//              WinUser Error codes              //
//                                               //
//                 1400 to 1499                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
// Invalid window handle.
//
#define ERROR_INVALID_WINDOW_HANDLE 1400L

//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
// Invalid menu handle.
//
#define ERROR_INVALID_MENU_HANDLE 1401L

//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
// Invalid cursor handle.
//
#define ERROR_INVALID_CURSOR_HANDLE 1402L

//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
// Invalid accelerator table handle.
//
#define ERROR_INVALID_ACCEL_HANDLE 1403L

//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
// Invalid hook handle.
//
#define ERROR_INVALID_HOOK_HANDLE 1404L

//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
// Invalid handle to a multiple-window position structure.
//
#define ERROR_INVALID_DWP_HANDLE 1405L

//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
// Cannot create a top-level child window.
//
#define ERROR_TLW_WITH_WSCHILD 1406L

//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
// Cannot find window class.
//
#define ERROR_CANNOT_FIND_WND_CLASS 1407L

//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
// Invalid window; it belongs to other thread.
//
#define ERROR_WINDOW_OF_OTHER_THREAD 1408L

//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
// Hot key is already registered.
//
#define ERROR_HOTKEY_ALREADY_REGISTERED 1409L

//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
// Class already exists.
//
#define ERROR_CLASS_ALREADY_EXISTS 1410L

//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
// Class does not exist.
//
#define ERROR_CLASS_DOES_NOT_EXIST 1411L

//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
// Class still has open windows.
//
#define ERROR_CLASS_HAS_WINDOWS 1412L

//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
// Invalid index.
//
#define ERROR_INVALID_INDEX 1413L

//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
// Invalid icon handle.
//
#define ERROR_INVALID_ICON_HANDLE 1414L

//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
// Using private DIALOG window words.
//
#define ERROR_PRIVATE_DIALOG_INDEX 1415L

//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
// The list box identifier was not found.
//
#define ERROR_LISTBOX_ID_NOT_FOUND 1416L

//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
// No wildcards were found.
//
#define ERROR_NO_WILDCARD_CHARACTERS 1417L

//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
// Thread does not have a clipboard open.
//
#define ERROR_CLIPBOARD_NOT_OPEN 1418L

//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
// Hot key is not registered.
//
#define ERROR_HOTKEY_NOT_REGISTERED 1419L

//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
// The window is not a valid dialog window.
//
#define ERROR_WINDOW_NOT_DIALOG 1420L

//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
// Control ID not found.
//
#define ERROR_CONTROL_ID_NOT_FOUND 1421L

//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
// Invalid message for a combo box because it does not have an edit control.
//
#define ERROR_INVALID_COMBOBOX_MESSAGE 1422L

//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
// The window is not a combo box.
//
#define ERROR_WINDOW_NOT_COMBOBOX 1423L

//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
// Height must be less than 256.
//
#define ERROR_INVALID_EDIT_HEIGHT 1424L

//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
// Invalid device context (DC) handle.
//
#define ERROR_DC_NOT_FOUND 1425L

//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
// Invalid hook procedure type.
//
#define ERROR_INVALID_HOOK_FILTER 1426L

//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
// Invalid hook procedure.
//
#define ERROR_INVALID_FILTER_PROC 1427L

//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
// Cannot set nonlocal hook without a module handle.
//
#define ERROR_HOOK_NEEDS_HMOD 1428L

//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
// This hook procedure can only be set globally.
//
#define ERROR_GLOBAL_ONLY_HOOK 1429L

//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
// The journal hook procedure is already installed.
//
#define ERROR_JOURNAL_HOOK_SET 1430L

//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
// The hook procedure is not installed.
//
#define ERROR_HOOK_NOT_INSTALLED 1431L

//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
// Invalid message for single-selection list box.
//
#define ERROR_INVALID_LB_MESSAGE 1432L

//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
// LB_SETCOUNT sent to non-lazy list box.
//
#define ERROR_SETCOUNT_ON_BAD_LB 1433L

//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
// This list box does not support tab stops.
//
#define ERROR_LB_WITHOUT_TABSTOPS 1434L

//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
// Cannot destroy object created by another thread.
//
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435L

//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
// Child windows cannot have menus.
//
#define ERROR_CHILD_WINDOW_MENU 1436L

//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
// The window does not have a system menu.
//
#define ERROR_NO_SYSTEM_MENU 1437L

//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
// Invalid message box style.
//
#define ERROR_INVALID_MSGBOX_STYLE 1438L

//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
// Invalid system-wide (SPI_*) parameter.
//
#define ERROR_INVALID_SPI_VALUE 1439L

//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
// Screen already locked.
//
#define ERROR_SCREEN_ALREADY_LOCKED 1440L

//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
// All handles to windows in a multiple-window position structure must have the same parent.
//
#define ERROR_HWNDS_HAVE_DIFF_PARENT 1441L

//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
// The window is not a child window.
//
#define ERROR_NOT_CHILD_WINDOW 1442L

//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
// Invalid GW_* command.
//
#define ERROR_INVALID_GW_COMMAND 1443L

//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
// Invalid thread identifier.
//
#define ERROR_INVALID_THREAD_ID 1444L

//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
// Cannot process a message from a window that is not a multiple document interface (MDI) window.
//
#define ERROR_NON_MDICHILD_WINDOW 1445L

//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
// Popup menu already active.
//
#define ERROR_POPUP_ALREADY_ACTIVE 1446L

//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
// The window does not have scroll bars.
//
#define ERROR_NO_SCROLLBARS 1447L

//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
// Scroll bar range cannot be greater than MAXLONG.
//
#define ERROR_INVALID_SCROLLBAR_RANGE 1448L

//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
// Cannot show or remove the window in the way specified.
//
#define ERROR_INVALID_SHOWWIN_COMMAND 1449L

//
// MessageId: ERROR_NO_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//
#define ERROR_NO_SYSTEM_RESOURCES 1450L

//
// MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//
#define ERROR_NONPAGED_SYSTEM_RESOURCES 1451L

//
// MessageId: ERROR_PAGED_SYSTEM_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the requested service.
//
#define ERROR_PAGED_SYSTEM_RESOURCES 1452L

//
// MessageId: ERROR_WORKING_SET_QUOTA
//
// MessageText:
//
// Insufficient quota to complete the requested service.
//
#define ERROR_WORKING_SET_QUOTA 1453L

//
// MessageId: ERROR_PAGEFILE_QUOTA
//
// MessageText:
//
// Insufficient quota to complete the requested service.
//
#define ERROR_PAGEFILE_QUOTA 1454L

//
// MessageId: ERROR_COMMITMENT_LIMIT
//
// MessageText:
//
// The paging file is too small for this operation to complete.
//
#define ERROR_COMMITMENT_LIMIT 1455L

//
// MessageId: ERROR_MENU_ITEM_NOT_FOUND
//
// MessageText:
//
// A menu item was not found.
//
#define ERROR_MENU_ITEM_NOT_FOUND 1456L

//
// MessageId: ERROR_INVALID_KEYBOARD_HANDLE
//
// MessageText:
//
// Invalid keyboard layout handle.
//
#define ERROR_INVALID_KEYBOARD_HANDLE 1457L

//
// MessageId: ERROR_HOOK_TYPE_NOT_ALLOWED
//
// MessageText:
//
// Hook type not allowed.
//
#define ERROR_HOOK_TYPE_NOT_ALLOWED 1458L

//
// MessageId: ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
//
// MessageText:
//
// This operation requires an interactive window station.
//
#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459L

//
// MessageId: ERROR_TIMEOUT
//
// MessageText:
//
// This operation returned because the timeout period expired.
//
#define ERROR_TIMEOUT 1460L

//
// MessageId: ERROR_INVALID_MONITOR_HANDLE
//
// MessageText:
//
// Invalid monitor handle.
//
#define ERROR_INVALID_MONITOR_HANDLE 1461L

//
// MessageId: ERROR_INCORRECT_SIZE
//
// MessageText:
//
// Incorrect size argument.
//
#define ERROR_INCORRECT_SIZE 1462L

//
// MessageId: ERROR_SYMLINK_CLASS_DISABLED
//
// MessageText:
//
// The symbolic link cannot be followed because its type is disabled.
//
#define ERROR_SYMLINK_CLASS_DISABLED 1463L

//
// MessageId: ERROR_SYMLINK_NOT_SUPPORTED
//
// MessageText:
//
// This application does not support the current operation on symbolic links.
//
#define ERROR_SYMLINK_NOT_SUPPORTED 1464L

//
// MessageId: ERROR_XML_PARSE_ERROR
//
// MessageText:
//
// Windows was unable to parse the requested XML data.
//
#define ERROR_XML_PARSE_ERROR 1465L

//
// MessageId: ERROR_XMLDSIG_ERROR
//
// MessageText:
//
// An error was encountered while processing an XML digital signature.
//
#define ERROR_XMLDSIG_ERROR 1466L

//
// MessageId: ERROR_RESTART_APPLICATION
//
// MessageText:
//
// This application must be restarted.
//
#define ERROR_RESTART_APPLICATION 1467L

//
// MessageId: ERROR_WRONG_COMPARTMENT
//
// MessageText:
//
// The caller made the connection request in the wrong routing compartment.
//
#define ERROR_WRONG_COMPARTMENT 1468L

//
// MessageId: ERROR_AUTHIP_FAILURE
//
// MessageText:
//
// There was an AuthIP failure when attempting to connect to the remote host.
//
#define ERROR_AUTHIP_FAILURE 1469L

//
// MessageId: ERROR_NO_NVRAM_RESOURCES
//
// MessageText:
//
// Insufficient NVRAM resources exist to complete the requested service. A reboot might be required.
//
#define ERROR_NO_NVRAM_RESOURCES 1470L


///////////////////////////////////////////////////
//                                               //
//             EventLog Error codes              //
//                                               //
//                 1500 to 1549                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
// The event log file is corrupted.
//
#define ERROR_EVENTLOG_FILE_CORRUPT 1500L

//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
// No event log file could be opened, so the event logging service did not start.
//
#define ERROR_EVENTLOG_CANT_START 1501L

//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
// The event log file is full.
//
#define ERROR_LOG_FILE_FULL 1502L

//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
// The event log file has changed between read operations.
//
#define ERROR_EVENTLOG_FILE_CHANGED 1503L


///////////////////////////////////////////////////
//                                               //
//            Class Scheduler Error codes        //
//                                               //
//                 1550 to 1599                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_TASK_NAME
//
// MessageText:
//
// The specified task name is invalid.
//
#define ERROR_INVALID_TASK_NAME 1550L

//
// MessageId: ERROR_INVALID_TASK_INDEX
//
// MessageText:
//
// The specified task index is invalid.
//
#define ERROR_INVALID_TASK_INDEX 1551L

//
// MessageId: ERROR_THREAD_ALREADY_IN_TASK
//
// MessageText:
//
// The specified thread is already joining a task.
//
#define ERROR_THREAD_ALREADY_IN_TASK 1552L


///////////////////////////////////////////////////
//                                               //
//                MSI Error codes                //
//                                               //
//                 1600 to 1699                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INSTALL_SERVICE_FAILURE
//
// MessageText:
//
// The Windows Installer Service could not be accessed. This can occur if the Windows Installer is not correctly installed. Contact your support personnel for assistance.
//
#define ERROR_INSTALL_SERVICE_FAILURE 1601L

//
// MessageId: ERROR_INSTALL_USEREXIT
//
// MessageText:
//
// User cancelled installation.
//
#define ERROR_INSTALL_USEREXIT 1602L

//
// MessageId: ERROR_INSTALL_FAILURE
//
// MessageText:
//
// Fatal error during installation.
//
#define ERROR_INSTALL_FAILURE 1603L

//
// MessageId: ERROR_INSTALL_SUSPEND
//
// MessageText:
//
// Installation suspended, incomplete.
//
#define ERROR_INSTALL_SUSPEND 1604L

//
// MessageId: ERROR_UNKNOWN_PRODUCT
//
// MessageText:
//
// This action is only valid for products that are currently installed.
//
#define ERROR_UNKNOWN_PRODUCT 1605L

//
// MessageId: ERROR_UNKNOWN_FEATURE
//
// MessageText:
//
// Feature ID not registered.
//
#define ERROR_UNKNOWN_FEATURE 1606L

//
// MessageId: ERROR_UNKNOWN_COMPONENT
//
// MessageText:
//
// Component ID not registered.
//
#define ERROR_UNKNOWN_COMPONENT 1607L

//
// MessageId: ERROR_UNKNOWN_PROPERTY
//
// MessageText:
//
// Unknown property.
//
#define ERROR_UNKNOWN_PROPERTY 1608L

//
// MessageId: ERROR_INVALID_HANDLE_STATE
//
// MessageText:
//
// Handle is in an invalid state.
//
#define ERROR_INVALID_HANDLE_STATE 1609L

//
// MessageId: ERROR_BAD_CONFIGURATION
//
// MessageText:
//
// The configuration data for this product is corrupt. Contact your support personnel.
//
#define ERROR_BAD_CONFIGURATION 1610L

//
// MessageId: ERROR_INDEX_ABSENT
//
// MessageText:
//
// Component qualifier not present.
//
#define ERROR_INDEX_ABSENT 1611L

//
// MessageId: ERROR_INSTALL_SOURCE_ABSENT
//
// MessageText:
//
// The installation source for this product is not available. Verify that the source exists and that you can access it.
//
#define ERROR_INSTALL_SOURCE_ABSENT 1612L

//
// MessageId: ERROR_INSTALL_PACKAGE_VERSION
//
// MessageText:
//
// This installation package cannot be installed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
//
#define ERROR_INSTALL_PACKAGE_VERSION 1613L

//
// MessageId: ERROR_PRODUCT_UNINSTALLED
//
// MessageText:
//
// Product is uninstalled.
//
#define ERROR_PRODUCT_UNINSTALLED 1614L

//
// MessageId: ERROR_BAD_QUERY_SYNTAX
//
// MessageText:
//
// SQL query syntax invalid or unsupported.
//
#define ERROR_BAD_QUERY_SYNTAX 1615L

//
// MessageId: ERROR_INVALID_FIELD
//
// MessageText:
//
// Record field does not exist.
//
#define ERROR_INVALID_FIELD 1616L

//
// MessageId: ERROR_DEVICE_REMOVED
//
// MessageText:
//
// The device has been removed.
//
#define ERROR_DEVICE_REMOVED 1617L

//
// MessageId: ERROR_INSTALL_ALREADY_RUNNING
//
// MessageText:
//
// Another installation is already in progress. Complete that installation before proceeding with this install.
//
#define ERROR_INSTALL_ALREADY_RUNNING 1618L

//
// MessageId: ERROR_INSTALL_PACKAGE_OPEN_FAILED
//
// MessageText:
//
// This installation package could not be opened. Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.
//
#define ERROR_INSTALL_PACKAGE_OPEN_FAILED 1619L

//
// MessageId: ERROR_INSTALL_PACKAGE_INVALID
//
// MessageText:
//
// This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer package.
//
#define ERROR_INSTALL_PACKAGE_INVALID 1620L

//
// MessageId: ERROR_INSTALL_UI_FAILURE
//
// MessageText:
//
// There was an error starting the Windows Installer service user interface. Contact your support personnel.
//
#define ERROR_INSTALL_UI_FAILURE 1621L

//
// MessageId: ERROR_INSTALL_LOG_FAILURE
//
// MessageText:
//
// Error opening installation log file. Verify that the specified log file location exists and that you can write to it.
//
#define ERROR_INSTALL_LOG_FAILURE 1622L

//
// MessageId: ERROR_INSTALL_LANGUAGE_UNSUPPORTED
//
// MessageText:
//
// The language of this installation package is not supported by your system.
//
#define ERROR_INSTALL_LANGUAGE_UNSUPPORTED 1623L

//
// MessageId: ERROR_INSTALL_TRANSFORM_FAILURE
//
// MessageText:
//
// Error applying transforms. Verify that the specified transform paths are valid.
//
#define ERROR_INSTALL_TRANSFORM_FAILURE 1624L

//
// MessageId: ERROR_INSTALL_PACKAGE_REJECTED
//
// MessageText:
//
// This installation is forbidden by system policy. Contact your system administrator.
//
#define ERROR_INSTALL_PACKAGE_REJECTED 1625L

//
// MessageId: ERROR_FUNCTION_NOT_CALLED
//
// MessageText:
//
// Function could not be executed.
//
#define ERROR_FUNCTION_NOT_CALLED 1626L

//
// MessageId: ERROR_FUNCTION_FAILED
//
// MessageText:
//
// Function failed during execution.
//
#define ERROR_FUNCTION_FAILED 1627L

//
// MessageId: ERROR_INVALID_TABLE
//
// MessageText:
//
// Invalid or unknown table specified.
//
#define ERROR_INVALID_TABLE 1628L

//
// MessageId: ERROR_DATATYPE_MISMATCH
//
// MessageText:
//
// Data supplied is of wrong type.
//
#define ERROR_DATATYPE_MISMATCH 1629L

//
// MessageId: ERROR_UNSUPPORTED_TYPE
//
// MessageText:
//
// Data of this type is not supported.
//
#define ERROR_UNSUPPORTED_TYPE 1630L

//
// MessageId: ERROR_CREATE_FAILED
//
// MessageText:
//
// The Windows Installer service failed to start. Contact your support personnel.
//
#define ERROR_CREATE_FAILED 1631L

//
// MessageId: ERROR_INSTALL_TEMP_UNWRITABLE
//
// MessageText:
//
// The Temp folder is on a drive that is full or is inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.
//
#define ERROR_INSTALL_TEMP_UNWRITABLE 1632L

//
// MessageId: ERROR_INSTALL_PLATFORM_UNSUPPORTED
//
// MessageText:
//
// This installation package is not supported by this processor type. Contact your product vendor.
//
#define ERROR_INSTALL_PLATFORM_UNSUPPORTED 1633L

//
// MessageId: ERROR_INSTALL_NOTUSED
//
// MessageText:
//
// Component not used on this computer.
//
#define ERROR_INSTALL_NOTUSED 1634L

//
// MessageId: ERROR_PATCH_PACKAGE_OPEN_FAILED
//
// MessageText:
//
// This update package could not be opened. Verify that the update package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer update package.
//
#define ERROR_PATCH_PACKAGE_OPEN_FAILED 1635L

//
// MessageId: ERROR_PATCH_PACKAGE_INVALID
//
// MessageText:
//
// This update package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer update package.
//
#define ERROR_PATCH_PACKAGE_INVALID 1636L

//
// MessageId: ERROR_PATCH_PACKAGE_UNSUPPORTED
//
// MessageText:
//
// This update package cannot be processed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.
//
#define ERROR_PATCH_PACKAGE_UNSUPPORTED 1637L

//
// MessageId: ERROR_PRODUCT_VERSION
//
// MessageText:
//
// Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.
//
#define ERROR_PRODUCT_VERSION 1638L

//
// MessageId: ERROR_INVALID_COMMAND_LINE
//
// MessageText:
//
// Invalid command line argument. Consult the Windows Installer SDK for detailed command line help.
//
#define ERROR_INVALID_COMMAND_LINE 1639L

//
// MessageId: ERROR_INSTALL_REMOTE_DISALLOWED
//
// MessageText:
//
// Only administrators have permission to add, remove, or configure server software during a Terminal services remote session. If you want to install or configure software on the server, contact your network administrator.
//
#define ERROR_INSTALL_REMOTE_DISALLOWED 1640L

//
// MessageId: ERROR_SUCCESS_REBOOT_INITIATED
//
// MessageText:
//
// The requested operation completed successfully. The system will be restarted so the changes can take effect.
//
#define ERROR_SUCCESS_REBOOT_INITIATED 1641L

//
// MessageId: ERROR_PATCH_TARGET_NOT_FOUND
//
// MessageText:
//
// The upgrade cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade.
//
#define ERROR_PATCH_TARGET_NOT_FOUND 1642L

//
// MessageId: ERROR_PATCH_PACKAGE_REJECTED
//
// MessageText:
//
// The update package is not permitted by software restriction policy.
//
#define ERROR_PATCH_PACKAGE_REJECTED 1643L

//
// MessageId: ERROR_INSTALL_TRANSFORM_REJECTED
//
// MessageText:
//
// One or more customizations are not permitted by software restriction policy.
//
#define ERROR_INSTALL_TRANSFORM_REJECTED 1644L

//
// MessageId: ERROR_INSTALL_REMOTE_PROHIBITED
//
// MessageText:
//
// The Windows Installer does not permit installation from a Remote Desktop Connection.
//
#define ERROR_INSTALL_REMOTE_PROHIBITED 1645L

//
// MessageId: ERROR_PATCH_REMOVAL_UNSUPPORTED
//
// MessageText:
//
// Uninstallation of the update package is not supported.
//
#define ERROR_PATCH_REMOVAL_UNSUPPORTED 1646L

//
// MessageId: ERROR_UNKNOWN_PATCH
//
// MessageText:
//
// The update is not applied to this product.
//
#define ERROR_UNKNOWN_PATCH 1647L

//
// MessageId: ERROR_PATCH_NO_SEQUENCE
//
// MessageText:
//
// No valid sequence could be found for the set of updates.
//
#define ERROR_PATCH_NO_SEQUENCE 1648L

//
// MessageId: ERROR_PATCH_REMOVAL_DISALLOWED
//
// MessageText:
//
// Update removal was disallowed by policy.
//
#define ERROR_PATCH_REMOVAL_DISALLOWED 1649L

//
// MessageId: ERROR_INVALID_PATCH_XML
//
// MessageText:
//
// The XML update data is invalid.
//
#define ERROR_INVALID_PATCH_XML 1650L

//
// MessageId: ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT
//
// MessageText:
//
// Windows Installer does not permit updating of managed advertised products. At least one feature of the product must be installed before applying the update.
//
#define ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT 1651L

//
// MessageId: ERROR_INSTALL_SERVICE_SAFEBOOT
//
// MessageText:
//
// The Windows Installer service is not accessible in Safe Mode. Please try again when your computer is not in Safe Mode or you can use System Restore to return your machine to a previous good state.
//
#define ERROR_INSTALL_SERVICE_SAFEBOOT 1652L

//
// MessageId: ERROR_FAIL_FAST_EXCEPTION
//
// MessageText:
//
// A fail fast exception occurred. Exception handlers will not be invoked and the process will be terminated immediately.
//
#define ERROR_FAIL_FAST_EXCEPTION 1653L


///////////////////////////////////////////////////
//                                               //
//               RPC Error codes                 //
//                                               //
//                 1700 to 1999                  //
///////////////////////////////////////////////////

//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
// The string binding is invalid.
//
#define RPC_S_INVALID_STRING_BINDING 1700L

//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
// The binding handle is not the correct type.
//
#define RPC_S_WRONG_KIND_OF_BINDING 1701L

//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
// The binding handle is invalid.
//
#define RPC_S_INVALID_BINDING 1702L

//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
// The RPC protocol sequence is not supported.
//
#define RPC_S_PROTSEQ_NOT_SUPPORTED 1703L

//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
// The RPC protocol sequence is invalid.
//
#define RPC_S_INVALID_RPC_PROTSEQ 1704L

//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
// The string universal unique identifier (UUID) is invalid.
//
#define RPC_S_INVALID_STRING_UUID 1705L

//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
// The endpoint format is invalid.
//
#define RPC_S_INVALID_ENDPOINT_FORMAT 1706L

//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
// The network address is invalid.
//
#define RPC_S_INVALID_NET_ADDR 1707L

//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
// No endpoint was found.
//
#define RPC_S_NO_ENDPOINT_FOUND 1708L

//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
// The timeout value is invalid.
//
#define RPC_S_INVALID_TIMEOUT 1709L

//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object universal unique identifier (UUID) was not found.
//
#define RPC_S_OBJECT_NOT_FOUND 1710L

//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
// The object universal unique identifier (UUID) has already been registered.
//
#define RPC_S_ALREADY_REGISTERED 1711L

//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
// The type universal unique identifier (UUID) has already been registered.
//
#define RPC_S_TYPE_ALREADY_REGISTERED 1712L

//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
// The RPC server is already listening.
//
#define RPC_S_ALREADY_LISTENING 1713L

//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
// No protocol sequences have been registered.
//
#define RPC_S_NO_PROTSEQS_REGISTERED 1714L

//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
// The RPC server is not listening.
//
#define RPC_S_NOT_LISTENING 1715L

//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
// The manager type is unknown.
//
#define RPC_S_UNKNOWN_MGR_TYPE 1716L

//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
// The interface is unknown.
//
#define RPC_S_UNKNOWN_IF 1717L

//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
// There are no bindings.
//
#define RPC_S_NO_BINDINGS 1718L

//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
// There are no protocol sequences.
//
#define RPC_S_NO_PROTSEQS 1719L

//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
// The endpoint cannot be created.
//
#define RPC_S_CANT_CREATE_ENDPOINT 1720L

//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
// Not enough resources are available to complete this operation.
//
#define RPC_S_OUT_OF_RESOURCES 1721L

//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
// The RPC server is unavailable.
//
#define RPC_S_SERVER_UNAVAILABLE 1722L

//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
// The RPC server is too busy to complete this operation.
//
#define RPC_S_SERVER_TOO_BUSY 1723L

//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
// The network options are invalid.
//
#define RPC_S_INVALID_NETWORK_OPTIONS 1724L

//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
// There are no remote procedure calls active on this thread.
//
#define RPC_S_NO_CALL_ACTIVE 1725L

//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
// The remote procedure call failed.
//
#define RPC_S_CALL_FAILED 1726L

//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
// The remote procedure call failed and did not execute.
//
#define RPC_S_CALL_FAILED_DNE 1727L

//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
// A remote procedure call (RPC) protocol error occurred.
//
#define RPC_S_PROTOCOL_ERROR 1728L

//
// MessageId: RPC_S_PROXY_ACCESS_DENIED
//
// MessageText:
//
// Access to the HTTP proxy is denied.
//
#define RPC_S_PROXY_ACCESS_DENIED 1729L

//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
// The transfer syntax is not supported by the RPC server.
//
#define RPC_S_UNSUPPORTED_TRANS_SYN 1730L

//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
// The universal unique identifier (UUID) type is not supported.
//
#define RPC_S_UNSUPPORTED_TYPE 1732L

//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
// The tag is invalid.
//
#define RPC_S_INVALID_TAG 1733L

//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
// The array bounds are invalid.
//
#define RPC_S_INVALID_BOUND 1734L

//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
// The binding does not contain an entry name.
//
#define RPC_S_NO_ENTRY_NAME 1735L

//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is invalid.
//
#define RPC_S_INVALID_NAME_SYNTAX 1736L

//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is not supported.
//
#define RPC_S_UNSUPPORTED_NAME_SYNTAX 1737L

//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
// No network address is available to use to construct a universal unique identifier (UUID).
//
#define RPC_S_UUID_NO_ADDRESS 1739L

//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
// The endpoint is a duplicate.
//
#define RPC_S_DUPLICATE_ENDPOINT 1740L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
// The authentication type is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_TYPE 1741L

//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
// The maximum number of calls is too small.
//
#define RPC_S_MAX_CALLS_TOO_SMALL 1742L

//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
// The string is too long.
//
#define RPC_S_STRING_TOO_LONG 1743L

//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
// The RPC protocol sequence was not found.
//
#define RPC_S_PROTSEQ_NOT_FOUND 1744L

//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
// The procedure number is out of range.
//
#define RPC_S_PROCNUM_OUT_OF_RANGE 1745L

//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
// The binding does not contain any authentication information.
//
#define RPC_S_BINDING_HAS_NO_AUTH 1746L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
// The authentication service is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_SERVICE 1747L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
// The authentication level is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_LEVEL 1748L

//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
// The security context is invalid.
//
#define RPC_S_INVALID_AUTH_IDENTITY 1749L

//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
// The authorization service is unknown.
//
#define RPC_S_UNKNOWN_AUTHZ_SERVICE 1750L

//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
// The entry is invalid.
//
#define EPT_S_INVALID_ENTRY 1751L

//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
// The server endpoint cannot perform the operation.
//
#define EPT_S_CANT_PERFORM_OP 1752L

//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
// There are no more endpoints available from the endpoint mapper.
//
#define EPT_S_NOT_REGISTERED 1753L

//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
// No interfaces have been exported.
//
#define RPC_S_NOTHING_TO_EXPORT 1754L

//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
// The entry name is incomplete.
//
#define RPC_S_INCOMPLETE_NAME 1755L

//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
// The version option is invalid.
//
#define RPC_S_INVALID_VERS_OPTION 1756L

//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
// There are no more members.
//
#define RPC_S_NO_MORE_MEMBERS 1757L

//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
// There is nothing to unexport.
//
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED 1758L

//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
// The interface was not found.
//
#define RPC_S_INTERFACE_NOT_FOUND 1759L

//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
// The entry already exists.
//
#define RPC_S_ENTRY_ALREADY_EXISTS 1760L

//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
// The entry is not found.
//
#define RPC_S_ENTRY_NOT_FOUND 1761L

//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The name service is unavailable.
//
#define RPC_S_NAME_SERVICE_UNAVAILABLE 1762L

//
// MessageId: RPC_S_INVALID_NAF_ID
//
// MessageText:
//
// The network address family is invalid.
//
#define RPC_S_INVALID_NAF_ID 1763L

//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
// The requested operation is not supported.
//
#define RPC_S_CANNOT_SUPPORT 1764L

//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
// No security context is available to allow impersonation.
//
#define RPC_S_NO_CONTEXT_AVAILABLE 1765L

//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred in a remote procedure call (RPC).
//
#define RPC_S_INTERNAL_ERROR 1766L

//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
// The RPC server attempted an integer division by zero.
//
#define RPC_S_ZERO_DIVIDE 1767L

//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
// An addressing error occurred in the RPC server.
//
#define RPC_S_ADDRESS_ERROR 1768L

//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
// A floating-point operation at the RPC server caused a division by zero.
//
#define RPC_S_FP_DIV_ZERO 1769L

//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
// A floating-point underflow occurred at the RPC server.
//
#define RPC_S_FP_UNDERFLOW 1770L

//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
// A floating-point overflow occurred at the RPC server.
//
#define RPC_S_FP_OVERFLOW 1771L

//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
// The list of RPC servers available for the binding of auto handles has been exhausted.
//
#define RPC_X_NO_MORE_ENTRIES 1772L

//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
// Unable to open the character translation table file.
//
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL 1773L

//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
// The file containing the character translation table has fewer than 512 bytes.
//
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE 1774L

//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
// A null context handle was passed from the client to the host during a remote procedure call.
//
#define RPC_X_SS_IN_NULL_CONTEXT 1775L

//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
// The context handle changed during a remote procedure call.
//
#define RPC_X_SS_CONTEXT_DAMAGED 1777L

//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
// The binding handles passed to a remote procedure call do not match.
//
#define RPC_X_SS_HANDLES_MISMATCH 1778L

//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
// The stub is unable to get the remote procedure call handle.
//
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE 1779L

//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
// A null reference pointer was passed to the stub.
//
#define RPC_X_NULL_REF_POINTER 1780L

//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The enumeration value is out of range.
//
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE 1781L

//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
// The byte count is too small.
//
#define RPC_X_BYTE_COUNT_TOO_SMALL 1782L

//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
// The stub received bad data.
//
#define RPC_X_BAD_STUB_DATA 1783L

//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
// The supplied user buffer is not valid for the requested operation.
//
#define ERROR_INVALID_USER_BUFFER 1784L

//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
// The disk media is not recognized. It may not be formatted.
//
#define ERROR_UNRECOGNIZED_MEDIA 1785L

//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
// The workstation does not have a trust secret.
//
#define ERROR_NO_TRUST_LSA_SECRET 1786L

//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
// The security database on the server does not have a computer account for this workstation trust relationship.
//
#define ERROR_NO_TRUST_SAM_ACCOUNT 1787L

//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
// The trust relationship between the primary domain and the trusted domain failed.
//
#define ERROR_TRUSTED_DOMAIN_FAILURE 1788L

//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
// The trust relationship between this workstation and the primary domain failed.
//
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789L

//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
// The network logon failed.
//
#define ERROR_TRUST_FAILURE 1790L

//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
// A remote procedure call is already in progress for this thread.
//
#define RPC_S_CALL_IN_PROGRESS 1791L

//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
// An attempt was made to logon, but the network logon service was not started.
//
#define ERROR_NETLOGON_NOT_STARTED 1792L

//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
// The user's account has expired.
//
#define ERROR_ACCOUNT_EXPIRED 1793L

//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
// The redirector is in use and cannot be unloaded.
//
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794L

//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
// The specified printer driver is already installed.
//
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795L

//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
// The specified port is unknown.
//
#define ERROR_UNKNOWN_PORT 1796L

//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
// The printer driver is unknown.
//
#define ERROR_UNKNOWN_PRINTER_DRIVER 1797L

//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
// The print processor is unknown.
//
#define ERROR_UNKNOWN_PRINTPROCESSOR 1798L

//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
// The specified separator file is invalid.
//
#define ERROR_INVALID_SEPARATOR_FILE 1799L

//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
// The specified priority is invalid.
//
#define ERROR_INVALID_PRIORITY 1800L

//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
// The printer name is invalid.
//
#define ERROR_INVALID_PRINTER_NAME 1801L

//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
// The printer already exists.
//
#define ERROR_PRINTER_ALREADY_EXISTS 1802L

//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
// The printer command is invalid.
//
#define ERROR_INVALID_PRINTER_COMMAND 1803L

//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
// The specified datatype is invalid.
//
#define ERROR_INVALID_DATATYPE 1804L

//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
// The environment specified is invalid.
//
#define ERROR_INVALID_ENVIRONMENT 1805L

//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
// There are no more bindings.
//
#define RPC_S_NO_MORE_BINDINGS 1806L

//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is an interdomain trust account. Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807L

//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is a computer account. Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808L

//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is a server trust account. Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809L

//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
// The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.
//
#define ERROR_DOMAIN_TRUST_INCONSISTENT 1810L

//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
// The server is in use and cannot be unloaded.
//
#define ERROR_SERVER_HAS_OPEN_HANDLES 1811L

//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
// The specified image file did not contain a resource section.
//
#define ERROR_RESOURCE_DATA_NOT_FOUND 1812L

//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
// The specified resource type cannot be found in the image file.
//
#define ERROR_RESOURCE_TYPE_NOT_FOUND 1813L

//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
// The specified resource name cannot be found in the image file.
//
#define ERROR_RESOURCE_NAME_NOT_FOUND 1814L

//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
// The specified resource language ID cannot be found in the image file.
//
#define ERROR_RESOURCE_LANG_NOT_FOUND 1815L

//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
// Not enough quota is available to process this command.
//
#define ERROR_NOT_ENOUGH_QUOTA 1816L

//
// MessageId: RPC_S_NO_INTERFACES
//
// MessageText:
//
// No interfaces have been registered.
//
#define RPC_S_NO_INTERFACES 1817L

//
// MessageId: RPC_S_CALL_CANCELLED
//
// MessageText:
//
// The remote procedure call was cancelled.
//
#define RPC_S_CALL_CANCELLED 1818L

//
// MessageId: RPC_S_BINDING_INCOMPLETE
//
// MessageText:
//
// The binding handle does not contain all required information.
//
#define RPC_S_BINDING_INCOMPLETE 1819L

//
// MessageId: RPC_S_COMM_FAILURE
//
// MessageText:
//
// A communications failure occurred during a remote procedure call.
//
#define RPC_S_COMM_FAILURE 1820L

//
// MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
// The requested authentication level is not supported.
//
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL 1821L

//
// MessageId: RPC_S_NO_PRINC_NAME
//
// MessageText:
//
// No principal name registered.
//
#define RPC_S_NO_PRINC_NAME 1822L

//
// MessageId: RPC_S_NOT_RPC_ERROR
//
// MessageText:
//
// The error specified is not a valid Windows RPC error code.
//
#define RPC_S_NOT_RPC_ERROR 1823L

//
// MessageId: RPC_S_UUID_LOCAL_ONLY
//
// MessageText:
//
// A UUID that is valid only on this computer has been allocated.
//
#define RPC_S_UUID_LOCAL_ONLY 1824L

//
// MessageId: RPC_S_SEC_PKG_ERROR
//
// MessageText:
//
// A security package specific error occurred.
//
#define RPC_S_SEC_PKG_ERROR 1825L

//
// MessageId: RPC_S_NOT_CANCELLED
//
// MessageText:
//
// Thread is not canceled.
//
#define RPC_S_NOT_CANCELLED 1826L

//
// MessageId: RPC_X_INVALID_ES_ACTION
//
// MessageText:
//
// Invalid operation on the encoding/decoding handle.
//
#define RPC_X_INVALID_ES_ACTION 1827L

//
// MessageId: RPC_X_WRONG_ES_VERSION
//
// MessageText:
//
// Incompatible version of the serializing package.
//
#define RPC_X_WRONG_ES_VERSION 1828L

//
// MessageId: RPC_X_WRONG_STUB_VERSION
//
// MessageText:
//
// Incompatible version of the RPC stub.
//
#define RPC_X_WRONG_STUB_VERSION 1829L

//
// MessageId: RPC_X_INVALID_PIPE_OBJECT
//
// MessageText:
//
// The RPC pipe object is invalid or corrupted.
//
#define RPC_X_INVALID_PIPE_OBJECT 1830L

//
// MessageId: RPC_X_WRONG_PIPE_ORDER
//
// MessageText:
//
// An invalid operation was attempted on an RPC pipe object.
//
#define RPC_X_WRONG_PIPE_ORDER 1831L

//
// MessageId: RPC_X_WRONG_PIPE_VERSION
//
// MessageText:
//
// Unsupported RPC pipe version.
//
#define RPC_X_WRONG_PIPE_VERSION 1832L

//
// MessageId: RPC_S_COOKIE_AUTH_FAILED
//
// MessageText:
//
// HTTP proxy server rejected the connection because the cookie authentication failed.
//
#define RPC_S_COOKIE_AUTH_FAILED 1833L

//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
// The group member was not found.
//
#define RPC_S_GROUP_MEMBER_NOT_FOUND 1898L

//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
// The endpoint mapper database entry could not be created.
//
#define EPT_S_CANT_CREATE 1899L

//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
// The object universal unique identifier (UUID) is the nil UUID.
//
#define RPC_S_INVALID_OBJECT 1900L

//
// MessageId: ERROR_INVALID_TIME
//
// MessageText:
//
// The specified time is invalid.
//
#define ERROR_INVALID_TIME 1901L

//
// MessageId: ERROR_INVALID_FORM_NAME
//
// MessageText:
//
// The specified form name is invalid.
//
#define ERROR_INVALID_FORM_NAME 1902L

//
// MessageId: ERROR_INVALID_FORM_SIZE
//
// MessageText:
//
// The specified form size is invalid.
//
#define ERROR_INVALID_FORM_SIZE 1903L

//
// MessageId: ERROR_ALREADY_WAITING
//
// MessageText:
//
// The specified printer handle is already being waited on
//
#define ERROR_ALREADY_WAITING 1904L

//
// MessageId: ERROR_PRINTER_DELETED
//
// MessageText:
//
// The specified printer has been deleted.
//
#define ERROR_PRINTER_DELETED 1905L

//
// MessageId: ERROR_INVALID_PRINTER_STATE
//
// MessageText:
//
// The state of the printer is invalid.
//
#define ERROR_INVALID_PRINTER_STATE 1906L

//
// MessageId: ERROR_PASSWORD_MUST_CHANGE
//
// MessageText:
//
// The user's password must be changed before logging on the first time.
//
#define ERROR_PASSWORD_MUST_CHANGE 1907L

//
// MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
// Could not find the domain controller for this domain.
//
#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908L

//
// MessageId: ERROR_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
// The referenced account is currently locked out and may not be logged on to.
//
#define ERROR_ACCOUNT_LOCKED_OUT 1909L

//
// MessageId: OR_INVALID_OXID
//
// MessageText:
//
// The object exporter specified was not found.
//
#define OR_INVALID_OXID 1910L

//
// MessageId: OR_INVALID_OID
//
// MessageText:
//
// The object specified was not found.
//
#define OR_INVALID_OID 1911L

//
// MessageId: OR_INVALID_SET
//
// MessageText:
//
// The object resolver set specified was not found.
//
#define OR_INVALID_SET 1912L

//
// MessageId: RPC_S_SEND_INCOMPLETE
//
// MessageText:
//
// Some data remains to be sent in the request buffer.
//
#define RPC_S_SEND_INCOMPLETE 1913L

//
// MessageId: RPC_S_INVALID_ASYNC_HANDLE
//
// MessageText:
//
// Invalid asynchronous remote procedure call handle.
//
#define RPC_S_INVALID_ASYNC_HANDLE 1914L

//
// MessageId: RPC_S_INVALID_ASYNC_CALL
//
// MessageText:
//
// Invalid asynchronous RPC call handle for this operation.
//
#define RPC_S_INVALID_ASYNC_CALL 1915L

//
// MessageId: RPC_X_PIPE_CLOSED
//
// MessageText:
//
// The RPC pipe object has already been closed.
//
#define RPC_X_PIPE_CLOSED 1916L

//
// MessageId: RPC_X_PIPE_DISCIPLINE_ERROR
//
// MessageText:
//
// The RPC call completed before all pipes were processed.
//
#define RPC_X_PIPE_DISCIPLINE_ERROR 1917L

//
// MessageId: RPC_X_PIPE_EMPTY
//
// MessageText:
//
// No more data is available from the RPC pipe.
//
#define RPC_X_PIPE_EMPTY 1918L

//
// MessageId: ERROR_NO_SITENAME
//
// MessageText:
//
// No site name is available for this machine.
//
#define ERROR_NO_SITENAME 1919L

//
// MessageId: ERROR_CANT_ACCESS_FILE
//
// MessageText:
//
// The file cannot be accessed by the system.
//
#define ERROR_CANT_ACCESS_FILE 1920L

//
// MessageId: ERROR_CANT_RESOLVE_FILENAME
//
// MessageText:
//
// The name of the file cannot be resolved by the system.
//
#define ERROR_CANT_RESOLVE_FILENAME 1921L

//
// MessageId: RPC_S_ENTRY_TYPE_MISMATCH
//
// MessageText:
//
// The entry is not of the expected type.
//
#define RPC_S_ENTRY_TYPE_MISMATCH 1922L

//
// MessageId: RPC_S_NOT_ALL_OBJS_EXPORTED
//
// MessageText:
//
// Not all object UUIDs could be exported to the specified entry.
//
#define RPC_S_NOT_ALL_OBJS_EXPORTED 1923L

//
// MessageId: RPC_S_INTERFACE_NOT_EXPORTED
//
// MessageText:
//
// Interface could not be exported to the specified entry.
//
#define RPC_S_INTERFACE_NOT_EXPORTED 1924L

//
// MessageId: RPC_S_PROFILE_NOT_ADDED
//
// MessageText:
//
// The specified profile entry could not be added.
//
#define RPC_S_PROFILE_NOT_ADDED 1925L

//
// MessageId: RPC_S_PRF_ELT_NOT_ADDED
//
// MessageText:
//
// The specified profile element could not be added.
//
#define RPC_S_PRF_ELT_NOT_ADDED 1926L

//
// MessageId: RPC_S_PRF_ELT_NOT_REMOVED
//
// MessageText:
//
// The specified profile element could not be removed.
//
#define RPC_S_PRF_ELT_NOT_REMOVED 1927L

//
// MessageId: RPC_S_GRP_ELT_NOT_ADDED
//
// MessageText:
//
// The group element could not be added.
//
#define RPC_S_GRP_ELT_NOT_ADDED 1928L

//
// MessageId: RPC_S_GRP_ELT_NOT_REMOVED
//
// MessageText:
//
// The group element could not be removed.
//
#define RPC_S_GRP_ELT_NOT_REMOVED 1929L

//
// MessageId: ERROR_KM_DRIVER_BLOCKED
//
// MessageText:
//
// The printer driver is not compatible with a policy enabled on your computer that blocks NT 4.0 drivers.
//
#define ERROR_KM_DRIVER_BLOCKED 1930L

//
// MessageId: ERROR_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//
#define ERROR_CONTEXT_EXPIRED 1931L

//
// MessageId: ERROR_PER_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust creation quota has been exceeded.
//
#define ERROR_PER_USER_TRUST_QUOTA_EXCEEDED 1932L

//
// MessageId: ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The total delegated trust creation quota has been exceeded.
//
#define ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED 1933L

//
// MessageId: ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust deletion quota has been exceeded.
//
#define ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED 1934L

//
// MessageId: ERROR_AUTHENTICATION_FIREWALL_FAILED
//
// MessageText:
//
// Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine.
//
#define ERROR_AUTHENTICATION_FIREWALL_FAILED 1935L

//
// MessageId: ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED
//
// MessageText:
//
// Remote connections to the Print Spooler are blocked by a policy set on your machine.
//
#define ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED 1936L

//
// MessageId: ERROR_NTLM_BLOCKED
//
// MessageText:
//
// Logon Failure: Authentication failed because NTLM authentication has been disabled.
//
#define ERROR_NTLM_BLOCKED 1937L


///////////////////////////////////////////////////
//                                               //
//              OpenGL Error codes               //
//                                               //
//                 2000 to 2009                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_PIXEL_FORMAT
//
// MessageText:
//
// The pixel format is invalid.
//
#define ERROR_INVALID_PIXEL_FORMAT 2000L

//
// MessageId: ERROR_BAD_DRIVER
//
// MessageText:
//
// The specified driver is invalid.
//
#define ERROR_BAD_DRIVER 2001L

//
// MessageId: ERROR_INVALID_WINDOW_STYLE
//
// MessageText:
//
// The window style or class attribute is invalid for this operation.
//
#define ERROR_INVALID_WINDOW_STYLE 2002L

//
// MessageId: ERROR_METAFILE_NOT_SUPPORTED
//
// MessageText:
//
// The requested metafile operation is not supported.
//
#define ERROR_METAFILE_NOT_SUPPORTED 2003L

//
// MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
//
// MessageText:
//
// The requested transformation operation is not supported.
//
#define ERROR_TRANSFORM_NOT_SUPPORTED 2004L

//
// MessageId: ERROR_CLIPPING_NOT_SUPPORTED
//
// MessageText:
//
// The requested clipping operation is not supported.
//
#define ERROR_CLIPPING_NOT_SUPPORTED 2005L


///////////////////////////////////////////////////
//                                               //
//       Image Color Management Error codes      //
//                                               //
//                 2010 to 2049                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_CMM
//
// MessageText:
//
// The specified color management module is invalid.
//
#define ERROR_INVALID_CMM 2010L

//
// MessageId: ERROR_INVALID_PROFILE
//
// MessageText:
//
// The specified color profile is invalid.
//
#define ERROR_INVALID_PROFILE 2011L

//
// MessageId: ERROR_TAG_NOT_FOUND
//
// MessageText:
//
// The specified tag was not found.
//
#define ERROR_TAG_NOT_FOUND 2012L

//
// MessageId: ERROR_TAG_NOT_PRESENT
//
// MessageText:
//
// A required tag is not present.
//
#define ERROR_TAG_NOT_PRESENT 2013L

//
// MessageId: ERROR_DUPLICATE_TAG
//
// MessageText:
//
// The specified tag is already present.
//
#define ERROR_DUPLICATE_TAG 2014L

//
// MessageId: ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
//
// MessageText:
//
// The specified color profile is not associated with the specified device.
//
#define ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE 2015L

//
// MessageId: ERROR_PROFILE_NOT_FOUND
//
// MessageText:
//
// The specified color profile was not found.
//
#define ERROR_PROFILE_NOT_FOUND 2016L

//
// MessageId: ERROR_INVALID_COLORSPACE
//
// MessageText:
//
// The specified color space is invalid.
//
#define ERROR_INVALID_COLORSPACE 2017L

//
// MessageId: ERROR_ICM_NOT_ENABLED
//
// MessageText:
//
// Image Color Management is not enabled.
//
#define ERROR_ICM_NOT_ENABLED 2018L

//
// MessageId: ERROR_DELETING_ICM_XFORM
//
// MessageText:
//
// There was an error while deleting the color transform.
//
#define ERROR_DELETING_ICM_XFORM 2019L

//
// MessageId: ERROR_INVALID_TRANSFORM
//
// MessageText:
//
// The specified color transform is invalid.
//
#define ERROR_INVALID_TRANSFORM 2020L

//
// MessageId: ERROR_COLORSPACE_MISMATCH
//
// MessageText:
//
// The specified transform does not match the bitmap's color space.
//
#define ERROR_COLORSPACE_MISMATCH 2021L

//
// MessageId: ERROR_INVALID_COLORINDEX
//
// MessageText:
//
// The specified named color index is not present in the profile.
//
#define ERROR_INVALID_COLORINDEX 2022L

//
// MessageId: ERROR_PROFILE_DOES_NOT_MATCH_DEVICE
//
// MessageText:
//
// The specified profile is intended for a device of a different type than the specified device.
//
#define ERROR_PROFILE_DOES_NOT_MATCH_DEVICE 2023L


///////////////////////////////////////////////////
//                                               //
//             Winnet32 Error codes              //
//                                               //
//                 2100 to 2999                  //
//                                               //
// The range 2100 through 2999 is reserved for   //
// network status codes. See lmerr.h for a       //
// complete listing                              //
///////////////////////////////////////////////////

//
// MessageId: ERROR_CONNECTED_OTHER_PASSWORD
//
// MessageText:
//
// The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.
//
#define ERROR_CONNECTED_OTHER_PASSWORD 2108L

//
// MessageId: ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT
//
// MessageText:
//
// The network connection was made successfully using default credentials.
//
#define ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT 2109L

//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
// The specified username is invalid.
//
#define ERROR_BAD_USERNAME 2202L

//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
// This network connection does not exist.
//
#define ERROR_NOT_CONNECTED 2250L

//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
// This network connection has files open or requests pending.
//
#define ERROR_OPEN_FILES 2401L

//
// MessageId: ERROR_ACTIVE_CONNECTIONS
//
// MessageText:
//
// Active connections still exist.
//
#define ERROR_ACTIVE_CONNECTIONS 2402L

//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
// The device is in use by an active process and cannot be disconnected.
//
#define ERROR_DEVICE_IN_USE 2404L


///////////////////////////////////////////////////
//                                               //
//           Win32 Spooler Error codes           //
//                                               //
//                 3000 to 3049                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_UNKNOWN_PRINT_MONITOR
//
// MessageText:
//
// The specified print monitor is unknown.
//
#define ERROR_UNKNOWN_PRINT_MONITOR 3000L

//
// MessageId: ERROR_PRINTER_DRIVER_IN_USE
//
// MessageText:
//
// The specified printer driver is currently in use.
//
#define ERROR_PRINTER_DRIVER_IN_USE 3001L

//
// MessageId: ERROR_SPOOL_FILE_NOT_FOUND
//
// MessageText:
//
// The spool file was not found.
//
#define ERROR_SPOOL_FILE_NOT_FOUND 3002L

//
// MessageId: ERROR_SPL_NO_STARTDOC
//
// MessageText:
//
// A StartDocPrinter call was not issued.
//
#define ERROR_SPL_NO_STARTDOC 3003L

//
// MessageId: ERROR_SPL_NO_ADDJOB
//
// MessageText:
//
// An AddJob call was not issued.
//
#define ERROR_SPL_NO_ADDJOB 3004L

//
// MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
//
// MessageText:
//
// The specified print processor has already been installed.
//
#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005L

//
// MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
//
// MessageText:
//
// The specified print monitor has already been installed.
//
#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006L

//
// MessageId: ERROR_INVALID_PRINT_MONITOR
//
// MessageText:
//
// The specified print monitor does not have the required functions.
//
#define ERROR_INVALID_PRINT_MONITOR 3007L

//
// MessageId: ERROR_PRINT_MONITOR_IN_USE
//
// MessageText:
//
// The specified print monitor is currently in use.
//
#define ERROR_PRINT_MONITOR_IN_USE 3008L

//
// MessageId: ERROR_PRINTER_HAS_JOBS_QUEUED
//
// MessageText:
//
// The requested operation is not allowed when there are jobs queued to the printer.
//
#define ERROR_PRINTER_HAS_JOBS_QUEUED 3009L

//
// MessageId: ERROR_SUCCESS_REBOOT_REQUIRED
//
// MessageText:
//
// The requested operation is successful. Changes will not be effective until the system is rebooted.
//
#define ERROR_SUCCESS_REBOOT_REQUIRED 3010L

//
// MessageId: ERROR_SUCCESS_RESTART_REQUIRED
//
// MessageText:
//
// The requested operation is successful. Changes will not be effective until the service is restarted.
//
#define ERROR_SUCCESS_RESTART_REQUIRED 3011L

//
// MessageId: ERROR_PRINTER_NOT_FOUND
//
// MessageText:
//
// No printers were found.
//
#define ERROR_PRINTER_NOT_FOUND 3012L

//
// MessageId: ERROR_PRINTER_DRIVER_WARNED
//
// MessageText:
//
// The printer driver is known to be unreliable.
//
#define ERROR_PRINTER_DRIVER_WARNED 3013L

//
// MessageId: ERROR_PRINTER_DRIVER_BLOCKED
//
// MessageText:
//
// The printer driver is known to harm the system.
//
#define ERROR_PRINTER_DRIVER_BLOCKED 3014L

//
// MessageId: ERROR_PRINTER_DRIVER_PACKAGE_IN_USE
//
// MessageText:
//
// The specified printer driver package is currently in use.
//
#define ERROR_PRINTER_DRIVER_PACKAGE_IN_USE 3015L

//
// MessageId: ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND
//
// MessageText:
//
// Unable to find a core driver package that is required by the printer driver package.
//
#define ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND 3016L

//
// MessageId: ERROR_FAIL_REBOOT_REQUIRED
//
// MessageText:
//
// The requested operation failed. A system reboot is required to roll back changes made.
//
#define ERROR_FAIL_REBOOT_REQUIRED 3017L

//
// MessageId: ERROR_FAIL_REBOOT_INITIATED
//
// MessageText:
//
// The requested operation failed. A system reboot has been initiated to roll back changes made.
//
#define ERROR_FAIL_REBOOT_INITIATED 3018L

//
// MessageId: ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED
//
// MessageText:
//
// The specified printer driver was not found on the system and needs to be downloaded.
//
#define ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED 3019L

//
// MessageId: ERROR_PRINT_JOB_RESTART_REQUIRED
//
// MessageText:
//
// The requested print job has failed to print. A print system update requires the job to be resubmitted.
//
#define ERROR_PRINT_JOB_RESTART_REQUIRED 3020L


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 3050 to 3199                  //
///////////////////////////////////////////////////


//
//               the message range
//                 3200 to 3299
//      is reserved and used in isolation lib
// 

///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 3300 to 3899                  //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//                IO Error Codes                 //
//                                               //
//                 3900 to 3999                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_IO_REISSUE_AS_CACHED
//
// MessageText:
//
// Reissue the given operation as a cached IO operation
//
#define ERROR_IO_REISSUE_AS_CACHED 3950L



///////////////////////////////////////////////////
//                                               //
//                Wins Error codes               //
//                                               //
//                 4000 to 4049                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_WINS_INTERNAL
//
// MessageText:
//
// WINS encountered an error while processing the command.
//
#define ERROR_WINS_INTERNAL 4000L

//
// MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
//
// MessageText:
//
// The local WINS cannot be deleted.
//
#define ERROR_CAN_NOT_DEL_LOCAL_WINS 4001L

//
// MessageId: ERROR_STATIC_INIT
//
// MessageText:
//
// The importation from the file failed.
//
#define ERROR_STATIC_INIT 4002L

//
// MessageId: ERROR_INC_BACKUP
//
// MessageText:
//
// The backup failed. Was a full backup done before?
//
#define ERROR_INC_BACKUP 4003L

//
// MessageId: ERROR_FULL_BACKUP
//
// MessageText:
//
// The backup failed. Check the directory to which you are backing the database.
//
#define ERROR_FULL_BACKUP 4004L

//
// MessageId: ERROR_REC_NON_EXISTENT
//
// MessageText:
//
// The name does not exist in the WINS database.
//
#define ERROR_REC_NON_EXISTENT 4005L

//
// MessageId: ERROR_RPL_NOT_ALLOWED
//
// MessageText:
//
// Replication with a nonconfigured partner is not allowed.
//
#define ERROR_RPL_NOT_ALLOWED 4006L


///////////////////////////////////////////////////
//                                               //
//              PeerDist Error codes             //
//                                               //
//                 4050 to 4099                  //
///////////////////////////////////////////////////

//
// MessageId: PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED
//
// MessageText:
//
// The version of the supplied content information is not supported.
//
#define PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED 4050L

//
// MessageId: PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO
//
// MessageText:
//
// The supplied content information is malformed.
//
#define PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO 4051L

//
// MessageId: PEERDIST_ERROR_MISSING_DATA
//
// MessageText:
//
// The requested data cannot be found in local or peer caches.
//
#define PEERDIST_ERROR_MISSING_DATA 4052L

//
// MessageId: PEERDIST_ERROR_NO_MORE
//
// MessageText:
//
// No more data is available or required.
//
#define PEERDIST_ERROR_NO_MORE 4053L

//
// MessageId: PEERDIST_ERROR_NOT_INITIALIZED
//
// MessageText:
//
// The supplied object has not been initialized.
//
#define PEERDIST_ERROR_NOT_INITIALIZED 4054L

//
// MessageId: PEERDIST_ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
// The supplied object has already been initialized.
//
#define PEERDIST_ERROR_ALREADY_INITIALIZED 4055L

//
// MessageId: PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A shutdown operation is already in progress.
//
#define PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS 4056L

//
// MessageId: PEERDIST_ERROR_INVALIDATED
//
// MessageText:
//
// The supplied object has already been invalidated.
//
#define PEERDIST_ERROR_INVALIDATED 4057L

//
// MessageId: PEERDIST_ERROR_ALREADY_EXISTS
//
// MessageText:
//
// An element already exists and was not replaced.
//
#define PEERDIST_ERROR_ALREADY_EXISTS 4058L

//
// MessageId: PEERDIST_ERROR_OPERATION_NOTFOUND
//
// MessageText:
//
// Can not cancel the requested operation as it has already been completed.
//
#define PEERDIST_ERROR_OPERATION_NOTFOUND 4059L

//
// MessageId: PEERDIST_ERROR_ALREADY_COMPLETED
//
// MessageText:
//
// Can not perform the reqested operation because it has already been carried out.
//
#define PEERDIST_ERROR_ALREADY_COMPLETED 4060L

//
// MessageId: PEERDIST_ERROR_OUT_OF_BOUNDS
//
// MessageText:
//
// An operation accessed data beyond the bounds of valid data.
//
#define PEERDIST_ERROR_OUT_OF_BOUNDS 4061L

//
// MessageId: PEERDIST_ERROR_VERSION_UNSUPPORTED
//
// MessageText:
//
// The requested version is not supported.
//
#define PEERDIST_ERROR_VERSION_UNSUPPORTED 4062L

//
// MessageId: PEERDIST_ERROR_INVALID_CONFIGURATION
//
// MessageText:
//
// A configuration value is invalid.
//
#define PEERDIST_ERROR_INVALID_CONFIGURATION 4063L

//
// MessageId: PEERDIST_ERROR_NOT_LICENSED
//
// MessageText:
//
// The SKU is not licensed.
//
#define PEERDIST_ERROR_NOT_LICENSED 4064L

//
// MessageId: PEERDIST_ERROR_SERVICE_UNAVAILABLE
//
// MessageText:
//
// PeerDist Service is still initializing and will be available shortly.
//
#define PEERDIST_ERROR_SERVICE_UNAVAILABLE 4065L


///////////////////////////////////////////////////
//                                               //
//               DHCP Error codes                //
//                                               //
//                 4100 to 4149                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_DHCP_ADDRESS_CONFLICT
//
// MessageText:
//
// The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.
//
#define ERROR_DHCP_ADDRESS_CONFLICT 4100L


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4150 to 4199                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//               WMI Error codes                 //
//                                               //
//                 4200 to 4249                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_WMI_GUID_NOT_FOUND
//
// MessageText:
//
// The GUID passed was not recognized as valid by a WMI data provider.
//
#define ERROR_WMI_GUID_NOT_FOUND 4200L

//
// MessageId: ERROR_WMI_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The instance name passed was not recognized as valid by a WMI data provider.
//
#define ERROR_WMI_INSTANCE_NOT_FOUND 4201L

//
// MessageId: ERROR_WMI_ITEMID_NOT_FOUND
//
// MessageText:
//
// The data item ID passed was not recognized as valid by a WMI data provider.
//
#define ERROR_WMI_ITEMID_NOT_FOUND 4202L

//
// MessageId: ERROR_WMI_TRY_AGAIN
//
// MessageText:
//
// The WMI request could not be completed and should be retried.
//
#define ERROR_WMI_TRY_AGAIN 4203L

//
// MessageId: ERROR_WMI_DP_NOT_FOUND
//
// MessageText:
//
// The WMI data provider could not be located.
//
#define ERROR_WMI_DP_NOT_FOUND 4204L

//
// MessageId: ERROR_WMI_UNRESOLVED_INSTANCE_REF
//
// MessageText:
//
// The WMI data provider references an instance set that has not been registered.
//
#define ERROR_WMI_UNRESOLVED_INSTANCE_REF 4205L

//
// MessageId: ERROR_WMI_ALREADY_ENABLED
//
// MessageText:
//
// The WMI data block or event notification has already been enabled.
//
#define ERROR_WMI_ALREADY_ENABLED 4206L

//
// MessageId: ERROR_WMI_GUID_DISCONNECTED
//
// MessageText:
//
// The WMI data block is no longer available.
//
#define ERROR_WMI_GUID_DISCONNECTED 4207L

//
// MessageId: ERROR_WMI_SERVER_UNAVAILABLE
//
// MessageText:
//
// The WMI data service is not available.
//
#define ERROR_WMI_SERVER_UNAVAILABLE 4208L

//
// MessageId: ERROR_WMI_DP_FAILED
//
// MessageText:
//
// The WMI data provider failed to carry out the request.
//
#define ERROR_WMI_DP_FAILED 4209L

//
// MessageId: ERROR_WMI_INVALID_MOF
//
// MessageText:
//
// The WMI MOF information is not valid.
//
#define ERROR_WMI_INVALID_MOF 4210L

//
// MessageId: ERROR_WMI_INVALID_REGINFO
//
// MessageText:
//
// The WMI registration information is not valid.
//
#define ERROR_WMI_INVALID_REGINFO 4211L

//
// MessageId: ERROR_WMI_ALREADY_DISABLED
//
// MessageText:
//
// The WMI data block or event notification has already been disabled.
//
#define ERROR_WMI_ALREADY_DISABLED 4212L

//
// MessageId: ERROR_WMI_READ_ONLY
//
// MessageText:
//
// The WMI data item or data block is read only.
//
#define ERROR_WMI_READ_ONLY 4213L

//
// MessageId: ERROR_WMI_SET_FAILURE
//
// MessageText:
//
// The WMI data item or data block could not be changed.
//
#define ERROR_WMI_SET_FAILURE 4214L


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4250 to 4299                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//        RSM (Media Services) Error codes       //
//                                               //
//                 4300 to 4349                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_MEDIA
//
// MessageText:
//
// The media identifier does not represent a valid medium.
//
#define ERROR_INVALID_MEDIA 4300L

//
// MessageId: ERROR_INVALID_LIBRARY
//
// MessageText:
//
// The library identifier does not represent a valid library.
//
#define ERROR_INVALID_LIBRARY 4301L

//
// MessageId: ERROR_INVALID_MEDIA_POOL
//
// MessageText:
//
// The media pool identifier does not represent a valid media pool.
//
#define ERROR_INVALID_MEDIA_POOL 4302L

//
// MessageId: ERROR_DRIVE_MEDIA_MISMATCH
//
// MessageText:
//
// The drive and medium are not compatible or exist in different libraries.
//
#define ERROR_DRIVE_MEDIA_MISMATCH 4303L

//
// MessageId: ERROR_MEDIA_OFFLINE
//
// MessageText:
//
// The medium currently exists in an offline library and must be online to perform this operation.
//
#define ERROR_MEDIA_OFFLINE 4304L

//
// MessageId: ERROR_LIBRARY_OFFLINE
//
// MessageText:
//
// The operation cannot be performed on an offline library.
//
#define ERROR_LIBRARY_OFFLINE 4305L

//
// MessageId: ERROR_EMPTY
//
// MessageText:
//
// The library, drive, or media pool is empty.
//
#define ERROR_EMPTY 4306L

//
// MessageId: ERROR_NOT_EMPTY
//
// MessageText:
//
// The library, drive, or media pool must be empty to perform this operation.
//
#define ERROR_NOT_EMPTY 4307L

//
// MessageId: ERROR_MEDIA_UNAVAILABLE
//
// MessageText:
//
// No media is currently available in this media pool or library.
//
#define ERROR_MEDIA_UNAVAILABLE 4308L

//
// MessageId: ERROR_RESOURCE_DISABLED
//
// MessageText:
//
// A resource required for this operation is disabled.
//
#define ERROR_RESOURCE_DISABLED 4309L

//
// MessageId: ERROR_INVALID_CLEANER
//
// MessageText:
//
// The media identifier does not represent a valid cleaner.
//
#define ERROR_INVALID_CLEANER 4310L

//
// MessageId: ERROR_UNABLE_TO_CLEAN
//
// MessageText:
//
// The drive cannot be cleaned or does not support cleaning.
//
#define ERROR_UNABLE_TO_CLEAN 4311L

//
// MessageId: ERROR_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object identifier does not represent a valid object.
//
#define ERROR_OBJECT_NOT_FOUND 4312L

//
// MessageId: ERROR_DATABASE_FAILURE
//
// MessageText:
//
// Unable to read from or write to the database.
//
#define ERROR_DATABASE_FAILURE 4313L

//
// MessageId: ERROR_DATABASE_FULL
//
// MessageText:
//
// The database is full.
//
#define ERROR_DATABASE_FULL 4314L

//
// MessageId: ERROR_MEDIA_INCOMPATIBLE
//
// MessageText:
//
// The medium is not compatible with the device or media pool.
//
#define ERROR_MEDIA_INCOMPATIBLE 4315L

//
// MessageId: ERROR_RESOURCE_NOT_PRESENT
//
// MessageText:
//
// The resource required for this operation does not exist.
//
#define ERROR_RESOURCE_NOT_PRESENT 4316L

//
// MessageId: ERROR_INVALID_OPERATION
//
// MessageText:
//
// The operation identifier is not valid.
//
#define ERROR_INVALID_OPERATION 4317L

//
// MessageId: ERROR_MEDIA_NOT_AVAILABLE
//
// MessageText:
//
// The media is not mounted or ready for use.
//
#define ERROR_MEDIA_NOT_AVAILABLE 4318L

//
// MessageId: ERROR_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
// The device is not ready for use.
//
#define ERROR_DEVICE_NOT_AVAILABLE 4319L

//
// MessageId: ERROR_REQUEST_REFUSED
//
// MessageText:
//
// The operator or administrator has refused the request.
//
#define ERROR_REQUEST_REFUSED 4320L

//
// MessageId: ERROR_INVALID_DRIVE_OBJECT
//
// MessageText:
//
// The drive identifier does not represent a valid drive.
//
#define ERROR_INVALID_DRIVE_OBJECT 4321L

//
// MessageId: ERROR_LIBRARY_FULL
//
// MessageText:
//
// Library is full. No slot is available for use.
//
#define ERROR_LIBRARY_FULL 4322L

//
// MessageId: ERROR_MEDIUM_NOT_ACCESSIBLE
//
// MessageText:
//
// The transport cannot access the medium.
//
#define ERROR_MEDIUM_NOT_ACCESSIBLE 4323L

//
// MessageId: ERROR_UNABLE_TO_LOAD_MEDIUM
//
// MessageText:
//
// Unable to load the medium into the drive.
//
#define ERROR_UNABLE_TO_LOAD_MEDIUM 4324L

//
// MessageId: ERROR_UNABLE_TO_INVENTORY_DRIVE
//
// MessageText:
//
// Unable to retrieve the drive status.
//
#define ERROR_UNABLE_TO_INVENTORY_DRIVE 4325L

//
// MessageId: ERROR_UNABLE_TO_INVENTORY_SLOT
//
// MessageText:
//
// Unable to retrieve the slot status.
//
#define ERROR_UNABLE_TO_INVENTORY_SLOT 4326L

//
// MessageId: ERROR_UNABLE_TO_INVENTORY_TRANSPORT
//
// MessageText:
//
// Unable to retrieve status about the transport.
//
#define ERROR_UNABLE_TO_INVENTORY_TRANSPORT 4327L

//
// MessageId: ERROR_TRANSPORT_FULL
//
// MessageText:
//
// Cannot use the transport because it is already in use.
//
#define ERROR_TRANSPORT_FULL 4328L

//
// MessageId: ERROR_CONTROLLING_IEPORT
//
// MessageText:
//
// Unable to open or close the inject/eject port.
//
#define ERROR_CONTROLLING_IEPORT 4329L

//
// MessageId: ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA
//
// MessageText:
//
// Unable to eject the medium because it is in a drive.
//
#define ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA 4330L

//
// MessageId: ERROR_CLEANER_SLOT_SET
//
// MessageText:
//
// A cleaner slot is already reserved.
//
#define ERROR_CLEANER_SLOT_SET 4331L

//
// MessageId: ERROR_CLEANER_SLOT_NOT_SET
//
// MessageText:
//
// A cleaner slot is not reserved.
//
#define ERROR_CLEANER_SLOT_NOT_SET 4332L

//
// MessageId: ERROR_CLEANER_CARTRIDGE_SPENT
//
// MessageText:
//
// The cleaner cartridge has performed the maximum number of drive cleanings.
//
#define ERROR_CLEANER_CARTRIDGE_SPENT 4333L

//
// MessageId: ERROR_UNEXPECTED_OMID
//
// MessageText:
//
// Unexpected on-medium identifier.
//
#define ERROR_UNEXPECTED_OMID 4334L

//
// MessageId: ERROR_CANT_DELETE_LAST_ITEM
//
// MessageText:
//
// The last remaining item in this group or resource cannot be deleted.
//
#define ERROR_CANT_DELETE_LAST_ITEM 4335L

//
// MessageId: ERROR_MESSAGE_EXCEEDS_MAX_SIZE
//
// MessageText:
//
// The message provided exceeds the maximum size allowed for this parameter.
//
#define ERROR_MESSAGE_EXCEEDS_MAX_SIZE 4336L

//
// MessageId: ERROR_VOLUME_CONTAINS_SYS_FILES
//
// MessageText:
//
// The volume contains system or paging files.
//
#define ERROR_VOLUME_CONTAINS_SYS_FILES 4337L

//
// MessageId: ERROR_INDIGENOUS_TYPE
//
// MessageText:
//
// The media type cannot be removed from this library since at least one drive in the library reports it can support this media type.
//
#define ERROR_INDIGENOUS_TYPE 4338L

//
// MessageId: ERROR_NO_SUPPORTING_DRIVES
//
// MessageText:
//
// This offline media cannot be mounted on this system since no enabled drives are present which can be used.
//
#define ERROR_NO_SUPPORTING_DRIVES 4339L

//
// MessageId: ERROR_CLEANER_CARTRIDGE_INSTALLED
//
// MessageText:
//
// A cleaner cartridge is present in the tape library.
//
#define ERROR_CLEANER_CARTRIDGE_INSTALLED 4340L

//
// MessageId: ERROR_IEPORT_FULL
//
// MessageText:
//
// Cannot use the inject/eject port because it is not empty.
//
#define ERROR_IEPORT_FULL 4341L


///////////////////////////////////////////////////
//                                               //
//       Remote Storage Service Error codes      //
//                                               //
//                 4350 to 4389                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_FILE_OFFLINE
//
// MessageText:
//
// This file is currently not available for use on this computer.
//
#define ERROR_FILE_OFFLINE 4350L

//
// MessageId: ERROR_REMOTE_STORAGE_NOT_ACTIVE
//
// MessageText:
//
// The remote storage service is not operational at this time.
//
#define ERROR_REMOTE_STORAGE_NOT_ACTIVE 4351L

//
// MessageId: ERROR_REMOTE_STORAGE_MEDIA_ERROR
//
// MessageText:
//
// The remote storage service encountered a media error.
//
#define ERROR_REMOTE_STORAGE_MEDIA_ERROR 4352L


///////////////////////////////////////////////////
//                                               //
//           Reparse Point Error codes           //
//                                               //
//                 4390 to 4399                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_NOT_A_REPARSE_POINT
//
// MessageText:
//
// The file or directory is not a reparse point.
//
#define ERROR_NOT_A_REPARSE_POINT 4390L

//
// MessageId: ERROR_REPARSE_ATTRIBUTE_CONFLICT
//
// MessageText:
//
// The reparse point attribute cannot be set because it conflicts with an existing attribute.
//
#define ERROR_REPARSE_ATTRIBUTE_CONFLICT 4391L

//
// MessageId: ERROR_INVALID_REPARSE_DATA
//
// MessageText:
//
// The data present in the reparse point buffer is invalid.
//
#define ERROR_INVALID_REPARSE_DATA 4392L

//
// MessageId: ERROR_REPARSE_TAG_INVALID
//
// MessageText:
//
// The tag present in the reparse point buffer is invalid.
//
#define ERROR_REPARSE_TAG_INVALID 4393L

//
// MessageId: ERROR_REPARSE_TAG_MISMATCH
//
// MessageText:
//
// There is a mismatch between the tag specified in the request and the tag present in the reparse point.
// 
//
#define ERROR_REPARSE_TAG_MISMATCH 4394L


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4400 to 4499                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//    Single Instance Store (SIS) Error codes    //
//                                               //
//                 4500 to 4549                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_VOLUME_NOT_SIS_ENABLED
//
// MessageText:
//
// Single Instance Storage is not available on this volume.
//
#define ERROR_VOLUME_NOT_SIS_ENABLED 4500L

///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 4550 to 4599                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//             Cluster Error codes               //
//                                               //
//                 5000 to 5999                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_DEPENDENT_RESOURCE_EXISTS
//
// MessageText:
//
// The operation cannot be completed because other resources are dependent on this resource.
//
#define ERROR_DEPENDENT_RESOURCE_EXISTS 5001L

//
// MessageId: ERROR_DEPENDENCY_NOT_FOUND
//
// MessageText:
//
// The cluster resource dependency cannot be found.
//
#define ERROR_DEPENDENCY_NOT_FOUND 5002L

//
// MessageId: ERROR_DEPENDENCY_ALREADY_EXISTS
//
// MessageText:
//
// The cluster resource cannot be made dependent on the specified resource because it is already dependent.
//
#define ERROR_DEPENDENCY_ALREADY_EXISTS 5003L

//
// MessageId: ERROR_RESOURCE_NOT_ONLINE
//
// MessageText:
//
// The cluster resource is not online.
//
#define ERROR_RESOURCE_NOT_ONLINE 5004L

//
// MessageId: ERROR_HOST_NODE_NOT_AVAILABLE
//
// MessageText:
//
// A cluster node is not available for this operation.
//
#define ERROR_HOST_NODE_NOT_AVAILABLE 5005L

//
// MessageId: ERROR_RESOURCE_NOT_AVAILABLE
//
// MessageText:
//
// The cluster resource is not available.
//
#define ERROR_RESOURCE_NOT_AVAILABLE 5006L

//
// MessageId: ERROR_RESOURCE_NOT_FOUND
//
// MessageText:
//
// The cluster resource could not be found.
//
#define ERROR_RESOURCE_NOT_FOUND 5007L

//
// MessageId: ERROR_SHUTDOWN_CLUSTER
//
// MessageText:
//
// The cluster is being shut down.
//
#define ERROR_SHUTDOWN_CLUSTER 5008L

//
// MessageId: ERROR_CANT_EVICT_ACTIVE_NODE
//
// MessageText:
//
// A cluster node cannot be evicted from the cluster unless the node is down or it is the last node.
//
#define ERROR_CANT_EVICT_ACTIVE_NODE 5009L

//
// MessageId: ERROR_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
// The object already exists.
//
#define ERROR_OBJECT_ALREADY_EXISTS 5010L

//
// MessageId: ERROR_OBJECT_IN_LIST
//
// MessageText:
//
// The object is already in the list.
//
#define ERROR_OBJECT_IN_LIST 5011L

//
// MessageId: ERROR_GROUP_NOT_AVAILABLE
//
// MessageText:
//
// The cluster group is not available for any new requests.
//
#define ERROR_GROUP_NOT_AVAILABLE 5012L

//
// MessageId: ERROR_GROUP_NOT_FOUND
//
// MessageText:
//
// The cluster group could not be found.
//
#define ERROR_GROUP_NOT_FOUND 5013L

//
// MessageId: ERROR_GROUP_NOT_ONLINE
//
// MessageText:
//
// The operation could not be completed because the cluster group is not online.
//
#define ERROR_GROUP_NOT_ONLINE 5014L

//
// MessageId: ERROR_HOST_NODE_NOT_RESOURCE_OWNER
//
// MessageText:
//
// The operation failed because either the specified cluster node is not the owner of the resource, or the node is not a possible owner of the resource.
//
#define ERROR_HOST_NODE_NOT_RESOURCE_OWNER 5015L

//
// MessageId: ERROR_HOST_NODE_NOT_GROUP_OWNER
//
// MessageText:
//
// The operation failed because either the specified cluster node is not the owner of the group, or the node is not a possible owner of the group.
//
#define ERROR_HOST_NODE_NOT_GROUP_OWNER 5016L

//
// MessageId: ERROR_RESMON_CREATE_FAILED
//
// MessageText:
//
// The cluster resource could not be created in the specified resource monitor.
//
#define ERROR_RESMON_CREATE_FAILED 5017L

//
// MessageId: ERROR_RESMON_ONLINE_FAILED
//
// MessageText:
//
// The cluster resource could not be brought online by the resource monitor.
//
#define ERROR_RESMON_ONLINE_FAILED 5018L

//
// MessageId: ERROR_RESOURCE_ONLINE
//
// MessageText:
//
// The operation could not be completed because the cluster resource is online.
//
#define ERROR_RESOURCE_ONLINE 5019L

//
// MessageId: ERROR_QUORUM_RESOURCE
//
// MessageText:
//
// The cluster resource could not be deleted or brought offline because it is the quorum resource.
//
#define ERROR_QUORUM_RESOURCE 5020L

//
// MessageId: ERROR_NOT_QUORUM_CAPABLE
//
// MessageText:
//
// The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.
//
#define ERROR_NOT_QUORUM_CAPABLE 5021L

//
// MessageId: ERROR_CLUSTER_SHUTTING_DOWN
//
// MessageText:
//
// The cluster software is shutting down.
//
#define ERROR_CLUSTER_SHUTTING_DOWN 5022L

//
// MessageId: ERROR_INVALID_STATE
//
// MessageText:
//
// The group or resource is not in the correct state to perform the requested operation.
//
#define ERROR_INVALID_STATE 5023L

//
// MessageId: ERROR_RESOURCE_PROPERTIES_STORED
//
// MessageText:
//
// The properties were stored but not all changes will take effect until the next time the resource is brought online.
//
#define ERROR_RESOURCE_PROPERTIES_STORED 5024L

//
// MessageId: ERROR_NOT_QUORUM_CLASS
//
// MessageText:
//
// The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.
//
#define ERROR_NOT_QUORUM_CLASS 5025L

//
// MessageId: ERROR_CORE_RESOURCE
//
// MessageText:
//
// The cluster resource could not be deleted since it is a core resource.
//
#define ERROR_CORE_RESOURCE 5026L

//
// MessageId: ERROR_QUORUM_RESOURCE_ONLINE_FAILED
//
// MessageText:
//
// The quorum resource failed to come online.
//
#define ERROR_QUORUM_RESOURCE_ONLINE_FAILED 5027L

//
// MessageId: ERROR_QUORUMLOG_OPEN_FAILED
//
// MessageText:
//
// The quorum log could not be created or mounted successfully.
//
#define ERROR_QUORUMLOG_OPEN_FAILED 5028L

//
// MessageId: ERROR_CLUSTERLOG_CORRUPT
//
// MessageText:
//
// The cluster log is corrupt.
//
#define ERROR_CLUSTERLOG_CORRUPT 5029L

//
// MessageId: ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
//
// MessageText:
//
// The record could not be written to the cluster log since it exceeds the maximum size.
//
#define ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE 5030L

//
// MessageId: ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
//
// MessageText:
//
// The cluster log exceeds its maximum size.
//
#define ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE 5031L

//
// MessageId: ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
//
// MessageText:
//
// No checkpoint record was found in the cluster log.
//
#define ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND 5032L

//
// MessageId: ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
//
// MessageText:
//
// The minimum required disk space needed for logging is not available.
//
#define ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE 5033L

//
// MessageId: ERROR_QUORUM_OWNER_ALIVE
//
// MessageText:
//
// The cluster node failed to take control of the quorum resource because the resource is owned by another active node.
//
#define ERROR_QUORUM_OWNER_ALIVE 5034L

//
// MessageId: ERROR_NETWORK_NOT_AVAILABLE
//
// MessageText:
//
// A cluster network is not available for this operation.
//
#define ERROR_NETWORK_NOT_AVAILABLE 5035L

//
// MessageId: ERROR_NODE_NOT_AVAILABLE
//
// MessageText:
//
// A cluster node is not available for this operation.
//
#define ERROR_NODE_NOT_AVAILABLE 5036L

//
// MessageId: ERROR_ALL_NODES_NOT_AVAILABLE
//
// MessageText:
//
// All cluster nodes must be running to perform this operation.
//
#define ERROR_ALL_NODES_NOT_AVAILABLE 5037L

//
// MessageId: ERROR_RESOURCE_FAILED
//
// MessageText:
//
// A cluster resource failed.
//
#define ERROR_RESOURCE_FAILED 5038L

//
// MessageId: ERROR_CLUSTER_INVALID_NODE
//
// MessageText:
//
// The cluster node is not valid.
//
#define ERROR_CLUSTER_INVALID_NODE 5039L

//
// MessageId: ERROR_CLUSTER_NODE_EXISTS
//
// MessageText:
//
// The cluster node already exists.
//
#define ERROR_CLUSTER_NODE_EXISTS 5040L

//
// MessageId: ERROR_CLUSTER_JOIN_IN_PROGRESS
//
// MessageText:
//
// A node is in the process of joining the cluster.
//
#define ERROR_CLUSTER_JOIN_IN_PROGRESS 5041L

//
// MessageId: ERROR_CLUSTER_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster node was not found.
//
#define ERROR_CLUSTER_NODE_NOT_FOUND 5042L

//
// MessageId: ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster local node information was not found.
//
#define ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND 5043L

//
// MessageId: ERROR_CLUSTER_NETWORK_EXISTS
//
// MessageText:
//
// The cluster network already exists.
//
#define ERROR_CLUSTER_NETWORK_EXISTS 5044L

//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_FOUND
//
// MessageText:
//
// The cluster network was not found.
//
#define ERROR_CLUSTER_NETWORK_NOT_FOUND 5045L

//
// MessageId: ERROR_CLUSTER_NETINTERFACE_EXISTS
//
// MessageText:
//
// The cluster network interface already exists.
//
#define ERROR_CLUSTER_NETINTERFACE_EXISTS 5046L

//
// MessageId: ERROR_CLUSTER_NETINTERFACE_NOT_FOUND
//
// MessageText:
//
// The cluster network interface was not found.
//
#define ERROR_CLUSTER_NETINTERFACE_NOT_FOUND 5047L

//
// MessageId: ERROR_CLUSTER_INVALID_REQUEST
//
// MessageText:
//
// The cluster request is not valid for this object.
//
#define ERROR_CLUSTER_INVALID_REQUEST 5048L

//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK_PROVIDER
//
// MessageText:
//
// The cluster network provider is not valid.
//
#define ERROR_CLUSTER_INVALID_NETWORK_PROVIDER 5049L

//
// MessageId: ERROR_CLUSTER_NODE_DOWN
//
// MessageText:
//
// The cluster node is down.
//
#define ERROR_CLUSTER_NODE_DOWN 5050L

//
// MessageId: ERROR_CLUSTER_NODE_UNREACHABLE
//
// MessageText:
//
// The cluster node is not reachable.
//
#define ERROR_CLUSTER_NODE_UNREACHABLE 5051L

//
// MessageId: ERROR_CLUSTER_NODE_NOT_MEMBER
//
// MessageText:
//
// The cluster node is not a member of the cluster.
//
#define ERROR_CLUSTER_NODE_NOT_MEMBER 5052L

//
// MessageId: ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS
//
// MessageText:
//
// A cluster join operation is not in progress.
//
#define ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS 5053L

//
// MessageId: ERROR_CLUSTER_INVALID_NETWORK
//
// MessageText:
//
// The cluster network is not valid.
//
#define ERROR_CLUSTER_INVALID_NETWORK 5054L

//
// MessageId: ERROR_CLUSTER_NODE_UP
//
// MessageText:
//
// The cluster node is up.
//
#define ERROR_CLUSTER_NODE_UP 5056L

//
// MessageId: ERROR_CLUSTER_IPADDR_IN_USE
//
// MessageText:
//
// The cluster IP address is already in use.
//
#define ERROR_CLUSTER_IPADDR_IN_USE 5057L

//
// MessageId: ERROR_CLUSTER_NODE_NOT_PAUSED
//
// MessageText:
//
// The cluster node is not paused.
//
#define ERROR_CLUSTER_NODE_NOT_PAUSED 5058L

//
// MessageId: ERROR_CLUSTER_NO_SECURITY_CONTEXT
//
// MessageText:
//
// No cluster security context is available.
//
#define ERROR_CLUSTER_NO_SECURITY_CONTEXT 5059L

//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_INTERNAL
//
// MessageText:
//
// The cluster network is not configured for internal cluster communication.
//
#define ERROR_CLUSTER_NETWORK_NOT_INTERNAL 5060L

//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_UP
//
// MessageText:
//
// The cluster node is already up.
//
#define ERROR_CLUSTER_NODE_ALREADY_UP 5061L

//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_DOWN
//
// MessageText:
//
// The cluster node is already down.
//
#define ERROR_CLUSTER_NODE_ALREADY_DOWN 5062L

//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_ONLINE
//
// MessageText:
//
// The cluster network is already online.
//
#define ERROR_CLUSTER_NETWORK_ALREADY_ONLINE 5063L

//
// MessageId: ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE
//
// MessageText:
//
// The cluster network is already offline.
//
#define ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE 5064L

//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_MEMBER
//
// MessageText:
//
// The cluster node is already a member of the cluster.
//
#define ERROR_CLUSTER_NODE_ALREADY_MEMBER 5065L

//
// MessageId: ERROR_CLUSTER_LAST_INTERNAL_NETWORK
//
// MessageText:
//
// The cluster network is the only one configured for internal cluster communication between two or more active cluster nodes. The internal communication capability cannot be removed from the network.
//
#define ERROR_CLUSTER_LAST_INTERNAL_NETWORK 5066L

//
// MessageId: ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS
//
// MessageText:
//
// One or more cluster resources depend on the network to provide service to clients. The client access capability cannot be removed from the network.
//
#define ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS 5067L

//
// MessageId: ERROR_INVALID_OPERATION_ON_QUORUM
//
// MessageText:
//
// This operation cannot be performed on the cluster resource as it the quorum resource. You may not bring the quorum resource offline or modify its possible owners list.
//
#define ERROR_INVALID_OPERATION_ON_QUORUM 5068L

//
// MessageId: ERROR_DEPENDENCY_NOT_ALLOWED
//
// MessageText:
//
// The cluster quorum resource is not allowed to have any dependencies.
//
#define ERROR_DEPENDENCY_NOT_ALLOWED 5069L

//
// MessageId: ERROR_CLUSTER_NODE_PAUSED
//
// MessageText:
//
// The cluster node is paused.
//
#define ERROR_CLUSTER_NODE_PAUSED 5070L

//
// MessageId: ERROR_NODE_CANT_HOST_RESOURCE
//
// MessageText:
//
// The cluster resource cannot be brought online. The owner node cannot run this resource.
//
#define ERROR_NODE_CANT_HOST_RESOURCE 5071L

//
// MessageId: ERROR_CLUSTER_NODE_NOT_READY
//
// MessageText:
//
// The cluster node is not ready to perform the requested operation.
//
#define ERROR_CLUSTER_NODE_NOT_READY 5072L

//
// MessageId: ERROR_CLUSTER_NODE_SHUTTING_DOWN
//
// MessageText:
//
// The cluster node is shutting down.
//
#define ERROR_CLUSTER_NODE_SHUTTING_DOWN 5073L

//
// MessageId: ERROR_CLUSTER_JOIN_ABORTED
//
// MessageText:
//
// The cluster join operation was aborted.
//
#define ERROR_CLUSTER_JOIN_ABORTED 5074L

//
// MessageId: ERROR_CLUSTER_INCOMPATIBLE_VERSIONS
//
// MessageText:
//
// The cluster join operation failed due to incompatible software versions between the joining node and its sponsor.
//
#define ERROR_CLUSTER_INCOMPATIBLE_VERSIONS 5075L

//
// MessageId: ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED
//
// MessageText:
//
// This resource cannot be created because the cluster has reached the limit on the number of resources it can monitor.
//
#define ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED 5076L

//
// MessageId: ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED
//
// MessageText:
//
// The system configuration changed during the cluster join or form operation. The join or form operation was aborted.
//
#define ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED 5077L

//
// MessageId: ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
// The specified resource type was not found.
//
#define ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND 5078L

//
// MessageId: ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED
//
// MessageText:
//
// The specified node does not support a resource of this type. This may be due to version inconsistencies or due to the absence of the resource DLL on this node.
//
#define ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED 5079L

//
// MessageId: ERROR_CLUSTER_RESNAME_NOT_FOUND
//
// MessageText:
//
// The specified resource name is not supported by this resource DLL. This may be due to a bad (or changed) name supplied to the resource DLL.
//
#define ERROR_CLUSTER_RESNAME_NOT_FOUND 5080L

//
// MessageId: ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED
//
// MessageText:
//
// No authentication package could be registered with the RPC server.
//
#define ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED 5081L

//
// MessageId: ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST
//
// MessageText:
//
// You cannot bring the group online because the owner of the group is not in the preferred list for the group. To change the owner node for the group, move the group.
//
#define ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST 5082L

//
// MessageId: ERROR_CLUSTER_DATABASE_SEQMISMATCH
//
// MessageText:
//
// The join operation failed because the cluster database sequence number has changed or is incompatible with the locker node. This may happen during a join operation if the cluster database was changing during the join.
//
#define ERROR_CLUSTER_DATABASE_SEQMISMATCH 5083L

//
// MessageId: ERROR_RESMON_INVALID_STATE
//
// MessageText:
//
// The resource monitor will not allow the fail operation to be performed while the resource is in its current state. This may happen if the resource is in a pending state.
//
#define ERROR_RESMON_INVALID_STATE 5084L

//
// MessageId: ERROR_CLUSTER_GUM_NOT_LOCKER
//
// MessageText:
//
// A non locker code got a request to reserve the lock for making global updates.
//
#define ERROR_CLUSTER_GUM_NOT_LOCKER 5085L

//
// MessageId: ERROR_QUORUM_DISK_NOT_FOUND
//
// MessageText:
//
// The quorum disk could not be located by the cluster service.
//
#define ERROR_QUORUM_DISK_NOT_FOUND 5086L

//
// MessageId: ERROR_DATABASE_BACKUP_CORRUPT
//
// MessageText:
//
// The backed up cluster database is possibly corrupt.
//
#define ERROR_DATABASE_BACKUP_CORRUPT 5087L

//
// MessageId: ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT
//
// MessageText:
//
// A DFS root already exists in this cluster node.
//
#define ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT 5088L

//
// MessageId: ERROR_RESOURCE_PROPERTY_UNCHANGEABLE
//
// MessageText:
//
// An attempt to modify a resource property failed because it conflicts with another existing property.
//
#define ERROR_RESOURCE_PROPERTY_UNCHANGEABLE 5089L

/*

 Codes from 4300 through 5889 overlap with codes in ds\published\inc\apperr2.w.

 Do not add any more error codes in that range.

*/
# 12363 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
// MessageId: ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE
//
// MessageText:
//
// An operation was attempted that is incompatible with the current membership state of the node.
//
#define ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE 5890L

//
// MessageId: ERROR_CLUSTER_QUORUMLOG_NOT_FOUND
//
// MessageText:
//
// The quorum resource does not contain the quorum log.
//
#define ERROR_CLUSTER_QUORUMLOG_NOT_FOUND 5891L

//
// MessageId: ERROR_CLUSTER_MEMBERSHIP_HALT
//
// MessageText:
//
// The membership engine requested shutdown of the cluster service on this node.
//
#define ERROR_CLUSTER_MEMBERSHIP_HALT 5892L

//
// MessageId: ERROR_CLUSTER_INSTANCE_ID_MISMATCH
//
// MessageText:
//
// The join operation failed because the cluster instance ID of the joining node does not match the cluster instance ID of the sponsor node.
//
#define ERROR_CLUSTER_INSTANCE_ID_MISMATCH 5893L

//
// MessageId: ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP
//
// MessageText:
//
// A matching cluster network for the specified IP address could not be found.
//
#define ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP 5894L

//
// MessageId: ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH
//
// MessageText:
//
// The actual data type of the property did not match the expected data type of the property.
//
#define ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH 5895L

//
// MessageId: ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP
//
// MessageText:
//
// The cluster node was evicted from the cluster successfully, but the node was not cleaned up. To determine what cleanup steps failed and how to recover, see the Failover Clustering application event log using Event Viewer.
//
#define ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP 5896L

//
// MessageId: ERROR_CLUSTER_PARAMETER_MISMATCH
//
// MessageText:
//
// Two or more parameter values specified for a resource's properties are in conflict.
//
#define ERROR_CLUSTER_PARAMETER_MISMATCH 5897L

//
// MessageId: ERROR_NODE_CANNOT_BE_CLUSTERED
//
// MessageText:
//
// This computer cannot be made a member of a cluster.
//
#define ERROR_NODE_CANNOT_BE_CLUSTERED 5898L

//
// MessageId: ERROR_CLUSTER_WRONG_OS_VERSION
//
// MessageText:
//
// This computer cannot be made a member of a cluster because it does not have the correct version of Windows installed.
//
#define ERROR_CLUSTER_WRONG_OS_VERSION 5899L

//
// MessageId: ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME
//
// MessageText:
//
// A cluster cannot be created with the specified cluster name because that cluster name is already in use. Specify a different name for the cluster.
//
#define ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME 5900L

//
// MessageId: ERROR_CLUSCFG_ALREADY_COMMITTED
//
// MessageText:
//
// The cluster configuration action has already been committed.
//
#define ERROR_CLUSCFG_ALREADY_COMMITTED 5901L

//
// MessageId: ERROR_CLUSCFG_ROLLBACK_FAILED
//
// MessageText:
//
// The cluster configuration action could not be rolled back.
//
#define ERROR_CLUSCFG_ROLLBACK_FAILED 5902L

//
// MessageId: ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT
//
// MessageText:
//
// The drive letter assigned to a system disk on one node conflicted with the drive letter assigned to a disk on another node.
//
#define ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT 5903L

//
// MessageId: ERROR_CLUSTER_OLD_VERSION
//
// MessageText:
//
// One or more nodes in the cluster are running a version of Windows that does not support this operation.
//
#define ERROR_CLUSTER_OLD_VERSION 5904L

//
// MessageId: ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME
//
// MessageText:
//
// The name of the corresponding computer account doesn't match the Network Name for this resource.
//
#define ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME 5905L

//
// MessageId: ERROR_CLUSTER_NO_NET_ADAPTERS
//
// MessageText:
//
// No network adapters are available.
//
#define ERROR_CLUSTER_NO_NET_ADAPTERS 5906L

//
// MessageId: ERROR_CLUSTER_POISONED
//
// MessageText:
//
// The cluster node has been poisoned.
//
#define ERROR_CLUSTER_POISONED 5907L

//
// MessageId: ERROR_CLUSTER_GROUP_MOVING
//
// MessageText:
//
// The group is unable to accept the request since it is moving to another node.
//
#define ERROR_CLUSTER_GROUP_MOVING 5908L

//
// MessageId: ERROR_CLUSTER_RESOURCE_TYPE_BUSY
//
// MessageText:
//
// The resource type cannot accept the request since is too busy performing another operation.
//
#define ERROR_CLUSTER_RESOURCE_TYPE_BUSY 5909L

//
// MessageId: ERROR_RESOURCE_CALL_TIMED_OUT
//
// MessageText:
//
// The call to the cluster resource DLL timed out.
//
#define ERROR_RESOURCE_CALL_TIMED_OUT 5910L

//
// MessageId: ERROR_INVALID_CLUSTER_IPV6_ADDRESS
//
// MessageText:
//
// The address is not valid for an IPv6 Address resource. A global IPv6 address is required, and it must match a cluster network. Compatibility addresses are not permitted.
//
#define ERROR_INVALID_CLUSTER_IPV6_ADDRESS 5911L

//
// MessageId: ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION
//
// MessageText:
//
// An internal cluster error occurred. A call to an invalid function was attempted.
//
#define ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION 5912L

//
// MessageId: ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS
//
// MessageText:
//
// A parameter value is out of acceptable range.
//
#define ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS 5913L

//
// MessageId: ERROR_CLUSTER_PARTIAL_SEND
//
// MessageText:
//
// A network error occurred while sending data to another node in the cluster. The number of bytes transmitted was less than required.
//
#define ERROR_CLUSTER_PARTIAL_SEND 5914L

//
// MessageId: ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION
//
// MessageText:
//
// An invalid cluster registry operation was attempted.
//
#define ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION 5915L

//
// MessageId: ERROR_CLUSTER_INVALID_STRING_TERMINATION
//
// MessageText:
//
// An input string of characters is not properly terminated.
//
#define ERROR_CLUSTER_INVALID_STRING_TERMINATION 5916L

//
// MessageId: ERROR_CLUSTER_INVALID_STRING_FORMAT
//
// MessageText:
//
// An input string of characters is not in a valid format for the data it represents.
//
#define ERROR_CLUSTER_INVALID_STRING_FORMAT 5917L

//
// MessageId: ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// An internal cluster error occurred. A cluster database transaction was attempted while a transaction was already in progress.
//
#define ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS 5918L

//
// MessageId: ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS
//
// MessageText:
//
// An internal cluster error occurred. There was an attempt to commit a cluster database transaction while no transaction was in progress.
//
#define ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS 5919L

//
// MessageId: ERROR_CLUSTER_NULL_DATA
//
// MessageText:
//
// An internal cluster error occurred. Data was not properly initialized.
//
#define ERROR_CLUSTER_NULL_DATA 5920L

//
// MessageId: ERROR_CLUSTER_PARTIAL_READ
//
// MessageText:
//
// An error occurred while reading from a stream of data. An unexpected number of bytes was returned.
//
#define ERROR_CLUSTER_PARTIAL_READ 5921L

//
// MessageId: ERROR_CLUSTER_PARTIAL_WRITE
//
// MessageText:
//
// An error occurred while writing to a stream of data. The required number of bytes could not be written.
//
#define ERROR_CLUSTER_PARTIAL_WRITE 5922L

//
// MessageId: ERROR_CLUSTER_CANT_DESERIALIZE_DATA
//
// MessageText:
//
// An error occurred while deserializing a stream of cluster data.
//
#define ERROR_CLUSTER_CANT_DESERIALIZE_DATA 5923L

//
// MessageId: ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT
//
// MessageText:
//
// One or more property values for this resource are in conflict with one or more property values associated with its dependent resource(s).
//
#define ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT 5924L

//
// MessageId: ERROR_CLUSTER_NO_QUORUM
//
// MessageText:
//
// A quorum of cluster nodes was not present to form a cluster.
//
#define ERROR_CLUSTER_NO_QUORUM 5925L

//
// MessageId: ERROR_CLUSTER_INVALID_IPV6_NETWORK
//
// MessageText:
//
// The cluster network is not valid for an IPv6 Address resource, or it does not match the configured address.
//
#define ERROR_CLUSTER_INVALID_IPV6_NETWORK 5926L

//
// MessageId: ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK
//
// MessageText:
//
// The cluster network is not valid for an IPv6 Tunnel resource. Check the configuration of the IP Address resource on which the IPv6 Tunnel resource depends.
//
#define ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK 5927L

//
// MessageId: ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP
//
// MessageText:
//
// Quorum resource cannot reside in the Available Storage group.
//
#define ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP 5928L

//
// MessageId: ERROR_DEPENDENCY_TREE_TOO_COMPLEX
//
// MessageText:
//
// The dependencies for this resource are nested too deeply.
//
#define ERROR_DEPENDENCY_TREE_TOO_COMPLEX 5929L

//
// MessageId: ERROR_EXCEPTION_IN_RESOURCE_CALL
//
// MessageText:
//
// The call into the resource DLL raised an unhandled exception.
//
#define ERROR_EXCEPTION_IN_RESOURCE_CALL 5930L

//
// MessageId: ERROR_CLUSTER_RHS_FAILED_INITIALIZATION
//
// MessageText:
//
// The RHS process failed to initialize.
//
#define ERROR_CLUSTER_RHS_FAILED_INITIALIZATION 5931L

//
// MessageId: ERROR_CLUSTER_NOT_INSTALLED
//
// MessageText:
//
// The Failover Clustering feature is not installed on this node.
//
#define ERROR_CLUSTER_NOT_INSTALLED 5932L

//
// MessageId: ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE
//
// MessageText:
//
// The resources must be online on the same node for this operation
//
#define ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE 5933L

//
// MessageId: ERROR_CLUSTER_MAX_NODES_IN_CLUSTER
//
// MessageText:
//
// A new node can not be added since this cluster is already at its maximum number of nodes.
//
#define ERROR_CLUSTER_MAX_NODES_IN_CLUSTER 5934L

//
// MessageId: ERROR_CLUSTER_TOO_MANY_NODES
//
// MessageText:
//
// This cluster can not be created since the specified number of nodes exceeds the maximum allowed limit.
//
#define ERROR_CLUSTER_TOO_MANY_NODES 5935L

//
// MessageId: ERROR_CLUSTER_OBJECT_ALREADY_USED
//
// MessageText:
//
// An attempt to use the specified cluster name failed because an enabled computer object with the given name already exists in the domain.
//
#define ERROR_CLUSTER_OBJECT_ALREADY_USED 5936L

//
// MessageId: ERROR_NONCORE_GROUPS_FOUND
//
// MessageText:
//
// This cluster cannot be destroyed. It has non-core application groups which must be deleted before the cluster can be destroyed.
//
#define ERROR_NONCORE_GROUPS_FOUND 5937L

//
// MessageId: ERROR_FILE_SHARE_RESOURCE_CONFLICT
//
// MessageText:
//
// File share associated with file share witness resource cannot be hosted by this cluster or any of its nodes.
//
#define ERROR_FILE_SHARE_RESOURCE_CONFLICT 5938L

//
// MessageId: ERROR_CLUSTER_EVICT_INVALID_REQUEST
//
// MessageText:
//
// Eviction of this node is invalid at this time. Due to quorum requirements node eviction will result in cluster shutdown.
// If it is the last node in the cluster, destroy cluster command should be used.
//
#define ERROR_CLUSTER_EVICT_INVALID_REQUEST 5939L

//
// MessageId: ERROR_CLUSTER_SINGLETON_RESOURCE
//
// MessageText:
//
// Only one instance of this resource type is allowed in the cluster.
//
#define ERROR_CLUSTER_SINGLETON_RESOURCE 5940L

//
// MessageId: ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE
//
// MessageText:
//
// Only one instance of this resource type is allowed per resource group.
//
#define ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE 5941L

//
// MessageId: ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED
//
// MessageText:
//
// The resource failed to come online due to the failure of one or more provider resources.
//
#define ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED 5942L

//
// MessageId: ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR
//
// MessageText:
//
// The resource has indicated that it cannot come online on any node.
//
#define ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR 5943L

//
// MessageId: ERROR_CLUSTER_GROUP_BUSY
//
// MessageText:
//
// The current operation cannot be performed on this group at this time.
//
#define ERROR_CLUSTER_GROUP_BUSY 5944L

//
// MessageId: ERROR_CLUSTER_NOT_SHARED_VOLUME
//
// MessageText:
//
// The directory or file is not located on a cluster shared volume.
//
#define ERROR_CLUSTER_NOT_SHARED_VOLUME 5945L

//
// MessageId: ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR
//
// MessageText:
//
// The Security Descriptor does not meet the requirements for a cluster.
//
#define ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR 5946L

//
// MessageId: ERROR_CLUSTER_SHARED_VOLUMES_IN_USE
//
// MessageText:
//
// There is one or more shared volumes resources configured in the cluster.
// Those resources must be moved to available storage in order for operation to succeed.
//
#define ERROR_CLUSTER_SHARED_VOLUMES_IN_USE 5947L

//
// MessageId: ERROR_CLUSTER_USE_SHARED_VOLUMES_API
//
// MessageText:
//
// This group or resource cannot be directly manipulated.
// Use shared volume APIs to perform desired operation.
//
#define ERROR_CLUSTER_USE_SHARED_VOLUMES_API 5948L

//
// MessageId: ERROR_CLUSTER_BACKUP_IN_PROGRESS
//
// MessageText:
//
// Back up is in progress. Please wait for backup completion before trying this operation again.
//
#define ERROR_CLUSTER_BACKUP_IN_PROGRESS 5949L

//
// MessageId: ERROR_NON_CSV_PATH
//
// MessageText:
//
// The path does not belong to a cluster shared volume.
//
#define ERROR_NON_CSV_PATH 5950L

//
// MessageId: ERROR_CSV_VOLUME_NOT_LOCAL
//
// MessageText:
//
// The cluster shared volume is not locally mounted on this node.
//
#define ERROR_CSV_VOLUME_NOT_LOCAL 5951L

//
// MessageId: ERROR_CLUSTER_WATCHDOG_TERMINATING
//
// MessageText:
//
// The cluster watchdog is terminating.
//
#define ERROR_CLUSTER_WATCHDOG_TERMINATING 5952L


///////////////////////////////////////////////////
//                                               //
//               EFS Error codes                 //
//                                               //
//                 6000 to 6099                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_ENCRYPTION_FAILED
//
// MessageText:
//
// The specified file could not be encrypted.
//
#define ERROR_ENCRYPTION_FAILED 6000L

//
// MessageId: ERROR_DECRYPTION_FAILED
//
// MessageText:
//
// The specified file could not be decrypted.
//
#define ERROR_DECRYPTION_FAILED 6001L

//
// MessageId: ERROR_FILE_ENCRYPTED
//
// MessageText:
//
// The specified file is encrypted and the user does not have the ability to decrypt it.
//
#define ERROR_FILE_ENCRYPTED 6002L

//
// MessageId: ERROR_NO_RECOVERY_POLICY
//
// MessageText:
//
// There is no valid encryption recovery policy configured for this system.
//
#define ERROR_NO_RECOVERY_POLICY 6003L

//
// MessageId: ERROR_NO_EFS
//
// MessageText:
//
// The required encryption driver is not loaded for this system.
//
#define ERROR_NO_EFS 6004L

//
// MessageId: ERROR_WRONG_EFS
//
// MessageText:
//
// The file was encrypted with a different encryption driver than is currently loaded.
//
#define ERROR_WRONG_EFS 6005L

//
// MessageId: ERROR_NO_USER_KEYS
//
// MessageText:
//
// There are no EFS keys defined for the user.
//
#define ERROR_NO_USER_KEYS 6006L

//
// MessageId: ERROR_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// The specified file is not encrypted.
//
#define ERROR_FILE_NOT_ENCRYPTED 6007L

//
// MessageId: ERROR_NOT_EXPORT_FORMAT
//
// MessageText:
//
// The specified file is not in the defined EFS export format.
//
#define ERROR_NOT_EXPORT_FORMAT 6008L

//
// MessageId: ERROR_FILE_READ_ONLY
//
// MessageText:
//
// The specified file is read only.
//
#define ERROR_FILE_READ_ONLY 6009L

//
// MessageId: ERROR_DIR_EFS_DISALLOWED
//
// MessageText:
//
// The directory has been disabled for encryption.
//
#define ERROR_DIR_EFS_DISALLOWED 6010L

//
// MessageId: ERROR_EFS_SERVER_NOT_TRUSTED
//
// MessageText:
//
// The server is not trusted for remote encryption operation.
//
#define ERROR_EFS_SERVER_NOT_TRUSTED 6011L

//
// MessageId: ERROR_BAD_RECOVERY_POLICY
//
// MessageText:
//
// Recovery policy configured for this system contains invalid recovery certificate.
//
#define ERROR_BAD_RECOVERY_POLICY 6012L

//
// MessageId: ERROR_EFS_ALG_BLOB_TOO_BIG
//
// MessageText:
//
// The encryption algorithm used on the source file needs a bigger key buffer than the one on the destination file.
//
#define ERROR_EFS_ALG_BLOB_TOO_BIG 6013L

//
// MessageId: ERROR_VOLUME_NOT_SUPPORT_EFS
//
// MessageText:
//
// The disk partition does not support file encryption.
//
#define ERROR_VOLUME_NOT_SUPPORT_EFS 6014L

//
// MessageId: ERROR_EFS_DISABLED
//
// MessageText:
//
// This machine is disabled for file encryption.
//
#define ERROR_EFS_DISABLED 6015L

//
// MessageId: ERROR_EFS_VERSION_NOT_SUPPORT
//
// MessageText:
//
// A newer system is required to decrypt this encrypted file.
//
#define ERROR_EFS_VERSION_NOT_SUPPORT 6016L

//
// MessageId: ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The remote server sent an invalid response for a file being opened with Client Side Encryption.
//
#define ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE 6017L

//
// MessageId: ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER
//
// MessageText:
//
// Client Side Encryption is not supported by the remote server even though it claims to support it.
//
#define ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER 6018L

//
// MessageId: ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE
//
// MessageText:
//
// File is encrypted and should be opened in Client Side Encryption mode.
//
#define ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE 6019L

//
// MessageId: ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE
//
// MessageText:
//
// A new encrypted file is being created and a $EFS needs to be provided.
//
#define ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE 6020L

//
// MessageId: ERROR_CS_ENCRYPTION_FILE_NOT_CSE
//
// MessageText:
//
// The SMB client requested a CSE FSCTL on a non-CSE file.
//
#define ERROR_CS_ENCRYPTION_FILE_NOT_CSE 6021L

//
// MessageId: ERROR_ENCRYPTION_POLICY_DENIES_OPERATION
//
// MessageText:
//
// The requested operation was blocked by policy. For more information, contact your system administrator.
//
#define ERROR_ENCRYPTION_POLICY_DENIES_OPERATION 6022L


///////////////////////////////////////////////////
//                                               //
//              BROWSER Error codes              //
//                                               //
//                 6100 to 6199                  //
///////////////////////////////////////////////////

// This message number is for historical purposes and cannot be changed or re-used.
//
// MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
// The list of servers for this workgroup is not currently available
//
#define ERROR_NO_BROWSER_SERVERS_FOUND 6118L


///////////////////////////////////////////////////
//                                               //
//            Task Scheduler Error codes         //
//            NET START must understand          //
//                                               //
//                 6200 to 6249                  //
///////////////////////////////////////////////////

//
// MessageId: SCHED_E_SERVICE_NOT_LOCALSYSTEM
//
// MessageText:
//
// The Task Scheduler service must be configured to run in the System account to function properly. Individual tasks may be configured to run in other accounts.
//
#define SCHED_E_SERVICE_NOT_LOCALSYSTEM 6200L


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 6250 to 6599                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//         Common Log (CLFS) Error codes         //
//                                               //
//                 6600 to 6699                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_LOG_SECTOR_INVALID
//
// MessageText:
//
// Log service encountered an invalid log sector.
//
#define ERROR_LOG_SECTOR_INVALID 6600L

//
// MessageId: ERROR_LOG_SECTOR_PARITY_INVALID
//
// MessageText:
//
// Log service encountered a log sector with invalid block parity.
//
#define ERROR_LOG_SECTOR_PARITY_INVALID 6601L

//
// MessageId: ERROR_LOG_SECTOR_REMAPPED
//
// MessageText:
//
// Log service encountered a remapped log sector.
//
#define ERROR_LOG_SECTOR_REMAPPED 6602L

//
// MessageId: ERROR_LOG_BLOCK_INCOMPLETE
//
// MessageText:
//
// Log service encountered a partial or incomplete log block.
//
#define ERROR_LOG_BLOCK_INCOMPLETE 6603L

//
// MessageId: ERROR_LOG_INVALID_RANGE
//
// MessageText:
//
// Log service encountered an attempt access data outside the active log range.
//
#define ERROR_LOG_INVALID_RANGE 6604L

//
// MessageId: ERROR_LOG_BLOCKS_EXHAUSTED
//
// MessageText:
//
// Log service user marshalling buffers are exhausted.
//
#define ERROR_LOG_BLOCKS_EXHAUSTED 6605L

//
// MessageId: ERROR_LOG_READ_CONTEXT_INVALID
//
// MessageText:
//
// Log service encountered an attempt read from a marshalling area with an invalid read context.
//
#define ERROR_LOG_READ_CONTEXT_INVALID 6606L

//
// MessageId: ERROR_LOG_RESTART_INVALID
//
// MessageText:
//
// Log service encountered an invalid log restart area.
//
#define ERROR_LOG_RESTART_INVALID 6607L

//
// MessageId: ERROR_LOG_BLOCK_VERSION
//
// MessageText:
//
// Log service encountered an invalid log block version.
//
#define ERROR_LOG_BLOCK_VERSION 6608L

//
// MessageId: ERROR_LOG_BLOCK_INVALID
//
// MessageText:
//
// Log service encountered an invalid log block.
//
#define ERROR_LOG_BLOCK_INVALID 6609L

//
// MessageId: ERROR_LOG_READ_MODE_INVALID
//
// MessageText:
//
// Log service encountered an attempt to read the log with an invalid read mode.
//
#define ERROR_LOG_READ_MODE_INVALID 6610L

//
// MessageId: ERROR_LOG_NO_RESTART
//
// MessageText:
//
// Log service encountered a log stream with no restart area.
//
#define ERROR_LOG_NO_RESTART 6611L

//
// MessageId: ERROR_LOG_METADATA_CORRUPT
//
// MessageText:
//
// Log service encountered a corrupted metadata file.
//
#define ERROR_LOG_METADATA_CORRUPT 6612L

//
// MessageId: ERROR_LOG_METADATA_INVALID
//
// MessageText:
//
// Log service encountered a metadata file that could not be created by the log file system.
//
#define ERROR_LOG_METADATA_INVALID 6613L

//
// MessageId: ERROR_LOG_METADATA_INCONSISTENT
//
// MessageText:
//
// Log service encountered a metadata file with inconsistent data.
//
#define ERROR_LOG_METADATA_INCONSISTENT 6614L

//
// MessageId: ERROR_LOG_RESERVATION_INVALID
//
// MessageText:
//
// Log service encountered an attempt to erroneous allocate or dispose reservation space.
//
#define ERROR_LOG_RESERVATION_INVALID 6615L

//
// MessageId: ERROR_LOG_CANT_DELETE
//
// MessageText:
//
// Log service cannot delete log file or file system container.
//
#define ERROR_LOG_CANT_DELETE 6616L

//
// MessageId: ERROR_LOG_CONTAINER_LIMIT_EXCEEDED
//
// MessageText:
//
// Log service has reached the maximum allowable containers allocated to a log file.
//
#define ERROR_LOG_CONTAINER_LIMIT_EXCEEDED 6617L

//
// MessageId: ERROR_LOG_START_OF_LOG
//
// MessageText:
//
// Log service has attempted to read or write backward past the start of the log.
//
#define ERROR_LOG_START_OF_LOG 6618L

//
// MessageId: ERROR_LOG_POLICY_ALREADY_INSTALLED
//
// MessageText:
//
// Log policy could not be installed because a policy of the same type is already present.
//
#define ERROR_LOG_POLICY_ALREADY_INSTALLED 6619L

//
// MessageId: ERROR_LOG_POLICY_NOT_INSTALLED
//
// MessageText:
//
// Log policy in question was not installed at the time of the request.
//
#define ERROR_LOG_POLICY_NOT_INSTALLED 6620L

//
// MessageId: ERROR_LOG_POLICY_INVALID
//
// MessageText:
//
// The installed set of policies on the log is invalid.
//
#define ERROR_LOG_POLICY_INVALID 6621L

//
// MessageId: ERROR_LOG_POLICY_CONFLICT
//
// MessageText:
//
// A policy on the log in question prevented the operation from completing.
//
#define ERROR_LOG_POLICY_CONFLICT 6622L

//
// MessageId: ERROR_LOG_PINNED_ARCHIVE_TAIL
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned by the archive tail.
//
#define ERROR_LOG_PINNED_ARCHIVE_TAIL 6623L

//
// MessageId: ERROR_LOG_RECORD_NONEXISTENT
//
// MessageText:
//
// Log record is not a record in the log file.
//
#define ERROR_LOG_RECORD_NONEXISTENT 6624L

//
// MessageId: ERROR_LOG_RECORDS_RESERVED_INVALID
//
// MessageText:
//
// Number of reserved log records or the adjustment of the number of reserved log records is invalid.
//
#define ERROR_LOG_RECORDS_RESERVED_INVALID 6625L

//
// MessageId: ERROR_LOG_SPACE_RESERVED_INVALID
//
// MessageText:
//
// Reserved log space or the adjustment of the log space is invalid.
//
#define ERROR_LOG_SPACE_RESERVED_INVALID 6626L

//
// MessageId: ERROR_LOG_TAIL_INVALID
//
// MessageText:
//
// An new or existing archive tail or base of the active log is invalid.
//
#define ERROR_LOG_TAIL_INVALID 6627L

//
// MessageId: ERROR_LOG_FULL
//
// MessageText:
//
// Log space is exhausted.
//
#define ERROR_LOG_FULL 6628L

//
// MessageId: ERROR_COULD_NOT_RESIZE_LOG
//
// MessageText:
//
// The log could not be set to the requested size.
//
#define ERROR_COULD_NOT_RESIZE_LOG 6629L

//
// MessageId: ERROR_LOG_MULTIPLEXED
//
// MessageText:
//
// Log is multiplexed, no direct writes to the physical log is allowed.
//
#define ERROR_LOG_MULTIPLEXED 6630L

//
// MessageId: ERROR_LOG_DEDICATED
//
// MessageText:
//
// The operation failed because the log is a dedicated log.
//
#define ERROR_LOG_DEDICATED 6631L

//
// MessageId: ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS
//
// MessageText:
//
// The operation requires an archive context.
//
#define ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS 6632L

//
// MessageId: ERROR_LOG_ARCHIVE_IN_PROGRESS
//
// MessageText:
//
// Log archival is in progress.
//
#define ERROR_LOG_ARCHIVE_IN_PROGRESS 6633L

//
// MessageId: ERROR_LOG_EPHEMERAL
//
// MessageText:
//
// The operation requires a non-ephemeral log, but the log is ephemeral.
//
#define ERROR_LOG_EPHEMERAL 6634L

//
// MessageId: ERROR_LOG_NOT_ENOUGH_CONTAINERS
//
// MessageText:
//
// The log must have at least two containers before it can be read from or written to.
//
#define ERROR_LOG_NOT_ENOUGH_CONTAINERS 6635L

//
// MessageId: ERROR_LOG_CLIENT_ALREADY_REGISTERED
//
// MessageText:
//
// A log client has already registered on the stream.
//
#define ERROR_LOG_CLIENT_ALREADY_REGISTERED 6636L

//
// MessageId: ERROR_LOG_CLIENT_NOT_REGISTERED
//
// MessageText:
//
// A log client has not been registered on the stream.
//
#define ERROR_LOG_CLIENT_NOT_REGISTERED 6637L

//
// MessageId: ERROR_LOG_FULL_HANDLER_IN_PROGRESS
//
// MessageText:
//
// A request has already been made to handle the log full condition.
//
#define ERROR_LOG_FULL_HANDLER_IN_PROGRESS 6638L

//
// MessageId: ERROR_LOG_CONTAINER_READ_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to read from a log container.
//
#define ERROR_LOG_CONTAINER_READ_FAILED 6639L

//
// MessageId: ERROR_LOG_CONTAINER_WRITE_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to write to a log container.
//
#define ERROR_LOG_CONTAINER_WRITE_FAILED 6640L

//
// MessageId: ERROR_LOG_CONTAINER_OPEN_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting open a log container.
//
#define ERROR_LOG_CONTAINER_OPEN_FAILED 6641L

//
// MessageId: ERROR_LOG_CONTAINER_STATE_INVALID
//
// MessageText:
//
// Log service encountered an invalid container state when attempting a requested action.
//
#define ERROR_LOG_CONTAINER_STATE_INVALID 6642L

//
// MessageId: ERROR_LOG_STATE_INVALID
//
// MessageText:
//
// Log service is not in the correct state to perform a requested action.
//
#define ERROR_LOG_STATE_INVALID 6643L

//
// MessageId: ERROR_LOG_PINNED
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned.
//
#define ERROR_LOG_PINNED 6644L

//
// MessageId: ERROR_LOG_METADATA_FLUSH_FAILED
//
// MessageText:
//
// Log metadata flush failed.
//
#define ERROR_LOG_METADATA_FLUSH_FAILED 6645L

//
// MessageId: ERROR_LOG_INCONSISTENT_SECURITY
//
// MessageText:
//
// Security on the log and its containers is inconsistent.
//
#define ERROR_LOG_INCONSISTENT_SECURITY 6646L

//
// MessageId: ERROR_LOG_APPENDED_FLUSH_FAILED
//
// MessageText:
//
// Records were appended to the log or reservation changes were made, but the log could not be flushed.
//
#define ERROR_LOG_APPENDED_FLUSH_FAILED 6647L

//
// MessageId: ERROR_LOG_PINNED_RESERVATION
//
// MessageText:
//
// The log is pinned due to reservation consuming most of the log space. Free some reserved records to make space available.
//
#define ERROR_LOG_PINNED_RESERVATION 6648L


///////////////////////////////////////////////////
//                                               //
//           Transaction (KTM) Error codes       //
//                                               //
//                 6700 to 6799                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_INVALID_TRANSACTION
//
// MessageText:
//
// The transaction handle associated with this operation is not valid.
//
#define ERROR_INVALID_TRANSACTION 6700L

//
// MessageId: ERROR_TRANSACTION_NOT_ACTIVE
//
// MessageText:
//
// The requested operation was made in the context of a transaction that is no longer active.
//
#define ERROR_TRANSACTION_NOT_ACTIVE 6701L

//
// MessageId: ERROR_TRANSACTION_REQUEST_NOT_VALID
//
// MessageText:
//
// The requested operation is not valid on the Transaction object in its current state.
//
#define ERROR_TRANSACTION_REQUEST_NOT_VALID 6702L

//
// MessageId: ERROR_TRANSACTION_NOT_REQUESTED
//
// MessageText:
//
// The caller has called a response API, but the response is not expected because the TM did not issue the corresponding request to the caller.
//
#define ERROR_TRANSACTION_NOT_REQUESTED 6703L

//
// MessageId: ERROR_TRANSACTION_ALREADY_ABORTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been aborted.
//
#define ERROR_TRANSACTION_ALREADY_ABORTED 6704L

//
// MessageId: ERROR_TRANSACTION_ALREADY_COMMITTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been committed.
//
#define ERROR_TRANSACTION_ALREADY_COMMITTED 6705L

//
// MessageId: ERROR_TM_INITIALIZATION_FAILED
//
// MessageText:
//
// The Transaction Manager was unable to be successfully initialized. Transacted operations are not supported.
//
#define ERROR_TM_INITIALIZATION_FAILED 6706L

//
// MessageId: ERROR_RESOURCEMANAGER_READ_ONLY
//
// MessageText:
//
// The specified ResourceManager made no changes or updates to the resource under this transaction.
//
#define ERROR_RESOURCEMANAGER_READ_ONLY 6707L

//
// MessageId: ERROR_TRANSACTION_NOT_JOINED
//
// MessageText:
//
// The resource manager has attempted to prepare a transaction that it has not successfully joined.
//
#define ERROR_TRANSACTION_NOT_JOINED 6708L

//
// MessageId: ERROR_TRANSACTION_SUPERIOR_EXISTS
//
// MessageText:
//
// The Transaction object already has a superior enlistment, and the caller attempted an operation that would have created a new superior. Only a single superior enlistment is allow.
//
#define ERROR_TRANSACTION_SUPERIOR_EXISTS 6709L

//
// MessageId: ERROR_CRM_PROTOCOL_ALREADY_EXISTS
//
// MessageText:
//
// The RM tried to register a protocol that already exists.
//
#define ERROR_CRM_PROTOCOL_ALREADY_EXISTS 6710L

//
// MessageId: ERROR_TRANSACTION_PROPAGATION_FAILED
//
// MessageText:
//
// The attempt to propagate the Transaction failed.
//
#define ERROR_TRANSACTION_PROPAGATION_FAILED 6711L

//
// MessageId: ERROR_CRM_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// The requested propagation protocol was not registered as a CRM.
//
#define ERROR_CRM_PROTOCOL_NOT_FOUND 6712L

//
// MessageId: ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER
//
// MessageText:
//
// The buffer passed in to PushTransaction or PullTransaction is not in a valid format.
//
#define ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER 6713L

//
// MessageId: ERROR_CURRENT_TRANSACTION_NOT_VALID
//
// MessageText:
//
// The current transaction context associated with the thread is not a valid handle to a transaction object.
//
#define ERROR_CURRENT_TRANSACTION_NOT_VALID 6714L

//
// MessageId: ERROR_TRANSACTION_NOT_FOUND
//
// MessageText:
//
// The specified Transaction object could not be opened, because it was not found.
//
#define ERROR_TRANSACTION_NOT_FOUND 6715L

//
// MessageId: ERROR_RESOURCEMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified ResourceManager object could not be opened, because it was not found.
//
#define ERROR_RESOURCEMANAGER_NOT_FOUND 6716L

//
// MessageId: ERROR_ENLISTMENT_NOT_FOUND
//
// MessageText:
//
// The specified Enlistment object could not be opened, because it was not found.
//
#define ERROR_ENLISTMENT_NOT_FOUND 6717L

//
// MessageId: ERROR_TRANSACTIONMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified TransactionManager object could not be opened, because it was not found.
//
#define ERROR_TRANSACTIONMANAGER_NOT_FOUND 6718L

//
// MessageId: ERROR_TRANSACTIONMANAGER_NOT_ONLINE
//
// MessageText:
//
// The object specified could not be created or opened, because its associated TransactionManager is not online.  The TransactionManager must be brought fully Online by calling RecoverTransactionManager to recover to the end of its LogFile before objects in its Transaction or ResourceManager namespaces can be opened.  In addition, errors in writing records to its LogFile can cause a TransactionManager to go offline.
//
#define ERROR_TRANSACTIONMANAGER_NOT_ONLINE 6719L

//
// MessageId: ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION
//
// MessageText:
//
// The specified TransactionManager was unable to create the objects contained in its logfile in the Ob namespace. Therefore, the TransactionManager was unable to recover.
//
#define ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION 6720L

//
// MessageId: ERROR_TRANSACTION_NOT_ROOT
//
// MessageText:
//
// The call to create a superior Enlistment on this Transaction object could not be completed, because the Transaction object specified for the enlistment is a subordinate branch of the Transaction. Only the root of the Transaction can be enlisted on as a superior.
//
#define ERROR_TRANSACTION_NOT_ROOT 6721L

//
// MessageId: ERROR_TRANSACTION_OBJECT_EXPIRED
//
// MessageText:
//
// Because the associated transaction manager or resource manager has been closed, the handle is no longer valid.
//
#define ERROR_TRANSACTION_OBJECT_EXPIRED 6722L

//
// MessageId: ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed on this Superior enlistment, because the enlistment was not created with the corresponding completion response in the NotificationMask.
//
#define ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED 6723L

//
// MessageId: ERROR_TRANSACTION_RECORD_TOO_LONG
//
// MessageText:
//
// The specified operation could not be performed, because the record that would be logged was too long. This can occur because of two conditions: either there are too many Enlistments on this Transaction, or the combined RecoveryInformation being logged on behalf of those Enlistments is too long.
//
#define ERROR_TRANSACTION_RECORD_TOO_LONG 6724L

//
// MessageId: ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED
//
// MessageText:
//
// Implicit transaction are not supported.
//
#define ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED 6725L

//
// MessageId: ERROR_TRANSACTION_INTEGRITY_VIOLATED
//
// MessageText:
//
// The kernel transaction manager had to abort or forget the transaction because it blocked forward progress.
//
#define ERROR_TRANSACTION_INTEGRITY_VIOLATED 6726L

//
// MessageId: ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH
//
// MessageText:
//
// The TransactionManager identity that was supplied did not match the one recorded in the TransactionManager's log file.
//
#define ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH 6727L

//
// MessageId: ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT
//
// MessageText:
//
// This snapshot operation cannot continue because a transactional resource manager cannot be frozen in its current state.  Please try again.
//
#define ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT 6728L

//
// MessageId: ERROR_TRANSACTION_MUST_WRITETHROUGH
//
// MessageText:
//
// The transaction cannot be enlisted on with the specified EnlistmentMask, because the transaction has already completed the PrePrepare phase.  In order to ensure correctness, the ResourceManager must switch to a write-through mode and cease caching data within this transaction.  Enlisting for only subsequent transaction phases may still succeed.
//
#define ERROR_TRANSACTION_MUST_WRITETHROUGH 6729L

//
// MessageId: ERROR_TRANSACTION_NO_SUPERIOR
//
// MessageText:
//
// The transaction does not have a superior enlistment.
//
#define ERROR_TRANSACTION_NO_SUPERIOR 6730L

//
// MessageId: ERROR_HEURISTIC_DAMAGE_POSSIBLE
//
// MessageText:
//
// The attempt to commit the Transaction completed, but it is possible that some portion of the transaction tree did not commit successfully due to heuristics.  Therefore it is possible that some data modified in the transaction may not have committed, resulting in transactional inconsistency.  If possible, check the consistency of the associated data.
//
#define ERROR_HEURISTIC_DAMAGE_POSSIBLE 6731L


///////////////////////////////////////////////////
//                                               //
//        Transactional File Services (TxF)      //
//                  Error codes                  //
//                                               //
//                 6800 to 6899                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_TRANSACTIONAL_CONFLICT
//
// MessageText:
//
// The function attempted to use a name that is reserved for use by another transaction.
//
#define ERROR_TRANSACTIONAL_CONFLICT 6800L

//
// MessageId: ERROR_RM_NOT_ACTIVE
//
// MessageText:
//
// Transaction support within the specified resource manager is not started or was shut down due to an error.
//
#define ERROR_RM_NOT_ACTIVE 6801L

//
// MessageId: ERROR_RM_METADATA_CORRUPT
//
// MessageText:
//
// The metadata of the RM has been corrupted. The RM will not function.
//
#define ERROR_RM_METADATA_CORRUPT 6802L

//
// MessageId: ERROR_DIRECTORY_NOT_RM
//
// MessageText:
//
// The specified directory does not contain a resource manager.
//
#define ERROR_DIRECTORY_NOT_RM 6803L

//
// MessageId: ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE
//
// MessageText:
//
// The remote server or share does not support transacted file operations.
//
#define ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE 6805L

//
// MessageId: ERROR_LOG_RESIZE_INVALID_SIZE
//
// MessageText:
//
// The requested log size is invalid.
//
#define ERROR_LOG_RESIZE_INVALID_SIZE 6806L

//
// MessageId: ERROR_OBJECT_NO_LONGER_EXISTS
//
// MessageText:
//
// The object (file, stream, link) corresponding to the handle has been deleted by a Transaction Savepoint Rollback.
//
#define ERROR_OBJECT_NO_LONGER_EXISTS 6807L

//
// MessageId: ERROR_STREAM_MINIVERSION_NOT_FOUND
//
// MessageText:
//
// The specified file miniversion was not found for this transacted file open.
//
#define ERROR_STREAM_MINIVERSION_NOT_FOUND 6808L

//
// MessageId: ERROR_STREAM_MINIVERSION_NOT_VALID
//
// MessageText:
//
// The specified file miniversion was found but has been invalidated. Most likely cause is a transaction savepoint rollback.
//
#define ERROR_STREAM_MINIVERSION_NOT_VALID 6809L

//
// MessageId: ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION
//
// MessageText:
//
// A miniversion may only be opened in the context of the transaction that created it.
//
#define ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION 6810L

//
// MessageId: ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT
//
// MessageText:
//
// It is not possible to open a miniversion with modify access.
//
#define ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT 6811L

//
// MessageId: ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS
//
// MessageText:
//
// It is not possible to create any more miniversions for this stream.
//
#define ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS 6812L

//
// MessageId: ERROR_REMOTE_FILE_VERSION_MISMATCH
//
// MessageText:
//
// The remote server sent mismatching version number or Fid for a file opened with transactions.
//
#define ERROR_REMOTE_FILE_VERSION_MISMATCH 6814L

//
// MessageId: ERROR_HANDLE_NO_LONGER_VALID
//
// MessageText:
//
// The handle has been invalidated by a transaction. The most likely cause is the presence of memory mapping on a file or an open handle when the transaction ended or rolled back to savepoint.
//
#define ERROR_HANDLE_NO_LONGER_VALID 6815L

//
// MessageId: ERROR_NO_TXF_METADATA
//
// MessageText:
//
// There is no transaction metadata on the file.
//
#define ERROR_NO_TXF_METADATA 6816L

//
// MessageId: ERROR_LOG_CORRUPTION_DETECTED
//
// MessageText:
//
// The log data is corrupt.
//
#define ERROR_LOG_CORRUPTION_DETECTED 6817L

//
// MessageId: ERROR_CANT_RECOVER_WITH_HANDLE_OPEN
//
// MessageText:
//
// The file can't be recovered because there is a handle still open on it.
//
#define ERROR_CANT_RECOVER_WITH_HANDLE_OPEN 6818L

//
// MessageId: ERROR_RM_DISCONNECTED
//
// MessageText:
//
// The transaction outcome is unavailable because the resource manager responsible for it has disconnected.
//
#define ERROR_RM_DISCONNECTED 6819L

//
// MessageId: ERROR_ENLISTMENT_NOT_SUPERIOR
//
// MessageText:
//
// The request was rejected because the enlistment in question is not a superior enlistment.
//
#define ERROR_ENLISTMENT_NOT_SUPERIOR 6820L

//
// MessageId: ERROR_RECOVERY_NOT_NEEDED
//
// MessageText:
//
// The transactional resource manager is already consistent. Recovery is not needed.
//
#define ERROR_RECOVERY_NOT_NEEDED 6821L

//
// MessageId: ERROR_RM_ALREADY_STARTED
//
// MessageText:
//
// The transactional resource manager has already been started.
//
#define ERROR_RM_ALREADY_STARTED 6822L

//
// MessageId: ERROR_FILE_IDENTITY_NOT_PERSISTENT
//
// MessageText:
//
// The file cannot be opened transactionally, because its identity depends on the outcome of an unresolved transaction.
//
#define ERROR_FILE_IDENTITY_NOT_PERSISTENT 6823L

//
// MessageId: ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY
//
// MessageText:
//
// The operation cannot be performed because another transaction is depending on the fact that this property will not change.
//
#define ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY 6824L

//
// MessageId: ERROR_CANT_CROSS_RM_BOUNDARY
//
// MessageText:
//
// The operation would involve a single file with two transactional resource managers and is therefore not allowed.
//
#define ERROR_CANT_CROSS_RM_BOUNDARY 6825L

//
// MessageId: ERROR_TXF_DIR_NOT_EMPTY
//
// MessageText:
//
// The $Txf directory must be empty for this operation to succeed.
//
#define ERROR_TXF_DIR_NOT_EMPTY 6826L

//
// MessageId: ERROR_INDOUBT_TRANSACTIONS_EXIST
//
// MessageText:
//
// The operation would leave a transactional resource manager in an inconsistent state and is therefore not allowed.
//
#define ERROR_INDOUBT_TRANSACTIONS_EXIST 6827L

//
// MessageId: ERROR_TM_VOLATILE
//
// MessageText:
//
// The operation could not be completed because the transaction manager does not have a log.
//
#define ERROR_TM_VOLATILE 6828L

//
// MessageId: ERROR_ROLLBACK_TIMER_EXPIRED
//
// MessageText:
//
// A rollback could not be scheduled because a previously scheduled rollback has already executed or been queued for execution.
//
#define ERROR_ROLLBACK_TIMER_EXPIRED 6829L

//
// MessageId: ERROR_TXF_ATTRIBUTE_CORRUPT
//
// MessageText:
//
// The transactional metadata attribute on the file or directory is corrupt and unreadable.
//
#define ERROR_TXF_ATTRIBUTE_CORRUPT 6830L

//
// MessageId: ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The encryption operation could not be completed because a transaction is active.
//
#define ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION 6831L

//
// MessageId: ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED
//
// MessageText:
//
// This object is not allowed to be opened in a transaction.
//
#define ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED 6832L

//
// MessageId: ERROR_LOG_GROWTH_FAILED
//
// MessageText:
//
// An attempt to create space in the transactional resource manager's log failed. The failure status has been recorded in the event log.
//
#define ERROR_LOG_GROWTH_FAILED 6833L

//
// MessageId: ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE
//
// MessageText:
//
// Memory mapping (creating a mapped section) a remote file under a transaction is not supported.
//
#define ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE 6834L

//
// MessageId: ERROR_TXF_METADATA_ALREADY_PRESENT
//
// MessageText:
//
// Transaction metadata is already present on this file and cannot be superseded.
//
#define ERROR_TXF_METADATA_ALREADY_PRESENT 6835L

//
// MessageId: ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET
//
// MessageText:
//
// A transaction scope could not be entered because the scope handler has not been initialized.
//
#define ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET 6836L

//
// MessageId: ERROR_TRANSACTION_REQUIRED_PROMOTION
//
// MessageText:
//
// Promotion was required in order to allow the resource manager to enlist, but the transaction was set to disallow it.
//
#define ERROR_TRANSACTION_REQUIRED_PROMOTION 6837L

//
// MessageId: ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION
//
// MessageText:
//
// This file is open for modification in an unresolved transaction and may be opened for execute only by a transacted reader.
//
#define ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION 6838L

//
// MessageId: ERROR_TRANSACTIONS_NOT_FROZEN
//
// MessageText:
//
// The request to thaw frozen transactions was ignored because transactions had not previously been frozen.
//
#define ERROR_TRANSACTIONS_NOT_FROZEN 6839L

//
// MessageId: ERROR_TRANSACTION_FREEZE_IN_PROGRESS
//
// MessageText:
//
// Transactions cannot be frozen because a freeze is already in progress.
//
#define ERROR_TRANSACTION_FREEZE_IN_PROGRESS 6840L

//
// MessageId: ERROR_NOT_SNAPSHOT_VOLUME
//
// MessageText:
//
// The target volume is not a snapshot volume. This operation is only valid on a volume mounted as a snapshot.
//
#define ERROR_NOT_SNAPSHOT_VOLUME 6841L

//
// MessageId: ERROR_NO_SAVEPOINT_WITH_OPEN_FILES
//
// MessageText:
//
// The savepoint operation failed because files are open on the transaction. This is not permitted.
//
#define ERROR_NO_SAVEPOINT_WITH_OPEN_FILES 6842L

//
// MessageId: ERROR_DATA_LOST_REPAIR
//
// MessageText:
//
// Windows has discovered corruption in a file, and that file has since been repaired. Data loss may have occurred.
//
#define ERROR_DATA_LOST_REPAIR 6843L

//
// MessageId: ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The sparse operation could not be completed because a transaction is active on the file.
//
#define ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION 6844L

//
// MessageId: ERROR_TM_IDENTITY_MISMATCH
//
// MessageText:
//
// The call to create a TransactionManager object failed because the Tm Identity stored in the logfile does not match the Tm Identity that was passed in as an argument.
//
#define ERROR_TM_IDENTITY_MISMATCH 6845L

//
// MessageId: ERROR_FLOATED_SECTION
//
// MessageText:
//
// I/O was attempted on a section object that has been floated as a result of a transaction ending. There is no valid data.
//
#define ERROR_FLOATED_SECTION 6846L

//
// MessageId: ERROR_CANNOT_ACCEPT_TRANSACTED_WORK
//
// MessageText:
//
// The transactional resource manager cannot currently accept transacted work due to a transient condition such as low resources.
//
#define ERROR_CANNOT_ACCEPT_TRANSACTED_WORK 6847L

//
// MessageId: ERROR_CANNOT_ABORT_TRANSACTIONS
//
// MessageText:
//
// The transactional resource manager had too many tranactions outstanding that could not be aborted. The transactional resource manger has been shut down.
//
#define ERROR_CANNOT_ABORT_TRANSACTIONS 6848L

//
// MessageId: ERROR_BAD_CLUSTERS
//
// MessageText:
//
// The operation could not be completed due to bad clusters on disk.
//
#define ERROR_BAD_CLUSTERS 6849L

//
// MessageId: ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The compression operation could not be completed because a transaction is active on the file.
//
#define ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION 6850L

//
// MessageId: ERROR_VOLUME_DIRTY
//
// MessageText:
//
// The operation could not be completed because the volume is dirty. Please run chkdsk and try again.
//
#define ERROR_VOLUME_DIRTY 6851L

//
// MessageId: ERROR_NO_LINK_TRACKING_IN_TRANSACTION
//
// MessageText:
//
// The link tracking operation could not be completed because a transaction is active.
//
#define ERROR_NO_LINK_TRACKING_IN_TRANSACTION 6852L

//
// MessageId: ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION
//
// MessageText:
//
// This operation cannot be performed in a transaction.
//
#define ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION 6853L

//
// MessageId: ERROR_EXPIRED_HANDLE
//
// MessageText:
//
// The handle is no longer properly associated with its transaction.  It may have been opened in a transactional resource manager that was subsequently forced to restart.  Please close the handle and open a new one.
//
#define ERROR_EXPIRED_HANDLE 6854L

//
// MessageId: ERROR_TRANSACTION_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed because the resource manager is not enlisted in the transaction.
//
#define ERROR_TRANSACTION_NOT_ENLISTED 6855L


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 6900 to 6999                  //
///////////////////////////////////////////////////

///////////////////////////////////////////////////
//                                               //
//          Terminal Server Error codes          //
//                                               //
//                 7000 to 7099                  //
///////////////////////////////////////////////////

//
// MessageId: ERROR_CTX_WINSTATION_NAME_INVALID
//
// MessageText:
//
// The specified session name is invalid.
//
#define ERROR_CTX_WINSTATION_NAME_INVALID 7001L

//
// MessageId: ERROR_CTX_INVALID_PD
//
// MessageText:
//
// The specified protocol driver is invalid.
//
#define ERROR_CTX_INVALID_PD 7002L

//
// MessageId: ERROR_CTX_PD_NOT_FOUND
//
// MessageText:
//
// The specified protocol driver was not found in the system path.
//
#define ERROR_CTX_PD_NOT_FOUND 7003L

//
// MessageId: ERROR_CTX_WD_NOT_FOUND
//
// MessageText:
//
// The specified terminal connection driver was not found in the system path.
//
#define ERROR_CTX_WD_NOT_FOUND 7004L

//
// MessageId: ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY
//
// MessageText:
//
// A registry key for event logging could not be created for this session.
//
#define ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY 7005L

//
// MessageId: ERROR_CTX_SERVICE_NAME_COLLISION
//
// MessageText:
//
// A service with the same name already exists on the system.
//
#define ERROR_CTX_SERVICE_NAME_COLLISION 7006L

//
// MessageId: ERROR_CTX_CLOSE_PENDING
//
// MessageText:
//
// A close operation is pending on the session.
//
#define ERROR_CTX_CLOSE_PENDING 7007L

//
// MessageId: ERROR_CTX_NO_OUTBUF
//
// MessageText:
//
// There are no free output buffers available.
//
#define ERROR_CTX_NO_OUTBUF 7008L

//
// MessageId: ERROR_CTX_MODEM_INF_NOT_FOUND
//
// MessageText:
//
// The MODEM.INF file was not found.
//
#define ERROR_CTX_MODEM_INF_NOT_FOUND 7009L

//
// MessageId: ERROR_CTX_INVALID_MODEMNAME
//
// MessageText:
//
// The modem name was not found in MODEM.INF.
//
#define ERROR_CTX_INVALID_MODEMNAME 7010L

//
// MessageId: ERROR_CTX_MODEM_RESPONSE_ERROR
//
// MessageText:
//
// The modem did not accept the command sent to it. Verify that the configured modem name matches the attached modem.
//
#define ERROR_CTX_MODEM_RESPONSE_ERROR 7011L

//
// MessageId: ERROR_CTX_MODEM_RESPONSE_TIMEOUT
//
// MessageText:
//
// The modem did not respond to the command sent to it. Verify that the modem is properly cabled and powered on.
//
#define ERROR_CTX_MODEM_RESPONSE_TIMEOUT 7012L

//
// MessageId: ERROR_CTX_MODEM_RESPONSE_NO_CARRIER
//
// MessageText:
//
// Carrier detect has failed or carrier has been dropped due to disconnect.
//
#define ERROR_CTX_MODEM_RESPONSE_NO_CARRIER 7013L

//
// MessageId: ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE
//
// MessageText:
//
// Dial tone not detected within the required time. Verify that the phone cable is properly attached and functional.
//
#define ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE 7014L

//
// MessageId: ERROR_CTX_MODEM_RESPONSE_BUSY
//
// MessageText:
//
// Busy signal detected at remote site on callback.
//
#define ERROR_CTX_MODEM_RESPONSE_BUSY 7015L

//
// MessageId: ERROR_CTX_MODEM_RESPONSE_VOICE
//
// MessageText:
//
// Voice detected at remote site on callback.
//
#define ERROR_CTX_MODEM_RESPONSE_VOICE 7016L

//
// MessageId: ERROR_CTX_TD_ERROR
//
// MessageText:
//
// Transport driver error
//
#define ERROR_CTX_TD_ERROR 7017L

//
// MessageId: ERROR_CTX_WINSTATION_NOT_FOUND
//
// MessageText:
//
// The specified session cannot be found.
//
#define ERROR_CTX_WINSTATION_NOT_FOUND 7022L

//
// MessageId: ERROR_CTX_WINSTATION_ALREADY_EXISTS
//
// MessageText:
//
// The specified session name is already in use.
//
#define ERROR_CTX_WINSTATION_ALREADY_EXISTS 7023L

//
// MessageId: ERROR_CTX_WINSTATION_BUSY
//
// MessageText:
//
// The task you are trying to do can't be completed because Remote Desktop Services is currently busy. Please try again in a few minutes. Other users should still be able to log on.
//
#define ERROR_CTX_WINSTATION_BUSY 7024L

//
// MessageId: ERROR_CTX_BAD_VIDEO_MODE
//
// MessageText:
//
// An attempt has been made to connect to a session whose video mode is not supported by the current client.
//
#define ERROR_CTX_BAD_VIDEO_MODE 7025L

//
// MessageId: ERROR_CTX_GRAPHICS_INVALID
//
// MessageText:
//
// The application attempted to enable DOS graphics mode. DOS graphics mode is not supported.
//
#define ERROR_CTX_GRAPHICS_INVALID 7035L

//
// MessageId: ERROR_CTX_LOGON_DISABLED
//
// MessageText:
//
// Your interactive logon privilege has been disabled. Please contact your administrator.
//
#define ERROR_CTX_LOGON_DISABLED 7037L

//
// MessageId: ERROR_CTX_NOT_CONSOLE
//
// MessageText:
//
// The requested operation can be performed only on the system console. This is most often the result of a driver or system DLL requiring direct console access.
//
#define ERROR_CTX_NOT_CONSOLE 7038L

//
// MessageId: ERROR_CTX_CLIENT_QUERY_TIMEOUT
//
// MessageText:
//
// The client failed to respond to the server connect message.
//
#define ERROR_CTX_CLIENT_QUERY_TIMEOUT 7040L

//
// MessageId: ERROR_CTX_CONSOLE_DISCONNECT
//
// MessageText:
//
// Disconnecting the console session is not supported.
//
#define ERROR_CTX_CONSOLE_DISCONNECT 7041L

//
// MessageId: ERROR_CTX_CONSOLE_CONNECT
//
// MessageText:
//
// Reconnecting a disconnected session to the console is not supported.
//
#define ERROR_CTX_CONSOLE_CONNECT 7042L

//
// MessageId: ERROR_CTX_SHADOW_DENIED
//
// MessageText:
//
// The request to control another session remotely was denied.
//
#define ERROR_CTX_SHADOW_DENIED 7044L

//
// MessageId: ERROR_CTX_WINSTATION_ACCESS_DENIED
//
// MessageText:
//
// The requested session access is denied.
//
#define ERROR_CTX_WINSTATION_ACCESS_DENIED 7045L

//
// MessageId: ERROR_CTX_INVALID_WD
//
// MessageText:
//
// The specified terminal connection driver is invalid.
//
#define ERROR_CTX_INVALID_WD 7049L

//
// MessageId: ERROR_CTX_SHADOW_INVALID
//
// MessageText:
//
// The requested session cannot be controlled remotely.
// This may be because the session is disconnected or does not currently have a user logged on.
//
#define ERROR_CTX_SHADOW_INVALID 7050L

//
// MessageId: ERROR_CTX_SHADOW_DISABLED
//
// MessageText:
//
// The requested session is not configured to allow remote control.
//
#define ERROR_CTX_SHADOW_DISABLED 7051L

//
// MessageId: ERROR_CTX_CLIENT_LICENSE_IN_USE
//
// MessageText:
//
// Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number is currently being used by another user. Please call your system administrator to obtain a unique license number.
//
#define ERROR_CTX_CLIENT_LICENSE_IN_USE 7052L

//
// MessageId: ERROR_CTX_CLIENT_LICENSE_NOT_SET
//
// MessageText:
//
// Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number has not been entered for this copy of the Terminal Server client. Please contact your system administrator.
//
#define ERROR_CTX_CLIENT_LICENSE_NOT_SET 7053L

//
// MessageId: ERROR_CTX_LICENSE_NOT_AVAILABLE
//
// MessageText:
//
// The number of connections to this computer is limited and all connections are in use right now. Try connecting later or contact your system administrator.
//
#define ERROR_CTX_LICENSE_NOT_AVAILABLE 7054L

//
// MessageId: ERROR_CTX_LICENSE_CLIENT_INVALID
//
// MessageText:
//
// The client you are using is not licensed to use this system. Your logon request is denied.
//
#define ERROR_CTX_LICENSE_CLIENT_INVALID 7055L

//
// MessageId: ERROR_CTX_LICENSE_EXPIRED
//
// MessageText:
//
// The system license has expired. Your logon request is denied.
//
#define ERROR_CTX_LICENSE_EXPIRED 7056L

//
// MessageId: ERROR_CTX_SHADOW_NOT_RUNNING
//
// MessageText:
//
// Remote control could not be terminated because the specified session is not currently being remotely controlled.
//
#define ERROR_CTX_SHADOW_NOT_RUNNING 7057L

//
// MessageId: ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE
//
// MessageText:
//
// The remote control of the console was terminated because the display mode was changed. Changing the display mode in a remote control session is not supported.
//
#define ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE 7058L

//
// MessageId: ERROR_ACTIVATION_COUNT_EXCEEDED
//
// MessageText:
//
// Activation has already been reset the maximum number of times for this installation. Your activation timer will not be cleared.
//
#define ERROR_ACTIVATION_COUNT_EXCEEDED 7059L

//
// MessageId: ERROR_CTX_WINSTATIONS_DISABLED
//
// MessageText:
//
// Remote logins are currently disabled.
//
#define ERROR_CTX_WINSTATIONS_DISABLED 7060L

//
// MessageId: ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED
//
// MessageText:
//
// You do not have the proper encryption level to access this Session.
//
#define ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED 7061L

//
// MessageId: ERROR_CTX_SESSION_IN_USE
//
// MessageText:
//
// The user %s\\%s is currently logged on to this computer. Only the current user or an administrator can log on to this computer.
//
#define ERROR_CTX_SESSION_IN_USE 7062L

//
// MessageId: ERROR_CTX_NO_FORCE_LOGOFF
//
// MessageText:
//
// The user %s\\%s is already logged on to the console of this computer. You do not have permission to log in at this time. To resolve this issue, contact %s\\%s and have them log off.
//
#define ERROR_CTX_NO_FORCE_LOGOFF 7063L

//
// MessageId: ERROR_CTX_ACCOUNT_RESTRICTION
//
// MessageText:
//
// Unable to log you on because of an account restriction.
//
#define ERROR_CTX_ACCOUNT_RESTRICTION 7064L

//
// MessageId: ERROR_RDP_PROTOCOL_ERROR
//
// MessageText:
//
// The RDP protocol component %2 detected an error in the protocol stream and has disconnected the client.
//
#define ERROR_RDP_PROTOCOL_ERROR 7065L

//
// MessageId: ERROR_CTX_CDM_CONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Connected on Terminal Connection.
//
#define ERROR_CTX_CDM_CONNECT 7066L

//
// MessageId: ERROR_CTX_CDM_DISCONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Disconnected on Terminal Connection.
//
#define ERROR_CTX_CDM_DISCONNECT 7067L

//
// MessageId: ERROR_CTX_SECURITY_LAYER_ERROR
//
// MessageText:
//
// The Terminal Server security layer detected an error in the protocol stream and has disconnected the client.
//
#define ERROR_CTX_SECURITY_LAYER_ERROR 7068L

//
// MessageId: ERROR_TS_INCOMPATIBLE_SESSIONS
//
// MessageText:
//
// The target session is incompatible with the current session.
//
#define ERROR_TS_INCOMPATIBLE_SESSIONS 7069L

//
// MessageId: ERROR_TS_VIDEO_SUBSYSTEM_ERROR
//
// MessageText:
//
// Windows can't connect to your session because a problem occurred in the Windows video subsystem. Try connecting again later, or contact the server administrator for assistance.
//
#define ERROR_TS_VIDEO_SUBSYSTEM_ERROR 7070L

///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 7100 to 7499                  //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                                /
//           Traffic Control Error Codes          /
//                                                /
//                  7500 to 7999                  /
//                                                /
//            defined in: tcerror.h               /
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//           Active Directory Error codes        //
//                                               //
//                 8000 to 8999                  //
///////////////////////////////////////////////////

// *****************
// FACILITY_FILE_REPLICATION_SERVICE
// *****************
//
// MessageId: FRS_ERR_INVALID_API_SEQUENCE
//
// MessageText:
//
// The file replication service API was called incorrectly.
//
#define FRS_ERR_INVALID_API_SEQUENCE 8001L

//
// MessageId: FRS_ERR_STARTING_SERVICE
//
// MessageText:
//
// The file replication service cannot be started.
//
#define FRS_ERR_STARTING_SERVICE 8002L

//
// MessageId: FRS_ERR_STOPPING_SERVICE
//
// MessageText:
//
// The file replication service cannot be stopped.
//
#define FRS_ERR_STOPPING_SERVICE 8003L

//
// MessageId: FRS_ERR_INTERNAL_API
//
// MessageText:
//
// The file replication service API terminated the request. The event log may have more information.
//
#define FRS_ERR_INTERNAL_API 8004L

//
// MessageId: FRS_ERR_INTERNAL
//
// MessageText:
//
// The file replication service terminated the request. The event log may have more information.
//
#define FRS_ERR_INTERNAL 8005L

//
// MessageId: FRS_ERR_SERVICE_COMM
//
// MessageText:
//
// The file replication service cannot be contacted. The event log may have more information.
//
#define FRS_ERR_SERVICE_COMM 8006L

//
// MessageId: FRS_ERR_INSUFFICIENT_PRIV
//
// MessageText:
//
// The file replication service cannot satisfy the request because the user has insufficient privileges. The event log may have more information.
//
#define FRS_ERR_INSUFFICIENT_PRIV 8007L

//
// MessageId: FRS_ERR_AUTHENTICATION
//
// MessageText:
//
// The file replication service cannot satisfy the request because authenticated RPC is not available. The event log may have more information.
//
#define FRS_ERR_AUTHENTICATION 8008L

//
// MessageId: FRS_ERR_PARENT_INSUFFICIENT_PRIV
//
// MessageText:
//
// The file replication service cannot satisfy the request because the user has insufficient privileges on the domain controller. The event log may have more information.
//
#define FRS_ERR_PARENT_INSUFFICIENT_PRIV 8009L

//
// MessageId: FRS_ERR_PARENT_AUTHENTICATION
//
// MessageText:
//
// The file replication service cannot satisfy the request because authenticated RPC is not available on the domain controller. The event log may have more information.
//
#define FRS_ERR_PARENT_AUTHENTICATION 8010L

//
// MessageId: FRS_ERR_CHILD_TO_PARENT_COMM
//
// MessageText:
//
// The file replication service cannot communicate with the file replication service on the domain controller. The event log may have more information.
//
#define FRS_ERR_CHILD_TO_PARENT_COMM 8011L

//
// MessageId: FRS_ERR_PARENT_TO_CHILD_COMM
//
// MessageText:
//
// The file replication service on the domain controller cannot communicate with the file replication service on this computer. The event log may have more information.
//
#define FRS_ERR_PARENT_TO_CHILD_COMM 8012L

//
// MessageId: FRS_ERR_SYSVOL_POPULATE
//
// MessageText:
//
// The file replication service cannot populate the system volume because of an internal error. The event log may have more information.
//
#define FRS_ERR_SYSVOL_POPULATE 8013L

//
// MessageId: FRS_ERR_SYSVOL_POPULATE_TIMEOUT
//
// MessageText:
//
// The file replication service cannot populate the system volume because of an internal timeout. The event log may have more information.
//
#define FRS_ERR_SYSVOL_POPULATE_TIMEOUT 8014L

//
// MessageId: FRS_ERR_SYSVOL_IS_BUSY
//
// MessageText:
//
// The file replication service cannot process the request. The system volume is busy with a previous request.
//
#define FRS_ERR_SYSVOL_IS_BUSY 8015L

//
// MessageId: FRS_ERR_SYSVOL_DEMOTE
//
// MessageText:
//
// The file replication service cannot stop replicating the system volume because of an internal error. The event log may have more information.
//
#define FRS_ERR_SYSVOL_DEMOTE 8016L

//
// MessageId: FRS_ERR_INVALID_SERVICE_PARAMETER
//
// MessageText:
//
// The file replication service detected an invalid parameter.
//
#define FRS_ERR_INVALID_SERVICE_PARAMETER 8017L

// *****************
// FACILITY DIRECTORY SERVICE
// *****************
#define DS_S_SUCCESS NO_ERROR
//
// MessageId: ERROR_DS_NOT_INSTALLED
//
// MessageText:
//
// An error occurred while installing the directory service. For more information, see the event log.
//
#define ERROR_DS_NOT_INSTALLED 8200L

//
// MessageId: ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
//
// MessageText:
//
// The directory service evaluated group memberships locally.
//
#define ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY 8201L

//
// MessageId: ERROR_DS_NO_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
// The specified directory service attribute or value does not exist.
//
#define ERROR_DS_NO_ATTRIBUTE_OR_VALUE 8202L

//
// MessageId: ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
//
// MessageText:
//
// The attribute syntax specified to the directory service is invalid.
//
#define ERROR_DS_INVALID_ATTRIBUTE_SYNTAX 8203L

//
// MessageId: ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
//
// MessageText:
//
// The attribute type specified to the directory service is not defined.
//
#define ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED 8204L

//
// MessageId: ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
// The specified directory service attribute or value already exists.
//
#define ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS 8205L

//
// MessageId: ERROR_DS_BUSY
//
// MessageText:
//
// The directory service is busy.
//
#define ERROR_DS_BUSY 8206L

//
// MessageId: ERROR_DS_UNAVAILABLE
//
// MessageText:
//
// The directory service is unavailable.
//
#define ERROR_DS_UNAVAILABLE 8207L

//
// MessageId: ERROR_DS_NO_RIDS_ALLOCATED
//
// MessageText:
//
// The directory service was unable to allocate a relative identifier.
//
#define ERROR_DS_NO_RIDS_ALLOCATED 8208L

//
// MessageId: ERROR_DS_NO_MORE_RIDS
//
// MessageText:
//
// The directory service has exhausted the pool of relative identifiers.
//
#define ERROR_DS_NO_MORE_RIDS 8209L

//
// MessageId: ERROR_DS_INCORRECT_ROLE_OWNER
//
// MessageText:
//
// The requested operation could not be performed because the directory service is not the master for that type of operation.
//
#define ERROR_DS_INCORRECT_ROLE_OWNER 8210L

//
// MessageId: ERROR_DS_RIDMGR_INIT_ERROR
//
// MessageText:
//
// The directory service was unable to initialize the subsystem that allocates relative identifiers.
//
#define ERROR_DS_RIDMGR_INIT_ERROR 8211L

//
// MessageId: ERROR_DS_OBJ_CLASS_VIOLATION
//
// MessageText:
//
// The requested operation did not satisfy one or more constraints associated with the class of the object.
//
#define ERROR_DS_OBJ_CLASS_VIOLATION 8212L

//
// MessageId: ERROR_DS_CANT_ON_NON_LEAF
//
// MessageText:
//
// The directory service can perform the requested operation only on a leaf object.
//
#define ERROR_DS_CANT_ON_NON_LEAF 8213L

//
// MessageId: ERROR_DS_CANT_ON_RDN
//
// MessageText:
//
// The directory service cannot perform the requested operation on the RDN attribute of an object.
//
#define ERROR_DS_CANT_ON_RDN 8214L

//
// MessageId: ERROR_DS_CANT_MOD_OBJ_CLASS
//
// MessageText:
//
// The directory service detected an attempt to modify the object class of an object.
//
#define ERROR_DS_CANT_MOD_OBJ_CLASS 8215L

//
// MessageId: ERROR_DS_CROSS_DOM_MOVE_ERROR
//
// MessageText:
//
// The requested cross-domain move operation could not be performed.
//
#define ERROR_DS_CROSS_DOM_MOVE_ERROR 8216L

//
// MessageId: ERROR_DS_GC_NOT_AVAILABLE
//
// MessageText:
//
// Unable to contact the global catalog server.
//
#define ERROR_DS_GC_NOT_AVAILABLE 8217L

//
// MessageId: ERROR_SHARED_POLICY
//
// MessageText:
//
// The policy object is shared and can only be modified at the root.
//
#define ERROR_SHARED_POLICY 8218L

//
// MessageId: ERROR_POLICY_OBJECT_NOT_FOUND
//
// MessageText:
//
// The policy object does not exist.
//
#define ERROR_POLICY_OBJECT_NOT_FOUND 8219L

//
// MessageId: ERROR_POLICY_ONLY_IN_DS
//
// MessageText:
//
// The requested policy information is only in the directory service.
//
#define ERROR_POLICY_ONLY_IN_DS 8220L

//
// MessageId: ERROR_PROMOTION_ACTIVE
//
// MessageText:
//
// A domain controller promotion is currently active.
//
#define ERROR_PROMOTION_ACTIVE 8221L

//
// MessageId: ERROR_NO_PROMOTION_ACTIVE
//
// MessageText:
//
// A domain controller promotion is not currently active
//
#define ERROR_NO_PROMOTION_ACTIVE 8222L

// 8223 unused
//
// MessageId: ERROR_DS_OPERATIONS_ERROR
//
// MessageText:
//
// An operations error occurred.
//
#define ERROR_DS_OPERATIONS_ERROR 8224L

//
// MessageId: ERROR_DS_PROTOCOL_ERROR
//
// MessageText:
//
// A protocol error occurred.
//
#define ERROR_DS_PROTOCOL_ERROR 8225L

//
// MessageId: ERROR_DS_TIMELIMIT_EXCEEDED
//
// MessageText:
//
// The time limit for this request was exceeded.
//
#define ERROR_DS_TIMELIMIT_EXCEEDED 8226L

//
// MessageId: ERROR_DS_SIZELIMIT_EXCEEDED
//
// MessageText:
//
// The size limit for this request was exceeded.
//
#define ERROR_DS_SIZELIMIT_EXCEEDED 8227L

//
// MessageId: ERROR_DS_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
// The administrative limit for this request was exceeded.
//
#define ERROR_DS_ADMIN_LIMIT_EXCEEDED 8228L

//
// MessageId: ERROR_DS_COMPARE_FALSE
//
// MessageText:
//
// The compare response was false.
//
#define ERROR_DS_COMPARE_FALSE 8229L

//
// MessageId: ERROR_DS_COMPARE_TRUE
//
// MessageText:
//
// The compare response was true.
//
#define ERROR_DS_COMPARE_TRUE 8230L

//
// MessageId: ERROR_DS_AUTH_METHOD_NOT_SUPPORTED
//
// MessageText:
//
// The requested authentication method is not supported by the server.
//
#define ERROR_DS_AUTH_METHOD_NOT_SUPPORTED 8231L

//
// MessageId: ERROR_DS_STRONG_AUTH_REQUIRED
//
// MessageText:
//
// A more secure authentication method is required for this server.
//
#define ERROR_DS_STRONG_AUTH_REQUIRED 8232L

//
// MessageId: ERROR_DS_INAPPROPRIATE_AUTH
//
// MessageText:
//
// Inappropriate authentication.
//
#define ERROR_DS_INAPPROPRIATE_AUTH 8233L

//
// MessageId: ERROR_DS_AUTH_UNKNOWN
//
// MessageText:
//
// The authentication mechanism is unknown.
//
#define ERROR_DS_AUTH_UNKNOWN 8234L

//
// MessageId: ERROR_DS_REFERRAL
//
// MessageText:
//
// A referral was returned from the server.
//
#define ERROR_DS_REFERRAL 8235L

//
// MessageId: ERROR_DS_UNAVAILABLE_CRIT_EXTENSION
//
// MessageText:
//
// The server does not support the requested critical extension.
//
#define ERROR_DS_UNAVAILABLE_CRIT_EXTENSION 8236L

//
// MessageId: ERROR_DS_CONFIDENTIALITY_REQUIRED
//
// MessageText:
//
// This request requires a secure connection.
//
#define ERROR_DS_CONFIDENTIALITY_REQUIRED 8237L

//
// MessageId: ERROR_DS_INAPPROPRIATE_MATCHING
//
// MessageText:
//
// Inappropriate matching.
//
#define ERROR_DS_INAPPROPRIATE_MATCHING 8238L

//
// MessageId: ERROR_DS_CONSTRAINT_VIOLATION
//
// MessageText:
//
// A constraint violation occurred.
//
#define ERROR_DS_CONSTRAINT_VIOLATION 8239L

//
// MessageId: ERROR_DS_NO_SUCH_OBJECT
//
// MessageText:
//
// There is no such object on the server.
//
#define ERROR_DS_NO_SUCH_OBJECT 8240L

//
// MessageId: ERROR_DS_ALIAS_PROBLEM
//
// MessageText:
//
// There is an alias problem.
//
#define ERROR_DS_ALIAS_PROBLEM 8241L

//
// MessageId: ERROR_DS_INVALID_DN_SYNTAX
//
// MessageText:
//
// An invalid dn syntax has been specified.
//
#define ERROR_DS_INVALID_DN_SYNTAX 8242L

//
// MessageId: ERROR_DS_IS_LEAF
//
// MessageText:
//
// The object is a leaf object.
//
#define ERROR_DS_IS_LEAF 8243L

//
// MessageId: ERROR_DS_ALIAS_DEREF_PROBLEM
//
// MessageText:
//
// There is an alias dereferencing problem.
//
#define ERROR_DS_ALIAS_DEREF_PROBLEM 8244L

//
// MessageId: ERROR_DS_UNWILLING_TO_PERFORM
//
// MessageText:
//
// The server is unwilling to process the request.
//
#define ERROR_DS_UNWILLING_TO_PERFORM 8245L

//
// MessageId: ERROR_DS_LOOP_DETECT
//
// MessageText:
//
// A loop has been detected.
//
#define ERROR_DS_LOOP_DETECT 8246L

//
// MessageId: ERROR_DS_NAMING_VIOLATION
//
// MessageText:
//
// There is a naming violation.
//
#define ERROR_DS_NAMING_VIOLATION 8247L

//
// MessageId: ERROR_DS_OBJECT_RESULTS_TOO_LARGE
//
// MessageText:
//
// The result set is too large.
//
#define ERROR_DS_OBJECT_RESULTS_TOO_LARGE 8248L

//
// MessageId: ERROR_DS_AFFECTS_MULTIPLE_DSAS
//
// MessageText:
//
// The operation affects multiple DSAs
//
#define ERROR_DS_AFFECTS_MULTIPLE_DSAS 8249L

//
// MessageId: ERROR_DS_SERVER_DOWN
//
// MessageText:
//
// The server is not operational.
//
#define ERROR_DS_SERVER_DOWN 8250L

//
// MessageId: ERROR_DS_LOCAL_ERROR
//
// MessageText:
//
// A local error has occurred.
//
#define ERROR_DS_LOCAL_ERROR 8251L

//
// MessageId: ERROR_DS_ENCODING_ERROR
//
// MessageText:
//
// An encoding error has occurred.
//
#define ERROR_DS_ENCODING_ERROR 8252L

//
// MessageId: ERROR_DS_DECODING_ERROR
//
// MessageText:
//
// A decoding error has occurred.
//
#define ERROR_DS_DECODING_ERROR 8253L

//
// MessageId: ERROR_DS_FILTER_UNKNOWN
//
// MessageText:
//
// The search filter cannot be recognized.
//
#define ERROR_DS_FILTER_UNKNOWN 8254L

//
// MessageId: ERROR_DS_PARAM_ERROR
//
// MessageText:
//
// One or more parameters are illegal.
//
#define ERROR_DS_PARAM_ERROR 8255L

//
// MessageId: ERROR_DS_NOT_SUPPORTED
//
// MessageText:
//
// The specified method is not supported.
//
#define ERROR_DS_NOT_SUPPORTED 8256L

//
// MessageId: ERROR_DS_NO_RESULTS_RETURNED
//
// MessageText:
//
// No results were returned.
//
#define ERROR_DS_NO_RESULTS_RETURNED 8257L

//
// MessageId: ERROR_DS_CONTROL_NOT_FOUND
//
// MessageText:
//
// The specified control is not supported by the server.
//
#define ERROR_DS_CONTROL_NOT_FOUND 8258L

//
// MessageId: ERROR_DS_CLIENT_LOOP
//
// MessageText:
//
// A referral loop was detected by the client.
//
#define ERROR_DS_CLIENT_LOOP 8259L

//
// MessageId: ERROR_DS_REFERRAL_LIMIT_EXCEEDED
//
// MessageText:
//
// The preset referral limit was exceeded.
//
#define ERROR_DS_REFERRAL_LIMIT_EXCEEDED 8260L

//
// MessageId: ERROR_DS_SORT_CONTROL_MISSING
//
// MessageText:
//
// The search requires a SORT control.
//
#define ERROR_DS_SORT_CONTROL_MISSING 8261L

//
// MessageId: ERROR_DS_OFFSET_RANGE_ERROR
//
// MessageText:
//
// The search results exceed the offset range specified.
//
#define ERROR_DS_OFFSET_RANGE_ERROR 8262L

//
// MessageId: ERROR_DS_ROOT_MUST_BE_NC
//
// MessageText:
//
// The root object must be the head of a naming context. The root object cannot have an instantiated parent.
//
#define ERROR_DS_ROOT_MUST_BE_NC 8301L

//
// MessageId: ERROR_DS_ADD_REPLICA_INHIBITED
//
// MessageText:
//
// The add replica operation cannot be performed. The naming context must be writeable in order to create the replica.
//
#define ERROR_DS_ADD_REPLICA_INHIBITED 8302L

//
// MessageId: ERROR_DS_ATT_NOT_DEF_IN_SCHEMA
//
// MessageText:
//
// A reference to an attribute that is not defined in the schema occurred.
//
#define ERROR_DS_ATT_NOT_DEF_IN_SCHEMA 8303L

//
// MessageId: ERROR_DS_MAX_OBJ_SIZE_EXCEEDED
//
// MessageText:
//
// The maximum size of an object has been exceeded.
//
#define ERROR_DS_MAX_OBJ_SIZE_EXCEEDED 8304L

//
// MessageId: ERROR_DS_OBJ_STRING_NAME_EXISTS
//
// MessageText:
//
// An attempt was made to add an object to the directory with a name that is already in use.
//
#define ERROR_DS_OBJ_STRING_NAME_EXISTS 8305L

//
// MessageId: ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA
//
// MessageText:
//
// An attempt was made to add an object of a class that does not have an RDN defined in the schema.
//
#define ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA 8306L

//
// MessageId: ERROR_DS_RDN_DOESNT_MATCH_SCHEMA
//
// MessageText:
//
// An attempt was made to add an object using an RDN that is not the RDN defined in the schema.
//
#define ERROR_DS_RDN_DOESNT_MATCH_SCHEMA 8307L

//
// MessageId: ERROR_DS_NO_REQUESTED_ATTS_FOUND
//
// MessageText:
//
// None of the requested attributes were found on the objects.
//
#define ERROR_DS_NO_REQUESTED_ATTS_FOUND 8308L

//
// MessageId: ERROR_DS_USER_BUFFER_TO_SMALL
//
// MessageText:
//
// The user buffer is too small.
//
#define ERROR_DS_USER_BUFFER_TO_SMALL 8309L

//
// MessageId: ERROR_DS_ATT_IS_NOT_ON_OBJ
//
// MessageText:
//
// The attribute specified in the operation is not present on the object.
//
#define ERROR_DS_ATT_IS_NOT_ON_OBJ 8310L

//
// MessageId: ERROR_DS_ILLEGAL_MOD_OPERATION
//
// MessageText:
//
// Illegal modify operation. Some aspect of the modification is not permitted.
//
#define ERROR_DS_ILLEGAL_MOD_OPERATION 8311L

//
// MessageId: ERROR_DS_OBJ_TOO_LARGE
//
// MessageText:
//
// The specified object is too large.
//
#define ERROR_DS_OBJ_TOO_LARGE 8312L

//
// MessageId: ERROR_DS_BAD_INSTANCE_TYPE
//
// MessageText:
//
// The specified instance type is not valid.
//
#define ERROR_DS_BAD_INSTANCE_TYPE 8313L

//
// MessageId: ERROR_DS_MASTERDSA_REQUIRED
//
// MessageText:
//
// The operation must be performed at a master DSA.
//
#define ERROR_DS_MASTERDSA_REQUIRED 8314L

//
// MessageId: ERROR_DS_OBJECT_CLASS_REQUIRED
//
// MessageText:
//
// The object class attribute must be specified.
//
#define ERROR_DS_OBJECT_CLASS_REQUIRED 8315L

//
// MessageId: ERROR_DS_MISSING_REQUIRED_ATT
//
// MessageText:
//
// A required attribute is missing.
//
#define ERROR_DS_MISSING_REQUIRED_ATT 8316L

//
// MessageId: ERROR_DS_ATT_NOT_DEF_FOR_CLASS
//
// MessageText:
//
// An attempt was made to modify an object to include an attribute that is not legal for its class.
//
#define ERROR_DS_ATT_NOT_DEF_FOR_CLASS 8317L

//
// MessageId: ERROR_DS_ATT_ALREADY_EXISTS
//
// MessageText:
//
// The specified attribute is already present on the object.
//
#define ERROR_DS_ATT_ALREADY_EXISTS 8318L

// 8319 unused
//
// MessageId: ERROR_DS_CANT_ADD_ATT_VALUES
//
// MessageText:
//
// The specified attribute is not present, or has no values.
//
#define ERROR_DS_CANT_ADD_ATT_VALUES 8320L

//
// MessageId: ERROR_DS_SINGLE_VALUE_CONSTRAINT
//
// MessageText:
//
// Multiple values were specified for an attribute that can have only one value.
//
#define ERROR_DS_SINGLE_VALUE_CONSTRAINT 8321L

//
// MessageId: ERROR_DS_RANGE_CONSTRAINT
//
// MessageText:
//
// A value for the attribute was not in the acceptable range of values.
//
#define ERROR_DS_RANGE_CONSTRAINT 8322L

//
// MessageId: ERROR_DS_ATT_VAL_ALREADY_EXISTS
//
// MessageText:
//
// The specified value already exists.
//
#define ERROR_DS_ATT_VAL_ALREADY_EXISTS 8323L

//
// MessageId: ERROR_DS_CANT_REM_MISSING_ATT
//
// MessageText:
//
// The attribute cannot be removed because it is not present on the object.
//
#define ERROR_DS_CANT_REM_MISSING_ATT 8324L

//
// MessageId: ERROR_DS_CANT_REM_MISSING_ATT_VAL
//
// MessageText:
//
// The attribute value cannot be removed because it is not present on the object.
//
#define ERROR_DS_CANT_REM_MISSING_ATT_VAL 8325L

//
// MessageId: ERROR_DS_ROOT_CANT_BE_SUBREF
//
// MessageText:
//
// The specified root object cannot be a subref.
//
#define ERROR_DS_ROOT_CANT_BE_SUBREF 8326L

//
// MessageId: ERROR_DS_NO_CHAINING
//
// MessageText:
//
// Chaining is not permitted.
//
#define ERROR_DS_NO_CHAINING 8327L

//
// MessageId: ERROR_DS_NO_CHAINED_EVAL
//
// MessageText:
//
// Chained evaluation is not permitted.
//
#define ERROR_DS_NO_CHAINED_EVAL 8328L

//
// MessageId: ERROR_DS_NO_PARENT_OBJECT
//
// MessageText:
//
// The operation could not be performed because the object's parent is either uninstantiated or deleted.
//
#define ERROR_DS_NO_PARENT_OBJECT 8329L

//
// MessageId: ERROR_DS_PARENT_IS_AN_ALIAS
//
// MessageText:
//
// Having a parent that is an alias is not permitted. Aliases are leaf objects.
//
#define ERROR_DS_PARENT_IS_AN_ALIAS 8330L

//
// MessageId: ERROR_DS_CANT_MIX_MASTER_AND_REPS
//
// MessageText:
//
// The object and parent must be of the same type, either both masters or both replicas.
//
#define ERROR_DS_CANT_MIX_MASTER_AND_REPS 8331L

//
// MessageId: ERROR_DS_CHILDREN_EXIST
//
// MessageText:
//
// The operation cannot be performed because child objects exist. This operation can only be performed on a leaf object.
//
#define ERROR_DS_CHILDREN_EXIST 8332L

//
// MessageId: ERROR_DS_OBJ_NOT_FOUND
//
// MessageText:
//
// Directory object not found.
//
#define ERROR_DS_OBJ_NOT_FOUND 8333L

//
// MessageId: ERROR_DS_ALIASED_OBJ_MISSING
//
// MessageText:
//
// The aliased object is missing.
//
#define ERROR_DS_ALIASED_OBJ_MISSING 8334L

//
// MessageId: ERROR_DS_BAD_NAME_SYNTAX
//
// MessageText:
//
// The object name has bad syntax.
//
#define ERROR_DS_BAD_NAME_SYNTAX 8335L

//
// MessageId: ERROR_DS_ALIAS_POINTS_TO_ALIAS
//
// MessageText:
//
// It is not permitted for an alias to refer to another alias.
//
#define ERROR_DS_ALIAS_POINTS_TO_ALIAS 8336L

//
// MessageId: ERROR_DS_CANT_DEREF_ALIAS
//
// MessageText:
//
// The alias cannot be dereferenced.
//
#define ERROR_DS_CANT_DEREF_ALIAS 8337L

//
// MessageId: ERROR_DS_OUT_OF_SCOPE
//
// MessageText:
//
// The operation is out of scope.
//
#define ERROR_DS_OUT_OF_SCOPE 8338L

//
// MessageId: ERROR_DS_OBJECT_BEING_REMOVED
//
// MessageText:
//
// The operation cannot continue because the object is in the process of being removed.
//
#define ERROR_DS_OBJECT_BEING_REMOVED 8339L

//
// MessageId: ERROR_DS_CANT_DELETE_DSA_OBJ
//
// MessageText:
//
// The DSA object cannot be deleted.
//
#define ERROR_DS_CANT_DELETE_DSA_OBJ 8340L

//
// MessageId: ERROR_DS_GENERIC_ERROR
//
// MessageText:
//
// A directory service error has occurred.
//
#define ERROR_DS_GENERIC_ERROR 8341L

//
// MessageId: ERROR_DS_DSA_MUST_BE_INT_MASTER
//
// MessageText:
//
// The operation can only be performed on an internal master DSA object.
//
#define ERROR_DS_DSA_MUST_BE_INT_MASTER 8342L

//
// MessageId: ERROR_DS_CLASS_NOT_DSA
//
// MessageText:
//
// The object must be of class DSA.
//
#define ERROR_DS_CLASS_NOT_DSA 8343L

//
// MessageId: ERROR_DS_INSUFF_ACCESS_RIGHTS
//
// MessageText:
//
// Insufficient access rights to perform the operation.
//
#define ERROR_DS_INSUFF_ACCESS_RIGHTS 8344L

//
// MessageId: ERROR_DS_ILLEGAL_SUPERIOR
//
// MessageText:
//
// The object cannot be added because the parent is not on the list of possible superiors.
//
#define ERROR_DS_ILLEGAL_SUPERIOR 8345L

//
// MessageId: ERROR_DS_ATTRIBUTE_OWNED_BY_SAM
//
// MessageText:
//
// Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM).
//
#define ERROR_DS_ATTRIBUTE_OWNED_BY_SAM 8346L

//
// MessageId: ERROR_DS_NAME_TOO_MANY_PARTS
//
// MessageText:
//
// The name has too many parts.
//
#define ERROR_DS_NAME_TOO_MANY_PARTS 8347L

//
// MessageId: ERROR_DS_NAME_TOO_LONG
//
// MessageText:
//
// The name is too long.
//
#define ERROR_DS_NAME_TOO_LONG 8348L

//
// MessageId: ERROR_DS_NAME_VALUE_TOO_LONG
//
// MessageText:
//
// The name value is too long.
//
#define ERROR_DS_NAME_VALUE_TOO_LONG 8349L

//
// MessageId: ERROR_DS_NAME_UNPARSEABLE
//
// MessageText:
//
// The directory service encountered an error parsing a name.
//
#define ERROR_DS_NAME_UNPARSEABLE 8350L

//
// MessageId: ERROR_DS_NAME_TYPE_UNKNOWN
//
// MessageText:
//
// The directory service cannot get the attribute type for a name.
//
#define ERROR_DS_NAME_TYPE_UNKNOWN 8351L

//
// MessageId: ERROR_DS_NOT_AN_OBJECT
//
// MessageText:
//
// The name does not identify an object; the name identifies a phantom.
//
#define ERROR_DS_NOT_AN_OBJECT 8352L

//
// MessageId: ERROR_DS_SEC_DESC_TOO_SHORT
//
// MessageText:
//
// The security descriptor is too short.
//
#define ERROR_DS_SEC_DESC_TOO_SHORT 8353L

//
// MessageId: ERROR_DS_SEC_DESC_INVALID
//
// MessageText:
//
// The security descriptor is invalid.
//
#define ERROR_DS_SEC_DESC_INVALID 8354L

//
// MessageId: ERROR_DS_NO_DELETED_NAME
//
// MessageText:
//
// Failed to create name for deleted object.
//
#define ERROR_DS_NO_DELETED_NAME 8355L

//
// MessageId: ERROR_DS_SUBREF_MUST_HAVE_PARENT
//
// MessageText:
//
// The parent of a new subref must exist.
//
#define ERROR_DS_SUBREF_MUST_HAVE_PARENT 8356L

//
// MessageId: ERROR_DS_NCNAME_MUST_BE_NC
//
// MessageText:
//
// The object must be a naming context.
//
#define ERROR_DS_NCNAME_MUST_BE_NC 8357L

//
// MessageId: ERROR_DS_CANT_ADD_SYSTEM_ONLY
//
// MessageText:
//
// It is not permitted to add an attribute which is owned by the system.
//
#define ERROR_DS_CANT_ADD_SYSTEM_ONLY 8358L

//
// MessageId: ERROR_DS_CLASS_MUST_BE_CONCRETE
//
// MessageText:
//
// The class of the object must be structural; you cannot instantiate an abstract class.
//
#define ERROR_DS_CLASS_MUST_BE_CONCRETE 8359L

//
// MessageId: ERROR_DS_INVALID_DMD
//
// MessageText:
//
// The schema object could not be found.
//
#define ERROR_DS_INVALID_DMD 8360L

//
// MessageId: ERROR_DS_OBJ_GUID_EXISTS
//
// MessageText:
//
// A local object with this GUID (dead or alive) already exists.
//
#define ERROR_DS_OBJ_GUID_EXISTS 8361L

//
// MessageId: ERROR_DS_NOT_ON_BACKLINK
//
// MessageText:
//
// The operation cannot be performed on a back link.
//
#define ERROR_DS_NOT_ON_BACKLINK 8362L

//
// MessageId: ERROR_DS_NO_CROSSREF_FOR_NC
//
// MessageText:
//
// The cross reference for the specified naming context could not be found.
//
#define ERROR_DS_NO_CROSSREF_FOR_NC 8363L

//
// MessageId: ERROR_DS_SHUTTING_DOWN
//
// MessageText:
//
// The operation could not be performed because the directory service is shutting down.
//
#define ERROR_DS_SHUTTING_DOWN 8364L

//
// MessageId: ERROR_DS_UNKNOWN_OPERATION
//
// MessageText:
//
// The directory service request is invalid.
//
#define ERROR_DS_UNKNOWN_OPERATION 8365L

//
// MessageId: ERROR_DS_INVALID_ROLE_OWNER
//
// MessageText:
//
// The role owner attribute could not be read.
//
#define ERROR_DS_INVALID_ROLE_OWNER 8366L

//
// MessageId: ERROR_DS_COULDNT_CONTACT_FSMO
//
// MessageText:
//
// The requested FSMO operation failed. The current FSMO holder could not be contacted.
//
#define ERROR_DS_COULDNT_CONTACT_FSMO 8367L

//
// MessageId: ERROR_DS_CROSS_NC_DN_RENAME
//
// MessageText:
//
// Modification of a DN across a naming context is not permitted.
//
#define ERROR_DS_CROSS_NC_DN_RENAME 8368L

//
// MessageId: ERROR_DS_CANT_MOD_SYSTEM_ONLY
//
// MessageText:
//
// The attribute cannot be modified because it is owned by the system.
//
#define ERROR_DS_CANT_MOD_SYSTEM_ONLY 8369L

//
// MessageId: ERROR_DS_REPLICATOR_ONLY
//
// MessageText:
//
// Only the replicator can perform this function.
//
#define ERROR_DS_REPLICATOR_ONLY 8370L

//
// MessageId: ERROR_DS_OBJ_CLASS_NOT_DEFINED
//
// MessageText:
//
// The specified class is not defined.
//
#define ERROR_DS_OBJ_CLASS_NOT_DEFINED 8371L

//
// MessageId: ERROR_DS_OBJ_CLASS_NOT_SUBCLASS
//
// MessageText:
//
// The specified class is not a subclass.
//
#define ERROR_DS_OBJ_CLASS_NOT_SUBCLASS 8372L

//
// MessageId: ERROR_DS_NAME_REFERENCE_INVALID
//
// MessageText:
//
// The name reference is invalid.
//
#define ERROR_DS_NAME_REFERENCE_INVALID 8373L

//
// MessageId: ERROR_DS_CROSS_REF_EXISTS
//
// MessageText:
//
// A cross reference already exists.
//
#define ERROR_DS_CROSS_REF_EXISTS 8374L

//
// MessageId: ERROR_DS_CANT_DEL_MASTER_CROSSREF
//
// MessageText:
//
// It is not permitted to delete a master cross reference.
//
#define ERROR_DS_CANT_DEL_MASTER_CROSSREF 8375L

//
// MessageId: ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD
//
// MessageText:
//
// Subtree notifications are only supported on NC heads.
//
#define ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD 8376L

//
// MessageId: ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX
//
// MessageText:
//
// Notification filter is too complex.
//
#define ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX 8377L

//
// MessageId: ERROR_DS_DUP_RDN
//
// MessageText:
//
// Schema update failed: duplicate RDN.
//
#define ERROR_DS_DUP_RDN 8378L

//
// MessageId: ERROR_DS_DUP_OID
//
// MessageText:
//
// Schema update failed: duplicate OID.
//
#define ERROR_DS_DUP_OID 8379L

//
// MessageId: ERROR_DS_DUP_MAPI_ID
//
// MessageText:
//
// Schema update failed: duplicate MAPI identifier.
//
#define ERROR_DS_DUP_MAPI_ID 8380L

//
// MessageId: ERROR_DS_DUP_SCHEMA_ID_GUID
//
// MessageText:
//
// Schema update failed: duplicate schema-id GUID.
//
#define ERROR_DS_DUP_SCHEMA_ID_GUID 8381L

//
// MessageId: ERROR_DS_DUP_LDAP_DISPLAY_NAME
//
// MessageText:
//
// Schema update failed: duplicate LDAP display name.
//
#define ERROR_DS_DUP_LDAP_DISPLAY_NAME 8382L

//
// MessageId: ERROR_DS_SEMANTIC_ATT_TEST
//
// MessageText:
//
// Schema update failed: range-lower less than range upper.
//
#define ERROR_DS_SEMANTIC_ATT_TEST 8383L

//
// MessageId: ERROR_DS_SYNTAX_MISMATCH
//
// MessageText:
//
// Schema update failed: syntax mismatch.
//
#define ERROR_DS_SYNTAX_MISMATCH 8384L

//
// MessageId: ERROR_DS_EXISTS_IN_MUST_HAVE
//
// MessageText:
//
// Schema deletion failed: attribute is used in must-contain.
//
#define ERROR_DS_EXISTS_IN_MUST_HAVE 8385L

//
// MessageId: ERROR_DS_EXISTS_IN_MAY_HAVE
//
// MessageText:
//
// Schema deletion failed: attribute is used in may-contain.
//
#define ERROR_DS_EXISTS_IN_MAY_HAVE 8386L

//
// MessageId: ERROR_DS_NONEXISTENT_MAY_HAVE
//
// MessageText:
//
// Schema update failed: attribute in may-contain does not exist.
//
#define ERROR_DS_NONEXISTENT_MAY_HAVE 8387L

//
// MessageId: ERROR_DS_NONEXISTENT_MUST_HAVE
//
// MessageText:
//
// Schema update failed: attribute in must-contain does not exist.
//
#define ERROR_DS_NONEXISTENT_MUST_HAVE 8388L

//
// MessageId: ERROR_DS_AUX_CLS_TEST_FAIL
//
// MessageText:
//
// Schema update failed: class in aux-class list does not exist or is not an auxiliary class.
//
#define ERROR_DS_AUX_CLS_TEST_FAIL 8389L

//
// MessageId: ERROR_DS_NONEXISTENT_POSS_SUP
//
// MessageText:
//
// Schema update failed: class in poss-superiors does not exist.
//
#define ERROR_DS_NONEXISTENT_POSS_SUP 8390L

//
// MessageId: ERROR_DS_SUB_CLS_TEST_FAIL
//
// MessageText:
//
// Schema update failed: class in subclassof list does not exist or does not satisfy hierarchy rules.
//
#define ERROR_DS_SUB_CLS_TEST_FAIL 8391L

//
// MessageId: ERROR_DS_BAD_RDN_ATT_ID_SYNTAX
//
// MessageText:
//
// Schema update failed: Rdn-Att-Id has wrong syntax.
//
#define ERROR_DS_BAD_RDN_ATT_ID_SYNTAX 8392L

//
// MessageId: ERROR_DS_EXISTS_IN_AUX_CLS
//
// MessageText:
//
// Schema deletion failed: class is used as auxiliary class.
//
#define ERROR_DS_EXISTS_IN_AUX_CLS 8393L

//
// MessageId: ERROR_DS_EXISTS_IN_SUB_CLS
//
// MessageText:
//
// Schema deletion failed: class is used as sub class.
//
#define ERROR_DS_EXISTS_IN_SUB_CLS 8394L

//
// MessageId: ERROR_DS_EXISTS_IN_POSS_SUP
//
// MessageText:
//
// Schema deletion failed: class is used as poss superior.
//
#define ERROR_DS_EXISTS_IN_POSS_SUP 8395L

//
// MessageId: ERROR_DS_RECALCSCHEMA_FAILED
//
// MessageText:
//
// Schema update failed in recalculating validation cache.
//
#define ERROR_DS_RECALCSCHEMA_FAILED 8396L

//
// MessageId: ERROR_DS_TREE_DELETE_NOT_FINISHED
//
// MessageText:
//
// The tree deletion is not finished. The request must be made again to continue deleting the tree.
//
#define ERROR_DS_TREE_DELETE_NOT_FINISHED 8397L

//
// MessageId: ERROR_DS_CANT_DELETE
//
// MessageText:
//
// The requested delete operation could not be performed.
//
#define ERROR_DS_CANT_DELETE 8398L

//
// MessageId: ERROR_DS_ATT_SCHEMA_REQ_ID
//
// MessageText:
//
// Cannot read the governs class identifier for the schema record.
//
#define ERROR_DS_ATT_SCHEMA_REQ_ID 8399L

//
// MessageId: ERROR_DS_BAD_ATT_SCHEMA_SYNTAX
//
// MessageText:
//
// The attribute schema has bad syntax.
//
#define ERROR_DS_BAD_ATT_SCHEMA_SYNTAX 8400L

//
// MessageId: ERROR_DS_CANT_CACHE_ATT
//
// MessageText:
//
// The attribute could not be cached.
//
#define ERROR_DS_CANT_CACHE_ATT 8401L

//
// MessageId: ERROR_DS_CANT_CACHE_CLASS
//
// MessageText:
//
// The class could not be cached.
//
#define ERROR_DS_CANT_CACHE_CLASS 8402L

//
// MessageId: ERROR_DS_CANT_REMOVE_ATT_CACHE
//
// MessageText:
//
// The attribute could not be removed from the cache.
//
#define ERROR_DS_CANT_REMOVE_ATT_CACHE 8403L

//
// MessageId: ERROR_DS_CANT_REMOVE_CLASS_CACHE
//
// MessageText:
//
// The class could not be removed from the cache.
//
#define ERROR_DS_CANT_REMOVE_CLASS_CACHE 8404L

//
// MessageId: ERROR_DS_CANT_RETRIEVE_DN
//
// MessageText:
//
// The distinguished name attribute could not be read.
//
#define ERROR_DS_CANT_RETRIEVE_DN 8405L

//
// MessageId: ERROR_DS_MISSING_SUPREF
//
// MessageText:
//
// No superior reference has been configured for the directory service. The directory service is therefore unable to issue referrals to objects outside this forest.
//
#define ERROR_DS_MISSING_SUPREF 8406L

//
// MessageId: ERROR_DS_CANT_RETRIEVE_INSTANCE
//
// MessageText:
//
// The instance type attribute could not be retrieved.
//
#define ERROR_DS_CANT_RETRIEVE_INSTANCE 8407L

//
// MessageId: ERROR_DS_CODE_INCONSISTENCY
//
// MessageText:
//
// An internal error has occurred.
//
#define ERROR_DS_CODE_INCONSISTENCY 8408L

//
// MessageId: ERROR_DS_DATABASE_ERROR
//
// MessageText:
//
// A database error has occurred.
//
#define ERROR_DS_DATABASE_ERROR 8409L

//
// MessageId: ERROR_DS_GOVERNSID_MISSING
//
// MessageText:
//
// The attribute GOVERNSID is missing.
//
#define ERROR_DS_GOVERNSID_MISSING 8410L

//
// MessageId: ERROR_DS_MISSING_EXPECTED_ATT
//
// MessageText:
//
// An expected attribute is missing.
//
#define ERROR_DS_MISSING_EXPECTED_ATT 8411L

//
// MessageId: ERROR_DS_NCNAME_MISSING_CR_REF
//
// MessageText:
//
// The specified naming context is missing a cross reference.
//
#define ERROR_DS_NCNAME_MISSING_CR_REF 8412L

//
// MessageId: ERROR_DS_SECURITY_CHECKING_ERROR
//
// MessageText:
//
// A security checking error has occurred.
//
#define ERROR_DS_SECURITY_CHECKING_ERROR 8413L

//
// MessageId: ERROR_DS_SCHEMA_NOT_LOADED
//
// MessageText:
//
// The schema is not loaded.
//
#define ERROR_DS_SCHEMA_NOT_LOADED 8414L

//
// MessageId: ERROR_DS_SCHEMA_ALLOC_FAILED
//
// MessageText:
//
// Schema allocation failed. Please check if the machine is running low on memory.
//
#define ERROR_DS_SCHEMA_ALLOC_FAILED 8415L

//
// MessageId: ERROR_DS_ATT_SCHEMA_REQ_SYNTAX
//
// MessageText:
//
// Failed to obtain the required syntax for the attribute schema.
//
#define ERROR_DS_ATT_SCHEMA_REQ_SYNTAX 8416L

//
// MessageId: ERROR_DS_GCVERIFY_ERROR
//
// MessageText:
//
// The global catalog verification failed. The global catalog is not available or does not support the operation. Some part of the directory is currently not available.
//
#define ERROR_DS_GCVERIFY_ERROR 8417L

//
// MessageId: ERROR_DS_DRA_SCHEMA_MISMATCH
//
// MessageText:
//
// The replication operation failed because of a schema mismatch between the servers involved.
//
#define ERROR_DS_DRA_SCHEMA_MISMATCH 8418L

//
// MessageId: ERROR_DS_CANT_FIND_DSA_OBJ
//
// MessageText:
//
// The DSA object could not be found.
//
#define ERROR_DS_CANT_FIND_DSA_OBJ 8419L

//
// MessageId: ERROR_DS_CANT_FIND_EXPECTED_NC
//
// MessageText:
//
// The naming context could not be found.
//
#define ERROR_DS_CANT_FIND_EXPECTED_NC 8420L

//
// MessageId: ERROR_DS_CANT_FIND_NC_IN_CACHE
//
// MessageText:
//
// The naming context could not be found in the cache.
//
#define ERROR_DS_CANT_FIND_NC_IN_CACHE 8421L

//
// MessageId: ERROR_DS_CANT_RETRIEVE_CHILD
//
// MessageText:
//
// The child object could not be retrieved.
//
#define ERROR_DS_CANT_RETRIEVE_CHILD 8422L

//
// MessageId: ERROR_DS_SECURITY_ILLEGAL_MODIFY
//
// MessageText:
//
// The modification was not permitted for security reasons.
//
#define ERROR_DS_SECURITY_ILLEGAL_MODIFY 8423L

//
// MessageId: ERROR_DS_CANT_REPLACE_HIDDEN_REC
//
// MessageText:
//
// The operation cannot replace the hidden record.
//
#define ERROR_DS_CANT_REPLACE_HIDDEN_REC 8424L

//
// MessageId: ERROR_DS_BAD_HIERARCHY_FILE
//
// MessageText:
//
// The hierarchy file is invalid.
//
#define ERROR_DS_BAD_HIERARCHY_FILE 8425L

//
// MessageId: ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED
//
// MessageText:
//
// The attempt to build the hierarchy table failed.
//
#define ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED 8426L

//
// MessageId: ERROR_DS_CONFIG_PARAM_MISSING
//
// MessageText:
//
// The directory configuration parameter is missing from the registry.
//
#define ERROR_DS_CONFIG_PARAM_MISSING 8427L

//
// MessageId: ERROR_DS_COUNTING_AB_INDICES_FAILED
//
// MessageText:
//
// The attempt to count the address book indices failed.
//
#define ERROR_DS_COUNTING_AB_INDICES_FAILED 8428L

//
// MessageId: ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED
//
// MessageText:
//
// The allocation of the hierarchy table failed.
//
#define ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED 8429L

//
// MessageId: ERROR_DS_INTERNAL_FAILURE
//
// MessageText:
//
// The directory service encountered an internal failure.
//
#define ERROR_DS_INTERNAL_FAILURE 8430L

//
// MessageId: ERROR_DS_UNKNOWN_ERROR
//
// MessageText:
//
// The directory service encountered an unknown failure.
//
#define ERROR_DS_UNKNOWN_ERROR 8431L

//
// MessageId: ERROR_DS_ROOT_REQUIRES_CLASS_TOP
//
// MessageText:
//
// A root object requires a class of 'top'.
//
#define ERROR_DS_ROOT_REQUIRES_CLASS_TOP 8432L

//
// MessageId: ERROR_DS_REFUSING_FSMO_ROLES
//
// MessageText:
//
// This directory server is shutting down, and cannot take ownership of new floating single-master operation roles.
//
#define ERROR_DS_REFUSING_FSMO_ROLES 8433L

//
// MessageId: ERROR_DS_MISSING_FSMO_SETTINGS
//
// MessageText:
//
// The directory service is missing mandatory configuration information, and is unable to determine the ownership of floating single-master operation roles.
//
#define ERROR_DS_MISSING_FSMO_SETTINGS 8434L

//
// MessageId: ERROR_DS_UNABLE_TO_SURRENDER_ROLES
//
// MessageText:
//
// The directory service was unable to transfer ownership of one or more floating single-master operation roles to other servers.
//
#define ERROR_DS_UNABLE_TO_SURRENDER_ROLES 8435L

//
// MessageId: ERROR_DS_DRA_GENERIC
//
// MessageText:
//
// The replication operation failed.
//
#define ERROR_DS_DRA_GENERIC 8436L

//
// MessageId: ERROR_DS_DRA_INVALID_PARAMETER
//
// MessageText:
//
// An invalid parameter was specified for this replication operation.
//
#define ERROR_DS_DRA_INVALID_PARAMETER 8437L

//
// MessageId: ERROR_DS_DRA_BUSY
//
// MessageText:
//
// The directory service is too busy to complete the replication operation at this time.
//
#define ERROR_DS_DRA_BUSY 8438L

//
// MessageId: ERROR_DS_DRA_BAD_DN
//
// MessageText:
//
// The distinguished name specified for this replication operation is invalid.
//
#define ERROR_DS_DRA_BAD_DN 8439L

//
// MessageId: ERROR_DS_DRA_BAD_NC
//
// MessageText:
//
// The naming context specified for this replication operation is invalid.
//
#define ERROR_DS_DRA_BAD_NC 8440L

//
// MessageId: ERROR_DS_DRA_DN_EXISTS
//
// MessageText:
//
// The distinguished name specified for this replication operation already exists.
//
#define ERROR_DS_DRA_DN_EXISTS 8441L

//
// MessageId: ERROR_DS_DRA_INTERNAL_ERROR
//
// MessageText:
//
// The replication system encountered an internal error.
//
#define ERROR_DS_DRA_INTERNAL_ERROR 8442L

//
// MessageId: ERROR_DS_DRA_INCONSISTENT_DIT
//
// MessageText:
//
// The replication operation encountered a database inconsistency.
//
#define ERROR_DS_DRA_INCONSISTENT_DIT 8443L

//
// MessageId: ERROR_DS_DRA_CONNECTION_FAILED
//
// MessageText:
//
// The server specified for this replication operation could not be contacted.
//
#define ERROR_DS_DRA_CONNECTION_FAILED 8444L

//
// MessageId: ERROR_DS_DRA_BAD_INSTANCE_TYPE
//
// MessageText:
//
// The replication operation encountered an object with an invalid instance type.
//
#define ERROR_DS_DRA_BAD_INSTANCE_TYPE 8445L

//
// MessageId: ERROR_DS_DRA_OUT_OF_MEM
//
// MessageText:
//
// The replication operation failed to allocate memory.
//
#define ERROR_DS_DRA_OUT_OF_MEM 8446L

//
// MessageId: ERROR_DS_DRA_MAIL_PROBLEM
//
// MessageText:
//
// The replication operation encountered an error with the mail system.
//
#define ERROR_DS_DRA_MAIL_PROBLEM 8447L

//
// MessageId: ERROR_DS_DRA_REF_ALREADY_EXISTS
//
// MessageText:
//
// The replication reference information for the target server already exists.
//
#define ERROR_DS_DRA_REF_ALREADY_EXISTS 8448L

//
// MessageId: ERROR_DS_DRA_REF_NOT_FOUND
//
// MessageText:
//
// The replication reference information for the target server does not exist.
//
#define ERROR_DS_DRA_REF_NOT_FOUND 8449L

//
// MessageId: ERROR_DS_DRA_OBJ_IS_REP_SOURCE
//
// MessageText:
//
// The naming context cannot be removed because it is replicated to another server.
//
#define ERROR_DS_DRA_OBJ_IS_REP_SOURCE 8450L

//
// MessageId: ERROR_DS_DRA_DB_ERROR
//
// MessageText:
//
// The replication operation encountered a database error.
//
#define ERROR_DS_DRA_DB_ERROR 8451L

//
// MessageId: ERROR_DS_DRA_NO_REPLICA
//
// MessageText:
//
// The naming context is in the process of being removed or is not replicated from the specified server.
//
#define ERROR_DS_DRA_NO_REPLICA 8452L

//
// MessageId: ERROR_DS_DRA_ACCESS_DENIED
//
// MessageText:
//
// Replication access was denied.
//
#define ERROR_DS_DRA_ACCESS_DENIED 8453L

//
// MessageId: ERROR_DS_DRA_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported by this version of the directory service.
//
#define ERROR_DS_DRA_NOT_SUPPORTED 8454L

//
// MessageId: ERROR_DS_DRA_RPC_CANCELLED
//
// MessageText:
//
// The replication remote procedure call was cancelled.
//
#define ERROR_DS_DRA_RPC_CANCELLED 8455L

//
// MessageId: ERROR_DS_DRA_SOURCE_DISABLED
//
// MessageText:
//
// The source server is currently rejecting replication requests.
//
#define ERROR_DS_DRA_SOURCE_DISABLED 8456L

//
// MessageId: ERROR_DS_DRA_SINK_DISABLED
//
// MessageText:
//
// The destination server is currently rejecting replication requests.
//
#define ERROR_DS_DRA_SINK_DISABLED 8457L

//
// MessageId: ERROR_DS_DRA_NAME_COLLISION
//
// MessageText:
//
// The replication operation failed due to a collision of object names.
//
#define ERROR_DS_DRA_NAME_COLLISION 8458L

//
// MessageId: ERROR_DS_DRA_SOURCE_REINSTALLED
//
// MessageText:
//
// The replication source has been reinstalled.
//
#define ERROR_DS_DRA_SOURCE_REINSTALLED 8459L

//
// MessageId: ERROR_DS_DRA_MISSING_PARENT
//
// MessageText:
//
// The replication operation failed because a required parent object is missing.
//
#define ERROR_DS_DRA_MISSING_PARENT 8460L

//
// MessageId: ERROR_DS_DRA_PREEMPTED
//
// MessageText:
//
// The replication operation was preempted.
//
#define ERROR_DS_DRA_PREEMPTED 8461L

//
// MessageId: ERROR_DS_DRA_ABANDON_SYNC
//
// MessageText:
//
// The replication synchronization attempt was abandoned because of a lack of updates.
//
#define ERROR_DS_DRA_ABANDON_SYNC 8462L

//
// MessageId: ERROR_DS_DRA_SHUTDOWN
//
// MessageText:
//
// The replication operation was terminated because the system is shutting down.
//
#define ERROR_DS_DRA_SHUTDOWN 8463L

//
// MessageId: ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET
//
// MessageText:
//
// Synchronization attempt failed because the destination DC is currently waiting to synchronize new partial attributes from source. This condition is normal if a recent schema change modified the partial attribute set. The destination partial attribute set is not a subset of source partial attribute set.
//
#define ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET 8464L

//
// MessageId: ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA
//
// MessageText:
//
// The replication synchronization attempt failed because a master replica attempted to sync from a partial replica.
//
#define ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA 8465L

//
// MessageId: ERROR_DS_DRA_EXTN_CONNECTION_FAILED
//
// MessageText:
//
// The server specified for this replication operation was contacted, but that server was unable to contact an additional server needed to complete the operation.
//
#define ERROR_DS_DRA_EXTN_CONNECTION_FAILED 8466L

//
// MessageId: ERROR_DS_INSTALL_SCHEMA_MISMATCH
//
// MessageText:
//
// The version of the directory service schema of the source forest is not compatible with the version of directory service on this computer.
//
#define ERROR_DS_INSTALL_SCHEMA_MISMATCH 8467L

//
// MessageId: ERROR_DS_DUP_LINK_ID
//
// MessageText:
//
// Schema update failed: An attribute with the same link identifier already exists.
//
#define ERROR_DS_DUP_LINK_ID 8468L

//
// MessageId: ERROR_DS_NAME_ERROR_RESOLVING
//
// MessageText:
//
// Name translation: Generic processing error.
//
#define ERROR_DS_NAME_ERROR_RESOLVING 8469L

//
// MessageId: ERROR_DS_NAME_ERROR_NOT_FOUND
//
// MessageText:
//
// Name translation: Could not find the name or insufficient right to see name.
//
#define ERROR_DS_NAME_ERROR_NOT_FOUND 8470L

//
// MessageId: ERROR_DS_NAME_ERROR_NOT_UNIQUE
//
// MessageText:
//
// Name translation: Input name mapped to more than one output name.
//
#define ERROR_DS_NAME_ERROR_NOT_UNIQUE 8471L

//
// MessageId: ERROR_DS_NAME_ERROR_NO_MAPPING
//
// MessageText:
//
// Name translation: Input name found, but not the associated output format.
//
#define ERROR_DS_NAME_ERROR_NO_MAPPING 8472L

//
// MessageId: ERROR_DS_NAME_ERROR_DOMAIN_ONLY
//
// MessageText:
//
// Name translation: Unable to resolve completely, only the domain was found.
//
#define ERROR_DS_NAME_ERROR_DOMAIN_ONLY 8473L

//
// MessageId: ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
//
// MessageText:
//
// Name translation: Unable to perform purely syntactical mapping at the client without going out to the wire.
//
#define ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING 8474L

//
// MessageId: ERROR_DS_CONSTRUCTED_ATT_MOD
//
// MessageText:
//
// Modification of a constructed attribute is not allowed.
//
#define ERROR_DS_CONSTRUCTED_ATT_MOD 8475L

//
// MessageId: ERROR_DS_WRONG_OM_OBJ_CLASS
//
// MessageText:
//
// The OM-Object-Class specified is incorrect for an attribute with the specified syntax.
//
#define ERROR_DS_WRONG_OM_OBJ_CLASS 8476L

//
// MessageId: ERROR_DS_DRA_REPL_PENDING
//
// MessageText:
//
// The replication request has been posted; waiting for reply.
//
#define ERROR_DS_DRA_REPL_PENDING 8477L

//
// MessageId: ERROR_DS_DS_REQUIRED
//
// MessageText:
//
// The requested operation requires a directory service, and none was available.
//
#define ERROR_DS_DS_REQUIRED 8478L

//
// MessageId: ERROR_DS_INVALID_LDAP_DISPLAY_NAME
//
// MessageText:
//
// The LDAP display name of the class or attribute contains non-ASCII characters.
//
#define ERROR_DS_INVALID_LDAP_DISPLAY_NAME 8479L

//
// MessageId: ERROR_DS_NON_BASE_SEARCH
//
// MessageText:
//
// The requested search operation is only supported for base searches.
//
#define ERROR_DS_NON_BASE_SEARCH 8480L

//
// MessageId: ERROR_DS_CANT_RETRIEVE_ATTS
//
// MessageText:
//
// The search failed to retrieve attributes from the database.
//
#define ERROR_DS_CANT_RETRIEVE_ATTS 8481L

//
// MessageId: ERROR_DS_BACKLINK_WITHOUT_LINK
//
// MessageText:
//
// The schema update operation tried to add a backward link attribute that has no corresponding forward link.
//
#define ERROR_DS_BACKLINK_WITHOUT_LINK 8482L

//
// MessageId: ERROR_DS_EPOCH_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the object's epoch number. Either source or destination does not have the latest version of the object.
//
#define ERROR_DS_EPOCH_MISMATCH 8483L

//
// MessageId: ERROR_DS_SRC_NAME_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the object's current name. Either source or destination does not have the latest version of the object.
//
#define ERROR_DS_SRC_NAME_MISMATCH 8484L

//
// MessageId: ERROR_DS_SRC_AND_DST_NC_IDENTICAL
//
// MessageText:
//
// Source and destination for the cross-domain move operation are identical. Caller should use local move operation instead of cross-domain move operation.
//
#define ERROR_DS_SRC_AND_DST_NC_IDENTICAL 8485L

//
// MessageId: ERROR_DS_DST_NC_MISMATCH
//
// MessageText:
//
// Source and destination for a cross-domain move are not in agreement on the naming contexts in the forest. Either source or destination does not have the latest version of the Partitions container.
//
#define ERROR_DS_DST_NC_MISMATCH 8486L

//
// MessageId: ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC
//
// MessageText:
//
// Destination of a cross-domain move is not authoritative for the destination naming context.
//
#define ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC 8487L

//
// MessageId: ERROR_DS_SRC_GUID_MISMATCH
//
// MessageText:
//
// Source and destination of a cross-domain move do not agree on the identity of the source object. Either source or destination does not have the latest version of the source object.
//
#define ERROR_DS_SRC_GUID_MISMATCH 8488L

//
// MessageId: ERROR_DS_CANT_MOVE_DELETED_OBJECT
//
// MessageText:
//
// Object being moved across-domains is already known to be deleted by the destination server. The source server does not have the latest version of the source object.
//
#define ERROR_DS_CANT_MOVE_DELETED_OBJECT 8489L

//
// MessageId: ERROR_DS_PDC_OPERATION_IN_PROGRESS
//
// MessageText:
//
// Another operation which requires exclusive access to the PDC FSMO is already in progress.
//
#define ERROR_DS_PDC_OPERATION_IN_PROGRESS 8490L

//
// MessageId: ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD
//
// MessageText:
//
// A cross-domain move operation failed such that two versions of the moved object exist - one each in the source and destination domains. The destination object needs to be removed to restore the system to a consistent state.
//
#define ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD 8491L

//
// MessageId: ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION
//
// MessageText:
//
// This object may not be moved across domain boundaries either because cross-domain moves for this class are disallowed, or the object has some special characteristics, e.g.: trust account or restricted RID, which prevent its move.
//
#define ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION 8492L

//
// MessageId: ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS
//
// MessageText:
//
// Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group. Remove the object from any account group memberships and retry.
//
#define ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS 8493L

//
// MessageId: ERROR_DS_NC_MUST_HAVE_NC_PARENT
//
// MessageText:
//
// A naming context head must be the immediate child of another naming context head, not of an interior node.
//
#define ERROR_DS_NC_MUST_HAVE_NC_PARENT 8494L

//
// MessageId: ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE
//
// MessageText:
//
// The directory cannot validate the proposed naming context name because it does not hold a replica of the naming context above the proposed naming context. Please ensure that the domain naming master role is held by a server that is configured as a global catalog server, and that the server is up to date with its replication partners. (Applies only to Windows 2000 Domain Naming masters)
//
#define ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE 8495L

//
// MessageId: ERROR_DS_DST_DOMAIN_NOT_NATIVE
//
// MessageText:
//
// Destination domain must be in native mode.
//
#define ERROR_DS_DST_DOMAIN_NOT_NATIVE 8496L

//
// MessageId: ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER
//
// MessageText:
//
// The operation cannot be performed because the server does not have an infrastructure container in the domain of interest.
//
#define ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER 8497L

//
// MessageId: ERROR_DS_CANT_MOVE_ACCOUNT_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty account groups is not allowed.
//
#define ERROR_DS_CANT_MOVE_ACCOUNT_GROUP 8498L

//
// MessageId: ERROR_DS_CANT_MOVE_RESOURCE_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty resource groups is not allowed.
//
#define ERROR_DS_CANT_MOVE_RESOURCE_GROUP 8499L

//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG
//
// MessageText:
//
// The search flags for the attribute are invalid. The ANR bit is valid only on attributes of Unicode or Teletex strings.
//
#define ERROR_DS_INVALID_SEARCH_FLAG 8500L

//
// MessageId: ERROR_DS_NO_TREE_DELETE_ABOVE_NC
//
// MessageText:
//
// Tree deletions starting at an object which has an NC head as a descendant are not allowed.
//
#define ERROR_DS_NO_TREE_DELETE_ABOVE_NC 8501L

//
// MessageId: ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE
//
// MessageText:
//
// The directory service failed to lock a tree in preparation for a tree deletion because the tree was in use.
//
#define ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE 8502L

//
// MessageId: ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE
//
// MessageText:
//
// The directory service failed to identify the list of objects to delete while attempting a tree deletion.
//
#define ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE 8503L

//
// MessageId: ERROR_DS_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Please shutdown this system and reboot into Directory Services Restore Mode, check the event log for more detailed information.
//
#define ERROR_DS_SAM_INIT_FAILURE 8504L

//
// MessageId: ERROR_DS_SENSITIVE_GROUP_VIOLATION
//
// MessageText:
//
// Only an administrator can modify the membership list of an administrative group.
//
#define ERROR_DS_SENSITIVE_GROUP_VIOLATION 8505L

//
// MessageId: ERROR_DS_CANT_MOD_PRIMARYGROUPID
//
// MessageText:
//
// Cannot change the primary group ID of a domain controller account.
//
#define ERROR_DS_CANT_MOD_PRIMARYGROUPID 8506L

//
// MessageId: ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD
//
// MessageText:
//
// An attempt is made to modify the base schema.
//
#define ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD 8507L

//
// MessageId: ERROR_DS_NONSAFE_SCHEMA_CHANGE
//
// MessageText:
//
// Adding a new mandatory attribute to an existing class, deleting a mandatory attribute from an existing class, or adding an optional attribute to the special class Top that is not a backlink attribute (directly or through inheritance, for example, by adding or deleting an auxiliary class) is not allowed.
//
#define ERROR_DS_NONSAFE_SCHEMA_CHANGE 8508L

//
// MessageId: ERROR_DS_SCHEMA_UPDATE_DISALLOWED
//
// MessageText:
//
// Schema update is not allowed on this DC because the DC is not the schema FSMO Role Owner.
//
#define ERROR_DS_SCHEMA_UPDATE_DISALLOWED 8509L

//
// MessageId: ERROR_DS_CANT_CREATE_UNDER_SCHEMA
//
// MessageText:
//
// An object of this class cannot be created under the schema container. You can only create attribute-schema and class-schema objects under the schema container.
//
#define ERROR_DS_CANT_CREATE_UNDER_SCHEMA 8510L

//
// MessageId: ERROR_DS_INSTALL_NO_SRC_SCH_VERSION
//
// MessageText:
//
// The replica/child install failed to get the objectVersion attribute on the schema container on the source DC. Either the attribute is missing on the schema container or the credentials supplied do not have permission to read it.
//
#define ERROR_DS_INSTALL_NO_SRC_SCH_VERSION 8511L

//
// MessageId: ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE
//
// MessageText:
//
// The replica/child install failed to read the objectVersion attribute in the SCHEMA section of the file schema.ini in the system32 directory.
//
#define ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE 8512L

//
// MessageId: ERROR_DS_INVALID_GROUP_TYPE
//
// MessageText:
//
// The specified group type is invalid.
//
#define ERROR_DS_INVALID_GROUP_TYPE 8513L

//
// MessageId: ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// You cannot nest global groups in a mixed domain if the group is security-enabled.
//
#define ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN 8514L

//
// MessageId: ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// You cannot nest local groups in a mixed domain if the group is security-enabled.
//
#define ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN 8515L

//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A global group cannot have a local group as a member.
//
#define ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER 8516L

//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// A global group cannot have a universal group as a member.
//
#define ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER 8517L

//
// MessageId: ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A universal group cannot have a local group as a member.
//
#define ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER 8518L

//
// MessageId: ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER
//
// MessageText:
//
// A global group cannot have a cross-domain member.
//
#define ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER 8519L

//
// MessageId: ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER
//
// MessageText:
//
// A local group cannot have another cross domain local group as a member.
//
#define ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER 8520L

//
// MessageId: ERROR_DS_HAVE_PRIMARY_MEMBERS
//
// MessageText:
//
// A group with primary members cannot change to a security-disabled group.
//
#define ERROR_DS_HAVE_PRIMARY_MEMBERS 8521L

//
// MessageId: ERROR_DS_STRING_SD_CONVERSION_FAILED
//
// MessageText:
//
// The schema cache load failed to convert the string default SD on a class-schema object.
//
#define ERROR_DS_STRING_SD_CONVERSION_FAILED 8522L

//
// MessageId: ERROR_DS_NAMING_MASTER_GC
//
// MessageText:
//
// Only DSAs configured to be Global Catalog servers should be allowed to hold the Domain Naming Master FSMO role. (Applies only to Windows 2000 servers)
//
#define ERROR_DS_NAMING_MASTER_GC 8523L

//
// MessageId: ERROR_DS_DNS_LOOKUP_FAILURE
//
// MessageText:
//
// The DSA operation is unable to proceed because of a DNS lookup failure.
//
#define ERROR_DS_DNS_LOOKUP_FAILURE 8524L

//
// MessageId: ERROR_DS_COULDNT_UPDATE_SPNS
//
// MessageText:
//
// While processing a change to the DNS Host Name for an object, the Service Principal Name values could not be kept in sync.
//
#define ERROR_DS_COULDNT_UPDATE_SPNS 8525L

//
// MessageId: ERROR_DS_CANT_RETRIEVE_SD
//
// MessageText:
//
// The Security Descriptor attribute could not be read.
//
#define ERROR_DS_CANT_RETRIEVE_SD 8526L

//
// MessageId: ERROR_DS_KEY_NOT_UNIQUE
//
// MessageText:
//
// The object requested was not found, but an object with that key was found.
//
#define ERROR_DS_KEY_NOT_UNIQUE 8527L

//
// MessageId: ERROR_DS_WRONG_LINKED_ATT_SYNTAX
//
// MessageText:
//
// The syntax of the linked attribute being added is incorrect. Forward links can only have syntax 2.5.5.1, 2.5.5.7, and 2.5.5.14, and backlinks can only have syntax 2.5.5.1
//
#define ERROR_DS_WRONG_LINKED_ATT_SYNTAX 8528L

//
// MessageId: ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD
//
// MessageText:
//
// Security Account Manager needs to get the boot password.
//
#define ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD 8529L

//
// MessageId: ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY
//
// MessageText:
//
// Security Account Manager needs to get the boot key from floppy disk.
//
#define ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY 8530L

//
// MessageId: ERROR_DS_CANT_START
//
// MessageText:
//
// Directory Service cannot start.
//
#define ERROR_DS_CANT_START 8531L

//
// MessageId: ERROR_DS_INIT_FAILURE
//
// MessageText:
//
// Directory Services could not start.
//
#define ERROR_DS_INIT_FAILURE 8532L

//
// MessageId: ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION
//
// MessageText:
//
// The connection between client and server requires packet privacy or better.
//
#define ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION 8533L

//
// MessageId: ERROR_DS_SOURCE_DOMAIN_IN_FOREST
//
// MessageText:
//
// The source domain may not be in the same forest as destination.
//
#define ERROR_DS_SOURCE_DOMAIN_IN_FOREST 8534L

//
// MessageId: ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST
//
// MessageText:
//
// The destination domain must be in the forest.
//
#define ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST 8535L

//
// MessageId: ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED
//
// MessageText:
//
// The operation requires that destination domain auditing be enabled.
//
#define ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED 8536L

//
// MessageId: ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN
//
// MessageText:
//
// The operation couldn't locate a DC for the source domain.
//
#define ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN 8537L

//
// MessageId: ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER
//
// MessageText:
//
// The source object must be a group or user.
//
#define ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER 8538L

//
// MessageId: ERROR_DS_SRC_SID_EXISTS_IN_FOREST
//
// MessageText:
//
// The source object's SID already exists in destination forest.
//
#define ERROR_DS_SRC_SID_EXISTS_IN_FOREST 8539L

//
// MessageId: ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH
//
// MessageText:
//
// The source and destination object must be of the same type.
//
#define ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH 8540L

//
// MessageId: ERROR_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Click OK to shut down the system and reboot into Safe Mode. Check the event log for detailed information.
//
#define ERROR_SAM_INIT_FAILURE 8541L

//
// MessageId: ERROR_DS_DRA_SCHEMA_INFO_SHIP
//
// MessageText:
//
// Schema information could not be included in the replication request.
//
#define ERROR_DS_DRA_SCHEMA_INFO_SHIP 8542L

//
// MessageId: ERROR_DS_DRA_SCHEMA_CONFLICT
//
// MessageText:
//
// The replication operation could not be completed due to a schema incompatibility.
//
#define ERROR_DS_DRA_SCHEMA_CONFLICT 8543L

//
// MessageId: ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT
//
// MessageText:
//
// The replication operation could not be completed due to a previous schema incompatibility.
//
#define ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT 8544L

//
// MessageId: ERROR_DS_DRA_OBJ_NC_MISMATCH
//
// MessageText:
//
// The replication update could not be applied because either the source or the destination has not yet received information regarding a recent cross-domain move operation.
//
#define ERROR_DS_DRA_OBJ_NC_MISMATCH 8545L

//
// MessageId: ERROR_DS_NC_STILL_HAS_DSAS
//
// MessageText:
//
// The requested domain could not be deleted because there exist domain controllers that still host this domain.
//
#define ERROR_DS_NC_STILL_HAS_DSAS 8546L

//
// MessageId: ERROR_DS_GC_REQUIRED
//
// MessageText:
//
// The requested operation can be performed only on a global catalog server.
//
#define ERROR_DS_GC_REQUIRED 8547L

//
// MessageId: ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY
//
// MessageText:
//
// A local group can only be a member of other local groups in the same domain.
//
#define ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY 8548L

//
// MessageId: ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS
//
// MessageText:
//
// Foreign security principals cannot be members of universal groups.
//
#define ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS 8549L

//
// MessageId: ERROR_DS_CANT_ADD_TO_GC
//
// MessageText:
//
// The attribute is not allowed to be replicated to the GC because of security reasons.
//
#define ERROR_DS_CANT_ADD_TO_GC 8550L

//
// MessageId: ERROR_DS_NO_CHECKPOINT_WITH_PDC
//
// MessageText:
//
// The checkpoint with the PDC could not be taken because there too many modifications being processed currently.
//
#define ERROR_DS_NO_CHECKPOINT_WITH_PDC 8551L

//
// MessageId: ERROR_DS_SOURCE_AUDITING_NOT_ENABLED
//
// MessageText:
//
// The operation requires that source domain auditing be enabled.
//
#define ERROR_DS_SOURCE_AUDITING_NOT_ENABLED 8552L

//
// MessageId: ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC
//
// MessageText:
//
// Security principal objects can only be created inside domain naming contexts.
//
#define ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC 8553L

//
// MessageId: ERROR_DS_INVALID_NAME_FOR_SPN
//
// MessageText:
//
// A Service Principal Name (SPN) could not be constructed because the provided hostname is not in the necessary format.
//
#define ERROR_DS_INVALID_NAME_FOR_SPN 8554L

//
// MessageId: ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS
//
// MessageText:
//
// A Filter was passed that uses constructed attributes.
//
#define ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS 8555L

//
// MessageId: ERROR_DS_UNICODEPWD_NOT_IN_QUOTES
//
// MessageText:
//
// The unicodePwd attribute value must be enclosed in double quotes.
//
#define ERROR_DS_UNICODEPWD_NOT_IN_QUOTES 8556L

//
// MessageId: ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED
//
// MessageText:
//
// Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.
//
#define ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED 8557L

//
// MessageId: ERROR_DS_MUST_BE_RUN_ON_DST_DC
//
// MessageText:
//
// For security reasons, the operation must be run on the destination DC.
//
#define ERROR_DS_MUST_BE_RUN_ON_DST_DC 8558L

//
// MessageId: ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER
//
// MessageText:
//
// For security reasons, the source DC must be NT4SP4 or greater.
//
#define ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER 8559L

//
// MessageId: ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ
//
// MessageText:
//
// Critical Directory Service System objects cannot be deleted during tree delete operations. The tree delete may have been partially performed.
//
#define ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ 8560L

//
// MessageId: ERROR_DS_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Directory Services could not start because of the following error: %1.
// Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//
#define ERROR_DS_INIT_FAILURE_CONSOLE 8561L

//
// MessageId: ERROR_DS_SAM_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error: %1.
// Error Status: 0x%2. Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//
#define ERROR_DS_SAM_INIT_FAILURE_CONSOLE 8562L

//
// MessageId: ERROR_DS_FOREST_VERSION_TOO_HIGH
//
// MessageText:
//
// The version of the operating system is incompatible with the current AD DS forest functional level or AD LDS Configuration Set functional level. You must upgrade to a new version of the operating system before this server can become an AD DS Domain Controller or add an AD LDS Instance in this AD DS Forest or AD LDS Configuration Set.
//
#define ERROR_DS_FOREST_VERSION_TOO_HIGH 8563L

//
// MessageId: ERROR_DS_DOMAIN_VERSION_TOO_HIGH
//
// MessageText:
//
// The version of the operating system installed is incompatible with the current domain functional level. You must upgrade to a new version of the operating system before this server can become a domain controller in this domain.
//
#define ERROR_DS_DOMAIN_VERSION_TOO_HIGH 8564L

//
// MessageId: ERROR_DS_FOREST_VERSION_TOO_LOW
//
// MessageText:
//
// The version of the operating system installed on this server no longer supports the current AD DS Forest functional level or AD LDS Configuration Set functional level. You must raise the AD DS Forest functional level or AD LDS Configuration Set functional level before this server can become an AD DS Domain Controller or an AD LDS Instance in this Forest or Configuration Set.
//
#define ERROR_DS_FOREST_VERSION_TOO_LOW 8565L

//
// MessageId: ERROR_DS_DOMAIN_VERSION_TOO_LOW
//
// MessageText:
//
// The version of the operating system installed on this server no longer supports the current domain functional level. You must raise the domain functional level before this server can become a domain controller in this domain.
//
#define ERROR_DS_DOMAIN_VERSION_TOO_LOW 8566L

//
// MessageId: ERROR_DS_INCOMPATIBLE_VERSION
//
// MessageText:
//
// The version of the operating system installed on this server is incompatible with the functional level of the domain or forest.
//
#define ERROR_DS_INCOMPATIBLE_VERSION 8567L

//
// MessageId: ERROR_DS_LOW_DSA_VERSION
//
// MessageText:
//
// The functional level of the domain (or forest) cannot be raised to the requested value, because there exist one or more domain controllers in the domain (or forest) that are at a lower incompatible functional level.
//
#define ERROR_DS_LOW_DSA_VERSION 8568L

//
// MessageId: ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN
//
// MessageText:
//
// The forest functional level cannot be raised to the requested value since one or more domains are still in mixed domain mode. All domains in the forest must be in native mode, for you to raise the forest functional level.
//
#define ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN 8569L

//
// MessageId: ERROR_DS_NOT_SUPPORTED_SORT_ORDER
//
// MessageText:
//
// The sort order requested is not supported.
//
#define ERROR_DS_NOT_SUPPORTED_SORT_ORDER 8570L

//
// MessageId: ERROR_DS_NAME_NOT_UNIQUE
//
// MessageText:
//
// The requested name already exists as a unique identifier.
//
#define ERROR_DS_NAME_NOT_UNIQUE 8571L

//
// MessageId: ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4
//
// MessageText:
//
// The machine account was created pre-NT4. The account needs to be recreated.
//
#define ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 8572L

//
// MessageId: ERROR_DS_OUT_OF_VERSION_STORE
//
// MessageText:
//
// The database is out of version store.
//
#define ERROR_DS_OUT_OF_VERSION_STORE 8573L

//
// MessageId: ERROR_DS_INCOMPATIBLE_CONTROLS_USED
//
// MessageText:
//
// Unable to continue operation because multiple conflicting controls were used.
//
#define ERROR_DS_INCOMPATIBLE_CONTROLS_USED 8574L

//
// MessageId: ERROR_DS_NO_REF_DOMAIN
//
// MessageText:
//
// Unable to find a valid security descriptor reference domain for this partition.
//
#define ERROR_DS_NO_REF_DOMAIN 8575L

//
// MessageId: ERROR_DS_RESERVED_LINK_ID
//
// MessageText:
//
// Schema update failed: The link identifier is reserved.
//
#define ERROR_DS_RESERVED_LINK_ID 8576L

//
// MessageId: ERROR_DS_LINK_ID_NOT_AVAILABLE
//
// MessageText:
//
// Schema update failed: There are no link identifiers available.
//
#define ERROR_DS_LINK_ID_NOT_AVAILABLE 8577L

//
// MessageId: ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// An account group cannot have a universal group as a member.
//
#define ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER 8578L

//
// MessageId: ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE
//
// MessageText:
//
// Rename or move operations on naming context heads or read-only objects are not allowed.
//
#define ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE 8579L

//
// MessageId: ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC
//
// MessageText:
//
// Move operations on objects in the schema naming context are not allowed.
//
#define ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC 8580L

//
// MessageId: ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG
//
// MessageText:
//
// A system flag has been set on the object and does not allow the object to be moved or renamed.
//
#define ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG 8581L

//
// MessageId: ERROR_DS_MODIFYDN_WRONG_GRANDPARENT
//
// MessageText:
//
// This object is not allowed to change its grandparent container. Moves are not forbidden on this object, but are restricted to sibling containers.
//
#define ERROR_DS_MODIFYDN_WRONG_GRANDPARENT 8582L

//
// MessageId: ERROR_DS_NAME_ERROR_TRUST_REFERRAL
//
// MessageText:
//
// Unable to resolve completely, a referral to another forest is generated.
//
#define ERROR_DS_NAME_ERROR_TRUST_REFERRAL 8583L

//
// MessageId: ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER
//
// MessageText:
//
// The requested action is not supported on standard server.
//
#define ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER 8584L

//
// MessageId: ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD
//
// MessageText:
//
// Could not access a partition of the directory service located on a remote server. Make sure at least one server is running for the partition in question.
//
#define ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD 8585L

//
// MessageId: ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2
//
// MessageText:
//
// The directory cannot validate the proposed naming context (or partition) name because it does not hold a replica nor can it contact a replica of the naming context above the proposed naming context. Please ensure that the parent naming context is properly registered in DNS, and at least one replica of this naming context is reachable by the Domain Naming master.
//
#define ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 8586L

//
// MessageId: ERROR_DS_THREAD_LIMIT_EXCEEDED
//
// MessageText:
//
// The thread limit for this request was exceeded.
//
#define ERROR_DS_THREAD_LIMIT_EXCEEDED 8587L

//
// MessageId: ERROR_DS_NOT_CLOSEST
//
// MessageText:
//
// The Global catalog server is not in the closest site.
//
#define ERROR_DS_NOT_CLOSEST 8588L

//
// MessageId: ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF
//
// MessageText:
//
// The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the corresponding server object in the local DS database has no serverReference attribute.
//
#define ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF 8589L

//
// MessageId: ERROR_DS_SINGLE_USER_MODE_FAILED
//
// MessageText:
//
// The Directory Service failed to enter single user mode.
//
#define ERROR_DS_SINGLE_USER_MODE_FAILED 8590L

//
// MessageId: ERROR_DS_NTDSCRIPT_SYNTAX_ERROR
//
// MessageText:
//
// The Directory Service cannot parse the script because of a syntax error.
//
#define ERROR_DS_NTDSCRIPT_SYNTAX_ERROR 8591L

//
// MessageId: ERROR_DS_NTDSCRIPT_PROCESS_ERROR
//
// MessageText:
//
// The Directory Service cannot process the script because of an error.
//
#define ERROR_DS_NTDSCRIPT_PROCESS_ERROR 8592L

//
// MessageId: ERROR_DS_DIFFERENT_REPL_EPOCHS
//
// MessageText:
//
// The directory service cannot perform the requested operation because the servers involved are of different replication epochs (which is usually related to a domain rename that is in progress).
//
#define ERROR_DS_DIFFERENT_REPL_EPOCHS 8593L

//
// MessageId: ERROR_DS_DRS_EXTENSIONS_CHANGED
//
// MessageText:
//
// The directory service binding must be renegotiated due to a change in the server extensions information.
//
#define ERROR_DS_DRS_EXTENSIONS_CHANGED 8594L

//
// MessageId: ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR
//
// MessageText:
//
// Operation not allowed on a disabled cross ref.
//
#define ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR 8595L

//
// MessageId: ERROR_DS_NO_MSDS_INTID
//
// MessageText:
//
// Schema update failed: No values for msDS-IntId are available.
//
#define ERROR_DS_NO_MSDS_INTID 8596L

//
// MessageId: ERROR_DS_DUP_MSDS_INTID
//
// MessageText:
//
// Schema update failed: Duplicate msDS-INtId. Retry the operation.
//
#define ERROR_DS_DUP_MSDS_INTID 8597L

//
// MessageId: ERROR_DS_EXISTS_IN_RDNATTID
//
// MessageText:
//
// Schema deletion failed: attribute is used in rDNAttID.
//
#define ERROR_DS_EXISTS_IN_RDNATTID 8598L

//
// MessageId: ERROR_DS_AUTHORIZATION_FAILED
//
// MessageText:
//
// The directory service failed to authorize the request.
//
#define ERROR_DS_AUTHORIZATION_FAILED 8599L

//
// MessageId: ERROR_DS_INVALID_SCRIPT
//
// MessageText:
//
// The Directory Service cannot process the script because it is invalid.
//
#define ERROR_DS_INVALID_SCRIPT 8600L

//
// MessageId: ERROR_DS_REMOTE_CROSSREF_OP_FAILED
//
// MessageText:
//
// The remote create cross reference operation failed on the Domain Naming Master FSMO. The operation's error is in the extended data.
//
#define ERROR_DS_REMOTE_CROSSREF_OP_FAILED 8601L

//
// MessageId: ERROR_DS_CROSS_REF_BUSY
//
// MessageText:
//
// A cross reference is in use locally with the same name.
//
#define ERROR_DS_CROSS_REF_BUSY 8602L

//
// MessageId: ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN
//
// MessageText:
//
// The DS cannot derive a service principal name (SPN) with which to mutually authenticate the target server because the server's domain has been deleted from the forest.
//
#define ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN 8603L

//
// MessageId: ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC
//
// MessageText:
//
// Writeable NCs prevent this DC from demoting.
//
#define ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC 8604L

//
// MessageId: ERROR_DS_DUPLICATE_ID_FOUND
//
// MessageText:
//
// The requested object has a non-unique identifier and cannot be retrieved.
//
#define ERROR_DS_DUPLICATE_ID_FOUND 8605L

//
// MessageId: ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT
//
// MessageText:
//
// Insufficient attributes were given to create an object. This object may not exist because it may have been deleted and already garbage collected.
//
#define ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT 8606L

//
// MessageId: ERROR_DS_GROUP_CONVERSION_ERROR
//
// MessageText:
//
// The group cannot be converted due to attribute restrictions on the requested group type.
//
#define ERROR_DS_GROUP_CONVERSION_ERROR 8607L

//
// MessageId: ERROR_DS_CANT_MOVE_APP_BASIC_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty basic application groups is not allowed.
//
#define ERROR_DS_CANT_MOVE_APP_BASIC_GROUP 8608L

//
// MessageId: ERROR_DS_CANT_MOVE_APP_QUERY_GROUP
//
// MessageText:
//
// Cross-domain move of non-empty query based application groups is not allowed.
//
#define ERROR_DS_CANT_MOVE_APP_QUERY_GROUP 8609L

//
// MessageId: ERROR_DS_ROLE_NOT_VERIFIED
//
// MessageText:
//
// The FSMO role ownership could not be verified because its directory partition has not replicated successfully with at least one replication partner.
//
#define ERROR_DS_ROLE_NOT_VERIFIED 8610L

//
// MessageId: ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL
//
// MessageText:
//
// The target container for a redirection of a well known object container cannot already be a special container.
//
#define ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL 8611L

//
// MessageId: ERROR_DS_DOMAIN_RENAME_IN_PROGRESS
//
// MessageText:
//
// The Directory Service cannot perform the requested operation because a domain rename operation is in progress.
//
#define ERROR_DS_DOMAIN_RENAME_IN_PROGRESS 8612L

//
// MessageId: ERROR_DS_EXISTING_AD_CHILD_NC
//
// MessageText:
//
// The directory service detected a child partition below the requested partition name. The partition hierarchy must be created in a top down method.
//
#define ERROR_DS_EXISTING_AD_CHILD_NC 8613L

//
// MessageId: ERROR_DS_REPL_LIFETIME_EXCEEDED
//
// MessageText:
//
// The directory service cannot replicate with this server because the time since the last replication with this server has exceeded the tombstone lifetime.
//
#define ERROR_DS_REPL_LIFETIME_EXCEEDED 8614L

//
// MessageId: ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER
//
// MessageText:
//
// The requested operation is not allowed on an object under the system container.
//
#define ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER 8615L

//
// MessageId: ERROR_DS_LDAP_SEND_QUEUE_FULL
//
// MessageText:
//
// The LDAP servers network send queue has filled up because the client is not processing the results of it's requests fast enough. No more requests will be processed until the client catches up. If the client does not catch up then it will be disconnected.
//
#define ERROR_DS_LDAP_SEND_QUEUE_FULL 8616L

//
// MessageId: ERROR_DS_DRA_OUT_SCHEDULE_WINDOW
//
// MessageText:
//
// The scheduled replication did not take place because the system was too busy to execute the request within the schedule window. The replication queue is overloaded. Consider reducing the number of partners or decreasing the scheduled replication frequency.
//
#define ERROR_DS_DRA_OUT_SCHEDULE_WINDOW 8617L

//
// MessageId: ERROR_DS_POLICY_NOT_KNOWN
//
// MessageText:
//
// At this time, it cannot be determined if the branch replication policy is available on the hub domain controller. Please retry at a later time to account for replication latencies.
//
#define ERROR_DS_POLICY_NOT_KNOWN 8618L

//
// MessageId: ERROR_NO_SITE_SETTINGS_OBJECT
//
// MessageText:
//
// The site settings object for the specified site does not exist.
//
#define ERROR_NO_SITE_SETTINGS_OBJECT 8619L

//
// MessageId: ERROR_NO_SECRETS
//
// MessageText:
//
// The local account store does not contain secret material for the specified account.
//
#define ERROR_NO_SECRETS 8620L

//
// MessageId: ERROR_NO_WRITABLE_DC_FOUND
//
// MessageText:
//
// Could not find a writable domain controller in the domain.
//
#define ERROR_NO_WRITABLE_DC_FOUND 8621L

//
// MessageId: ERROR_DS_NO_SERVER_OBJECT
//
// MessageText:
//
// The server object for the domain controller does not exist.
//
#define ERROR_DS_NO_SERVER_OBJECT 8622L

//
// MessageId: ERROR_DS_NO_NTDSA_OBJECT
//
// MessageText:
//
// The NTDS Settings object for the domain controller does not exist.
//
#define ERROR_DS_NO_NTDSA_OBJECT 8623L

//
// MessageId: ERROR_DS_NON_ASQ_SEARCH
//
// MessageText:
//
// The requested search operation is not supported for ASQ searches.
//
#define ERROR_DS_NON_ASQ_SEARCH 8624L

//
// MessageId: ERROR_DS_AUDIT_FAILURE
//
// MessageText:
//
// A required audit event could not be generated for the operation.
//
#define ERROR_DS_AUDIT_FAILURE 8625L

//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE
//
// MessageText:
//
// The search flags for the attribute are invalid. The subtree index bit is valid only on single valued attributes.
//
#define ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE 8626L

//
// MessageId: ERROR_DS_INVALID_SEARCH_FLAG_TUPLE
//
// MessageText:
//
// The search flags for the attribute are invalid. The tuple index bit is valid only on attributes of Unicode strings.
//
#define ERROR_DS_INVALID_SEARCH_FLAG_TUPLE 8627L

//
// MessageId: ERROR_DS_HIERARCHY_TABLE_TOO_DEEP
//
// MessageText:
//
// The address books are nested too deeply. Failed to build the hierarchy table.
//
#define ERROR_DS_HIERARCHY_TABLE_TOO_DEEP 8628L

//
// MessageId: ERROR_DS_DRA_CORRUPT_UTD_VECTOR
//
// MessageText:
//
// The specified up-to-date-ness vector is corrupt.
//
#define ERROR_DS_DRA_CORRUPT_UTD_VECTOR 8629L

//
// MessageId: ERROR_DS_DRA_SECRETS_DENIED
//
// MessageText:
//
// The request to replicate secrets is denied.
//
#define ERROR_DS_DRA_SECRETS_DENIED 8630L

//
// MessageId: ERROR_DS_RESERVED_MAPI_ID
//
// MessageText:
//
// Schema update failed: The MAPI identifier is reserved.
//
#define ERROR_DS_RESERVED_MAPI_ID 8631L

//
// MessageId: ERROR_DS_MAPI_ID_NOT_AVAILABLE
//
// MessageText:
//
// Schema update failed: There are no MAPI identifiers available.
//
#define ERROR_DS_MAPI_ID_NOT_AVAILABLE 8632L

//
// MessageId: ERROR_DS_DRA_MISSING_KRBTGT_SECRET
//
// MessageText:
//
// The replication operation failed because the required attributes of the local krbtgt object are missing.
//
#define ERROR_DS_DRA_MISSING_KRBTGT_SECRET 8633L

//
// MessageId: ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The domain name of the trusted domain already exists in the forest.
//
#define ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST 8634L

//
// MessageId: ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The flat name of the trusted domain already exists in the forest.
//
#define ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST 8635L

//
// MessageId: ERROR_INVALID_USER_PRINCIPAL_NAME
//
// MessageText:
//
// The User Principal Name (UPN) is invalid.
//
#define ERROR_INVALID_USER_PRINCIPAL_NAME 8636L

//
// MessageId: ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS
//
// MessageText:
//
// OID mapped groups cannot have members.
//
#define ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS 8637L

//
// MessageId: ERROR_DS_OID_NOT_FOUND
//
// MessageText:
//
// The specified OID cannot be found.
//
#define ERROR_DS_OID_NOT_FOUND 8638L

//
// MessageId: ERROR_DS_DRA_RECYCLED_TARGET
//
// MessageText:
//
// The replication operation failed because the target object referred by a link value is recycled.
//
#define ERROR_DS_DRA_RECYCLED_TARGET 8639L


///////////////////////////////////////////////////
//                                                /
//        End of Active Directory Error Codes     /
//                                                /
//                  8000 to  8999                 /
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//               DNS Error codes                 //
//                                               //
//                 9000 to 9999                  //
///////////////////////////////////////////////////

// =============================
// Facility DNS Error Messages
// =============================

//
//  DNS response codes.
//

#define DNS_ERROR_RESPONSE_CODES_BASE 9000

#define DNS_ERROR_RCODE_NO_ERROR NO_ERROR

#define DNS_ERROR_MASK 0x00002328

// DNS_ERROR_RCODE_FORMAT_ERROR          0x00002329
//
// MessageId: DNS_ERROR_RCODE_FORMAT_ERROR
//
// MessageText:
//
// DNS server unable to interpret format.
//
#define DNS_ERROR_RCODE_FORMAT_ERROR 9001L

// DNS_ERROR_RCODE_SERVER_FAILURE        0x0000232a
//
// MessageId: DNS_ERROR_RCODE_SERVER_FAILURE
//
// MessageText:
//
// DNS server failure.
//
#define DNS_ERROR_RCODE_SERVER_FAILURE 9002L

// DNS_ERROR_RCODE_NAME_ERROR            0x0000232b
//
// MessageId: DNS_ERROR_RCODE_NAME_ERROR
//
// MessageText:
//
// DNS name does not exist.
//
#define DNS_ERROR_RCODE_NAME_ERROR 9003L

// DNS_ERROR_RCODE_NOT_IMPLEMENTED       0x0000232c
//
// MessageId: DNS_ERROR_RCODE_NOT_IMPLEMENTED
//
// MessageText:
//
// DNS request not supported by name server.
//
#define DNS_ERROR_RCODE_NOT_IMPLEMENTED 9004L

// DNS_ERROR_RCODE_REFUSED               0x0000232d
//
// MessageId: DNS_ERROR_RCODE_REFUSED
//
// MessageText:
//
// DNS operation refused.
//
#define DNS_ERROR_RCODE_REFUSED 9005L

// DNS_ERROR_RCODE_YXDOMAIN              0x0000232e
//
// MessageId: DNS_ERROR_RCODE_YXDOMAIN
//
// MessageText:
//
// DNS name that ought not exist, does exist.
//
#define DNS_ERROR_RCODE_YXDOMAIN 9006L

// DNS_ERROR_RCODE_YXRRSET               0x0000232f
//
// MessageId: DNS_ERROR_RCODE_YXRRSET
//
// MessageText:
//
// DNS RR set that ought not exist, does exist.
//
#define DNS_ERROR_RCODE_YXRRSET 9007L

// DNS_ERROR_RCODE_NXRRSET               0x00002330
//
// MessageId: DNS_ERROR_RCODE_NXRRSET
//
// MessageText:
//
// DNS RR set that ought to exist, does not exist.
//
#define DNS_ERROR_RCODE_NXRRSET 9008L

// DNS_ERROR_RCODE_NOTAUTH               0x00002331
//
// MessageId: DNS_ERROR_RCODE_NOTAUTH
//
// MessageText:
//
// DNS server not authoritative for zone.
//
#define DNS_ERROR_RCODE_NOTAUTH 9009L

// DNS_ERROR_RCODE_NOTZONE               0x00002332
//
// MessageId: DNS_ERROR_RCODE_NOTZONE
//
// MessageText:
//
// DNS name in update or prereq is not in zone.
//
#define DNS_ERROR_RCODE_NOTZONE 9010L

// DNS_ERROR_RCODE_BADSIG                0x00002338
//
// MessageId: DNS_ERROR_RCODE_BADSIG
//
// MessageText:
//
// DNS signature failed to verify.
//
#define DNS_ERROR_RCODE_BADSIG 9016L

// DNS_ERROR_RCODE_BADKEY                0x00002339
//
// MessageId: DNS_ERROR_RCODE_BADKEY
//
// MessageText:
//
// DNS bad key.
//
#define DNS_ERROR_RCODE_BADKEY 9017L

// DNS_ERROR_RCODE_BADTIME               0x0000233a
//
// MessageId: DNS_ERROR_RCODE_BADTIME
//
// MessageText:
//
// DNS signature validity expired.
//
#define DNS_ERROR_RCODE_BADTIME 9018L

#define DNS_ERROR_RCODE_LAST DNS_ERROR_RCODE_BADTIME


//
// Packet format
//

#define DNS_ERROR_PACKET_FMT_BASE 9500

// DNS_INFO_NO_RECORDS                   0x0000251d
//
// MessageId: DNS_INFO_NO_RECORDS
//
// MessageText:
//
// No records found for given DNS query.
//
#define DNS_INFO_NO_RECORDS 9501L

// DNS_ERROR_BAD_PACKET                  0x0000251e
//
// MessageId: DNS_ERROR_BAD_PACKET
//
// MessageText:
//
// Bad DNS packet.
//
#define DNS_ERROR_BAD_PACKET 9502L

// DNS_ERROR_NO_PACKET                   0x0000251f
//
// MessageId: DNS_ERROR_NO_PACKET
//
// MessageText:
//
// No DNS packet.
//
#define DNS_ERROR_NO_PACKET 9503L

// DNS_ERROR_RCODE                       0x00002520
//
// MessageId: DNS_ERROR_RCODE
//
// MessageText:
//
// DNS error, check rcode.
//
#define DNS_ERROR_RCODE 9504L

// DNS_ERROR_UNSECURE_PACKET             0x00002521
//
// MessageId: DNS_ERROR_UNSECURE_PACKET
//
// MessageText:
//
// Unsecured DNS packet.
//
#define DNS_ERROR_UNSECURE_PACKET 9505L

#define DNS_STATUS_PACKET_UNSECURE DNS_ERROR_UNSECURE_PACKET


//
// General API errors
//

#define DNS_ERROR_NO_MEMORY ERROR_OUTOFMEMORY
#define DNS_ERROR_INVALID_NAME ERROR_INVALID_NAME
#define DNS_ERROR_INVALID_DATA ERROR_INVALID_DATA

#define DNS_ERROR_GENERAL_API_BASE 9550

// DNS_ERROR_INVALID_TYPE                0x0000254f
//
// MessageId: DNS_ERROR_INVALID_TYPE
//
// MessageText:
//
// Invalid DNS type.
//
#define DNS_ERROR_INVALID_TYPE 9551L

// DNS_ERROR_INVALID_IP_ADDRESS          0x00002550
//
// MessageId: DNS_ERROR_INVALID_IP_ADDRESS
//
// MessageText:
//
// Invalid IP address.
//
#define DNS_ERROR_INVALID_IP_ADDRESS 9552L

// DNS_ERROR_INVALID_PROPERTY            0x00002551
//
// MessageId: DNS_ERROR_INVALID_PROPERTY
//
// MessageText:
//
// Invalid property.
//
#define DNS_ERROR_INVALID_PROPERTY 9553L

// DNS_ERROR_TRY_AGAIN_LATER             0x00002552
//
// MessageId: DNS_ERROR_TRY_AGAIN_LATER
//
// MessageText:
//
// Try DNS operation again later.
//
#define DNS_ERROR_TRY_AGAIN_LATER 9554L

// DNS_ERROR_NOT_UNIQUE                  0x00002553
//
// MessageId: DNS_ERROR_NOT_UNIQUE
//
// MessageText:
//
// Record for given name and type is not unique.
//
#define DNS_ERROR_NOT_UNIQUE 9555L

// DNS_ERROR_NON_RFC_NAME                0x00002554
//
// MessageId: DNS_ERROR_NON_RFC_NAME
//
// MessageText:
//
// DNS name does not comply with RFC specifications.
//
#define DNS_ERROR_NON_RFC_NAME 9556L

// DNS_STATUS_FQDN                       0x00002555
//
// MessageId: DNS_STATUS_FQDN
//
// MessageText:
//
// DNS name is a fully-qualified DNS name.
//
#define DNS_STATUS_FQDN 9557L

// DNS_STATUS_DOTTED_NAME                0x00002556
//
// MessageId: DNS_STATUS_DOTTED_NAME
//
// MessageText:
//
// DNS name is dotted (multi-label).
//
#define DNS_STATUS_DOTTED_NAME 9558L

// DNS_STATUS_SINGLE_PART_NAME           0x00002557
//
// MessageId: DNS_STATUS_SINGLE_PART_NAME
//
// MessageText:
//
// DNS name is a single-part name.
//
#define DNS_STATUS_SINGLE_PART_NAME 9559L

// DNS_ERROR_INVALID_NAME_CHAR           0x00002558
//
// MessageId: DNS_ERROR_INVALID_NAME_CHAR
//
// MessageText:
//
// DNS name contains an invalid character.
//
#define DNS_ERROR_INVALID_NAME_CHAR 9560L

// DNS_ERROR_NUMERIC_NAME                0x00002559
//
// MessageId: DNS_ERROR_NUMERIC_NAME
//
// MessageText:
//
// DNS name is entirely numeric.
//
#define DNS_ERROR_NUMERIC_NAME 9561L

// DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER  0x0000255A
//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER
//
// MessageText:
//
// The operation requested is not permitted on a DNS root server.
//
#define DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER 9562L

// DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION  0x0000255B
//
// MessageId: DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION
//
// MessageText:
//
// The record could not be created because this part of the DNS namespace has been delegated to another server.
//
#define DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION 9563L

// DNS_ERROR_CANNOT_FIND_ROOT_HINTS  0x0000255C
//
// MessageId: DNS_ERROR_CANNOT_FIND_ROOT_HINTS
//
// MessageText:
//
// The DNS server could not find a set of root hints.
//
#define DNS_ERROR_CANNOT_FIND_ROOT_HINTS 9564L

// DNS_ERROR_INCONSISTENT_ROOT_HINTS  0x0000255D
//
// MessageId: DNS_ERROR_INCONSISTENT_ROOT_HINTS
//
// MessageText:
//
// The DNS server found root hints but they were not consistent across all adapters.
//
#define DNS_ERROR_INCONSISTENT_ROOT_HINTS 9565L

// DNS_ERROR_DWORD_VALUE_TOO_SMALL    0x0000255E
//
// MessageId: DNS_ERROR_DWORD_VALUE_TOO_SMALL
//
// MessageText:
//
// The specified value is too small for this parameter.
//
#define DNS_ERROR_DWORD_VALUE_TOO_SMALL 9566L

// DNS_ERROR_DWORD_VALUE_TOO_LARGE    0x0000255F
//
// MessageId: DNS_ERROR_DWORD_VALUE_TOO_LARGE
//
// MessageText:
//
// The specified value is too large for this parameter.
//
#define DNS_ERROR_DWORD_VALUE_TOO_LARGE 9567L

// DNS_ERROR_BACKGROUND_LOADING       0x00002560
//
// MessageId: DNS_ERROR_BACKGROUND_LOADING
//
// MessageText:
//
// This operation is not allowed while the DNS server is loading zones in the background. Please try again later.
//
#define DNS_ERROR_BACKGROUND_LOADING 9568L

// DNS_ERROR_NOT_ALLOWED_ON_RODC      0x00002561
//
// MessageId: DNS_ERROR_NOT_ALLOWED_ON_RODC
//
// MessageText:
//
// The operation requested is not permitted on against a DNS server running on a read-only DC.
//
#define DNS_ERROR_NOT_ALLOWED_ON_RODC 9569L

// DNS_ERROR_NOT_ALLOWED_UNDER_DNAME   0x00002562
//
// MessageId: DNS_ERROR_NOT_ALLOWED_UNDER_DNAME
//
// MessageText:
//
// No data is allowed to exist underneath a DNAME record.
//
#define DNS_ERROR_NOT_ALLOWED_UNDER_DNAME 9570L

// DNS_ERROR_DELEGATION_REQUIRED       0x00002563
//
// MessageId: DNS_ERROR_DELEGATION_REQUIRED
//
// MessageText:
//
// This operation requires credentials delegation.
//
#define DNS_ERROR_DELEGATION_REQUIRED 9571L

// DNS_ERROR_INVALID_POLICY_TABLE        0x00002564
//
// MessageId: DNS_ERROR_INVALID_POLICY_TABLE
//
// MessageText:
//
// Name resolution policy table has been corrupted. DNS resolution will fail until it is fixed. Contact your network administrator.
//
#define DNS_ERROR_INVALID_POLICY_TABLE 9572L


//
// Zone errors
//

#define DNS_ERROR_ZONE_BASE 9600

// DNS_ERROR_ZONE_DOES_NOT_EXIST         0x00002581
//
// MessageId: DNS_ERROR_ZONE_DOES_NOT_EXIST
//
// MessageText:
//
// DNS zone does not exist.
//
#define DNS_ERROR_ZONE_DOES_NOT_EXIST 9601L

// DNS_ERROR_NO_ZONE_INFO                0x00002582
//
// MessageId: DNS_ERROR_NO_ZONE_INFO
//
// MessageText:
//
// DNS zone information not available.
//
#define DNS_ERROR_NO_ZONE_INFO 9602L

// DNS_ERROR_INVALID_ZONE_OPERATION      0x00002583
//
// MessageId: DNS_ERROR_INVALID_ZONE_OPERATION
//
// MessageText:
//
// Invalid operation for DNS zone.
//
#define DNS_ERROR_INVALID_ZONE_OPERATION 9603L

// DNS_ERROR_ZONE_CONFIGURATION_ERROR    0x00002584
//
// MessageId: DNS_ERROR_ZONE_CONFIGURATION_ERROR
//
// MessageText:
//
// Invalid DNS zone configuration.
//
#define DNS_ERROR_ZONE_CONFIGURATION_ERROR 9604L

// DNS_ERROR_ZONE_HAS_NO_SOA_RECORD      0x00002585
//
// MessageId: DNS_ERROR_ZONE_HAS_NO_SOA_RECORD
//
// MessageText:
//
// DNS zone has no start of authority (SOA) record.
//
#define DNS_ERROR_ZONE_HAS_NO_SOA_RECORD 9605L

// DNS_ERROR_ZONE_HAS_NO_NS_RECORDS      0x00002586
//
// MessageId: DNS_ERROR_ZONE_HAS_NO_NS_RECORDS
//
// MessageText:
//
// DNS zone has no Name Server (NS) record.
//
#define DNS_ERROR_ZONE_HAS_NO_NS_RECORDS 9606L

// DNS_ERROR_ZONE_LOCKED                 0x00002587
//
// MessageId: DNS_ERROR_ZONE_LOCKED
//
// MessageText:
//
// DNS zone is locked.
//
#define DNS_ERROR_ZONE_LOCKED 9607L

// DNS_ERROR_ZONE_CREATION_FAILED        0x00002588
//
// MessageId: DNS_ERROR_ZONE_CREATION_FAILED
//
// MessageText:
//
// DNS zone creation failed.
//
#define DNS_ERROR_ZONE_CREATION_FAILED 9608L

// DNS_ERROR_ZONE_ALREADY_EXISTS         0x00002589
//
// MessageId: DNS_ERROR_ZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS zone already exists.
//
#define DNS_ERROR_ZONE_ALREADY_EXISTS 9609L

// DNS_ERROR_AUTOZONE_ALREADY_EXISTS     0x0000258a
//
// MessageId: DNS_ERROR_AUTOZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS automatic zone already exists.
//
#define DNS_ERROR_AUTOZONE_ALREADY_EXISTS 9610L

// DNS_ERROR_INVALID_ZONE_TYPE           0x0000258b
//
// MessageId: DNS_ERROR_INVALID_ZONE_TYPE
//
// MessageText:
//
// Invalid DNS zone type.
//
#define DNS_ERROR_INVALID_ZONE_TYPE 9611L

// DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP 0x0000258c
//
// MessageId: DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP
//
// MessageText:
//
// Secondary DNS zone requires master IP address.
//
#define DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP 9612L

// DNS_ERROR_ZONE_NOT_SECONDARY          0x0000258d
//
// MessageId: DNS_ERROR_ZONE_NOT_SECONDARY
//
// MessageText:
//
// DNS zone not secondary.
//
#define DNS_ERROR_ZONE_NOT_SECONDARY 9613L

// DNS_ERROR_NEED_SECONDARY_ADDRESSES    0x0000258e
//
// MessageId: DNS_ERROR_NEED_SECONDARY_ADDRESSES
//
// MessageText:
//
// Need secondary IP address.
//
#define DNS_ERROR_NEED_SECONDARY_ADDRESSES 9614L

// DNS_ERROR_WINS_INIT_FAILED            0x0000258f
//
// MessageId: DNS_ERROR_WINS_INIT_FAILED
//
// MessageText:
//
// WINS initialization failed.
//
#define DNS_ERROR_WINS_INIT_FAILED 9615L

// DNS_ERROR_NEED_WINS_SERVERS           0x00002590
//
// MessageId: DNS_ERROR_NEED_WINS_SERVERS
//
// MessageText:
//
// Need WINS servers.
//
#define DNS_ERROR_NEED_WINS_SERVERS 9616L

// DNS_ERROR_NBSTAT_INIT_FAILED          0x00002591
//
// MessageId: DNS_ERROR_NBSTAT_INIT_FAILED
//
// MessageText:
//
// NBTSTAT initialization call failed.
//
#define DNS_ERROR_NBSTAT_INIT_FAILED 9617L

// DNS_ERROR_SOA_DELETE_INVALID          0x00002592
//
// MessageId: DNS_ERROR_SOA_DELETE_INVALID
//
// MessageText:
//
// Invalid delete of start of authority (SOA)
//
#define DNS_ERROR_SOA_DELETE_INVALID 9618L

// DNS_ERROR_FORWARDER_ALREADY_EXISTS    0x00002593
//
// MessageId: DNS_ERROR_FORWARDER_ALREADY_EXISTS
//
// MessageText:
//
// A conditional forwarding zone already exists for that name.
//
#define DNS_ERROR_FORWARDER_ALREADY_EXISTS 9619L

// DNS_ERROR_ZONE_REQUIRES_MASTER_IP     0x00002594
//
// MessageId: DNS_ERROR_ZONE_REQUIRES_MASTER_IP
//
// MessageText:
//
// This zone must be configured with one or more master DNS server IP addresses.
//
#define DNS_ERROR_ZONE_REQUIRES_MASTER_IP 9620L

// DNS_ERROR_ZONE_IS_SHUTDOWN            0x00002595
//
// MessageId: DNS_ERROR_ZONE_IS_SHUTDOWN
//
// MessageText:
//
// The operation cannot be performed because this zone is shutdown.
//
#define DNS_ERROR_ZONE_IS_SHUTDOWN 9621L


//
// Datafile errors
//

#define DNS_ERROR_DATAFILE_BASE 9650

// DNS                                   0x000025b3
//
// MessageId: DNS_ERROR_PRIMARY_REQUIRES_DATAFILE
//
// MessageText:
//
// Primary DNS zone requires datafile.
//
#define DNS_ERROR_PRIMARY_REQUIRES_DATAFILE 9651L

// DNS                                   0x000025b4
//
// MessageId: DNS_ERROR_INVALID_DATAFILE_NAME
//
// MessageText:
//
// Invalid datafile name for DNS zone.
//
#define DNS_ERROR_INVALID_DATAFILE_NAME 9652L

// DNS                                   0x000025b5
//
// MessageId: DNS_ERROR_DATAFILE_OPEN_FAILURE
//
// MessageText:
//
// Failed to open datafile for DNS zone.
//
#define DNS_ERROR_DATAFILE_OPEN_FAILURE 9653L

// DNS                                   0x000025b6
//
// MessageId: DNS_ERROR_FILE_WRITEBACK_FAILED
//
// MessageText:
//
// Failed to write datafile for DNS zone.
//
#define DNS_ERROR_FILE_WRITEBACK_FAILED 9654L

// DNS                                   0x000025b7
//
// MessageId: DNS_ERROR_DATAFILE_PARSING
//
// MessageText:
//
// Failure while reading datafile for DNS zone.
//
#define DNS_ERROR_DATAFILE_PARSING 9655L


//
// Database errors
//

#define DNS_ERROR_DATABASE_BASE 9700

// DNS_ERROR_RECORD_DOES_NOT_EXIST       0x000025e5
//
// MessageId: DNS_ERROR_RECORD_DOES_NOT_EXIST
//
// MessageText:
//
// DNS record does not exist.
//
#define DNS_ERROR_RECORD_DOES_NOT_EXIST 9701L

// DNS_ERROR_RECORD_FORMAT               0x000025e6
//
// MessageId: DNS_ERROR_RECORD_FORMAT
//
// MessageText:
//
// DNS record format error.
//
#define DNS_ERROR_RECORD_FORMAT 9702L

// DNS_ERROR_NODE_CREATION_FAILED        0x000025e7
//
// MessageId: DNS_ERROR_NODE_CREATION_FAILED
//
// MessageText:
//
// Node creation failure in DNS.
//
#define DNS_ERROR_NODE_CREATION_FAILED 9703L

// DNS_ERROR_UNKNOWN_RECORD_TYPE         0x000025e8
//
// MessageId: DNS_ERROR_UNKNOWN_RECORD_TYPE
//
// MessageText:
//
// Unknown DNS record type.
//
#define DNS_ERROR_UNKNOWN_RECORD_TYPE 9704L

// DNS_ERROR_RECORD_TIMED_OUT            0x000025e9
//
// MessageId: DNS_ERROR_RECORD_TIMED_OUT
//
// MessageText:
//
// DNS record timed out.
//
#define DNS_ERROR_RECORD_TIMED_OUT 9705L

// DNS_ERROR_NAME_NOT_IN_ZONE            0x000025ea
//
// MessageId: DNS_ERROR_NAME_NOT_IN_ZONE
//
// MessageText:
//
// Name not in DNS zone.
//
#define DNS_ERROR_NAME_NOT_IN_ZONE 9706L

// DNS_ERROR_CNAME_LOOP                  0x000025eb
//
// MessageId: DNS_ERROR_CNAME_LOOP
//
// MessageText:
//
// CNAME loop detected.
//
#define DNS_ERROR_CNAME_LOOP 9707L

// DNS_ERROR_NODE_IS_CNAME               0x000025ec
//
// MessageId: DNS_ERROR_NODE_IS_CNAME
//
// MessageText:
//
// Node is a CNAME DNS record.
//
#define DNS_ERROR_NODE_IS_CNAME 9708L

// DNS_ERROR_CNAME_COLLISION             0x000025ed
//
// MessageId: DNS_ERROR_CNAME_COLLISION
//
// MessageText:
//
// A CNAME record already exists for given name.
//
#define DNS_ERROR_CNAME_COLLISION 9709L

// DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT    0x000025ee
//
// MessageId: DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT
//
// MessageText:
//
// Record only at DNS zone root.
//
#define DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT 9710L

// DNS_ERROR_RECORD_ALREADY_EXISTS       0x000025ef
//
// MessageId: DNS_ERROR_RECORD_ALREADY_EXISTS
//
// MessageText:
//
// DNS record already exists.
//
#define DNS_ERROR_RECORD_ALREADY_EXISTS 9711L

// DNS_ERROR_SECONDARY_DATA              0x000025f0
//
// MessageId: DNS_ERROR_SECONDARY_DATA
//
// MessageText:
//
// Secondary DNS zone data error.
//
#define DNS_ERROR_SECONDARY_DATA 9712L

// DNS_ERROR_NO_CREATE_CACHE_DATA        0x000025f1
//
// MessageId: DNS_ERROR_NO_CREATE_CACHE_DATA
//
// MessageText:
//
// Could not create DNS cache data.
//
#define DNS_ERROR_NO_CREATE_CACHE_DATA 9713L

// DNS_ERROR_NAME_DOES_NOT_EXIST         0x000025f2
//
// MessageId: DNS_ERROR_NAME_DOES_NOT_EXIST
//
// MessageText:
//
// DNS name does not exist.
//
#define DNS_ERROR_NAME_DOES_NOT_EXIST 9714L

// DNS_WARNING_PTR_CREATE_FAILED         0x000025f3
//
// MessageId: DNS_WARNING_PTR_CREATE_FAILED
//
// MessageText:
//
// Could not create pointer (PTR) record.
//
#define DNS_WARNING_PTR_CREATE_FAILED 9715L

// DNS_WARNING_DOMAIN_UNDELETED          0x000025f4
//
// MessageId: DNS_WARNING_DOMAIN_UNDELETED
//
// MessageText:
//
// DNS domain was undeleted.
//
#define DNS_WARNING_DOMAIN_UNDELETED 9716L

// DNS_ERROR_DS_UNAVAILABLE              0x000025f5
//
// MessageId: DNS_ERROR_DS_UNAVAILABLE
//
// MessageText:
//
// The directory service is unavailable.
//
#define DNS_ERROR_DS_UNAVAILABLE 9717L

// DNS_ERROR_DS_ZONE_ALREADY_EXISTS      0x000025f6
//
// MessageId: DNS_ERROR_DS_ZONE_ALREADY_EXISTS
//
// MessageText:
//
// DNS zone already exists in the directory service.
//
#define DNS_ERROR_DS_ZONE_ALREADY_EXISTS 9718L

// DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE      0x000025f7
//
// MessageId: DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE
//
// MessageText:
//
// DNS server not creating or reading the boot file for the directory service integrated DNS zone.
//
#define DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE 9719L

// DNS_ERROR_NODE_IS_DNAME               0x000025f8
//
// MessageId: DNS_ERROR_NODE_IS_DNAME
//
// MessageText:
//
// Node is a DNAME DNS record.
//
#define DNS_ERROR_NODE_IS_DNAME 9720L

// DNS_ERROR_DNAME_COLLISION             0x000025f9
//
// MessageId: DNS_ERROR_DNAME_COLLISION
//
// MessageText:
//
// A DNAME record already exists for given name.
//
#define DNS_ERROR_DNAME_COLLISION 9721L

// DNS_ERROR_ALIAS_LOOP                  0x000025fa
//
// MessageId: DNS_ERROR_ALIAS_LOOP
//
// MessageText:
//
// An alias loop has been detected with either CNAME or DNAME records.
//
#define DNS_ERROR_ALIAS_LOOP 9722L


//
// Operation errors
//

#define DNS_ERROR_OPERATION_BASE 9750

// DNS_INFO_AXFR_COMPLETE                0x00002617
//
// MessageId: DNS_INFO_AXFR_COMPLETE
//
// MessageText:
//
// DNS AXFR (zone transfer) complete.
//
#define DNS_INFO_AXFR_COMPLETE 9751L

// DNS_ERROR_AXFR                        0x00002618
//
// MessageId: DNS_ERROR_AXFR
//
// MessageText:
//
// DNS zone transfer failed.
//
#define DNS_ERROR_AXFR 9752L

// DNS_INFO_ADDED_LOCAL_WINS             0x00002619
//
// MessageId: DNS_INFO_ADDED_LOCAL_WINS
//
// MessageText:
//
// Added local WINS server.
//
#define DNS_INFO_ADDED_LOCAL_WINS 9753L


//
// Secure update
//

#define DNS_ERROR_SECURE_BASE 9800

// DNS_STATUS_CONTINUE_NEEDED            0x00002649
//
// MessageId: DNS_STATUS_CONTINUE_NEEDED
//
// MessageText:
//
// Secure update call needs to continue update request.
//
#define DNS_STATUS_CONTINUE_NEEDED 9801L


//
// Setup errors
//

#define DNS_ERROR_SETUP_BASE 9850

// DNS_ERROR_NO_TCPIP                    0x0000267b
//
// MessageId: DNS_ERROR_NO_TCPIP
//
// MessageText:
//
// TCP/IP network protocol not installed.
//
#define DNS_ERROR_NO_TCPIP 9851L

// DNS_ERROR_NO_DNS_SERVERS              0x0000267c
//
// MessageId: DNS_ERROR_NO_DNS_SERVERS
//
// MessageText:
//
// No DNS servers configured for local system.
//
#define DNS_ERROR_NO_DNS_SERVERS 9852L


//
// Directory partition (DP) errors
//

#define DNS_ERROR_DP_BASE 9900

// DNS_ERROR_DP_DOES_NOT_EXIST           0x000026ad
//
// MessageId: DNS_ERROR_DP_DOES_NOT_EXIST
//
// MessageText:
//
// The specified directory partition does not exist.
//
#define DNS_ERROR_DP_DOES_NOT_EXIST 9901L

// DNS_ERROR_DP_ALREADY_EXISTS           0x000026ae
//
// MessageId: DNS_ERROR_DP_ALREADY_EXISTS
//
// MessageText:
//
// The specified directory partition already exists.
//
#define DNS_ERROR_DP_ALREADY_EXISTS 9902L

// DNS_ERROR_DP_NOT_ENLISTED             0x000026af
//
// MessageId: DNS_ERROR_DP_NOT_ENLISTED
//
// MessageText:
//
// This DNS server is not enlisted in the specified directory partition.
//
#define DNS_ERROR_DP_NOT_ENLISTED 9903L

// DNS_ERROR_DP_ALREADY_ENLISTED         0x000026b0
//
// MessageId: DNS_ERROR_DP_ALREADY_ENLISTED
//
// MessageText:
//
// This DNS server is already enlisted in the specified directory partition.
//
#define DNS_ERROR_DP_ALREADY_ENLISTED 9904L

// DNS_ERROR_DP_NOT_AVAILABLE            0x000026b1
//
// MessageId: DNS_ERROR_DP_NOT_AVAILABLE
//
// MessageText:
//
// The directory partition is not available at this time. Please wait a few minutes and try again.
//
#define DNS_ERROR_DP_NOT_AVAILABLE 9905L

// DNS_ERROR_DP_FSMO_ERROR               0x000026b2
//
// MessageId: DNS_ERROR_DP_FSMO_ERROR
//
// MessageText:
//
// The application directory partition operation failed. The domain controller holding the domain naming master role is down or unable to service the request or is not running Windows Server 2003.
//
#define DNS_ERROR_DP_FSMO_ERROR 9906L


///////////////////////////////////////////////////
//                                               //
//             End of DNS Error Codes            //
//                                               //
//                  9000 to 9999                 //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//               WinSock Error Codes             //
//                                               //
//                 10000 to 11999                //
///////////////////////////////////////////////////

//
// WinSock error codes are also defined in WinSock.h
// and WinSock2.h, hence the IFDEF
//

#define WSABASEERR 10000
//
// MessageId: WSAEINTR
//
// MessageText:
//
// A blocking operation was interrupted by a call to WSACancelBlockingCall.
//
#define WSAEINTR 10004L

//
// MessageId: WSAEBADF
//
// MessageText:
//
// The file handle supplied is not valid.
//
#define WSAEBADF 10009L

//
// MessageId: WSAEACCES
//
// MessageText:
//
// An attempt was made to access a socket in a way forbidden by its access permissions.
//
#define WSAEACCES 10013L

//
// MessageId: WSAEFAULT
//
// MessageText:
//
// The system detected an invalid pointer address in attempting to use a pointer argument in a call.
//
#define WSAEFAULT 10014L

//
// MessageId: WSAEINVAL
//
// MessageText:
//
// An invalid argument was supplied.
//
#define WSAEINVAL 10022L

//
// MessageId: WSAEMFILE
//
// MessageText:
//
// Too many open sockets.
//
#define WSAEMFILE 10024L

//
// MessageId: WSAEWOULDBLOCK
//
// MessageText:
//
// A non-blocking socket operation could not be completed immediately.
//
#define WSAEWOULDBLOCK 10035L

//
// MessageId: WSAEINPROGRESS
//
// MessageText:
//
// A blocking operation is currently executing.
//
#define WSAEINPROGRESS 10036L

//
// MessageId: WSAEALREADY
//
// MessageText:
//
// An operation was attempted on a non-blocking socket that already had an operation in progress.
//
#define WSAEALREADY 10037L

//
// MessageId: WSAENOTSOCK
//
// MessageText:
//
// An operation was attempted on something that is not a socket.
//
#define WSAENOTSOCK 10038L

//
// MessageId: WSAEDESTADDRREQ
//
// MessageText:
//
// A required address was omitted from an operation on a socket.
//
#define WSAEDESTADDRREQ 10039L

//
// MessageId: WSAEMSGSIZE
//
// MessageText:
//
// A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself.
//
#define WSAEMSGSIZE 10040L

//
// MessageId: WSAEPROTOTYPE
//
// MessageText:
//
// A protocol was specified in the socket function call that does not support the semantics of the socket type requested.
//
#define WSAEPROTOTYPE 10041L

//
// MessageId: WSAENOPROTOOPT
//
// MessageText:
//
// An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.
//
#define WSAENOPROTOOPT 10042L

//
// MessageId: WSAEPROTONOSUPPORT
//
// MessageText:
//
// The requested protocol has not been configured into the system, or no implementation for it exists.
//
#define WSAEPROTONOSUPPORT 10043L

//
// MessageId: WSAESOCKTNOSUPPORT
//
// MessageText:
//
// The support for the specified socket type does not exist in this address family.
//
#define WSAESOCKTNOSUPPORT 10044L

//
// MessageId: WSAEOPNOTSUPP
//
// MessageText:
//
// The attempted operation is not supported for the type of object referenced.
//
#define WSAEOPNOTSUPP 10045L

//
// MessageId: WSAEPFNOSUPPORT
//
// MessageText:
//
// The protocol family has not been configured into the system or no implementation for it exists.
//
#define WSAEPFNOSUPPORT 10046L

//
// MessageId: WSAEAFNOSUPPORT
//
// MessageText:
//
// An address incompatible with the requested protocol was used.
//
#define WSAEAFNOSUPPORT 10047L

//
// MessageId: WSAEADDRINUSE
//
// MessageText:
//
// Only one usage of each socket address (protocol/network address/port) is normally permitted.
//
#define WSAEADDRINUSE 10048L

//
// MessageId: WSAEADDRNOTAVAIL
//
// MessageText:
//
// The requested address is not valid in its context.
//
#define WSAEADDRNOTAVAIL 10049L

//
// MessageId: WSAENETDOWN
//
// MessageText:
//
// A socket operation encountered a dead network.
//
#define WSAENETDOWN 10050L

//
// MessageId: WSAENETUNREACH
//
// MessageText:
//
// A socket operation was attempted to an unreachable network.
//
#define WSAENETUNREACH 10051L

//
// MessageId: WSAENETRESET
//
// MessageText:
//
// The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.
//
#define WSAENETRESET 10052L

//
// MessageId: WSAECONNABORTED
//
// MessageText:
//
// An established connection was aborted by the software in your host machine.
//
#define WSAECONNABORTED 10053L

//
// MessageId: WSAECONNRESET
//
// MessageText:
//
// An existing connection was forcibly closed by the remote host.
//
#define WSAECONNRESET 10054L

//
// MessageId: WSAENOBUFS
//
// MessageText:
//
// An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.
//
#define WSAENOBUFS 10055L

//
// MessageId: WSAEISCONN
//
// MessageText:
//
// A connect request was made on an already connected socket.
//
#define WSAEISCONN 10056L

//
// MessageId: WSAENOTCONN
//
// MessageText:
//
// A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.
//
#define WSAENOTCONN 10057L

//
// MessageId: WSAESHUTDOWN
//
// MessageText:
//
// A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call.
//
#define WSAESHUTDOWN 10058L

//
// MessageId: WSAETOOMANYREFS
//
// MessageText:
//
// Too many references to some kernel object.
//
#define WSAETOOMANYREFS 10059L

//
// MessageId: WSAETIMEDOUT
//
// MessageText:
//
// A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.
//
#define WSAETIMEDOUT 10060L

//
// MessageId: WSAECONNREFUSED
//
// MessageText:
//
// No connection could be made because the target machine actively refused it.
//
#define WSAECONNREFUSED 10061L

//
// MessageId: WSAELOOP
//
// MessageText:
//
// Cannot translate name.
//
#define WSAELOOP 10062L

//
// MessageId: WSAENAMETOOLONG
//
// MessageText:
//
// Name component or name was too long.
//
#define WSAENAMETOOLONG 10063L

//
// MessageId: WSAEHOSTDOWN
//
// MessageText:
//
// A socket operation failed because the destination host was down.
//
#define WSAEHOSTDOWN 10064L

//
// MessageId: WSAEHOSTUNREACH
//
// MessageText:
//
// A socket operation was attempted to an unreachable host.
//
#define WSAEHOSTUNREACH 10065L

//
// MessageId: WSAENOTEMPTY
//
// MessageText:
//
// Cannot remove a directory that is not empty.
//
#define WSAENOTEMPTY 10066L

//
// MessageId: WSAEPROCLIM
//
// MessageText:
//
// A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.
//
#define WSAEPROCLIM 10067L

//
// MessageId: WSAEUSERS
//
// MessageText:
//
// Ran out of quota.
//
#define WSAEUSERS 10068L

//
// MessageId: WSAEDQUOT
//
// MessageText:
//
// Ran out of disk quota.
//
#define WSAEDQUOT 10069L

//
// MessageId: WSAESTALE
//
// MessageText:
//
// File handle reference is no longer available.
//
#define WSAESTALE 10070L

//
// MessageId: WSAEREMOTE
//
// MessageText:
//
// Item is not available locally.
//
#define WSAEREMOTE 10071L

//
// MessageId: WSASYSNOTREADY
//
// MessageText:
//
// WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.
//
#define WSASYSNOTREADY 10091L

//
// MessageId: WSAVERNOTSUPPORTED
//
// MessageText:
//
// The Windows Sockets version requested is not supported.
//
#define WSAVERNOTSUPPORTED 10092L

//
// MessageId: WSANOTINITIALISED
//
// MessageText:
//
// Either the application has not called WSAStartup, or WSAStartup failed.
//
#define WSANOTINITIALISED 10093L

//
// MessageId: WSAEDISCON
//
// MessageText:
//
// Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence.
//
#define WSAEDISCON 10101L

//
// MessageId: WSAENOMORE
//
// MessageText:
//
// No more results can be returned by WSALookupServiceNext.
//
#define WSAENOMORE 10102L

//
// MessageId: WSAECANCELLED
//
// MessageText:
//
// A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
//
#define WSAECANCELLED 10103L

//
// MessageId: WSAEINVALIDPROCTABLE
//
// MessageText:
//
// The procedure call table is invalid.
//
#define WSAEINVALIDPROCTABLE 10104L

//
// MessageId: WSAEINVALIDPROVIDER
//
// MessageText:
//
// The requested service provider is invalid.
//
#define WSAEINVALIDPROVIDER 10105L

//
// MessageId: WSAEPROVIDERFAILEDINIT
//
// MessageText:
//
// The requested service provider could not be loaded or initialized.
//
#define WSAEPROVIDERFAILEDINIT 10106L

//
// MessageId: WSASYSCALLFAILURE
//
// MessageText:
//
// A system call has failed.
//
#define WSASYSCALLFAILURE 10107L

//
// MessageId: WSASERVICE_NOT_FOUND
//
// MessageText:
//
// No such service is known. The service cannot be found in the specified name space.
//
#define WSASERVICE_NOT_FOUND 10108L

//
// MessageId: WSATYPE_NOT_FOUND
//
// MessageText:
//
// The specified class was not found.
//
#define WSATYPE_NOT_FOUND 10109L

//
// MessageId: WSA_E_NO_MORE
//
// MessageText:
//
// No more results can be returned by WSALookupServiceNext.
//
#define WSA_E_NO_MORE 10110L

//
// MessageId: WSA_E_CANCELLED
//
// MessageText:
//
// A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.
//
#define WSA_E_CANCELLED 10111L

//
// MessageId: WSAEREFUSED
//
// MessageText:
//
// A database query failed because it was actively refused.
//
#define WSAEREFUSED 10112L

//
// MessageId: WSAHOST_NOT_FOUND
//
// MessageText:
//
// No such host is known.
//
#define WSAHOST_NOT_FOUND 11001L

//
// MessageId: WSATRY_AGAIN
//
// MessageText:
//
// This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.
//
#define WSATRY_AGAIN 11002L

//
// MessageId: WSANO_RECOVERY
//
// MessageText:
//
// A non-recoverable error occurred during a database lookup.
//
#define WSANO_RECOVERY 11003L

//
// MessageId: WSANO_DATA
//
// MessageText:
//
// The requested name is valid, but no data of the requested type was found.
//
#define WSANO_DATA 11004L

//
// MessageId: WSA_QOS_RECEIVERS
//
// MessageText:
//
// At least one reserve has arrived.
//
#define WSA_QOS_RECEIVERS 11005L

//
// MessageId: WSA_QOS_SENDERS
//
// MessageText:
//
// At least one path has arrived.
//
#define WSA_QOS_SENDERS 11006L

//
// MessageId: WSA_QOS_NO_SENDERS
//
// MessageText:
//
// There are no senders.
//
#define WSA_QOS_NO_SENDERS 11007L

//
// MessageId: WSA_QOS_NO_RECEIVERS
//
// MessageText:
//
// There are no receivers.
//
#define WSA_QOS_NO_RECEIVERS 11008L

//
// MessageId: WSA_QOS_REQUEST_CONFIRMED
//
// MessageText:
//
// Reserve has been confirmed.
//
#define WSA_QOS_REQUEST_CONFIRMED 11009L

//
// MessageId: WSA_QOS_ADMISSION_FAILURE
//
// MessageText:
//
// Error due to lack of resources.
//
#define WSA_QOS_ADMISSION_FAILURE 11010L

//
// MessageId: WSA_QOS_POLICY_FAILURE
//
// MessageText:
//
// Rejected for administrative reasons - bad credentials.
//
#define WSA_QOS_POLICY_FAILURE 11011L

//
// MessageId: WSA_QOS_BAD_STYLE
//
// MessageText:
//
// Unknown or conflicting style.
//
#define WSA_QOS_BAD_STYLE 11012L

//
// MessageId: WSA_QOS_BAD_OBJECT
//
// MessageText:
//
// Problem with some part of the filterspec or providerspecific buffer in general.
//
#define WSA_QOS_BAD_OBJECT 11013L

//
// MessageId: WSA_QOS_TRAFFIC_CTRL_ERROR
//
// MessageText:
//
// Problem with some part of the flowspec.
//
#define WSA_QOS_TRAFFIC_CTRL_ERROR 11014L

//
// MessageId: WSA_QOS_GENERIC_ERROR
//
// MessageText:
//
// General QOS error.
//
#define WSA_QOS_GENERIC_ERROR 11015L

//
// MessageId: WSA_QOS_ESERVICETYPE
//
// MessageText:
//
// An invalid or unrecognized service type was found in the flowspec.
//
#define WSA_QOS_ESERVICETYPE 11016L

//
// MessageId: WSA_QOS_EFLOWSPEC
//
// MessageText:
//
// An invalid or inconsistent flowspec was found in the QOS structure.
//
#define WSA_QOS_EFLOWSPEC 11017L

//
// MessageId: WSA_QOS_EPROVSPECBUF
//
// MessageText:
//
// Invalid QOS provider-specific buffer.
//
#define WSA_QOS_EPROVSPECBUF 11018L

//
// MessageId: WSA_QOS_EFILTERSTYLE
//
// MessageText:
//
// An invalid QOS filter style was used.
//
#define WSA_QOS_EFILTERSTYLE 11019L

//
// MessageId: WSA_QOS_EFILTERTYPE
//
// MessageText:
//
// An invalid QOS filter type was used.
//
#define WSA_QOS_EFILTERTYPE 11020L

//
// MessageId: WSA_QOS_EFILTERCOUNT
//
// MessageText:
//
// An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR.
//
#define WSA_QOS_EFILTERCOUNT 11021L

//
// MessageId: WSA_QOS_EOBJLENGTH
//
// MessageText:
//
// An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer.
//
#define WSA_QOS_EOBJLENGTH 11022L

//
// MessageId: WSA_QOS_EFLOWCOUNT
//
// MessageText:
//
// An incorrect number of flow descriptors was specified in the QOS structure.
//
#define WSA_QOS_EFLOWCOUNT 11023L

//
// MessageId: WSA_QOS_EUNKOWNPSOBJ
//
// MessageText:
//
// An unrecognized object was found in the QOS provider-specific buffer.
//
#define WSA_QOS_EUNKOWNPSOBJ 11024L

//
// MessageId: WSA_QOS_EPOLICYOBJ
//
// MessageText:
//
// An invalid policy object was found in the QOS provider-specific buffer.
//
#define WSA_QOS_EPOLICYOBJ 11025L

//
// MessageId: WSA_QOS_EFLOWDESC
//
// MessageText:
//
// An invalid QOS flow descriptor was found in the flow descriptor list.
//
#define WSA_QOS_EFLOWDESC 11026L

//
// MessageId: WSA_QOS_EPSFLOWSPEC
//
// MessageText:
//
// An invalid or inconsistent flowspec was found in the QOS provider specific buffer.
//
#define WSA_QOS_EPSFLOWSPEC 11027L

//
// MessageId: WSA_QOS_EPSFILTERSPEC
//
// MessageText:
//
// An invalid FILTERSPEC was found in the QOS provider-specific buffer.
//
#define WSA_QOS_EPSFILTERSPEC 11028L

//
// MessageId: WSA_QOS_ESDMODEOBJ
//
// MessageText:
//
// An invalid shape discard mode object was found in the QOS provider specific buffer.
//
#define WSA_QOS_ESDMODEOBJ 11029L

//
// MessageId: WSA_QOS_ESHAPERATEOBJ
//
// MessageText:
//
// An invalid shaping rate object was found in the QOS provider-specific buffer.
//
#define WSA_QOS_ESHAPERATEOBJ 11030L

//
// MessageId: WSA_QOS_RESERVED_PETYPE
//
// MessageText:
//
// A reserved policy element was found in the QOS provider-specific buffer.
//
#define WSA_QOS_RESERVED_PETYPE 11031L

//
// MessageId: WSA_SECURE_HOST_NOT_FOUND
//
// MessageText:
//
// No such host is known securely.
//
#define WSA_SECURE_HOST_NOT_FOUND 11032L

//
// MessageId: WSA_IPSEC_NAME_POLICY_ERROR
//
// MessageText:
//
// Name based IPSEC policy could not be added.
//
#define WSA_IPSEC_NAME_POLICY_ERROR 11033L



///////////////////////////////////////////////////
//                                               //
//           End of WinSock Error Codes          //
//                                               //
//                 10000 to 11999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//                  Available                    //
//                                               //
//                 12000 to 12999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//           Start of IPSec Error codes          //
//                                               //
//                 13000 to 13999                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_IPSEC_QM_POLICY_EXISTS
//
// MessageText:
//
// The specified quick mode policy already exists.
//
#define ERROR_IPSEC_QM_POLICY_EXISTS 13000L

//
// MessageId: ERROR_IPSEC_QM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified quick mode policy was not found.
//
#define ERROR_IPSEC_QM_POLICY_NOT_FOUND 13001L

//
// MessageId: ERROR_IPSEC_QM_POLICY_IN_USE
//
// MessageText:
//
// The specified quick mode policy is being used.
//
#define ERROR_IPSEC_QM_POLICY_IN_USE 13002L

//
// MessageId: ERROR_IPSEC_MM_POLICY_EXISTS
//
// MessageText:
//
// The specified main mode policy already exists.
//
#define ERROR_IPSEC_MM_POLICY_EXISTS 13003L

//
// MessageId: ERROR_IPSEC_MM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified main mode policy was not found
//
#define ERROR_IPSEC_MM_POLICY_NOT_FOUND 13004L

//
// MessageId: ERROR_IPSEC_MM_POLICY_IN_USE
//
// MessageText:
//
// The specified main mode policy is being used.
//
#define ERROR_IPSEC_MM_POLICY_IN_USE 13005L

//
// MessageId: ERROR_IPSEC_MM_FILTER_EXISTS
//
// MessageText:
//
// The specified main mode filter already exists.
//
#define ERROR_IPSEC_MM_FILTER_EXISTS 13006L

//
// MessageId: ERROR_IPSEC_MM_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified main mode filter was not found.
//
#define ERROR_IPSEC_MM_FILTER_NOT_FOUND 13007L

//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_EXISTS
//
// MessageText:
//
// The specified transport mode filter already exists.
//
#define ERROR_IPSEC_TRANSPORT_FILTER_EXISTS 13008L

//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified transport mode filter does not exist.
//
#define ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND 13009L

//
// MessageId: ERROR_IPSEC_MM_AUTH_EXISTS
//
// MessageText:
//
// The specified main mode authentication list exists.
//
#define ERROR_IPSEC_MM_AUTH_EXISTS 13010L

//
// MessageId: ERROR_IPSEC_MM_AUTH_NOT_FOUND
//
// MessageText:
//
// The specified main mode authentication list was not found.
//
#define ERROR_IPSEC_MM_AUTH_NOT_FOUND 13011L

//
// MessageId: ERROR_IPSEC_MM_AUTH_IN_USE
//
// MessageText:
//
// The specified main mode authentication list is being used.
//
#define ERROR_IPSEC_MM_AUTH_IN_USE 13012L

//
// MessageId: ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified default main mode policy was not found.
//
#define ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND 13013L

//
// MessageId: ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND
//
// MessageText:
//
// The specified default main mode authentication list was not found.
//
#define ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND 13014L

//
// MessageId: ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND
//
// MessageText:
//
// The specified default quick mode policy was not found.
//
#define ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND 13015L

//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_EXISTS
//
// MessageText:
//
// The specified tunnel mode filter exists.
//
#define ERROR_IPSEC_TUNNEL_FILTER_EXISTS 13016L

//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND
//
// MessageText:
//
// The specified tunnel mode filter was not found.
//
#define ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND 13017L

//
// MessageId: ERROR_IPSEC_MM_FILTER_PENDING_DELETION
//
// MessageText:
//
// The Main Mode filter is pending deletion.
//
#define ERROR_IPSEC_MM_FILTER_PENDING_DELETION 13018L

//
// MessageId: ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION
//
// MessageText:
//
// The transport filter is pending deletion.
//
#define ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION 13019L

//
// MessageId: ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION
//
// MessageText:
//
// The tunnel filter is pending deletion.
//
#define ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION 13020L

//
// MessageId: ERROR_IPSEC_MM_POLICY_PENDING_DELETION
//
// MessageText:
//
// The Main Mode policy is pending deletion.
//
#define ERROR_IPSEC_MM_POLICY_PENDING_DELETION 13021L

//
// MessageId: ERROR_IPSEC_MM_AUTH_PENDING_DELETION
//
// MessageText:
//
// The Main Mode authentication bundle is pending deletion.
//
#define ERROR_IPSEC_MM_AUTH_PENDING_DELETION 13022L

//
// MessageId: ERROR_IPSEC_QM_POLICY_PENDING_DELETION
//
// MessageText:
//
// The Quick Mode policy is pending deletion.
//
#define ERROR_IPSEC_QM_POLICY_PENDING_DELETION 13023L

//
// MessageId: WARNING_IPSEC_MM_POLICY_PRUNED
//
// MessageText:
//
// The Main Mode policy was successfully added, but some of the requested offers are not supported.
//
#define WARNING_IPSEC_MM_POLICY_PRUNED 13024L

//
// MessageId: WARNING_IPSEC_QM_POLICY_PRUNED
//
// MessageText:
//
// The Quick Mode policy was successfully added, but some of the requested offers are not supported.
//
#define WARNING_IPSEC_QM_POLICY_PRUNED 13025L

//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_BEGIN
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_BEGIN
//
#define ERROR_IPSEC_IKE_NEG_STATUS_BEGIN 13800L

//
// MessageId: ERROR_IPSEC_IKE_AUTH_FAIL
//
// MessageText:
//
// IKE authentication credentials are unacceptable
//
#define ERROR_IPSEC_IKE_AUTH_FAIL 13801L

//
// MessageId: ERROR_IPSEC_IKE_ATTRIB_FAIL
//
// MessageText:
//
// IKE security attributes are unacceptable
//
#define ERROR_IPSEC_IKE_ATTRIB_FAIL 13802L

//
// MessageId: ERROR_IPSEC_IKE_NEGOTIATION_PENDING
//
// MessageText:
//
// IKE Negotiation in progress
//
#define ERROR_IPSEC_IKE_NEGOTIATION_PENDING 13803L

//
// MessageId: ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR
//
// MessageText:
//
// General processing error
//
#define ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR 13804L

//
// MessageId: ERROR_IPSEC_IKE_TIMED_OUT
//
// MessageText:
//
// Negotiation timed out
//
#define ERROR_IPSEC_IKE_TIMED_OUT 13805L

//
// MessageId: ERROR_IPSEC_IKE_NO_CERT
//
// MessageText:
//
// IKE failed to find valid machine certificate. Contact your Network Security Administrator about installing a valid certificate in the appropriate Certificate Store.
//
#define ERROR_IPSEC_IKE_NO_CERT 13806L

//
// MessageId: ERROR_IPSEC_IKE_SA_DELETED
//
// MessageText:
//
// IKE SA deleted by peer before establishment completed
//
#define ERROR_IPSEC_IKE_SA_DELETED 13807L

//
// MessageId: ERROR_IPSEC_IKE_SA_REAPED
//
// MessageText:
//
// IKE SA deleted before establishment completed
//
#define ERROR_IPSEC_IKE_SA_REAPED 13808L

//
// MessageId: ERROR_IPSEC_IKE_MM_ACQUIRE_DROP
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
#define ERROR_IPSEC_IKE_MM_ACQUIRE_DROP 13809L

//
// MessageId: ERROR_IPSEC_IKE_QM_ACQUIRE_DROP
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
#define ERROR_IPSEC_IKE_QM_ACQUIRE_DROP 13810L

//
// MessageId: ERROR_IPSEC_IKE_QUEUE_DROP_MM
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
#define ERROR_IPSEC_IKE_QUEUE_DROP_MM 13811L

//
// MessageId: ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM
//
// MessageText:
//
// Negotiation request sat in Queue too long
//
#define ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM 13812L

//
// MessageId: ERROR_IPSEC_IKE_DROP_NO_RESPONSE
//
// MessageText:
//
// No response from peer
//
#define ERROR_IPSEC_IKE_DROP_NO_RESPONSE 13813L

//
// MessageId: ERROR_IPSEC_IKE_MM_DELAY_DROP
//
// MessageText:
//
// Negotiation took too long
//
#define ERROR_IPSEC_IKE_MM_DELAY_DROP 13814L

//
// MessageId: ERROR_IPSEC_IKE_QM_DELAY_DROP
//
// MessageText:
//
// Negotiation took too long
//
#define ERROR_IPSEC_IKE_QM_DELAY_DROP 13815L

//
// MessageId: ERROR_IPSEC_IKE_ERROR
//
// MessageText:
//
// Unknown error occurred
//
#define ERROR_IPSEC_IKE_ERROR 13816L

//
// MessageId: ERROR_IPSEC_IKE_CRL_FAILED
//
// MessageText:
//
// Certificate Revocation Check failed
//
#define ERROR_IPSEC_IKE_CRL_FAILED 13817L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_KEY_USAGE
//
// MessageText:
//
// Invalid certificate key usage
//
#define ERROR_IPSEC_IKE_INVALID_KEY_USAGE 13818L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_CERT_TYPE
//
// MessageText:
//
// Invalid certificate type
//
#define ERROR_IPSEC_IKE_INVALID_CERT_TYPE 13819L

//
// MessageId: ERROR_IPSEC_IKE_NO_PRIVATE_KEY
//
// MessageText:
//
// IKE negotiation failed because the machine certificate used does not have a private key. IPsec certificates require a private key. Contact your Network Security administrator about replacing with a certificate that has a private key.
//
#define ERROR_IPSEC_IKE_NO_PRIVATE_KEY 13820L

//
// MessageId: ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY
//
// MessageText:
//
// Simultaneous rekeys were detected.
//
#define ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY 13821L

//
// MessageId: ERROR_IPSEC_IKE_DH_FAIL
//
// MessageText:
//
// Failure in Diffie-Hellman computation
//
#define ERROR_IPSEC_IKE_DH_FAIL 13822L

//
// MessageId: ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED
//
// MessageText:
//
// Don't know how to process critical payload
//
#define ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED 13823L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_HEADER
//
// MessageText:
//
// Invalid header
//
#define ERROR_IPSEC_IKE_INVALID_HEADER 13824L

//
// MessageId: ERROR_IPSEC_IKE_NO_POLICY
//
// MessageText:
//
// No policy configured
//
#define ERROR_IPSEC_IKE_NO_POLICY 13825L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_SIGNATURE
//
// MessageText:
//
// Failed to verify signature
//
#define ERROR_IPSEC_IKE_INVALID_SIGNATURE 13826L

//
// MessageId: ERROR_IPSEC_IKE_KERBEROS_ERROR
//
// MessageText:
//
// Failed to authenticate using Kerberos
//
#define ERROR_IPSEC_IKE_KERBEROS_ERROR 13827L

//
// MessageId: ERROR_IPSEC_IKE_NO_PUBLIC_KEY
//
// MessageText:
//
// Peer's certificate did not have a public key
//
#define ERROR_IPSEC_IKE_NO_PUBLIC_KEY 13828L

// These must stay as a unit.
//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR
//
// MessageText:
//
// Error processing error payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR 13829L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_SA
//
// MessageText:
//
// Error processing SA payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_SA 13830L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_PROP
//
// MessageText:
//
// Error processing Proposal payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_PROP 13831L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_TRANS
//
// MessageText:
//
// Error processing Transform payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_TRANS 13832L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_KE
//
// MessageText:
//
// Error processing KE payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_KE 13833L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_ID
//
// MessageText:
//
// Error processing ID payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_ID 13834L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_CERT
//
// MessageText:
//
// Error processing Cert payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_CERT 13835L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ
//
// MessageText:
//
// Error processing Certificate Request payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ 13836L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_HASH
//
// MessageText:
//
// Error processing Hash payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_HASH 13837L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_SIG
//
// MessageText:
//
// Error processing Signature payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_SIG 13838L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NONCE
//
// MessageText:
//
// Error processing Nonce payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_NONCE 13839L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY
//
// MessageText:
//
// Error processing Notify payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY 13840L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_DELETE
//
// MessageText:
//
// Error processing Delete Payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_DELETE 13841L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR
//
// MessageText:
//
// Error processing VendorId payload
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR 13842L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_PAYLOAD
//
// MessageText:
//
// Invalid payload received
//
#define ERROR_IPSEC_IKE_INVALID_PAYLOAD 13843L

//
// MessageId: ERROR_IPSEC_IKE_LOAD_SOFT_SA
//
// MessageText:
//
// Soft SA loaded
//
#define ERROR_IPSEC_IKE_LOAD_SOFT_SA 13844L

//
// MessageId: ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN
//
// MessageText:
//
// Soft SA torn down
//
#define ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN 13845L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_COOKIE
//
// MessageText:
//
// Invalid cookie received.
//
#define ERROR_IPSEC_IKE_INVALID_COOKIE 13846L

//
// MessageId: ERROR_IPSEC_IKE_NO_PEER_CERT
//
// MessageText:
//
// Peer failed to send valid machine certificate
//
#define ERROR_IPSEC_IKE_NO_PEER_CERT 13847L

//
// MessageId: ERROR_IPSEC_IKE_PEER_CRL_FAILED
//
// MessageText:
//
// Certification Revocation check of peer's certificate failed
//
#define ERROR_IPSEC_IKE_PEER_CRL_FAILED 13848L

//
// MessageId: ERROR_IPSEC_IKE_POLICY_CHANGE
//
// MessageText:
//
// New policy invalidated SAs formed with old policy
//
#define ERROR_IPSEC_IKE_POLICY_CHANGE 13849L

//
// MessageId: ERROR_IPSEC_IKE_NO_MM_POLICY
//
// MessageText:
//
// There is no available Main Mode IKE policy.
//
#define ERROR_IPSEC_IKE_NO_MM_POLICY 13850L

//
// MessageId: ERROR_IPSEC_IKE_NOTCBPRIV
//
// MessageText:
//
// Failed to enabled TCB privilege.
//
#define ERROR_IPSEC_IKE_NOTCBPRIV 13851L

//
// MessageId: ERROR_IPSEC_IKE_SECLOADFAIL
//
// MessageText:
//
// Failed to load SECURITY.DLL.
//
#define ERROR_IPSEC_IKE_SECLOADFAIL 13852L

//
// MessageId: ERROR_IPSEC_IKE_FAILSSPINIT
//
// MessageText:
//
// Failed to obtain security function table dispatch address from SSPI.
//
#define ERROR_IPSEC_IKE_FAILSSPINIT 13853L

//
// MessageId: ERROR_IPSEC_IKE_FAILQUERYSSP
//
// MessageText:
//
// Failed to query Kerberos package to obtain max token size.
//
#define ERROR_IPSEC_IKE_FAILQUERYSSP 13854L

//
// MessageId: ERROR_IPSEC_IKE_SRVACQFAIL
//
// MessageText:
//
// Failed to obtain Kerberos server credentials for ISAKMP/ERROR_IPSEC_IKE service. Kerberos authentication will not function. The most likely reason for this is lack of domain membership. This is normal if your computer is a member of a workgroup.
//
#define ERROR_IPSEC_IKE_SRVACQFAIL 13855L

//
// MessageId: ERROR_IPSEC_IKE_SRVQUERYCRED
//
// MessageText:
//
// Failed to determine SSPI principal name for ISAKMP/ERROR_IPSEC_IKE service (QueryCredentialsAttributes).
//
#define ERROR_IPSEC_IKE_SRVQUERYCRED 13856L

//
// MessageId: ERROR_IPSEC_IKE_GETSPIFAIL
//
// MessageText:
//
// Failed to obtain new SPI for the inbound SA from Ipsec driver. The most common cause for this is that the driver does not have the correct filter. Check your policy to verify the filters.
//
#define ERROR_IPSEC_IKE_GETSPIFAIL 13857L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_FILTER
//
// MessageText:
//
// Given filter is invalid
//
#define ERROR_IPSEC_IKE_INVALID_FILTER 13858L

//
// MessageId: ERROR_IPSEC_IKE_OUT_OF_MEMORY
//
// MessageText:
//
// Memory allocation failed.
//
#define ERROR_IPSEC_IKE_OUT_OF_MEMORY 13859L

//
// MessageId: ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED
//
// MessageText:
//
// Failed to add Security Association to IPSec Driver. The most common cause for this is if the IKE negotiation took too long to complete. If the problem persists, reduce the load on the faulting machine.
//
#define ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED 13860L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_POLICY
//
// MessageText:
//
// Invalid policy
//
#define ERROR_IPSEC_IKE_INVALID_POLICY 13861L

//
// MessageId: ERROR_IPSEC_IKE_UNKNOWN_DOI
//
// MessageText:
//
// Invalid DOI
//
#define ERROR_IPSEC_IKE_UNKNOWN_DOI 13862L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_SITUATION
//
// MessageText:
//
// Invalid situation
//
#define ERROR_IPSEC_IKE_INVALID_SITUATION 13863L

//
// MessageId: ERROR_IPSEC_IKE_DH_FAILURE
//
// MessageText:
//
// Diffie-Hellman failure
//
#define ERROR_IPSEC_IKE_DH_FAILURE 13864L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_GROUP
//
// MessageText:
//
// Invalid Diffie-Hellman group
//
#define ERROR_IPSEC_IKE_INVALID_GROUP 13865L

//
// MessageId: ERROR_IPSEC_IKE_ENCRYPT
//
// MessageText:
//
// Error encrypting payload
//
#define ERROR_IPSEC_IKE_ENCRYPT 13866L

//
// MessageId: ERROR_IPSEC_IKE_DECRYPT
//
// MessageText:
//
// Error decrypting payload
//
#define ERROR_IPSEC_IKE_DECRYPT 13867L

//
// MessageId: ERROR_IPSEC_IKE_POLICY_MATCH
//
// MessageText:
//
// Policy match error
//
#define ERROR_IPSEC_IKE_POLICY_MATCH 13868L

//
// MessageId: ERROR_IPSEC_IKE_UNSUPPORTED_ID
//
// MessageText:
//
// Unsupported ID
//
#define ERROR_IPSEC_IKE_UNSUPPORTED_ID 13869L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH
//
// MessageText:
//
// Hash verification failed
//
#define ERROR_IPSEC_IKE_INVALID_HASH 13870L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH_ALG
//
// MessageText:
//
// Invalid hash algorithm
//
#define ERROR_IPSEC_IKE_INVALID_HASH_ALG 13871L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_HASH_SIZE
//
// MessageText:
//
// Invalid hash size
//
#define ERROR_IPSEC_IKE_INVALID_HASH_SIZE 13872L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG
//
// MessageText:
//
// Invalid encryption algorithm
//
#define ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG 13873L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_AUTH_ALG
//
// MessageText:
//
// Invalid authentication algorithm
//
#define ERROR_IPSEC_IKE_INVALID_AUTH_ALG 13874L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_SIG
//
// MessageText:
//
// Invalid certificate signature
//
#define ERROR_IPSEC_IKE_INVALID_SIG 13875L

//
// MessageId: ERROR_IPSEC_IKE_LOAD_FAILED
//
// MessageText:
//
// Load failed
//
#define ERROR_IPSEC_IKE_LOAD_FAILED 13876L

//
// MessageId: ERROR_IPSEC_IKE_RPC_DELETE
//
// MessageText:
//
// Deleted via RPC call
//
#define ERROR_IPSEC_IKE_RPC_DELETE 13877L

//
// MessageId: ERROR_IPSEC_IKE_BENIGN_REINIT
//
// MessageText:
//
// Temporary state created to perform reinit. This is not a real failure.
//
#define ERROR_IPSEC_IKE_BENIGN_REINIT 13878L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY
//
// MessageText:
//
// The lifetime value received in the Responder Lifetime Notify is below the Windows 2000 configured minimum value. Please fix the policy on the peer machine.
//
#define ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY 13879L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION
//
// MessageText:
//
// The recipient cannot handle version of IKE specified in the header.
//
#define ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION 13880L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN
//
// MessageText:
//
// Key length in certificate is too small for configured security requirements.
//
#define ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN 13881L

//
// MessageId: ERROR_IPSEC_IKE_MM_LIMIT
//
// MessageText:
//
// Max number of established MM SAs to peer exceeded.
//
#define ERROR_IPSEC_IKE_MM_LIMIT 13882L

//
// MessageId: ERROR_IPSEC_IKE_NEGOTIATION_DISABLED
//
// MessageText:
//
// IKE received a policy that disables negotiation.
//
#define ERROR_IPSEC_IKE_NEGOTIATION_DISABLED 13883L

//
// MessageId: ERROR_IPSEC_IKE_QM_LIMIT
//
// MessageText:
//
// Reached maximum quick mode limit for the main mode. New main mode will be started.
//
#define ERROR_IPSEC_IKE_QM_LIMIT 13884L

//
// MessageId: ERROR_IPSEC_IKE_MM_EXPIRED
//
// MessageText:
//
// Main mode SA lifetime expired or peer sent a main mode delete.
//
#define ERROR_IPSEC_IKE_MM_EXPIRED 13885L

//
// MessageId: ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID
//
// MessageText:
//
// Main mode SA assumed to be invalid because peer stopped responding.
//
#define ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID 13886L

//
// MessageId: ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH
//
// MessageText:
//
// Certificate doesn't chain to a trusted root in IPsec policy.
//
#define ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH 13887L

//
// MessageId: ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID
//
// MessageText:
//
// Received unexpected message ID.
//
#define ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID 13888L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD
//
// MessageText:
//
// Received invalid authentication offers.
//
#define ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD 13889L

//
// MessageId: ERROR_IPSEC_IKE_DOS_COOKIE_SENT
//
// MessageText:
//
// Sent DoS cookie notify to initiator.
//
#define ERROR_IPSEC_IKE_DOS_COOKIE_SENT 13890L

//
// MessageId: ERROR_IPSEC_IKE_SHUTTING_DOWN
//
// MessageText:
//
// IKE service is shutting down.
//
#define ERROR_IPSEC_IKE_SHUTTING_DOWN 13891L

//
// MessageId: ERROR_IPSEC_IKE_CGA_AUTH_FAILED
//
// MessageText:
//
// Could not verify binding between CGA address and certificate.
//
#define ERROR_IPSEC_IKE_CGA_AUTH_FAILED 13892L

//
// MessageId: ERROR_IPSEC_IKE_PROCESS_ERR_NATOA
//
// MessageText:
//
// Error processing NatOA payload.
//
#define ERROR_IPSEC_IKE_PROCESS_ERR_NATOA 13893L

//
// MessageId: ERROR_IPSEC_IKE_INVALID_MM_FOR_QM
//
// MessageText:
//
// Parameters of the main mode are invalid for this quick mode.
//
#define ERROR_IPSEC_IKE_INVALID_MM_FOR_QM 13894L

//
// MessageId: ERROR_IPSEC_IKE_QM_EXPIRED
//
// MessageText:
//
// Quick mode SA was expired by IPsec driver.
//
#define ERROR_IPSEC_IKE_QM_EXPIRED 13895L

//
// MessageId: ERROR_IPSEC_IKE_TOO_MANY_FILTERS
//
// MessageText:
//
// Too many dynamically added IKEEXT filters were detected.
//
#define ERROR_IPSEC_IKE_TOO_MANY_FILTERS 13896L

// Do NOT change this final value.  It is used in a public API structure
//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_END
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_END
//
#define ERROR_IPSEC_IKE_NEG_STATUS_END 13897L

//
// MessageId: ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL
//
// MessageText:
//
// NAP reauth succeeded and must delete the dummy NAP IkeV2 tunnel.
//
#define ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL 13898L

//
// MessageId: ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE
//
// MessageText:
//
// Error in assigning inner IP address to intiator in tunnel mode.
//
#define ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE 13899L

//
// MessageId: ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING
//
// MessageText:
//
// Require configuration payload missing.
//
#define ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING 13900L

//
// MessageId: ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING
//
// MessageText:
//
// A negotiation running as the security principle who issued the connection is in progress
//
#define ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING 13901L

//
// MessageId: ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS
//
// MessageText:
//
// SA was deleted due to IKEv1/AuthIP co-existence suppress check.
//
#define ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS 13902L

//
// MessageId: ERROR_IPSEC_IKE_RATELIMIT_DROP
//
// MessageText:
//
// Incoming SA request was dropped due to peer IP address rate limiting.
//
#define ERROR_IPSEC_IKE_RATELIMIT_DROP 13903L

//
// MessageId: ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE
//
// MessageText:
//
// Peer does not support MOBIKE.
//
#define ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE 13904L

//
// MessageId: ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE
//
// MessageText:
//
// SA establishment is not authorized.
//
#define ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE 13905L

//
// MessageId: ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE
//
// MessageText:
//
// SA establishment is not authorized because there is not a sufficiently strong PKINIT-based credential.
//
#define ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE 13906L

//
// MessageId: ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY
//
// MessageText:
//
// SA establishment is not authorized.  You may need to enter updated or different credentials such as a smartcard.
//
#define ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY 13907L

//
// MessageId: ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE
//
// MessageText:
//
// SA establishment is not authorized because there is not a sufficiently strong PKINIT-based credential. This might be related to certificate-to-account mapping failure for the SA.
//
#define ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE 13908L

// Extended upper bound for IKE errors to accomodate new errors
//
// MessageId: ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END
//
// MessageText:
//
//  ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END
//
#define ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END 13909L

//
// Following error codes are returned by IPsec kernel.
//
//
// MessageId: ERROR_IPSEC_BAD_SPI
//
// MessageText:
//
// The SPI in the packet does not match a valid IPsec SA.
//
#define ERROR_IPSEC_BAD_SPI 13910L

//
// MessageId: ERROR_IPSEC_SA_LIFETIME_EXPIRED
//
// MessageText:
//
// Packet was received on an IPsec SA whose lifetime has expired.
//
#define ERROR_IPSEC_SA_LIFETIME_EXPIRED 13911L

//
// MessageId: ERROR_IPSEC_WRONG_SA
//
// MessageText:
//
// Packet was received on an IPsec SA that does not match the packet characteristics.
//
#define ERROR_IPSEC_WRONG_SA 13912L

//
// MessageId: ERROR_IPSEC_REPLAY_CHECK_FAILED
//
// MessageText:
//
// Packet sequence number replay check failed.
//
#define ERROR_IPSEC_REPLAY_CHECK_FAILED 13913L

//
// MessageId: ERROR_IPSEC_INVALID_PACKET
//
// MessageText:
//
// IPsec header and/or trailer in the packet is invalid.
//
#define ERROR_IPSEC_INVALID_PACKET 13914L

//
// MessageId: ERROR_IPSEC_INTEGRITY_CHECK_FAILED
//
// MessageText:
//
// IPsec integrity check failed.
//
#define ERROR_IPSEC_INTEGRITY_CHECK_FAILED 13915L

//
// MessageId: ERROR_IPSEC_CLEAR_TEXT_DROP
//
// MessageText:
//
// IPsec dropped a clear text packet.
//
#define ERROR_IPSEC_CLEAR_TEXT_DROP 13916L

//
// MessageId: ERROR_IPSEC_AUTH_FIREWALL_DROP
//
// MessageText:
//
// IPsec dropped an incoming ESP packet in authenticated firewall mode. This drop is benign.
//
#define ERROR_IPSEC_AUTH_FIREWALL_DROP 13917L

//
// MessageId: ERROR_IPSEC_THROTTLE_DROP
//
// MessageText:
//
// IPsec dropped a packet due to DoS throttling.
//
#define ERROR_IPSEC_THROTTLE_DROP 13918L

//
// MessageId: ERROR_IPSEC_DOSP_BLOCK
//
// MessageText:
//
// IPsec DoS Protection matched an explicit block rule.
//
#define ERROR_IPSEC_DOSP_BLOCK 13925L

//
// MessageId: ERROR_IPSEC_DOSP_RECEIVED_MULTICAST
//
// MessageText:
//
// IPsec DoS Protection received an IPsec specific multicast packet which is not allowed.
//
#define ERROR_IPSEC_DOSP_RECEIVED_MULTICAST 13926L

//
// MessageId: ERROR_IPSEC_DOSP_INVALID_PACKET
//
// MessageText:
//
// IPsec DoS Protection received an incorrectly formatted packet.
//
#define ERROR_IPSEC_DOSP_INVALID_PACKET 13927L

//
// MessageId: ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED
//
// MessageText:
//
// IPsec DoS Protection failed to look up state.
//
#define ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED 13928L

//
// MessageId: ERROR_IPSEC_DOSP_MAX_ENTRIES
//
// MessageText:
//
// IPsec DoS Protection failed to create state because the maximum number of entries allowed by policy has been reached.
//
#define ERROR_IPSEC_DOSP_MAX_ENTRIES 13929L

//
// MessageId: ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED
//
// MessageText:
//
// IPsec DoS Protection received an IPsec negotiation packet for a keying module which is not allowed by policy.
//
#define ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED 13930L

//
// MessageId: ERROR_IPSEC_DOSP_NOT_INSTALLED
//
// MessageText:
//
// IPsec DoS Protection has not been enabled.
//
#define ERROR_IPSEC_DOSP_NOT_INSTALLED 13931L

//
// MessageId: ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES
//
// MessageText:
//
// IPsec DoS Protection failed to create a per internal IP rate limit queue because the maximum number of queues allowed by policy has been reached.
//
#define ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES 13932L


///////////////////////////////////////////////////
//                                               //
//           End of IPSec Error codes            //
//                                               //
//                 13000 to 13999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//         Start of Side By Side Error Codes     //
//                                               //
//                 14000 to 14999                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_SXS_SECTION_NOT_FOUND
//
// MessageText:
//
// The requested section was not present in the activation context.
//
#define ERROR_SXS_SECTION_NOT_FOUND 14000L

//
// MessageId: ERROR_SXS_CANT_GEN_ACTCTX
//
// MessageText:
//
// The application has failed to start because its side-by-side configuration is incorrect. Please see the application event log or use the command-line sxstrace.exe tool for more detail.
//
#define ERROR_SXS_CANT_GEN_ACTCTX 14001L

//
// MessageId: ERROR_SXS_INVALID_ACTCTXDATA_FORMAT
//
// MessageText:
//
// The application binding data format is invalid.
//
#define ERROR_SXS_INVALID_ACTCTXDATA_FORMAT 14002L

//
// MessageId: ERROR_SXS_ASSEMBLY_NOT_FOUND
//
// MessageText:
//
// The referenced assembly is not installed on your system.
//
#define ERROR_SXS_ASSEMBLY_NOT_FOUND 14003L

//
// MessageId: ERROR_SXS_MANIFEST_FORMAT_ERROR
//
// MessageText:
//
// The manifest file does not begin with the required tag and format information.
//
#define ERROR_SXS_MANIFEST_FORMAT_ERROR 14004L

//
// MessageId: ERROR_SXS_MANIFEST_PARSE_ERROR
//
// MessageText:
//
// The manifest file contains one or more syntax errors.
//
#define ERROR_SXS_MANIFEST_PARSE_ERROR 14005L

//
// MessageId: ERROR_SXS_ACTIVATION_CONTEXT_DISABLED
//
// MessageText:
//
// The application attempted to activate a disabled activation context.
//
#define ERROR_SXS_ACTIVATION_CONTEXT_DISABLED 14006L

//
// MessageId: ERROR_SXS_KEY_NOT_FOUND
//
// MessageText:
//
// The requested lookup key was not found in any active activation context.
//
#define ERROR_SXS_KEY_NOT_FOUND 14007L

//
// MessageId: ERROR_SXS_VERSION_CONFLICT
//
// MessageText:
//
// A component version required by the application conflicts with another component version already active.
//
#define ERROR_SXS_VERSION_CONFLICT 14008L

//
// MessageId: ERROR_SXS_WRONG_SECTION_TYPE
//
// MessageText:
//
// The type requested activation context section does not match the query API used.
//
#define ERROR_SXS_WRONG_SECTION_TYPE 14009L

//
// MessageId: ERROR_SXS_THREAD_QUERIES_DISABLED
//
// MessageText:
//
// Lack of system resources has required isolated activation to be disabled for the current thread of execution.
//
#define ERROR_SXS_THREAD_QUERIES_DISABLED 14010L

//
// MessageId: ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET
//
// MessageText:
//
// An attempt to set the process default activation context failed because the process default activation context was already set.
//
#define ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET 14011L

//
// MessageId: ERROR_SXS_UNKNOWN_ENCODING_GROUP
//
// MessageText:
//
// The encoding group identifier specified is not recognized.
//
#define ERROR_SXS_UNKNOWN_ENCODING_GROUP 14012L

//
// MessageId: ERROR_SXS_UNKNOWN_ENCODING
//
// MessageText:
//
// The encoding requested is not recognized.
//
#define ERROR_SXS_UNKNOWN_ENCODING 14013L

//
// MessageId: ERROR_SXS_INVALID_XML_NAMESPACE_URI
//
// MessageText:
//
// The manifest contains a reference to an invalid URI.
//
#define ERROR_SXS_INVALID_XML_NAMESPACE_URI 14014L

//
// MessageId: ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED
//
// MessageText:
//
// The application manifest contains a reference to a dependent assembly which is not installed
//
#define ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED 14015L

//
// MessageId: ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED
//
// MessageText:
//
// The manifest for an assembly used by the application has a reference to a dependent assembly which is not installed
//
#define ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED 14016L

//
// MessageId: ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE
//
// MessageText:
//
// The manifest contains an attribute for the assembly identity which is not valid.
//
#define ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE 14017L

//
// MessageId: ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE
//
// MessageText:
//
// The manifest is missing the required default namespace specification on the assembly element.
//
#define ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE 14018L

//
// MessageId: ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE
//
// MessageText:
//
// The manifest has a default namespace specified on the assembly element but its value is not "urn:schemas-microsoft-com:asm.v1".
//
#define ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE 14019L

//
// MessageId: ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT
//
// MessageText:
//
// The private manifest probed has crossed a path with an unsupported reparse point.
//
#define ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT 14020L

//
// MessageId: ERROR_SXS_DUPLICATE_DLL_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have files by the same name.
//
#define ERROR_SXS_DUPLICATE_DLL_NAME 14021L

//
// MessageId: ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have window classes with the same name.
//
#define ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME 14022L

//
// MessageId: ERROR_SXS_DUPLICATE_CLSID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM server CLSIDs.
//
#define ERROR_SXS_DUPLICATE_CLSID 14023L

//
// MessageId: ERROR_SXS_DUPLICATE_IID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have proxies for the same COM interface IIDs.
//
#define ERROR_SXS_DUPLICATE_IID 14024L

//
// MessageId: ERROR_SXS_DUPLICATE_TLBID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM type library TLBIDs.
//
#define ERROR_SXS_DUPLICATE_TLBID 14025L

//
// MessageId: ERROR_SXS_DUPLICATE_PROGID
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest have the same COM ProgIDs.
//
#define ERROR_SXS_DUPLICATE_PROGID 14026L

//
// MessageId: ERROR_SXS_DUPLICATE_ASSEMBLY_NAME
//
// MessageText:
//
// Two or more components referenced directly or indirectly by the application manifest are different versions of the same component which is not permitted.
//
#define ERROR_SXS_DUPLICATE_ASSEMBLY_NAME 14027L

//
// MessageId: ERROR_SXS_FILE_HASH_MISMATCH
//
// MessageText:
//
// A component's file does not match the verification information present in the component manifest.
//
#define ERROR_SXS_FILE_HASH_MISMATCH 14028L

//
// MessageId: ERROR_SXS_POLICY_PARSE_ERROR
//
// MessageText:
//
// The policy manifest contains one or more syntax errors.
//
#define ERROR_SXS_POLICY_PARSE_ERROR 14029L

//
// MessageId: ERROR_SXS_XML_E_MISSINGQUOTE
//
// MessageText:
//
// Manifest Parse Error : A string literal was expected, but no opening quote character was found.
//
#define ERROR_SXS_XML_E_MISSINGQUOTE 14030L

//
// MessageId: ERROR_SXS_XML_E_COMMENTSYNTAX
//
// MessageText:
//
// Manifest Parse Error : Incorrect syntax was used in a comment.
//
#define ERROR_SXS_XML_E_COMMENTSYNTAX 14031L

//
// MessageId: ERROR_SXS_XML_E_BADSTARTNAMECHAR
//
// MessageText:
//
// Manifest Parse Error : A name was started with an invalid character.
//
#define ERROR_SXS_XML_E_BADSTARTNAMECHAR 14032L

//
// MessageId: ERROR_SXS_XML_E_BADNAMECHAR
//
// MessageText:
//
// Manifest Parse Error : A name contained an invalid character.
//
#define ERROR_SXS_XML_E_BADNAMECHAR 14033L

//
// MessageId: ERROR_SXS_XML_E_BADCHARINSTRING
//
// MessageText:
//
// Manifest Parse Error : A string literal contained an invalid character.
//
#define ERROR_SXS_XML_E_BADCHARINSTRING 14034L

//
// MessageId: ERROR_SXS_XML_E_XMLDECLSYNTAX
//
// MessageText:
//
// Manifest Parse Error : Invalid syntax for an xml declaration.
//
#define ERROR_SXS_XML_E_XMLDECLSYNTAX 14035L

//
// MessageId: ERROR_SXS_XML_E_BADCHARDATA
//
// MessageText:
//
// Manifest Parse Error : An Invalid character was found in text content.
//
#define ERROR_SXS_XML_E_BADCHARDATA 14036L

//
// MessageId: ERROR_SXS_XML_E_MISSINGWHITESPACE
//
// MessageText:
//
// Manifest Parse Error : Required white space was missing.
//
#define ERROR_SXS_XML_E_MISSINGWHITESPACE 14037L

//
// MessageId: ERROR_SXS_XML_E_EXPECTINGTAGEND
//
// MessageText:
//
// Manifest Parse Error : The character '>' was expected.
//
#define ERROR_SXS_XML_E_EXPECTINGTAGEND 14038L

//
// MessageId: ERROR_SXS_XML_E_MISSINGSEMICOLON
//
// MessageText:
//
// Manifest Parse Error : A semi colon character was expected.
//
#define ERROR_SXS_XML_E_MISSINGSEMICOLON 14039L

//
// MessageId: ERROR_SXS_XML_E_UNBALANCEDPAREN
//
// MessageText:
//
// Manifest Parse Error : Unbalanced parentheses.
//
#define ERROR_SXS_XML_E_UNBALANCEDPAREN 14040L

//
// MessageId: ERROR_SXS_XML_E_INTERNALERROR
//
// MessageText:
//
// Manifest Parse Error : Internal error.
//
#define ERROR_SXS_XML_E_INTERNALERROR 14041L

//
// MessageId: ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE
//
// MessageText:
//
// Manifest Parse Error : Whitespace is not allowed at this location.
//
#define ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE 14042L

//
// MessageId: ERROR_SXS_XML_E_INCOMPLETE_ENCODING
//
// MessageText:
//
// Manifest Parse Error : End of file reached in invalid state for current encoding.
//
#define ERROR_SXS_XML_E_INCOMPLETE_ENCODING 14043L

//
// MessageId: ERROR_SXS_XML_E_MISSING_PAREN
//
// MessageText:
//
// Manifest Parse Error : Missing parenthesis.
//
#define ERROR_SXS_XML_E_MISSING_PAREN 14044L

//
// MessageId: ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE
//
// MessageText:
//
// Manifest Parse Error : A single or double closing quote character (\' or \") is missing.
//
#define ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE 14045L

//
// MessageId: ERROR_SXS_XML_E_MULTIPLE_COLONS
//
// MessageText:
//
// Manifest Parse Error : Multiple colons are not allowed in a name.
//
#define ERROR_SXS_XML_E_MULTIPLE_COLONS 14046L

//
// MessageId: ERROR_SXS_XML_E_INVALID_DECIMAL
//
// MessageText:
//
// Manifest Parse Error : Invalid character for decimal digit.
//
#define ERROR_SXS_XML_E_INVALID_DECIMAL 14047L

//
// MessageId: ERROR_SXS_XML_E_INVALID_HEXIDECIMAL
//
// MessageText:
//
// Manifest Parse Error : Invalid character for hexadecimal digit.
//
#define ERROR_SXS_XML_E_INVALID_HEXIDECIMAL 14048L

//
// MessageId: ERROR_SXS_XML_E_INVALID_UNICODE
//
// MessageText:
//
// Manifest Parse Error : Invalid unicode character value for this platform.
//
#define ERROR_SXS_XML_E_INVALID_UNICODE 14049L

//
// MessageId: ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK
//
// MessageText:
//
// Manifest Parse Error : Expecting whitespace or '?'.
//
#define ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK 14050L

//
// MessageId: ERROR_SXS_XML_E_UNEXPECTEDENDTAG
//
// MessageText:
//
// Manifest Parse Error : End tag was not expected at this location.
//
#define ERROR_SXS_XML_E_UNEXPECTEDENDTAG 14051L

//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDTAG
//
// MessageText:
//
// Manifest Parse Error : The following tags were not closed: %1.
//
#define ERROR_SXS_XML_E_UNCLOSEDTAG 14052L

//
// MessageId: ERROR_SXS_XML_E_DUPLICATEATTRIBUTE
//
// MessageText:
//
// Manifest Parse Error : Duplicate attribute.
//
#define ERROR_SXS_XML_E_DUPLICATEATTRIBUTE 14053L

//
// MessageId: ERROR_SXS_XML_E_MULTIPLEROOTS
//
// MessageText:
//
// Manifest Parse Error : Only one top level element is allowed in an XML document.
//
#define ERROR_SXS_XML_E_MULTIPLEROOTS 14054L

//
// MessageId: ERROR_SXS_XML_E_INVALIDATROOTLEVEL
//
// MessageText:
//
// Manifest Parse Error : Invalid at the top level of the document.
//
#define ERROR_SXS_XML_E_INVALIDATROOTLEVEL 14055L

//
// MessageId: ERROR_SXS_XML_E_BADXMLDECL
//
// MessageText:
//
// Manifest Parse Error : Invalid xml declaration.
//
#define ERROR_SXS_XML_E_BADXMLDECL 14056L

//
// MessageId: ERROR_SXS_XML_E_MISSINGROOT
//
// MessageText:
//
// Manifest Parse Error : XML document must have a top level element.
//
#define ERROR_SXS_XML_E_MISSINGROOT 14057L

//
// MessageId: ERROR_SXS_XML_E_UNEXPECTEDEOF
//
// MessageText:
//
// Manifest Parse Error : Unexpected end of file.
//
#define ERROR_SXS_XML_E_UNEXPECTEDEOF 14058L

//
// MessageId: ERROR_SXS_XML_E_BADPEREFINSUBSET
//
// MessageText:
//
// Manifest Parse Error : Parameter entities cannot be used inside markup declarations in an internal subset.
//
#define ERROR_SXS_XML_E_BADPEREFINSUBSET 14059L

//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDSTARTTAG
//
// MessageText:
//
// Manifest Parse Error : Element was not closed.
//
#define ERROR_SXS_XML_E_UNCLOSEDSTARTTAG 14060L

//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDENDTAG
//
// MessageText:
//
// Manifest Parse Error : End element was missing the character '>'.
//
#define ERROR_SXS_XML_E_UNCLOSEDENDTAG 14061L

//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDSTRING
//
// MessageText:
//
// Manifest Parse Error : A string literal was not closed.
//
#define ERROR_SXS_XML_E_UNCLOSEDSTRING 14062L

//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDCOMMENT
//
// MessageText:
//
// Manifest Parse Error : A comment was not closed.
//
#define ERROR_SXS_XML_E_UNCLOSEDCOMMENT 14063L

//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDDECL
//
// MessageText:
//
// Manifest Parse Error : A declaration was not closed.
//
#define ERROR_SXS_XML_E_UNCLOSEDDECL 14064L

//
// MessageId: ERROR_SXS_XML_E_UNCLOSEDCDATA
//
// MessageText:
//
// Manifest Parse Error : A CDATA section was not closed.
//
#define ERROR_SXS_XML_E_UNCLOSEDCDATA 14065L

//
// MessageId: ERROR_SXS_XML_E_RESERVEDNAMESPACE
//
// MessageText:
//
// Manifest Parse Error : The namespace prefix is not allowed to start with the reserved string "xml".
//
#define ERROR_SXS_XML_E_RESERVEDNAMESPACE 14066L

//
// MessageId: ERROR_SXS_XML_E_INVALIDENCODING
//
// MessageText:
//
// Manifest Parse Error : System does not support the specified encoding.
//
#define ERROR_SXS_XML_E_INVALIDENCODING 14067L

//
// MessageId: ERROR_SXS_XML_E_INVALIDSWITCH
//
// MessageText:
//
// Manifest Parse Error : Switch from current encoding to specified encoding not supported.
//
#define ERROR_SXS_XML_E_INVALIDSWITCH 14068L

//
// MessageId: ERROR_SXS_XML_E_BADXMLCASE
//
// MessageText:
//
// Manifest Parse Error : The name 'xml' is reserved and must be lower case.
//
#define ERROR_SXS_XML_E_BADXMLCASE 14069L

//
// MessageId: ERROR_SXS_XML_E_INVALID_STANDALONE
//
// MessageText:
//
// Manifest Parse Error : The standalone attribute must have the value 'yes' or 'no'.
//
#define ERROR_SXS_XML_E_INVALID_STANDALONE 14070L

//
// MessageId: ERROR_SXS_XML_E_UNEXPECTED_STANDALONE
//
// MessageText:
//
// Manifest Parse Error : The standalone attribute cannot be used in external entities.
//
#define ERROR_SXS_XML_E_UNEXPECTED_STANDALONE 14071L

//
// MessageId: ERROR_SXS_XML_E_INVALID_VERSION
//
// MessageText:
//
// Manifest Parse Error : Invalid version number.
//
#define ERROR_SXS_XML_E_INVALID_VERSION 14072L

//
// MessageId: ERROR_SXS_XML_E_MISSINGEQUALS
//
// MessageText:
//
// Manifest Parse Error : Missing equals sign between attribute and attribute value.
//
#define ERROR_SXS_XML_E_MISSINGEQUALS 14073L

//
// MessageId: ERROR_SXS_PROTECTION_RECOVERY_FAILED
//
// MessageText:
//
// Assembly Protection Error : Unable to recover the specified assembly.
//
#define ERROR_SXS_PROTECTION_RECOVERY_FAILED 14074L

//
// MessageId: ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT
//
// MessageText:
//
// Assembly Protection Error : The public key for an assembly was too short to be allowed.
//
#define ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT 14075L

//
// MessageId: ERROR_SXS_PROTECTION_CATALOG_NOT_VALID
//
// MessageText:
//
// Assembly Protection Error : The catalog for an assembly is not valid, or does not match the assembly's manifest.
//
#define ERROR_SXS_PROTECTION_CATALOG_NOT_VALID 14076L

//
// MessageId: ERROR_SXS_UNTRANSLATABLE_HRESULT
//
// MessageText:
//
// An HRESULT could not be translated to a corresponding Win32 error code.
//
#define ERROR_SXS_UNTRANSLATABLE_HRESULT 14077L

//
// MessageId: ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING
//
// MessageText:
//
// Assembly Protection Error : The catalog for an assembly is missing.
//
#define ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING 14078L

//
// MessageId: ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE
//
// MessageText:
//
// The supplied assembly identity is missing one or more attributes which must be present in this context.
//
#define ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE 14079L

//
// MessageId: ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME
//
// MessageText:
//
// The supplied assembly identity has one or more attribute names that contain characters not permitted in XML names.
//
#define ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME 14080L

//
// MessageId: ERROR_SXS_ASSEMBLY_MISSING
//
// MessageText:
//
// The referenced assembly could not be found.
//
#define ERROR_SXS_ASSEMBLY_MISSING 14081L

//
// MessageId: ERROR_SXS_CORRUPT_ACTIVATION_STACK
//
// MessageText:
//
// The activation context activation stack for the running thread of execution is corrupt.
//
#define ERROR_SXS_CORRUPT_ACTIVATION_STACK 14082L

//
// MessageId: ERROR_SXS_CORRUPTION
//
// MessageText:
//
// The application isolation metadata for this process or thread has become corrupt.
//
#define ERROR_SXS_CORRUPTION 14083L

//
// MessageId: ERROR_SXS_EARLY_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not the most recently activated one.
//
#define ERROR_SXS_EARLY_DEACTIVATION 14084L

//
// MessageId: ERROR_SXS_INVALID_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not active for the current thread of execution.
//
#define ERROR_SXS_INVALID_DEACTIVATION 14085L

//
// MessageId: ERROR_SXS_MULTIPLE_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated has already been deactivated.
//
#define ERROR_SXS_MULTIPLE_DEACTIVATION 14086L

//
// MessageId: ERROR_SXS_PROCESS_TERMINATION_REQUESTED
//
// MessageText:
//
// A component used by the isolation facility has requested to terminate the process.
//
#define ERROR_SXS_PROCESS_TERMINATION_REQUESTED 14087L

//
// MessageId: ERROR_SXS_RELEASE_ACTIVATION_CONTEXT
//
// MessageText:
//
// A kernel mode component is releasing a reference on an activation context.
//
#define ERROR_SXS_RELEASE_ACTIVATION_CONTEXT 14088L

//
// MessageId: ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY
//
// MessageText:
//
// The activation context of system default assembly could not be generated.
//
#define ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY 14089L

//
// MessageId: ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE
//
// MessageText:
//
// The value of an attribute in an identity is not within the legal range.
//
#define ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE 14090L

//
// MessageId: ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME
//
// MessageText:
//
// The name of an attribute in an identity is not within the legal range.
//
#define ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME 14091L

//
// MessageId: ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE
//
// MessageText:
//
// An identity contains two definitions for the same attribute.
//
#define ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE 14092L

//
// MessageId: ERROR_SXS_IDENTITY_PARSE_ERROR
//
// MessageText:
//
// The identity string is malformed. This may be due to a trailing comma, more than two unnamed attributes, missing attribute name or missing attribute value.
//
#define ERROR_SXS_IDENTITY_PARSE_ERROR 14093L

//
// MessageId: ERROR_MALFORMED_SUBSTITUTION_STRING
//
// MessageText:
//
// A string containing localized substitutable content was malformed. Either a dollar sign ($) was followed by something other than a left parenthesis or another dollar sign or an substitution's right parenthesis was not found.
//
#define ERROR_MALFORMED_SUBSTITUTION_STRING 14094L

//
// MessageId: ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN
//
// MessageText:
//
// The public key token does not correspond to the public key specified.
//
#define ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN 14095L

//
// MessageId: ERROR_UNMAPPED_SUBSTITUTION_STRING
//
// MessageText:
//
// A substitution string had no mapping.
//
#define ERROR_UNMAPPED_SUBSTITUTION_STRING 14096L

//
// MessageId: ERROR_SXS_ASSEMBLY_NOT_LOCKED
//
// MessageText:
//
// The component must be locked before making the request.
//
#define ERROR_SXS_ASSEMBLY_NOT_LOCKED 14097L

//
// MessageId: ERROR_SXS_COMPONENT_STORE_CORRUPT
//
// MessageText:
//
// The component store has been corrupted.
//
#define ERROR_SXS_COMPONENT_STORE_CORRUPT 14098L

//
// MessageId: ERROR_ADVANCED_INSTALLER_FAILED
//
// MessageText:
//
// An advanced installer failed during setup or servicing.
//
#define ERROR_ADVANCED_INSTALLER_FAILED 14099L

//
// MessageId: ERROR_XML_ENCODING_MISMATCH
//
// MessageText:
//
// The character encoding in the XML declaration did not match the encoding used in the document.
//
#define ERROR_XML_ENCODING_MISMATCH 14100L

//
// MessageId: ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT
//
// MessageText:
//
// The identities of the manifests are identical but their contents are different.
//
#define ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT 14101L

//
// MessageId: ERROR_SXS_IDENTITIES_DIFFERENT
//
// MessageText:
//
// The component identities are different.
//
#define ERROR_SXS_IDENTITIES_DIFFERENT 14102L

//
// MessageId: ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT
//
// MessageText:
//
// The assembly is not a deployment.
//
#define ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT 14103L

//
// MessageId: ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY
//
// MessageText:
//
// The file is not a part of the assembly.
//
#define ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY 14104L

//
// MessageId: ERROR_SXS_MANIFEST_TOO_BIG
//
// MessageText:
//
// The size of the manifest exceeds the maximum allowed.
//
#define ERROR_SXS_MANIFEST_TOO_BIG 14105L

//
// MessageId: ERROR_SXS_SETTING_NOT_REGISTERED
//
// MessageText:
//
// The setting is not registered.
//
#define ERROR_SXS_SETTING_NOT_REGISTERED 14106L

//
// MessageId: ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE
//
// MessageText:
//
// One or more required members of the transaction are not present.
//
#define ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE 14107L

//
// MessageId: ERROR_SMI_PRIMITIVE_INSTALLER_FAILED
//
// MessageText:
//
// The SMI primitive installer failed during setup or servicing.
//
#define ERROR_SMI_PRIMITIVE_INSTALLER_FAILED 14108L

//
// MessageId: ERROR_GENERIC_COMMAND_FAILED
//
// MessageText:
//
// A generic command executable returned a result that indicates failure.
//
#define ERROR_GENERIC_COMMAND_FAILED 14109L

//
// MessageId: ERROR_SXS_FILE_HASH_MISSING
//
// MessageText:
//
// A component is missing file verification information in its manifest.
//
#define ERROR_SXS_FILE_HASH_MISSING 14110L


///////////////////////////////////////////////////
//                                               //
//           End of Side By Side Error Codes     //
//                                               //
//                 14000 to 14999                //
///////////////////////////////////////////////////


///////////////////////////////////////////////////
//                                               //
//           Start of WinEvt Error codes         //
//                                               //
//                 15000 to 15079                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_EVT_INVALID_CHANNEL_PATH
//
// MessageText:
//
// The specified channel path is invalid.
//
#define ERROR_EVT_INVALID_CHANNEL_PATH 15000L

//
// MessageId: ERROR_EVT_INVALID_QUERY
//
// MessageText:
//
// The specified query is invalid.
//
#define ERROR_EVT_INVALID_QUERY 15001L

//
// MessageId: ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND
//
// MessageText:
//
// The publisher metadata cannot be found in the resource.
//
#define ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND 15002L

//
// MessageId: ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND
//
// MessageText:
//
// The template for an event definition cannot be found in the resource (error = %1).
//
#define ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND 15003L

//
// MessageId: ERROR_EVT_INVALID_PUBLISHER_NAME
//
// MessageText:
//
// The specified publisher name is invalid.
//
#define ERROR_EVT_INVALID_PUBLISHER_NAME 15004L

//
// MessageId: ERROR_EVT_INVALID_EVENT_DATA
//
// MessageText:
//
// The event data raised by the publisher is not compatible with the event template definition in the publisher's manifest
//
#define ERROR_EVT_INVALID_EVENT_DATA 15005L

//
// MessageId: ERROR_EVT_CHANNEL_NOT_FOUND
//
// MessageText:
//
// The specified channel could not be found. Check channel configuration.
//
#define ERROR_EVT_CHANNEL_NOT_FOUND 15007L

//
// MessageId: ERROR_EVT_MALFORMED_XML_TEXT
//
// MessageText:
//
// The specified xml text was not well-formed. See Extended Error for more details.
//
#define ERROR_EVT_MALFORMED_XML_TEXT 15008L

//
// MessageId: ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL
//
// MessageText:
//
// The caller is trying to subscribe to a direct channel which is not allowed. The events for a direct channel go directly to a logfile and cannot be subscribed to.
//
#define ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL 15009L

//
// MessageId: ERROR_EVT_CONFIGURATION_ERROR
//
// MessageText:
//
// Configuration error.
//
#define ERROR_EVT_CONFIGURATION_ERROR 15010L

//
// MessageId: ERROR_EVT_QUERY_RESULT_STALE
//
// MessageText:
//
// The query result is stale / invalid. This may be due to the log being cleared or rolling over after the query result was created. Users should handle this code by releasing the query result object and reissuing the query.
//
#define ERROR_EVT_QUERY_RESULT_STALE 15011L

//
// MessageId: ERROR_EVT_QUERY_RESULT_INVALID_POSITION
//
// MessageText:
//
// Query result is currently at an invalid position.
//
#define ERROR_EVT_QUERY_RESULT_INVALID_POSITION 15012L

//
// MessageId: ERROR_EVT_NON_VALIDATING_MSXML
//
// MessageText:
//
// Registered MSXML doesn't support validation.
//
#define ERROR_EVT_NON_VALIDATING_MSXML 15013L

//
// MessageId: ERROR_EVT_FILTER_ALREADYSCOPED
//
// MessageText:
//
// An expression can only be followed by a change of scope operation if it itself evaluates to a node set and is not already part of some other change of scope operation.
//
#define ERROR_EVT_FILTER_ALREADYSCOPED 15014L

//
// MessageId: ERROR_EVT_FILTER_NOTELTSET
//
// MessageText:
//
// Can't perform a step operation from a term that does not represent an element set.
//
#define ERROR_EVT_FILTER_NOTELTSET 15015L

//
// MessageId: ERROR_EVT_FILTER_INVARG
//
// MessageText:
//
// Left hand side arguments to binary operators must be either attributes, nodes or variables and right hand side arguments must be constants.
//
#define ERROR_EVT_FILTER_INVARG 15016L

//
// MessageId: ERROR_EVT_FILTER_INVTEST
//
// MessageText:
//
// A step operation must involve either a node test or, in the case of a predicate, an algebraic expression against which to test each node in the node set identified by the preceeding node set can be evaluated.
//
#define ERROR_EVT_FILTER_INVTEST 15017L

//
// MessageId: ERROR_EVT_FILTER_INVTYPE
//
// MessageText:
//
// This data type is currently unsupported.
//
#define ERROR_EVT_FILTER_INVTYPE 15018L

//
// MessageId: ERROR_EVT_FILTER_PARSEERR
//
// MessageText:
//
// A syntax error occurred at position %1!d!
//
#define ERROR_EVT_FILTER_PARSEERR 15019L

//
// MessageId: ERROR_EVT_FILTER_UNSUPPORTEDOP
//
// MessageText:
//
// This operator is unsupported by this implementation of the filter.
//
#define ERROR_EVT_FILTER_UNSUPPORTEDOP 15020L

//
// MessageId: ERROR_EVT_FILTER_UNEXPECTEDTOKEN
//
// MessageText:
//
// The token encountered was unexpected.
//
#define ERROR_EVT_FILTER_UNEXPECTEDTOKEN 15021L

//
// MessageId: ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL
//
// MessageText:
//
// The requested operation cannot be performed over an enabled direct channel. The channel must first be disabled before performing the requested operation.
//
#define ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL 15022L

//
// MessageId: ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE
//
// MessageText:
//
// Channel property %1!s! contains invalid value. The value has invalid type, is outside of valid range, can't be updated or is not supported by this type of channel.
//
#define ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE 15023L

//
// MessageId: ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE
//
// MessageText:
//
// Publisher property %1!s! contains invalid value. The value has invalid type, is outside of valid range, can't be updated or is not supported by this type of publisher.
//
#define ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE 15024L

//
// MessageId: ERROR_EVT_CHANNEL_CANNOT_ACTIVATE
//
// MessageText:
//
// The channel fails to activate.
//
#define ERROR_EVT_CHANNEL_CANNOT_ACTIVATE 15025L

//
// MessageId: ERROR_EVT_FILTER_TOO_COMPLEX
//
// MessageText:
//
// The xpath expression exceeded supported complexity. Please symplify it or split it into two or more simple expressions.
//
#define ERROR_EVT_FILTER_TOO_COMPLEX 15026L

//
// MessageId: ERROR_EVT_MESSAGE_NOT_FOUND
//
// MessageText:
//
// the message resource is present but the message is not found in the string/message table
//
#define ERROR_EVT_MESSAGE_NOT_FOUND 15027L

//
// MessageId: ERROR_EVT_MESSAGE_ID_NOT_FOUND
//
// MessageText:
//
// The message id for the desired message could not be found.
//
#define ERROR_EVT_MESSAGE_ID_NOT_FOUND 15028L

//
// MessageId: ERROR_EVT_UNRESOLVED_VALUE_INSERT
//
// MessageText:
//
// The substitution string for insert index (%1) could not be found.
//
#define ERROR_EVT_UNRESOLVED_VALUE_INSERT 15029L

//
// MessageId: ERROR_EVT_UNRESOLVED_PARAMETER_INSERT
//
// MessageText:
//
// The description string for parameter reference (%1) could not be found.
//
#define ERROR_EVT_UNRESOLVED_PARAMETER_INSERT 15030L

//
// MessageId: ERROR_EVT_MAX_INSERTS_REACHED
//
// MessageText:
//
// The maximum number of replacements has been reached.
//
#define ERROR_EVT_MAX_INSERTS_REACHED 15031L

//
// MessageId: ERROR_EVT_EVENT_DEFINITION_NOT_FOUND
//
// MessageText:
//
// The event definition could not be found for event id (%1).
//
#define ERROR_EVT_EVENT_DEFINITION_NOT_FOUND 15032L

//
// MessageId: ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND
//
// MessageText:
//
// The locale specific resource for the desired message is not present.
//
#define ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND 15033L

//
// MessageId: ERROR_EVT_VERSION_TOO_OLD
//
// MessageText:
//
// The resource is too old to be compatible.
//
#define ERROR_EVT_VERSION_TOO_OLD 15034L

//
// MessageId: ERROR_EVT_VERSION_TOO_NEW
//
// MessageText:
//
// The resource is too new to be compatible.
//
#define ERROR_EVT_VERSION_TOO_NEW 15035L

//
// MessageId: ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY
//
// MessageText:
//
// The channel at index %1!d! of the query can't be opened.
//
#define ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY 15036L

//
// MessageId: ERROR_EVT_PUBLISHER_DISABLED
//
// MessageText:
//
// The publisher has been disabled and its resource is not avaiable. This usually occurs when the publisher is in the process of being uninstalled or upgraded.
//
#define ERROR_EVT_PUBLISHER_DISABLED 15037L

//
// MessageId: ERROR_EVT_FILTER_OUT_OF_RANGE
//
// MessageText:
//
// Attempted to create a numeric type that is outside of its valid range.
//
#define ERROR_EVT_FILTER_OUT_OF_RANGE 15038L


///////////////////////////////////////////////////
//                                               //
//           Start of Wecsvc Error codes         //
//                                               //
//                 15080 to 15099                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE
//
// MessageText:
//
// The subscription fails to activate.
//
#define ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE 15080L

//
// MessageId: ERROR_EC_LOG_DISABLED
//
// MessageText:
//
// The log of the subscription is in disabled state, and can not be used to forward events to. The log must first be enabled before the subscription can be activated.
//
#define ERROR_EC_LOG_DISABLED 15081L

//
// MessageId: ERROR_EC_CIRCULAR_FORWARDING
//
// MessageText:
//
// When forwarding events from local machine to itself, the query of the subscription can't contain target log of the subscription.
//
#define ERROR_EC_CIRCULAR_FORWARDING 15082L

//
// MessageId: ERROR_EC_CREDSTORE_FULL
//
// MessageText:
//
// The credential store that is used to save credentials is full.
//
#define ERROR_EC_CREDSTORE_FULL 15083L

//
// MessageId: ERROR_EC_CRED_NOT_FOUND
//
// MessageText:
//
// The credential used by this subscription can't be found in credential store.
//
#define ERROR_EC_CRED_NOT_FOUND 15084L

//
// MessageId: ERROR_EC_NO_ACTIVE_CHANNEL
//
// MessageText:
//
// No active channel is found for the query.
//
#define ERROR_EC_NO_ACTIVE_CHANNEL 15085L


///////////////////////////////////////////////////
//                                               //
//           Start of MUI Error codes            //
//                                               //
//                 15100 to 15199                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_MUI_FILE_NOT_FOUND
//
// MessageText:
//
// The resource loader failed to find MUI file.
//
#define ERROR_MUI_FILE_NOT_FOUND 15100L

//
// MessageId: ERROR_MUI_INVALID_FILE
//
// MessageText:
//
// The resource loader failed to load MUI file because the file fail to pass validation.
//
#define ERROR_MUI_INVALID_FILE 15101L

//
// MessageId: ERROR_MUI_INVALID_RC_CONFIG
//
// MessageText:
//
// The RC Manifest is corrupted with garbage data or unsupported version or missing required item.
//
#define ERROR_MUI_INVALID_RC_CONFIG 15102L

//
// MessageId: ERROR_MUI_INVALID_LOCALE_NAME
//
// MessageText:
//
// The RC Manifest has invalid culture name.
//
#define ERROR_MUI_INVALID_LOCALE_NAME 15103L

//
// MessageId: ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME
//
// MessageText:
//
// The RC Manifest has invalid ultimatefallback name.
//
#define ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME 15104L

//
// MessageId: ERROR_MUI_FILE_NOT_LOADED
//
// MessageText:
//
// The resource loader cache doesn't have loaded MUI entry.
//
#define ERROR_MUI_FILE_NOT_LOADED 15105L

//
// MessageId: ERROR_RESOURCE_ENUM_USER_STOP
//
// MessageText:
//
// User stopped resource enumeration.
//
#define ERROR_RESOURCE_ENUM_USER_STOP 15106L

//
// MessageId: ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED
//
// MessageText:
//
// UI language installation failed.
//
#define ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED 15107L

//
// MessageId: ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME
//
// MessageText:
//
// Locale installation failed.
//
#define ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME 15108L


///////////////////////////////////////////////////
//                                               //
// Start of Monitor Configuration API error codes//
//                                               //
//                 15200 to 15249                //
///////////////////////////////////////////////////

//
// MessageId: ERROR_MCA_INVALID_CAPABILITIES_STRING
//
// MessageText:
//
// The monitor returned a DDC/CI capabilities string that did not comply with the ACCESS.bus 3.0, DDC/CI 1.1 or MCCS 2 Revision 1 specification.
//
#define ERROR_MCA_INVALID_CAPABILITIES_STRING 15200L

//
// MessageId: ERROR_MCA_INVALID_VCP_VERSION
//
// MessageText:
//
// The monitor's VCP Version (0xDF) VCP code returned an invalid version value.
//
#define ERROR_MCA_INVALID_VCP_VERSION 15201L

//
// MessageId: ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION
//
// MessageText:
//
// The monitor does not comply with the MCCS specification it claims to support.
//
#define ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION 15202L

//
// MessageId: ERROR_MCA_MCCS_VERSION_MISMATCH
//
// MessageText:
//
// The MCCS version in a monitor's mccs_ver capability does not match the MCCS version the monitor reports when the VCP Version (0xDF) VCP code is used.
//
#define ERROR_MCA_MCCS_VERSION_MISMATCH 15203L

//
// MessageId: ERROR_MCA_UNSUPPORTED_MCCS_VERSION
//
// MessageText:
//
// The Monitor Configuration API only works with monitors that support the MCCS 1.0 specification, MCCS 2.0 specification or the MCCS 2.0 Revision 1 specification.
//
#define ERROR_MCA_UNSUPPORTED_MCCS_VERSION 15204L

//
// MessageId: ERROR_MCA_INTERNAL_ERROR
//
// MessageText:
//
// An internal Monitor Configuration API error occurred.
//
#define ERROR_MCA_INTERNAL_ERROR 15205L

//
// MessageId: ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED
//
// MessageText:
//
// The monitor returned an invalid monitor technology type. CRT, Plasma and LCD (TFT) are examples of monitor technology types. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
#define ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED 15206L

//
// MessageId: ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE
//
// MessageText:
//
// The caller of SetMonitorColorTemperature specified a color temperature that the current monitor did not support. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
#define ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE 15207L


//////////////////////////////////////////////////
//                                              //
// End of Monitor Configuration API error codes //
//                                              //
//                15200 to 15249                //
//                                              //
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//                                              //
//         Start of Syspart error codes         //
//                15250 - 15299                 //
//                                              //
//////////////////////////////////////////////////

//
// MessageId: ERROR_AMBIGUOUS_SYSTEM_DEVICE
//
// MessageText:
//
// The requested system device cannot be identified due to multiple indistinguishable devices potentially matching the identification criteria.
//
#define ERROR_AMBIGUOUS_SYSTEM_DEVICE 15250L

//
// MessageId: ERROR_SYSTEM_DEVICE_NOT_FOUND
//
// MessageText:
//
// The requested system device cannot be found.
//
#define ERROR_SYSTEM_DEVICE_NOT_FOUND 15299L

//////////////////////////////////////////////////
//                                              //
//         Start of Vortex error codes          //
//                15300 - 15320                 //
//                                              //
//////////////////////////////////////////////////

//
// MessageId: ERROR_HASH_NOT_SUPPORTED
//
// MessageText:
//
// Hash generation for the specified hash version and hash type is not enabled on the server.
//
#define ERROR_HASH_NOT_SUPPORTED 15300L

//
// MessageId: ERROR_HASH_NOT_PRESENT
//
// MessageText:
//
// The hash requested from the server is not available or no longer valid.
//
#define ERROR_HASH_NOT_PRESENT 15301L

////////////////////////////////////
//                                //
//     COM Error Codes            //
//                                //
////////////////////////////////////


//
// The return value of COM functions and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value. The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs. SCODEs are no longer used. The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS 0
#define SEVERITY_ERROR 1


//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define SUCCEEDED(hr) (((HRESULT)(hr)) >= 0)

//
// and the inverse
//

#define FAILED(hr) (((HRESULT)(hr)) < 0)


//
// Generic test for error on any status value.
//

#define IS_ERROR(Status) (((unsigned long)(Status)) >> 31 == SEVERITY_ERROR)

//
// Return the code
//

#define HRESULT_CODE(hr) ((hr) & 0xFFFF)
#define SCODE_CODE(sc) ((sc) & 0xFFFF)

//
//  Return the facility
//

#define HRESULT_FACILITY(hr) (((hr) >> 16) & 0x1fff)
#define SCODE_FACILITY(sc) (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define HRESULT_SEVERITY(hr) (((hr) >> 31) & 0x1)
#define SCODE_SEVERITY(sc) (((sc) >> 31) & 0x1)

//
// Create an HRESULT value from component pieces
//

#define MAKE_HRESULT(sev,fac,code) ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

#define MAKE_SCODE(sev,fac,code) ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



//
// Map a WIN32 error value into a HRESULT
// Note: This assumes that WIN32 errors fall in the range -32k to 32k.
//
// Define bits here so macros are guaranteed to work

#define FACILITY_NT_BIT 0x10000000

//
// HRESULT_FROM_WIN32(x) used to be a macro, however we now run it as an inline function
// to prevent double evaluation of 'x'. If you still need the macro, you can use __HRESULT_FROM_WIN32(x)
//
#define __HRESULT_FROM_WIN32(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) : ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)))







__inline HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (7 << 16) | 0x80000000);}




//
// Map an NT status value into a HRESULT
//

#define HRESULT_FROM_NT(x) ((HRESULT) ((x) | FACILITY_NT_BIT))


// ****** OBSOLETE functions

// HRESULT functions
// As noted above, these functions are obsolete and should not be used.


// Extract the SCODE from a HRESULT

#define GetScode(hr) ((SCODE) (hr))

// Convert an SCODE into an HRESULT.

#define ResultFromScode(sc) ((HRESULT) (sc))


// PropagateResult is a noop
#define PropagateResult(hrPrevious,scBase) ((HRESULT) scBase)


// ****** End of OBSOLETE functions.

#define E_NOT_SET HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
#define E_NOT_VALID_STATE HRESULT_FROM_WIN32(ERROR_INVALID_STATE)
#define E_NOT_SUFFICIENT_BUFFER HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)

// ---------------------- HRESULT value definitions -----------------
//
// HRESULT definitions
//




#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)


#define NOERROR 0

//
// Error definitions follow
//

//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
// Catastrophic failure
//
#define E_UNEXPECTED _HRESULT_TYPEDEF_(0x8000FFFFL)


//
// MessageId: E_NOTIMPL
//
// MessageText:
//
// Not implemented
//
#define E_NOTIMPL _HRESULT_TYPEDEF_(0x80004001L)

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
// Ran out of memory
//
#define E_OUTOFMEMORY _HRESULT_TYPEDEF_(0x8007000EL)

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
// One or more arguments are invalid
//
#define E_INVALIDARG _HRESULT_TYPEDEF_(0x80070057L)

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
// No such interface supported
//
#define E_NOINTERFACE _HRESULT_TYPEDEF_(0x80004002L)

//
// MessageId: E_POINTER
//
// MessageText:
//
// Invalid pointer
//
#define E_POINTER _HRESULT_TYPEDEF_(0x80004003L)

//
// MessageId: E_HANDLE
//
// MessageText:
//
// Invalid handle
//
#define E_HANDLE _HRESULT_TYPEDEF_(0x80070006L)

//
// MessageId: E_ABORT
//
// MessageText:
//
// Operation aborted
//
#define E_ABORT _HRESULT_TYPEDEF_(0x80004004L)

//
// MessageId: E_FAIL
//
// MessageText:
//
// Unspecified error
//
#define E_FAIL _HRESULT_TYPEDEF_(0x80004005L)

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
// General access denied error
//
#define E_ACCESSDENIED _HRESULT_TYPEDEF_(0x80070005L)
# 24075 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
// MessageId: E_PENDING
//
// MessageText:
//
// The data necessary to complete this operation is not yet available.
//
#define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)

//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
// Thread local storage failure
//
#define CO_E_INIT_TLS _HRESULT_TYPEDEF_(0x80004006L)

//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
// Get shared memory allocator failure
//
#define CO_E_INIT_SHARED_ALLOCATOR _HRESULT_TYPEDEF_(0x80004007L)

//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
// Get memory allocator failure
//
#define CO_E_INIT_MEMORY_ALLOCATOR _HRESULT_TYPEDEF_(0x80004008L)

//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
// Unable to initialize class cache
//
#define CO_E_INIT_CLASS_CACHE _HRESULT_TYPEDEF_(0x80004009L)

//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
// Unable to initialize RPC services
//
#define CO_E_INIT_RPC_CHANNEL _HRESULT_TYPEDEF_(0x8000400AL)

//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
// Cannot set thread local storage channel control
//
#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL _HRESULT_TYPEDEF_(0x8000400BL)

//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
// Could not allocate thread local storage channel control
//
#define CO_E_INIT_TLS_CHANNEL_CONTROL _HRESULT_TYPEDEF_(0x8000400CL)

//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
// The user supplied memory allocator is unacceptable
//
#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR _HRESULT_TYPEDEF_(0x8000400DL)

//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
// The OLE service mutex already exists
//
#define CO_E_INIT_SCM_MUTEX_EXISTS _HRESULT_TYPEDEF_(0x8000400EL)

//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
// The OLE service file mapping already exists
//
#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS _HRESULT_TYPEDEF_(0x8000400FL)

//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
// Unable to map view of file for OLE service
//
#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE _HRESULT_TYPEDEF_(0x80004010L)

//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
// Failure attempting to launch OLE service
//
#define CO_E_INIT_SCM_EXEC_FAILURE _HRESULT_TYPEDEF_(0x80004011L)

//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
// There was an attempt to call CoInitialize a second time while single threaded
//
#define CO_E_INIT_ONLY_SINGLE_THREADED _HRESULT_TYPEDEF_(0x80004012L)

//
// MessageId: CO_E_CANT_REMOTE
//
// MessageText:
//
// A Remote activation was necessary but was not allowed
//
#define CO_E_CANT_REMOTE _HRESULT_TYPEDEF_(0x80004013L)

//
// MessageId: CO_E_BAD_SERVER_NAME
//
// MessageText:
//
// A Remote activation was necessary but the server name provided was invalid
//
#define CO_E_BAD_SERVER_NAME _HRESULT_TYPEDEF_(0x80004014L)

//
// MessageId: CO_E_WRONG_SERVER_IDENTITY
//
// MessageText:
//
// The class is configured to run as a security id different from the caller
//
#define CO_E_WRONG_SERVER_IDENTITY _HRESULT_TYPEDEF_(0x80004015L)

//
// MessageId: CO_E_OLE1DDE_DISABLED
//
// MessageText:
//
// Use of Ole1 services requiring DDE windows is disabled
//
#define CO_E_OLE1DDE_DISABLED _HRESULT_TYPEDEF_(0x80004016L)

//
// MessageId: CO_E_RUNAS_SYNTAX
//
// MessageText:
//
// A RunAs specification must be <domain name>\<user name> or simply <user name>
//
#define CO_E_RUNAS_SYNTAX _HRESULT_TYPEDEF_(0x80004017L)

//
// MessageId: CO_E_CREATEPROCESS_FAILURE
//
// MessageText:
//
// The server process could not be started. The pathname may be incorrect.
//
#define CO_E_CREATEPROCESS_FAILURE _HRESULT_TYPEDEF_(0x80004018L)

//
// MessageId: CO_E_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
// The server process could not be started as the configured identity. The pathname may be incorrect or unavailable.
//
#define CO_E_RUNAS_CREATEPROCESS_FAILURE _HRESULT_TYPEDEF_(0x80004019L)

//
// MessageId: CO_E_RUNAS_LOGON_FAILURE
//
// MessageText:
//
// The server process could not be started because the configured identity is incorrect. Check the username and password.
//
#define CO_E_RUNAS_LOGON_FAILURE _HRESULT_TYPEDEF_(0x8000401AL)

//
// MessageId: CO_E_LAUNCH_PERMSSION_DENIED
//
// MessageText:
//
// The client is not allowed to launch this server.
//
#define CO_E_LAUNCH_PERMSSION_DENIED _HRESULT_TYPEDEF_(0x8000401BL)

//
// MessageId: CO_E_START_SERVICE_FAILURE
//
// MessageText:
//
// The service providing this server could not be started.
//
#define CO_E_START_SERVICE_FAILURE _HRESULT_TYPEDEF_(0x8000401CL)

//
// MessageId: CO_E_REMOTE_COMMUNICATION_FAILURE
//
// MessageText:
//
// This computer was unable to communicate with the computer providing the server.
//
#define CO_E_REMOTE_COMMUNICATION_FAILURE _HRESULT_TYPEDEF_(0x8000401DL)

//
// MessageId: CO_E_SERVER_START_TIMEOUT
//
// MessageText:
//
// The server did not respond after being launched.
//
#define CO_E_SERVER_START_TIMEOUT _HRESULT_TYPEDEF_(0x8000401EL)

//
// MessageId: CO_E_CLSREG_INCONSISTENT
//
// MessageText:
//
// The registration information for this server is inconsistent or incomplete.
//
#define CO_E_CLSREG_INCONSISTENT _HRESULT_TYPEDEF_(0x8000401FL)

//
// MessageId: CO_E_IIDREG_INCONSISTENT
//
// MessageText:
//
// The registration information for this interface is inconsistent or incomplete.
//
#define CO_E_IIDREG_INCONSISTENT _HRESULT_TYPEDEF_(0x80004020L)

//
// MessageId: CO_E_NOT_SUPPORTED
//
// MessageText:
//
// The operation attempted is not supported.
//
#define CO_E_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80004021L)

//
// MessageId: CO_E_RELOAD_DLL
//
// MessageText:
//
// A dll must be loaded.
//
#define CO_E_RELOAD_DLL _HRESULT_TYPEDEF_(0x80004022L)

//
// MessageId: CO_E_MSI_ERROR
//
// MessageText:
//
// A Microsoft Software Installer error was encountered.
//
#define CO_E_MSI_ERROR _HRESULT_TYPEDEF_(0x80004023L)

//
// MessageId: CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT
//
// MessageText:
//
// The specified activation could not occur in the client context as specified.
//
#define CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT _HRESULT_TYPEDEF_(0x80004024L)

//
// MessageId: CO_E_SERVER_PAUSED
//
// MessageText:
//
// Activations on the server are paused.
//
#define CO_E_SERVER_PAUSED _HRESULT_TYPEDEF_(0x80004025L)

//
// MessageId: CO_E_SERVER_NOT_PAUSED
//
// MessageText:
//
// Activations on the server are not paused.
//
#define CO_E_SERVER_NOT_PAUSED _HRESULT_TYPEDEF_(0x80004026L)

//
// MessageId: CO_E_CLASS_DISABLED
//
// MessageText:
//
// The component or application containing the component has been disabled.
//
#define CO_E_CLASS_DISABLED _HRESULT_TYPEDEF_(0x80004027L)

//
// MessageId: CO_E_CLRNOTAVAILABLE
//
// MessageText:
//
// The common language runtime is not available
//
#define CO_E_CLRNOTAVAILABLE _HRESULT_TYPEDEF_(0x80004028L)

//
// MessageId: CO_E_ASYNC_WORK_REJECTED
//
// MessageText:
//
// The thread-pool rejected the submitted asynchronous work.
//
#define CO_E_ASYNC_WORK_REJECTED _HRESULT_TYPEDEF_(0x80004029L)

//
// MessageId: CO_E_SERVER_INIT_TIMEOUT
//
// MessageText:
//
// The server started, but did not finish initializing in a timely fashion.
//
#define CO_E_SERVER_INIT_TIMEOUT _HRESULT_TYPEDEF_(0x8000402AL)

//
// MessageId: CO_E_NO_SECCTX_IN_ACTIVATE
//
// MessageText:
//
// Unable to complete the call since there is no COM+ security context inside IObjectControl.Activate.
//
#define CO_E_NO_SECCTX_IN_ACTIVATE _HRESULT_TYPEDEF_(0x8000402BL)

//
// MessageId: CO_E_TRACKER_CONFIG
//
// MessageText:
//
// The provided tracker configuration is invalid
//
#define CO_E_TRACKER_CONFIG _HRESULT_TYPEDEF_(0x80004030L)

//
// MessageId: CO_E_THREADPOOL_CONFIG
//
// MessageText:
//
// The provided thread pool configuration is invalid
//
#define CO_E_THREADPOOL_CONFIG _HRESULT_TYPEDEF_(0x80004031L)

//
// MessageId: CO_E_SXS_CONFIG
//
// MessageText:
//
// The provided side-by-side configuration is invalid
//
#define CO_E_SXS_CONFIG _HRESULT_TYPEDEF_(0x80004032L)

//
// MessageId: CO_E_MALFORMED_SPN
//
// MessageText:
//
// The server principal name (SPN) obtained during security negotiation is malformed.
//
#define CO_E_MALFORMED_SPN _HRESULT_TYPEDEF_(0x80004033L)


//
// Success codes
//
#define S_OK ((HRESULT)0L)
#define S_FALSE ((HRESULT)1L)

// ******************
// FACILITY_ITF
// ******************

//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//


//
// Generic OLE errors that may be returned by many inerfaces
//

#define OLE_E_FIRST ((HRESULT)0x80040000L)
#define OLE_E_LAST ((HRESULT)0x800400FFL)
#define OLE_S_FIRST ((HRESULT)0x00040000L)
#define OLE_S_LAST ((HRESULT)0x000400FFL)

//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
// Invalid OLEVERB structure
//
#define OLE_E_OLEVERB _HRESULT_TYPEDEF_(0x80040000L)

//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
// Invalid advise flags
//
#define OLE_E_ADVF _HRESULT_TYPEDEF_(0x80040001L)

//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
// Can't enumerate any more, because the associated data is missing
//
#define OLE_E_ENUM_NOMORE _HRESULT_TYPEDEF_(0x80040002L)

//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
// This implementation doesn't take advises
//
#define OLE_E_ADVISENOTSUPPORTED _HRESULT_TYPEDEF_(0x80040003L)

//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
// There is no connection for this connection ID
//
#define OLE_E_NOCONNECTION _HRESULT_TYPEDEF_(0x80040004L)

//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
// Need to run the object to perform this operation
//
#define OLE_E_NOTRUNNING _HRESULT_TYPEDEF_(0x80040005L)

//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
// There is no cache to operate on
//
#define OLE_E_NOCACHE _HRESULT_TYPEDEF_(0x80040006L)

//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
// Uninitialized object
//
#define OLE_E_BLANK _HRESULT_TYPEDEF_(0x80040007L)

//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
// Linked object's source class has changed
//
#define OLE_E_CLASSDIFF _HRESULT_TYPEDEF_(0x80040008L)

//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
// Not able to get the moniker of the object
//
#define OLE_E_CANT_GETMONIKER _HRESULT_TYPEDEF_(0x80040009L)

//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
// Not able to bind to the source
//
#define OLE_E_CANT_BINDTOSOURCE _HRESULT_TYPEDEF_(0x8004000AL)

//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
// Object is static; operation not allowed
//
#define OLE_E_STATIC _HRESULT_TYPEDEF_(0x8004000BL)

//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
// User canceled out of save dialog
//
#define OLE_E_PROMPTSAVECANCELLED _HRESULT_TYPEDEF_(0x8004000CL)

//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
// Invalid rectangle
//
#define OLE_E_INVALIDRECT _HRESULT_TYPEDEF_(0x8004000DL)

//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
// compobj.dll is too old for the ole2.dll initialized
//
#define OLE_E_WRONGCOMPOBJ _HRESULT_TYPEDEF_(0x8004000EL)

//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
// Invalid window handle
//
#define OLE_E_INVALIDHWND _HRESULT_TYPEDEF_(0x8004000FL)

//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
// Object is not in any of the inplace active states
//
#define OLE_E_NOT_INPLACEACTIVE _HRESULT_TYPEDEF_(0x80040010L)

//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
// Not able to convert object
//
#define OLE_E_CANTCONVERT _HRESULT_TYPEDEF_(0x80040011L)

//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
// Not able to perform the operation because object is not given storage yet
//
#define OLE_E_NOSTORAGE _HRESULT_TYPEDEF_(0x80040012L)

//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
// Invalid FORMATETC structure
//
#define DV_E_FORMATETC _HRESULT_TYPEDEF_(0x80040064L)

//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
// Invalid DVTARGETDEVICE structure
//
#define DV_E_DVTARGETDEVICE _HRESULT_TYPEDEF_(0x80040065L)

//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
// Invalid STDGMEDIUM structure
//
#define DV_E_STGMEDIUM _HRESULT_TYPEDEF_(0x80040066L)

//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
// Invalid STATDATA structure
//
#define DV_E_STATDATA _HRESULT_TYPEDEF_(0x80040067L)

//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
// Invalid lindex
//
#define DV_E_LINDEX _HRESULT_TYPEDEF_(0x80040068L)

//
// MessageId: DV_E_TYMED
//
// MessageText:
//
// Invalid tymed
//
#define DV_E_TYMED _HRESULT_TYPEDEF_(0x80040069L)

//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
// Invalid clipboard format
//
#define DV_E_CLIPFORMAT _HRESULT_TYPEDEF_(0x8004006AL)

//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
// Invalid aspect(s)
//
#define DV_E_DVASPECT _HRESULT_TYPEDEF_(0x8004006BL)

//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
// tdSize parameter of the DVTARGETDEVICE structure is invalid
//
#define DV_E_DVTARGETDEVICE_SIZE _HRESULT_TYPEDEF_(0x8004006CL)

//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
// Object doesn't support IViewObject interface
//
#define DV_E_NOIVIEWOBJECT _HRESULT_TYPEDEF_(0x8004006DL)

#define DRAGDROP_E_FIRST 0x80040100L
#define DRAGDROP_E_LAST 0x8004010FL
#define DRAGDROP_S_FIRST 0x00040100L
#define DRAGDROP_S_LAST 0x0004010FL
//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
// Trying to revoke a drop target that has not been registered
//
#define DRAGDROP_E_NOTREGISTERED _HRESULT_TYPEDEF_(0x80040100L)

//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
// This window has already been registered as a drop target
//
#define DRAGDROP_E_ALREADYREGISTERED _HRESULT_TYPEDEF_(0x80040101L)

//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
// Invalid window handle
//
#define DRAGDROP_E_INVALIDHWND _HRESULT_TYPEDEF_(0x80040102L)

#define CLASSFACTORY_E_FIRST 0x80040110L
#define CLASSFACTORY_E_LAST 0x8004011FL
#define CLASSFACTORY_S_FIRST 0x00040110L
#define CLASSFACTORY_S_LAST 0x0004011FL
//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
// Class does not support aggregation (or class object is remote)
//
#define CLASS_E_NOAGGREGATION _HRESULT_TYPEDEF_(0x80040110L)

//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
// ClassFactory cannot supply requested class
//
#define CLASS_E_CLASSNOTAVAILABLE _HRESULT_TYPEDEF_(0x80040111L)

//
// MessageId: CLASS_E_NOTLICENSED
//
// MessageText:
//
// Class is not licensed for use
//
#define CLASS_E_NOTLICENSED _HRESULT_TYPEDEF_(0x80040112L)

#define MARSHAL_E_FIRST 0x80040120L
#define MARSHAL_E_LAST 0x8004012FL
#define MARSHAL_S_FIRST 0x00040120L
#define MARSHAL_S_LAST 0x0004012FL
#define DATA_E_FIRST 0x80040130L
#define DATA_E_LAST 0x8004013FL
#define DATA_S_FIRST 0x00040130L
#define DATA_S_LAST 0x0004013FL
#define VIEW_E_FIRST 0x80040140L
#define VIEW_E_LAST 0x8004014FL
#define VIEW_S_FIRST 0x00040140L
#define VIEW_S_LAST 0x0004014FL
//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
// Error drawing view
//
#define VIEW_E_DRAW _HRESULT_TYPEDEF_(0x80040140L)

#define REGDB_E_FIRST 0x80040150L
#define REGDB_E_LAST 0x8004015FL
#define REGDB_S_FIRST 0x00040150L
#define REGDB_S_LAST 0x0004015FL
//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
// Could not read key from registry
//
#define REGDB_E_READREGDB _HRESULT_TYPEDEF_(0x80040150L)

//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
// Could not write key to registry
//
#define REGDB_E_WRITEREGDB _HRESULT_TYPEDEF_(0x80040151L)

//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
// Could not find the key in the registry
//
#define REGDB_E_KEYMISSING _HRESULT_TYPEDEF_(0x80040152L)

//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
// Invalid value for registry
//
#define REGDB_E_INVALIDVALUE _HRESULT_TYPEDEF_(0x80040153L)

//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
// Class not registered
//
#define REGDB_E_CLASSNOTREG _HRESULT_TYPEDEF_(0x80040154L)

//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
// Interface not registered
//
#define REGDB_E_IIDNOTREG _HRESULT_TYPEDEF_(0x80040155L)

//
// MessageId: REGDB_E_BADTHREADINGMODEL
//
// MessageText:
//
// Threading model entry is not valid
//
#define REGDB_E_BADTHREADINGMODEL _HRESULT_TYPEDEF_(0x80040156L)

#define CAT_E_FIRST 0x80040160L
#define CAT_E_LAST 0x80040161L
//
// MessageId: CAT_E_CATIDNOEXIST
//
// MessageText:
//
// CATID does not exist
//
#define CAT_E_CATIDNOEXIST _HRESULT_TYPEDEF_(0x80040160L)

//
// MessageId: CAT_E_NODESCRIPTION
//
// MessageText:
//
// Description not found
//
#define CAT_E_NODESCRIPTION _HRESULT_TYPEDEF_(0x80040161L)

////////////////////////////////////
//                                //
//     Class Store Error Codes    //
//                                //
////////////////////////////////////
#define CS_E_FIRST 0x80040164L
#define CS_E_LAST 0x8004016FL
//
// MessageId: CS_E_PACKAGE_NOTFOUND
//
// MessageText:
//
// No package in the software installation data in the Active Directory meets this criteria.
//
#define CS_E_PACKAGE_NOTFOUND _HRESULT_TYPEDEF_(0x80040164L)

//
// MessageId: CS_E_NOT_DELETABLE
//
// MessageText:
//
// Deleting this will break the referential integrity of the software installation data in the Active Directory.
//
#define CS_E_NOT_DELETABLE _HRESULT_TYPEDEF_(0x80040165L)

//
// MessageId: CS_E_CLASS_NOTFOUND
//
// MessageText:
//
// The CLSID was not found in the software installation data in the Active Directory.
//
#define CS_E_CLASS_NOTFOUND _HRESULT_TYPEDEF_(0x80040166L)

//
// MessageId: CS_E_INVALID_VERSION
//
// MessageText:
//
// The software installation data in the Active Directory is corrupt.
//
#define CS_E_INVALID_VERSION _HRESULT_TYPEDEF_(0x80040167L)

//
// MessageId: CS_E_NO_CLASSSTORE
//
// MessageText:
//
// There is no software installation data in the Active Directory.
//
#define CS_E_NO_CLASSSTORE _HRESULT_TYPEDEF_(0x80040168L)

//
// MessageId: CS_E_OBJECT_NOTFOUND
//
// MessageText:
//
// There is no software installation data object in the Active Directory.
//
#define CS_E_OBJECT_NOTFOUND _HRESULT_TYPEDEF_(0x80040169L)

//
// MessageId: CS_E_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
// The software installation data object in the Active Directory already exists.
//
#define CS_E_OBJECT_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x8004016AL)

//
// MessageId: CS_E_INVALID_PATH
//
// MessageText:
//
// The path to the software installation data in the Active Directory is not correct.
//
#define CS_E_INVALID_PATH _HRESULT_TYPEDEF_(0x8004016BL)

//
// MessageId: CS_E_NETWORK_ERROR
//
// MessageText:
//
// A network error interrupted the operation.
//
#define CS_E_NETWORK_ERROR _HRESULT_TYPEDEF_(0x8004016CL)

//
// MessageId: CS_E_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
// The size of this object exceeds the maximum size set by the Administrator.
//
#define CS_E_ADMIN_LIMIT_EXCEEDED _HRESULT_TYPEDEF_(0x8004016DL)

//
// MessageId: CS_E_SCHEMA_MISMATCH
//
// MessageText:
//
// The schema for the software installation data in the Active Directory does not match the required schema.
//
#define CS_E_SCHEMA_MISMATCH _HRESULT_TYPEDEF_(0x8004016EL)

//
// MessageId: CS_E_INTERNAL_ERROR
//
// MessageText:
//
// An error occurred in the software installation data in the Active Directory.
//
#define CS_E_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x8004016FL)

#define CACHE_E_FIRST 0x80040170L
#define CACHE_E_LAST 0x8004017FL
#define CACHE_S_FIRST 0x00040170L
#define CACHE_S_LAST 0x0004017FL
//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
// Cache not updated
//
#define CACHE_E_NOCACHE_UPDATED _HRESULT_TYPEDEF_(0x80040170L)

#define OLEOBJ_E_FIRST 0x80040180L
#define OLEOBJ_E_LAST 0x8004018FL
#define OLEOBJ_S_FIRST 0x00040180L
#define OLEOBJ_S_LAST 0x0004018FL
//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
// No verbs for OLE object
//
#define OLEOBJ_E_NOVERBS _HRESULT_TYPEDEF_(0x80040180L)

//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
// Invalid verb for OLE object
//
#define OLEOBJ_E_INVALIDVERB _HRESULT_TYPEDEF_(0x80040181L)

#define CLIENTSITE_E_FIRST 0x80040190L
#define CLIENTSITE_E_LAST 0x8004019FL
#define CLIENTSITE_S_FIRST 0x00040190L
#define CLIENTSITE_S_LAST 0x0004019FL
//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
// Undo is not available
//
#define INPLACE_E_NOTUNDOABLE _HRESULT_TYPEDEF_(0x800401A0L)

//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
// Space for tools is not available
//
#define INPLACE_E_NOTOOLSPACE _HRESULT_TYPEDEF_(0x800401A1L)

#define INPLACE_E_FIRST 0x800401A0L
#define INPLACE_E_LAST 0x800401AFL
#define INPLACE_S_FIRST 0x000401A0L
#define INPLACE_S_LAST 0x000401AFL
#define ENUM_E_FIRST 0x800401B0L
#define ENUM_E_LAST 0x800401BFL
#define ENUM_S_FIRST 0x000401B0L
#define ENUM_S_LAST 0x000401BFL
#define CONVERT10_E_FIRST 0x800401C0L
#define CONVERT10_E_LAST 0x800401CFL
#define CONVERT10_S_FIRST 0x000401C0L
#define CONVERT10_S_LAST 0x000401CFL
//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
// OLESTREAM Get method failed
//
#define CONVERT10_E_OLESTREAM_GET _HRESULT_TYPEDEF_(0x800401C0L)

//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
// OLESTREAM Put method failed
//
#define CONVERT10_E_OLESTREAM_PUT _HRESULT_TYPEDEF_(0x800401C1L)

//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
// Contents of the OLESTREAM not in correct format
//
#define CONVERT10_E_OLESTREAM_FMT _HRESULT_TYPEDEF_(0x800401C2L)

//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
// There was an error in a Windows GDI call while converting the bitmap to a DIB
//
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB _HRESULT_TYPEDEF_(0x800401C3L)

//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
// Contents of the IStorage not in correct format
//
#define CONVERT10_E_STG_FMT _HRESULT_TYPEDEF_(0x800401C4L)

//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
// Contents of IStorage is missing one of the standard streams
//
#define CONVERT10_E_STG_NO_STD_STREAM _HRESULT_TYPEDEF_(0x800401C5L)

//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
// There was an error in a Windows GDI call while converting the DIB to a bitmap.
//
#define CONVERT10_E_STG_DIB_TO_BITMAP _HRESULT_TYPEDEF_(0x800401C6L)

#define CLIPBRD_E_FIRST 0x800401D0L
#define CLIPBRD_E_LAST 0x800401DFL
#define CLIPBRD_S_FIRST 0x000401D0L
#define CLIPBRD_S_LAST 0x000401DFL
//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
// OpenClipboard Failed
//
#define CLIPBRD_E_CANT_OPEN _HRESULT_TYPEDEF_(0x800401D0L)

//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
// EmptyClipboard Failed
//
#define CLIPBRD_E_CANT_EMPTY _HRESULT_TYPEDEF_(0x800401D1L)

//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
// SetClipboard Failed
//
#define CLIPBRD_E_CANT_SET _HRESULT_TYPEDEF_(0x800401D2L)

//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
// Data on clipboard is invalid
//
#define CLIPBRD_E_BAD_DATA _HRESULT_TYPEDEF_(0x800401D3L)

//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
// CloseClipboard Failed
//
#define CLIPBRD_E_CANT_CLOSE _HRESULT_TYPEDEF_(0x800401D4L)

#define MK_E_FIRST 0x800401E0L
#define MK_E_LAST 0x800401EFL
#define MK_S_FIRST 0x000401E0L
#define MK_S_LAST 0x000401EFL
//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
// Moniker needs to be connected manually
//
#define MK_E_CONNECTMANUALLY _HRESULT_TYPEDEF_(0x800401E0L)

//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
// Operation exceeded deadline
//
#define MK_E_EXCEEDEDDEADLINE _HRESULT_TYPEDEF_(0x800401E1L)

//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
// Moniker needs to be generic
//
#define MK_E_NEEDGENERIC _HRESULT_TYPEDEF_(0x800401E2L)

//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
// Operation unavailable
//
#define MK_E_UNAVAILABLE _HRESULT_TYPEDEF_(0x800401E3L)

//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
// Invalid syntax
//
#define MK_E_SYNTAX _HRESULT_TYPEDEF_(0x800401E4L)

//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
// No object for moniker
//
#define MK_E_NOOBJECT _HRESULT_TYPEDEF_(0x800401E5L)

//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
// Bad extension for file
//
#define MK_E_INVALIDEXTENSION _HRESULT_TYPEDEF_(0x800401E6L)

//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
// Intermediate operation failed
//
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED _HRESULT_TYPEDEF_(0x800401E7L)

//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
// Moniker is not bindable
//
#define MK_E_NOTBINDABLE _HRESULT_TYPEDEF_(0x800401E8L)

//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
// Moniker is not bound
//
#define MK_E_NOTBOUND _HRESULT_TYPEDEF_(0x800401E9L)

//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
// Moniker cannot open file
//
#define MK_E_CANTOPENFILE _HRESULT_TYPEDEF_(0x800401EAL)

//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
// User input required for operation to succeed
//
#define MK_E_MUSTBOTHERUSER _HRESULT_TYPEDEF_(0x800401EBL)

//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
// Moniker class has no inverse
//
#define MK_E_NOINVERSE _HRESULT_TYPEDEF_(0x800401ECL)

//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
// Moniker does not refer to storage
//
#define MK_E_NOSTORAGE _HRESULT_TYPEDEF_(0x800401EDL)

//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
// No common prefix
//
#define MK_E_NOPREFIX _HRESULT_TYPEDEF_(0x800401EEL)

//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
// Moniker could not be enumerated
//
#define MK_E_ENUMERATION_FAILED _HRESULT_TYPEDEF_(0x800401EFL)

#define CO_E_FIRST 0x800401F0L
#define CO_E_LAST 0x800401FFL
#define CO_S_FIRST 0x000401F0L
#define CO_S_LAST 0x000401FFL
//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
// CoInitialize has not been called.
//
#define CO_E_NOTINITIALIZED _HRESULT_TYPEDEF_(0x800401F0L)

//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
// CoInitialize has already been called.
//
#define CO_E_ALREADYINITIALIZED _HRESULT_TYPEDEF_(0x800401F1L)

//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
// Class of object cannot be determined
//
#define CO_E_CANTDETERMINECLASS _HRESULT_TYPEDEF_(0x800401F2L)

//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
// Invalid class string
//
#define CO_E_CLASSSTRING _HRESULT_TYPEDEF_(0x800401F3L)

//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
// Invalid interface string
//
#define CO_E_IIDSTRING _HRESULT_TYPEDEF_(0x800401F4L)

//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
// Application not found
//
#define CO_E_APPNOTFOUND _HRESULT_TYPEDEF_(0x800401F5L)

//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
// Application cannot be run more than once
//
#define CO_E_APPSINGLEUSE _HRESULT_TYPEDEF_(0x800401F6L)

//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
// Some error in application program
//
#define CO_E_ERRORINAPP _HRESULT_TYPEDEF_(0x800401F7L)

//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
// DLL for class not found
//
#define CO_E_DLLNOTFOUND _HRESULT_TYPEDEF_(0x800401F8L)

//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
// Error in the DLL
//
#define CO_E_ERRORINDLL _HRESULT_TYPEDEF_(0x800401F9L)

//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
// Wrong OS or OS version for application
//
#define CO_E_WRONGOSFORAPP _HRESULT_TYPEDEF_(0x800401FAL)

//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
// Object is not registered
//
#define CO_E_OBJNOTREG _HRESULT_TYPEDEF_(0x800401FBL)

//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
// Object is already registered
//
#define CO_E_OBJISREG _HRESULT_TYPEDEF_(0x800401FCL)

//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
// Object is not connected to server
//
#define CO_E_OBJNOTCONNECTED _HRESULT_TYPEDEF_(0x800401FDL)

//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
// Application was launched but it didn't register a class factory
//
#define CO_E_APPDIDNTREG _HRESULT_TYPEDEF_(0x800401FEL)

//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
// Object has been released
//
#define CO_E_RELEASED _HRESULT_TYPEDEF_(0x800401FFL)

#define EVENT_E_FIRST 0x80040200L
#define EVENT_E_LAST 0x8004021FL
#define EVENT_S_FIRST 0x00040200L
#define EVENT_S_LAST 0x0004021FL
//
// MessageId: EVENT_S_SOME_SUBSCRIBERS_FAILED
//
// MessageText:
//
// An event was able to invoke some but not all of the subscribers
//
#define EVENT_S_SOME_SUBSCRIBERS_FAILED _HRESULT_TYPEDEF_(0x00040200L)

//
// MessageId: EVENT_E_ALL_SUBSCRIBERS_FAILED
//
// MessageText:
//
// An event was unable to invoke any of the subscribers
//
#define EVENT_E_ALL_SUBSCRIBERS_FAILED _HRESULT_TYPEDEF_(0x80040201L)

//
// MessageId: EVENT_S_NOSUBSCRIBERS
//
// MessageText:
//
// An event was delivered but there were no subscribers
//
#define EVENT_S_NOSUBSCRIBERS _HRESULT_TYPEDEF_(0x00040202L)

//
// MessageId: EVENT_E_QUERYSYNTAX
//
// MessageText:
//
// A syntax error occurred trying to evaluate a query string
//
#define EVENT_E_QUERYSYNTAX _HRESULT_TYPEDEF_(0x80040203L)

//
// MessageId: EVENT_E_QUERYFIELD
//
// MessageText:
//
// An invalid field name was used in a query string
//
#define EVENT_E_QUERYFIELD _HRESULT_TYPEDEF_(0x80040204L)

//
// MessageId: EVENT_E_INTERNALEXCEPTION
//
// MessageText:
//
// An unexpected exception was raised
//
#define EVENT_E_INTERNALEXCEPTION _HRESULT_TYPEDEF_(0x80040205L)

//
// MessageId: EVENT_E_INTERNALERROR
//
// MessageText:
//
// An unexpected internal error was detected
//
#define EVENT_E_INTERNALERROR _HRESULT_TYPEDEF_(0x80040206L)

//
// MessageId: EVENT_E_INVALID_PER_USER_SID
//
// MessageText:
//
// The owner SID on a per-user subscription doesn't exist
//
#define EVENT_E_INVALID_PER_USER_SID _HRESULT_TYPEDEF_(0x80040207L)

//
// MessageId: EVENT_E_USER_EXCEPTION
//
// MessageText:
//
// A user-supplied component or subscriber raised an exception
//
#define EVENT_E_USER_EXCEPTION _HRESULT_TYPEDEF_(0x80040208L)

//
// MessageId: EVENT_E_TOO_MANY_METHODS
//
// MessageText:
//
// An interface has too many methods to fire events from
//
#define EVENT_E_TOO_MANY_METHODS _HRESULT_TYPEDEF_(0x80040209L)

//
// MessageId: EVENT_E_MISSING_EVENTCLASS
//
// MessageText:
//
// A subscription cannot be stored unless its event class already exists
//
#define EVENT_E_MISSING_EVENTCLASS _HRESULT_TYPEDEF_(0x8004020AL)

//
// MessageId: EVENT_E_NOT_ALL_REMOVED
//
// MessageText:
//
// Not all the objects requested could be removed
//
#define EVENT_E_NOT_ALL_REMOVED _HRESULT_TYPEDEF_(0x8004020BL)

//
// MessageId: EVENT_E_COMPLUS_NOT_INSTALLED
//
// MessageText:
//
// COM+ is required for this operation, but is not installed
//
#define EVENT_E_COMPLUS_NOT_INSTALLED _HRESULT_TYPEDEF_(0x8004020CL)

//
// MessageId: EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT
//
// MessageText:
//
// Cannot modify or delete an object that was not added using the COM+ Admin SDK
//
#define EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT _HRESULT_TYPEDEF_(0x8004020DL)

//
// MessageId: EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT
//
// MessageText:
//
// Cannot modify or delete an object that was added using the COM+ Admin SDK
//
#define EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT _HRESULT_TYPEDEF_(0x8004020EL)

//
// MessageId: EVENT_E_INVALID_EVENT_CLASS_PARTITION
//
// MessageText:
//
// The event class for this subscription is in an invalid partition
//
#define EVENT_E_INVALID_EVENT_CLASS_PARTITION _HRESULT_TYPEDEF_(0x8004020FL)

//
// MessageId: EVENT_E_PER_USER_SID_NOT_LOGGED_ON
//
// MessageText:
//
// The owner of the PerUser subscription is not logged on to the system specified
//
#define EVENT_E_PER_USER_SID_NOT_LOGGED_ON _HRESULT_TYPEDEF_(0x80040210L)

#define XACT_E_FIRST 0x8004D000
#define XACT_E_LAST 0x8004D02B
#define XACT_S_FIRST 0x0004D000
#define XACT_S_LAST 0x0004D010
//
// MessageId: XACT_E_ALREADYOTHERSINGLEPHASE
//
// MessageText:
//
// Another single phase resource manager has already been enlisted in this transaction.
//
#define XACT_E_ALREADYOTHERSINGLEPHASE _HRESULT_TYPEDEF_(0x8004D000L)

//
// MessageId: XACT_E_CANTRETAIN
//
// MessageText:
//
// A retaining commit or abort is not supported
//
#define XACT_E_CANTRETAIN _HRESULT_TYPEDEF_(0x8004D001L)

//
// MessageId: XACT_E_COMMITFAILED
//
// MessageText:
//
// The transaction failed to commit for an unknown reason. The transaction was aborted.
//
#define XACT_E_COMMITFAILED _HRESULT_TYPEDEF_(0x8004D002L)

//
// MessageId: XACT_E_COMMITPREVENTED
//
// MessageText:
//
// Cannot call commit on this transaction object because the calling application did not initiate the transaction.
//
#define XACT_E_COMMITPREVENTED _HRESULT_TYPEDEF_(0x8004D003L)

//
// MessageId: XACT_E_HEURISTICABORT
//
// MessageText:
//
// Instead of committing, the resource heuristically aborted.
//
#define XACT_E_HEURISTICABORT _HRESULT_TYPEDEF_(0x8004D004L)

//
// MessageId: XACT_E_HEURISTICCOMMIT
//
// MessageText:
//
// Instead of aborting, the resource heuristically committed.
//
#define XACT_E_HEURISTICCOMMIT _HRESULT_TYPEDEF_(0x8004D005L)

//
// MessageId: XACT_E_HEURISTICDAMAGE
//
// MessageText:
//
// Some of the states of the resource were committed while others were aborted, likely because of heuristic decisions.
//
#define XACT_E_HEURISTICDAMAGE _HRESULT_TYPEDEF_(0x8004D006L)

//
// MessageId: XACT_E_HEURISTICDANGER
//
// MessageText:
//
// Some of the states of the resource may have been committed while others may have been aborted, likely because of heuristic decisions.
//
#define XACT_E_HEURISTICDANGER _HRESULT_TYPEDEF_(0x8004D007L)

//
// MessageId: XACT_E_ISOLATIONLEVEL
//
// MessageText:
//
// The requested isolation level is not valid or supported.
//
#define XACT_E_ISOLATIONLEVEL _HRESULT_TYPEDEF_(0x8004D008L)

//
// MessageId: XACT_E_NOASYNC
//
// MessageText:
//
// The transaction manager doesn't support an asynchronous operation for this method.
//
#define XACT_E_NOASYNC _HRESULT_TYPEDEF_(0x8004D009L)

//
// MessageId: XACT_E_NOENLIST
//
// MessageText:
//
// Unable to enlist in the transaction.
//
#define XACT_E_NOENLIST _HRESULT_TYPEDEF_(0x8004D00AL)

//
// MessageId: XACT_E_NOISORETAIN
//
// MessageText:
//
// The requested semantics of retention of isolation across retaining commit and abort boundaries cannot be supported by this transaction implementation, or isoFlags was not equal to zero.
//
#define XACT_E_NOISORETAIN _HRESULT_TYPEDEF_(0x8004D00BL)

//
// MessageId: XACT_E_NORESOURCE
//
// MessageText:
//
// There is no resource presently associated with this enlistment
//
#define XACT_E_NORESOURCE _HRESULT_TYPEDEF_(0x8004D00CL)

//
// MessageId: XACT_E_NOTCURRENT
//
// MessageText:
//
// The transaction failed to commit due to the failure of optimistic concurrency control in at least one of the resource managers.
//
#define XACT_E_NOTCURRENT _HRESULT_TYPEDEF_(0x8004D00DL)

//
// MessageId: XACT_E_NOTRANSACTION
//
// MessageText:
//
// The transaction has already been implicitly or explicitly committed or aborted
//
#define XACT_E_NOTRANSACTION _HRESULT_TYPEDEF_(0x8004D00EL)

//
// MessageId: XACT_E_NOTSUPPORTED
//
// MessageText:
//
// An invalid combination of flags was specified
//
#define XACT_E_NOTSUPPORTED _HRESULT_TYPEDEF_(0x8004D00FL)

//
// MessageId: XACT_E_UNKNOWNRMGRID
//
// MessageText:
//
// The resource manager id is not associated with this transaction or the transaction manager.
//
#define XACT_E_UNKNOWNRMGRID _HRESULT_TYPEDEF_(0x8004D010L)

//
// MessageId: XACT_E_WRONGSTATE
//
// MessageText:
//
// This method was called in the wrong state
//
#define XACT_E_WRONGSTATE _HRESULT_TYPEDEF_(0x8004D011L)

//
// MessageId: XACT_E_WRONGUOW
//
// MessageText:
//
// The indicated unit of work does not match the unit of work expected by the resource manager.
//
#define XACT_E_WRONGUOW _HRESULT_TYPEDEF_(0x8004D012L)

//
// MessageId: XACT_E_XTIONEXISTS
//
// MessageText:
//
// An enlistment in a transaction already exists.
//
#define XACT_E_XTIONEXISTS _HRESULT_TYPEDEF_(0x8004D013L)

//
// MessageId: XACT_E_NOIMPORTOBJECT
//
// MessageText:
//
// An import object for the transaction could not be found.
//
#define XACT_E_NOIMPORTOBJECT _HRESULT_TYPEDEF_(0x8004D014L)

//
// MessageId: XACT_E_INVALIDCOOKIE
//
// MessageText:
//
// The transaction cookie is invalid.
//
#define XACT_E_INVALIDCOOKIE _HRESULT_TYPEDEF_(0x8004D015L)

//
// MessageId: XACT_E_INDOUBT
//
// MessageText:
//
// The transaction status is in doubt. A communication failure occurred, or a transaction manager or resource manager has failed
//
#define XACT_E_INDOUBT _HRESULT_TYPEDEF_(0x8004D016L)

//
// MessageId: XACT_E_NOTIMEOUT
//
// MessageText:
//
// A time-out was specified, but time-outs are not supported.
//
#define XACT_E_NOTIMEOUT _HRESULT_TYPEDEF_(0x8004D017L)

//
// MessageId: XACT_E_ALREADYINPROGRESS
//
// MessageText:
//
// The requested operation is already in progress for the transaction.
//
#define XACT_E_ALREADYINPROGRESS _HRESULT_TYPEDEF_(0x8004D018L)

//
// MessageId: XACT_E_ABORTED
//
// MessageText:
//
// The transaction has already been aborted.
//
#define XACT_E_ABORTED _HRESULT_TYPEDEF_(0x8004D019L)

//
// MessageId: XACT_E_LOGFULL
//
// MessageText:
//
// The Transaction Manager returned a log full error.
//
#define XACT_E_LOGFULL _HRESULT_TYPEDEF_(0x8004D01AL)

//
// MessageId: XACT_E_TMNOTAVAILABLE
//
// MessageText:
//
// The Transaction Manager is not available.
//
#define XACT_E_TMNOTAVAILABLE _HRESULT_TYPEDEF_(0x8004D01BL)

//
// MessageId: XACT_E_CONNECTION_DOWN
//
// MessageText:
//
// A connection with the transaction manager was lost.
//
#define XACT_E_CONNECTION_DOWN _HRESULT_TYPEDEF_(0x8004D01CL)

//
// MessageId: XACT_E_CONNECTION_DENIED
//
// MessageText:
//
// A request to establish a connection with the transaction manager was denied.
//
#define XACT_E_CONNECTION_DENIED _HRESULT_TYPEDEF_(0x8004D01DL)

//
// MessageId: XACT_E_REENLISTTIMEOUT
//
// MessageText:
//
// Resource manager reenlistment to determine transaction status timed out.
//
#define XACT_E_REENLISTTIMEOUT _HRESULT_TYPEDEF_(0x8004D01EL)

//
// MessageId: XACT_E_TIP_CONNECT_FAILED
//
// MessageText:
//
// This transaction manager failed to establish a connection with another TIP transaction manager.
//
#define XACT_E_TIP_CONNECT_FAILED _HRESULT_TYPEDEF_(0x8004D01FL)

//
// MessageId: XACT_E_TIP_PROTOCOL_ERROR
//
// MessageText:
//
// This transaction manager encountered a protocol error with another TIP transaction manager.
//
#define XACT_E_TIP_PROTOCOL_ERROR _HRESULT_TYPEDEF_(0x8004D020L)

//
// MessageId: XACT_E_TIP_PULL_FAILED
//
// MessageText:
//
// This transaction manager could not propagate a transaction from another TIP transaction manager.
//
#define XACT_E_TIP_PULL_FAILED _HRESULT_TYPEDEF_(0x8004D021L)

//
// MessageId: XACT_E_DEST_TMNOTAVAILABLE
//
// MessageText:
//
// The Transaction Manager on the destination machine is not available.
//
#define XACT_E_DEST_TMNOTAVAILABLE _HRESULT_TYPEDEF_(0x8004D022L)

//
// MessageId: XACT_E_TIP_DISABLED
//
// MessageText:
//
// The Transaction Manager has disabled its support for TIP.
//
#define XACT_E_TIP_DISABLED _HRESULT_TYPEDEF_(0x8004D023L)

//
// MessageId: XACT_E_NETWORK_TX_DISABLED
//
// MessageText:
//
// The transaction manager has disabled its support for remote/network transactions.
//
#define XACT_E_NETWORK_TX_DISABLED _HRESULT_TYPEDEF_(0x8004D024L)

//
// MessageId: XACT_E_PARTNER_NETWORK_TX_DISABLED
//
// MessageText:
//
// The partner transaction manager has disabled its support for remote/network transactions.
//
#define XACT_E_PARTNER_NETWORK_TX_DISABLED _HRESULT_TYPEDEF_(0x8004D025L)

//
// MessageId: XACT_E_XA_TX_DISABLED
//
// MessageText:
//
// The transaction manager has disabled its support for XA transactions.
//
#define XACT_E_XA_TX_DISABLED _HRESULT_TYPEDEF_(0x8004D026L)

//
// MessageId: XACT_E_UNABLE_TO_READ_DTC_CONFIG
//
// MessageText:
//
// MSDTC was unable to read its configuration information.
//
#define XACT_E_UNABLE_TO_READ_DTC_CONFIG _HRESULT_TYPEDEF_(0x8004D027L)

//
// MessageId: XACT_E_UNABLE_TO_LOAD_DTC_PROXY
//
// MessageText:
//
// MSDTC was unable to load the dtc proxy dll.
//
#define XACT_E_UNABLE_TO_LOAD_DTC_PROXY _HRESULT_TYPEDEF_(0x8004D028L)

//
// MessageId: XACT_E_ABORTING
//
// MessageText:
//
// The local transaction has aborted.
//
#define XACT_E_ABORTING _HRESULT_TYPEDEF_(0x8004D029L)

//
// MessageId: XACT_E_PUSH_COMM_FAILURE
//
// MessageText:
//
// The MSDTC transaction manager was unable to push the transaction to the destination transaction manager due to communication problems. Possible causes are: a firewall is present and it doesn't have an exception for the MSDTC process, the two machines cannot find each other by their NetBIOS names, or the support for network transactions is not enabled for one of the two transaction managers.
//
#define XACT_E_PUSH_COMM_FAILURE _HRESULT_TYPEDEF_(0x8004D02AL)

//
// MessageId: XACT_E_PULL_COMM_FAILURE
//
// MessageText:
//
// The MSDTC transaction manager was unable to pull the transaction from the source transaction manager due to communication problems. Possible causes are: a firewall is present and it doesn't have an exception for the MSDTC process, the two machines cannot find each other by their NetBIOS names, or the support for network transactions is not enabled for one of the two transaction managers.
//
#define XACT_E_PULL_COMM_FAILURE _HRESULT_TYPEDEF_(0x8004D02BL)

//
// MessageId: XACT_E_LU_TX_DISABLED
//
// MessageText:
//
// The MSDTC transaction manager has disabled its support for SNA LU 6.2 transactions.
//
#define XACT_E_LU_TX_DISABLED _HRESULT_TYPEDEF_(0x8004D02CL)

//
// TXF & CRM errors start 4d080.
//
// MessageId: XACT_E_CLERKNOTFOUND
//
// MessageText:
//
//  XACT_E_CLERKNOTFOUND
//
#define XACT_E_CLERKNOTFOUND _HRESULT_TYPEDEF_(0x8004D080L)

//
// MessageId: XACT_E_CLERKEXISTS
//
// MessageText:
//
//  XACT_E_CLERKEXISTS
//
#define XACT_E_CLERKEXISTS _HRESULT_TYPEDEF_(0x8004D081L)

//
// MessageId: XACT_E_RECOVERYINPROGRESS
//
// MessageText:
//
//  XACT_E_RECOVERYINPROGRESS
//
#define XACT_E_RECOVERYINPROGRESS _HRESULT_TYPEDEF_(0x8004D082L)

//
// MessageId: XACT_E_TRANSACTIONCLOSED
//
// MessageText:
//
//  XACT_E_TRANSACTIONCLOSED
//
#define XACT_E_TRANSACTIONCLOSED _HRESULT_TYPEDEF_(0x8004D083L)

//
// MessageId: XACT_E_INVALIDLSN
//
// MessageText:
//
//  XACT_E_INVALIDLSN
//
#define XACT_E_INVALIDLSN _HRESULT_TYPEDEF_(0x8004D084L)

//
// MessageId: XACT_E_REPLAYREQUEST
//
// MessageText:
//
//  XACT_E_REPLAYREQUEST
//
#define XACT_E_REPLAYREQUEST _HRESULT_TYPEDEF_(0x8004D085L)

// Begin XACT_DTC_CONSTANTS enumerated values defined in txdtc.h

// SymbolicName=XACT_E_CONNECTION_REQUEST_DENIED
//
// MessageId: 0x8004D100L (No symbolic name defined)
//
// MessageText:
//
// The request to connect to the specified transaction coordinator was denied.
//


// SymbolicName=XACT_E_TOOMANY_ENLISTMENTS
//
// MessageId: 0x8004D101L (No symbolic name defined)
//
// MessageText:
//
// The maximum number of enlistments for the specified transaction has been reached.
//


// SymbolicName=XACT_E_DUPLICATE_GUID
//
// MessageId: 0x8004D102L (No symbolic name defined)
//
// MessageText:
//
// A resource manager with the same identifier is already registered with the specified transaction coordinator.
//


// SymbolicName=XACT_E_NOTSINGLEPHASE
//
// MessageId: 0x8004D103L (No symbolic name defined)
//
// MessageText:
//
// The prepare request given was not eligible for single phase optimizations.
//


// SymbolicName=XACT_E_RECOVERYALREADYDONE
//
// MessageId: 0x8004D104L (No symbolic name defined)
//
// MessageText:
//
// RecoveryComplete has already been called for the given resource manager.
//


// SymbolicName=XACT_E_PROTOCOL
//
// MessageId: 0x8004D105L (No symbolic name defined)
//
// MessageText:
//
// The interface call made was incorrect for the current state of the protocol.
//


// SymbolicName=XACT_E_RM_FAILURE
//
// MessageId: 0x8004D106L (No symbolic name defined)
//
// MessageText:
//
// xa_open call failed for the XA resource.
//


// SymbolicName=XACT_E_RECOVERY_FAILED
//
// MessageId: 0x8004D107L (No symbolic name defined)
//
// MessageText:
//
// xa_recover call failed for the XA resource.
//


// SymbolicName=XACT_E_LU_NOT_FOUND
//
// MessageId: 0x8004D108L (No symbolic name defined)
//
// MessageText:
//
// The Logical Unit of Work specified cannot be found.
//


// SymbolicName=XACT_E_DUPLICATE_LU
//
// MessageId: 0x8004D109L (No symbolic name defined)
//
// MessageText:
//
// The specified Logical Unit of Work already exists.
//


// SymbolicName=XACT_E_LU_NOT_CONNECTED
//
// MessageId: 0x8004D10AL (No symbolic name defined)
//
// MessageText:
//
// Subordinate creation failed. The specified Logical Unit of Work was not connected.
//


// SymbolicName=XACT_E_DUPLICATE_TRANSID
//
// MessageId: 0x8004D10BL (No symbolic name defined)
//
// MessageText:
//
// A transaction with the given identifier already exists.
//


// SymbolicName=XACT_E_LU_BUSY
//
// MessageId: 0x8004D10CL (No symbolic name defined)
//
// MessageText:
//
// The resource is in use.
//


// SymbolicName=XACT_E_LU_NO_RECOVERY_PROCESS
//
// MessageId: 0x8004D10DL (No symbolic name defined)
//
// MessageText:
//
// The LU Recovery process is down.
//


// SymbolicName=XACT_E_LU_DOWN
//
// MessageId: 0x8004D10EL (No symbolic name defined)
//
// MessageText:
//
// The remote session was lost.
//


// SymbolicName=XACT_E_LU_RECOVERING
//
// MessageId: 0x8004D10FL (No symbolic name defined)
//
// MessageText:
//
// The resource is currently recovering.
//


// SymbolicName=XACT_E_LU_RECOVERY_MISMATCH
//
// MessageId: 0x8004D110L (No symbolic name defined)
//
// MessageText:
//
// There was a mismatch in driving recovery.
//


// SymbolicName=XACT_E_RM_UNAVAILABLE
//
// MessageId: 0x8004D111L (No symbolic name defined)
//
// MessageText:
//
// An error occurred with the XA resource.
//


// End XACT_DTC_CONSTANTS enumerated values defined in txdtc.h

//
// OleTx Success codes.
//
//
// MessageId: XACT_S_ASYNC
//
// MessageText:
//
// An asynchronous operation was specified. The operation has begun, but its outcome is not known yet.
//
#define XACT_S_ASYNC _HRESULT_TYPEDEF_(0x0004D000L)

//
// MessageId: XACT_S_DEFECT
//
// MessageText:
//
//  XACT_S_DEFECT
//
#define XACT_S_DEFECT _HRESULT_TYPEDEF_(0x0004D001L)

//
// MessageId: XACT_S_READONLY
//
// MessageText:
//
// The method call succeeded because the transaction was read-only.
//
#define XACT_S_READONLY _HRESULT_TYPEDEF_(0x0004D002L)

//
// MessageId: XACT_S_SOMENORETAIN
//
// MessageText:
//
// The transaction was successfully aborted. However, this is a coordinated transaction, and some number of enlisted resources were aborted outright because they could not support abort-retaining semantics
//
#define XACT_S_SOMENORETAIN _HRESULT_TYPEDEF_(0x0004D003L)

//
// MessageId: XACT_S_OKINFORM
//
// MessageText:
//
// No changes were made during this call, but the sink wants another chance to look if any other sinks make further changes.
//
#define XACT_S_OKINFORM _HRESULT_TYPEDEF_(0x0004D004L)

//
// MessageId: XACT_S_MADECHANGESCONTENT
//
// MessageText:
//
// The sink is content and wishes the transaction to proceed. Changes were made to one or more resources during this call.
//
#define XACT_S_MADECHANGESCONTENT _HRESULT_TYPEDEF_(0x0004D005L)

//
// MessageId: XACT_S_MADECHANGESINFORM
//
// MessageText:
//
// The sink is for the moment and wishes the transaction to proceed, but if other changes are made following this return by other event sinks then this sink wants another chance to look
//
#define XACT_S_MADECHANGESINFORM _HRESULT_TYPEDEF_(0x0004D006L)

//
// MessageId: XACT_S_ALLNORETAIN
//
// MessageText:
//
// The transaction was successfully aborted. However, the abort was non-retaining.
//
#define XACT_S_ALLNORETAIN _HRESULT_TYPEDEF_(0x0004D007L)

//
// MessageId: XACT_S_ABORTING
//
// MessageText:
//
// An abort operation was already in progress.
//
#define XACT_S_ABORTING _HRESULT_TYPEDEF_(0x0004D008L)

//
// MessageId: XACT_S_SINGLEPHASE
//
// MessageText:
//
// The resource manager has performed a single-phase commit of the transaction.
//
#define XACT_S_SINGLEPHASE _HRESULT_TYPEDEF_(0x0004D009L)

//
// MessageId: XACT_S_LOCALLY_OK
//
// MessageText:
//
// The local transaction has not aborted.
//
#define XACT_S_LOCALLY_OK _HRESULT_TYPEDEF_(0x0004D00AL)

//
// MessageId: XACT_S_LASTRESOURCEMANAGER
//
// MessageText:
//
// The resource manager has requested to be the coordinator (last resource manager) for the transaction.
//
#define XACT_S_LASTRESOURCEMANAGER _HRESULT_TYPEDEF_(0x0004D010L)

#define CONTEXT_E_FIRST 0x8004E000L
#define CONTEXT_E_LAST 0x8004E02FL
#define CONTEXT_S_FIRST 0x0004E000L
#define CONTEXT_S_LAST 0x0004E02FL
//
// MessageId: CONTEXT_E_ABORTED
//
// MessageText:
//
// The root transaction wanted to commit, but transaction aborted
//
#define CONTEXT_E_ABORTED _HRESULT_TYPEDEF_(0x8004E002L)

//
// MessageId: CONTEXT_E_ABORTING
//
// MessageText:
//
// You made a method call on a COM+ component that has a transaction that has already aborted or in the process of aborting.
//
#define CONTEXT_E_ABORTING _HRESULT_TYPEDEF_(0x8004E003L)

//
// MessageId: CONTEXT_E_NOCONTEXT
//
// MessageText:
//
// There is no MTS object context
//
#define CONTEXT_E_NOCONTEXT _HRESULT_TYPEDEF_(0x8004E004L)

//
// MessageId: CONTEXT_E_WOULD_DEADLOCK
//
// MessageText:
//
// The component is configured to use synchronization and this method call would cause a deadlock to occur.
//
#define CONTEXT_E_WOULD_DEADLOCK _HRESULT_TYPEDEF_(0x8004E005L)

//
// MessageId: CONTEXT_E_SYNCH_TIMEOUT
//
// MessageText:
//
// The component is configured to use synchronization and a thread has timed out waiting to enter the context.
//
#define CONTEXT_E_SYNCH_TIMEOUT _HRESULT_TYPEDEF_(0x8004E006L)

//
// MessageId: CONTEXT_E_OLDREF
//
// MessageText:
//
// You made a method call on a COM+ component that has a transaction that has already committed or aborted.
//
#define CONTEXT_E_OLDREF _HRESULT_TYPEDEF_(0x8004E007L)

//
// MessageId: CONTEXT_E_ROLENOTFOUND
//
// MessageText:
//
// The specified role was not configured for the application
//
#define CONTEXT_E_ROLENOTFOUND _HRESULT_TYPEDEF_(0x8004E00CL)

//
// MessageId: CONTEXT_E_TMNOTAVAILABLE
//
// MessageText:
//
// COM+ was unable to talk to the Microsoft Distributed Transaction Coordinator
//
#define CONTEXT_E_TMNOTAVAILABLE _HRESULT_TYPEDEF_(0x8004E00FL)

//
// MessageId: CO_E_ACTIVATIONFAILED
//
// MessageText:
//
// An unexpected error occurred during COM+ Activation.
//
#define CO_E_ACTIVATIONFAILED _HRESULT_TYPEDEF_(0x8004E021L)

//
// MessageId: CO_E_ACTIVATIONFAILED_EVENTLOGGED
//
// MessageText:
//
// COM+ Activation failed. Check the event log for more information
//
#define CO_E_ACTIVATIONFAILED_EVENTLOGGED _HRESULT_TYPEDEF_(0x8004E022L)

//
// MessageId: CO_E_ACTIVATIONFAILED_CATALOGERROR
//
// MessageText:
//
// COM+ Activation failed due to a catalog or configuration error.
//
#define CO_E_ACTIVATIONFAILED_CATALOGERROR _HRESULT_TYPEDEF_(0x8004E023L)

//
// MessageId: CO_E_ACTIVATIONFAILED_TIMEOUT
//
// MessageText:
//
// COM+ activation failed because the activation could not be completed in the specified amount of time.
//
#define CO_E_ACTIVATIONFAILED_TIMEOUT _HRESULT_TYPEDEF_(0x8004E024L)

//
// MessageId: CO_E_INITIALIZATIONFAILED
//
// MessageText:
//
// COM+ Activation failed because an initialization function failed. Check the event log for more information.
//
#define CO_E_INITIALIZATIONFAILED _HRESULT_TYPEDEF_(0x8004E025L)

//
// MessageId: CONTEXT_E_NOJIT
//
// MessageText:
//
// The requested operation requires that JIT be in the current context and it is not
//
#define CONTEXT_E_NOJIT _HRESULT_TYPEDEF_(0x8004E026L)

//
// MessageId: CONTEXT_E_NOTRANSACTION
//
// MessageText:
//
// The requested operation requires that the current context have a Transaction, and it does not
//
#define CONTEXT_E_NOTRANSACTION _HRESULT_TYPEDEF_(0x8004E027L)

//
// MessageId: CO_E_THREADINGMODEL_CHANGED
//
// MessageText:
//
// The components threading model has changed after install into a COM+ Application. Please re-install component.
//
#define CO_E_THREADINGMODEL_CHANGED _HRESULT_TYPEDEF_(0x8004E028L)

//
// MessageId: CO_E_NOIISINTRINSICS
//
// MessageText:
//
// IIS intrinsics not available. Start your work with IIS.
//
#define CO_E_NOIISINTRINSICS _HRESULT_TYPEDEF_(0x8004E029L)

//
// MessageId: CO_E_NOCOOKIES
//
// MessageText:
//
// An attempt to write a cookie failed.
//
#define CO_E_NOCOOKIES _HRESULT_TYPEDEF_(0x8004E02AL)

//
// MessageId: CO_E_DBERROR
//
// MessageText:
//
// An attempt to use a database generated a database specific error.
//
#define CO_E_DBERROR _HRESULT_TYPEDEF_(0x8004E02BL)

//
// MessageId: CO_E_NOTPOOLED
//
// MessageText:
//
// The COM+ component you created must use object pooling to work.
//
#define CO_E_NOTPOOLED _HRESULT_TYPEDEF_(0x8004E02CL)

//
// MessageId: CO_E_NOTCONSTRUCTED
//
// MessageText:
//
// The COM+ component you created must use object construction to work correctly.
//
#define CO_E_NOTCONSTRUCTED _HRESULT_TYPEDEF_(0x8004E02DL)

//
// MessageId: CO_E_NOSYNCHRONIZATION
//
// MessageText:
//
// The COM+ component requires synchronization, and it is not configured for it.
//
#define CO_E_NOSYNCHRONIZATION _HRESULT_TYPEDEF_(0x8004E02EL)

//
// MessageId: CO_E_ISOLEVELMISMATCH
//
// MessageText:
//
// The TxIsolation Level property for the COM+ component being created is stronger than the TxIsolationLevel for the "root" component for the transaction. The creation failed.
//
#define CO_E_ISOLEVELMISMATCH _HRESULT_TYPEDEF_(0x8004E02FL)

//
// MessageId: CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED
//
// MessageText:
//
// The component attempted to make a cross-context call between invocations of EnterTransactionScopeand ExitTransactionScope. This is not allowed. Cross-context calls cannot be made while inside of a transaction scope.
//
#define CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED _HRESULT_TYPEDEF_(0x8004E030L)

//
// MessageId: CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED
//
// MessageText:
//
// The component made a call to EnterTransactionScope, but did not make a corresponding call to ExitTransactionScope before returning.
//
#define CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED _HRESULT_TYPEDEF_(0x8004E031L)

//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
// Use the registry database to provide the requested information
//
#define OLE_S_USEREG _HRESULT_TYPEDEF_(0x00040000L)

//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
// Success, but static
//
#define OLE_S_STATIC _HRESULT_TYPEDEF_(0x00040001L)

//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
// Macintosh clipboard format
//
#define OLE_S_MAC_CLIPFORMAT _HRESULT_TYPEDEF_(0x00040002L)

//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
// Successful drop took place
//
#define DRAGDROP_S_DROP _HRESULT_TYPEDEF_(0x00040100L)

//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
// Drag-drop operation canceled
//
#define DRAGDROP_S_CANCEL _HRESULT_TYPEDEF_(0x00040101L)

//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
// Use the default cursor
//
#define DRAGDROP_S_USEDEFAULTCURSORS _HRESULT_TYPEDEF_(0x00040102L)

//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
// Data has same FORMATETC
//
#define DATA_S_SAMEFORMATETC _HRESULT_TYPEDEF_(0x00040130L)

//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
// View is already frozen
//
#define VIEW_S_ALREADY_FROZEN _HRESULT_TYPEDEF_(0x00040140L)

//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
// FORMATETC not supported
//
#define CACHE_S_FORMATETC_NOTSUPPORTED _HRESULT_TYPEDEF_(0x00040170L)

//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
// Same cache
//
#define CACHE_S_SAMECACHE _HRESULT_TYPEDEF_(0x00040171L)

//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
// Some cache(s) not updated
//
#define CACHE_S_SOMECACHES_NOTUPDATED _HRESULT_TYPEDEF_(0x00040172L)

//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
// Invalid verb for OLE object
//
#define OLEOBJ_S_INVALIDVERB _HRESULT_TYPEDEF_(0x00040180L)

//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
// Verb number is valid but verb cannot be done now
//
#define OLEOBJ_S_CANNOT_DOVERB_NOW _HRESULT_TYPEDEF_(0x00040181L)

//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
// Invalid window handle passed
//
#define OLEOBJ_S_INVALIDHWND _HRESULT_TYPEDEF_(0x00040182L)

//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
// Message is too long; some of it had to be truncated before displaying
//
#define INPLACE_S_TRUNCATED _HRESULT_TYPEDEF_(0x000401A0L)

//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
// Unable to convert OLESTREAM to IStorage
//
#define CONVERT10_S_NO_PRESENTATION _HRESULT_TYPEDEF_(0x000401C0L)

//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
// Moniker reduced to itself
//
#define MK_S_REDUCED_TO_SELF _HRESULT_TYPEDEF_(0x000401E2L)

//
// MessageId: MK_S_ME
//
// MessageText:
//
// Common prefix is this moniker
//
#define MK_S_ME _HRESULT_TYPEDEF_(0x000401E4L)

//
// MessageId: MK_S_HIM
//
// MessageText:
//
// Common prefix is input moniker
//
#define MK_S_HIM _HRESULT_TYPEDEF_(0x000401E5L)

//
// MessageId: MK_S_US
//
// MessageText:
//
// Common prefix is both monikers
//
#define MK_S_US _HRESULT_TYPEDEF_(0x000401E6L)

//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
// Moniker is already registered in running object table
//
#define MK_S_MONIKERALREADYREGISTERED _HRESULT_TYPEDEF_(0x000401E7L)

//
// Task Scheduler errors
//
//
// MessageId: SCHED_S_TASK_READY
//
// MessageText:
//
// The task is ready to run at its next scheduled time.
//
#define SCHED_S_TASK_READY _HRESULT_TYPEDEF_(0x00041300L)

//
// MessageId: SCHED_S_TASK_RUNNING
//
// MessageText:
//
// The task is currently running.
//
#define SCHED_S_TASK_RUNNING _HRESULT_TYPEDEF_(0x00041301L)

//
// MessageId: SCHED_S_TASK_DISABLED
//
// MessageText:
//
// The task will not run at the scheduled times because it has been disabled.
//
#define SCHED_S_TASK_DISABLED _HRESULT_TYPEDEF_(0x00041302L)

//
// MessageId: SCHED_S_TASK_HAS_NOT_RUN
//
// MessageText:
//
// The task has not yet run.
//
#define SCHED_S_TASK_HAS_NOT_RUN _HRESULT_TYPEDEF_(0x00041303L)

//
// MessageId: SCHED_S_TASK_NO_MORE_RUNS
//
// MessageText:
//
// There are no more runs scheduled for this task.
//
#define SCHED_S_TASK_NO_MORE_RUNS _HRESULT_TYPEDEF_(0x00041304L)

//
// MessageId: SCHED_S_TASK_NOT_SCHEDULED
//
// MessageText:
//
// One or more of the properties that are needed to run this task on a schedule have not been set.
//
#define SCHED_S_TASK_NOT_SCHEDULED _HRESULT_TYPEDEF_(0x00041305L)

//
// MessageId: SCHED_S_TASK_TERMINATED
//
// MessageText:
//
// The last run of the task was terminated by the user.
//
#define SCHED_S_TASK_TERMINATED _HRESULT_TYPEDEF_(0x00041306L)

//
// MessageId: SCHED_S_TASK_NO_VALID_TRIGGERS
//
// MessageText:
//
// Either the task has no triggers or the existing triggers are disabled or not set.
//
#define SCHED_S_TASK_NO_VALID_TRIGGERS _HRESULT_TYPEDEF_(0x00041307L)

//
// MessageId: SCHED_S_EVENT_TRIGGER
//
// MessageText:
//
// Event triggers don't have set run times.
//
#define SCHED_S_EVENT_TRIGGER _HRESULT_TYPEDEF_(0x00041308L)

//
// MessageId: SCHED_E_TRIGGER_NOT_FOUND
//
// MessageText:
//
// Trigger not found.
//
#define SCHED_E_TRIGGER_NOT_FOUND _HRESULT_TYPEDEF_(0x80041309L)

//
// MessageId: SCHED_E_TASK_NOT_READY
//
// MessageText:
//
// One or more of the properties that are needed to run this task have not been set.
//
#define SCHED_E_TASK_NOT_READY _HRESULT_TYPEDEF_(0x8004130AL)

//
// MessageId: SCHED_E_TASK_NOT_RUNNING
//
// MessageText:
//
// There is no running instance of the task.
//
#define SCHED_E_TASK_NOT_RUNNING _HRESULT_TYPEDEF_(0x8004130BL)

//
// MessageId: SCHED_E_SERVICE_NOT_INSTALLED
//
// MessageText:
//
// The Task Scheduler Service is not installed on this computer.
//
#define SCHED_E_SERVICE_NOT_INSTALLED _HRESULT_TYPEDEF_(0x8004130CL)

//
// MessageId: SCHED_E_CANNOT_OPEN_TASK
//
// MessageText:
//
// The task object could not be opened.
//
#define SCHED_E_CANNOT_OPEN_TASK _HRESULT_TYPEDEF_(0x8004130DL)

//
// MessageId: SCHED_E_INVALID_TASK
//
// MessageText:
//
// The object is either an invalid task object or is not a task object.
//
#define SCHED_E_INVALID_TASK _HRESULT_TYPEDEF_(0x8004130EL)

//
// MessageId: SCHED_E_ACCOUNT_INFORMATION_NOT_SET
//
// MessageText:
//
// No account information could be found in the Task Scheduler security database for the task indicated.
//
#define SCHED_E_ACCOUNT_INFORMATION_NOT_SET _HRESULT_TYPEDEF_(0x8004130FL)

//
// MessageId: SCHED_E_ACCOUNT_NAME_NOT_FOUND
//
// MessageText:
//
// Unable to establish existence of the account specified.
//
#define SCHED_E_ACCOUNT_NAME_NOT_FOUND _HRESULT_TYPEDEF_(0x80041310L)

//
// MessageId: SCHED_E_ACCOUNT_DBASE_CORRUPT
//
// MessageText:
//
// Corruption was detected in the Task Scheduler security database; the database has been reset.
//
#define SCHED_E_ACCOUNT_DBASE_CORRUPT _HRESULT_TYPEDEF_(0x80041311L)

//
// MessageId: SCHED_E_NO_SECURITY_SERVICES
//
// MessageText:
//
// Task Scheduler security services are available only on Windows NT.
//
#define SCHED_E_NO_SECURITY_SERVICES _HRESULT_TYPEDEF_(0x80041312L)

//
// MessageId: SCHED_E_UNKNOWN_OBJECT_VERSION
//
// MessageText:
//
// The task object version is either unsupported or invalid.
//
#define SCHED_E_UNKNOWN_OBJECT_VERSION _HRESULT_TYPEDEF_(0x80041313L)

//
// MessageId: SCHED_E_UNSUPPORTED_ACCOUNT_OPTION
//
// MessageText:
//
// The task has been configured with an unsupported combination of account settings and run time options.
//
#define SCHED_E_UNSUPPORTED_ACCOUNT_OPTION _HRESULT_TYPEDEF_(0x80041314L)

//
// MessageId: SCHED_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The Task Scheduler Service is not running.
//
#define SCHED_E_SERVICE_NOT_RUNNING _HRESULT_TYPEDEF_(0x80041315L)

//
// MessageId: SCHED_E_UNEXPECTEDNODE
//
// MessageText:
//
// The task XML contains an unexpected node.
//
#define SCHED_E_UNEXPECTEDNODE _HRESULT_TYPEDEF_(0x80041316L)

//
// MessageId: SCHED_E_NAMESPACE
//
// MessageText:
//
// The task XML contains an element or attribute from an unexpected namespace.
//
#define SCHED_E_NAMESPACE _HRESULT_TYPEDEF_(0x80041317L)

//
// MessageId: SCHED_E_INVALIDVALUE
//
// MessageText:
//
// The task XML contains a value which is incorrectly formatted or out of range.
//
#define SCHED_E_INVALIDVALUE _HRESULT_TYPEDEF_(0x80041318L)

//
// MessageId: SCHED_E_MISSINGNODE
//
// MessageText:
//
// The task XML is missing a required element or attribute.
//
#define SCHED_E_MISSINGNODE _HRESULT_TYPEDEF_(0x80041319L)

//
// MessageId: SCHED_E_MALFORMEDXML
//
// MessageText:
//
// The task XML is malformed.
//
#define SCHED_E_MALFORMEDXML _HRESULT_TYPEDEF_(0x8004131AL)

//
// MessageId: SCHED_S_SOME_TRIGGERS_FAILED
//
// MessageText:
//
// The task is registered, but not all specified triggers will start the task.
//
#define SCHED_S_SOME_TRIGGERS_FAILED _HRESULT_TYPEDEF_(0x0004131BL)

//
// MessageId: SCHED_S_BATCH_LOGON_PROBLEM
//
// MessageText:
//
// The task is registered, but may fail to start. Batch logon privilege needs to be enabled for the task principal.
//
#define SCHED_S_BATCH_LOGON_PROBLEM _HRESULT_TYPEDEF_(0x0004131CL)

//
// MessageId: SCHED_E_TOO_MANY_NODES
//
// MessageText:
//
// The task XML contains too many nodes of the same type.
//
#define SCHED_E_TOO_MANY_NODES _HRESULT_TYPEDEF_(0x8004131DL)

//
// MessageId: SCHED_E_PAST_END_BOUNDARY
//
// MessageText:
//
// The task cannot be started after the trigger's end boundary.
//
#define SCHED_E_PAST_END_BOUNDARY _HRESULT_TYPEDEF_(0x8004131EL)

//
// MessageId: SCHED_E_ALREADY_RUNNING
//
// MessageText:
//
// An instance of this task is already running.
//
#define SCHED_E_ALREADY_RUNNING _HRESULT_TYPEDEF_(0x8004131FL)

//
// MessageId: SCHED_E_USER_NOT_LOGGED_ON
//
// MessageText:
//
// The task will not run because the user is not logged on.
//
#define SCHED_E_USER_NOT_LOGGED_ON _HRESULT_TYPEDEF_(0x80041320L)

//
// MessageId: SCHED_E_INVALID_TASK_HASH
//
// MessageText:
//
// The task image is corrupt or has been tampered with.
//
#define SCHED_E_INVALID_TASK_HASH _HRESULT_TYPEDEF_(0x80041321L)

//
// MessageId: SCHED_E_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// The Task Scheduler service is not available.
//
#define SCHED_E_SERVICE_NOT_AVAILABLE _HRESULT_TYPEDEF_(0x80041322L)

//
// MessageId: SCHED_E_SERVICE_TOO_BUSY
//
// MessageText:
//
// The Task Scheduler service is too busy to handle your request. Please try again later.
//
#define SCHED_E_SERVICE_TOO_BUSY _HRESULT_TYPEDEF_(0x80041323L)

//
// MessageId: SCHED_E_TASK_ATTEMPTED
//
// MessageText:
//
// The Task Scheduler service attempted to run the task, but the task did not run due to one of the constraints in the task definition.
//
#define SCHED_E_TASK_ATTEMPTED _HRESULT_TYPEDEF_(0x80041324L)

//
// MessageId: SCHED_S_TASK_QUEUED
//
// MessageText:
//
// The Task Scheduler service has asked the task to run.
//
#define SCHED_S_TASK_QUEUED _HRESULT_TYPEDEF_(0x00041325L)

//
// MessageId: SCHED_E_TASK_DISABLED
//
// MessageText:
//
// The task is disabled.
//
#define SCHED_E_TASK_DISABLED _HRESULT_TYPEDEF_(0x80041326L)

//
// MessageId: SCHED_E_TASK_NOT_V1_COMPAT
//
// MessageText:
//
// The task has properties that are not compatible with previous versions of Windows.
//
#define SCHED_E_TASK_NOT_V1_COMPAT _HRESULT_TYPEDEF_(0x80041327L)

//
// MessageId: SCHED_E_START_ON_DEMAND
//
// MessageText:
//
// The task settings do not allow the task to start on demand.
//
#define SCHED_E_START_ON_DEMAND _HRESULT_TYPEDEF_(0x80041328L)

// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
// Attempt to create a class object failed
//
#define CO_E_CLASS_CREATE_FAILED _HRESULT_TYPEDEF_(0x80080001L)

//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
// OLE service could not bind object
//
#define CO_E_SCM_ERROR _HRESULT_TYPEDEF_(0x80080002L)

//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
// RPC communication failed with OLE service
//
#define CO_E_SCM_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080003L)

//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
// Bad path to object
//
#define CO_E_BAD_PATH _HRESULT_TYPEDEF_(0x80080004L)

//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
// Server execution failed
//
#define CO_E_SERVER_EXEC_FAILURE _HRESULT_TYPEDEF_(0x80080005L)

//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
// OLE service could not communicate with the object server
//
#define CO_E_OBJSRV_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080006L)

//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
// Moniker path could not be normalized
//
#define MK_E_NO_NORMALIZED _HRESULT_TYPEDEF_(0x80080007L)

//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
// Object server is stopping when OLE service contacts it
//
#define CO_E_SERVER_STOPPING _HRESULT_TYPEDEF_(0x80080008L)

//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
// An invalid root block pointer was specified
//
#define MEM_E_INVALID_ROOT _HRESULT_TYPEDEF_(0x80080009L)

//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
// An allocation chain contained an invalid link pointer
//
#define MEM_E_INVALID_LINK _HRESULT_TYPEDEF_(0x80080010L)

//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
// The requested allocation size was too large
//
#define MEM_E_INVALID_SIZE _HRESULT_TYPEDEF_(0x80080011L)

//
// MessageId: CO_S_NOTALLINTERFACES
//
// MessageText:
//
// Not all the requested interfaces were available
//
#define CO_S_NOTALLINTERFACES _HRESULT_TYPEDEF_(0x00080012L)

//
// MessageId: CO_S_MACHINENAMENOTFOUND
//
// MessageText:
//
// The specified machine name was not found in the cache.
//
#define CO_S_MACHINENAMENOTFOUND _HRESULT_TYPEDEF_(0x00080013L)

//
// MessageId: CO_E_MISSING_DISPLAYNAME
//
// MessageText:
//
// The activation requires a display name to be present under the CLSID key.
//
#define CO_E_MISSING_DISPLAYNAME _HRESULT_TYPEDEF_(0x80080015L)

//
// MessageId: CO_E_RUNAS_VALUE_MUST_BE_AAA
//
// MessageText:
//
// The activation requires that the RunAs value for the application is Activate As Activator.
//
#define CO_E_RUNAS_VALUE_MUST_BE_AAA _HRESULT_TYPEDEF_(0x80080016L)

//
// MessageId: CO_E_ELEVATION_DISABLED
//
// MessageText:
//
// The class is not configured to support Elevated activation.
//
#define CO_E_ELEVATION_DISABLED _HRESULT_TYPEDEF_(0x80080017L)

// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
// Unknown interface.
//
#define DISP_E_UNKNOWNINTERFACE _HRESULT_TYPEDEF_(0x80020001L)

//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
// Member not found.
//
#define DISP_E_MEMBERNOTFOUND _HRESULT_TYPEDEF_(0x80020003L)

//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
// Parameter not found.
//
#define DISP_E_PARAMNOTFOUND _HRESULT_TYPEDEF_(0x80020004L)

//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
// Type mismatch.
//
#define DISP_E_TYPEMISMATCH _HRESULT_TYPEDEF_(0x80020005L)

//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
// Unknown name.
//
#define DISP_E_UNKNOWNNAME _HRESULT_TYPEDEF_(0x80020006L)

//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
// No named arguments.
//
#define DISP_E_NONAMEDARGS _HRESULT_TYPEDEF_(0x80020007L)

//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
// Bad variable type.
//
#define DISP_E_BADVARTYPE _HRESULT_TYPEDEF_(0x80020008L)

//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
// Exception occurred.
//
#define DISP_E_EXCEPTION _HRESULT_TYPEDEF_(0x80020009L)

//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
// Out of present range.
//
#define DISP_E_OVERFLOW _HRESULT_TYPEDEF_(0x8002000AL)

//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
// Invalid index.
//
#define DISP_E_BADINDEX _HRESULT_TYPEDEF_(0x8002000BL)

//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
// Unknown language.
//
#define DISP_E_UNKNOWNLCID _HRESULT_TYPEDEF_(0x8002000CL)

//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
// Memory is locked.
//
#define DISP_E_ARRAYISLOCKED _HRESULT_TYPEDEF_(0x8002000DL)

//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
// Invalid number of parameters.
//
#define DISP_E_BADPARAMCOUNT _HRESULT_TYPEDEF_(0x8002000EL)

//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
// Parameter not optional.
//
#define DISP_E_PARAMNOTOPTIONAL _HRESULT_TYPEDEF_(0x8002000FL)

//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
// Invalid callee.
//
#define DISP_E_BADCALLEE _HRESULT_TYPEDEF_(0x80020010L)

//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
// Does not support a collection.
//
#define DISP_E_NOTACOLLECTION _HRESULT_TYPEDEF_(0x80020011L)

//
// MessageId: DISP_E_DIVBYZERO
//
// MessageText:
//
// Division by zero.
//
#define DISP_E_DIVBYZERO _HRESULT_TYPEDEF_(0x80020012L)

//
// MessageId: DISP_E_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer too small
//
#define DISP_E_BUFFERTOOSMALL _HRESULT_TYPEDEF_(0x80020013L)

//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer too small.
//
#define TYPE_E_BUFFERTOOSMALL _HRESULT_TYPEDEF_(0x80028016L)

//
// MessageId: TYPE_E_FIELDNOTFOUND
//
// MessageText:
//
// Field name not defined in the record.
//
#define TYPE_E_FIELDNOTFOUND _HRESULT_TYPEDEF_(0x80028017L)

//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
// Old format or invalid type library.
//
#define TYPE_E_INVDATAREAD _HRESULT_TYPEDEF_(0x80028018L)

//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
// Old format or invalid type library.
//
#define TYPE_E_UNSUPFORMAT _HRESULT_TYPEDEF_(0x80028019L)

//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
// Error accessing the OLE registry.
//
#define TYPE_E_REGISTRYACCESS _HRESULT_TYPEDEF_(0x8002801CL)

//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
// Library not registered.
//
#define TYPE_E_LIBNOTREGISTERED _HRESULT_TYPEDEF_(0x8002801DL)

//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
// Bound to unknown type.
//
#define TYPE_E_UNDEFINEDTYPE _HRESULT_TYPEDEF_(0x80028027L)

//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
// Qualified name disallowed.
//
#define TYPE_E_QUALIFIEDNAMEDISALLOWED _HRESULT_TYPEDEF_(0x80028028L)

//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
// Invalid forward reference, or reference to uncompiled type.
//
#define TYPE_E_INVALIDSTATE _HRESULT_TYPEDEF_(0x80028029L)

//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
// Type mismatch.
//
#define TYPE_E_WRONGTYPEKIND _HRESULT_TYPEDEF_(0x8002802AL)

//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
// Element not found.
//
#define TYPE_E_ELEMENTNOTFOUND _HRESULT_TYPEDEF_(0x8002802BL)

//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
// Ambiguous name.
//
#define TYPE_E_AMBIGUOUSNAME _HRESULT_TYPEDEF_(0x8002802CL)

//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
// Name already exists in the library.
//
#define TYPE_E_NAMECONFLICT _HRESULT_TYPEDEF_(0x8002802DL)

//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
// Unknown LCID.
//
#define TYPE_E_UNKNOWNLCID _HRESULT_TYPEDEF_(0x8002802EL)

//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
// Function not defined in specified DLL.
//
#define TYPE_E_DLLFUNCTIONNOTFOUND _HRESULT_TYPEDEF_(0x8002802FL)

//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
// Wrong module kind for the operation.
//
#define TYPE_E_BADMODULEKIND _HRESULT_TYPEDEF_(0x800288BDL)

//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
// Size may not exceed 64K.
//
#define TYPE_E_SIZETOOBIG _HRESULT_TYPEDEF_(0x800288C5L)

//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
// Duplicate ID in inheritance hierarchy.
//
#define TYPE_E_DUPLICATEID _HRESULT_TYPEDEF_(0x800288C6L)

//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
// Incorrect inheritance depth in standard OLE hmember.
//
#define TYPE_E_INVALIDID _HRESULT_TYPEDEF_(0x800288CFL)

//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
// Type mismatch.
//
#define TYPE_E_TYPEMISMATCH _HRESULT_TYPEDEF_(0x80028CA0L)

//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
// Invalid number of arguments.
//
#define TYPE_E_OUTOFBOUNDS _HRESULT_TYPEDEF_(0x80028CA1L)

//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
// I/O Error.
//
#define TYPE_E_IOERROR _HRESULT_TYPEDEF_(0x80028CA2L)

//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
// Error creating unique tmp file.
//
#define TYPE_E_CANTCREATETMPFILE _HRESULT_TYPEDEF_(0x80028CA3L)

//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
// Error loading type library/DLL.
//
#define TYPE_E_CANTLOADLIBRARY _HRESULT_TYPEDEF_(0x80029C4AL)

//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
// Inconsistent property functions.
//
#define TYPE_E_INCONSISTENTPROPFUNCS _HRESULT_TYPEDEF_(0x80029C83L)

//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
// Circular dependency between types/modules.
//
#define TYPE_E_CIRCULARTYPE _HRESULT_TYPEDEF_(0x80029C84L)

// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
// Unable to perform requested operation.
//
#define STG_E_INVALIDFUNCTION _HRESULT_TYPEDEF_(0x80030001L)

//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
// %1 could not be found.
//
#define STG_E_FILENOTFOUND _HRESULT_TYPEDEF_(0x80030002L)

//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
// The path %1 could not be found.
//
#define STG_E_PATHNOTFOUND _HRESULT_TYPEDEF_(0x80030003L)

//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
// There are insufficient resources to open another file.
//
#define STG_E_TOOMANYOPENFILES _HRESULT_TYPEDEF_(0x80030004L)

//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
// Access Denied.
//
#define STG_E_ACCESSDENIED _HRESULT_TYPEDEF_(0x80030005L)

//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
// Attempted an operation on an invalid object.
//
#define STG_E_INVALIDHANDLE _HRESULT_TYPEDEF_(0x80030006L)

//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
// There is insufficient memory available to complete operation.
//
#define STG_E_INSUFFICIENTMEMORY _HRESULT_TYPEDEF_(0x80030008L)

//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
// Invalid pointer error.
//
#define STG_E_INVALIDPOINTER _HRESULT_TYPEDEF_(0x80030009L)

//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
// There are no more entries to return.
//
#define STG_E_NOMOREFILES _HRESULT_TYPEDEF_(0x80030012L)

//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
// Disk is write-protected.
//
#define STG_E_DISKISWRITEPROTECTED _HRESULT_TYPEDEF_(0x80030013L)

//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
// An error occurred during a seek operation.
//
#define STG_E_SEEKERROR _HRESULT_TYPEDEF_(0x80030019L)

//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
// A disk error occurred during a write operation.
//
#define STG_E_WRITEFAULT _HRESULT_TYPEDEF_(0x8003001DL)

//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
// A disk error occurred during a read operation.
//
#define STG_E_READFAULT _HRESULT_TYPEDEF_(0x8003001EL)

//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
// A share violation has occurred.
//
#define STG_E_SHAREVIOLATION _HRESULT_TYPEDEF_(0x80030020L)

//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
// A lock violation has occurred.
//
#define STG_E_LOCKVIOLATION _HRESULT_TYPEDEF_(0x80030021L)

//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
// %1 already exists.
//
#define STG_E_FILEALREADYEXISTS _HRESULT_TYPEDEF_(0x80030050L)

//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
// Invalid parameter error.
//
#define STG_E_INVALIDPARAMETER _HRESULT_TYPEDEF_(0x80030057L)

//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
// There is insufficient disk space to complete operation.
//
#define STG_E_MEDIUMFULL _HRESULT_TYPEDEF_(0x80030070L)

//
// MessageId: STG_E_PROPSETMISMATCHED
//
// MessageText:
//
// Illegal write of non-simple property to simple property set.
//
#define STG_E_PROPSETMISMATCHED _HRESULT_TYPEDEF_(0x800300F0L)

//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
// An API call exited abnormally.
//
#define STG_E_ABNORMALAPIEXIT _HRESULT_TYPEDEF_(0x800300FAL)

//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
// The file %1 is not a valid compound file.
//
#define STG_E_INVALIDHEADER _HRESULT_TYPEDEF_(0x800300FBL)

//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
// The name %1 is not valid.
//
#define STG_E_INVALIDNAME _HRESULT_TYPEDEF_(0x800300FCL)

//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
// An unexpected error occurred.
//
#define STG_E_UNKNOWN _HRESULT_TYPEDEF_(0x800300FDL)

//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
// That function is not implemented.
//
#define STG_E_UNIMPLEMENTEDFUNCTION _HRESULT_TYPEDEF_(0x800300FEL)

//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
// Invalid flag error.
//
#define STG_E_INVALIDFLAG _HRESULT_TYPEDEF_(0x800300FFL)

//
// MessageId: STG_E_INUSE
//
// MessageText:
//
// Attempted to use an object that is busy.
//
#define STG_E_INUSE _HRESULT_TYPEDEF_(0x80030100L)

//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
// The storage has been changed since the last commit.
//
#define STG_E_NOTCURRENT _HRESULT_TYPEDEF_(0x80030101L)

//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
// Attempted to use an object that has ceased to exist.
//
#define STG_E_REVERTED _HRESULT_TYPEDEF_(0x80030102L)

//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
// Can't save.
//
#define STG_E_CANTSAVE _HRESULT_TYPEDEF_(0x80030103L)

//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
// The compound file %1 was produced with an incompatible version of storage.
//
#define STG_E_OLDFORMAT _HRESULT_TYPEDEF_(0x80030104L)

//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
// The compound file %1 was produced with a newer version of storage.
//
#define STG_E_OLDDLL _HRESULT_TYPEDEF_(0x80030105L)

//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
// Share.exe or equivalent is required for operation.
//
#define STG_E_SHAREREQUIRED _HRESULT_TYPEDEF_(0x80030106L)

//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
// Illegal operation called on non-file based storage.
//
#define STG_E_NOTFILEBASEDSTORAGE _HRESULT_TYPEDEF_(0x80030107L)

//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
// Illegal operation called on object with extant marshallings.
//
#define STG_E_EXTANTMARSHALLINGS _HRESULT_TYPEDEF_(0x80030108L)

//
// MessageId: STG_E_DOCFILECORRUPT
//
// MessageText:
//
// The docfile has been corrupted.
//
#define STG_E_DOCFILECORRUPT _HRESULT_TYPEDEF_(0x80030109L)

//
// MessageId: STG_E_BADBASEADDRESS
//
// MessageText:
//
// OLE32.DLL has been loaded at the wrong address.
//
#define STG_E_BADBASEADDRESS _HRESULT_TYPEDEF_(0x80030110L)

//
// MessageId: STG_E_DOCFILETOOLARGE
//
// MessageText:
//
// The compound file is too large for the current implementation
//
#define STG_E_DOCFILETOOLARGE _HRESULT_TYPEDEF_(0x80030111L)

//
// MessageId: STG_E_NOTSIMPLEFORMAT
//
// MessageText:
//
// The compound file was not created with the STGM_SIMPLE flag
//
#define STG_E_NOTSIMPLEFORMAT _HRESULT_TYPEDEF_(0x80030112L)

//
// MessageId: STG_E_INCOMPLETE
//
// MessageText:
//
// The file download was aborted abnormally. The file is incomplete.
//
#define STG_E_INCOMPLETE _HRESULT_TYPEDEF_(0x80030201L)

//
// MessageId: STG_E_TERMINATED
//
// MessageText:
//
// The file download has been terminated.
//
#define STG_E_TERMINATED _HRESULT_TYPEDEF_(0x80030202L)

//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
// The underlying file was converted to compound file format.
//
#define STG_S_CONVERTED _HRESULT_TYPEDEF_(0x00030200L)

//
// MessageId: STG_S_BLOCK
//
// MessageText:
//
// The storage operation should block until more data is available.
//
#define STG_S_BLOCK _HRESULT_TYPEDEF_(0x00030201L)

//
// MessageId: STG_S_RETRYNOW
//
// MessageText:
//
// The storage operation should retry immediately.
//
#define STG_S_RETRYNOW _HRESULT_TYPEDEF_(0x00030202L)

//
// MessageId: STG_S_MONITORING
//
// MessageText:
//
// The notified event sink will not influence the storage operation.
//
#define STG_S_MONITORING _HRESULT_TYPEDEF_(0x00030203L)

//
// MessageId: STG_S_MULTIPLEOPENS
//
// MessageText:
//
// Multiple opens prevent consolidated. (commit succeeded).
//
#define STG_S_MULTIPLEOPENS _HRESULT_TYPEDEF_(0x00030204L)

//
// MessageId: STG_S_CONSOLIDATIONFAILED
//
// MessageText:
//
// Consolidation of the storage file failed. (commit succeeded).
//
#define STG_S_CONSOLIDATIONFAILED _HRESULT_TYPEDEF_(0x00030205L)

//
// MessageId: STG_S_CANNOTCONSOLIDATE
//
// MessageText:
//
// Consolidation of the storage file is inappropriate. (commit succeeded).
//
#define STG_S_CANNOTCONSOLIDATE _HRESULT_TYPEDEF_(0x00030206L)

/*++



 MessageId's 0x0305 - 0x031f (inclusive) are reserved for **STORAGE**

 copy protection errors.



--*/
# 28206 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
//
// MessageId: STG_E_STATUS_COPY_PROTECTION_FAILURE
//
// MessageText:
//
// Generic Copy Protection Error.
//
#define STG_E_STATUS_COPY_PROTECTION_FAILURE _HRESULT_TYPEDEF_(0x80030305L)

//
// MessageId: STG_E_CSS_AUTHENTICATION_FAILURE
//
// MessageText:
//
// Copy Protection Error - DVD CSS Authentication failed.
//
#define STG_E_CSS_AUTHENTICATION_FAILURE _HRESULT_TYPEDEF_(0x80030306L)

//
// MessageId: STG_E_CSS_KEY_NOT_PRESENT
//
// MessageText:
//
// Copy Protection Error - The given sector does not have a valid CSS key.
//
#define STG_E_CSS_KEY_NOT_PRESENT _HRESULT_TYPEDEF_(0x80030307L)

//
// MessageId: STG_E_CSS_KEY_NOT_ESTABLISHED
//
// MessageText:
//
// Copy Protection Error - DVD session key not established.
//
#define STG_E_CSS_KEY_NOT_ESTABLISHED _HRESULT_TYPEDEF_(0x80030308L)

//
// MessageId: STG_E_CSS_SCRAMBLED_SECTOR
//
// MessageText:
//
// Copy Protection Error - The read failed because the sector is encrypted.
//
#define STG_E_CSS_SCRAMBLED_SECTOR _HRESULT_TYPEDEF_(0x80030309L)

//
// MessageId: STG_E_CSS_REGION_MISMATCH
//
// MessageText:
//
// Copy Protection Error - The current DVD's region does not correspond to the region setting of the drive.
//
#define STG_E_CSS_REGION_MISMATCH _HRESULT_TYPEDEF_(0x8003030AL)

//
// MessageId: STG_E_RESETS_EXHAUSTED
//
// MessageText:
//
// Copy Protection Error - The drive's region setting may be permanent or the number of user resets has been exhausted.
//
#define STG_E_RESETS_EXHAUSTED _HRESULT_TYPEDEF_(0x8003030BL)

/*++



 MessageId's 0x0305 - 0x031f (inclusive) are reserved for **STORAGE**

 copy protection errors.



--*/
# 28275 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winerror.h"
// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propagated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
// Call was rejected by callee.
//
#define RPC_E_CALL_REJECTED _HRESULT_TYPEDEF_(0x80010001L)

//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
// Call was canceled by the message filter.
//
#define RPC_E_CALL_CANCELED _HRESULT_TYPEDEF_(0x80010002L)

//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
// The caller is dispatching an intertask SendMessage call and cannot call out via PostMessage.
//
#define RPC_E_CANTPOST_INSENDCALL _HRESULT_TYPEDEF_(0x80010003L)

//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
// The caller is dispatching an asynchronous call and cannot make an outgoing call on behalf of this call.
//
#define RPC_E_CANTCALLOUT_INASYNCCALL _HRESULT_TYPEDEF_(0x80010004L)

//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
// It is illegal to call out while inside message filter.
//
#define RPC_E_CANTCALLOUT_INEXTERNALCALL _HRESULT_TYPEDEF_(0x80010005L)

//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
// The connection terminated or is in a bogus state and cannot be used any more. Other connections are still valid.
//
#define RPC_E_CONNECTION_TERMINATED _HRESULT_TYPEDEF_(0x80010006L)

//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
// The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call may have executed.
//
#define RPC_E_SERVER_DIED _HRESULT_TYPEDEF_(0x80010007L)

//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
// The caller (client) disappeared while the callee (server) was processing a call.
//
#define RPC_E_CLIENT_DIED _HRESULT_TYPEDEF_(0x80010008L)

//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
// The data packet with the marshalled parameter data is incorrect.
//
#define RPC_E_INVALID_DATAPACKET _HRESULT_TYPEDEF_(0x80010009L)

//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
// The call was not transmitted properly; the message queue was full and was not emptied after yielding.
//
#define RPC_E_CANTTRANSMIT_CALL _HRESULT_TYPEDEF_(0x8001000AL)

//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
// The client (caller) cannot marshall the parameter data - low memory, etc.
//
#define RPC_E_CLIENT_CANTMARSHAL_DATA _HRESULT_TYPEDEF_(0x8001000BL)

//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
// The client (caller) cannot unmarshall the return data - low memory, etc.
//
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA _HRESULT_TYPEDEF_(0x8001000CL)

//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
// The server (callee) cannot marshall the return data - low memory, etc.
//
#define RPC_E_SERVER_CANTMARSHAL_DATA _HRESULT_TYPEDEF_(0x8001000DL)

//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
// The server (callee) cannot unmarshall the parameter data - low memory, etc.
//
#define RPC_E_SERVER_CANTUNMARSHAL_DATA _HRESULT_TYPEDEF_(0x8001000EL)

//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
// Received data is invalid; could be server or client data.
//
#define RPC_E_INVALID_DATA _HRESULT_TYPEDEF_(0x8001000FL)

//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
// A particular parameter is invalid and cannot be (un)marshalled.
//
#define RPC_E_INVALID_PARAMETER _HRESULT_TYPEDEF_(0x80010010L)

//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
// There is no second outgoing call on same channel in DDE conversation.
//
#define RPC_E_CANTCALLOUT_AGAIN _HRESULT_TYPEDEF_(0x80010011L)

//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
// The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call did not execute.
//
#define RPC_E_SERVER_DIED_DNE _HRESULT_TYPEDEF_(0x80010012L)

//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
// System call failed.
//
#define RPC_E_SYS_CALL_FAILED _HRESULT_TYPEDEF_(0x80010100L)

//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
// Could not allocate some required resource (memory, events, ...)
//
#define RPC_E_OUT_OF_RESOURCES _HRESULT_TYPEDEF_(0x80010101L)

//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
// Attempted to make calls on more than one thread in single threaded mode.
//
#define RPC_E_ATTEMPTED_MULTITHREAD _HRESULT_TYPEDEF_(0x80010102L)

//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
// The requested interface is not registered on the server object.
//
#define RPC_E_NOT_REGISTERED _HRESULT_TYPEDEF_(0x80010103L)

//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
// RPC could not call the server or could not return the results of calling the server.
//
#define RPC_E_FAULT _HRESULT_TYPEDEF_(0x80010104L)

//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
// The server threw an exception.
//
#define RPC_E_SERVERFAULT _HRESULT_TYPEDEF_(0x80010105L)

//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
// Cannot change thread mode after it is set.
//
#define RPC_E_CHANGED_MODE _HRESULT_TYPEDEF_(0x80010106L)

//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
// The method called does not exist on the server.
//
#define RPC_E_INVALIDMETHOD _HRESULT_TYPEDEF_(0x80010107L)

//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
// The object invoked has disconnected from its clients.
//
#define RPC_E_DISCONNECTED _HRESULT_TYPEDEF_(0x80010108L)

//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
// The object invoked chose not to process the call now. Try again later.
//
#define RPC_E_RETRY _HRESULT_TYPEDEF_(0x80010109L)

//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
// The message filter indicated that the application is busy.
//
#define RPC_E_SERVERCALL_RETRYLATER _HRESULT_TYPEDEF_(0x8001010AL)

//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
// The message filter rejected the call.
//
#define RPC_E_SERVERCALL_REJECTED _HRESULT_TYPEDEF_(0x8001010BL)

//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
// A call control interfaces was called with invalid data.
//
#define RPC_E_INVALID_CALLDATA _HRESULT_TYPEDEF_(0x8001010CL)

//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
// An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//
#define RPC_E_CANTCALLOUT_ININPUTSYNCCALL _HRESULT_TYPEDEF_(0x8001010DL)

//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
// The application called an interface that was marshalled for a different thread.
//
#define RPC_E_WRONG_THREAD _HRESULT_TYPEDEF_(0x8001010EL)

//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
// CoInitialize has not been called on the current thread.
//
#define RPC_E_THREAD_NOT_INIT _HRESULT_TYPEDEF_(0x8001010FL)

//
// MessageId: RPC_E_VERSION_MISMATCH
//
// MessageText:
//
// The version of OLE on the client and server machines does not match.
//
#define RPC_E_VERSION_MISMATCH _HRESULT_TYPEDEF_(0x80010110L)

//
// MessageId: RPC_E_INVALID_HEADER
//
// MessageText:
//
// OLE received a packet with an invalid header.
//
#define RPC_E_INVALID_HEADER _HRESULT_TYPEDEF_(0x80010111L)

//
// MessageId: RPC_E_INVALID_EXTENSION
//
// MessageText:
//
// OLE received a packet with an invalid extension.
//
#define RPC_E_INVALID_EXTENSION _HRESULT_TYPEDEF_(0x80010112L)

//
// MessageId: RPC_E_INVALID_IPID
//
// MessageText:
//
// The requested object or interface does not exist.
//
#define RPC_E_INVALID_IPID _HRESULT_TYPEDEF_(0x80010113L)

//
// MessageId: RPC_E_INVALID_OBJECT
//
// MessageText:
//
// The requested object does not exist.
//
#define RPC_E_INVALID_OBJECT _HRESULT_TYPEDEF_(0x80010114L)

//
// MessageId: RPC_S_CALLPENDING
//
// MessageText:
//
// OLE has sent a request and is waiting for a reply.
//
#define RPC_S_CALLPENDING _HRESULT_TYPEDEF_(0x80010115L)

//
// MessageId: RPC_S_WAITONTIMER
//
// MessageText:
//
// OLE is waiting before retrying a request.
//
#define RPC_S_WAITONTIMER _HRESULT_TYPEDEF_(0x80010116L)

//
// MessageId: RPC_E_CALL_COMPLETE
//
// MessageText:
//
// Call context cannot be accessed after call completed.
//
#define RPC_E_CALL_COMPLETE _HRESULT_TYPEDEF_(0x80010117L)

//
// MessageId: RPC_E_UNSECURE_CALL
//
// MessageText:
//
// Impersonate on unsecure calls is not supported.
//
#define RPC_E_UNSECURE_CALL _HRESULT_TYPEDEF_(0x80010118L)

//
// MessageId: RPC_E_TOO_LATE
//
// MessageText:
//
// Security must be initialized before any interfaces are marshalled or unmarshalled. It cannot be changed once initialized.
//
#define RPC_E_TOO_LATE _HRESULT_TYPEDEF_(0x80010119L)

//
// MessageId: RPC_E_NO_GOOD_SECURITY_PACKAGES
//
// MessageText:
//
// No security packages are installed on this machine or the user is not logged on or there are no compatible security packages between the client and server.
//
#define RPC_E_NO_GOOD_SECURITY_PACKAGES _HRESULT_TYPEDEF_(0x8001011AL)

//
// MessageId: RPC_E_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
#define RPC_E_ACCESS_DENIED _HRESULT_TYPEDEF_(0x8001011BL)

//
// MessageId: RPC_E_REMOTE_DISABLED
//
// MessageText:
//
// Remote calls are not allowed for this process.
//
#define RPC_E_REMOTE_DISABLED _HRESULT_TYPEDEF_(0x8001011CL)

//
// MessageId: RPC_E_INVALID_OBJREF
//
// MessageText:
//
// The marshaled interface data packet (OBJREF) has an invalid or unknown format.
//
#define RPC_E_INVALID_OBJREF _HRESULT_TYPEDEF_(0x8001011DL)

//
// MessageId: RPC_E_NO_CONTEXT
//
// MessageText:
//
// No context is associated with this call. This happens for some custom marshalled calls and on the client side of the call.
//
#define RPC_E_NO_CONTEXT _HRESULT_TYPEDEF_(0x8001011EL)

//
// MessageId: RPC_E_TIMEOUT
//
// MessageText:
//
// This operation returned because the timeout period expired.
//
#define RPC_E_TIMEOUT _HRESULT_TYPEDEF_(0x8001011FL)

//
// MessageId: RPC_E_NO_SYNC
//
// MessageText:
//
// There are no synchronize objects to wait on.
//
#define RPC_E_NO_SYNC _HRESULT_TYPEDEF_(0x80010120L)

//
// MessageId: RPC_E_FULLSIC_REQUIRED
//
// MessageText:
//
// Full subject issuer chain SSL principal name expected from the server.
//
#define RPC_E_FULLSIC_REQUIRED _HRESULT_TYPEDEF_(0x80010121L)

//
// MessageId: RPC_E_INVALID_STD_NAME
//
// MessageText:
//
// Principal name is not a valid MSSTD name.
//
#define RPC_E_INVALID_STD_NAME _HRESULT_TYPEDEF_(0x80010122L)

//
// MessageId: CO_E_FAILEDTOIMPERSONATE
//
// MessageText:
//
// Unable to impersonate DCOM client
//
#define CO_E_FAILEDTOIMPERSONATE _HRESULT_TYPEDEF_(0x80010123L)

//
// MessageId: CO_E_FAILEDTOGETSECCTX
//
// MessageText:
//
// Unable to obtain server's security context
//
#define CO_E_FAILEDTOGETSECCTX _HRESULT_TYPEDEF_(0x80010124L)

//
// MessageId: CO_E_FAILEDTOOPENTHREADTOKEN
//
// MessageText:
//
// Unable to open the access token of the current thread
//
#define CO_E_FAILEDTOOPENTHREADTOKEN _HRESULT_TYPEDEF_(0x80010125L)

//
// MessageId: CO_E_FAILEDTOGETTOKENINFO
//
// MessageText:
//
// Unable to obtain user info from an access token
//
#define CO_E_FAILEDTOGETTOKENINFO _HRESULT_TYPEDEF_(0x80010126L)

//
// MessageId: CO_E_TRUSTEEDOESNTMATCHCLIENT
//
// MessageText:
//
// The client who called IAccessControl::IsAccessPermitted was not the trustee provided to the method
//
#define CO_E_TRUSTEEDOESNTMATCHCLIENT _HRESULT_TYPEDEF_(0x80010127L)

//
// MessageId: CO_E_FAILEDTOQUERYCLIENTBLANKET
//
// MessageText:
//
// Unable to obtain the client's security blanket
//
#define CO_E_FAILEDTOQUERYCLIENTBLANKET _HRESULT_TYPEDEF_(0x80010128L)

//
// MessageId: CO_E_FAILEDTOSETDACL
//
// MessageText:
//
// Unable to set a discretionary ACL into a security descriptor
//
#define CO_E_FAILEDTOSETDACL _HRESULT_TYPEDEF_(0x80010129L)

//
// MessageId: CO_E_ACCESSCHECKFAILED
//
// MessageText:
//
// The system function, AccessCheck, returned false
//
#define CO_E_ACCESSCHECKFAILED _HRESULT_TYPEDEF_(0x8001012AL)

//
// MessageId: CO_E_NETACCESSAPIFAILED
//
// MessageText:
//
// Either NetAccessDel or NetAccessAdd returned an error code.
//
#define CO_E_NETACCESSAPIFAILED _HRESULT_TYPEDEF_(0x8001012BL)

//
// MessageId: CO_E_WRONGTRUSTEENAMESYNTAX
//
// MessageText:
//
// One of the trustee strings provided by the user did not conform to the <Domain>\<Name> syntax and it was not the "*" string
//
#define CO_E_WRONGTRUSTEENAMESYNTAX _HRESULT_TYPEDEF_(0x8001012CL)

//
// MessageId: CO_E_INVALIDSID
//
// MessageText:
//
// One of the security identifiers provided by the user was invalid
//
#define CO_E_INVALIDSID _HRESULT_TYPEDEF_(0x8001012DL)

//
// MessageId: CO_E_CONVERSIONFAILED
//
// MessageText:
//
// Unable to convert a wide character trustee string to a multibyte trustee string
//
#define CO_E_CONVERSIONFAILED _HRESULT_TYPEDEF_(0x8001012EL)

//
// MessageId: CO_E_NOMATCHINGSIDFOUND
//
// MessageText:
//
// Unable to find a security identifier that corresponds to a trustee string provided by the user
//
#define CO_E_NOMATCHINGSIDFOUND _HRESULT_TYPEDEF_(0x8001012FL)

//
// MessageId: CO_E_LOOKUPACCSIDFAILED
//
// MessageText:
//
// The system function, LookupAccountSID, failed
//
#define CO_E_LOOKUPACCSIDFAILED _HRESULT_TYPEDEF_(0x80010130L)

//
// MessageId: CO_E_NOMATCHINGNAMEFOUND
//
// MessageText:
//
// Unable to find a trustee name that corresponds to a security identifier provided by the user
//
#define CO_E_NOMATCHINGNAMEFOUND _HRESULT_TYPEDEF_(0x80010131L)

//
// MessageId: CO_E_LOOKUPACCNAMEFAILED
//
// MessageText:
//
// The system function, LookupAccountName, failed
//
#define CO_E_LOOKUPACCNAMEFAILED _HRESULT_TYPEDEF_(0x80010132L)

//
// MessageId: CO_E_SETSERLHNDLFAILED
//
// MessageText:
//
// Unable to set or reset a serialization handle
//
#define CO_E_SETSERLHNDLFAILED _HRESULT_TYPEDEF_(0x80010133L)

//
// MessageId: CO_E_FAILEDTOGETWINDIR
//
// MessageText:
//
// Unable to obtain the Windows directory
//
#define CO_E_FAILEDTOGETWINDIR _HRESULT_TYPEDEF_(0x80010134L)

//
// MessageId: CO_E_PATHTOOLONG
//
// MessageText:
//
// Path too long
//
#define CO_E_PATHTOOLONG _HRESULT_TYPEDEF_(0x80010135L)

//
// MessageId: CO_E_FAILEDTOGENUUID
//
// MessageText:
//
// Unable to generate a uuid.
//
#define CO_E_FAILEDTOGENUUID _HRESULT_TYPEDEF_(0x80010136L)

//
// MessageId: CO_E_FAILEDTOCREATEFILE
//
// MessageText:
//
// Unable to create file
//
#define CO_E_FAILEDTOCREATEFILE _HRESULT_TYPEDEF_(0x80010137L)

//
// MessageId: CO_E_FAILEDTOCLOSEHANDLE
//
// MessageText:
//
// Unable to close a serialization handle or a file handle.
//
#define CO_E_FAILEDTOCLOSEHANDLE _HRESULT_TYPEDEF_(0x80010138L)

//
// MessageId: CO_E_EXCEEDSYSACLLIMIT
//
// MessageText:
//
// The number of ACEs in an ACL exceeds the system limit.
//
#define CO_E_EXCEEDSYSACLLIMIT _HRESULT_TYPEDEF_(0x80010139L)

//
// MessageId: CO_E_ACESINWRONGORDER
//
// MessageText:
//
// Not all the DENY_ACCESS ACEs are arranged in front of the GRANT_ACCESS ACEs in the stream.
//
#define CO_E_ACESINWRONGORDER _HRESULT_TYPEDEF_(0x8001013AL)

//
// MessageId: CO_E_INCOMPATIBLESTREAMVERSION
//
// MessageText:
//
// The version of ACL format in the stream is not supported by this implementation of IAccessControl
//
#define CO_E_INCOMPATIBLESTREAMVERSION _HRESULT_TYPEDEF_(0x8001013BL)

//
// MessageId: CO_E_FAILEDTOOPENPROCESSTOKEN
//
// MessageText:
//
// Unable to open the access token of the server process
//
#define CO_E_FAILEDTOOPENPROCESSTOKEN _HRESULT_TYPEDEF_(0x8001013CL)

//
// MessageId: CO_E_DECODEFAILED
//
// MessageText:
//
// Unable to decode the ACL in the stream provided by the user
//
#define CO_E_DECODEFAILED _HRESULT_TYPEDEF_(0x8001013DL)

//
// MessageId: CO_E_ACNOTINITIALIZED
//
// MessageText:
//
// The COM IAccessControl object is not initialized
//
#define CO_E_ACNOTINITIALIZED _HRESULT_TYPEDEF_(0x8001013FL)

//
// MessageId: CO_E_CANCEL_DISABLED
//
// MessageText:
//
// Call Cancellation is disabled
//
#define CO_E_CANCEL_DISABLED _HRESULT_TYPEDEF_(0x80010140L)

//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
// An internal error occurred.
//
#define RPC_E_UNEXPECTED _HRESULT_TYPEDEF_(0x8001FFFFL)



//////////////////////////////////////
//                                  //
// Additional Security Status Codes //
//                                  //
// Facility=Security                //
//                                  //
//////////////////////////////////////


//
// MessageId: ERROR_AUDITING_DISABLED
//
// MessageText:
//
// The specified event is currently not being audited.
//
#define ERROR_AUDITING_DISABLED _HRESULT_TYPEDEF_(0xC0090001L)

//
// MessageId: ERROR_ALL_SIDS_FILTERED
//
// MessageText:
//
// The SID filtering operation removed all SIDs.
//
#define ERROR_ALL_SIDS_FILTERED _HRESULT_TYPEDEF_(0xC0090002L)

//
// MessageId: ERROR_BIZRULES_NOT_ENABLED
//
// MessageText:
//
// Business rule scripts are disabled for the calling application.
//
#define ERROR_BIZRULES_NOT_ENABLED _HRESULT_TYPEDEF_(0xC0090003L)



/////////////////////////////////////////////
//                                         //
// end of Additional Security Status Codes //
//                                         //
/////////////////////////////////////////////



 /////////////////
 //
 //  FACILITY_SSPI
 //
 /////////////////

//
// MessageId: NTE_BAD_UID
//
// MessageText:
//
// Bad UID.
//
#define NTE_BAD_UID _HRESULT_TYPEDEF_(0x80090001L)

//
// MessageId: NTE_BAD_HASH
//
// MessageText:
//
// Bad Hash.
//
#define NTE_BAD_HASH _HRESULT_TYPEDEF_(0x80090002L)

//
// MessageId: NTE_BAD_KEY
//
// MessageText:
//
// Bad Key.
//
#define NTE_BAD_KEY _HRESULT_TYPEDEF_(0x80090003L)

//
// MessageId: NTE_BAD_LEN
//
// MessageText:
//
// Bad Length.
//
#define NTE_BAD_LEN _HRESULT_TYPEDEF_(0x80090004L)

//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
// Bad Data.
//
#define NTE_BAD_DATA _HRESULT_TYPEDEF_(0x80090005L)

//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
// Invalid Signature.
//
#define NTE_BAD_SIGNATURE _HRESULT_TYPEDEF_(0x80090006L)

//
// MessageId: NTE_BAD_VER
//
// MessageText:
//
// Bad Version of provider.
//
#define NTE_BAD_VER _HRESULT_TYPEDEF_(0x80090007L)

//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
// Invalid algorithm specified.
//
#define NTE_BAD_ALGID _HRESULT_TYPEDEF_(0x80090008L)

//
// MessageId: NTE_BAD_FLAGS
//
// MessageText:
//
// Invalid flags specified.
//
#define NTE_BAD_FLAGS _HRESULT_TYPEDEF_(0x80090009L)

//
// MessageId: NTE_BAD_TYPE
//
// MessageText:
//
// Invalid type specified.
//
#define NTE_BAD_TYPE _HRESULT_TYPEDEF_(0x8009000AL)

//
// MessageId: NTE_BAD_KEY_STATE
//
// MessageText:
//
// Key not valid for use in specified state.
//
#define NTE_BAD_KEY_STATE _HRESULT_TYPEDEF_(0x8009000BL)

//
// MessageId: NTE_BAD_HASH_STATE
//
// MessageText:
//
// Hash not valid for use in specified state.
//
#define NTE_BAD_HASH_STATE _HRESULT_TYPEDEF_(0x8009000CL)

//
// MessageId: NTE_NO_KEY
//
// MessageText:
//
// Key does not exist.
//
#define NTE_NO_KEY _HRESULT_TYPEDEF_(0x8009000DL)

//
// MessageId: NTE_NO_MEMORY
//
// MessageText:
//
// Insufficient memory available for the operation.
//
#define NTE_NO_MEMORY _HRESULT_TYPEDEF_(0x8009000EL)

//
// MessageId: NTE_EXISTS
//
// MessageText:
//
// Object already exists.
//
#define NTE_EXISTS _HRESULT_TYPEDEF_(0x8009000FL)

//
// MessageId: NTE_PERM
//
// MessageText:
//
// Access denied.
//
#define NTE_PERM _HRESULT_TYPEDEF_(0x80090010L)

//
// MessageId: NTE_NOT_FOUND
//
// MessageText:
//
// Object was not found.
//
#define NTE_NOT_FOUND _HRESULT_TYPEDEF_(0x80090011L)

//
// MessageId: NTE_DOUBLE_ENCRYPT
//
// MessageText:
//
// Data already encrypted.
//
#define NTE_DOUBLE_ENCRYPT _HRESULT_TYPEDEF_(0x80090012L)

//
// MessageId: NTE_BAD_PROVIDER
//
// MessageText:
//
// Invalid provider specified.
//
#define NTE_BAD_PROVIDER _HRESULT_TYPEDEF_(0x80090013L)

//
// MessageId: NTE_BAD_PROV_TYPE
//
// MessageText:
//
// Invalid provider type specified.
//
#define NTE_BAD_PROV_TYPE _HRESULT_TYPEDEF_(0x80090014L)

//
// MessageId: NTE_BAD_PUBLIC_KEY
//
// MessageText:
//
// Provider's public key is invalid.
//
#define NTE_BAD_PUBLIC_KEY _HRESULT_TYPEDEF_(0x80090015L)

//
// MessageId: NTE_BAD_KEYSET
//
// MessageText:
//
// Keyset does not exist
//
#define NTE_BAD_KEYSET _HRESULT_TYPEDEF_(0x80090016L)

//
// MessageId: NTE_PROV_TYPE_NOT_DEF
//
// MessageText:
//
// Provider type not defined.
//
#define NTE_PROV_TYPE_NOT_DEF _HRESULT_TYPEDEF_(0x80090017L)

//
// MessageId: NTE_PROV_TYPE_ENTRY_BAD
//
// MessageText:
//
// Provider type as registered is invalid.
//
#define NTE_PROV_TYPE_ENTRY_BAD _HRESULT_TYPEDEF_(0x80090018L)

//
// MessageId: NTE_KEYSET_NOT_DEF
//
// MessageText:
//
// The keyset is not defined.
//
#define NTE_KEYSET_NOT_DEF _HRESULT_TYPEDEF_(0x80090019L)

//
// MessageId: NTE_KEYSET_ENTRY_BAD
//
// MessageText:
//
// Keyset as registered is invalid.
//
#define NTE_KEYSET_ENTRY_BAD _HRESULT_TYPEDEF_(0x8009001AL)

//
// MessageId: NTE_PROV_TYPE_NO_MATCH
//
// MessageText:
//
// Provider type does not match registered value.
//
#define NTE_PROV_TYPE_NO_MATCH _HRESULT_TYPEDEF_(0x8009001BL)

//
// MessageId: NTE_SIGNATURE_FILE_BAD
//
// MessageText:
//
// The digital signature file is corrupt.
//
#define NTE_SIGNATURE_FILE_BAD _HRESULT_TYPEDEF_(0x8009001CL)

//
// MessageId: NTE_PROVIDER_DLL_FAIL
//
// MessageText:
//
// Provider DLL failed to initialize correctly.
//
#define NTE_PROVIDER_DLL_FAIL _HRESULT_TYPEDEF_(0x8009001DL)

//
// MessageId: NTE_PROV_DLL_NOT_FOUND
//
// MessageText:
//
// Provider DLL could not be found.
//
#define NTE_PROV_DLL_NOT_FOUND _HRESULT_TYPEDEF_(0x8009001EL)

//
// MessageId: NTE_BAD_KEYSET_PARAM
//
// MessageText:
//
// The Keyset parameter is invalid.
//
#define NTE_BAD_KEYSET_PARAM _HRESULT_TYPEDEF_(0x8009001FL)

//
// MessageId: NTE_FAIL
//
// MessageText:
//
// An internal error occurred.
//
#define NTE_FAIL _HRESULT_TYPEDEF_(0x80090020L)

//
// MessageId: NTE_SYS_ERR
//
// MessageText:
//
// A base error occurred.
//
#define NTE_SYS_ERR _HRESULT_TYPEDEF_(0x80090021L)

//
// MessageId: NTE_SILENT_CONTEXT
//
// MessageText:
//
// Provider could not perform the action since the context was acquired as silent.
//
#define NTE_SILENT_CONTEXT _HRESULT_TYPEDEF_(0x80090022L)

//
// MessageId: NTE_TOKEN_KEYSET_STORAGE_FULL
//
// MessageText:
//
// The security token does not have storage space available for an additional container.
//
#define NTE_TOKEN_KEYSET_STORAGE_FULL _HRESULT_TYPEDEF_(0x80090023L)

//
// MessageId: NTE_TEMPORARY_PROFILE
//
// MessageText:
//
// The profile for the user is a temporary profile.
//
#define NTE_TEMPORARY_PROFILE _HRESULT_TYPEDEF_(0x80090024L)

//
// MessageId: NTE_FIXEDPARAMETER
//
// MessageText:
//
// The key parameters could not be set because the CSP uses fixed parameters.
//
#define NTE_FIXEDPARAMETER _HRESULT_TYPEDEF_(0x80090025L)

//
// MessageId: NTE_INVALID_HANDLE
//
// MessageText:
//
// The supplied handle is invalid.
//
#define NTE_INVALID_HANDLE _HRESULT_TYPEDEF_(0x80090026L)

//
// MessageId: NTE_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
#define NTE_INVALID_PARAMETER _HRESULT_TYPEDEF_(0x80090027L)

//
// MessageId: NTE_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied to a function was too small.
//
#define NTE_BUFFER_TOO_SMALL _HRESULT_TYPEDEF_(0x80090028L)

//
// MessageId: NTE_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported.
//
#define NTE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80090029L)

//
// MessageId: NTE_NO_MORE_ITEMS
//
// MessageText:
//
// No more data is available.
//
#define NTE_NO_MORE_ITEMS _HRESULT_TYPEDEF_(0x8009002AL)

//
// MessageId: NTE_BUFFERS_OVERLAP
//
// MessageText:
//
// The supplied buffers overlap incorrectly.
//
#define NTE_BUFFERS_OVERLAP _HRESULT_TYPEDEF_(0x8009002BL)

//
// MessageId: NTE_DECRYPTION_FAILURE
//
// MessageText:
//
// The specified data could not be decrypted.
//
#define NTE_DECRYPTION_FAILURE _HRESULT_TYPEDEF_(0x8009002CL)

//
// MessageId: NTE_INTERNAL_ERROR
//
// MessageText:
//
// An internal consistency check failed.
//
#define NTE_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x8009002DL)

//
// MessageId: NTE_UI_REQUIRED
//
// MessageText:
//
// This operation requires input from the user.
//
#define NTE_UI_REQUIRED _HRESULT_TYPEDEF_(0x8009002EL)

//
// MessageId: NTE_HMAC_NOT_SUPPORTED
//
// MessageText:
//
// The cryptographic provider does not support HMAC.
//
#define NTE_HMAC_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8009002FL)

//
// MessageId: SEC_E_INSUFFICIENT_MEMORY
//
// MessageText:
//
// Not enough memory is available to complete this request
//
#define SEC_E_INSUFFICIENT_MEMORY _HRESULT_TYPEDEF_(0x80090300L)

//
// MessageId: SEC_E_INVALID_HANDLE
//
// MessageText:
//
// The handle specified is invalid
//
#define SEC_E_INVALID_HANDLE _HRESULT_TYPEDEF_(0x80090301L)

//
// MessageId: SEC_E_UNSUPPORTED_FUNCTION
//
// MessageText:
//
// The function requested is not supported
//
#define SEC_E_UNSUPPORTED_FUNCTION _HRESULT_TYPEDEF_(0x80090302L)

//
// MessageId: SEC_E_TARGET_UNKNOWN
//
// MessageText:
//
// The specified target is unknown or unreachable
//
#define SEC_E_TARGET_UNKNOWN _HRESULT_TYPEDEF_(0x80090303L)

//
// MessageId: SEC_E_INTERNAL_ERROR
//
// MessageText:
//
// The Local Security Authority cannot be contacted
//
#define SEC_E_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x80090304L)

//
// MessageId: SEC_E_SECPKG_NOT_FOUND
//
// MessageText:
//
// The requested security package does not exist
//
#define SEC_E_SECPKG_NOT_FOUND _HRESULT_TYPEDEF_(0x80090305L)

//
// MessageId: SEC_E_NOT_OWNER
//
// MessageText:
//
// The caller is not the owner of the desired credentials
//
#define SEC_E_NOT_OWNER _HRESULT_TYPEDEF_(0x80090306L)

//
// MessageId: SEC_E_CANNOT_INSTALL
//
// MessageText:
//
// The security package failed to initialize, and cannot be installed
//
#define SEC_E_CANNOT_INSTALL _HRESULT_TYPEDEF_(0x80090307L)

//
// MessageId: SEC_E_INVALID_TOKEN
//
// MessageText:
//
// The token supplied to the function is invalid
//
#define SEC_E_INVALID_TOKEN _HRESULT_TYPEDEF_(0x80090308L)

//
// MessageId: SEC_E_CANNOT_PACK
//
// MessageText:
//
// The security package is not able to marshall the logon buffer, so the logon attempt has failed
//
#define SEC_E_CANNOT_PACK _HRESULT_TYPEDEF_(0x80090309L)

//
// MessageId: SEC_E_QOP_NOT_SUPPORTED
//
// MessageText:
//
// The per-message Quality of Protection is not supported by the security package
//
#define SEC_E_QOP_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8009030AL)

//
// MessageId: SEC_E_NO_IMPERSONATION
//
// MessageText:
//
// The security context does not allow impersonation of the client
//
#define SEC_E_NO_IMPERSONATION _HRESULT_TYPEDEF_(0x8009030BL)

//
// MessageId: SEC_E_LOGON_DENIED
//
// MessageText:
//
// The logon attempt failed
//
#define SEC_E_LOGON_DENIED _HRESULT_TYPEDEF_(0x8009030CL)

//
// MessageId: SEC_E_UNKNOWN_CREDENTIALS
//
// MessageText:
//
// The credentials supplied to the package were not recognized
//
#define SEC_E_UNKNOWN_CREDENTIALS _HRESULT_TYPEDEF_(0x8009030DL)

//
// MessageId: SEC_E_NO_CREDENTIALS
//
// MessageText:
//
// No credentials are available in the security package
//
#define SEC_E_NO_CREDENTIALS _HRESULT_TYPEDEF_(0x8009030EL)

//
// MessageId: SEC_E_MESSAGE_ALTERED
//
// MessageText:
//
// The message or signature supplied for verification has been altered
//
#define SEC_E_MESSAGE_ALTERED _HRESULT_TYPEDEF_(0x8009030FL)

//
// MessageId: SEC_E_OUT_OF_SEQUENCE
//
// MessageText:
//
// The message supplied for verification is out of sequence
//
#define SEC_E_OUT_OF_SEQUENCE _HRESULT_TYPEDEF_(0x80090310L)

//
// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
//
// MessageText:
//
// No authority could be contacted for authentication.
//
#define SEC_E_NO_AUTHENTICATING_AUTHORITY _HRESULT_TYPEDEF_(0x80090311L)

//
// MessageId: SEC_I_CONTINUE_NEEDED
//
// MessageText:
//
// The function completed successfully, but must be called again to complete the context
//
#define SEC_I_CONTINUE_NEEDED _HRESULT_TYPEDEF_(0x00090312L)

//
// MessageId: SEC_I_COMPLETE_NEEDED
//
// MessageText:
//
// The function completed successfully, but CompleteToken must be called
//
#define SEC_I_COMPLETE_NEEDED _HRESULT_TYPEDEF_(0x00090313L)

//
// MessageId: SEC_I_COMPLETE_AND_CONTINUE
//
// MessageText:
//
// The function completed successfully, but both CompleteToken and this function must be called to complete the context
//
#define SEC_I_COMPLETE_AND_CONTINUE _HRESULT_TYPEDEF_(0x00090314L)

//
// MessageId: SEC_I_LOCAL_LOGON
//
// MessageText:
//
// The logon was completed, but no network authority was available. The logon was made using locally known information
//
#define SEC_I_LOCAL_LOGON _HRESULT_TYPEDEF_(0x00090315L)

//
// MessageId: SEC_E_BAD_PKGID
//
// MessageText:
//
// The requested security package does not exist
//
#define SEC_E_BAD_PKGID _HRESULT_TYPEDEF_(0x80090316L)

//
// MessageId: SEC_E_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//
#define SEC_E_CONTEXT_EXPIRED _HRESULT_TYPEDEF_(0x80090317L)

//
// MessageId: SEC_I_CONTEXT_EXPIRED
//
// MessageText:
//
// The context has expired and can no longer be used.
//
#define SEC_I_CONTEXT_EXPIRED _HRESULT_TYPEDEF_(0x00090317L)

//
// MessageId: SEC_E_INCOMPLETE_MESSAGE
//
// MessageText:
//
// The supplied message is incomplete. The signature was not verified.
//
#define SEC_E_INCOMPLETE_MESSAGE _HRESULT_TYPEDEF_(0x80090318L)

//
// MessageId: SEC_E_INCOMPLETE_CREDENTIALS
//
// MessageText:
//
// The credentials supplied were not complete, and could not be verified. The context could not be initialized.
//
#define SEC_E_INCOMPLETE_CREDENTIALS _HRESULT_TYPEDEF_(0x80090320L)

//
// MessageId: SEC_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffers supplied to a function was too small.
//
#define SEC_E_BUFFER_TOO_SMALL _HRESULT_TYPEDEF_(0x80090321L)

//
// MessageId: SEC_I_INCOMPLETE_CREDENTIALS
//
// MessageText:
//
// The credentials supplied were not complete, and could not be verified. Additional information can be returned from the context.
//
#define SEC_I_INCOMPLETE_CREDENTIALS _HRESULT_TYPEDEF_(0x00090320L)

//
// MessageId: SEC_I_RENEGOTIATE
//
// MessageText:
//
// The context data must be renegotiated with the peer.
//
#define SEC_I_RENEGOTIATE _HRESULT_TYPEDEF_(0x00090321L)

//
// MessageId: SEC_E_WRONG_PRINCIPAL
//
// MessageText:
//
// The target principal name is incorrect.
//
#define SEC_E_WRONG_PRINCIPAL _HRESULT_TYPEDEF_(0x80090322L)

//
// MessageId: SEC_I_NO_LSA_CONTEXT
//
// MessageText:
//
// There is no LSA mode context associated with this context.
//
#define SEC_I_NO_LSA_CONTEXT _HRESULT_TYPEDEF_(0x00090323L)

//
// MessageId: SEC_E_TIME_SKEW
//
// MessageText:
//
// The clocks on the client and server machines are skewed.
//
#define SEC_E_TIME_SKEW _HRESULT_TYPEDEF_(0x80090324L)

//
// MessageId: SEC_E_UNTRUSTED_ROOT
//
// MessageText:
//
// The certificate chain was issued by an authority that is not trusted.
//
#define SEC_E_UNTRUSTED_ROOT _HRESULT_TYPEDEF_(0x80090325L)

//
// MessageId: SEC_E_ILLEGAL_MESSAGE
//
// MessageText:
//
// The message received was unexpected or badly formatted.
//
#define SEC_E_ILLEGAL_MESSAGE _HRESULT_TYPEDEF_(0x80090326L)

//
// MessageId: SEC_E_CERT_UNKNOWN
//
// MessageText:
//
// An unknown error occurred while processing the certificate.
//
#define SEC_E_CERT_UNKNOWN _HRESULT_TYPEDEF_(0x80090327L)

//
// MessageId: SEC_E_CERT_EXPIRED
//
// MessageText:
//
// The received certificate has expired.
//
#define SEC_E_CERT_EXPIRED _HRESULT_TYPEDEF_(0x80090328L)

//
// MessageId: SEC_E_ENCRYPT_FAILURE
//
// MessageText:
//
// The specified data could not be encrypted.
//
#define SEC_E_ENCRYPT_FAILURE _HRESULT_TYPEDEF_(0x80090329L)

//
// MessageId: SEC_E_DECRYPT_FAILURE
//
// MessageText:
//
// The specified data could not be decrypted.
// 
//
#define SEC_E_DECRYPT_FAILURE _HRESULT_TYPEDEF_(0x80090330L)

//
// MessageId: SEC_E_ALGORITHM_MISMATCH
//
// MessageText:
//
// The client and server cannot communicate, because they do not possess a common algorithm.
//
#define SEC_E_ALGORITHM_MISMATCH _HRESULT_TYPEDEF_(0x80090331L)

//
// MessageId: SEC_E_SECURITY_QOS_FAILED
//
// MessageText:
//
// The security context could not be established due to a failure in the requested quality of service (e.g. mutual authentication or delegation).
//
#define SEC_E_SECURITY_QOS_FAILED _HRESULT_TYPEDEF_(0x80090332L)

//
// MessageId: SEC_E_UNFINISHED_CONTEXT_DELETED
//
// MessageText:
//
// A security context was deleted before the context was completed. This is considered a logon failure.
//
#define SEC_E_UNFINISHED_CONTEXT_DELETED _HRESULT_TYPEDEF_(0x80090333L)

//
// MessageId: SEC_E_NO_TGT_REPLY
//
// MessageText:
//
// The client is trying to negotiate a context and the server requires user-to-user but didn't send a TGT reply.
//
#define SEC_E_NO_TGT_REPLY _HRESULT_TYPEDEF_(0x80090334L)

//
// MessageId: SEC_E_NO_IP_ADDRESSES
//
// MessageText:
//
// Unable to accomplish the requested task because the local machine does not have any IP addresses.
//
#define SEC_E_NO_IP_ADDRESSES _HRESULT_TYPEDEF_(0x80090335L)

//
// MessageId: SEC_E_WRONG_CREDENTIAL_HANDLE
//
// MessageText:
//
// The supplied credential handle does not match the credential associated with the security context.
//
#define SEC_E_WRONG_CREDENTIAL_HANDLE _HRESULT_TYPEDEF_(0x80090336L)

//
// MessageId: SEC_E_CRYPTO_SYSTEM_INVALID
//
// MessageText:
//
// The crypto system or checksum function is invalid because a required function is unavailable.
//
#define SEC_E_CRYPTO_SYSTEM_INVALID _HRESULT_TYPEDEF_(0x80090337L)

//
// MessageId: SEC_E_MAX_REFERRALS_EXCEEDED
//
// MessageText:
//
// The number of maximum ticket referrals has been exceeded.
//
#define SEC_E_MAX_REFERRALS_EXCEEDED _HRESULT_TYPEDEF_(0x80090338L)

//
// MessageId: SEC_E_MUST_BE_KDC
//
// MessageText:
//
// The local machine must be a Kerberos KDC (domain controller) and it is not.
//
#define SEC_E_MUST_BE_KDC _HRESULT_TYPEDEF_(0x80090339L)

//
// MessageId: SEC_E_STRONG_CRYPTO_NOT_SUPPORTED
//
// MessageText:
//
// The other end of the security negotiation is requires strong crypto but it is not supported on the local machine.
//
#define SEC_E_STRONG_CRYPTO_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8009033AL)

//
// MessageId: SEC_E_TOO_MANY_PRINCIPALS
//
// MessageText:
//
// The KDC reply contained more than one principal name.
//
#define SEC_E_TOO_MANY_PRINCIPALS _HRESULT_TYPEDEF_(0x8009033BL)

//
// MessageId: SEC_E_NO_PA_DATA
//
// MessageText:
//
// Expected to find PA data for a hint of what etype to use, but it was not found.
//
#define SEC_E_NO_PA_DATA _HRESULT_TYPEDEF_(0x8009033CL)

//
// MessageId: SEC_E_PKINIT_NAME_MISMATCH
//
// MessageText:
//
// The client certificate does not contain a valid UPN, or does not match the client name in the logon request. Please contact your administrator.
//
#define SEC_E_PKINIT_NAME_MISMATCH _HRESULT_TYPEDEF_(0x8009033DL)

//
// MessageId: SEC_E_SMARTCARD_LOGON_REQUIRED
//
// MessageText:
//
// Smartcard logon is required and was not used.
//
#define SEC_E_SMARTCARD_LOGON_REQUIRED _HRESULT_TYPEDEF_(0x8009033EL)

//
// MessageId: SEC_E_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//
#define SEC_E_SHUTDOWN_IN_PROGRESS _HRESULT_TYPEDEF_(0x8009033FL)

//
// MessageId: SEC_E_KDC_INVALID_REQUEST
//
// MessageText:
//
// An invalid request was sent to the KDC.
//
#define SEC_E_KDC_INVALID_REQUEST _HRESULT_TYPEDEF_(0x80090340L)

//
// MessageId: SEC_E_KDC_UNABLE_TO_REFER
//
// MessageText:
//
// The KDC was unable to generate a referral for the service requested.
//
#define SEC_E_KDC_UNABLE_TO_REFER _HRESULT_TYPEDEF_(0x80090341L)

//
// MessageId: SEC_E_KDC_UNKNOWN_ETYPE
//
// MessageText:
//
// The encryption type requested is not supported by the KDC.
//
#define SEC_E_KDC_UNKNOWN_ETYPE _HRESULT_TYPEDEF_(0x80090342L)

//
// MessageId: SEC_E_UNSUPPORTED_PREAUTH
//
// MessageText:
//
// An unsupported preauthentication mechanism was presented to the Kerberos package.
//
#define SEC_E_UNSUPPORTED_PREAUTH _HRESULT_TYPEDEF_(0x80090343L)

//
// MessageId: SEC_E_DELEGATION_REQUIRED
//
// MessageText:
//
// The requested operation cannot be completed. The computer must be trusted for delegation and the current user account must be configured to allow delegation.
//
#define SEC_E_DELEGATION_REQUIRED _HRESULT_TYPEDEF_(0x80090345L)

//
// MessageId: SEC_E_BAD_BINDINGS
//
// MessageText:
//
// Client's supplied SSPI channel bindings were incorrect.
//
#define SEC_E_BAD_BINDINGS _HRESULT_TYPEDEF_(0x80090346L)

//
// MessageId: SEC_E_MULTIPLE_ACCOUNTS
//
// MessageText:
//
// The received certificate was mapped to multiple accounts.
//
#define SEC_E_MULTIPLE_ACCOUNTS _HRESULT_TYPEDEF_(0x80090347L)

//
// MessageId: SEC_E_NO_KERB_KEY
//
// MessageText:
//
//  SEC_E_NO_KERB_KEY
//
#define SEC_E_NO_KERB_KEY _HRESULT_TYPEDEF_(0x80090348L)

//
// MessageId: SEC_E_CERT_WRONG_USAGE
//
// MessageText:
//
// The certificate is not valid for the requested usage.
//
#define SEC_E_CERT_WRONG_USAGE _HRESULT_TYPEDEF_(0x80090349L)

//
// MessageId: SEC_E_DOWNGRADE_DETECTED
//
// MessageText:
//
// The system detected a possible attempt to compromise security. Please ensure that you can contact the server that authenticated you.
//
#define SEC_E_DOWNGRADE_DETECTED _HRESULT_TYPEDEF_(0x80090350L)

//
// MessageId: SEC_E_SMARTCARD_CERT_REVOKED
//
// MessageText:
//
// The smartcard certificate used for authentication has been revoked. Please contact your system administrator. There may be additional information in the event log.
//
#define SEC_E_SMARTCARD_CERT_REVOKED _HRESULT_TYPEDEF_(0x80090351L)

//
// MessageId: SEC_E_ISSUING_CA_UNTRUSTED
//
// MessageText:
//
// An untrusted certificate authority was detected While processing the smartcard certificate used for authentication. Please contact your system administrator.
//
#define SEC_E_ISSUING_CA_UNTRUSTED _HRESULT_TYPEDEF_(0x80090352L)

//
// MessageId: SEC_E_REVOCATION_OFFLINE_C
//
// MessageText:
//
// The revocation status of the smartcard certificate used for authentication could not be determined. Please contact your system administrator.
//
#define SEC_E_REVOCATION_OFFLINE_C _HRESULT_TYPEDEF_(0x80090353L)

//
// MessageId: SEC_E_PKINIT_CLIENT_FAILURE
//
// MessageText:
//
// The smartcard certificate used for authentication was not trusted. Please contact your system administrator.
//
#define SEC_E_PKINIT_CLIENT_FAILURE _HRESULT_TYPEDEF_(0x80090354L)

//
// MessageId: SEC_E_SMARTCARD_CERT_EXPIRED
//
// MessageText:
//
// The smartcard certificate used for authentication has expired. Please contact your system administrator.
//
#define SEC_E_SMARTCARD_CERT_EXPIRED _HRESULT_TYPEDEF_(0x80090355L)

//
// MessageId: SEC_E_NO_S4U_PROT_SUPPORT
//
// MessageText:
//
// The Kerberos subsystem encountered an error. A service for user protocol request was made against a domain controller which does not support service for user.
//
#define SEC_E_NO_S4U_PROT_SUPPORT _HRESULT_TYPEDEF_(0x80090356L)

//
// MessageId: SEC_E_CROSSREALM_DELEGATION_FAILURE
//
// MessageText:
//
// An attempt was made by this server to make a Kerberos constrained delegation request for a target outside of the server's realm. This is not supported, and indicates a misconfiguration on this server's allowed to delegate to list. Please contact your administrator.
//
#define SEC_E_CROSSREALM_DELEGATION_FAILURE _HRESULT_TYPEDEF_(0x80090357L)

//
// MessageId: SEC_E_REVOCATION_OFFLINE_KDC
//
// MessageText:
//
// The revocation status of the domain controller certificate used for smartcard authentication could not be determined. There is additional information in the system event log. Please contact your system administrator.
//
#define SEC_E_REVOCATION_OFFLINE_KDC _HRESULT_TYPEDEF_(0x80090358L)

//
// MessageId: SEC_E_ISSUING_CA_UNTRUSTED_KDC
//
// MessageText:
//
// An untrusted certificate authority was detected while processing the domain controller certificate used for authentication. There is additional information in the system event log. Please contact your system administrator.
//
#define SEC_E_ISSUING_CA_UNTRUSTED_KDC _HRESULT_TYPEDEF_(0x80090359L)

//
// MessageId: SEC_E_KDC_CERT_EXPIRED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has expired. Please contact your system administrator with the contents of your system event log.
//
#define SEC_E_KDC_CERT_EXPIRED _HRESULT_TYPEDEF_(0x8009035AL)

//
// MessageId: SEC_E_KDC_CERT_REVOKED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has been revoked. Please contact your system administrator with the contents of your system event log.
//
#define SEC_E_KDC_CERT_REVOKED _HRESULT_TYPEDEF_(0x8009035BL)

//
// MessageId: SEC_I_SIGNATURE_NEEDED
//
// MessageText:
//
// A signature operation must be performed before the user can authenticate.
//
#define SEC_I_SIGNATURE_NEEDED _HRESULT_TYPEDEF_(0x0009035CL)

//
// MessageId: SEC_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more of the parameters passed to the function was invalid.
//
#define SEC_E_INVALID_PARAMETER _HRESULT_TYPEDEF_(0x8009035DL)

//
// MessageId: SEC_E_DELEGATION_POLICY
//
// MessageText:
//
// Client policy does not allow credential delegation to target server.
//
#define SEC_E_DELEGATION_POLICY _HRESULT_TYPEDEF_(0x8009035EL)

//
// MessageId: SEC_E_POLICY_NLTM_ONLY
//
// MessageText:
//
// Client policy does not allow credential delegation to target server with NLTM only authentication.
//
#define SEC_E_POLICY_NLTM_ONLY _HRESULT_TYPEDEF_(0x8009035FL)

//
// MessageId: SEC_I_NO_RENEGOTIATION
//
// MessageText:
//
// The recipient rejected the renegotiation request.
//
#define SEC_I_NO_RENEGOTIATION _HRESULT_TYPEDEF_(0x00090360L)

//
// MessageId: SEC_E_NO_CONTEXT
//
// MessageText:
//
// The required security context does not exist.
//
#define SEC_E_NO_CONTEXT _HRESULT_TYPEDEF_(0x80090361L)

//
// MessageId: SEC_E_PKU2U_CERT_FAILURE
//
// MessageText:
//
// The PKU2U protocol encountered an error while attempting to utilize the associated certificates.
//
#define SEC_E_PKU2U_CERT_FAILURE _HRESULT_TYPEDEF_(0x80090362L)

//
// MessageId: SEC_E_MUTUAL_AUTH_FAILED
//
// MessageText:
//
// The identity of the server computer could not be verified.
//
#define SEC_E_MUTUAL_AUTH_FAILED _HRESULT_TYPEDEF_(0x80090363L)

//
// Provided for backwards compatibility
//

#define SEC_E_NO_SPM SEC_E_INTERNAL_ERROR
#define SEC_E_NOT_SUPPORTED SEC_E_UNSUPPORTED_FUNCTION

//
// MessageId: CRYPT_E_MSG_ERROR
//
// MessageText:
//
// An error occurred while performing an operation on a cryptographic message.
//
#define CRYPT_E_MSG_ERROR _HRESULT_TYPEDEF_(0x80091001L)

//
// MessageId: CRYPT_E_UNKNOWN_ALGO
//
// MessageText:
//
// Unknown cryptographic algorithm.
//
#define CRYPT_E_UNKNOWN_ALGO _HRESULT_TYPEDEF_(0x80091002L)

//
// MessageId: CRYPT_E_OID_FORMAT
//
// MessageText:
//
// The object identifier is poorly formatted.
//
#define CRYPT_E_OID_FORMAT _HRESULT_TYPEDEF_(0x80091003L)

//
// MessageId: CRYPT_E_INVALID_MSG_TYPE
//
// MessageText:
//
// Invalid cryptographic message type.
//
#define CRYPT_E_INVALID_MSG_TYPE _HRESULT_TYPEDEF_(0x80091004L)

//
// MessageId: CRYPT_E_UNEXPECTED_ENCODING
//
// MessageText:
//
// Unexpected cryptographic message encoding.
//
#define CRYPT_E_UNEXPECTED_ENCODING _HRESULT_TYPEDEF_(0x80091005L)

//
// MessageId: CRYPT_E_AUTH_ATTR_MISSING
//
// MessageText:
//
// The cryptographic message does not contain an expected authenticated attribute.
//
#define CRYPT_E_AUTH_ATTR_MISSING _HRESULT_TYPEDEF_(0x80091006L)

//
// MessageId: CRYPT_E_HASH_VALUE
//
// MessageText:
//
// The hash value is not correct.
//
#define CRYPT_E_HASH_VALUE _HRESULT_TYPEDEF_(0x80091007L)

//
// MessageId: CRYPT_E_INVALID_INDEX
//
// MessageText:
//
// The index value is not valid.
//
#define CRYPT_E_INVALID_INDEX _HRESULT_TYPEDEF_(0x80091008L)

//
// MessageId: CRYPT_E_ALREADY_DECRYPTED
//
// MessageText:
//
// The content of the cryptographic message has already been decrypted.
//
#define CRYPT_E_ALREADY_DECRYPTED _HRESULT_TYPEDEF_(0x80091009L)

//
// MessageId: CRYPT_E_NOT_DECRYPTED
//
// MessageText:
//
// The content of the cryptographic message has not been decrypted yet.
//
#define CRYPT_E_NOT_DECRYPTED _HRESULT_TYPEDEF_(0x8009100AL)

//
// MessageId: CRYPT_E_RECIPIENT_NOT_FOUND
//
// MessageText:
//
// The enveloped-data message does not contain the specified recipient.
//
#define CRYPT_E_RECIPIENT_NOT_FOUND _HRESULT_TYPEDEF_(0x8009100BL)

//
// MessageId: CRYPT_E_CONTROL_TYPE
//
// MessageText:
//
// Invalid control type.
//
#define CRYPT_E_CONTROL_TYPE _HRESULT_TYPEDEF_(0x8009100CL)

//
// MessageId: CRYPT_E_ISSUER_SERIALNUMBER
//
// MessageText:
//
// Invalid issuer and/or serial number.
//
#define CRYPT_E_ISSUER_SERIALNUMBER _HRESULT_TYPEDEF_(0x8009100DL)

//
// MessageId: CRYPT_E_SIGNER_NOT_FOUND
//
// MessageText:
//
// Cannot find the original signer.
//
#define CRYPT_E_SIGNER_NOT_FOUND _HRESULT_TYPEDEF_(0x8009100EL)

//
// MessageId: CRYPT_E_ATTRIBUTES_MISSING
//
// MessageText:
//
// The cryptographic message does not contain all of the requested attributes.
//
#define CRYPT_E_ATTRIBUTES_MISSING _HRESULT_TYPEDEF_(0x8009100FL)

//
// MessageId: CRYPT_E_STREAM_MSG_NOT_READY
//
// MessageText:
//
// The streamed cryptographic message is not ready to return data.
//
#define CRYPT_E_STREAM_MSG_NOT_READY _HRESULT_TYPEDEF_(0x80091010L)

//
// MessageId: CRYPT_E_STREAM_INSUFFICIENT_DATA
//
// MessageText:
//
// The streamed cryptographic message requires more data to complete the decode operation.
//
#define CRYPT_E_STREAM_INSUFFICIENT_DATA _HRESULT_TYPEDEF_(0x80091011L)

//
// MessageId: CRYPT_I_NEW_PROTECTION_REQUIRED
//
// MessageText:
//
// The protected data needs to be re-protected.
//
#define CRYPT_I_NEW_PROTECTION_REQUIRED _HRESULT_TYPEDEF_(0x00091012L)

//
// MessageId: CRYPT_E_BAD_LEN
//
// MessageText:
//
// The length specified for the output data was insufficient.
//
#define CRYPT_E_BAD_LEN _HRESULT_TYPEDEF_(0x80092001L)

//
// MessageId: CRYPT_E_BAD_ENCODE
//
// MessageText:
//
// An error occurred during encode or decode operation.
//
#define CRYPT_E_BAD_ENCODE _HRESULT_TYPEDEF_(0x80092002L)

//
// MessageId: CRYPT_E_FILE_ERROR
//
// MessageText:
//
// An error occurred while reading or writing to a file.
//
#define CRYPT_E_FILE_ERROR _HRESULT_TYPEDEF_(0x80092003L)

//
// MessageId: CRYPT_E_NOT_FOUND
//
// MessageText:
//
// Cannot find object or property.
//
#define CRYPT_E_NOT_FOUND _HRESULT_TYPEDEF_(0x80092004L)

//
// MessageId: CRYPT_E_EXISTS
//
// MessageText:
//
// The object or property already exists.
//
#define CRYPT_E_EXISTS _HRESULT_TYPEDEF_(0x80092005L)

//
// MessageId: CRYPT_E_NO_PROVIDER
//
// MessageText:
//
// No provider was specified for the store or object.
//
#define CRYPT_E_NO_PROVIDER _HRESULT_TYPEDEF_(0x80092006L)

//
// MessageId: CRYPT_E_SELF_SIGNED
//
// MessageText:
//
// The specified certificate is self signed.
//
#define CRYPT_E_SELF_SIGNED _HRESULT_TYPEDEF_(0x80092007L)

//
// MessageId: CRYPT_E_DELETED_PREV
//
// MessageText:
//
// The previous certificate or CRL context was deleted.
//
#define CRYPT_E_DELETED_PREV _HRESULT_TYPEDEF_(0x80092008L)

//
// MessageId: CRYPT_E_NO_MATCH
//
// MessageText:
//
// Cannot find the requested object.
//
#define CRYPT_E_NO_MATCH _HRESULT_TYPEDEF_(0x80092009L)

//
// MessageId: CRYPT_E_UNEXPECTED_MSG_TYPE
//
// MessageText:
//
// The certificate does not have a property that references a private key.
//
#define CRYPT_E_UNEXPECTED_MSG_TYPE _HRESULT_TYPEDEF_(0x8009200AL)

//
// MessageId: CRYPT_E_NO_KEY_PROPERTY
//
// MessageText:
//
// Cannot find the certificate and private key for decryption.
//
#define CRYPT_E_NO_KEY_PROPERTY _HRESULT_TYPEDEF_(0x8009200BL)

//
// MessageId: CRYPT_E_NO_DECRYPT_CERT
//
// MessageText:
//
// Cannot find the certificate and private key to use for decryption.
//
#define CRYPT_E_NO_DECRYPT_CERT _HRESULT_TYPEDEF_(0x8009200CL)

//
// MessageId: CRYPT_E_BAD_MSG
//
// MessageText:
//
// Not a cryptographic message or the cryptographic message is not formatted correctly.
//
#define CRYPT_E_BAD_MSG _HRESULT_TYPEDEF_(0x8009200DL)

//
// MessageId: CRYPT_E_NO_SIGNER
//
// MessageText:
//
// The signed cryptographic message does not have a signer for the specified signer index.
//
#define CRYPT_E_NO_SIGNER _HRESULT_TYPEDEF_(0x8009200EL)

//
// MessageId: CRYPT_E_PENDING_CLOSE
//
// MessageText:
//
// Final closure is pending until additional frees or closes.
//
#define CRYPT_E_PENDING_CLOSE _HRESULT_TYPEDEF_(0x8009200FL)

//
// MessageId: CRYPT_E_REVOKED
//
// MessageText:
//
// The certificate is revoked.
//
#define CRYPT_E_REVOKED _HRESULT_TYPEDEF_(0x80092010L)

//
// MessageId: CRYPT_E_NO_REVOCATION_DLL
//
// MessageText:
//
// No Dll or exported function was found to verify revocation.
//
#define CRYPT_E_NO_REVOCATION_DLL _HRESULT_TYPEDEF_(0x80092011L)

//
// MessageId: CRYPT_E_NO_REVOCATION_CHECK
//
// MessageText:
//
// The revocation function was unable to check revocation for the certificate.
//
#define CRYPT_E_NO_REVOCATION_CHECK _HRESULT_TYPEDEF_(0x80092012L)

//
// MessageId: CRYPT_E_REVOCATION_OFFLINE
//
// MessageText:
//
// The revocation function was unable to check revocation because the revocation server was offline.
//
#define CRYPT_E_REVOCATION_OFFLINE _HRESULT_TYPEDEF_(0x80092013L)

//
// MessageId: CRYPT_E_NOT_IN_REVOCATION_DATABASE
//
// MessageText:
//
// The certificate is not in the revocation server's database.
//
#define CRYPT_E_NOT_IN_REVOCATION_DATABASE _HRESULT_TYPEDEF_(0x80092014L)

//
// MessageId: CRYPT_E_INVALID_NUMERIC_STRING
//
// MessageText:
//
// The string contains a non-numeric character.
//
#define CRYPT_E_INVALID_NUMERIC_STRING _HRESULT_TYPEDEF_(0x80092020L)

//
// MessageId: CRYPT_E_INVALID_PRINTABLE_STRING
//
// MessageText:
//
// The string contains a non-printable character.
//
#define CRYPT_E_INVALID_PRINTABLE_STRING _HRESULT_TYPEDEF_(0x80092021L)

//
// MessageId: CRYPT_E_INVALID_IA5_STRING
//
// MessageText:
//
// The string contains a character not in the 7 bit ASCII character set.
//
#define CRYPT_E_INVALID_IA5_STRING _HRESULT_TYPEDEF_(0x80092022L)

//
// MessageId: CRYPT_E_INVALID_X500_STRING
//
// MessageText:
//
// The string contains an invalid X500 name attribute key, oid, value or delimiter.
//
#define CRYPT_E_INVALID_X500_STRING _HRESULT_TYPEDEF_(0x80092023L)

//
// MessageId: CRYPT_E_NOT_CHAR_STRING
//
// MessageText:
//
// The dwValueType for the CERT_NAME_VALUE is not one of the character strings. Most likely it is either a CERT_RDN_ENCODED_BLOB or CERT_TDN_OCTED_STRING.
//
#define CRYPT_E_NOT_CHAR_STRING _HRESULT_TYPEDEF_(0x80092024L)

//
// MessageId: CRYPT_E_FILERESIZED
//
// MessageText:
//
// The Put operation cannot continue. The file needs to be resized. However, there is already a signature present. A complete signing operation must be done.
//
#define CRYPT_E_FILERESIZED _HRESULT_TYPEDEF_(0x80092025L)

//
// MessageId: CRYPT_E_SECURITY_SETTINGS
//
// MessageText:
//
// The cryptographic operation failed due to a local security option setting.
//
#define CRYPT_E_SECURITY_SETTINGS _HRESULT_TYPEDEF_(0x80092026L)

//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_DLL
//
// MessageText:
//
// No DLL or exported function was found to verify subject usage.
//
#define CRYPT_E_NO_VERIFY_USAGE_DLL _HRESULT_TYPEDEF_(0x80092027L)

//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_CHECK
//
// MessageText:
//
// The called function was unable to do a usage check on the subject.
//
#define CRYPT_E_NO_VERIFY_USAGE_CHECK _HRESULT_TYPEDEF_(0x80092028L)

//
// MessageId: CRYPT_E_VERIFY_USAGE_OFFLINE
//
// MessageText:
//
// Since the server was offline, the called function was unable to complete the usage check.
//
#define CRYPT_E_VERIFY_USAGE_OFFLINE _HRESULT_TYPEDEF_(0x80092029L)

//
// MessageId: CRYPT_E_NOT_IN_CTL
//
// MessageText:
//
// The subject was not found in a Certificate Trust List (CTL).
//
#define CRYPT_E_NOT_IN_CTL _HRESULT_TYPEDEF_(0x8009202AL)

//
// MessageId: CRYPT_E_NO_TRUSTED_SIGNER
//
// MessageText:
//
// None of the signers of the cryptographic message or certificate trust list is trusted.
//
#define CRYPT_E_NO_TRUSTED_SIGNER _HRESULT_TYPEDEF_(0x8009202BL)

//
// MessageId: CRYPT_E_MISSING_PUBKEY_PARA
//
// MessageText:
//
// The public key's algorithm parameters are missing.
//
#define CRYPT_E_MISSING_PUBKEY_PARA _HRESULT_TYPEDEF_(0x8009202CL)

//
// MessageId: CRYPT_E_OSS_ERROR
//
// MessageText:
//
// OSS Certificate encode/decode error code base
// 
// See asn1code.h for a definition of the OSS runtime errors. The OSS error values are offset by CRYPT_E_OSS_ERROR.
//
#define CRYPT_E_OSS_ERROR _HRESULT_TYPEDEF_(0x80093000L)

//
// MessageId: OSS_MORE_BUF
//
// MessageText:
//
// OSS ASN.1 Error: Output Buffer is too small.
//
#define OSS_MORE_BUF _HRESULT_TYPEDEF_(0x80093001L)

//
// MessageId: OSS_NEGATIVE_UINTEGER
//
// MessageText:
//
// OSS ASN.1 Error: Signed integer is encoded as a unsigned integer.
//
#define OSS_NEGATIVE_UINTEGER _HRESULT_TYPEDEF_(0x80093002L)

//
// MessageId: OSS_PDU_RANGE
//
// MessageText:
//
// OSS ASN.1 Error: Unknown ASN.1 data type.
//
#define OSS_PDU_RANGE _HRESULT_TYPEDEF_(0x80093003L)

//
// MessageId: OSS_MORE_INPUT
//
// MessageText:
//
// OSS ASN.1 Error: Output buffer is too small, the decoded data has been truncated.
//
#define OSS_MORE_INPUT _HRESULT_TYPEDEF_(0x80093004L)

//
// MessageId: OSS_DATA_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_DATA_ERROR _HRESULT_TYPEDEF_(0x80093005L)

//
// MessageId: OSS_BAD_ARG
//
// MessageText:
//
// OSS ASN.1 Error: Invalid argument.
//
#define OSS_BAD_ARG _HRESULT_TYPEDEF_(0x80093006L)

//
// MessageId: OSS_BAD_VERSION
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode version mismatch.
//
#define OSS_BAD_VERSION _HRESULT_TYPEDEF_(0x80093007L)

//
// MessageId: OSS_OUT_MEMORY
//
// MessageText:
//
// OSS ASN.1 Error: Out of memory.
//
#define OSS_OUT_MEMORY _HRESULT_TYPEDEF_(0x80093008L)

//
// MessageId: OSS_PDU_MISMATCH
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode Error.
//
#define OSS_PDU_MISMATCH _HRESULT_TYPEDEF_(0x80093009L)

//
// MessageId: OSS_LIMITED
//
// MessageText:
//
// OSS ASN.1 Error: Internal Error.
//
#define OSS_LIMITED _HRESULT_TYPEDEF_(0x8009300AL)

//
// MessageId: OSS_BAD_PTR
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_BAD_PTR _HRESULT_TYPEDEF_(0x8009300BL)

//
// MessageId: OSS_BAD_TIME
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_BAD_TIME _HRESULT_TYPEDEF_(0x8009300CL)

//
// MessageId: OSS_INDEFINITE_NOT_SUPPORTED
//
// MessageText:
//
// OSS ASN.1 Error: Unsupported BER indefinite-length encoding.
//
#define OSS_INDEFINITE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8009300DL)

//
// MessageId: OSS_MEM_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Access violation.
//
#define OSS_MEM_ERROR _HRESULT_TYPEDEF_(0x8009300EL)

//
// MessageId: OSS_BAD_TABLE
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_BAD_TABLE _HRESULT_TYPEDEF_(0x8009300FL)

//
// MessageId: OSS_TOO_LONG
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_TOO_LONG _HRESULT_TYPEDEF_(0x80093010L)

//
// MessageId: OSS_CONSTRAINT_VIOLATED
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_CONSTRAINT_VIOLATED _HRESULT_TYPEDEF_(0x80093011L)

//
// MessageId: OSS_FATAL_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Internal Error.
//
#define OSS_FATAL_ERROR _HRESULT_TYPEDEF_(0x80093012L)

//
// MessageId: OSS_ACCESS_SERIALIZATION_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Multi-threading conflict.
//
#define OSS_ACCESS_SERIALIZATION_ERROR _HRESULT_TYPEDEF_(0x80093013L)

//
// MessageId: OSS_NULL_TBL
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_NULL_TBL _HRESULT_TYPEDEF_(0x80093014L)

//
// MessageId: OSS_NULL_FCN
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_NULL_FCN _HRESULT_TYPEDEF_(0x80093015L)

//
// MessageId: OSS_BAD_ENCRULES
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_BAD_ENCRULES _HRESULT_TYPEDEF_(0x80093016L)

//
// MessageId: OSS_UNAVAIL_ENCRULES
//
// MessageText:
//
// OSS ASN.1 Error: Encode/Decode function not implemented.
//
#define OSS_UNAVAIL_ENCRULES _HRESULT_TYPEDEF_(0x80093017L)

//
// MessageId: OSS_CANT_OPEN_TRACE_WINDOW
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
#define OSS_CANT_OPEN_TRACE_WINDOW _HRESULT_TYPEDEF_(0x80093018L)

//
// MessageId: OSS_UNIMPLEMENTED
//
// MessageText:
//
// OSS ASN.1 Error: Function not implemented.
//
#define OSS_UNIMPLEMENTED _HRESULT_TYPEDEF_(0x80093019L)

//
// MessageId: OSS_OID_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_OID_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x8009301AL)

//
// MessageId: OSS_CANT_OPEN_TRACE_FILE
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
#define OSS_CANT_OPEN_TRACE_FILE _HRESULT_TYPEDEF_(0x8009301BL)

//
// MessageId: OSS_TRACE_FILE_ALREADY_OPEN
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
#define OSS_TRACE_FILE_ALREADY_OPEN _HRESULT_TYPEDEF_(0x8009301CL)

//
// MessageId: OSS_TABLE_MISMATCH
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_TABLE_MISMATCH _HRESULT_TYPEDEF_(0x8009301DL)

//
// MessageId: OSS_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// OSS ASN.1 Error: Invalid data.
//
#define OSS_TYPE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8009301EL)

//
// MessageId: OSS_REAL_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_REAL_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x8009301FL)

//
// MessageId: OSS_REAL_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_REAL_CODE_NOT_LINKED _HRESULT_TYPEDEF_(0x80093020L)

//
// MessageId: OSS_OUT_OF_RANGE
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_OUT_OF_RANGE _HRESULT_TYPEDEF_(0x80093021L)

//
// MessageId: OSS_COPIER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_COPIER_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x80093022L)

//
// MessageId: OSS_CONSTRAINT_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_CONSTRAINT_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x80093023L)

//
// MessageId: OSS_COMPARATOR_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_COMPARATOR_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x80093024L)

//
// MessageId: OSS_COMPARATOR_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_COMPARATOR_CODE_NOT_LINKED _HRESULT_TYPEDEF_(0x80093025L)

//
// MessageId: OSS_MEM_MGR_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_MEM_MGR_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x80093026L)

//
// MessageId: OSS_PDV_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_PDV_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x80093027L)

//
// MessageId: OSS_PDV_CODE_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_PDV_CODE_NOT_LINKED _HRESULT_TYPEDEF_(0x80093028L)

//
// MessageId: OSS_API_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_API_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x80093029L)

//
// MessageId: OSS_BERDER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_BERDER_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x8009302AL)

//
// MessageId: OSS_PER_DLL_NOT_LINKED
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_PER_DLL_NOT_LINKED _HRESULT_TYPEDEF_(0x8009302BL)

//
// MessageId: OSS_OPEN_TYPE_ERROR
//
// MessageText:
//
// OSS ASN.1 Error: Program link error.
//
#define OSS_OPEN_TYPE_ERROR _HRESULT_TYPEDEF_(0x8009302CL)

//
// MessageId: OSS_MUTEX_NOT_CREATED
//
// MessageText:
//
// OSS ASN.1 Error: System resource error.
//
#define OSS_MUTEX_NOT_CREATED _HRESULT_TYPEDEF_(0x8009302DL)

//
// MessageId: OSS_CANT_CLOSE_TRACE_FILE
//
// MessageText:
//
// OSS ASN.1 Error: Trace file error.
//
#define OSS_CANT_CLOSE_TRACE_FILE _HRESULT_TYPEDEF_(0x8009302EL)

//
// MessageId: CRYPT_E_ASN1_ERROR
//
// MessageText:
//
// ASN1 Certificate encode/decode error code base. The ASN1 error values are offset by CRYPT_E_ASN1_ERROR.
//
#define CRYPT_E_ASN1_ERROR _HRESULT_TYPEDEF_(0x80093100L)

//
// MessageId: CRYPT_E_ASN1_INTERNAL
//
// MessageText:
//
// ASN1 internal encode or decode error.
//
#define CRYPT_E_ASN1_INTERNAL _HRESULT_TYPEDEF_(0x80093101L)

//
// MessageId: CRYPT_E_ASN1_EOD
//
// MessageText:
//
// ASN1 unexpected end of data.
//
#define CRYPT_E_ASN1_EOD _HRESULT_TYPEDEF_(0x80093102L)

//
// MessageId: CRYPT_E_ASN1_CORRUPT
//
// MessageText:
//
// ASN1 corrupted data.
//
#define CRYPT_E_ASN1_CORRUPT _HRESULT_TYPEDEF_(0x80093103L)

//
// MessageId: CRYPT_E_ASN1_LARGE
//
// MessageText:
//
// ASN1 value too large.
//
#define CRYPT_E_ASN1_LARGE _HRESULT_TYPEDEF_(0x80093104L)

//
// MessageId: CRYPT_E_ASN1_CONSTRAINT
//
// MessageText:
//
// ASN1 constraint violated.
//
#define CRYPT_E_ASN1_CONSTRAINT _HRESULT_TYPEDEF_(0x80093105L)

//
// MessageId: CRYPT_E_ASN1_MEMORY
//
// MessageText:
//
// ASN1 out of memory.
//
#define CRYPT_E_ASN1_MEMORY _HRESULT_TYPEDEF_(0x80093106L)

//
// MessageId: CRYPT_E_ASN1_OVERFLOW
//
// MessageText:
//
// ASN1 buffer overflow.
//
#define CRYPT_E_ASN1_OVERFLOW _HRESULT_TYPEDEF_(0x80093107L)

//
// MessageId: CRYPT_E_ASN1_BADPDU
//
// MessageText:
//
// ASN1 function not supported for this PDU.
//
#define CRYPT_E_ASN1_BADPDU _HRESULT_TYPEDEF_(0x80093108L)

//
// MessageId: CRYPT_E_ASN1_BADARGS
//
// MessageText:
//
// ASN1 bad arguments to function call.
//
#define CRYPT_E_ASN1_BADARGS _HRESULT_TYPEDEF_(0x80093109L)

//
// MessageId: CRYPT_E_ASN1_BADREAL
//
// MessageText:
//
// ASN1 bad real value.
//
#define CRYPT_E_ASN1_BADREAL _HRESULT_TYPEDEF_(0x8009310AL)

//
// MessageId: CRYPT_E_ASN1_BADTAG
//
// MessageText:
//
// ASN1 bad tag value met.
//
#define CRYPT_E_ASN1_BADTAG _HRESULT_TYPEDEF_(0x8009310BL)

//
// MessageId: CRYPT_E_ASN1_CHOICE
//
// MessageText:
//
// ASN1 bad choice value.
//
#define CRYPT_E_ASN1_CHOICE _HRESULT_TYPEDEF_(0x8009310CL)

//
// MessageId: CRYPT_E_ASN1_RULE
//
// MessageText:
//
// ASN1 bad encoding rule.
//
#define CRYPT_E_ASN1_RULE _HRESULT_TYPEDEF_(0x8009310DL)

//
// MessageId: CRYPT_E_ASN1_UTF8
//
// MessageText:
//
// ASN1 bad unicode (UTF8).
//
#define CRYPT_E_ASN1_UTF8 _HRESULT_TYPEDEF_(0x8009310EL)

//
// MessageId: CRYPT_E_ASN1_PDU_TYPE
//
// MessageText:
//
// ASN1 bad PDU type.
//
#define CRYPT_E_ASN1_PDU_TYPE _HRESULT_TYPEDEF_(0x80093133L)

//
// MessageId: CRYPT_E_ASN1_NYI
//
// MessageText:
//
// ASN1 not yet implemented.
//
#define CRYPT_E_ASN1_NYI _HRESULT_TYPEDEF_(0x80093134L)

//
// MessageId: CRYPT_E_ASN1_EXTENDED
//
// MessageText:
//
// ASN1 skipped unknown extension(s).
//
#define CRYPT_E_ASN1_EXTENDED _HRESULT_TYPEDEF_(0x80093201L)

//
// MessageId: CRYPT_E_ASN1_NOEOD
//
// MessageText:
//
// ASN1 end of data expected
//
#define CRYPT_E_ASN1_NOEOD _HRESULT_TYPEDEF_(0x80093202L)

//
// MessageId: CERTSRV_E_BAD_REQUESTSUBJECT
//
// MessageText:
//
// The request subject name is invalid or too long.
//
#define CERTSRV_E_BAD_REQUESTSUBJECT _HRESULT_TYPEDEF_(0x80094001L)

//
// MessageId: CERTSRV_E_NO_REQUEST
//
// MessageText:
//
// The request does not exist.
//
#define CERTSRV_E_NO_REQUEST _HRESULT_TYPEDEF_(0x80094002L)

//
// MessageId: CERTSRV_E_BAD_REQUESTSTATUS
//
// MessageText:
//
// The request's current status does not allow this operation.
//
#define CERTSRV_E_BAD_REQUESTSTATUS _HRESULT_TYPEDEF_(0x80094003L)

//
// MessageId: CERTSRV_E_PROPERTY_EMPTY
//
// MessageText:
//
// The requested property value is empty.
//
#define CERTSRV_E_PROPERTY_EMPTY _HRESULT_TYPEDEF_(0x80094004L)

//
// MessageId: CERTSRV_E_INVALID_CA_CERTIFICATE
//
// MessageText:
//
// The certification authority's certificate contains invalid data.
//
#define CERTSRV_E_INVALID_CA_CERTIFICATE _HRESULT_TYPEDEF_(0x80094005L)

//
// MessageId: CERTSRV_E_SERVER_SUSPENDED
//
// MessageText:
//
// Certificate service has been suspended for a database restore operation.
//
#define CERTSRV_E_SERVER_SUSPENDED _HRESULT_TYPEDEF_(0x80094006L)

//
// MessageId: CERTSRV_E_ENCODING_LENGTH
//
// MessageText:
//
// The certificate contains an encoded length that is potentially incompatible with older enrollment software.
//
#define CERTSRV_E_ENCODING_LENGTH _HRESULT_TYPEDEF_(0x80094007L)

//
// MessageId: CERTSRV_E_ROLECONFLICT
//
// MessageText:
//
// The operation is denied. The user has multiple roles assigned and the certification authority is configured to enforce role separation.
//
#define CERTSRV_E_ROLECONFLICT _HRESULT_TYPEDEF_(0x80094008L)

//
// MessageId: CERTSRV_E_RESTRICTEDOFFICER
//
// MessageText:
//
// The operation is denied. It can only be performed by a certificate manager that is allowed to manage certificates for the current requester.
//
#define CERTSRV_E_RESTRICTEDOFFICER _HRESULT_TYPEDEF_(0x80094009L)

//
// MessageId: CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED
//
// MessageText:
//
// Cannot archive private key. The certification authority is not configured for key archival.
//
#define CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED _HRESULT_TYPEDEF_(0x8009400AL)

//
// MessageId: CERTSRV_E_NO_VALID_KRA
//
// MessageText:
//
// Cannot archive private key. The certification authority could not verify one or more key recovery certificates.
//
#define CERTSRV_E_NO_VALID_KRA _HRESULT_TYPEDEF_(0x8009400BL)

//
// MessageId: CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL
//
// MessageText:
//
// The request is incorrectly formatted. The encrypted private key must be in an unauthenticated attribute in an outermost signature.
//
#define CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL _HRESULT_TYPEDEF_(0x8009400CL)

//
// MessageId: CERTSRV_E_NO_CAADMIN_DEFINED
//
// MessageText:
//
// At least one security principal must have the permission to manage this CA.
//
#define CERTSRV_E_NO_CAADMIN_DEFINED _HRESULT_TYPEDEF_(0x8009400DL)

//
// MessageId: CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE
//
// MessageText:
//
// The request contains an invalid renewal certificate attribute.
//
#define CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE _HRESULT_TYPEDEF_(0x8009400EL)

//
// MessageId: CERTSRV_E_NO_DB_SESSIONS
//
// MessageText:
//
// An attempt was made to open a Certification Authority database session, but there are already too many active sessions. The server may need to be configured to allow additional sessions.
//
#define CERTSRV_E_NO_DB_SESSIONS _HRESULT_TYPEDEF_(0x8009400FL)

//
// MessageId: CERTSRV_E_ALIGNMENT_FAULT
//
// MessageText:
//
// A memory reference caused a data alignment fault.
//
#define CERTSRV_E_ALIGNMENT_FAULT _HRESULT_TYPEDEF_(0x80094010L)

//
// MessageId: CERTSRV_E_ENROLL_DENIED
//
// MessageText:
//
// The permissions on this certification authority do not allow the current user to enroll for certificates.
//
#define CERTSRV_E_ENROLL_DENIED _HRESULT_TYPEDEF_(0x80094011L)

//
// MessageId: CERTSRV_E_TEMPLATE_DENIED
//
// MessageText:
//
// The permissions on the certificate template do not allow the current user to enroll for this type of certificate.
//
#define CERTSRV_E_TEMPLATE_DENIED _HRESULT_TYPEDEF_(0x80094012L)

//
// MessageId: CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE
//
// MessageText:
//
// The contacted domain controller cannot support signed LDAP traffic. Update the domain controller or configure Certificate Services to use SSL for Active Directory access.
//
#define CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE _HRESULT_TYPEDEF_(0x80094013L)

//
// MessageId: CERTSRV_E_ADMIN_DENIED_REQUEST
//
// MessageText:
//
// The request was denied by a certificate manager or CA administrator.
//
#define CERTSRV_E_ADMIN_DENIED_REQUEST _HRESULT_TYPEDEF_(0x80094014L)

//
// MessageId: CERTSRV_E_NO_POLICY_SERVER
//
// MessageText:
//
// An enrollment policy server cannot be located.
//
#define CERTSRV_E_NO_POLICY_SERVER _HRESULT_TYPEDEF_(0x80094015L)

//
// MessageId: CERTSRV_E_UNSUPPORTED_CERT_TYPE
//
// MessageText:
//
// The requested certificate template is not supported by this CA.
//
#define CERTSRV_E_UNSUPPORTED_CERT_TYPE _HRESULT_TYPEDEF_(0x80094800L)

//
// MessageId: CERTSRV_E_NO_CERT_TYPE
//
// MessageText:
//
// The request contains no certificate template information.
//
#define CERTSRV_E_NO_CERT_TYPE _HRESULT_TYPEDEF_(0x80094801L)

//
// MessageId: CERTSRV_E_TEMPLATE_CONFLICT
//
// MessageText:
//
// The request contains conflicting template information.
//
#define CERTSRV_E_TEMPLATE_CONFLICT _HRESULT_TYPEDEF_(0x80094802L)

//
// MessageId: CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED
//
// MessageText:
//
// The request is missing a required Subject Alternate name extension.
//
#define CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED _HRESULT_TYPEDEF_(0x80094803L)

//
// MessageId: CERTSRV_E_ARCHIVED_KEY_REQUIRED
//
// MessageText:
//
// The request is missing a required private key for archival by the server.
//
#define CERTSRV_E_ARCHIVED_KEY_REQUIRED _HRESULT_TYPEDEF_(0x80094804L)

//
// MessageId: CERTSRV_E_SMIME_REQUIRED
//
// MessageText:
//
// The request is missing a required SMIME capabilities extension.
//
#define CERTSRV_E_SMIME_REQUIRED _HRESULT_TYPEDEF_(0x80094805L)

//
// MessageId: CERTSRV_E_BAD_RENEWAL_SUBJECT
//
// MessageText:
//
// The request was made on behalf of a subject other than the caller. The certificate template must be configured to require at least one signature to authorize the request.
//
#define CERTSRV_E_BAD_RENEWAL_SUBJECT _HRESULT_TYPEDEF_(0x80094806L)

//
// MessageId: CERTSRV_E_BAD_TEMPLATE_VERSION
//
// MessageText:
//
// The request template version is newer than the supported template version.
//
#define CERTSRV_E_BAD_TEMPLATE_VERSION _HRESULT_TYPEDEF_(0x80094807L)

//
// MessageId: CERTSRV_E_TEMPLATE_POLICY_REQUIRED
//
// MessageText:
//
// The template is missing a required signature policy attribute.
//
#define CERTSRV_E_TEMPLATE_POLICY_REQUIRED _HRESULT_TYPEDEF_(0x80094808L)

//
// MessageId: CERTSRV_E_SIGNATURE_POLICY_REQUIRED
//
// MessageText:
//
// The request is missing required signature policy information.
//
#define CERTSRV_E_SIGNATURE_POLICY_REQUIRED _HRESULT_TYPEDEF_(0x80094809L)

//
// MessageId: CERTSRV_E_SIGNATURE_COUNT
//
// MessageText:
//
// The request is missing one or more required signatures.
//
#define CERTSRV_E_SIGNATURE_COUNT _HRESULT_TYPEDEF_(0x8009480AL)

//
// MessageId: CERTSRV_E_SIGNATURE_REJECTED
//
// MessageText:
//
// One or more signatures did not include the required application or issuance policies. The request is missing one or more required valid signatures.
//
#define CERTSRV_E_SIGNATURE_REJECTED _HRESULT_TYPEDEF_(0x8009480BL)

//
// MessageId: CERTSRV_E_ISSUANCE_POLICY_REQUIRED
//
// MessageText:
//
// The request is missing one or more required signature issuance policies.
//
#define CERTSRV_E_ISSUANCE_POLICY_REQUIRED _HRESULT_TYPEDEF_(0x8009480CL)

//
// MessageId: CERTSRV_E_SUBJECT_UPN_REQUIRED
//
// MessageText:
//
// The UPN is unavailable and cannot be added to the Subject Alternate name.
//
#define CERTSRV_E_SUBJECT_UPN_REQUIRED _HRESULT_TYPEDEF_(0x8009480DL)

//
// MessageId: CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED
//
// MessageText:
//
// The Active Directory GUID is unavailable and cannot be added to the Subject Alternate name.
//
#define CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED _HRESULT_TYPEDEF_(0x8009480EL)

//
// MessageId: CERTSRV_E_SUBJECT_DNS_REQUIRED
//
// MessageText:
//
// The DNS name is unavailable and cannot be added to the Subject Alternate name.
//
#define CERTSRV_E_SUBJECT_DNS_REQUIRED _HRESULT_TYPEDEF_(0x8009480FL)

//
// MessageId: CERTSRV_E_ARCHIVED_KEY_UNEXPECTED
//
// MessageText:
//
// The request includes a private key for archival by the server, but key archival is not enabled for the specified certificate template.
//
#define CERTSRV_E_ARCHIVED_KEY_UNEXPECTED _HRESULT_TYPEDEF_(0x80094810L)

//
// MessageId: CERTSRV_E_KEY_LENGTH
//
// MessageText:
//
// The public key does not meet the minimum size required by the specified certificate template.
//
#define CERTSRV_E_KEY_LENGTH _HRESULT_TYPEDEF_(0x80094811L)

//
// MessageId: CERTSRV_E_SUBJECT_EMAIL_REQUIRED
//
// MessageText:
//
// The EMail name is unavailable and cannot be added to the Subject or Subject Alternate name.
//
#define CERTSRV_E_SUBJECT_EMAIL_REQUIRED _HRESULT_TYPEDEF_(0x80094812L)

//
// MessageId: CERTSRV_E_UNKNOWN_CERT_TYPE
//
// MessageText:
//
// One or more certificate templates to be enabled on this certification authority could not be found.
//
#define CERTSRV_E_UNKNOWN_CERT_TYPE _HRESULT_TYPEDEF_(0x80094813L)

//
// MessageId: CERTSRV_E_CERT_TYPE_OVERLAP
//
// MessageText:
//
// The certificate template renewal period is longer than the certificate validity period. The template should be reconfigured or the CA certificate renewed.
//
#define CERTSRV_E_CERT_TYPE_OVERLAP _HRESULT_TYPEDEF_(0x80094814L)

//
// MessageId: CERTSRV_E_TOO_MANY_SIGNATURES
//
// MessageText:
//
// The certificate template requires too many RA signatures. Only one RA signature is allowed.
//
#define CERTSRV_E_TOO_MANY_SIGNATURES _HRESULT_TYPEDEF_(0x80094815L)

//
// The range 0x5000-0x51ff is reserved for XENROLL errors.
//
//
// MessageId: XENROLL_E_KEY_NOT_EXPORTABLE
//
// MessageText:
//
// The key is not exportable.
//
#define XENROLL_E_KEY_NOT_EXPORTABLE _HRESULT_TYPEDEF_(0x80095000L)

//
// MessageId: XENROLL_E_CANNOT_ADD_ROOT_CERT
//
// MessageText:
//
// You cannot add the root CA certificate into your local store.
//
#define XENROLL_E_CANNOT_ADD_ROOT_CERT _HRESULT_TYPEDEF_(0x80095001L)

//
// MessageId: XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND
//
// MessageText:
//
// The key archival hash attribute was not found in the response.
//
#define XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND _HRESULT_TYPEDEF_(0x80095002L)

//
// MessageId: XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH
//
// MessageText:
//
// An unexpected key archival hash attribute was found in the response.
//
#define XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH _HRESULT_TYPEDEF_(0x80095003L)

//
// MessageId: XENROLL_E_RESPONSE_KA_HASH_MISMATCH
//
// MessageText:
//
// There is a key archival hash mismatch between the request and the response.
//
#define XENROLL_E_RESPONSE_KA_HASH_MISMATCH _HRESULT_TYPEDEF_(0x80095004L)

//
// MessageId: XENROLL_E_KEYSPEC_SMIME_MISMATCH
//
// MessageText:
//
// Signing certificate cannot include SMIME extension.
//
#define XENROLL_E_KEYSPEC_SMIME_MISMATCH _HRESULT_TYPEDEF_(0x80095005L)

//
// MessageId: TRUST_E_SYSTEM_ERROR
//
// MessageText:
//
// A system-level error occurred while verifying trust.
//
#define TRUST_E_SYSTEM_ERROR _HRESULT_TYPEDEF_(0x80096001L)

//
// MessageId: TRUST_E_NO_SIGNER_CERT
//
// MessageText:
//
// The certificate for the signer of the message is invalid or not found.
//
#define TRUST_E_NO_SIGNER_CERT _HRESULT_TYPEDEF_(0x80096002L)

//
// MessageId: TRUST_E_COUNTER_SIGNER
//
// MessageText:
//
// One of the counter signatures was invalid.
//
#define TRUST_E_COUNTER_SIGNER _HRESULT_TYPEDEF_(0x80096003L)

//
// MessageId: TRUST_E_CERT_SIGNATURE
//
// MessageText:
//
// The signature of the certificate cannot be verified.
//
#define TRUST_E_CERT_SIGNATURE _HRESULT_TYPEDEF_(0x80096004L)

//
// MessageId: TRUST_E_TIME_STAMP
//
// MessageText:
//
// The timestamp signature and/or certificate could not be verified or is malformed.
//
#define TRUST_E_TIME_STAMP _HRESULT_TYPEDEF_(0x80096005L)

//
// MessageId: TRUST_E_BAD_DIGEST
//
// MessageText:
//
// The digital signature of the object did not verify.
//
#define TRUST_E_BAD_DIGEST _HRESULT_TYPEDEF_(0x80096010L)

//
// MessageId: TRUST_E_BASIC_CONSTRAINTS
//
// MessageText:
//
// A certificate's basic constraint extension has not been observed.
//
#define TRUST_E_BASIC_CONSTRAINTS _HRESULT_TYPEDEF_(0x80096019L)

//
// MessageId: TRUST_E_FINANCIAL_CRITERIA
//
// MessageText:
//
// The certificate does not meet or contain the Authenticode(tm) financial extensions.
//
#define TRUST_E_FINANCIAL_CRITERIA _HRESULT_TYPEDEF_(0x8009601EL)

//
// Error codes for mssipotf.dll
// Most of the error codes can only occur when an error occurs
//    during font file signing
//
//
//
// MessageId: MSSIPOTF_E_OUTOFMEMRANGE
//
// MessageText:
//
// Tried to reference a part of the file outside the proper range.
//
#define MSSIPOTF_E_OUTOFMEMRANGE _HRESULT_TYPEDEF_(0x80097001L)

//
// MessageId: MSSIPOTF_E_CANTGETOBJECT
//
// MessageText:
//
// Could not retrieve an object from the file.
//
#define MSSIPOTF_E_CANTGETOBJECT _HRESULT_TYPEDEF_(0x80097002L)

//
// MessageId: MSSIPOTF_E_NOHEADTABLE
//
// MessageText:
//
// Could not find the head table in the file.
//
#define MSSIPOTF_E_NOHEADTABLE _HRESULT_TYPEDEF_(0x80097003L)

//
// MessageId: MSSIPOTF_E_BAD_MAGICNUMBER
//
// MessageText:
//
// The magic number in the head table is incorrect.
//
#define MSSIPOTF_E_BAD_MAGICNUMBER _HRESULT_TYPEDEF_(0x80097004L)

//
// MessageId: MSSIPOTF_E_BAD_OFFSET_TABLE
//
// MessageText:
//
// The offset table has incorrect values.
//
#define MSSIPOTF_E_BAD_OFFSET_TABLE _HRESULT_TYPEDEF_(0x80097005L)

//
// MessageId: MSSIPOTF_E_TABLE_TAGORDER
//
// MessageText:
//
// Duplicate table tags or tags out of alphabetical order.
//
#define MSSIPOTF_E_TABLE_TAGORDER _HRESULT_TYPEDEF_(0x80097006L)

//
// MessageId: MSSIPOTF_E_TABLE_LONGWORD
//
// MessageText:
//
// A table does not start on a long word boundary.
//
#define MSSIPOTF_E_TABLE_LONGWORD _HRESULT_TYPEDEF_(0x80097007L)

//
// MessageId: MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT
//
// MessageText:
//
// First table does not appear after header information.
//
#define MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT _HRESULT_TYPEDEF_(0x80097008L)

//
// MessageId: MSSIPOTF_E_TABLES_OVERLAP
//
// MessageText:
//
// Two or more tables overlap.
//
#define MSSIPOTF_E_TABLES_OVERLAP _HRESULT_TYPEDEF_(0x80097009L)

//
// MessageId: MSSIPOTF_E_TABLE_PADBYTES
//
// MessageText:
//
// Too many pad bytes between tables or pad bytes are not 0.
//
#define MSSIPOTF_E_TABLE_PADBYTES _HRESULT_TYPEDEF_(0x8009700AL)

//
// MessageId: MSSIPOTF_E_FILETOOSMALL
//
// MessageText:
//
// File is too small to contain the last table.
//
#define MSSIPOTF_E_FILETOOSMALL _HRESULT_TYPEDEF_(0x8009700BL)

//
// MessageId: MSSIPOTF_E_TABLE_CHECKSUM
//
// MessageText:
//
// A table checksum is incorrect.
//
#define MSSIPOTF_E_TABLE_CHECKSUM _HRESULT_TYPEDEF_(0x8009700CL)

//
// MessageId: MSSIPOTF_E_FILE_CHECKSUM
//
// MessageText:
//
// The file checksum is incorrect.
//
#define MSSIPOTF_E_FILE_CHECKSUM _HRESULT_TYPEDEF_(0x8009700DL)

//
// MessageId: MSSIPOTF_E_FAILED_POLICY
//
// MessageText:
//
// The signature does not have the correct attributes for the policy.
//
#define MSSIPOTF_E_FAILED_POLICY _HRESULT_TYPEDEF_(0x80097010L)

//
// MessageId: MSSIPOTF_E_FAILED_HINTS_CHECK
//
// MessageText:
//
// The file did not pass the hints check.
//
#define MSSIPOTF_E_FAILED_HINTS_CHECK _HRESULT_TYPEDEF_(0x80097011L)

//
// MessageId: MSSIPOTF_E_NOT_OPENTYPE
//
// MessageText:
//
// The file is not an OpenType file.
//
#define MSSIPOTF_E_NOT_OPENTYPE _HRESULT_TYPEDEF_(0x80097012L)

//
// MessageId: MSSIPOTF_E_FILE
//
// MessageText:
//
// Failed on a file operation (open, map, read, write).
//
#define MSSIPOTF_E_FILE _HRESULT_TYPEDEF_(0x80097013L)

//
// MessageId: MSSIPOTF_E_CRYPT
//
// MessageText:
//
// A call to a CryptoAPI function failed.
//
#define MSSIPOTF_E_CRYPT _HRESULT_TYPEDEF_(0x80097014L)

//
// MessageId: MSSIPOTF_E_BADVERSION
//
// MessageText:
//
// There is a bad version number in the file.
//
#define MSSIPOTF_E_BADVERSION _HRESULT_TYPEDEF_(0x80097015L)

//
// MessageId: MSSIPOTF_E_DSIG_STRUCTURE
//
// MessageText:
//
// The structure of the DSIG table is incorrect.
//
#define MSSIPOTF_E_DSIG_STRUCTURE _HRESULT_TYPEDEF_(0x80097016L)

//
// MessageId: MSSIPOTF_E_PCONST_CHECK
//
// MessageText:
//
// A check failed in a partially constant table.
//
#define MSSIPOTF_E_PCONST_CHECK _HRESULT_TYPEDEF_(0x80097017L)

//
// MessageId: MSSIPOTF_E_STRUCTURE
//
// MessageText:
//
// Some kind of structural error.
//
#define MSSIPOTF_E_STRUCTURE _HRESULT_TYPEDEF_(0x80097018L)

//
// MessageId: ERROR_CRED_REQUIRES_CONFIRMATION
//
// MessageText:
//
// The requested credential requires confirmation.
//
#define ERROR_CRED_REQUIRES_CONFIRMATION _HRESULT_TYPEDEF_(0x80097019L)

#define NTE_OP_OK 0

//
// Note that additional FACILITY_SSPI errors are in issperr.h
//
// ******************
// FACILITY_CERT
// ******************
//
// MessageId: TRUST_E_PROVIDER_UNKNOWN
//
// MessageText:
//
// Unknown trust provider.
//
#define TRUST_E_PROVIDER_UNKNOWN _HRESULT_TYPEDEF_(0x800B0001L)

//
// MessageId: TRUST_E_ACTION_UNKNOWN
//
// MessageText:
//
// The trust verification action specified is not supported by the specified trust provider.
//
#define TRUST_E_ACTION_UNKNOWN _HRESULT_TYPEDEF_(0x800B0002L)

//
// MessageId: TRUST_E_SUBJECT_FORM_UNKNOWN
//
// MessageText:
//
// The form specified for the subject is not one supported or known by the specified trust provider.
//
#define TRUST_E_SUBJECT_FORM_UNKNOWN _HRESULT_TYPEDEF_(0x800B0003L)

//
// MessageId: TRUST_E_SUBJECT_NOT_TRUSTED
//
// MessageText:
//
// The subject is not trusted for the specified action.
//
#define TRUST_E_SUBJECT_NOT_TRUSTED _HRESULT_TYPEDEF_(0x800B0004L)

//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
// Error due to problem in ASN.1 encoding process.
//
#define DIGSIG_E_ENCODE _HRESULT_TYPEDEF_(0x800B0005L)

//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
// Error due to problem in ASN.1 decoding process.
//
#define DIGSIG_E_DECODE _HRESULT_TYPEDEF_(0x800B0006L)

//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
// Reading / writing Extensions where Attributes are appropriate, and visa versa.
//
#define DIGSIG_E_EXTENSIBILITY _HRESULT_TYPEDEF_(0x800B0007L)

//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
// Unspecified cryptographic failure.
//
#define DIGSIG_E_CRYPTO _HRESULT_TYPEDEF_(0x800B0008L)

//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
// The size of the data could not be determined.
//
#define PERSIST_E_SIZEDEFINITE _HRESULT_TYPEDEF_(0x800B0009L)

//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
// The size of the indefinite-sized data could not be determined.
//
#define PERSIST_E_SIZEINDEFINITE _HRESULT_TYPEDEF_(0x800B000AL)

//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
// This object does not read and write self-sizing data.
//
#define PERSIST_E_NOTSELFSIZING _HRESULT_TYPEDEF_(0x800B000BL)

//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
// No signature was present in the subject.
//
#define TRUST_E_NOSIGNATURE _HRESULT_TYPEDEF_(0x800B0100L)

//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
// A required certificate is not within its validity period when verifying against the current system clock or the timestamp in the signed file.
//
#define CERT_E_EXPIRED _HRESULT_TYPEDEF_(0x800B0101L)

//
// MessageId: CERT_E_VALIDITYPERIODNESTING
//
// MessageText:
//
// The validity periods of the certification chain do not nest correctly.
//
#define CERT_E_VALIDITYPERIODNESTING _HRESULT_TYPEDEF_(0x800B0102L)

//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
// A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
#define CERT_E_ROLE _HRESULT_TYPEDEF_(0x800B0103L)

//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
// A path length constraint in the certification chain has been violated.
//
#define CERT_E_PATHLENCONST _HRESULT_TYPEDEF_(0x800B0104L)

//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
// A certificate contains an unknown extension that is marked 'critical'.
//
#define CERT_E_CRITICAL _HRESULT_TYPEDEF_(0x800B0105L)

//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
// A certificate being used for a purpose other than the ones specified by its CA.
//
#define CERT_E_PURPOSE _HRESULT_TYPEDEF_(0x800B0106L)

//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
// A parent of a given certificate in fact did not issue that child certificate.
//
#define CERT_E_ISSUERCHAINING _HRESULT_TYPEDEF_(0x800B0107L)

//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
// A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
#define CERT_E_MALFORMED _HRESULT_TYPEDEF_(0x800B0108L)

//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
// A certificate chain processed, but terminated in a root certificate which is not trusted by the trust provider.
//
#define CERT_E_UNTRUSTEDROOT _HRESULT_TYPEDEF_(0x800B0109L)

//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
// A certificate chain could not be built to a trusted root authority.
//
#define CERT_E_CHAINING _HRESULT_TYPEDEF_(0x800B010AL)

//
// MessageId: TRUST_E_FAIL
//
// MessageText:
//
// Generic trust failure.
//
#define TRUST_E_FAIL _HRESULT_TYPEDEF_(0x800B010BL)

//
// MessageId: CERT_E_REVOKED
//
// MessageText:
//
// A certificate was explicitly revoked by its issuer.
//
#define CERT_E_REVOKED _HRESULT_TYPEDEF_(0x800B010CL)

//
// MessageId: CERT_E_UNTRUSTEDTESTROOT
//
// MessageText:
//
// The certification path terminates with the test root which is not trusted with the current policy settings.
//
#define CERT_E_UNTRUSTEDTESTROOT _HRESULT_TYPEDEF_(0x800B010DL)

//
// MessageId: CERT_E_REVOCATION_FAILURE
//
// MessageText:
//
// The revocation process could not continue - the certificate(s) could not be checked.
//
#define CERT_E_REVOCATION_FAILURE _HRESULT_TYPEDEF_(0x800B010EL)

//
// MessageId: CERT_E_CN_NO_MATCH
//
// MessageText:
//
// The certificate's CN name does not match the passed value.
//
#define CERT_E_CN_NO_MATCH _HRESULT_TYPEDEF_(0x800B010FL)

//
// MessageId: CERT_E_WRONG_USAGE
//
// MessageText:
//
// The certificate is not valid for the requested usage.
//
#define CERT_E_WRONG_USAGE _HRESULT_TYPEDEF_(0x800B0110L)

//
// MessageId: TRUST_E_EXPLICIT_DISTRUST
//
// MessageText:
//
// The certificate was explicitly marked as untrusted by the user.
//
#define TRUST_E_EXPLICIT_DISTRUST _HRESULT_TYPEDEF_(0x800B0111L)

//
// MessageId: CERT_E_UNTRUSTEDCA
//
// MessageText:
//
// A certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider.
//
#define CERT_E_UNTRUSTEDCA _HRESULT_TYPEDEF_(0x800B0112L)

//
// MessageId: CERT_E_INVALID_POLICY
//
// MessageText:
//
// The certificate has invalid policy.
//
#define CERT_E_INVALID_POLICY _HRESULT_TYPEDEF_(0x800B0113L)

//
// MessageId: CERT_E_INVALID_NAME
//
// MessageText:
//
// The certificate has an invalid name. The name is not included in the permitted list or is explicitly excluded.
//
#define CERT_E_INVALID_NAME _HRESULT_TYPEDEF_(0x800B0114L)

// *****************
// FACILITY_SETUPAPI
// *****************
//
// Since these error codes aren't in the standard Win32 range (i.e., 0-64K), define a
// macro to map either Win32 or SetupAPI error codes into an HRESULT.
//
#define HRESULT_FROM_SETUPAPI(x) ((((x) & (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR)) == (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR)) ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_SETUPAPI << 16) | 0x80000000)) : HRESULT_FROM_WIN32(x))


//
// MessageId: SPAPI_E_EXPECTED_SECTION_NAME
//
// MessageText:
//
// A non-empty line was encountered in the INF before the start of a section.
//
#define SPAPI_E_EXPECTED_SECTION_NAME _HRESULT_TYPEDEF_(0x800F0000L)

//
// MessageId: SPAPI_E_BAD_SECTION_NAME_LINE
//
// MessageText:
//
// A section name marker in the INF is not complete, or does not exist on a line by itself.
//
#define SPAPI_E_BAD_SECTION_NAME_LINE _HRESULT_TYPEDEF_(0x800F0001L)

//
// MessageId: SPAPI_E_SECTION_NAME_TOO_LONG
//
// MessageText:
//
// An INF section was encountered whose name exceeds the maximum section name length.
//
#define SPAPI_E_SECTION_NAME_TOO_LONG _HRESULT_TYPEDEF_(0x800F0002L)

//
// MessageId: SPAPI_E_GENERAL_SYNTAX
//
// MessageText:
//
// The syntax of the INF is invalid.
//
#define SPAPI_E_GENERAL_SYNTAX _HRESULT_TYPEDEF_(0x800F0003L)

//
// MessageId: SPAPI_E_WRONG_INF_STYLE
//
// MessageText:
//
// The style of the INF is different than what was requested.
//
#define SPAPI_E_WRONG_INF_STYLE _HRESULT_TYPEDEF_(0x800F0100L)

//
// MessageId: SPAPI_E_SECTION_NOT_FOUND
//
// MessageText:
//
// The required section was not found in the INF.
//
#define SPAPI_E_SECTION_NOT_FOUND _HRESULT_TYPEDEF_(0x800F0101L)

//
// MessageId: SPAPI_E_LINE_NOT_FOUND
//
// MessageText:
//
// The required line was not found in the INF.
//
#define SPAPI_E_LINE_NOT_FOUND _HRESULT_TYPEDEF_(0x800F0102L)

//
// MessageId: SPAPI_E_NO_BACKUP
//
// MessageText:
//
// The files affected by the installation of this file queue have not been backed up for uninstall.
//
#define SPAPI_E_NO_BACKUP _HRESULT_TYPEDEF_(0x800F0103L)

//
// MessageId: SPAPI_E_NO_ASSOCIATED_CLASS
//
// MessageText:
//
// The INF or the device information set or element does not have an associated install class.
//
#define SPAPI_E_NO_ASSOCIATED_CLASS _HRESULT_TYPEDEF_(0x800F0200L)

//
// MessageId: SPAPI_E_CLASS_MISMATCH
//
// MessageText:
//
// The INF or the device information set or element does not match the specified install class.
//
#define SPAPI_E_CLASS_MISMATCH _HRESULT_TYPEDEF_(0x800F0201L)

//
// MessageId: SPAPI_E_DUPLICATE_FOUND
//
// MessageText:
//
// An existing device was found that is a duplicate of the device being manually installed.
//
#define SPAPI_E_DUPLICATE_FOUND _HRESULT_TYPEDEF_(0x800F0202L)

//
// MessageId: SPAPI_E_NO_DRIVER_SELECTED
//
// MessageText:
//
// There is no driver selected for the device information set or element.
//
#define SPAPI_E_NO_DRIVER_SELECTED _HRESULT_TYPEDEF_(0x800F0203L)

//
// MessageId: SPAPI_E_KEY_DOES_NOT_EXIST
//
// MessageText:
//
// The requested device registry key does not exist.
//
#define SPAPI_E_KEY_DOES_NOT_EXIST _HRESULT_TYPEDEF_(0x800F0204L)

//
// MessageId: SPAPI_E_INVALID_DEVINST_NAME
//
// MessageText:
//
// The device instance name is invalid.
//
#define SPAPI_E_INVALID_DEVINST_NAME _HRESULT_TYPEDEF_(0x800F0205L)

//
// MessageId: SPAPI_E_INVALID_CLASS
//
// MessageText:
//
// The install class is not present or is invalid.
//
#define SPAPI_E_INVALID_CLASS _HRESULT_TYPEDEF_(0x800F0206L)

//
// MessageId: SPAPI_E_DEVINST_ALREADY_EXISTS
//
// MessageText:
//
// The device instance cannot be created because it already exists.
//
#define SPAPI_E_DEVINST_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x800F0207L)

//
// MessageId: SPAPI_E_DEVINFO_NOT_REGISTERED
//
// MessageText:
//
// The operation cannot be performed on a device information element that has not been registered.
//
#define SPAPI_E_DEVINFO_NOT_REGISTERED _HRESULT_TYPEDEF_(0x800F0208L)

//
// MessageId: SPAPI_E_INVALID_REG_PROPERTY
//
// MessageText:
//
// The device property code is invalid.
//
#define SPAPI_E_INVALID_REG_PROPERTY _HRESULT_TYPEDEF_(0x800F0209L)

//
// MessageId: SPAPI_E_NO_INF
//
// MessageText:
//
// The INF from which a driver list is to be built does not exist.
//
#define SPAPI_E_NO_INF _HRESULT_TYPEDEF_(0x800F020AL)

//
// MessageId: SPAPI_E_NO_SUCH_DEVINST
//
// MessageText:
//
// The device instance does not exist in the hardware tree.
//
#define SPAPI_E_NO_SUCH_DEVINST _HRESULT_TYPEDEF_(0x800F020BL)

//
// MessageId: SPAPI_E_CANT_LOAD_CLASS_ICON
//
// MessageText:
//
// The icon representing this install class cannot be loaded.
//
#define SPAPI_E_CANT_LOAD_CLASS_ICON _HRESULT_TYPEDEF_(0x800F020CL)

//
// MessageId: SPAPI_E_INVALID_CLASS_INSTALLER
//
// MessageText:
//
// The class installer registry entry is invalid.
//
#define SPAPI_E_INVALID_CLASS_INSTALLER _HRESULT_TYPEDEF_(0x800F020DL)

//
// MessageId: SPAPI_E_DI_DO_DEFAULT
//
// MessageText:
//
// The class installer has indicated that the default action should be performed for this installation request.
//
#define SPAPI_E_DI_DO_DEFAULT _HRESULT_TYPEDEF_(0x800F020EL)

//
// MessageId: SPAPI_E_DI_NOFILECOPY
//
// MessageText:
//
// The operation does not require any files to be copied.
//
#define SPAPI_E_DI_NOFILECOPY _HRESULT_TYPEDEF_(0x800F020FL)

//
// MessageId: SPAPI_E_INVALID_HWPROFILE
//
// MessageText:
//
// The specified hardware profile does not exist.
//
#define SPAPI_E_INVALID_HWPROFILE _HRESULT_TYPEDEF_(0x800F0210L)

//
// MessageId: SPAPI_E_NO_DEVICE_SELECTED
//
// MessageText:
//
// There is no device information element currently selected for this device information set.
//
#define SPAPI_E_NO_DEVICE_SELECTED _HRESULT_TYPEDEF_(0x800F0211L)

//
// MessageId: SPAPI_E_DEVINFO_LIST_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the device information set is locked.
//
#define SPAPI_E_DEVINFO_LIST_LOCKED _HRESULT_TYPEDEF_(0x800F0212L)

//
// MessageId: SPAPI_E_DEVINFO_DATA_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the device information element is locked.
//
#define SPAPI_E_DEVINFO_DATA_LOCKED _HRESULT_TYPEDEF_(0x800F0213L)

//
// MessageId: SPAPI_E_DI_BAD_PATH
//
// MessageText:
//
// The specified path does not contain any applicable device INFs.
//
#define SPAPI_E_DI_BAD_PATH _HRESULT_TYPEDEF_(0x800F0214L)

//
// MessageId: SPAPI_E_NO_CLASSINSTALL_PARAMS
//
// MessageText:
//
// No class installer parameters have been set for the device information set or element.
//
#define SPAPI_E_NO_CLASSINSTALL_PARAMS _HRESULT_TYPEDEF_(0x800F0215L)

//
// MessageId: SPAPI_E_FILEQUEUE_LOCKED
//
// MessageText:
//
// The operation cannot be performed because the file queue is locked.
//
#define SPAPI_E_FILEQUEUE_LOCKED _HRESULT_TYPEDEF_(0x800F0216L)

//
// MessageId: SPAPI_E_BAD_SERVICE_INSTALLSECT
//
// MessageText:
//
// A service installation section in this INF is invalid.
//
#define SPAPI_E_BAD_SERVICE_INSTALLSECT _HRESULT_TYPEDEF_(0x800F0217L)

//
// MessageId: SPAPI_E_NO_CLASS_DRIVER_LIST
//
// MessageText:
//
// There is no class driver list for the device information element.
//
#define SPAPI_E_NO_CLASS_DRIVER_LIST _HRESULT_TYPEDEF_(0x800F0218L)

//
// MessageId: SPAPI_E_NO_ASSOCIATED_SERVICE
//
// MessageText:
//
// The installation failed because a function driver was not specified for this device instance.
//
#define SPAPI_E_NO_ASSOCIATED_SERVICE _HRESULT_TYPEDEF_(0x800F0219L)

//
// MessageId: SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE
//
// MessageText:
//
// There is presently no default device interface designated for this interface class.
//
#define SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE _HRESULT_TYPEDEF_(0x800F021AL)

//
// MessageId: SPAPI_E_DEVICE_INTERFACE_ACTIVE
//
// MessageText:
//
// The operation cannot be performed because the device interface is currently active.
//
#define SPAPI_E_DEVICE_INTERFACE_ACTIVE _HRESULT_TYPEDEF_(0x800F021BL)

//
// MessageId: SPAPI_E_DEVICE_INTERFACE_REMOVED
//
// MessageText:
//
// The operation cannot be performed because the device interface has been removed from the system.
//
#define SPAPI_E_DEVICE_INTERFACE_REMOVED _HRESULT_TYPEDEF_(0x800F021CL)

//
// MessageId: SPAPI_E_BAD_INTERFACE_INSTALLSECT
//
// MessageText:
//
// An interface installation section in this INF is invalid.
//
#define SPAPI_E_BAD_INTERFACE_INSTALLSECT _HRESULT_TYPEDEF_(0x800F021DL)

//
// MessageId: SPAPI_E_NO_SUCH_INTERFACE_CLASS
//
// MessageText:
//
// This interface class does not exist in the system.
//
#define SPAPI_E_NO_SUCH_INTERFACE_CLASS _HRESULT_TYPEDEF_(0x800F021EL)

//
// MessageId: SPAPI_E_INVALID_REFERENCE_STRING
//
// MessageText:
//
// The reference string supplied for this interface device is invalid.
//
#define SPAPI_E_INVALID_REFERENCE_STRING _HRESULT_TYPEDEF_(0x800F021FL)

//
// MessageId: SPAPI_E_INVALID_MACHINENAME
//
// MessageText:
//
// The specified machine name does not conform to UNC naming conventions.
//
#define SPAPI_E_INVALID_MACHINENAME _HRESULT_TYPEDEF_(0x800F0220L)

//
// MessageId: SPAPI_E_REMOTE_COMM_FAILURE
//
// MessageText:
//
// A general remote communication error occurred.
//
#define SPAPI_E_REMOTE_COMM_FAILURE _HRESULT_TYPEDEF_(0x800F0221L)

//
// MessageId: SPAPI_E_MACHINE_UNAVAILABLE
//
// MessageText:
//
// The machine selected for remote communication is not available at this time.
//
#define SPAPI_E_MACHINE_UNAVAILABLE _HRESULT_TYPEDEF_(0x800F0222L)

//
// MessageId: SPAPI_E_NO_CONFIGMGR_SERVICES
//
// MessageText:
//
// The Plug and Play service is not available on the remote machine.
//
#define SPAPI_E_NO_CONFIGMGR_SERVICES _HRESULT_TYPEDEF_(0x800F0223L)

//
// MessageId: SPAPI_E_INVALID_PROPPAGE_PROVIDER
//
// MessageText:
//
// The property page provider registry entry is invalid.
//
#define SPAPI_E_INVALID_PROPPAGE_PROVIDER _HRESULT_TYPEDEF_(0x800F0224L)

//
// MessageId: SPAPI_E_NO_SUCH_DEVICE_INTERFACE
//
// MessageText:
//
// The requested device interface is not present in the system.
//
#define SPAPI_E_NO_SUCH_DEVICE_INTERFACE _HRESULT_TYPEDEF_(0x800F0225L)

//
// MessageId: SPAPI_E_DI_POSTPROCESSING_REQUIRED
//
// MessageText:
//
// The device's co-installer has additional work to perform after installation is complete.
//
#define SPAPI_E_DI_POSTPROCESSING_REQUIRED _HRESULT_TYPEDEF_(0x800F0226L)

//
// MessageId: SPAPI_E_INVALID_COINSTALLER
//
// MessageText:
//
// The device's co-installer is invalid.
//
#define SPAPI_E_INVALID_COINSTALLER _HRESULT_TYPEDEF_(0x800F0227L)

//
// MessageId: SPAPI_E_NO_COMPAT_DRIVERS
//
// MessageText:
//
// There are no compatible drivers for this device.
//
#define SPAPI_E_NO_COMPAT_DRIVERS _HRESULT_TYPEDEF_(0x800F0228L)

//
// MessageId: SPAPI_E_NO_DEVICE_ICON
//
// MessageText:
//
// There is no icon that represents this device or device type.
//
#define SPAPI_E_NO_DEVICE_ICON _HRESULT_TYPEDEF_(0x800F0229L)

//
// MessageId: SPAPI_E_INVALID_INF_LOGCONFIG
//
// MessageText:
//
// A logical configuration specified in this INF is invalid.
//
#define SPAPI_E_INVALID_INF_LOGCONFIG _HRESULT_TYPEDEF_(0x800F022AL)

//
// MessageId: SPAPI_E_DI_DONT_INSTALL
//
// MessageText:
//
// The class installer has denied the request to install or upgrade this device.
//
#define SPAPI_E_DI_DONT_INSTALL _HRESULT_TYPEDEF_(0x800F022BL)

//
// MessageId: SPAPI_E_INVALID_FILTER_DRIVER
//
// MessageText:
//
// One of the filter drivers installed for this device is invalid.
//
#define SPAPI_E_INVALID_FILTER_DRIVER _HRESULT_TYPEDEF_(0x800F022CL)

//
// MessageId: SPAPI_E_NON_WINDOWS_NT_DRIVER
//
// MessageText:
//
// The driver selected for this device does not support this version of Windows.
//
#define SPAPI_E_NON_WINDOWS_NT_DRIVER _HRESULT_TYPEDEF_(0x800F022DL)

//
// MessageId: SPAPI_E_NON_WINDOWS_DRIVER
//
// MessageText:
//
// The driver selected for this device does not support Windows.
//
#define SPAPI_E_NON_WINDOWS_DRIVER _HRESULT_TYPEDEF_(0x800F022EL)

//
// MessageId: SPAPI_E_NO_CATALOG_FOR_OEM_INF
//
// MessageText:
//
// The third-party INF does not contain digital signature information.
//
#define SPAPI_E_NO_CATALOG_FOR_OEM_INF _HRESULT_TYPEDEF_(0x800F022FL)

//
// MessageId: SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE
//
// MessageText:
//
// An invalid attempt was made to use a device installation file queue for verification of digital signatures relative to other platforms.
//
#define SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE _HRESULT_TYPEDEF_(0x800F0230L)

//
// MessageId: SPAPI_E_NOT_DISABLEABLE
//
// MessageText:
//
// The device cannot be disabled.
//
#define SPAPI_E_NOT_DISABLEABLE _HRESULT_TYPEDEF_(0x800F0231L)

//
// MessageId: SPAPI_E_CANT_REMOVE_DEVINST
//
// MessageText:
//
// The device could not be dynamically removed.
//
#define SPAPI_E_CANT_REMOVE_DEVINST _HRESULT_TYPEDEF_(0x800F0232L)

//
// MessageId: SPAPI_E_INVALID_TARGET
//
// MessageText:
//
// Cannot copy to specified target.
//
#define SPAPI_E_INVALID_TARGET _HRESULT_TYPEDEF_(0x800F0233L)

//
// MessageId: SPAPI_E_DRIVER_NONNATIVE
//
// MessageText:
//
// Driver is not intended for this platform.
//
#define SPAPI_E_DRIVER_NONNATIVE _HRESULT_TYPEDEF_(0x800F0234L)

//
// MessageId: SPAPI_E_IN_WOW64
//
// MessageText:
//
// Operation not allowed in WOW64.
//
#define SPAPI_E_IN_WOW64 _HRESULT_TYPEDEF_(0x800F0235L)

//
// MessageId: SPAPI_E_SET_SYSTEM_RESTORE_POINT
//
// MessageText:
//
// The operation involving unsigned file copying was rolled back, so that a system restore point could be set.
//
#define SPAPI_E_SET_SYSTEM_RESTORE_POINT _HRESULT_TYPEDEF_(0x800F0236L)

//
// MessageId: SPAPI_E_INCORRECTLY_COPIED_INF
//
// MessageText:
//
// An INF was copied into the Windows INF directory in an improper manner.
//
#define SPAPI_E_INCORRECTLY_COPIED_INF _HRESULT_TYPEDEF_(0x800F0237L)

//
// MessageId: SPAPI_E_SCE_DISABLED
//
// MessageText:
//
// The Security Configuration Editor (SCE) APIs have been disabled on this Embedded product.
//
#define SPAPI_E_SCE_DISABLED _HRESULT_TYPEDEF_(0x800F0238L)

//
// MessageId: SPAPI_E_UNKNOWN_EXCEPTION
//
// MessageText:
//
// An unknown exception was encountered.
//
#define SPAPI_E_UNKNOWN_EXCEPTION _HRESULT_TYPEDEF_(0x800F0239L)

//
// MessageId: SPAPI_E_PNP_REGISTRY_ERROR
//
// MessageText:
//
// A problem was encountered when accessing the Plug and Play registry database.
//
#define SPAPI_E_PNP_REGISTRY_ERROR _HRESULT_TYPEDEF_(0x800F023AL)

//
// MessageId: SPAPI_E_REMOTE_REQUEST_UNSUPPORTED
//
// MessageText:
//
// The requested operation is not supported for a remote machine.
//
#define SPAPI_E_REMOTE_REQUEST_UNSUPPORTED _HRESULT_TYPEDEF_(0x800F023BL)

//
// MessageId: SPAPI_E_NOT_AN_INSTALLED_OEM_INF
//
// MessageText:
//
// The specified file is not an installed OEM INF.
//
#define SPAPI_E_NOT_AN_INSTALLED_OEM_INF _HRESULT_TYPEDEF_(0x800F023CL)

//
// MessageId: SPAPI_E_INF_IN_USE_BY_DEVICES
//
// MessageText:
//
// One or more devices are presently installed using the specified INF.
//
#define SPAPI_E_INF_IN_USE_BY_DEVICES _HRESULT_TYPEDEF_(0x800F023DL)

//
// MessageId: SPAPI_E_DI_FUNCTION_OBSOLETE
//
// MessageText:
//
// The requested device install operation is obsolete.
//
#define SPAPI_E_DI_FUNCTION_OBSOLETE _HRESULT_TYPEDEF_(0x800F023EL)

//
// MessageId: SPAPI_E_NO_AUTHENTICODE_CATALOG
//
// MessageText:
//
// A file could not be verified because it does not have an associated catalog signed via Authenticode(tm).
//
#define SPAPI_E_NO_AUTHENTICODE_CATALOG _HRESULT_TYPEDEF_(0x800F023FL)

//
// MessageId: SPAPI_E_AUTHENTICODE_DISALLOWED
//
// MessageText:
//
// Authenticode(tm) signature verification is not supported for the specified INF.
//
#define SPAPI_E_AUTHENTICODE_DISALLOWED _HRESULT_TYPEDEF_(0x800F0240L)

//
// MessageId: SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER
//
// MessageText:
//
// The INF was signed with an Authenticode(tm) catalog from a trusted publisher.
//
#define SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER _HRESULT_TYPEDEF_(0x800F0241L)

//
// MessageId: SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED
//
// MessageText:
//
// The publisher of an Authenticode(tm) signed catalog has not yet been established as trusted.
//
#define SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED _HRESULT_TYPEDEF_(0x800F0242L)

//
// MessageId: SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED
//
// MessageText:
//
// The publisher of an Authenticode(tm) signed catalog was not established as trusted.
//
#define SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED _HRESULT_TYPEDEF_(0x800F0243L)

//
// MessageId: SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH
//
// MessageText:
//
// The software was tested for compliance with Windows Logo requirements on a different version of Windows, and may not be compatible with this version.
//
#define SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH _HRESULT_TYPEDEF_(0x800F0244L)

//
// MessageId: SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE
//
// MessageText:
//
// The file may only be validated by a catalog signed via Authenticode(tm).
//
#define SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE _HRESULT_TYPEDEF_(0x800F0245L)

//
// MessageId: SPAPI_E_DEVICE_INSTALLER_NOT_READY
//
// MessageText:
//
// One of the installers for this device cannot perform the installation at this time.
//
#define SPAPI_E_DEVICE_INSTALLER_NOT_READY _HRESULT_TYPEDEF_(0x800F0246L)

//
// MessageId: SPAPI_E_DRIVER_STORE_ADD_FAILED
//
// MessageText:
//
// A problem was encountered while attempting to add the driver to the store.
//
#define SPAPI_E_DRIVER_STORE_ADD_FAILED _HRESULT_TYPEDEF_(0x800F0247L)

//
// MessageId: SPAPI_E_DEVICE_INSTALL_BLOCKED
//
// MessageText:
//
// The installation of this device is forbidden by system policy. Contact your system administrator.
//
#define SPAPI_E_DEVICE_INSTALL_BLOCKED _HRESULT_TYPEDEF_(0x800F0248L)

//
// MessageId: SPAPI_E_DRIVER_INSTALL_BLOCKED
//
// MessageText:
//
// The installation of this driver is forbidden by system policy. Contact your system administrator.
//
#define SPAPI_E_DRIVER_INSTALL_BLOCKED _HRESULT_TYPEDEF_(0x800F0249L)

//
// MessageId: SPAPI_E_WRONG_INF_TYPE
//
// MessageText:
//
// The specified INF is the wrong type for this operation.
//
#define SPAPI_E_WRONG_INF_TYPE _HRESULT_TYPEDEF_(0x800F024AL)

//
// MessageId: SPAPI_E_FILE_HASH_NOT_IN_CATALOG
//
// MessageText:
//
// The hash for the file is not present in the specified catalog file. The file is likely corrupt or the victim of tampering.
//
#define SPAPI_E_FILE_HASH_NOT_IN_CATALOG _HRESULT_TYPEDEF_(0x800F024BL)

//
// MessageId: SPAPI_E_DRIVER_STORE_DELETE_FAILED
//
// MessageText:
//
// A problem was encountered while attempting to delete the driver from the store.
//
#define SPAPI_E_DRIVER_STORE_DELETE_FAILED _HRESULT_TYPEDEF_(0x800F024CL)

//
// MessageId: SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW
//
// MessageText:
//
// An unrecoverable stack overflow was encountered.
//
#define SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW _HRESULT_TYPEDEF_(0x800F0300L)

//
// MessageId: SPAPI_E_ERROR_NOT_INSTALLED
//
// MessageText:
//
// No installed components were detected.
//
#define SPAPI_E_ERROR_NOT_INSTALLED _HRESULT_TYPEDEF_(0x800F1000L)

// *****************
// FACILITY_SCARD
// *****************
//
// =============================
// Facility SCARD Error Messages
// =============================
//
#define SCARD_S_SUCCESS NO_ERROR
//
// MessageId: SCARD_F_INTERNAL_ERROR
//
// MessageText:
//
// An internal consistency check failed.
//
#define SCARD_F_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x80100001L)

//
// MessageId: SCARD_E_CANCELLED
//
// MessageText:
//
// The action was cancelled by an SCardCancel request.
//
#define SCARD_E_CANCELLED _HRESULT_TYPEDEF_(0x80100002L)

//
// MessageId: SCARD_E_INVALID_HANDLE
//
// MessageText:
//
// The supplied handle was invalid.
//
#define SCARD_E_INVALID_HANDLE _HRESULT_TYPEDEF_(0x80100003L)

//
// MessageId: SCARD_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more of the supplied parameters could not be properly interpreted.
//
#define SCARD_E_INVALID_PARAMETER _HRESULT_TYPEDEF_(0x80100004L)

//
// MessageId: SCARD_E_INVALID_TARGET
//
// MessageText:
//
// Registry startup information is missing or invalid.
//
#define SCARD_E_INVALID_TARGET _HRESULT_TYPEDEF_(0x80100005L)

//
// MessageId: SCARD_E_NO_MEMORY
//
// MessageText:
//
// Not enough memory available to complete this command.
//
#define SCARD_E_NO_MEMORY _HRESULT_TYPEDEF_(0x80100006L)

//
// MessageId: SCARD_F_WAITED_TOO_LONG
//
// MessageText:
//
// An internal consistency timer has expired.
//
#define SCARD_F_WAITED_TOO_LONG _HRESULT_TYPEDEF_(0x80100007L)

//
// MessageId: SCARD_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The data buffer to receive returned data is too small for the returned data.
//
#define SCARD_E_INSUFFICIENT_BUFFER _HRESULT_TYPEDEF_(0x80100008L)

//
// MessageId: SCARD_E_UNKNOWN_READER
//
// MessageText:
//
// The specified reader name is not recognized.
//
#define SCARD_E_UNKNOWN_READER _HRESULT_TYPEDEF_(0x80100009L)

//
// MessageId: SCARD_E_TIMEOUT
//
// MessageText:
//
// The user-specified timeout value has expired.
//
#define SCARD_E_TIMEOUT _HRESULT_TYPEDEF_(0x8010000AL)

//
// MessageId: SCARD_E_SHARING_VIOLATION
//
// MessageText:
//
// The smart card cannot be accessed because of other connections outstanding.
//
#define SCARD_E_SHARING_VIOLATION _HRESULT_TYPEDEF_(0x8010000BL)

//
// MessageId: SCARD_E_NO_SMARTCARD
//
// MessageText:
//
// The operation requires a Smart Card, but no Smart Card is currently in the device.
//
#define SCARD_E_NO_SMARTCARD _HRESULT_TYPEDEF_(0x8010000CL)

//
// MessageId: SCARD_E_UNKNOWN_CARD
//
// MessageText:
//
// The specified smart card name is not recognized.
//
#define SCARD_E_UNKNOWN_CARD _HRESULT_TYPEDEF_(0x8010000DL)

//
// MessageId: SCARD_E_CANT_DISPOSE
//
// MessageText:
//
// The system could not dispose of the media in the requested manner.
//
#define SCARD_E_CANT_DISPOSE _HRESULT_TYPEDEF_(0x8010000EL)

//
// MessageId: SCARD_E_PROTO_MISMATCH
//
// MessageText:
//
// The requested protocols are incompatible with the protocol currently in use with the smart card.
//
#define SCARD_E_PROTO_MISMATCH _HRESULT_TYPEDEF_(0x8010000FL)

//
// MessageId: SCARD_E_NOT_READY
//
// MessageText:
//
// The reader or smart card is not ready to accept commands.
//
#define SCARD_E_NOT_READY _HRESULT_TYPEDEF_(0x80100010L)

//
// MessageId: SCARD_E_INVALID_VALUE
//
// MessageText:
//
// One or more of the supplied parameters values could not be properly interpreted.
//
#define SCARD_E_INVALID_VALUE _HRESULT_TYPEDEF_(0x80100011L)

//
// MessageId: SCARD_E_SYSTEM_CANCELLED
//
// MessageText:
//
// The action was cancelled by the system, presumably to log off or shut down.
//
#define SCARD_E_SYSTEM_CANCELLED _HRESULT_TYPEDEF_(0x80100012L)

//
// MessageId: SCARD_F_COMM_ERROR
//
// MessageText:
//
// An internal communications error has been detected.
//
#define SCARD_F_COMM_ERROR _HRESULT_TYPEDEF_(0x80100013L)

//
// MessageId: SCARD_F_UNKNOWN_ERROR
//
// MessageText:
//
// An internal error has been detected, but the source is unknown.
//
#define SCARD_F_UNKNOWN_ERROR _HRESULT_TYPEDEF_(0x80100014L)

//
// MessageId: SCARD_E_INVALID_ATR
//
// MessageText:
//
// An ATR obtained from the registry is not a valid ATR string.
//
#define SCARD_E_INVALID_ATR _HRESULT_TYPEDEF_(0x80100015L)

//
// MessageId: SCARD_E_NOT_TRANSACTED
//
// MessageText:
//
// An attempt was made to end a non-existent transaction.
//
#define SCARD_E_NOT_TRANSACTED _HRESULT_TYPEDEF_(0x80100016L)

//
// MessageId: SCARD_E_READER_UNAVAILABLE
//
// MessageText:
//
// The specified reader is not currently available for use.
//
#define SCARD_E_READER_UNAVAILABLE _HRESULT_TYPEDEF_(0x80100017L)

//
// MessageId: SCARD_P_SHUTDOWN
//
// MessageText:
//
// The operation has been aborted to allow the server application to exit.
//
#define SCARD_P_SHUTDOWN _HRESULT_TYPEDEF_(0x80100018L)

//
// MessageId: SCARD_E_PCI_TOO_SMALL
//
// MessageText:
//
// The PCI Receive buffer was too small.
//
#define SCARD_E_PCI_TOO_SMALL _HRESULT_TYPEDEF_(0x80100019L)

//
// MessageId: SCARD_E_READER_UNSUPPORTED
//
// MessageText:
//
// The reader driver does not meet minimal requirements for support.
//
#define SCARD_E_READER_UNSUPPORTED _HRESULT_TYPEDEF_(0x8010001AL)

//
// MessageId: SCARD_E_DUPLICATE_READER
//
// MessageText:
//
// The reader driver did not produce a unique reader name.
//
#define SCARD_E_DUPLICATE_READER _HRESULT_TYPEDEF_(0x8010001BL)

//
// MessageId: SCARD_E_CARD_UNSUPPORTED
//
// MessageText:
//
// The smart card does not meet minimal requirements for support.
//
#define SCARD_E_CARD_UNSUPPORTED _HRESULT_TYPEDEF_(0x8010001CL)

//
// MessageId: SCARD_E_NO_SERVICE
//
// MessageText:
//
// The Smart card resource manager is not running.
//
#define SCARD_E_NO_SERVICE _HRESULT_TYPEDEF_(0x8010001DL)

//
// MessageId: SCARD_E_SERVICE_STOPPED
//
// MessageText:
//
// The Smart card resource manager has shut down.
//
#define SCARD_E_SERVICE_STOPPED _HRESULT_TYPEDEF_(0x8010001EL)

//
// MessageId: SCARD_E_UNEXPECTED
//
// MessageText:
//
// An unexpected card error has occurred.
//
#define SCARD_E_UNEXPECTED _HRESULT_TYPEDEF_(0x8010001FL)

//
// MessageId: SCARD_E_ICC_INSTALLATION
//
// MessageText:
//
// No Primary Provider can be found for the smart card.
//
#define SCARD_E_ICC_INSTALLATION _HRESULT_TYPEDEF_(0x80100020L)

//
// MessageId: SCARD_E_ICC_CREATEORDER
//
// MessageText:
//
// The requested order of object creation is not supported.
//
#define SCARD_E_ICC_CREATEORDER _HRESULT_TYPEDEF_(0x80100021L)

//
// MessageId: SCARD_E_UNSUPPORTED_FEATURE
//
// MessageText:
//
// This smart card does not support the requested feature.
//
#define SCARD_E_UNSUPPORTED_FEATURE _HRESULT_TYPEDEF_(0x80100022L)

//
// MessageId: SCARD_E_DIR_NOT_FOUND
//
// MessageText:
//
// The identified directory does not exist in the smart card.
//
#define SCARD_E_DIR_NOT_FOUND _HRESULT_TYPEDEF_(0x80100023L)

//
// MessageId: SCARD_E_FILE_NOT_FOUND
//
// MessageText:
//
// The identified file does not exist in the smart card.
//
#define SCARD_E_FILE_NOT_FOUND _HRESULT_TYPEDEF_(0x80100024L)

//
// MessageId: SCARD_E_NO_DIR
//
// MessageText:
//
// The supplied path does not represent a smart card directory.
//
#define SCARD_E_NO_DIR _HRESULT_TYPEDEF_(0x80100025L)

//
// MessageId: SCARD_E_NO_FILE
//
// MessageText:
//
// The supplied path does not represent a smart card file.
//
#define SCARD_E_NO_FILE _HRESULT_TYPEDEF_(0x80100026L)

//
// MessageId: SCARD_E_NO_ACCESS
//
// MessageText:
//
// Access is denied to this file.
//
#define SCARD_E_NO_ACCESS _HRESULT_TYPEDEF_(0x80100027L)

//
// MessageId: SCARD_E_WRITE_TOO_MANY
//
// MessageText:
//
// The smartcard does not have enough memory to store the information.
//
#define SCARD_E_WRITE_TOO_MANY _HRESULT_TYPEDEF_(0x80100028L)

//
// MessageId: SCARD_E_BAD_SEEK
//
// MessageText:
//
// There was an error trying to set the smart card file object pointer.
//
#define SCARD_E_BAD_SEEK _HRESULT_TYPEDEF_(0x80100029L)

//
// MessageId: SCARD_E_INVALID_CHV
//
// MessageText:
//
// The supplied PIN is incorrect.
//
#define SCARD_E_INVALID_CHV _HRESULT_TYPEDEF_(0x8010002AL)

//
// MessageId: SCARD_E_UNKNOWN_RES_MNG
//
// MessageText:
//
// An unrecognized error code was returned from a layered component.
//
#define SCARD_E_UNKNOWN_RES_MNG _HRESULT_TYPEDEF_(0x8010002BL)

//
// MessageId: SCARD_E_NO_SUCH_CERTIFICATE
//
// MessageText:
//
// The requested certificate does not exist.
//
#define SCARD_E_NO_SUCH_CERTIFICATE _HRESULT_TYPEDEF_(0x8010002CL)

//
// MessageId: SCARD_E_CERTIFICATE_UNAVAILABLE
//
// MessageText:
//
// The requested certificate could not be obtained.
//
#define SCARD_E_CERTIFICATE_UNAVAILABLE _HRESULT_TYPEDEF_(0x8010002DL)

//
// MessageId: SCARD_E_NO_READERS_AVAILABLE
//
// MessageText:
//
// Cannot find a smart card reader.
//
#define SCARD_E_NO_READERS_AVAILABLE _HRESULT_TYPEDEF_(0x8010002EL)

//
// MessageId: SCARD_E_COMM_DATA_LOST
//
// MessageText:
//
// A communications error with the smart card has been detected. Retry the operation.
//
#define SCARD_E_COMM_DATA_LOST _HRESULT_TYPEDEF_(0x8010002FL)

//
// MessageId: SCARD_E_NO_KEY_CONTAINER
//
// MessageText:
//
// The requested key container does not exist on the smart card.
//
#define SCARD_E_NO_KEY_CONTAINER _HRESULT_TYPEDEF_(0x80100030L)

//
// MessageId: SCARD_E_SERVER_TOO_BUSY
//
// MessageText:
//
// The Smart card resource manager is too busy to complete this operation.
//
#define SCARD_E_SERVER_TOO_BUSY _HRESULT_TYPEDEF_(0x80100031L)

//
// MessageId: SCARD_E_PIN_CACHE_EXPIRED
//
// MessageText:
//
// The smart card PIN cache has expired.
//
#define SCARD_E_PIN_CACHE_EXPIRED _HRESULT_TYPEDEF_(0x80100032L)

//
// MessageId: SCARD_E_NO_PIN_CACHE
//
// MessageText:
//
// The smart card PIN cannot be cached.
//
#define SCARD_E_NO_PIN_CACHE _HRESULT_TYPEDEF_(0x80100033L)

//
// MessageId: SCARD_E_READ_ONLY_CARD
//
// MessageText:
//
// The smart card is read only and cannot be written to.
//
#define SCARD_E_READ_ONLY_CARD _HRESULT_TYPEDEF_(0x80100034L)

//
// These are warning codes.
//
//
// MessageId: SCARD_W_UNSUPPORTED_CARD
//
// MessageText:
//
// The reader cannot communicate with the smart card, due to ATR configuration conflicts.
//
#define SCARD_W_UNSUPPORTED_CARD _HRESULT_TYPEDEF_(0x80100065L)

//
// MessageId: SCARD_W_UNRESPONSIVE_CARD
//
// MessageText:
//
// The smart card is not responding to a reset.
//
#define SCARD_W_UNRESPONSIVE_CARD _HRESULT_TYPEDEF_(0x80100066L)

//
// MessageId: SCARD_W_UNPOWERED_CARD
//
// MessageText:
//
// Power has been removed from the smart card, so that further communication is not possible.
//
#define SCARD_W_UNPOWERED_CARD _HRESULT_TYPEDEF_(0x80100067L)

//
// MessageId: SCARD_W_RESET_CARD
//
// MessageText:
//
// The smart card has been reset, so any shared state information is invalid.
//
#define SCARD_W_RESET_CARD _HRESULT_TYPEDEF_(0x80100068L)

//
// MessageId: SCARD_W_REMOVED_CARD
//
// MessageText:
//
// The smart card has been removed, so that further communication is not possible.
//
#define SCARD_W_REMOVED_CARD _HRESULT_TYPEDEF_(0x80100069L)

//
// MessageId: SCARD_W_SECURITY_VIOLATION
//
// MessageText:
//
// Access was denied because of a security violation.
//
#define SCARD_W_SECURITY_VIOLATION _HRESULT_TYPEDEF_(0x8010006AL)

//
// MessageId: SCARD_W_WRONG_CHV
//
// MessageText:
//
// The card cannot be accessed because the wrong PIN was presented.
//
#define SCARD_W_WRONG_CHV _HRESULT_TYPEDEF_(0x8010006BL)

//
// MessageId: SCARD_W_CHV_BLOCKED
//
// MessageText:
//
// The card cannot be accessed because the maximum number of PIN entry attempts has been reached.
//
#define SCARD_W_CHV_BLOCKED _HRESULT_TYPEDEF_(0x8010006CL)

//
// MessageId: SCARD_W_EOF
//
// MessageText:
//
// The end of the smart card file has been reached.
//
#define SCARD_W_EOF _HRESULT_TYPEDEF_(0x8010006DL)

//
// MessageId: SCARD_W_CANCELLED_BY_USER
//
// MessageText:
//
// The action was cancelled by the user.
//
#define SCARD_W_CANCELLED_BY_USER _HRESULT_TYPEDEF_(0x8010006EL)

//
// MessageId: SCARD_W_CARD_NOT_AUTHENTICATED
//
// MessageText:
//
// No PIN was presented to the smart card.
//
#define SCARD_W_CARD_NOT_AUTHENTICATED _HRESULT_TYPEDEF_(0x8010006FL)

//
// MessageId: SCARD_W_CACHE_ITEM_NOT_FOUND
//
// MessageText:
//
// The requested item could not be found in the cache.
//
#define SCARD_W_CACHE_ITEM_NOT_FOUND _HRESULT_TYPEDEF_(0x80100070L)

//
// MessageId: SCARD_W_CACHE_ITEM_STALE
//
// MessageText:
//
// The requested cache item is too old and was deleted from the cache.
//
#define SCARD_W_CACHE_ITEM_STALE _HRESULT_TYPEDEF_(0x80100071L)

//
// MessageId: SCARD_W_CACHE_ITEM_TOO_BIG
//
// MessageText:
//
// The new cache item exceeds the maximum per-item size defined for the cache.
//
#define SCARD_W_CACHE_ITEM_TOO_BIG _HRESULT_TYPEDEF_(0x80100072L)

// *****************
// FACILITY_COMPLUS
// *****************
//
// ===============================
// Facility COMPLUS Error Messages
// ===============================
//
//
// The following are the subranges  within the COMPLUS facility
// 0x400 - 0x4ff               COMADMIN_E_CAT
// 0x600 - 0x6ff               COMQC errors
// 0x700 - 0x7ff               MSDTC errors
// 0x800 - 0x8ff               Other COMADMIN errors
//
// COMPLUS Admin errors
//
//
// MessageId: COMADMIN_E_OBJECTERRORS
//
// MessageText:
//
// Errors occurred accessing one or more objects - the ErrorInfo collection may have more detail
//
#define COMADMIN_E_OBJECTERRORS _HRESULT_TYPEDEF_(0x80110401L)

//
// MessageId: COMADMIN_E_OBJECTINVALID
//
// MessageText:
//
// One or more of the object's properties are missing or invalid
//
#define COMADMIN_E_OBJECTINVALID _HRESULT_TYPEDEF_(0x80110402L)

//
// MessageId: COMADMIN_E_KEYMISSING
//
// MessageText:
//
// The object was not found in the catalog
//
#define COMADMIN_E_KEYMISSING _HRESULT_TYPEDEF_(0x80110403L)

//
// MessageId: COMADMIN_E_ALREADYINSTALLED
//
// MessageText:
//
// The object is already registered
//
#define COMADMIN_E_ALREADYINSTALLED _HRESULT_TYPEDEF_(0x80110404L)

//
// MessageId: COMADMIN_E_APP_FILE_WRITEFAIL
//
// MessageText:
//
// Error occurred writing to the application file
//
#define COMADMIN_E_APP_FILE_WRITEFAIL _HRESULT_TYPEDEF_(0x80110407L)

//
// MessageId: COMADMIN_E_APP_FILE_READFAIL
//
// MessageText:
//
// Error occurred reading the application file
//
#define COMADMIN_E_APP_FILE_READFAIL _HRESULT_TYPEDEF_(0x80110408L)

//
// MessageId: COMADMIN_E_APP_FILE_VERSION
//
// MessageText:
//
// Invalid version number in application file
//
#define COMADMIN_E_APP_FILE_VERSION _HRESULT_TYPEDEF_(0x80110409L)

//
// MessageId: COMADMIN_E_BADPATH
//
// MessageText:
//
// The file path is invalid
//
#define COMADMIN_E_BADPATH _HRESULT_TYPEDEF_(0x8011040AL)

//
// MessageId: COMADMIN_E_APPLICATIONEXISTS
//
// MessageText:
//
// The application is already installed
//
#define COMADMIN_E_APPLICATIONEXISTS _HRESULT_TYPEDEF_(0x8011040BL)

//
// MessageId: COMADMIN_E_ROLEEXISTS
//
// MessageText:
//
// The role already exists
//
#define COMADMIN_E_ROLEEXISTS _HRESULT_TYPEDEF_(0x8011040CL)

//
// MessageId: COMADMIN_E_CANTCOPYFILE
//
// MessageText:
//
// An error occurred copying the file
//
#define COMADMIN_E_CANTCOPYFILE _HRESULT_TYPEDEF_(0x8011040DL)

//
// MessageId: COMADMIN_E_NOUSER
//
// MessageText:
//
// One or more users are not valid
//
#define COMADMIN_E_NOUSER _HRESULT_TYPEDEF_(0x8011040FL)

//
// MessageId: COMADMIN_E_INVALIDUSERIDS
//
// MessageText:
//
// One or more users in the application file are not valid
//
#define COMADMIN_E_INVALIDUSERIDS _HRESULT_TYPEDEF_(0x80110410L)

//
// MessageId: COMADMIN_E_NOREGISTRYCLSID
//
// MessageText:
//
// The component's CLSID is missing or corrupt
//
#define COMADMIN_E_NOREGISTRYCLSID _HRESULT_TYPEDEF_(0x80110411L)

//
// MessageId: COMADMIN_E_BADREGISTRYPROGID
//
// MessageText:
//
// The component's progID is missing or corrupt
//
#define COMADMIN_E_BADREGISTRYPROGID _HRESULT_TYPEDEF_(0x80110412L)

//
// MessageId: COMADMIN_E_AUTHENTICATIONLEVEL
//
// MessageText:
//
// Unable to set required authentication level for update request
//
#define COMADMIN_E_AUTHENTICATIONLEVEL _HRESULT_TYPEDEF_(0x80110413L)

//
// MessageId: COMADMIN_E_USERPASSWDNOTVALID
//
// MessageText:
//
// The identity or password set on the application is not valid
//
#define COMADMIN_E_USERPASSWDNOTVALID _HRESULT_TYPEDEF_(0x80110414L)

//
// MessageId: COMADMIN_E_CLSIDORIIDMISMATCH
//
// MessageText:
//
// Application file CLSIDs or IIDs do not match corresponding DLLs
//
#define COMADMIN_E_CLSIDORIIDMISMATCH _HRESULT_TYPEDEF_(0x80110418L)

//
// MessageId: COMADMIN_E_REMOTEINTERFACE
//
// MessageText:
//
// Interface information is either missing or changed
//
#define COMADMIN_E_REMOTEINTERFACE _HRESULT_TYPEDEF_(0x80110419L)

//
// MessageId: COMADMIN_E_DLLREGISTERSERVER
//
// MessageText:
//
// DllRegisterServer failed on component install
//
#define COMADMIN_E_DLLREGISTERSERVER _HRESULT_TYPEDEF_(0x8011041AL)

//
// MessageId: COMADMIN_E_NOSERVERSHARE
//
// MessageText:
//
// No server file share available
//
#define COMADMIN_E_NOSERVERSHARE _HRESULT_TYPEDEF_(0x8011041BL)

//
// MessageId: COMADMIN_E_DLLLOADFAILED
//
// MessageText:
//
// DLL could not be loaded
//
#define COMADMIN_E_DLLLOADFAILED _HRESULT_TYPEDEF_(0x8011041DL)

//
// MessageId: COMADMIN_E_BADREGISTRYLIBID
//
// MessageText:
//
// The registered TypeLib ID is not valid
//
#define COMADMIN_E_BADREGISTRYLIBID _HRESULT_TYPEDEF_(0x8011041EL)

//
// MessageId: COMADMIN_E_APPDIRNOTFOUND
//
// MessageText:
//
// Application install directory not found
//
#define COMADMIN_E_APPDIRNOTFOUND _HRESULT_TYPEDEF_(0x8011041FL)

//
// MessageId: COMADMIN_E_REGISTRARFAILED
//
// MessageText:
//
// Errors occurred while in the component registrar
//
#define COMADMIN_E_REGISTRARFAILED _HRESULT_TYPEDEF_(0x80110423L)

//
// MessageId: COMADMIN_E_COMPFILE_DOESNOTEXIST
//
// MessageText:
//
// The file does not exist
//
#define COMADMIN_E_COMPFILE_DOESNOTEXIST _HRESULT_TYPEDEF_(0x80110424L)

//
// MessageId: COMADMIN_E_COMPFILE_LOADDLLFAIL
//
// MessageText:
//
// The DLL could not be loaded
//
#define COMADMIN_E_COMPFILE_LOADDLLFAIL _HRESULT_TYPEDEF_(0x80110425L)

//
// MessageId: COMADMIN_E_COMPFILE_GETCLASSOBJ
//
// MessageText:
//
// GetClassObject failed in the DLL
//
#define COMADMIN_E_COMPFILE_GETCLASSOBJ _HRESULT_TYPEDEF_(0x80110426L)

//
// MessageId: COMADMIN_E_COMPFILE_CLASSNOTAVAIL
//
// MessageText:
//
// The DLL does not support the components listed in the TypeLib
//
#define COMADMIN_E_COMPFILE_CLASSNOTAVAIL _HRESULT_TYPEDEF_(0x80110427L)

//
// MessageId: COMADMIN_E_COMPFILE_BADTLB
//
// MessageText:
//
// The TypeLib could not be loaded
//
#define COMADMIN_E_COMPFILE_BADTLB _HRESULT_TYPEDEF_(0x80110428L)

//
// MessageId: COMADMIN_E_COMPFILE_NOTINSTALLABLE
//
// MessageText:
//
// The file does not contain components or component information
//
#define COMADMIN_E_COMPFILE_NOTINSTALLABLE _HRESULT_TYPEDEF_(0x80110429L)

//
// MessageId: COMADMIN_E_NOTCHANGEABLE
//
// MessageText:
//
// Changes to this object and its sub-objects have been disabled
//
#define COMADMIN_E_NOTCHANGEABLE _HRESULT_TYPEDEF_(0x8011042AL)

//
// MessageId: COMADMIN_E_NOTDELETEABLE
//
// MessageText:
//
// The delete function has been disabled for this object
//
#define COMADMIN_E_NOTDELETEABLE _HRESULT_TYPEDEF_(0x8011042BL)

//
// MessageId: COMADMIN_E_SESSION
//
// MessageText:
//
// The server catalog version is not supported
//
#define COMADMIN_E_SESSION _HRESULT_TYPEDEF_(0x8011042CL)

//
// MessageId: COMADMIN_E_COMP_MOVE_LOCKED
//
// MessageText:
//
// The component move was disallowed, because the source or destination application is either a system application or currently locked against changes
//
#define COMADMIN_E_COMP_MOVE_LOCKED _HRESULT_TYPEDEF_(0x8011042DL)

//
// MessageId: COMADMIN_E_COMP_MOVE_BAD_DEST
//
// MessageText:
//
// The component move failed because the destination application no longer exists
//
#define COMADMIN_E_COMP_MOVE_BAD_DEST _HRESULT_TYPEDEF_(0x8011042EL)

//
// MessageId: COMADMIN_E_REGISTERTLB
//
// MessageText:
//
// The system was unable to register the TypeLib
//
#define COMADMIN_E_REGISTERTLB _HRESULT_TYPEDEF_(0x80110430L)

//
// MessageId: COMADMIN_E_SYSTEMAPP
//
// MessageText:
//
// This operation cannot be performed on the system application
//
#define COMADMIN_E_SYSTEMAPP _HRESULT_TYPEDEF_(0x80110433L)

//
// MessageId: COMADMIN_E_COMPFILE_NOREGISTRAR
//
// MessageText:
//
// The component registrar referenced in this file is not available
//
#define COMADMIN_E_COMPFILE_NOREGISTRAR _HRESULT_TYPEDEF_(0x80110434L)

//
// MessageId: COMADMIN_E_COREQCOMPINSTALLED
//
// MessageText:
//
// A component in the same DLL is already installed
//
#define COMADMIN_E_COREQCOMPINSTALLED _HRESULT_TYPEDEF_(0x80110435L)

//
// MessageId: COMADMIN_E_SERVICENOTINSTALLED
//
// MessageText:
//
// The service is not installed
//
#define COMADMIN_E_SERVICENOTINSTALLED _HRESULT_TYPEDEF_(0x80110436L)

//
// MessageId: COMADMIN_E_PROPERTYSAVEFAILED
//
// MessageText:
//
// One or more property settings are either invalid or in conflict with each other
//
#define COMADMIN_E_PROPERTYSAVEFAILED _HRESULT_TYPEDEF_(0x80110437L)

//
// MessageId: COMADMIN_E_OBJECTEXISTS
//
// MessageText:
//
// The object you are attempting to add or rename already exists
//
#define COMADMIN_E_OBJECTEXISTS _HRESULT_TYPEDEF_(0x80110438L)

//
// MessageId: COMADMIN_E_COMPONENTEXISTS
//
// MessageText:
//
// The component already exists
//
#define COMADMIN_E_COMPONENTEXISTS _HRESULT_TYPEDEF_(0x80110439L)

//
// MessageId: COMADMIN_E_REGFILE_CORRUPT
//
// MessageText:
//
// The registration file is corrupt
//
#define COMADMIN_E_REGFILE_CORRUPT _HRESULT_TYPEDEF_(0x8011043BL)

//
// MessageId: COMADMIN_E_PROPERTY_OVERFLOW
//
// MessageText:
//
// The property value is too large
//
#define COMADMIN_E_PROPERTY_OVERFLOW _HRESULT_TYPEDEF_(0x8011043CL)

//
// MessageId: COMADMIN_E_NOTINREGISTRY
//
// MessageText:
//
// Object was not found in registry
//
#define COMADMIN_E_NOTINREGISTRY _HRESULT_TYPEDEF_(0x8011043EL)

//
// MessageId: COMADMIN_E_OBJECTNOTPOOLABLE
//
// MessageText:
//
// This object is not poolable
//
#define COMADMIN_E_OBJECTNOTPOOLABLE _HRESULT_TYPEDEF_(0x8011043FL)

//
// MessageId: COMADMIN_E_APPLID_MATCHES_CLSID
//
// MessageText:
//
// A CLSID with the same GUID as the new application ID is already installed on this machine
//
#define COMADMIN_E_APPLID_MATCHES_CLSID _HRESULT_TYPEDEF_(0x80110446L)

//
// MessageId: COMADMIN_E_ROLE_DOES_NOT_EXIST
//
// MessageText:
//
// A role assigned to a component, interface, or method did not exist in the application
//
#define COMADMIN_E_ROLE_DOES_NOT_EXIST _HRESULT_TYPEDEF_(0x80110447L)

//
// MessageId: COMADMIN_E_START_APP_NEEDS_COMPONENTS
//
// MessageText:
//
// You must have components in an application in order to start the application
//
#define COMADMIN_E_START_APP_NEEDS_COMPONENTS _HRESULT_TYPEDEF_(0x80110448L)

//
// MessageId: COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM
//
// MessageText:
//
// This operation is not enabled on this platform
//
#define COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM _HRESULT_TYPEDEF_(0x80110449L)

//
// MessageId: COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY
//
// MessageText:
//
// Application Proxy is not exportable
//
#define COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY _HRESULT_TYPEDEF_(0x8011044AL)

//
// MessageId: COMADMIN_E_CAN_NOT_START_APP
//
// MessageText:
//
// Failed to start application because it is either a library application or an application proxy
//
#define COMADMIN_E_CAN_NOT_START_APP _HRESULT_TYPEDEF_(0x8011044BL)

//
// MessageId: COMADMIN_E_CAN_NOT_EXPORT_SYS_APP
//
// MessageText:
//
// System application is not exportable
//
#define COMADMIN_E_CAN_NOT_EXPORT_SYS_APP _HRESULT_TYPEDEF_(0x8011044CL)

//
// MessageId: COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT
//
// MessageText:
//
// Cannot subscribe to this component (the component may have been imported)
//
#define COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT _HRESULT_TYPEDEF_(0x8011044DL)

//
// MessageId: COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER
//
// MessageText:
//
// An event class cannot also be a subscriber component
//
#define COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER _HRESULT_TYPEDEF_(0x8011044EL)

//
// MessageId: COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE
//
// MessageText:
//
// Library applications and application proxies are incompatible
//
#define COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE _HRESULT_TYPEDEF_(0x8011044FL)

//
// MessageId: COMADMIN_E_BASE_PARTITION_ONLY
//
// MessageText:
//
// This function is valid for the base partition only
//
#define COMADMIN_E_BASE_PARTITION_ONLY _HRESULT_TYPEDEF_(0x80110450L)

//
// MessageId: COMADMIN_E_START_APP_DISABLED
//
// MessageText:
//
// You cannot start an application that has been disabled
//
#define COMADMIN_E_START_APP_DISABLED _HRESULT_TYPEDEF_(0x80110451L)

//
// MessageId: COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME
//
// MessageText:
//
// The specified partition name is already in use on this computer
//
#define COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME _HRESULT_TYPEDEF_(0x80110457L)

//
// MessageId: COMADMIN_E_CAT_INVALID_PARTITION_NAME
//
// MessageText:
//
// The specified partition name is invalid. Check that the name contains at least one visible character
//
#define COMADMIN_E_CAT_INVALID_PARTITION_NAME _HRESULT_TYPEDEF_(0x80110458L)

//
// MessageId: COMADMIN_E_CAT_PARTITION_IN_USE
//
// MessageText:
//
// The partition cannot be deleted because it is the default partition for one or more users
//
#define COMADMIN_E_CAT_PARTITION_IN_USE _HRESULT_TYPEDEF_(0x80110459L)

//
// MessageId: COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES
//
// MessageText:
//
// The partition cannot be exported, because one or more components in the partition have the same file name
//
#define COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES _HRESULT_TYPEDEF_(0x8011045AL)

//
// MessageId: COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED
//
// MessageText:
//
// Applications that contain one or more imported components cannot be installed into a non-base partition
//
#define COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED _HRESULT_TYPEDEF_(0x8011045BL)

//
// MessageId: COMADMIN_E_AMBIGUOUS_APPLICATION_NAME
//
// MessageText:
//
// The application name is not unique and cannot be resolved to an application id
//
#define COMADMIN_E_AMBIGUOUS_APPLICATION_NAME _HRESULT_TYPEDEF_(0x8011045CL)

//
// MessageId: COMADMIN_E_AMBIGUOUS_PARTITION_NAME
//
// MessageText:
//
// The partition name is not unique and cannot be resolved to a partition id
//
#define COMADMIN_E_AMBIGUOUS_PARTITION_NAME _HRESULT_TYPEDEF_(0x8011045DL)

//
// MessageId: COMADMIN_E_REGDB_NOTINITIALIZED
//
// MessageText:
//
// The COM+ registry database has not been initialized
//
#define COMADMIN_E_REGDB_NOTINITIALIZED _HRESULT_TYPEDEF_(0x80110472L)

//
// MessageId: COMADMIN_E_REGDB_NOTOPEN
//
// MessageText:
//
// The COM+ registry database is not open
//
#define COMADMIN_E_REGDB_NOTOPEN _HRESULT_TYPEDEF_(0x80110473L)

//
// MessageId: COMADMIN_E_REGDB_SYSTEMERR
//
// MessageText:
//
// The COM+ registry database detected a system error
//
#define COMADMIN_E_REGDB_SYSTEMERR _HRESULT_TYPEDEF_(0x80110474L)

//
// MessageId: COMADMIN_E_REGDB_ALREADYRUNNING
//
// MessageText:
//
// The COM+ registry database is already running
//
#define COMADMIN_E_REGDB_ALREADYRUNNING _HRESULT_TYPEDEF_(0x80110475L)

//
// MessageId: COMADMIN_E_MIG_VERSIONNOTSUPPORTED
//
// MessageText:
//
// This version of the COM+ registry database cannot be migrated
//
#define COMADMIN_E_MIG_VERSIONNOTSUPPORTED _HRESULT_TYPEDEF_(0x80110480L)

//
// MessageId: COMADMIN_E_MIG_SCHEMANOTFOUND
//
// MessageText:
//
// The schema version to be migrated could not be found in the COM+ registry database
//
#define COMADMIN_E_MIG_SCHEMANOTFOUND _HRESULT_TYPEDEF_(0x80110481L)

//
// MessageId: COMADMIN_E_CAT_BITNESSMISMATCH
//
// MessageText:
//
// There was a type mismatch between binaries
//
#define COMADMIN_E_CAT_BITNESSMISMATCH _HRESULT_TYPEDEF_(0x80110482L)

//
// MessageId: COMADMIN_E_CAT_UNACCEPTABLEBITNESS
//
// MessageText:
//
// A binary of unknown or invalid type was provided
//
#define COMADMIN_E_CAT_UNACCEPTABLEBITNESS _HRESULT_TYPEDEF_(0x80110483L)

//
// MessageId: COMADMIN_E_CAT_WRONGAPPBITNESS
//
// MessageText:
//
// There was a type mismatch between a binary and an application
//
#define COMADMIN_E_CAT_WRONGAPPBITNESS _HRESULT_TYPEDEF_(0x80110484L)

//
// MessageId: COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED
//
// MessageText:
//
// The application cannot be paused or resumed
//
#define COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80110485L)

//
// MessageId: COMADMIN_E_CAT_SERVERFAULT
//
// MessageText:
//
// The COM+ Catalog Server threw an exception during execution
//
#define COMADMIN_E_CAT_SERVERFAULT _HRESULT_TYPEDEF_(0x80110486L)

//
// COMPLUS Queued component errors
//
//
// MessageId: COMQC_E_APPLICATION_NOT_QUEUED
//
// MessageText:
//
// Only COM+ Applications marked "queued" can be invoked using the "queue" moniker
//
#define COMQC_E_APPLICATION_NOT_QUEUED _HRESULT_TYPEDEF_(0x80110600L)

//
// MessageId: COMQC_E_NO_QUEUEABLE_INTERFACES
//
// MessageText:
//
// At least one interface must be marked "queued" in order to create a queued component instance with the "queue" moniker
//
#define COMQC_E_NO_QUEUEABLE_INTERFACES _HRESULT_TYPEDEF_(0x80110601L)

//
// MessageId: COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE
//
// MessageText:
//
// MSMQ is required for the requested operation and is not installed
//
#define COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE _HRESULT_TYPEDEF_(0x80110602L)

//
// MessageId: COMQC_E_NO_IPERSISTSTREAM
//
// MessageText:
//
// Unable to marshal an interface that does not support IPersistStream
//
#define COMQC_E_NO_IPERSISTSTREAM _HRESULT_TYPEDEF_(0x80110603L)

//
// MessageId: COMQC_E_BAD_MESSAGE
//
// MessageText:
//
// The message is improperly formatted or was damaged in transit
//
#define COMQC_E_BAD_MESSAGE _HRESULT_TYPEDEF_(0x80110604L)

//
// MessageId: COMQC_E_UNAUTHENTICATED
//
// MessageText:
//
// An unauthenticated message was received by an application that accepts only authenticated messages
//
#define COMQC_E_UNAUTHENTICATED _HRESULT_TYPEDEF_(0x80110605L)

//
// MessageId: COMQC_E_UNTRUSTED_ENQUEUER
//
// MessageText:
//
// The message was requeued or moved by a user not in the "QC Trusted User" role
//
#define COMQC_E_UNTRUSTED_ENQUEUER _HRESULT_TYPEDEF_(0x80110606L)

//
// The range 0x700-0x7ff is reserved for MSDTC errors.
//
//
// MessageId: MSDTC_E_DUPLICATE_RESOURCE
//
// MessageText:
//
// Cannot create a duplicate resource of type Distributed Transaction Coordinator
//
#define MSDTC_E_DUPLICATE_RESOURCE _HRESULT_TYPEDEF_(0x80110701L)

//
// More COMADMIN errors from 0x8**
//
//
// MessageId: COMADMIN_E_OBJECT_PARENT_MISSING
//
// MessageText:
//
// One of the objects being inserted or updated does not belong to a valid parent collection
//
#define COMADMIN_E_OBJECT_PARENT_MISSING _HRESULT_TYPEDEF_(0x80110808L)

//
// MessageId: COMADMIN_E_OBJECT_DOES_NOT_EXIST
//
// MessageText:
//
// One of the specified objects cannot be found
//
#define COMADMIN_E_OBJECT_DOES_NOT_EXIST _HRESULT_TYPEDEF_(0x80110809L)

//
// MessageId: COMADMIN_E_APP_NOT_RUNNING
//
// MessageText:
//
// The specified application is not currently running
//
#define COMADMIN_E_APP_NOT_RUNNING _HRESULT_TYPEDEF_(0x8011080AL)

//
// MessageId: COMADMIN_E_INVALID_PARTITION
//
// MessageText:
//
// The partition(s) specified are not valid.
//
#define COMADMIN_E_INVALID_PARTITION _HRESULT_TYPEDEF_(0x8011080BL)

//
// MessageId: COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE
//
// MessageText:
//
// COM+ applications that run as NT service may not be pooled or recycled
//
#define COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE _HRESULT_TYPEDEF_(0x8011080DL)

//
// MessageId: COMADMIN_E_USER_IN_SET
//
// MessageText:
//
// One or more users are already assigned to a local partition set.
//
#define COMADMIN_E_USER_IN_SET _HRESULT_TYPEDEF_(0x8011080EL)

//
// MessageId: COMADMIN_E_CANTRECYCLELIBRARYAPPS
//
// MessageText:
//
// Library applications may not be recycled.
//
#define COMADMIN_E_CANTRECYCLELIBRARYAPPS _HRESULT_TYPEDEF_(0x8011080FL)

//
// MessageId: COMADMIN_E_CANTRECYCLESERVICEAPPS
//
// MessageText:
//
// Applications running as NT services may not be recycled.
//
#define COMADMIN_E_CANTRECYCLESERVICEAPPS _HRESULT_TYPEDEF_(0x80110811L)

//
// MessageId: COMADMIN_E_PROCESSALREADYRECYCLED
//
// MessageText:
//
// The process has already been recycled.
//
#define COMADMIN_E_PROCESSALREADYRECYCLED _HRESULT_TYPEDEF_(0x80110812L)

//
// MessageId: COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED
//
// MessageText:
//
// A paused process may not be recycled.
//
#define COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED _HRESULT_TYPEDEF_(0x80110813L)

//
// MessageId: COMADMIN_E_CANTMAKEINPROCSERVICE
//
// MessageText:
//
// Library applications may not be NT services.
//
#define COMADMIN_E_CANTMAKEINPROCSERVICE _HRESULT_TYPEDEF_(0x80110814L)

//
// MessageId: COMADMIN_E_PROGIDINUSEBYCLSID
//
// MessageText:
//
// The ProgID provided to the copy operation is invalid. The ProgID is in use by another registered CLSID.
//
#define COMADMIN_E_PROGIDINUSEBYCLSID _HRESULT_TYPEDEF_(0x80110815L)

//
// MessageId: COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET
//
// MessageText:
//
// The partition specified as default is not a member of the partition set.
//
#define COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET _HRESULT_TYPEDEF_(0x80110816L)

//
// MessageId: COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED
//
// MessageText:
//
// A recycled process may not be paused.
//
#define COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED _HRESULT_TYPEDEF_(0x80110817L)

//
// MessageId: COMADMIN_E_PARTITION_ACCESSDENIED
//
// MessageText:
//
// Access to the specified partition is denied.
//
#define COMADMIN_E_PARTITION_ACCESSDENIED _HRESULT_TYPEDEF_(0x80110818L)

//
// MessageId: COMADMIN_E_PARTITION_MSI_ONLY
//
// MessageText:
//
// Only Application Files (*.MSI files) can be installed into partitions.
//
#define COMADMIN_E_PARTITION_MSI_ONLY _HRESULT_TYPEDEF_(0x80110819L)

//
// MessageId: COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT
//
// MessageText:
//
// Applications containing one or more legacy components may not be exported to 1.0 format.
//
#define COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT _HRESULT_TYPEDEF_(0x8011081AL)

//
// MessageId: COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS
//
// MessageText:
//
// Legacy components may not exist in non-base partitions.
//
#define COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS _HRESULT_TYPEDEF_(0x8011081BL)

//
// MessageId: COMADMIN_E_COMP_MOVE_SOURCE
//
// MessageText:
//
// A component cannot be moved (or copied) from the System Application, an application proxy or a non-changeable application
//
#define COMADMIN_E_COMP_MOVE_SOURCE _HRESULT_TYPEDEF_(0x8011081CL)

//
// MessageId: COMADMIN_E_COMP_MOVE_DEST
//
// MessageText:
//
// A component cannot be moved (or copied) to the System Application, an application proxy or a non-changeable application
//
#define COMADMIN_E_COMP_MOVE_DEST _HRESULT_TYPEDEF_(0x8011081DL)

//
// MessageId: COMADMIN_E_COMP_MOVE_PRIVATE
//
// MessageText:
//
// A private component cannot be moved (or copied) to a library application or to the base partition
//
#define COMADMIN_E_COMP_MOVE_PRIVATE _HRESULT_TYPEDEF_(0x8011081EL)

//
// MessageId: COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET
//
// MessageText:
//
// The Base Application Partition exists in all partition sets and cannot be removed.
//
#define COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET _HRESULT_TYPEDEF_(0x8011081FL)

//
// MessageId: COMADMIN_E_CANNOT_ALIAS_EVENTCLASS
//
// MessageText:
//
// Alas, Event Class components cannot be aliased.
//
#define COMADMIN_E_CANNOT_ALIAS_EVENTCLASS _HRESULT_TYPEDEF_(0x80110820L)

//
// MessageId: COMADMIN_E_PRIVATE_ACCESSDENIED
//
// MessageText:
//
// Access is denied because the component is private.
//
#define COMADMIN_E_PRIVATE_ACCESSDENIED _HRESULT_TYPEDEF_(0x80110821L)

//
// MessageId: COMADMIN_E_SAFERINVALID
//
// MessageText:
//
// The specified SAFER level is invalid.
//
#define COMADMIN_E_SAFERINVALID _HRESULT_TYPEDEF_(0x80110822L)

//
// MessageId: COMADMIN_E_REGISTRY_ACCESSDENIED
//
// MessageText:
//
// The specified user cannot write to the system registry
//
#define COMADMIN_E_REGISTRY_ACCESSDENIED _HRESULT_TYPEDEF_(0x80110823L)

//
// MessageId: COMADMIN_E_PARTITIONS_DISABLED
//
// MessageText:
//
// COM+ partitions are currently disabled.
//
#define COMADMIN_E_PARTITIONS_DISABLED _HRESULT_TYPEDEF_(0x80110824L)

// ***********************
// FACILITY_USERMODE_FILTER_MANAGER
// ***********************
//
// Translation macro for converting FilterManager error codes only from:
//     NTSTATUS  --> HRESULT
//
#define FILTER_HRESULT_FROM_FLT_NTSTATUS(x) (ASSERT((x & 0xfff0000) == 0x001c0000),(HRESULT) (((x) & 0x8000FFFF) | (FACILITY_USERMODE_FILTER_MANAGER << 16)))
//
// MessageId: ERROR_FLT_IO_COMPLETE
//
// MessageText:
//
// The IO was completed by a filter.
//
#define ERROR_FLT_IO_COMPLETE _HRESULT_TYPEDEF_(0x001F0001L)

//
// MessageId: ERROR_FLT_NO_HANDLER_DEFINED
//
// MessageText:
//
// A handler was not defined by the filter for this operation.
//
#define ERROR_FLT_NO_HANDLER_DEFINED _HRESULT_TYPEDEF_(0x801F0001L)

//
// MessageId: ERROR_FLT_CONTEXT_ALREADY_DEFINED
//
// MessageText:
//
// A context is already defined for this object.
//
#define ERROR_FLT_CONTEXT_ALREADY_DEFINED _HRESULT_TYPEDEF_(0x801F0002L)

//
// MessageId: ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST
//
// MessageText:
//
// Asynchronous requests are not valid for this operation.
//
#define ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST _HRESULT_TYPEDEF_(0x801F0003L)

//
// MessageId: ERROR_FLT_DISALLOW_FAST_IO
//
// MessageText:
//
// Disallow the Fast IO path for this operation.
//
#define ERROR_FLT_DISALLOW_FAST_IO _HRESULT_TYPEDEF_(0x801F0004L)

//
// MessageId: ERROR_FLT_INVALID_NAME_REQUEST
//
// MessageText:
//
// An invalid name request was made. The name requested cannot be retrieved at this time.
//
#define ERROR_FLT_INVALID_NAME_REQUEST _HRESULT_TYPEDEF_(0x801F0005L)

//
// MessageId: ERROR_FLT_NOT_SAFE_TO_POST_OPERATION
//
// MessageText:
//
// Posting this operation to a worker thread for further processing is not safe at this time because it could lead to a system deadlock.
//
#define ERROR_FLT_NOT_SAFE_TO_POST_OPERATION _HRESULT_TYPEDEF_(0x801F0006L)

//
// MessageId: ERROR_FLT_NOT_INITIALIZED
//
// MessageText:
//
// The Filter Manager was not initialized when a filter tried to register. Make sure that the Filter Manager is getting loaded as a driver.
//
#define ERROR_FLT_NOT_INITIALIZED _HRESULT_TYPEDEF_(0x801F0007L)

//
// MessageId: ERROR_FLT_FILTER_NOT_READY
//
// MessageText:
//
// The filter is not ready for attachment to volumes because it has not finished initializing (FltStartFiltering has not been called).
//
#define ERROR_FLT_FILTER_NOT_READY _HRESULT_TYPEDEF_(0x801F0008L)

//
// MessageId: ERROR_FLT_POST_OPERATION_CLEANUP
//
// MessageText:
//
// The filter must cleanup any operation specific context at this time because it is being removed from the system before the operation is completed by the lower drivers.
//
#define ERROR_FLT_POST_OPERATION_CLEANUP _HRESULT_TYPEDEF_(0x801F0009L)

//
// MessageId: ERROR_FLT_INTERNAL_ERROR
//
// MessageText:
//
// The Filter Manager had an internal error from which it cannot recover, therefore the operation has been failed. This is usually the result of a filter returning an invalid value from a pre-operation callback.
//
#define ERROR_FLT_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x801F000AL)

//
// MessageId: ERROR_FLT_DELETING_OBJECT
//
// MessageText:
//
// The object specified for this action is in the process of being deleted, therefore the action requested cannot be completed at this time.
//
#define ERROR_FLT_DELETING_OBJECT _HRESULT_TYPEDEF_(0x801F000BL)

//
// MessageId: ERROR_FLT_MUST_BE_NONPAGED_POOL
//
// MessageText:
//
// Non-paged pool must be used for this type of context.
//
#define ERROR_FLT_MUST_BE_NONPAGED_POOL _HRESULT_TYPEDEF_(0x801F000CL)

//
// MessageId: ERROR_FLT_DUPLICATE_ENTRY
//
// MessageText:
//
// A duplicate handler definition has been provided for an operation.
//
#define ERROR_FLT_DUPLICATE_ENTRY _HRESULT_TYPEDEF_(0x801F000DL)

//
// MessageId: ERROR_FLT_CBDQ_DISABLED
//
// MessageText:
//
// The callback data queue has been disabled.
//
#define ERROR_FLT_CBDQ_DISABLED _HRESULT_TYPEDEF_(0x801F000EL)

//
// MessageId: ERROR_FLT_DO_NOT_ATTACH
//
// MessageText:
//
// Do not attach the filter to the volume at this time.
//
#define ERROR_FLT_DO_NOT_ATTACH _HRESULT_TYPEDEF_(0x801F000FL)

//
// MessageId: ERROR_FLT_DO_NOT_DETACH
//
// MessageText:
//
// Do not detach the filter from the volume at this time.
//
#define ERROR_FLT_DO_NOT_DETACH _HRESULT_TYPEDEF_(0x801F0010L)

//
// MessageId: ERROR_FLT_INSTANCE_ALTITUDE_COLLISION
//
// MessageText:
//
// An instance already exists at this altitude on the volume specified.
//
#define ERROR_FLT_INSTANCE_ALTITUDE_COLLISION _HRESULT_TYPEDEF_(0x801F0011L)

//
// MessageId: ERROR_FLT_INSTANCE_NAME_COLLISION
//
// MessageText:
//
// An instance already exists with this name on the volume specified.
//
#define ERROR_FLT_INSTANCE_NAME_COLLISION _HRESULT_TYPEDEF_(0x801F0012L)

//
// MessageId: ERROR_FLT_FILTER_NOT_FOUND
//
// MessageText:
//
// The system could not find the filter specified.
//
#define ERROR_FLT_FILTER_NOT_FOUND _HRESULT_TYPEDEF_(0x801F0013L)

//
// MessageId: ERROR_FLT_VOLUME_NOT_FOUND
//
// MessageText:
//
// The system could not find the volume specified.
//
#define ERROR_FLT_VOLUME_NOT_FOUND _HRESULT_TYPEDEF_(0x801F0014L)

//
// MessageId: ERROR_FLT_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The system could not find the instance specified.
//
#define ERROR_FLT_INSTANCE_NOT_FOUND _HRESULT_TYPEDEF_(0x801F0015L)

//
// MessageId: ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND
//
// MessageText:
//
// No registered context allocation definition was found for the given request.
//
#define ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND _HRESULT_TYPEDEF_(0x801F0016L)

//
// MessageId: ERROR_FLT_INVALID_CONTEXT_REGISTRATION
//
// MessageText:
//
// An invalid parameter was specified during context registration.
//
#define ERROR_FLT_INVALID_CONTEXT_REGISTRATION _HRESULT_TYPEDEF_(0x801F0017L)

//
// MessageId: ERROR_FLT_NAME_CACHE_MISS
//
// MessageText:
//
// The name requested was not found in Filter Manager's name cache and could not be retrieved from the file system.
//
#define ERROR_FLT_NAME_CACHE_MISS _HRESULT_TYPEDEF_(0x801F0018L)

//
// MessageId: ERROR_FLT_NO_DEVICE_OBJECT
//
// MessageText:
//
// The requested device object does not exist for the given volume.
//
#define ERROR_FLT_NO_DEVICE_OBJECT _HRESULT_TYPEDEF_(0x801F0019L)

//
// MessageId: ERROR_FLT_VOLUME_ALREADY_MOUNTED
//
// MessageText:
//
// The specified volume is already mounted.
//
#define ERROR_FLT_VOLUME_ALREADY_MOUNTED _HRESULT_TYPEDEF_(0x801F001AL)

//
// MessageId: ERROR_FLT_ALREADY_ENLISTED
//
// MessageText:
//
// The specified Transaction Context is already enlisted in a transaction
//
#define ERROR_FLT_ALREADY_ENLISTED _HRESULT_TYPEDEF_(0x801F001BL)

//
// MessageId: ERROR_FLT_CONTEXT_ALREADY_LINKED
//
// MessageText:
//
// The specifiec context is already attached to another object
//
#define ERROR_FLT_CONTEXT_ALREADY_LINKED _HRESULT_TYPEDEF_(0x801F001CL)

//
// MessageId: ERROR_FLT_NO_WAITER_FOR_REPLY
//
// MessageText:
//
// No waiter is present for the filter's reply to this message.
//
#define ERROR_FLT_NO_WAITER_FOR_REPLY _HRESULT_TYPEDEF_(0x801F0020L)

//
// ===============================
// Facility Graphics Error Messages
// ===============================
//
//
// The following are the subranges within the Graphics facility
//
// 0x0000 - 0x0fff     Display Driver Loader driver & Video Port errors (displdr.sys, videoprt.sys)
// 0x1000 - 0x1fff     Monitor Class Function driver errors             (monitor.sys)
// 0x2000 - 0x2fff     Windows Graphics Kernel Subsystem errors         (dxgkrnl.sys)
// 0x3000 - 0x3fff               Desktop Window Manager errors
//   0x2000 - 0x20ff      Common errors
//   0x2100 - 0x21ff      Video Memory Manager (VidMM) subsystem errors
//   0x2200 - 0x22ff      Video GPU Scheduler (VidSch) subsystem errors
//   0x2300 - 0x23ff      Video Display Mode Management (VidDMM) subsystem errors
//
// Display Driver Loader driver & Video Port errors {0x0000..0x0fff}
//
//
// MessageId: ERROR_HUNG_DISPLAY_DRIVER_THREAD
//
// MessageText:
//
// {Display Driver Stopped Responding}
// The %hs display driver has stopped working normally. Save your work and reboot the system to restore full display functionality.
// The next time you reboot the machine a dialog will be displayed giving you a chance to report this failure to Microsoft.
//
#define ERROR_HUNG_DISPLAY_DRIVER_THREAD _HRESULT_TYPEDEF_(0x80260001L)

//
// Desktop Window Manager errors {0x3000..0x3fff}
//
//
// MessageId: DWM_E_COMPOSITIONDISABLED
//
// MessageText:
//
// {Desktop composition is disabled}
// The operation could not be completed because desktop composition is disabled.
//
#define DWM_E_COMPOSITIONDISABLED _HRESULT_TYPEDEF_(0x80263001L)

//
// MessageId: DWM_E_REMOTING_NOT_SUPPORTED
//
// MessageText:
//
// {Some desktop composition APIs are not supported while remoting}
// The operation is not supported while running in a remote session.
//
#define DWM_E_REMOTING_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80263002L)

//
// MessageId: DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE
//
// MessageText:
//
// {No DWM redirection surface is available}
// The DWM was unable to provide a redireciton surface to complete the DirectX present.
//
#define DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE _HRESULT_TYPEDEF_(0x80263003L)

//
// MessageId: DWM_E_NOT_QUEUING_PRESENTS
//
// MessageText:
//
// {DWM is not queuing presents for the specified window}
// The window specified is not currently using queued presents.
//
#define DWM_E_NOT_QUEUING_PRESENTS _HRESULT_TYPEDEF_(0x80263004L)

//
// MessageId: DWM_E_ADAPTER_NOT_FOUND
//
// MessageText:
//
// {The adapter specified by the LUID is not found}
// DWM can not find the adapter specified by the LUID.
//
#define DWM_E_ADAPTER_NOT_FOUND _HRESULT_TYPEDEF_(0x80263005L)

//
// MessageId: DWM_S_GDI_REDIRECTION_SURFACE
//
// MessageText:
//
// {GDI redirection surface was returned}
// GDI redirection surface of the top level window was returned.
//
#define DWM_S_GDI_REDIRECTION_SURFACE _HRESULT_TYPEDEF_(0x00263005L)

//
// Monitor class function driver errors {0x1000..0x1fff}
//
//
// MessageId: ERROR_MONITOR_NO_DESCRIPTOR
//
// MessageText:
//
// Monitor descriptor could not be obtained.
//
#define ERROR_MONITOR_NO_DESCRIPTOR _HRESULT_TYPEDEF_(0x00261001L)

//
// MessageId: ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT
//
// MessageText:
//
// Format of the obtained monitor descriptor is not supported by this release.
//
#define ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT _HRESULT_TYPEDEF_(0x00261002L)

//
// MessageId: ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM
//
// MessageText:
//
// Checksum of the obtained monitor descriptor is invalid.
//
#define ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM _HRESULT_TYPEDEF_(0xC0261003L)

//
// MessageId: ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid standard timing block.
//
#define ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK _HRESULT_TYPEDEF_(0xC0261004L)

//
// MessageId: ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED
//
// MessageText:
//
// WMI data block registration failed for one of the MSMonitorClass WMI subclasses.
//
#define ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED _HRESULT_TYPEDEF_(0xC0261005L)

//
// MessageId: ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's detailed serial number.
//
#define ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK _HRESULT_TYPEDEF_(0xC0261006L)

//
// MessageId: ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's user friendly name.
//
#define ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK _HRESULT_TYPEDEF_(0xC0261007L)

//
// MessageId: ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA
//
// MessageText:
//
// There is no monitor descriptor data at the specified (offset, size) region.
//
#define ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA _HRESULT_TYPEDEF_(0xC0261008L)

//
// MessageId: ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid detailed timing block.
//
#define ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK _HRESULT_TYPEDEF_(0xC0261009L)

//
// MessageId: ERROR_MONITOR_INVALID_MANUFACTURE_DATE
//
// MessageText:
//
// Monitor descriptor contains invalid manufacture date.
//
#define ERROR_MONITOR_INVALID_MANUFACTURE_DATE _HRESULT_TYPEDEF_(0xC026100AL)

//
// Windows Graphics Kernel Subsystem errors {0x2000..0x2fff}
//
// TODO: Add DXG Win32 errors here
//
// Common errors {0x2000..0x20ff}
//
//
// MessageId: ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER
//
// MessageText:
//
// Exclusive mode ownership is needed to create unmanaged primary allocation.
//
#define ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER _HRESULT_TYPEDEF_(0xC0262000L)

//
// MessageId: ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER
//
// MessageText:
//
// The driver needs more DMA buffer space in order to complete the requested operation.
//
#define ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER _HRESULT_TYPEDEF_(0xC0262001L)

//
// MessageId: ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER
//
// MessageText:
//
// Specified display adapter handle is invalid.
//
#define ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER _HRESULT_TYPEDEF_(0xC0262002L)

//
// MessageId: ERROR_GRAPHICS_ADAPTER_WAS_RESET
//
// MessageText:
//
// Specified display adapter and all of its state has been reset.
//
#define ERROR_GRAPHICS_ADAPTER_WAS_RESET _HRESULT_TYPEDEF_(0xC0262003L)

//
// MessageId: ERROR_GRAPHICS_INVALID_DRIVER_MODEL
//
// MessageText:
//
// The driver stack doesn't match the expected driver model.
//
#define ERROR_GRAPHICS_INVALID_DRIVER_MODEL _HRESULT_TYPEDEF_(0xC0262004L)

//
// MessageId: ERROR_GRAPHICS_PRESENT_MODE_CHANGED
//
// MessageText:
//
// Present happened but ended up into the changed desktop mode
//
#define ERROR_GRAPHICS_PRESENT_MODE_CHANGED _HRESULT_TYPEDEF_(0xC0262005L)

//
// MessageId: ERROR_GRAPHICS_PRESENT_OCCLUDED
//
// MessageText:
//
// Nothing to present due to desktop occlusion
//
#define ERROR_GRAPHICS_PRESENT_OCCLUDED _HRESULT_TYPEDEF_(0xC0262006L)

//
// MessageId: ERROR_GRAPHICS_PRESENT_DENIED
//
// MessageText:
//
// Not able to present due to denial of desktop access
//
#define ERROR_GRAPHICS_PRESENT_DENIED _HRESULT_TYPEDEF_(0xC0262007L)

//
// MessageId: ERROR_GRAPHICS_CANNOTCOLORCONVERT
//
// MessageText:
//
// Not able to present with color convertion
//
#define ERROR_GRAPHICS_CANNOTCOLORCONVERT _HRESULT_TYPEDEF_(0xC0262008L)

//
// MessageId: ERROR_GRAPHICS_DRIVER_MISMATCH
//
// MessageText:
//
// The kernel driver detected a version mismatch between it and the user mode driver.
//
#define ERROR_GRAPHICS_DRIVER_MISMATCH _HRESULT_TYPEDEF_(0xC0262009L)

//
// MessageId: ERROR_GRAPHICS_PARTIAL_DATA_POPULATED
//
// MessageText:
//
// Specified buffer is not big enough to contain entire requested dataset. Partial data populated up to the size of the buffer. Caller needs to provide buffer of size as specified in the partially populated buffer's content (interface specific).
//
#define ERROR_GRAPHICS_PARTIAL_DATA_POPULATED _HRESULT_TYPEDEF_(0x4026200AL)

//
// MessageId: ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED
//
// MessageText:
//
// Present redirection is disabled (desktop windowing management subsystem is off).
//
#define ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED _HRESULT_TYPEDEF_(0xC026200BL)

//
// MessageId: ERROR_GRAPHICS_PRESENT_UNOCCLUDED
//
// MessageText:
//
// Previous exclusive VidPn source owner has released its ownership
//
#define ERROR_GRAPHICS_PRESENT_UNOCCLUDED _HRESULT_TYPEDEF_(0xC026200CL)

//
// Video Memory Manager (VidMM) subsystem errors {0x2100..0x21ff}
//
//
// MessageId: ERROR_GRAPHICS_NO_VIDEO_MEMORY
//
// MessageText:
//
// Not enough video memory available to complete the operation.
//
#define ERROR_GRAPHICS_NO_VIDEO_MEMORY _HRESULT_TYPEDEF_(0xC0262100L)

//
// MessageId: ERROR_GRAPHICS_CANT_LOCK_MEMORY
//
// MessageText:
//
// Couldn't probe and lock the underlying memory of an allocation.
//
#define ERROR_GRAPHICS_CANT_LOCK_MEMORY _HRESULT_TYPEDEF_(0xC0262101L)

//
// MessageId: ERROR_GRAPHICS_ALLOCATION_BUSY
//
// MessageText:
//
// The allocation is currently busy.
//
#define ERROR_GRAPHICS_ALLOCATION_BUSY _HRESULT_TYPEDEF_(0xC0262102L)

//
// MessageId: ERROR_GRAPHICS_TOO_MANY_REFERENCES
//
// MessageText:
//
// An object being referenced has reach the maximum reference count already and can't be reference further.
//
#define ERROR_GRAPHICS_TOO_MANY_REFERENCES _HRESULT_TYPEDEF_(0xC0262103L)

//
// MessageId: ERROR_GRAPHICS_TRY_AGAIN_LATER
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again later.
//
#define ERROR_GRAPHICS_TRY_AGAIN_LATER _HRESULT_TYPEDEF_(0xC0262104L)

//
// MessageId: ERROR_GRAPHICS_TRY_AGAIN_NOW
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again immediately.
//
#define ERROR_GRAPHICS_TRY_AGAIN_NOW _HRESULT_TYPEDEF_(0xC0262105L)

//
// MessageId: ERROR_GRAPHICS_ALLOCATION_INVALID
//
// MessageText:
//
// The allocation is invalid.
//
#define ERROR_GRAPHICS_ALLOCATION_INVALID _HRESULT_TYPEDEF_(0xC0262106L)

//
// MessageId: ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE
//
// MessageText:
//
// No more unswizzling aperture are currently available.
//
#define ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE _HRESULT_TYPEDEF_(0xC0262107L)

//
// MessageId: ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED
//
// MessageText:
//
// The current allocation can't be unswizzled by an aperture.
//
#define ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED _HRESULT_TYPEDEF_(0xC0262108L)

//
// MessageId: ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION
//
// MessageText:
//
// The request failed because a pinned allocation can't be evicted.
//
#define ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION _HRESULT_TYPEDEF_(0xC0262109L)

//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE
//
// MessageText:
//
// The allocation can't be used from it's current segment location for the specified operation.
//
#define ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE _HRESULT_TYPEDEF_(0xC0262110L)

//
// MessageId: ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION
//
// MessageText:
//
// A locked allocation can't be used in the current command buffer.
//
#define ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION _HRESULT_TYPEDEF_(0xC0262111L)

//
// MessageId: ERROR_GRAPHICS_ALLOCATION_CLOSED
//
// MessageText:
//
// The allocation being referenced has been closed permanently.
//
#define ERROR_GRAPHICS_ALLOCATION_CLOSED _HRESULT_TYPEDEF_(0xC0262112L)

//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE
//
// MessageText:
//
// An invalid allocation instance is being referenced.
//
#define ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE _HRESULT_TYPEDEF_(0xC0262113L)

//
// MessageId: ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE
//
// MessageText:
//
// An invalid allocation handle is being referenced.
//
#define ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE _HRESULT_TYPEDEF_(0xC0262114L)

//
// MessageId: ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE
//
// MessageText:
//
// The allocation being referenced doesn't belong to the current device.
//
#define ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE _HRESULT_TYPEDEF_(0xC0262115L)

//
// MessageId: ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST
//
// MessageText:
//
// The specified allocation lost its content.
//
#define ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST _HRESULT_TYPEDEF_(0xC0262116L)

//
// Video GPU Scheduler (VidSch) subsystem errors {0x2200..0x22ff}
//
//
// MessageId: ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE
//
// MessageText:
//
// GPU exception is detected on the given device. The device is not able to be scheduled.
//
#define ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE _HRESULT_TYPEDEF_(0xC0262200L)

//
// Video Present Network Management (VidPNMgr) subsystem errors {0x2300..0x23ff}
//
//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY _HRESULT_TYPEDEF_(0xC0262300L)

//
// MessageId: ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by this model of the display adapter.
//
#define ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262301L)

//
// MessageId: ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by the display adapter at this time, due to current allocation of its resources.
//
#define ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262302L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN
//
// MessageText:
//
// Specified VidPN handle is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDPN _HRESULT_TYPEDEF_(0xC0262303L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE
//
// MessageText:
//
// Specified video present source is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE _HRESULT_TYPEDEF_(0xC0262304L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET
//
// MessageText:
//
// Specified video present target is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET _HRESULT_TYPEDEF_(0xC0262305L)

//
// MessageId: ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN modality is not supported (e.g. at least two of the pinned modes are not cofunctional).
//
#define ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262306L)

//
// MessageId: ERROR_GRAPHICS_MODE_NOT_PINNED
//
// MessageText:
//
// No mode is pinned on the specified VidPN source/target.
//
#define ERROR_GRAPHICS_MODE_NOT_PINNED _HRESULT_TYPEDEF_(0x00262307L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET
//
// MessageText:
//
// Specified VidPN source mode set is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET _HRESULT_TYPEDEF_(0xC0262308L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET
//
// MessageText:
//
// Specified VidPN target mode set is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET _HRESULT_TYPEDEF_(0xC0262309L)

//
// MessageId: ERROR_GRAPHICS_INVALID_FREQUENCY
//
// MessageText:
//
// Specified video signal frequency is invalid.
//
#define ERROR_GRAPHICS_INVALID_FREQUENCY _HRESULT_TYPEDEF_(0xC026230AL)

//
// MessageId: ERROR_GRAPHICS_INVALID_ACTIVE_REGION
//
// MessageText:
//
// Specified video signal active region is invalid.
//
#define ERROR_GRAPHICS_INVALID_ACTIVE_REGION _HRESULT_TYPEDEF_(0xC026230BL)

//
// MessageId: ERROR_GRAPHICS_INVALID_TOTAL_REGION
//
// MessageText:
//
// Specified video signal total region is invalid.
//
#define ERROR_GRAPHICS_INVALID_TOTAL_REGION _HRESULT_TYPEDEF_(0xC026230CL)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE
//
// MessageText:
//
// Specified video present source mode is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE _HRESULT_TYPEDEF_(0xC0262310L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE
//
// MessageText:
//
// Specified video present target mode is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE _HRESULT_TYPEDEF_(0xC0262311L)

//
// MessageId: ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET
//
// MessageText:
//
// Pinned mode must remain in the set on VidPN's cofunctional modality enumeration.
//
#define ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET _HRESULT_TYPEDEF_(0xC0262312L)

//
// MessageId: ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY
//
// MessageText:
//
// Specified video present path is already in VidPN's topology.
//
#define ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY _HRESULT_TYPEDEF_(0xC0262313L)

//
// MessageId: ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET
//
// MessageText:
//
// Specified mode is already in the mode set.
//
#define ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET _HRESULT_TYPEDEF_(0xC0262314L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET
//
// MessageText:
//
// Specified video present source set is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET _HRESULT_TYPEDEF_(0xC0262315L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET
//
// MessageText:
//
// Specified video present target set is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET _HRESULT_TYPEDEF_(0xC0262316L)

//
// MessageId: ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present source is already in the video present source set.
//
#define ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET _HRESULT_TYPEDEF_(0xC0262317L)

//
// MessageId: ERROR_GRAPHICS_TARGET_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present target is already in the video present target set.
//
#define ERROR_GRAPHICS_TARGET_ALREADY_IN_SET _HRESULT_TYPEDEF_(0xC0262318L)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH
//
// MessageText:
//
// Specified VidPN present path is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH _HRESULT_TYPEDEF_(0xC0262319L)

//
// MessageId: ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY
//
// MessageText:
//
// Miniport has no recommendation for augmentation of the specified VidPN's topology.
//
#define ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY _HRESULT_TYPEDEF_(0xC026231AL)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET
//
// MessageText:
//
// Specified monitor frequency range set is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET _HRESULT_TYPEDEF_(0xC026231BL)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE
//
// MessageText:
//
// Specified monitor frequency range is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE _HRESULT_TYPEDEF_(0xC026231CL)

//
// MessageId: ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET
//
// MessageText:
//
// Specified frequency range is not in the specified monitor frequency range set.
//
#define ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET _HRESULT_TYPEDEF_(0xC026231DL)

//
// MessageId: ERROR_GRAPHICS_NO_PREFERRED_MODE
//
// MessageText:
//
// Specified mode set does not specify preference for one of its modes.
//
#define ERROR_GRAPHICS_NO_PREFERRED_MODE _HRESULT_TYPEDEF_(0x0026231EL)

//
// MessageId: ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET
//
// MessageText:
//
// Specified frequency range is already in the specified monitor frequency range set.
//
#define ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET _HRESULT_TYPEDEF_(0xC026231FL)

//
// MessageId: ERROR_GRAPHICS_STALE_MODESET
//
// MessageText:
//
// Specified mode set is stale. Please reacquire the new mode set.
//
#define ERROR_GRAPHICS_STALE_MODESET _HRESULT_TYPEDEF_(0xC0262320L)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET
//
// MessageText:
//
// Specified monitor source mode set is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET _HRESULT_TYPEDEF_(0xC0262321L)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE
//
// MessageText:
//
// Specified monitor source mode is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE _HRESULT_TYPEDEF_(0xC0262322L)

//
// MessageId: ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN
//
// MessageText:
//
// Miniport does not have any recommendation regarding the request to provide a functional VidPN given the current display adapter configuration.
//
#define ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN _HRESULT_TYPEDEF_(0xC0262323L)

//
// MessageId: ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified mode is already used by another mode in the set.
//
#define ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE _HRESULT_TYPEDEF_(0xC0262324L)

//
// MessageId: ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION
//
// MessageText:
//
// System failed to determine a mode that is supported by both the display adapter and the monitor connected to it.
//
#define ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION _HRESULT_TYPEDEF_(0xC0262325L)

//
// MessageId: ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES
//
// MessageText:
//
// Number of video present targets must be greater than or equal to the number of video present sources.
//
#define ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES _HRESULT_TYPEDEF_(0xC0262326L)

//
// MessageId: ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified present path is not in VidPN's topology.
//
#define ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY _HRESULT_TYPEDEF_(0xC0262327L)

//
// MessageId: ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE
//
// MessageText:
//
// Display adapter must have at least one video present source.
//
#define ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE _HRESULT_TYPEDEF_(0xC0262328L)

//
// MessageId: ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET
//
// MessageText:
//
// Display adapter must have at least one video present target.
//
#define ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET _HRESULT_TYPEDEF_(0xC0262329L)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET
//
// MessageText:
//
// Specified monitor descriptor set is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET _HRESULT_TYPEDEF_(0xC026232AL)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR
//
// MessageText:
//
// Specified monitor descriptor is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR _HRESULT_TYPEDEF_(0xC026232BL)

//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET
//
// MessageText:
//
// Specified descriptor is not in the specified monitor descriptor set.
//
#define ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET _HRESULT_TYPEDEF_(0xC026232CL)

//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET
//
// MessageText:
//
// Specified descriptor is already in the specified monitor descriptor set.
//
#define ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET _HRESULT_TYPEDEF_(0xC026232DL)

//
// MessageId: ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified monitor descriptor is already used by another descriptor in the set.
//
#define ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE _HRESULT_TYPEDEF_(0xC026232EL)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE
//
// MessageText:
//
// Specified video present target subset type is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE _HRESULT_TYPEDEF_(0xC026232FL)

//
// MessageId: ERROR_GRAPHICS_RESOURCES_NOT_RELATED
//
// MessageText:
//
// Two or more of the specified resources are not related to each other, as defined by the interface semantics.
//
#define ERROR_GRAPHICS_RESOURCES_NOT_RELATED _HRESULT_TYPEDEF_(0xC0262330L)

//
// MessageId: ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present source is already used by another source in the set.
//
#define ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE _HRESULT_TYPEDEF_(0xC0262331L)

//
// MessageId: ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present target is already used by another target in the set.
//
#define ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE _HRESULT_TYPEDEF_(0xC0262332L)

//
// MessageId: ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET
//
// MessageText:
//
// Specified VidPN source cannot be used because there is no available VidPN target to connect it to.
//
#define ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET _HRESULT_TYPEDEF_(0xC0262333L)

//
// MessageId: ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER
//
// MessageText:
//
// Newly arrived monitor could not be associated with a display adapter.
//
#define ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER _HRESULT_TYPEDEF_(0xC0262334L)

//
// MessageId: ERROR_GRAPHICS_NO_VIDPNMGR
//
// MessageText:
//
// Display adapter in question does not have an associated VidPN manager.
//
#define ERROR_GRAPHICS_NO_VIDPNMGR _HRESULT_TYPEDEF_(0xC0262335L)

//
// MessageId: ERROR_GRAPHICS_NO_ACTIVE_VIDPN
//
// MessageText:
//
// VidPN manager of the display adapter in question does not have an active VidPN.
//
#define ERROR_GRAPHICS_NO_ACTIVE_VIDPN _HRESULT_TYPEDEF_(0xC0262336L)

//
// MessageId: ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is stale. Please reacquire the new topology.
//
#define ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY _HRESULT_TYPEDEF_(0xC0262337L)

//
// MessageId: ERROR_GRAPHICS_MONITOR_NOT_CONNECTED
//
// MessageText:
//
// There is no monitor connected on the specified video present target.
//
#define ERROR_GRAPHICS_MONITOR_NOT_CONNECTED _HRESULT_TYPEDEF_(0xC0262338L)

//
// MessageId: ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified source is not part of the specified VidPN's topology.
//
#define ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY _HRESULT_TYPEDEF_(0xC0262339L)

//
// MessageId: ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE
//
// MessageText:
//
// Specified primary surface size is invalid.
//
#define ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE _HRESULT_TYPEDEF_(0xC026233AL)

//
// MessageId: ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE
//
// MessageText:
//
// Specified visible region size is invalid.
//
#define ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE _HRESULT_TYPEDEF_(0xC026233BL)

//
// MessageId: ERROR_GRAPHICS_INVALID_STRIDE
//
// MessageText:
//
// Specified stride is invalid.
//
#define ERROR_GRAPHICS_INVALID_STRIDE _HRESULT_TYPEDEF_(0xC026233CL)

//
// MessageId: ERROR_GRAPHICS_INVALID_PIXELFORMAT
//
// MessageText:
//
// Specified pixel format is invalid.
//
#define ERROR_GRAPHICS_INVALID_PIXELFORMAT _HRESULT_TYPEDEF_(0xC026233DL)

//
// MessageId: ERROR_GRAPHICS_INVALID_COLORBASIS
//
// MessageText:
//
// Specified color basis is invalid.
//
#define ERROR_GRAPHICS_INVALID_COLORBASIS _HRESULT_TYPEDEF_(0xC026233EL)

//
// MessageId: ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE
//
// MessageText:
//
// Specified pixel value access mode is invalid.
//
#define ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE _HRESULT_TYPEDEF_(0xC026233FL)

//
// MessageId: ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified target is not part of the specified VidPN's topology.
//
#define ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY _HRESULT_TYPEDEF_(0xC0262340L)

//
// MessageId: ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT
//
// MessageText:
//
// Failed to acquire display mode management interface.
//
#define ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT _HRESULT_TYPEDEF_(0xC0262341L)

//
// MessageId: ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE
//
// MessageText:
//
// Specified VidPN source is already owned by a DMM client and cannot be used until that client releases it.
//
#define ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE _HRESULT_TYPEDEF_(0xC0262342L)

//
// MessageId: ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN
//
// MessageText:
//
// Specified VidPN is active and cannot be accessed.
//
#define ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN _HRESULT_TYPEDEF_(0xC0262343L)

//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL
//
// MessageText:
//
// Specified VidPN present path importance ordinal is invalid.
//
#define ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL _HRESULT_TYPEDEF_(0xC0262344L)

//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION
//
// MessageText:
//
// Specified VidPN present path content geometry transformation is invalid.
//
#define ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION _HRESULT_TYPEDEF_(0xC0262345L)

//
// MessageId: ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED
//
// MessageText:
//
// Specified content geometry transformation is not supported on the respective VidPN present path.
//
#define ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262346L)

//
// MessageId: ERROR_GRAPHICS_INVALID_GAMMA_RAMP
//
// MessageText:
//
// Specified gamma ramp is invalid.
//
#define ERROR_GRAPHICS_INVALID_GAMMA_RAMP _HRESULT_TYPEDEF_(0xC0262347L)

//
// MessageId: ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED
//
// MessageText:
//
// Specified gamma ramp is not supported on the respective VidPN present path.
//
#define ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262348L)

//
// MessageId: ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED
//
// MessageText:
//
// Multi-sampling is not supported on the respective VidPN present path.
//
#define ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262349L)

//
// MessageId: ERROR_GRAPHICS_MODE_NOT_IN_MODESET
//
// MessageText:
//
// Specified mode is not in the specified mode set.
//
#define ERROR_GRAPHICS_MODE_NOT_IN_MODESET _HRESULT_TYPEDEF_(0xC026234AL)

//
// MessageId: ERROR_GRAPHICS_DATASET_IS_EMPTY
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) is empty.
//
#define ERROR_GRAPHICS_DATASET_IS_EMPTY _HRESULT_TYPEDEF_(0x0026234BL)

//
// MessageId: ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) does not contain any more elements.
//
#define ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET _HRESULT_TYPEDEF_(0x0026234CL)

//
// MessageId: ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON
//
// MessageText:
//
// Specified VidPN topology recommendation reason is invalid.
//
#define ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON _HRESULT_TYPEDEF_(0xC026234DL)

//
// MessageId: ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE
//
// MessageText:
//
// Specified VidPN present path content type is invalid.
//
#define ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE _HRESULT_TYPEDEF_(0xC026234EL)

//
// MessageId: ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE
//
// MessageText:
//
// Specified VidPN present path copy protection type is invalid.
//
#define ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE _HRESULT_TYPEDEF_(0xC026234FL)

//
// MessageId: ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS
//
// MessageText:
//
// No more than one unassigned mode set can exist at any given time for a given VidPN source/target.
//
#define ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS _HRESULT_TYPEDEF_(0xC0262350L)

//
// MessageId: ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED
//
// MessageText:
//
// Specified content transformation is not pinned on the specified VidPN present path.
//
#define ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED _HRESULT_TYPEDEF_(0x00262351L)

//
// MessageId: ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING
//
// MessageText:
//
// Specified scanline ordering type is invalid.
//
#define ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING _HRESULT_TYPEDEF_(0xC0262352L)

//
// MessageId: ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED
//
// MessageText:
//
// Topology changes are not allowed for the specified VidPN.
//
#define ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC0262353L)

//
// MessageId: ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS
//
// MessageText:
//
// All available importance ordinals are already used in specified topology.
//
#define ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS _HRESULT_TYPEDEF_(0xC0262354L)

//
// MessageId: ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT
//
// MessageText:
//
// Specified primary surface has a different private format attribute than the current primary surface
//
#define ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT _HRESULT_TYPEDEF_(0xC0262355L)

//
// MessageId: ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM
//
// MessageText:
//
// Specified mode pruning algorithm is invalid
//
#define ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM _HRESULT_TYPEDEF_(0xC0262356L)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN
//
// MessageText:
//
// Specified monitor capability origin is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN _HRESULT_TYPEDEF_(0xC0262357L)

//
// MessageId: ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT
//
// MessageText:
//
// Specified monitor frequency range constraint is invalid.
//
#define ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT _HRESULT_TYPEDEF_(0xC0262358L)

//
// MessageId: ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED
//
// MessageText:
//
// Maximum supported number of present paths has been reached.
//
#define ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED _HRESULT_TYPEDEF_(0xC0262359L)

//
// MessageId: ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION
//
// MessageText:
//
// Miniport requested that augmentation be cancelled for the specified source of the specified VidPN's topology.
//
#define ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION _HRESULT_TYPEDEF_(0xC026235AL)

//
// MessageId: ERROR_GRAPHICS_INVALID_CLIENT_TYPE
//
// MessageText:
//
// Specified client type was not recognized.
//
#define ERROR_GRAPHICS_INVALID_CLIENT_TYPE _HRESULT_TYPEDEF_(0xC026235BL)

//
// MessageId: ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET
//
// MessageText:
//
// Client VidPN is not set on this adapter (e.g. no user mode initiated mode changes took place on this adapter yet).
//
#define ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET _HRESULT_TYPEDEF_(0xC026235CL)

//
// Port specific status codes {0x2400..0x24ff}
//
//
// MessageId: ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED
//
// MessageText:
//
// Specified display adapter child device already has an external device connected to it.
//
#define ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED _HRESULT_TYPEDEF_(0xC0262400L)

//
// MessageId: ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED
//
// MessageText:
//
// Specified display adapter child device does not support descriptor exposure.
//
#define ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262401L)

//
// MessageId: ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS
//
// MessageText:
//
// Child device presence was not reliably detected.
//
#define ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS _HRESULT_TYPEDEF_(0x4026242FL)

//
// MessageId: ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER
//
// MessageText:
//
// The display adapter is not linked to any other adapters.
//
#define ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER _HRESULT_TYPEDEF_(0xC0262430L)

//
// MessageId: ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED
//
// MessageText:
//
// Lead adapter in a linked configuration was not enumerated yet.
//
#define ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED _HRESULT_TYPEDEF_(0xC0262431L)

//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED
//
// MessageText:
//
// Some chain adapters in a linked configuration were not enumerated yet.
//
#define ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED _HRESULT_TYPEDEF_(0xC0262432L)

//
// MessageId: ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY
//
// MessageText:
//
// The chain of linked adapters is not ready to start because of an unknown failure.
//
#define ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY _HRESULT_TYPEDEF_(0xC0262433L)

//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED
//
// MessageText:
//
// An attempt was made to start a lead link display adapter when the chain links were not started yet.
//
#define ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED _HRESULT_TYPEDEF_(0xC0262434L)

//
// MessageId: ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON
//
// MessageText:
//
// An attempt was made to power up a lead link display adapter when the chain links were powered down.
//
#define ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON _HRESULT_TYPEDEF_(0xC0262435L)

//
// MessageId: ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE
//
// MessageText:
//
// The adapter link was found to be in an inconsistent state. Not all adapters are in an expected PNP/Power state.
//
#define ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE _HRESULT_TYPEDEF_(0xC0262436L)

//
// MessageId: ERROR_GRAPHICS_LEADLINK_START_DEFERRED
//
// MessageText:
//
// Starting the leadlink adapter has been deferred temporarily.
//
#define ERROR_GRAPHICS_LEADLINK_START_DEFERRED _HRESULT_TYPEDEF_(0x40262437L)

//
// MessageId: ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER
//
// MessageText:
//
// The driver trying to start is not the same as the driver for the POSTed display adapter.
//
#define ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER _HRESULT_TYPEDEF_(0xC0262438L)

//
// MessageId: ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY
//
// MessageText:
//
// The display adapter is being polled for children too frequently at the same polling level.
//
#define ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY _HRESULT_TYPEDEF_(0x40262439L)

//
// MessageId: ERROR_GRAPHICS_START_DEFERRED
//
// MessageText:
//
// Starting the adapter has been deferred temporarily.
//
#define ERROR_GRAPHICS_START_DEFERRED _HRESULT_TYPEDEF_(0x4026243AL)

//
// MessageId: ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED
//
// MessageText:
//
// An operation is being attempted that requires the display adapter to be in a quiescent state.
//
#define ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED _HRESULT_TYPEDEF_(0xC026243BL)

//
// OPM, UAB and PVP specific error codes {0x2500..0x257f}
//
//
// MessageId: ERROR_GRAPHICS_OPM_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support OPM.
//
#define ERROR_GRAPHICS_OPM_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262500L)

//
// MessageId: ERROR_GRAPHICS_COPP_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support COPP.
//
#define ERROR_GRAPHICS_COPP_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262501L)

//
// MessageId: ERROR_GRAPHICS_UAB_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support UAB.
//
#define ERROR_GRAPHICS_UAB_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262502L)

//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS
//
// MessageText:
//
// The specified encrypted parameters are invalid.
//
#define ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS _HRESULT_TYPEDEF_(0xC0262503L)

//
// MessageId: ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST
//
// MessageText:
//
// The GDI display device passed to this function does not have any active video outputs.
//
#define ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST _HRESULT_TYPEDEF_(0xC0262505L)

//
// MessageId: ERROR_GRAPHICS_OPM_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused this operation to fail.
//
#define ERROR_GRAPHICS_OPM_INTERNAL_ERROR _HRESULT_TYPEDEF_(0xC026250BL)

//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_HANDLE
//
// MessageText:
//
// The function failed because the caller passed in an invalid OPM user mode handle.
//
#define ERROR_GRAPHICS_OPM_INVALID_HANDLE _HRESULT_TYPEDEF_(0xC026250CL)

//
// MessageId: ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH
//
// MessageText:
//
// A certificate could not be returned because the certificate buffer passed to the function was too small.
//
#define ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH _HRESULT_TYPEDEF_(0xC026250EL)

//
// MessageId: ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED
//
// MessageText:
//
// A video output could not be created because the frame buffer is in spanning mode.
//
#define ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED _HRESULT_TYPEDEF_(0xC026250FL)

//
// MessageId: ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED
//
// MessageText:
//
// A video output could not be created because the frame buffer is in theater mode.
//
#define ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED _HRESULT_TYPEDEF_(0xC0262510L)

//
// MessageId: ERROR_GRAPHICS_PVP_HFS_FAILED
//
// MessageText:
//
// The function failed because the display adapter's Hardware Functionality Scan failed to validate the graphics hardware.
//
#define ERROR_GRAPHICS_PVP_HFS_FAILED _HRESULT_TYPEDEF_(0xC0262511L)

//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_SRM
//
// MessageText:
//
// The HDCP System Renewability Message passed to this function did not comply with section 5 of the HDCP 1.1 specification.
//
#define ERROR_GRAPHICS_OPM_INVALID_SRM _HRESULT_TYPEDEF_(0xC0262512L)

//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP
//
// MessageText:
//
// The video output cannot enable the High-bandwidth Digital Content Protection (HDCP) System because it does not support HDCP.
//
#define ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP _HRESULT_TYPEDEF_(0xC0262513L)

//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP
//
// MessageText:
//
// The video output cannot enable Analogue Copy Protection (ACP) because it does not support ACP.
//
#define ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP _HRESULT_TYPEDEF_(0xC0262514L)

//
// MessageId: ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA
//
// MessageText:
//
// The video output cannot enable the Content Generation Management System Analogue (CGMS-A) protection technology because it does not support CGMS-A.
//
#define ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA _HRESULT_TYPEDEF_(0xC0262515L)

//
// MessageId: ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET
//
// MessageText:
//
// The IOPMVideoOutput::GetInformation method cannot return the version of the SRM being used because the application never successfully passed an SRM to the video output.
//
#define ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET _HRESULT_TYPEDEF_(0xC0262516L)

//
// MessageId: ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH
//
// MessageText:
//
// The IOPMVideoOutput::Configure method cannot enable the specified output protection technology because the output's screen resolution is too high.
//
#define ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH _HRESULT_TYPEDEF_(0xC0262517L)

//
// MessageId: ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE
//
// MessageText:
//
// The IOPMVideoOutput::Configure method cannot enable HDCP because the display adapter's HDCP hardware is already being used by other physical outputs.
//
#define ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE _HRESULT_TYPEDEF_(0xC0262518L)

//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed this OPM video output because the operating system's state changed. This error typically occurs because the monitor PDO associated with this video output was removed, the monitor PDO associated with this video output was stopped, the video output's session became a non-console session or the video output's desktop became an inactive desktop.
//
#define ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS _HRESULT_TYPEDEF_(0xC026251AL)

//
// MessageId: ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The method failed because the session is changing its type. No IOPMVideoOutput methods can be called when a session is changing its type. There are currently three types of sessions: console, disconnected and remote.
//
#define ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS _HRESULT_TYPEDEF_(0xC026251BL)

//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS
//
// MessageText:
//
// Either the IOPMVideoOutput::COPPCompatibleGetInformation, IOPMVideoOutput::GetInformation, or IOPMVideoOutput::Configure method failed. This error is returned when the caller tries to use a COPP specific command while the video output has OPM semantics only.
//
#define ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS _HRESULT_TYPEDEF_(0xC026251CL)

//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST
//
// MessageText:
//
// The IOPMVideoOutput::GetInformation and IOPMVideoOutput::COPPCompatibleGetInformation methods return this error if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//
#define ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST _HRESULT_TYPEDEF_(0xC026251DL)

//
// MessageId: ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// The method failed because an unexpected error occurred inside of a display driver.
//
#define ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR _HRESULT_TYPEDEF_(0xC026251EL)

//
// MessageId: ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS
//
// MessageText:
//
// Either the IOPMVideoOutput::COPPCompatibleGetInformation, IOPMVideoOutput::GetInformation, or IOPMVideoOutput::Configure method failed. This error is returned when the caller tries to use an OPM specific command while the video output has COPP semantics only.
//
#define ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS _HRESULT_TYPEDEF_(0xC026251FL)

//
// MessageId: ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED
//
// MessageText:
//
// The IOPMVideoOutput::COPPCompatibleGetInformation or IOPMVideoOutput::Configure method failed because the display driver does not support the OPM_GET_ACP_AND_CGMSA_SIGNALING and OPM_SET_ACP_AND_CGMSA_SIGNALING GUIDs.
//
#define ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262520L)

//
// MessageId: ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST
//
// MessageText:
//
// The IOPMVideoOutput::Configure function returns this error code if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//
#define ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST _HRESULT_TYPEDEF_(0xC0262521L)

//
// Monitor Configuration API error codes {0x2580..0x25DF}
//
//
// MessageId: ERROR_GRAPHICS_I2C_NOT_SUPPORTED
//
// MessageText:
//
// The monitor connected to the specified video output does not have an I2C bus.
//
#define ERROR_GRAPHICS_I2C_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262580L)

//
// MessageId: ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST
//
// MessageText:
//
// No device on the I2C bus has the specified address.
//
#define ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST _HRESULT_TYPEDEF_(0xC0262581L)

//
// MessageId: ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA
//
// MessageText:
//
// An error occurred while transmitting data to the device on the I2C bus.
//
#define ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA _HRESULT_TYPEDEF_(0xC0262582L)

//
// MessageId: ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA
//
// MessageText:
//
// An error occurred while receiving data from the device on the I2C bus.
//
#define ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA _HRESULT_TYPEDEF_(0xC0262583L)

//
// MessageId: ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED
//
// MessageText:
//
// The monitor does not support the specified VCP code.
//
#define ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC0262584L)

//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_DATA
//
// MessageText:
//
// The data received from the monitor is invalid.
//
#define ERROR_GRAPHICS_DDCCI_INVALID_DATA _HRESULT_TYPEDEF_(0xC0262585L)

//
// MessageId: ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE
//
// MessageText:
//
// The function failed because a monitor returned an invalid Timing Status byte when the operating system used the DDC/CI Get Timing Report & Timing Message command to get a timing report from a monitor.
//
#define ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE _HRESULT_TYPEDEF_(0xC0262586L)

//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING
//
// MessageText:
//
// The monitor returned a DDC/CI capabilities string which did not comply with the ACCESS.bus 3.0, DDC/CI 1.1, or MCCS 2 Revision 1 specification.
//
#define ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING _HRESULT_TYPEDEF_(0xC0262587L)

//
// MessageId: ERROR_GRAPHICS_MCA_INTERNAL_ERROR
//
// MessageText:
//
// An internal Monitor Configuration API error occured.
//
#define ERROR_GRAPHICS_MCA_INTERNAL_ERROR _HRESULT_TYPEDEF_(0xC0262588L)

//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND
//
// MessageText:
//
// An operation failed because a DDC/CI message had an invalid value in its command field.
//
#define ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND _HRESULT_TYPEDEF_(0xC0262589L)

//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH
//
// MessageText:
//
// An error occurred because the field length of a DDC/CI message contained an invalid value.
//
#define ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH _HRESULT_TYPEDEF_(0xC026258AL)

//
// MessageId: ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM
//
// MessageText:
//
// An error occurred because the checksum field in a DDC/CI message did not match the message's computed checksum value. This error implies that the data was corrupted while it was being transmitted from a monitor to a computer.
//
#define ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM _HRESULT_TYPEDEF_(0xC026258BL)

//
// MessageId: ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE
//
// MessageText:
//
// This function failed because an invalid monitor handle was passed to it.
//
#define ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE _HRESULT_TYPEDEF_(0xC026258CL)

//
// MessageId: ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed the monitor which corresponds to this handle because the operating system's state changed. This error typically occurs because the monitor PDO associated with this handle was removed, the monitor PDO associated with this handle was stopped, or a display mode change occurred. A display mode change occurs when windows sends a WM_DISPLAYCHANGE windows message to applications.
//
#define ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS _HRESULT_TYPEDEF_(0xC026258DL)

//
// MessageId: ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE
//
// MessageText:
//
// A continuous VCP code's current value is greater than its maximum value. This error code indicates that a monitor returned an invalid value.
//
#define ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE _HRESULT_TYPEDEF_(0xC02625D8L)

//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION
//
// MessageText:
//
// The monitor's VCP Version (0xDF) VCP code returned an invalid version value.
//
#define ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION _HRESULT_TYPEDEF_(0xC02625D9L)

//
// MessageId: ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION
//
// MessageText:
//
// The monitor does not comply with the MCCS specification it claims to support.
//
#define ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION _HRESULT_TYPEDEF_(0xC02625DAL)

//
// MessageId: ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH
//
// MessageText:
//
// The MCCS version in a monitor's mccs_ver capability does not match the MCCS version the monitor reports when the VCP Version (0xDF) VCP code is used.
//
#define ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH _HRESULT_TYPEDEF_(0xC02625DBL)

//
// MessageId: ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION
//
// MessageText:
//
// The Monitor Configuration API only works with monitors which support the MCCS 1.0 specification, MCCS 2.0 specification or the MCCS 2.0 Revision 1 specification.
//
#define ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION _HRESULT_TYPEDEF_(0xC02625DCL)

//
// MessageId: ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED
//
// MessageText:
//
// The monitor returned an invalid monitor technology type. CRT, Plasma and LCD (TFT) are examples of monitor technology types. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
#define ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED _HRESULT_TYPEDEF_(0xC02625DEL)

//
// MessageId: ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE
//
// MessageText:
//
// SetMonitorColorTemperature()'s caller passed a color temperature to it which the current monitor did not support. This error implies that the monitor violated the MCCS 2.0 or MCCS 2.0 Revision 1 specification.
//
#define ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE _HRESULT_TYPEDEF_(0xC02625DFL)

//
// OPM, UAB, PVP and DDC/CI shared error codes {0x25E0..0x25ff}
//
//
// MessageId: ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED
//
// MessageText:
//
// This function can only be used if a program is running in the local console session. It cannot be used if the program is running on a remote desktop session or on a terminal server session.
//
#define ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED _HRESULT_TYPEDEF_(0xC02625E0L)

//
// MessageId: ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME
//
// MessageText:
//
// This function cannot find an actual GDI display device which corresponds to the specified GDI display device name.
//
#define ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME _HRESULT_TYPEDEF_(0xC02625E1L)

//
// MessageId: ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP
//
// MessageText:
//
// The function failed because the specified GDI display device was not attached to the Windows desktop.
//
#define ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP _HRESULT_TYPEDEF_(0xC02625E2L)

//
// MessageId: ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED
//
// MessageText:
//
// This function does not support GDI mirroring display devices because GDI mirroring display devices do not have any physical monitors associated with them.
//
#define ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC02625E3L)

//
// MessageId: ERROR_GRAPHICS_INVALID_POINTER
//
// MessageText:
//
// The function failed because an invalid pointer parameter was passed to it. A pointer parameter is invalid if it is NULL, points to an invalid address, points to a kernel mode address, or is not correctly aligned.
//
#define ERROR_GRAPHICS_INVALID_POINTER _HRESULT_TYPEDEF_(0xC02625E4L)

//
// MessageId: ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE
//
// MessageText:
//
// The function failed because the specified GDI device did not have any monitors associated with it.
//
#define ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE _HRESULT_TYPEDEF_(0xC02625E5L)

//
// MessageId: ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL
//
// MessageText:
//
// An array passed to the function cannot hold all of the data that the function must copy into the array.
//
#define ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL _HRESULT_TYPEDEF_(0xC02625E6L)

//
// MessageId: ERROR_GRAPHICS_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused an operation to fail.
//
#define ERROR_GRAPHICS_INTERNAL_ERROR _HRESULT_TYPEDEF_(0xC02625E7L)

//
// MessageId: ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The function failed because the current session is changing its type. This function cannot be called when the current session is changing its type. There are currently three types of sessions: console, disconnected and remote.
//
#define ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS _HRESULT_TYPEDEF_(0xC02605E8L)

//
// ===============================
// TPM Services and TPM Software Error Messages
// ===============================
//
// The TPM services and TPM software facilities are used by the various
// TPM software components. There are two facilities because the services
// errors are within the TCG-defined error space and the software errors
// are not.
//
// The following are the subranges within the TPM Services facility.
// The TPM hardware errors are defined in the document
// TPM Main Specification 1.2 Part 2 TPM Structures.
// The TBS errors are slotted into the TCG error namespace at the TBS layer.
//
// 0x0000 - 0x08ff     TPM hardware errors
// 0x4000 - 0x40ff     TPM Base Services errors (tbssvc.dll)
//
// The following are the subranges within the TPM Software facility. The TBS
// has two classes of errors - those that can be returned (the public errors,
// defined in the TBS spec), which are in the TPM services facility,  and
// those that are internal or implementation specific, which are here in the
// TPM software facility.
//
// 0x0000 - 0x00ff     TPM device driver errors (tpm.sys)
// 0x0100 - 0x01ff     TPM API errors (tpmapi.lib)
// 0x0200 - 0x02ff     TBS internal errors (tbssvc.dll)
// 0x0300 - 0x03ff     TPM Physical Presence errors
//
//
// TPM hardware error codes {0x0000..0x08ff}
// This space is further subdivided into hardware errors, vendor-specific
// errors, and non-fatal errors.
//
//
// TPM hardware errors {0x0000..0x003ff}
//
//
// MessageId: TPM_E_ERROR_MASK
//
// MessageText:
//
// This is an error mask to convert TPM hardware errors to win errors.
//
#define TPM_E_ERROR_MASK _HRESULT_TYPEDEF_(0x80280000L)

//
// MessageId: TPM_E_AUTHFAIL
//
// MessageText:
//
// Authentication failed.
//
#define TPM_E_AUTHFAIL _HRESULT_TYPEDEF_(0x80280001L)

//
// MessageId: TPM_E_BADINDEX
//
// MessageText:
//
// The index to a PCR, DIR or other register is incorrect.
//
#define TPM_E_BADINDEX _HRESULT_TYPEDEF_(0x80280002L)

//
// MessageId: TPM_E_BAD_PARAMETER
//
// MessageText:
//
// One or more parameter is bad.
//
#define TPM_E_BAD_PARAMETER _HRESULT_TYPEDEF_(0x80280003L)

//
// MessageId: TPM_E_AUDITFAILURE
//
// MessageText:
//
// An operation completed successfully but the auditing of that operation failed.
//
#define TPM_E_AUDITFAILURE _HRESULT_TYPEDEF_(0x80280004L)

//
// MessageId: TPM_E_CLEAR_DISABLED
//
// MessageText:
//
// The clear disable flag is set and all clear operations now require physical access.
//
#define TPM_E_CLEAR_DISABLED _HRESULT_TYPEDEF_(0x80280005L)

//
// MessageId: TPM_E_DEACTIVATED
//
// MessageText:
//
// Activate the Trusted Platform Module (TPM).
//
#define TPM_E_DEACTIVATED _HRESULT_TYPEDEF_(0x80280006L)

//
// MessageId: TPM_E_DISABLED
//
// MessageText:
//
// Enable the Trusted Platform Module (TPM).
//
#define TPM_E_DISABLED _HRESULT_TYPEDEF_(0x80280007L)

//
// MessageId: TPM_E_DISABLED_CMD
//
// MessageText:
//
// The target command has been disabled.
//
#define TPM_E_DISABLED_CMD _HRESULT_TYPEDEF_(0x80280008L)

//
// MessageId: TPM_E_FAIL
//
// MessageText:
//
// The operation failed.
//
#define TPM_E_FAIL _HRESULT_TYPEDEF_(0x80280009L)

//
// MessageId: TPM_E_BAD_ORDINAL
//
// MessageText:
//
// The ordinal was unknown or inconsistent.
//
#define TPM_E_BAD_ORDINAL _HRESULT_TYPEDEF_(0x8028000AL)

//
// MessageId: TPM_E_INSTALL_DISABLED
//
// MessageText:
//
// The ability to install an owner is disabled.
//
#define TPM_E_INSTALL_DISABLED _HRESULT_TYPEDEF_(0x8028000BL)

//
// MessageId: TPM_E_INVALID_KEYHANDLE
//
// MessageText:
//
// The key handle cannot be interpreted.
//
#define TPM_E_INVALID_KEYHANDLE _HRESULT_TYPEDEF_(0x8028000CL)

//
// MessageId: TPM_E_KEYNOTFOUND
//
// MessageText:
//
// The key handle points to an invalid key.
//
#define TPM_E_KEYNOTFOUND _HRESULT_TYPEDEF_(0x8028000DL)

//
// MessageId: TPM_E_INAPPROPRIATE_ENC
//
// MessageText:
//
// Unacceptable encryption scheme.
//
#define TPM_E_INAPPROPRIATE_ENC _HRESULT_TYPEDEF_(0x8028000EL)

//
// MessageId: TPM_E_MIGRATEFAIL
//
// MessageText:
//
// Migration authorization failed.
//
#define TPM_E_MIGRATEFAIL _HRESULT_TYPEDEF_(0x8028000FL)

//
// MessageId: TPM_E_INVALID_PCR_INFO
//
// MessageText:
//
// PCR information could not be interpreted.
//
#define TPM_E_INVALID_PCR_INFO _HRESULT_TYPEDEF_(0x80280010L)

//
// MessageId: TPM_E_NOSPACE
//
// MessageText:
//
// No room to load key.
//
#define TPM_E_NOSPACE _HRESULT_TYPEDEF_(0x80280011L)

//
// MessageId: TPM_E_NOSRK
//
// MessageText:
//
// There is no Storage Root Key (SRK) set.
//
#define TPM_E_NOSRK _HRESULT_TYPEDEF_(0x80280012L)

//
// MessageId: TPM_E_NOTSEALED_BLOB
//
// MessageText:
//
// An encrypted blob is invalid or was not created by this TPM.
//
#define TPM_E_NOTSEALED_BLOB _HRESULT_TYPEDEF_(0x80280013L)

//
// MessageId: TPM_E_OWNER_SET
//
// MessageText:
//
// The Trusted Platform Module (TPM) already has an owner.
//
#define TPM_E_OWNER_SET _HRESULT_TYPEDEF_(0x80280014L)

//
// MessageId: TPM_E_RESOURCES
//
// MessageText:
//
// The TPM has insufficient internal resources to perform the requested action.
//
#define TPM_E_RESOURCES _HRESULT_TYPEDEF_(0x80280015L)

//
// MessageId: TPM_E_SHORTRANDOM
//
// MessageText:
//
// A random string was too short.
//
#define TPM_E_SHORTRANDOM _HRESULT_TYPEDEF_(0x80280016L)

//
// MessageId: TPM_E_SIZE
//
// MessageText:
//
// The TPM does not have the space to perform the operation.
//
#define TPM_E_SIZE _HRESULT_TYPEDEF_(0x80280017L)

//
// MessageId: TPM_E_WRONGPCRVAL
//
// MessageText:
//
// The named PCR value does not match the current PCR value.
//
#define TPM_E_WRONGPCRVAL _HRESULT_TYPEDEF_(0x80280018L)

//
// MessageId: TPM_E_BAD_PARAM_SIZE
//
// MessageText:
//
// The paramSize argument to the command has the incorrect value .
//
#define TPM_E_BAD_PARAM_SIZE _HRESULT_TYPEDEF_(0x80280019L)

//
// MessageId: TPM_E_SHA_THREAD
//
// MessageText:
//
// There is no existing SHA-1 thread.
//
#define TPM_E_SHA_THREAD _HRESULT_TYPEDEF_(0x8028001AL)

//
// MessageId: TPM_E_SHA_ERROR
//
// MessageText:
//
// The calculation is unable to proceed because the existing SHA-1 thread has already encountered an error.
//
#define TPM_E_SHA_ERROR _HRESULT_TYPEDEF_(0x8028001BL)

//
// MessageId: TPM_E_FAILEDSELFTEST
//
// MessageText:
//
// The TPM hardware device reported a failure during its internal self test. Try restarting the computer to resolve the problem. If the problem continues, you might need to replace your TPM hardware or motherboard.
//
#define TPM_E_FAILEDSELFTEST _HRESULT_TYPEDEF_(0x8028001CL)

//
// MessageId: TPM_E_AUTH2FAIL
//
// MessageText:
//
// The authorization for the second key in a 2 key function failed authorization.
//
#define TPM_E_AUTH2FAIL _HRESULT_TYPEDEF_(0x8028001DL)

//
// MessageId: TPM_E_BADTAG
//
// MessageText:
//
// The tag value sent to for a command is invalid.
//
#define TPM_E_BADTAG _HRESULT_TYPEDEF_(0x8028001EL)

//
// MessageId: TPM_E_IOERROR
//
// MessageText:
//
// An IO error occurred transmitting information to the TPM.
//
#define TPM_E_IOERROR _HRESULT_TYPEDEF_(0x8028001FL)

//
// MessageId: TPM_E_ENCRYPT_ERROR
//
// MessageText:
//
// The encryption process had a problem.
//
#define TPM_E_ENCRYPT_ERROR _HRESULT_TYPEDEF_(0x80280020L)

//
// MessageId: TPM_E_DECRYPT_ERROR
//
// MessageText:
//
// The decryption process did not complete.
//
#define TPM_E_DECRYPT_ERROR _HRESULT_TYPEDEF_(0x80280021L)

//
// MessageId: TPM_E_INVALID_AUTHHANDLE
//
// MessageText:
//
// An invalid handle was used.
//
#define TPM_E_INVALID_AUTHHANDLE _HRESULT_TYPEDEF_(0x80280022L)

//
// MessageId: TPM_E_NO_ENDORSEMENT
//
// MessageText:
//
// The TPM does not have an Endorsement Key (EK) installed.
//
#define TPM_E_NO_ENDORSEMENT _HRESULT_TYPEDEF_(0x80280023L)

//
// MessageId: TPM_E_INVALID_KEYUSAGE
//
// MessageText:
//
// The usage of a key is not allowed.
//
#define TPM_E_INVALID_KEYUSAGE _HRESULT_TYPEDEF_(0x80280024L)

//
// MessageId: TPM_E_WRONG_ENTITYTYPE
//
// MessageText:
//
// The submitted entity type is not allowed.
//
#define TPM_E_WRONG_ENTITYTYPE _HRESULT_TYPEDEF_(0x80280025L)

//
// MessageId: TPM_E_INVALID_POSTINIT
//
// MessageText:
//
// The command was received in the wrong sequence relative to TPM_Init and a subsequent TPM_Startup.
//
#define TPM_E_INVALID_POSTINIT _HRESULT_TYPEDEF_(0x80280026L)

//
// MessageId: TPM_E_INAPPROPRIATE_SIG
//
// MessageText:
//
// Signed data cannot include additional DER information.
//
#define TPM_E_INAPPROPRIATE_SIG _HRESULT_TYPEDEF_(0x80280027L)

//
// MessageId: TPM_E_BAD_KEY_PROPERTY
//
// MessageText:
//
// The key properties in TPM_KEY_PARMs are not supported by this TPM.
//
#define TPM_E_BAD_KEY_PROPERTY _HRESULT_TYPEDEF_(0x80280028L)

//
// MessageId: TPM_E_BAD_MIGRATION
//
// MessageText:
//
// The migration properties of this key are incorrect.
//
#define TPM_E_BAD_MIGRATION _HRESULT_TYPEDEF_(0x80280029L)

//
// MessageId: TPM_E_BAD_SCHEME
//
// MessageText:
//
// The signature or encryption scheme for this key is incorrect or not permitted in this situation.
//
#define TPM_E_BAD_SCHEME _HRESULT_TYPEDEF_(0x8028002AL)

//
// MessageId: TPM_E_BAD_DATASIZE
//
// MessageText:
//
// The size of the data (or blob) parameter is bad or inconsistent with the referenced key.
//
#define TPM_E_BAD_DATASIZE _HRESULT_TYPEDEF_(0x8028002BL)

//
// MessageId: TPM_E_BAD_MODE
//
// MessageText:
//
// A mode parameter is bad, such as capArea or subCapArea for TPM_GetCapability, phsicalPresence parameter for TPM_PhysicalPresence, or migrationType for TPM_CreateMigrationBlob.
//
#define TPM_E_BAD_MODE _HRESULT_TYPEDEF_(0x8028002CL)

//
// MessageId: TPM_E_BAD_PRESENCE
//
// MessageText:
//
// Either the physicalPresence or physicalPresenceLock bits have the wrong value.
//
#define TPM_E_BAD_PRESENCE _HRESULT_TYPEDEF_(0x8028002DL)

//
// MessageId: TPM_E_BAD_VERSION
//
// MessageText:
//
// The TPM cannot perform this version of the capability.
//
#define TPM_E_BAD_VERSION _HRESULT_TYPEDEF_(0x8028002EL)

//
// MessageId: TPM_E_NO_WRAP_TRANSPORT
//
// MessageText:
//
// The TPM does not allow for wrapped transport sessions.
//
#define TPM_E_NO_WRAP_TRANSPORT _HRESULT_TYPEDEF_(0x8028002FL)

//
// MessageId: TPM_E_AUDITFAIL_UNSUCCESSFUL
//
// MessageText:
//
// TPM audit construction failed and the underlying command was returning a failure code also.
//
#define TPM_E_AUDITFAIL_UNSUCCESSFUL _HRESULT_TYPEDEF_(0x80280030L)

//
// MessageId: TPM_E_AUDITFAIL_SUCCESSFUL
//
// MessageText:
//
// TPM audit construction failed and the underlying command was returning success.
//
#define TPM_E_AUDITFAIL_SUCCESSFUL _HRESULT_TYPEDEF_(0x80280031L)

//
// MessageId: TPM_E_NOTRESETABLE
//
// MessageText:
//
// Attempt to reset a PCR register that does not have the resettable attribute.
//
#define TPM_E_NOTRESETABLE _HRESULT_TYPEDEF_(0x80280032L)

//
// MessageId: TPM_E_NOTLOCAL
//
// MessageText:
//
// Attempt to reset a PCR register that requires locality and locality modifier not part of command transport.
//
#define TPM_E_NOTLOCAL _HRESULT_TYPEDEF_(0x80280033L)

//
// MessageId: TPM_E_BAD_TYPE
//
// MessageText:
//
// Make identity blob not properly typed.
//
#define TPM_E_BAD_TYPE _HRESULT_TYPEDEF_(0x80280034L)

//
// MessageId: TPM_E_INVALID_RESOURCE
//
// MessageText:
//
// When saving context identified resource type does not match actual resource.
//
#define TPM_E_INVALID_RESOURCE _HRESULT_TYPEDEF_(0x80280035L)

//
// MessageId: TPM_E_NOTFIPS
//
// MessageText:
//
// The TPM is attempting to execute a command only available when in FIPS mode.
//
#define TPM_E_NOTFIPS _HRESULT_TYPEDEF_(0x80280036L)

//
// MessageId: TPM_E_INVALID_FAMILY
//
// MessageText:
//
// The command is attempting to use an invalid family ID.
//
#define TPM_E_INVALID_FAMILY _HRESULT_TYPEDEF_(0x80280037L)

//
// MessageId: TPM_E_NO_NV_PERMISSION
//
// MessageText:
//
// The permission to manipulate the NV storage is not available.
//
#define TPM_E_NO_NV_PERMISSION _HRESULT_TYPEDEF_(0x80280038L)

//
// MessageId: TPM_E_REQUIRES_SIGN
//
// MessageText:
//
// The operation requires a signed command.
//
#define TPM_E_REQUIRES_SIGN _HRESULT_TYPEDEF_(0x80280039L)

//
// MessageId: TPM_E_KEY_NOTSUPPORTED
//
// MessageText:
//
// Wrong operation to load an NV key.
//
#define TPM_E_KEY_NOTSUPPORTED _HRESULT_TYPEDEF_(0x8028003AL)

//
// MessageId: TPM_E_AUTH_CONFLICT
//
// MessageText:
//
// NV_LoadKey blob requires both owner and blob authorization.
//
#define TPM_E_AUTH_CONFLICT _HRESULT_TYPEDEF_(0x8028003BL)

//
// MessageId: TPM_E_AREA_LOCKED
//
// MessageText:
//
// The NV area is locked and not writtable.
//
#define TPM_E_AREA_LOCKED _HRESULT_TYPEDEF_(0x8028003CL)

//
// MessageId: TPM_E_BAD_LOCALITY
//
// MessageText:
//
// The locality is incorrect for the attempted operation.
//
#define TPM_E_BAD_LOCALITY _HRESULT_TYPEDEF_(0x8028003DL)

//
// MessageId: TPM_E_READ_ONLY
//
// MessageText:
//
// The NV area is read only and can't be written to.
//
#define TPM_E_READ_ONLY _HRESULT_TYPEDEF_(0x8028003EL)

//
// MessageId: TPM_E_PER_NOWRITE
//
// MessageText:
//
// There is no protection on the write to the NV area.
//
#define TPM_E_PER_NOWRITE _HRESULT_TYPEDEF_(0x8028003FL)

//
// MessageId: TPM_E_FAMILYCOUNT
//
// MessageText:
//
// The family count value does not match.
//
#define TPM_E_FAMILYCOUNT _HRESULT_TYPEDEF_(0x80280040L)

//
// MessageId: TPM_E_WRITE_LOCKED
//
// MessageText:
//
// The NV area has already been written to.
//
#define TPM_E_WRITE_LOCKED _HRESULT_TYPEDEF_(0x80280041L)

//
// MessageId: TPM_E_BAD_ATTRIBUTES
//
// MessageText:
//
// The NV area attributes conflict.
//
#define TPM_E_BAD_ATTRIBUTES _HRESULT_TYPEDEF_(0x80280042L)

//
// MessageId: TPM_E_INVALID_STRUCTURE
//
// MessageText:
//
// The structure tag and version are invalid or inconsistent.
//
#define TPM_E_INVALID_STRUCTURE _HRESULT_TYPEDEF_(0x80280043L)

//
// MessageId: TPM_E_KEY_OWNER_CONTROL
//
// MessageText:
//
// The key is under control of the TPM Owner and can only be evicted by the TPM Owner.
//
#define TPM_E_KEY_OWNER_CONTROL _HRESULT_TYPEDEF_(0x80280044L)

//
// MessageId: TPM_E_BAD_COUNTER
//
// MessageText:
//
// The counter handle is incorrect.
//
#define TPM_E_BAD_COUNTER _HRESULT_TYPEDEF_(0x80280045L)

//
// MessageId: TPM_E_NOT_FULLWRITE
//
// MessageText:
//
// The write is not a complete write of the area.
//
#define TPM_E_NOT_FULLWRITE _HRESULT_TYPEDEF_(0x80280046L)

//
// MessageId: TPM_E_CONTEXT_GAP
//
// MessageText:
//
// The gap between saved context counts is too large.
//
#define TPM_E_CONTEXT_GAP _HRESULT_TYPEDEF_(0x80280047L)

//
// MessageId: TPM_E_MAXNVWRITES
//
// MessageText:
//
// The maximum number of NV writes without an owner has been exceeded.
//
#define TPM_E_MAXNVWRITES _HRESULT_TYPEDEF_(0x80280048L)

//
// MessageId: TPM_E_NOOPERATOR
//
// MessageText:
//
// No operator AuthData value is set.
//
#define TPM_E_NOOPERATOR _HRESULT_TYPEDEF_(0x80280049L)

//
// MessageId: TPM_E_RESOURCEMISSING
//
// MessageText:
//
// The resource pointed to by context is not loaded.
//
#define TPM_E_RESOURCEMISSING _HRESULT_TYPEDEF_(0x8028004AL)

//
// MessageId: TPM_E_DELEGATE_LOCK
//
// MessageText:
//
// The delegate administration is locked.
//
#define TPM_E_DELEGATE_LOCK _HRESULT_TYPEDEF_(0x8028004BL)

//
// MessageId: TPM_E_DELEGATE_FAMILY
//
// MessageText:
//
// Attempt to manage a family other then the delegated family.
//
#define TPM_E_DELEGATE_FAMILY _HRESULT_TYPEDEF_(0x8028004CL)

//
// MessageId: TPM_E_DELEGATE_ADMIN
//
// MessageText:
//
// Delegation table management not enabled.
//
#define TPM_E_DELEGATE_ADMIN _HRESULT_TYPEDEF_(0x8028004DL)

//
// MessageId: TPM_E_TRANSPORT_NOTEXCLUSIVE
//
// MessageText:
//
// There was a command executed outside of an exclusive transport session.
//
#define TPM_E_TRANSPORT_NOTEXCLUSIVE _HRESULT_TYPEDEF_(0x8028004EL)

//
// MessageId: TPM_E_OWNER_CONTROL
//
// MessageText:
//
// Attempt to context save a owner evict controlled key.
//
#define TPM_E_OWNER_CONTROL _HRESULT_TYPEDEF_(0x8028004FL)

//
// MessageId: TPM_E_DAA_RESOURCES
//
// MessageText:
//
// The DAA command has no resources availble to execute the command.
//
#define TPM_E_DAA_RESOURCES _HRESULT_TYPEDEF_(0x80280050L)

//
// MessageId: TPM_E_DAA_INPUT_DATA0
//
// MessageText:
//
// The consistency check on DAA parameter inputData0 has failed.
//
#define TPM_E_DAA_INPUT_DATA0 _HRESULT_TYPEDEF_(0x80280051L)

//
// MessageId: TPM_E_DAA_INPUT_DATA1
//
// MessageText:
//
// The consistency check on DAA parameter inputData1 has failed.
//
#define TPM_E_DAA_INPUT_DATA1 _HRESULT_TYPEDEF_(0x80280052L)

//
// MessageId: TPM_E_DAA_ISSUER_SETTINGS
//
// MessageText:
//
// The consistency check on DAA_issuerSettings has failed.
//
#define TPM_E_DAA_ISSUER_SETTINGS _HRESULT_TYPEDEF_(0x80280053L)

//
// MessageId: TPM_E_DAA_TPM_SETTINGS
//
// MessageText:
//
// The consistency check on DAA_tpmSpecific has failed.
//
#define TPM_E_DAA_TPM_SETTINGS _HRESULT_TYPEDEF_(0x80280054L)

//
// MessageId: TPM_E_DAA_STAGE
//
// MessageText:
//
// The atomic process indicated by the submitted DAA command is not the expected process.
//
#define TPM_E_DAA_STAGE _HRESULT_TYPEDEF_(0x80280055L)

//
// MessageId: TPM_E_DAA_ISSUER_VALIDITY
//
// MessageText:
//
// The issuer's validity check has detected an inconsistency.
//
#define TPM_E_DAA_ISSUER_VALIDITY _HRESULT_TYPEDEF_(0x80280056L)

//
// MessageId: TPM_E_DAA_WRONG_W
//
// MessageText:
//
// The consistency check on w has failed.
//
#define TPM_E_DAA_WRONG_W _HRESULT_TYPEDEF_(0x80280057L)

//
// MessageId: TPM_E_BAD_HANDLE
//
// MessageText:
//
// The handle is incorrect.
//
#define TPM_E_BAD_HANDLE _HRESULT_TYPEDEF_(0x80280058L)

//
// MessageId: TPM_E_BAD_DELEGATE
//
// MessageText:
//
// Delegation is not correct.
//
#define TPM_E_BAD_DELEGATE _HRESULT_TYPEDEF_(0x80280059L)

//
// MessageId: TPM_E_BADCONTEXT
//
// MessageText:
//
// The context blob is invalid.
//
#define TPM_E_BADCONTEXT _HRESULT_TYPEDEF_(0x8028005AL)

//
// MessageId: TPM_E_TOOMANYCONTEXTS
//
// MessageText:
//
// Too many contexts held by the TPM.
//
#define TPM_E_TOOMANYCONTEXTS _HRESULT_TYPEDEF_(0x8028005BL)

//
// MessageId: TPM_E_MA_TICKET_SIGNATURE
//
// MessageText:
//
// Migration authority signature validation failure.
//
#define TPM_E_MA_TICKET_SIGNATURE _HRESULT_TYPEDEF_(0x8028005CL)

//
// MessageId: TPM_E_MA_DESTINATION
//
// MessageText:
//
// Migration destination not authenticated.
//
#define TPM_E_MA_DESTINATION _HRESULT_TYPEDEF_(0x8028005DL)

//
// MessageId: TPM_E_MA_SOURCE
//
// MessageText:
//
// Migration source incorrect.
//
#define TPM_E_MA_SOURCE _HRESULT_TYPEDEF_(0x8028005EL)

//
// MessageId: TPM_E_MA_AUTHORITY
//
// MessageText:
//
// Incorrect migration authority.
//
#define TPM_E_MA_AUTHORITY _HRESULT_TYPEDEF_(0x8028005FL)

//
// MessageId: TPM_E_PERMANENTEK
//
// MessageText:
//
// Attempt to revoke the EK and the EK is not revocable.
//
#define TPM_E_PERMANENTEK _HRESULT_TYPEDEF_(0x80280061L)

//
// MessageId: TPM_E_BAD_SIGNATURE
//
// MessageText:
//
// Bad signature of CMK ticket.
//
#define TPM_E_BAD_SIGNATURE _HRESULT_TYPEDEF_(0x80280062L)

//
// MessageId: TPM_E_NOCONTEXTSPACE
//
// MessageText:
//
// There is no room in the context list for additional contexts.
//
#define TPM_E_NOCONTEXTSPACE _HRESULT_TYPEDEF_(0x80280063L)

//
// TPM vendor specific hardware errors {0x0400..0x04ff}
//
//
// MessageId: TPM_E_COMMAND_BLOCKED
//
// MessageText:
//
// The command was blocked.
//
#define TPM_E_COMMAND_BLOCKED _HRESULT_TYPEDEF_(0x80280400L)

//
// MessageId: TPM_E_INVALID_HANDLE
//
// MessageText:
//
// The specified handle was not found.
//
#define TPM_E_INVALID_HANDLE _HRESULT_TYPEDEF_(0x80280401L)

//
// MessageId: TPM_E_DUPLICATE_VHANDLE
//
// MessageText:
//
// The TPM returned a duplicate handle and the command needs to be resubmitted.
//
#define TPM_E_DUPLICATE_VHANDLE _HRESULT_TYPEDEF_(0x80280402L)

//
// MessageId: TPM_E_EMBEDDED_COMMAND_BLOCKED
//
// MessageText:
//
// The command within the transport was blocked.
//
#define TPM_E_EMBEDDED_COMMAND_BLOCKED _HRESULT_TYPEDEF_(0x80280403L)

//
// MessageId: TPM_E_EMBEDDED_COMMAND_UNSUPPORTED
//
// MessageText:
//
// The command within the transport is not supported.
//
#define TPM_E_EMBEDDED_COMMAND_UNSUPPORTED _HRESULT_TYPEDEF_(0x80280404L)

//
// TPM non-fatal hardware errors {0x0800..0x08ff}
//
//
// MessageId: TPM_E_RETRY
//
// MessageText:
//
// The TPM is too busy to respond to the command immediately, but the command could be resubmitted at a later time.
//
#define TPM_E_RETRY _HRESULT_TYPEDEF_(0x80280800L)

//
// MessageId: TPM_E_NEEDS_SELFTEST
//
// MessageText:
//
// SelfTestFull has not been run.
//
#define TPM_E_NEEDS_SELFTEST _HRESULT_TYPEDEF_(0x80280801L)

//
// MessageId: TPM_E_DOING_SELFTEST
//
// MessageText:
//
// The TPM is currently executing a full selftest.
//
#define TPM_E_DOING_SELFTEST _HRESULT_TYPEDEF_(0x80280802L)

//
// MessageId: TPM_E_DEFEND_LOCK_RUNNING
//
// MessageText:
//
// The TPM is defending against dictionary attacks and is in a time-out period.
//
#define TPM_E_DEFEND_LOCK_RUNNING _HRESULT_TYPEDEF_(0x80280803L)

//
// TPM Base Services error codes {0x4000..0x40ff}
//
//
// MessageId: TBS_E_INTERNAL_ERROR
//
// MessageText:
//
// An internal software error has been detected.
//
#define TBS_E_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x80284001L)

//
// MessageId: TBS_E_BAD_PARAMETER
//
// MessageText:
//
// One or more input parameters is bad.
//
#define TBS_E_BAD_PARAMETER _HRESULT_TYPEDEF_(0x80284002L)

//
// MessageId: TBS_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// A specified output pointer is bad.
//
#define TBS_E_INVALID_OUTPUT_POINTER _HRESULT_TYPEDEF_(0x80284003L)

//
// MessageId: TBS_E_INVALID_CONTEXT
//
// MessageText:
//
// The specified context handle does not refer to a valid context.
//
#define TBS_E_INVALID_CONTEXT _HRESULT_TYPEDEF_(0x80284004L)

//
// MessageId: TBS_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// A specified output buffer is too small.
//
#define TBS_E_INSUFFICIENT_BUFFER _HRESULT_TYPEDEF_(0x80284005L)

//
// MessageId: TBS_E_IOERROR
//
// MessageText:
//
// An error occurred while communicating with the TPM.
//
#define TBS_E_IOERROR _HRESULT_TYPEDEF_(0x80284006L)

//
// MessageId: TBS_E_INVALID_CONTEXT_PARAM
//
// MessageText:
//
// One or more context parameters is invalid.
//
#define TBS_E_INVALID_CONTEXT_PARAM _HRESULT_TYPEDEF_(0x80284007L)

//
// MessageId: TBS_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The TBS service is not running and could not be started.
//
#define TBS_E_SERVICE_NOT_RUNNING _HRESULT_TYPEDEF_(0x80284008L)

//
// MessageId: TBS_E_TOO_MANY_TBS_CONTEXTS
//
// MessageText:
//
// A new context could not be created because there are too many open contexts.
//
#define TBS_E_TOO_MANY_TBS_CONTEXTS _HRESULT_TYPEDEF_(0x80284009L)

//
// MessageId: TBS_E_TOO_MANY_RESOURCES
//
// MessageText:
//
// A new virtual resource could not be created because there are too many open virtual resources.
//
#define TBS_E_TOO_MANY_RESOURCES _HRESULT_TYPEDEF_(0x8028400AL)

//
// MessageId: TBS_E_SERVICE_START_PENDING
//
// MessageText:
//
// The TBS service has been started but is not yet running.
//
#define TBS_E_SERVICE_START_PENDING _HRESULT_TYPEDEF_(0x8028400BL)

//
// MessageId: TBS_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The physical presence interface is not supported.
//
#define TBS_E_PPI_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8028400CL)

//
// MessageId: TBS_E_COMMAND_CANCELED
//
// MessageText:
//
// The command was canceled.
//
#define TBS_E_COMMAND_CANCELED _HRESULT_TYPEDEF_(0x8028400DL)

//
// MessageId: TBS_E_BUFFER_TOO_LARGE
//
// MessageText:
//
// The input or output buffer is too large.
//
#define TBS_E_BUFFER_TOO_LARGE _HRESULT_TYPEDEF_(0x8028400EL)

//
// MessageId: TBS_E_TPM_NOT_FOUND
//
// MessageText:
//
// A compatible Trusted Platform Module (TPM) Security Device cannot be found on this computer.
//
#define TBS_E_TPM_NOT_FOUND _HRESULT_TYPEDEF_(0x8028400FL)

//
// MessageId: TBS_E_SERVICE_DISABLED
//
// MessageText:
//
// The TBS service has been disabled.
//
#define TBS_E_SERVICE_DISABLED _HRESULT_TYPEDEF_(0x80284010L)

//
// MessageId: TBS_E_NO_EVENT_LOG
//
// MessageText:
//
// No TCG event log is available.
//
#define TBS_E_NO_EVENT_LOG _HRESULT_TYPEDEF_(0x80284011L)

//
// TPM API error codes {0x0100..0x01ff}
//
//
// MessageId: TPMAPI_E_INVALID_STATE
//
// MessageText:
//
// The command buffer is not in the correct state.
//
#define TPMAPI_E_INVALID_STATE _HRESULT_TYPEDEF_(0x80290100L)

//
// MessageId: TPMAPI_E_NOT_ENOUGH_DATA
//
// MessageText:
//
// The command buffer does not contain enough data to satisfy the request.
//
#define TPMAPI_E_NOT_ENOUGH_DATA _HRESULT_TYPEDEF_(0x80290101L)

//
// MessageId: TPMAPI_E_TOO_MUCH_DATA
//
// MessageText:
//
// The command buffer cannot contain any more data.
//
#define TPMAPI_E_TOO_MUCH_DATA _HRESULT_TYPEDEF_(0x80290102L)

//
// MessageId: TPMAPI_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// One or more output parameters was NULL or invalid.
//
#define TPMAPI_E_INVALID_OUTPUT_POINTER _HRESULT_TYPEDEF_(0x80290103L)

//
// MessageId: TPMAPI_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more input parameters is invalid.
//
#define TPMAPI_E_INVALID_PARAMETER _HRESULT_TYPEDEF_(0x80290104L)

//
// MessageId: TPMAPI_E_OUT_OF_MEMORY
//
// MessageText:
//
// Not enough memory was available to satisfy the request.
//
#define TPMAPI_E_OUT_OF_MEMORY _HRESULT_TYPEDEF_(0x80290105L)

//
// MessageId: TPMAPI_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The specified buffer was too small.
//
#define TPMAPI_E_BUFFER_TOO_SMALL _HRESULT_TYPEDEF_(0x80290106L)

//
// MessageId: TPMAPI_E_INTERNAL_ERROR
//
// MessageText:
//
// An internal error was detected.
//
#define TPMAPI_E_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x80290107L)

//
// MessageId: TPMAPI_E_ACCESS_DENIED
//
// MessageText:
//
// The caller does not have the appropriate rights to perform the requested operation.
//
#define TPMAPI_E_ACCESS_DENIED _HRESULT_TYPEDEF_(0x80290108L)

//
// MessageId: TPMAPI_E_AUTHORIZATION_FAILED
//
// MessageText:
//
// The specified authorization information was invalid.
//
#define TPMAPI_E_AUTHORIZATION_FAILED _HRESULT_TYPEDEF_(0x80290109L)

//
// MessageId: TPMAPI_E_INVALID_CONTEXT_HANDLE
//
// MessageText:
//
// The specified context handle was not valid.
//
#define TPMAPI_E_INVALID_CONTEXT_HANDLE _HRESULT_TYPEDEF_(0x8029010AL)

//
// MessageId: TPMAPI_E_TBS_COMMUNICATION_ERROR
//
// MessageText:
//
// An error occurred while communicating with the TBS.
//
#define TPMAPI_E_TBS_COMMUNICATION_ERROR _HRESULT_TYPEDEF_(0x8029010BL)

//
// MessageId: TPMAPI_E_TPM_COMMAND_ERROR
//
// MessageText:
//
// The TPM returned an unexpected result.
//
#define TPMAPI_E_TPM_COMMAND_ERROR _HRESULT_TYPEDEF_(0x8029010CL)

//
// MessageId: TPMAPI_E_MESSAGE_TOO_LARGE
//
// MessageText:
//
// The message was too large for the encoding scheme.
//
#define TPMAPI_E_MESSAGE_TOO_LARGE _HRESULT_TYPEDEF_(0x8029010DL)

//
// MessageId: TPMAPI_E_INVALID_ENCODING
//
// MessageText:
//
// The encoding in the blob was not recognized.
//
#define TPMAPI_E_INVALID_ENCODING _HRESULT_TYPEDEF_(0x8029010EL)

//
// MessageId: TPMAPI_E_INVALID_KEY_SIZE
//
// MessageText:
//
// The key size is not valid.
//
#define TPMAPI_E_INVALID_KEY_SIZE _HRESULT_TYPEDEF_(0x8029010FL)

//
// MessageId: TPMAPI_E_ENCRYPTION_FAILED
//
// MessageText:
//
// The encryption operation failed.
//
#define TPMAPI_E_ENCRYPTION_FAILED _HRESULT_TYPEDEF_(0x80290110L)

//
// MessageId: TPMAPI_E_INVALID_KEY_PARAMS
//
// MessageText:
//
// The key parameters structure was not valid
//
#define TPMAPI_E_INVALID_KEY_PARAMS _HRESULT_TYPEDEF_(0x80290111L)

//
// MessageId: TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB
//
// MessageText:
//
// The requested supplied data does not appear to be a valid migration authorization blob.
//
#define TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB _HRESULT_TYPEDEF_(0x80290112L)

//
// MessageId: TPMAPI_E_INVALID_PCR_INDEX
//
// MessageText:
//
// The specified PCR index was invalid
//
#define TPMAPI_E_INVALID_PCR_INDEX _HRESULT_TYPEDEF_(0x80290113L)

//
// MessageId: TPMAPI_E_INVALID_DELEGATE_BLOB
//
// MessageText:
//
// The data given does not appear to be a valid delegate blob.
//
#define TPMAPI_E_INVALID_DELEGATE_BLOB _HRESULT_TYPEDEF_(0x80290114L)

//
// MessageId: TPMAPI_E_INVALID_CONTEXT_PARAMS
//
// MessageText:
//
// One or more of the specified context parameters was not valid.
//
#define TPMAPI_E_INVALID_CONTEXT_PARAMS _HRESULT_TYPEDEF_(0x80290115L)

//
// MessageId: TPMAPI_E_INVALID_KEY_BLOB
//
// MessageText:
//
// The data given does not appear to be a valid key blob
//
#define TPMAPI_E_INVALID_KEY_BLOB _HRESULT_TYPEDEF_(0x80290116L)

//
// MessageId: TPMAPI_E_INVALID_PCR_DATA
//
// MessageText:
//
// The specified PCR data was invalid.
//
#define TPMAPI_E_INVALID_PCR_DATA _HRESULT_TYPEDEF_(0x80290117L)

//
// MessageId: TPMAPI_E_INVALID_OWNER_AUTH
//
// MessageText:
//
// The format of the owner auth data was invalid.
//
#define TPMAPI_E_INVALID_OWNER_AUTH _HRESULT_TYPEDEF_(0x80290118L)

//
// MessageId: TPMAPI_E_FIPS_RNG_CHECK_FAILED
//
// MessageText:
//
// The random number generated did not pass FIPS RNG check.
//
#define TPMAPI_E_FIPS_RNG_CHECK_FAILED _HRESULT_TYPEDEF_(0x80290119L)

//
// MessageId: TPMAPI_E_EMPTY_TCG_LOG
//
// MessageText:
//
// The TCG Event Log does not contain any data.
//
#define TPMAPI_E_EMPTY_TCG_LOG _HRESULT_TYPEDEF_(0x8029011AL)

//
// MessageId: TPMAPI_E_INVALID_TCG_LOG_ENTRY
//
// MessageText:
//
// An entry in the TCG Event Log was invalid.
//
#define TPMAPI_E_INVALID_TCG_LOG_ENTRY _HRESULT_TYPEDEF_(0x8029011BL)

//
// MessageId: TPMAPI_E_TCG_SEPARATOR_ABSENT
//
// MessageText:
//
// A TCG Separator was not found.
//
#define TPMAPI_E_TCG_SEPARATOR_ABSENT _HRESULT_TYPEDEF_(0x8029011CL)

//
// MessageId: TPMAPI_E_TCG_INVALID_DIGEST_ENTRY
//
// MessageText:
//
// A digest value in a TCG Log entry did not match hashed data.
//
#define TPMAPI_E_TCG_INVALID_DIGEST_ENTRY _HRESULT_TYPEDEF_(0x8029011DL)

//
// TBS implementation error codes {0x0200..0x02ff}
//
//
// MessageId: TBSIMP_E_BUFFER_TOO_SMALL
//
// MessageText:
//
// The specified buffer was too small.
//
#define TBSIMP_E_BUFFER_TOO_SMALL _HRESULT_TYPEDEF_(0x80290200L)

//
// MessageId: TBSIMP_E_CLEANUP_FAILED
//
// MessageText:
//
// The context could not be cleaned up.
//
#define TBSIMP_E_CLEANUP_FAILED _HRESULT_TYPEDEF_(0x80290201L)

//
// MessageId: TBSIMP_E_INVALID_CONTEXT_HANDLE
//
// MessageText:
//
// The specified context handle is invalid.
//
#define TBSIMP_E_INVALID_CONTEXT_HANDLE _HRESULT_TYPEDEF_(0x80290202L)

//
// MessageId: TBSIMP_E_INVALID_CONTEXT_PARAM
//
// MessageText:
//
// An invalid context parameter was specified.
//
#define TBSIMP_E_INVALID_CONTEXT_PARAM _HRESULT_TYPEDEF_(0x80290203L)

//
// MessageId: TBSIMP_E_TPM_ERROR
//
// MessageText:
//
// An error occurred while communicating with the TPM
//
#define TBSIMP_E_TPM_ERROR _HRESULT_TYPEDEF_(0x80290204L)

//
// MessageId: TBSIMP_E_HASH_BAD_KEY
//
// MessageText:
//
// No entry with the specified key was found.
//
#define TBSIMP_E_HASH_BAD_KEY _HRESULT_TYPEDEF_(0x80290205L)

//
// MessageId: TBSIMP_E_DUPLICATE_VHANDLE
//
// MessageText:
//
// The specified virtual handle matches a virtual handle already in use.
//
#define TBSIMP_E_DUPLICATE_VHANDLE _HRESULT_TYPEDEF_(0x80290206L)

//
// MessageId: TBSIMP_E_INVALID_OUTPUT_POINTER
//
// MessageText:
//
// The pointer to the returned handle location was NULL or invalid
//
#define TBSIMP_E_INVALID_OUTPUT_POINTER _HRESULT_TYPEDEF_(0x80290207L)

//
// MessageId: TBSIMP_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more parameters is invalid
//
#define TBSIMP_E_INVALID_PARAMETER _HRESULT_TYPEDEF_(0x80290208L)

//
// MessageId: TBSIMP_E_RPC_INIT_FAILED
//
// MessageText:
//
// The RPC subsystem could not be initialized.
//
#define TBSIMP_E_RPC_INIT_FAILED _HRESULT_TYPEDEF_(0x80290209L)

//
// MessageId: TBSIMP_E_SCHEDULER_NOT_RUNNING
//
// MessageText:
//
// The TBS scheduler is not running.
//
#define TBSIMP_E_SCHEDULER_NOT_RUNNING _HRESULT_TYPEDEF_(0x8029020AL)

//
// MessageId: TBSIMP_E_COMMAND_CANCELED
//
// MessageText:
//
// The command was canceled.
//
#define TBSIMP_E_COMMAND_CANCELED _HRESULT_TYPEDEF_(0x8029020BL)

//
// MessageId: TBSIMP_E_OUT_OF_MEMORY
//
// MessageText:
//
// There was not enough memory to fulfill the request
//
#define TBSIMP_E_OUT_OF_MEMORY _HRESULT_TYPEDEF_(0x8029020CL)

//
// MessageId: TBSIMP_E_LIST_NO_MORE_ITEMS
//
// MessageText:
//
// The specified list is empty, or the iteration has reached the end of the list.
//
#define TBSIMP_E_LIST_NO_MORE_ITEMS _HRESULT_TYPEDEF_(0x8029020DL)

//
// MessageId: TBSIMP_E_LIST_NOT_FOUND
//
// MessageText:
//
// The specified item was not found in the list.
//
#define TBSIMP_E_LIST_NOT_FOUND _HRESULT_TYPEDEF_(0x8029020EL)

//
// MessageId: TBSIMP_E_NOT_ENOUGH_SPACE
//
// MessageText:
//
// The TPM does not have enough space to load the requested resource.
//
#define TBSIMP_E_NOT_ENOUGH_SPACE _HRESULT_TYPEDEF_(0x8029020FL)

//
// MessageId: TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS
//
// MessageText:
//
// There are too many TPM contexts in use.
//
#define TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS _HRESULT_TYPEDEF_(0x80290210L)

//
// MessageId: TBSIMP_E_COMMAND_FAILED
//
// MessageText:
//
// The TPM command failed.
//
#define TBSIMP_E_COMMAND_FAILED _HRESULT_TYPEDEF_(0x80290211L)

//
// MessageId: TBSIMP_E_UNKNOWN_ORDINAL
//
// MessageText:
//
// The TBS does not recognize the specified ordinal.
//
#define TBSIMP_E_UNKNOWN_ORDINAL _HRESULT_TYPEDEF_(0x80290212L)

//
// MessageId: TBSIMP_E_RESOURCE_EXPIRED
//
// MessageText:
//
// The requested resource is no longer available.
//
#define TBSIMP_E_RESOURCE_EXPIRED _HRESULT_TYPEDEF_(0x80290213L)

//
// MessageId: TBSIMP_E_INVALID_RESOURCE
//
// MessageText:
//
// The resource type did not match.
//
#define TBSIMP_E_INVALID_RESOURCE _HRESULT_TYPEDEF_(0x80290214L)

//
// MessageId: TBSIMP_E_NOTHING_TO_UNLOAD
//
// MessageText:
//
// No resources can be unloaded.
//
#define TBSIMP_E_NOTHING_TO_UNLOAD _HRESULT_TYPEDEF_(0x80290215L)

//
// MessageId: TBSIMP_E_HASH_TABLE_FULL
//
// MessageText:
//
// No new entries can be added to the hash table.
//
#define TBSIMP_E_HASH_TABLE_FULL _HRESULT_TYPEDEF_(0x80290216L)

//
// MessageId: TBSIMP_E_TOO_MANY_TBS_CONTEXTS
//
// MessageText:
//
// A new TBS context could not be created because there are too many open contexts.
//
#define TBSIMP_E_TOO_MANY_TBS_CONTEXTS _HRESULT_TYPEDEF_(0x80290217L)

//
// MessageId: TBSIMP_E_TOO_MANY_RESOURCES
//
// MessageText:
//
// A new virtual resource could not be created because there are too many open virtual resources.
//
#define TBSIMP_E_TOO_MANY_RESOURCES _HRESULT_TYPEDEF_(0x80290218L)

//
// MessageId: TBSIMP_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The physical presence interface is not supported.
//
#define TBSIMP_E_PPI_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80290219L)

//
// MessageId: TBSIMP_E_TPM_INCOMPATIBLE
//
// MessageText:
//
// TBS is not compatible with the version of TPM found on the system.
//
#define TBSIMP_E_TPM_INCOMPATIBLE _HRESULT_TYPEDEF_(0x8029021AL)

//
// MessageId: TBSIMP_E_NO_EVENT_LOG
//
// MessageText:
//
// No TCG event log is available.
//
#define TBSIMP_E_NO_EVENT_LOG _HRESULT_TYPEDEF_(0x8029021BL)

//
// TPM Physical Presence implementation error codes {0x0300..0x03ff}
//
//
// MessageId: TPM_E_PPI_ACPI_FAILURE
//
// MessageText:
//
// A general error was detected when attempting to acquire the BIOS's response to a Physical Presence command.
//
#define TPM_E_PPI_ACPI_FAILURE _HRESULT_TYPEDEF_(0x80290300L)

//
// MessageId: TPM_E_PPI_USER_ABORT
//
// MessageText:
//
// The user failed to confirm the TPM operation request.
//
#define TPM_E_PPI_USER_ABORT _HRESULT_TYPEDEF_(0x80290301L)

//
// MessageId: TPM_E_PPI_BIOS_FAILURE
//
// MessageText:
//
// The BIOS failure prevented the successful execution of the requested TPM operation (e.g. invalid TPM operation request, BIOS communication error with the TPM).
//
#define TPM_E_PPI_BIOS_FAILURE _HRESULT_TYPEDEF_(0x80290302L)

//
// MessageId: TPM_E_PPI_NOT_SUPPORTED
//
// MessageText:
//
// The BIOS does not support the physical presence interface.
//
#define TPM_E_PPI_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80290303L)

//
// =======================================================
// Facility Performance Logs & Alerts (PLA) Error Messages
// =======================================================
//
//
// MessageId: PLA_E_DCS_NOT_FOUND
//
// MessageText:
//
// Data Collector Set was not found.
//
#define PLA_E_DCS_NOT_FOUND _HRESULT_TYPEDEF_(0x80300002L)

//
// MessageId: PLA_E_DCS_IN_USE
//
// MessageText:
//
// The Data Collector Set or one of its dependencies is already in use.
//
#define PLA_E_DCS_IN_USE _HRESULT_TYPEDEF_(0x803000AAL)

//
// MessageId: PLA_E_TOO_MANY_FOLDERS
//
// MessageText:
//
// Unable to start Data Collector Set because there are too many folders.
//
#define PLA_E_TOO_MANY_FOLDERS _HRESULT_TYPEDEF_(0x80300045L)

//
// MessageId: PLA_E_NO_MIN_DISK
//
// MessageText:
//
// Not enough free disk space to start Data Collector Set.
//
#define PLA_E_NO_MIN_DISK _HRESULT_TYPEDEF_(0x80300070L)

//
// MessageId: PLA_E_DCS_ALREADY_EXISTS
//
// MessageText:
//
// Data Collector Set already exists.
//
#define PLA_E_DCS_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x803000B7L)

//
// MessageId: PLA_S_PROPERTY_IGNORED
//
// MessageText:
//
// Property value will be ignored.
//
#define PLA_S_PROPERTY_IGNORED _HRESULT_TYPEDEF_(0x00300100L)

//
// MessageId: PLA_E_PROPERTY_CONFLICT
//
// MessageText:
//
// Property value conflict.
//
#define PLA_E_PROPERTY_CONFLICT _HRESULT_TYPEDEF_(0x80300101L)

//
// MessageId: PLA_E_DCS_SINGLETON_REQUIRED
//
// MessageText:
//
// The current configuration for this Data Collector Set requires that it contain exactly one Data Collector.
//
#define PLA_E_DCS_SINGLETON_REQUIRED _HRESULT_TYPEDEF_(0x80300102L)

//
// MessageId: PLA_E_CREDENTIALS_REQUIRED
//
// MessageText:
//
// A user account is required in order to commit the current Data Collector Set properties.
//
#define PLA_E_CREDENTIALS_REQUIRED _HRESULT_TYPEDEF_(0x80300103L)

//
// MessageId: PLA_E_DCS_NOT_RUNNING
//
// MessageText:
//
// Data Collector Set is not running.
//
#define PLA_E_DCS_NOT_RUNNING _HRESULT_TYPEDEF_(0x80300104L)

//
// MessageId: PLA_E_CONFLICT_INCL_EXCL_API
//
// MessageText:
//
// A conflict was detected in the list of include/exclude APIs. Do not specify the same API in both the include list and the exclude list.
//
#define PLA_E_CONFLICT_INCL_EXCL_API _HRESULT_TYPEDEF_(0x80300105L)

//
// MessageId: PLA_E_NETWORK_EXE_NOT_VALID
//
// MessageText:
//
// The executable path you have specified refers to a network share or UNC path.
//
#define PLA_E_NETWORK_EXE_NOT_VALID _HRESULT_TYPEDEF_(0x80300106L)

//
// MessageId: PLA_E_EXE_ALREADY_CONFIGURED
//
// MessageText:
//
// The executable path you have specified is already configured for API tracing.
//
#define PLA_E_EXE_ALREADY_CONFIGURED _HRESULT_TYPEDEF_(0x80300107L)

//
// MessageId: PLA_E_EXE_PATH_NOT_VALID
//
// MessageText:
//
// The executable path you have specified does not exist. Verify that the specified path is correct.
//
#define PLA_E_EXE_PATH_NOT_VALID _HRESULT_TYPEDEF_(0x80300108L)

//
// MessageId: PLA_E_DC_ALREADY_EXISTS
//
// MessageText:
//
// Data Collector already exists.
//
#define PLA_E_DC_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x80300109L)

//
// MessageId: PLA_E_DCS_START_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the Data Collector Set start notification has timed out.
//
#define PLA_E_DCS_START_WAIT_TIMEOUT _HRESULT_TYPEDEF_(0x8030010AL)

//
// MessageId: PLA_E_DC_START_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the Data Collector to start has timed out.
//
#define PLA_E_DC_START_WAIT_TIMEOUT _HRESULT_TYPEDEF_(0x8030010BL)

//
// MessageId: PLA_E_REPORT_WAIT_TIMEOUT
//
// MessageText:
//
// The wait for the report generation tool to finish has timed out.
//
#define PLA_E_REPORT_WAIT_TIMEOUT _HRESULT_TYPEDEF_(0x8030010CL)

//
// MessageId: PLA_E_NO_DUPLICATES
//
// MessageText:
//
// Duplicate items are not allowed.
//
#define PLA_E_NO_DUPLICATES _HRESULT_TYPEDEF_(0x8030010DL)

//
// MessageId: PLA_E_EXE_FULL_PATH_REQUIRED
//
// MessageText:
//
// When specifying the executable that you want to trace, you must specify a full path to the executable and not just a filename.
//
#define PLA_E_EXE_FULL_PATH_REQUIRED _HRESULT_TYPEDEF_(0x8030010EL)

//
// MessageId: PLA_E_INVALID_SESSION_NAME
//
// MessageText:
//
// The session name provided is invalid.
//
#define PLA_E_INVALID_SESSION_NAME _HRESULT_TYPEDEF_(0x8030010FL)

//
// MessageId: PLA_E_PLA_CHANNEL_NOT_ENABLED
//
// MessageText:
//
// The Event Log channel Microsoft-Windows-Diagnosis-PLA/Operational must be enabled to perform this operation.
//
#define PLA_E_PLA_CHANNEL_NOT_ENABLED _HRESULT_TYPEDEF_(0x80300110L)

//
// MessageId: PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED
//
// MessageText:
//
// The Event Log channel Microsoft-Windows-TaskScheduler must be enabled to perform this operation.
//
#define PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED _HRESULT_TYPEDEF_(0x80300111L)

//
// MessageId: PLA_E_RULES_MANAGER_FAILED
//
// MessageText:
//
// The execution of the Rules Manager failed.
//
#define PLA_E_RULES_MANAGER_FAILED _HRESULT_TYPEDEF_(0x80300112L)

//
// MessageId: PLA_E_CABAPI_FAILURE
//
// MessageText:
//
// An error occurred while attempting to compress or extract the data.
//
#define PLA_E_CABAPI_FAILURE _HRESULT_TYPEDEF_(0x80300113L)

//
// =======================================================
// Full Volume Encryption Error Messages
// =======================================================
//
//
// MessageId: FVE_E_LOCKED_VOLUME
//
// MessageText:
//
// This drive is locked by BitLocker Drive Encryption. You must unlock this drive from Control Panel.
//
#define FVE_E_LOCKED_VOLUME _HRESULT_TYPEDEF_(0x80310000L)

//
// MessageId: FVE_E_NOT_ENCRYPTED
//
// MessageText:
//
// This drive is not encrypted.
//
#define FVE_E_NOT_ENCRYPTED _HRESULT_TYPEDEF_(0x80310001L)

//
// MessageId: FVE_E_NO_TPM_BIOS
//
// MessageText:
//
// The BIOS did not correctly communicate with the Trusted Platform Module (TPM). Contact the computer manufacturer for BIOS upgrade instructions.
//
#define FVE_E_NO_TPM_BIOS _HRESULT_TYPEDEF_(0x80310002L)

//
// MessageId: FVE_E_NO_MBR_METRIC
//
// MessageText:
//
// The BIOS did not correctly communicate with the master boot record (MBR). Contact the computer manufacturer for BIOS upgrade instructions.
//
#define FVE_E_NO_MBR_METRIC _HRESULT_TYPEDEF_(0x80310003L)

//
// MessageId: FVE_E_NO_BOOTSECTOR_METRIC
//
// MessageText:
//
// A required TPM measurement is missing. If there is a bootable CD or DVD in your computer, remove it, restart the computer, and turn on BitLocker again. If the problem persists, ensure the master boot record is up to date.
//
#define FVE_E_NO_BOOTSECTOR_METRIC _HRESULT_TYPEDEF_(0x80310004L)

//
// MessageId: FVE_E_NO_BOOTMGR_METRIC
//
// MessageText:
//
// The boot sector of this drive is not compatible with BitLocker Drive Encryption. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot manager (BOOTMGR).
//
#define FVE_E_NO_BOOTMGR_METRIC _HRESULT_TYPEDEF_(0x80310005L)

//
// MessageId: FVE_E_WRONG_BOOTMGR
//
// MessageText:
//
// The boot manager of this operating system is not compatible with BitLocker Drive Encryption. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot manager (BOOTMGR).
//
#define FVE_E_WRONG_BOOTMGR _HRESULT_TYPEDEF_(0x80310006L)

//
// MessageId: FVE_E_SECURE_KEY_REQUIRED
//
// MessageText:
//
// At least one secure key protector is required for this operation to be performed.
//
#define FVE_E_SECURE_KEY_REQUIRED _HRESULT_TYPEDEF_(0x80310007L)

//
// MessageId: FVE_E_NOT_ACTIVATED
//
// MessageText:
//
// BitLocker Drive Encryption is not enabled on this drive. Turn on BitLocker.
//
#define FVE_E_NOT_ACTIVATED _HRESULT_TYPEDEF_(0x80310008L)

//
// MessageId: FVE_E_ACTION_NOT_ALLOWED
//
// MessageText:
//
// BitLocker Drive Encryption cannot perform the requested action. This condition may occur when two requests are issued at the same time. Wait a few moments and then try the action again.
//
#define FVE_E_ACTION_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310009L)

//
// MessageId: FVE_E_AD_SCHEMA_NOT_INSTALLED
//
// MessageText:
//
// The Active Directory Domain Services forest does not contain the required attributes and classes to host BitLocker Drive Encryption or Trusted Platform Module information. Contact your domain administrator to verify that any required BitLocker Active Directory schema extensions have been installed.
//
#define FVE_E_AD_SCHEMA_NOT_INSTALLED _HRESULT_TYPEDEF_(0x8031000AL)

//
// MessageId: FVE_E_AD_INVALID_DATATYPE
//
// MessageText:
//
// The type of the data obtained from Active Directory was not expected. The BitLocker recovery information may be missing or corrupted.
//
#define FVE_E_AD_INVALID_DATATYPE _HRESULT_TYPEDEF_(0x8031000BL)

//
// MessageId: FVE_E_AD_INVALID_DATASIZE
//
// MessageText:
//
// The size of the data obtained from Active Directory was not expected. The BitLocker recovery information may be missing or corrupted.
//
#define FVE_E_AD_INVALID_DATASIZE _HRESULT_TYPEDEF_(0x8031000CL)

//
// MessageId: FVE_E_AD_NO_VALUES
//
// MessageText:
//
// The attribute read from Active Directory does not contain any values. The BitLocker recovery information may be missing or corrupted.
//
#define FVE_E_AD_NO_VALUES _HRESULT_TYPEDEF_(0x8031000DL)

//
// MessageId: FVE_E_AD_ATTR_NOT_SET
//
// MessageText:
//
// The attribute was not set. Verify that you are logged on with a domain account that has the ability to write information to Active Directory objects.
//
#define FVE_E_AD_ATTR_NOT_SET _HRESULT_TYPEDEF_(0x8031000EL)

//
// MessageId: FVE_E_AD_GUID_NOT_FOUND
//
// MessageText:
//
// The specified attribute cannot be found in Active Directory Domain Services. Contact your domain administrator to verify that any required BitLocker Active Directory schema extensions have been installed.
//
#define FVE_E_AD_GUID_NOT_FOUND _HRESULT_TYPEDEF_(0x8031000FL)

//
// MessageId: FVE_E_BAD_INFORMATION
//
// MessageText:
//
// The BitLocker metadata for the encrypted drive is not valid. You can attempt to repair the drive to restore access.
//
#define FVE_E_BAD_INFORMATION _HRESULT_TYPEDEF_(0x80310010L)

//
// MessageId: FVE_E_TOO_SMALL
//
// MessageText:
//
// The drive cannot be encrypted because it does not have enough free space. Delete any unnecessary data on the drive to create additional free space and then try again.
//
#define FVE_E_TOO_SMALL _HRESULT_TYPEDEF_(0x80310011L)

//
// MessageId: FVE_E_SYSTEM_VOLUME
//
// MessageText:
//
// The drive cannot be encrypted because it contains system boot information. Create a separate partition for use as the system drive that contains the boot information and a second partition for use as the operating system drive and then encrypt the operating system drive.
//
#define FVE_E_SYSTEM_VOLUME _HRESULT_TYPEDEF_(0x80310012L)

//
// MessageId: FVE_E_FAILED_WRONG_FS
//
// MessageText:
//
// The drive cannot be encrypted because the file system is not supported.
//
#define FVE_E_FAILED_WRONG_FS _HRESULT_TYPEDEF_(0x80310013L)

//
// MessageId: FVE_E_BAD_PARTITION_SIZE
//
// MessageText:
//
// The file system size is larger than the partition size in the partition table. This drive may be corrupt or may have been tampered with. To use it with BitLocker, you must reformat the partition.
//
#define FVE_E_BAD_PARTITION_SIZE _HRESULT_TYPEDEF_(0x80310014L)

//
// MessageId: FVE_E_NOT_SUPPORTED
//
// MessageText:
//
// This drive cannot be encrypted.
//
#define FVE_E_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80310015L)

//
// MessageId: FVE_E_BAD_DATA
//
// MessageText:
//
// The data is not valid.
//
#define FVE_E_BAD_DATA _HRESULT_TYPEDEF_(0x80310016L)

//
// MessageId: FVE_E_VOLUME_NOT_BOUND
//
// MessageText:
//
// The data drive specified is not set to automatically unlock on the current computer and cannot be unlocked automatically.
//
#define FVE_E_VOLUME_NOT_BOUND _HRESULT_TYPEDEF_(0x80310017L)

//
// MessageId: FVE_E_TPM_NOT_OWNED
//
// MessageText:
//
// You must initialize the Trusted Platform Module (TPM) before you can use BitLocker Drive Encryption.
//
#define FVE_E_TPM_NOT_OWNED _HRESULT_TYPEDEF_(0x80310018L)

//
// MessageId: FVE_E_NOT_DATA_VOLUME
//
// MessageText:
//
// The operation attempted cannot be performed on an operating system drive.
//
#define FVE_E_NOT_DATA_VOLUME _HRESULT_TYPEDEF_(0x80310019L)

//
// MessageId: FVE_E_AD_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The buffer supplied to a function was insufficient to contain the returned data. Increase the buffer size before running the function again.
//
#define FVE_E_AD_INSUFFICIENT_BUFFER _HRESULT_TYPEDEF_(0x8031001AL)

//
// MessageId: FVE_E_CONV_READ
//
// MessageText:
//
// A read operation failed while converting the drive. The drive was not converted. Please re-enable BitLocker.
//
#define FVE_E_CONV_READ _HRESULT_TYPEDEF_(0x8031001BL)

//
// MessageId: FVE_E_CONV_WRITE
//
// MessageText:
//
// A write operation failed while converting the drive. The drive was not converted. Please re-enable BitLocker.
//
#define FVE_E_CONV_WRITE _HRESULT_TYPEDEF_(0x8031001CL)

//
// MessageId: FVE_E_KEY_REQUIRED
//
// MessageText:
//
// One or more BitLocker key protectors are required. You cannot delete the last key on this drive.
//
#define FVE_E_KEY_REQUIRED _HRESULT_TYPEDEF_(0x8031001DL)

//
// MessageId: FVE_E_CLUSTERING_NOT_SUPPORTED
//
// MessageText:
//
// Cluster configurations are not supported by BitLocker Drive Encryption.
//
#define FVE_E_CLUSTERING_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8031001EL)

//
// MessageId: FVE_E_VOLUME_BOUND_ALREADY
//
// MessageText:
//
// The drive specified is already configured to be automatically unlocked on the current computer.
//
#define FVE_E_VOLUME_BOUND_ALREADY _HRESULT_TYPEDEF_(0x8031001FL)

//
// MessageId: FVE_E_OS_NOT_PROTECTED
//
// MessageText:
//
// The operating system drive is not protected by BitLocker Drive Encryption.
//
#define FVE_E_OS_NOT_PROTECTED _HRESULT_TYPEDEF_(0x80310020L)

//
// MessageId: FVE_E_PROTECTION_DISABLED
//
// MessageText:
//
// BitLocker Drive Encryption has been suspended on this drive. All BitLocker key protectors configured for this drive are effectively disabled, and the drive will be automatically unlocked using an unencrypted (clear) key.
//
#define FVE_E_PROTECTION_DISABLED _HRESULT_TYPEDEF_(0x80310021L)

//
// MessageId: FVE_E_RECOVERY_KEY_REQUIRED
//
// MessageText:
//
// The drive you are attempting to lock does not have any key protectors available for encryption because BitLocker protection is currently suspended. Re-enable BitLocker to lock this drive.
//
#define FVE_E_RECOVERY_KEY_REQUIRED _HRESULT_TYPEDEF_(0x80310022L)

//
// MessageId: FVE_E_FOREIGN_VOLUME
//
// MessageText:
//
// BitLocker cannot use the Trusted Platform Module (TPM) to protect a data drive. TPM protection can only be used with the operating system drive.
//
#define FVE_E_FOREIGN_VOLUME _HRESULT_TYPEDEF_(0x80310023L)

//
// MessageId: FVE_E_OVERLAPPED_UPDATE
//
// MessageText:
//
// The BitLocker metadata for the encrypted drive cannot be updated because it was locked for updating by another process. Please try this process again.
//
#define FVE_E_OVERLAPPED_UPDATE _HRESULT_TYPEDEF_(0x80310024L)

//
// MessageId: FVE_E_TPM_SRK_AUTH_NOT_ZERO
//
// MessageText:
//
// The authorization data for the storage root key (SRK) of the Trusted Platform Module (TPM) is not zero and is therefore incompatible with BitLocker. Please initialize the TPM before attempting to use it with BitLocker.
//
#define FVE_E_TPM_SRK_AUTH_NOT_ZERO _HRESULT_TYPEDEF_(0x80310025L)

//
// MessageId: FVE_E_FAILED_SECTOR_SIZE
//
// MessageText:
//
// The drive encryption algorithm cannot be used on this sector size.
//
#define FVE_E_FAILED_SECTOR_SIZE _HRESULT_TYPEDEF_(0x80310026L)

//
// MessageId: FVE_E_FAILED_AUTHENTICATION
//
// MessageText:
//
// The drive cannot be unlocked with the key provided. Confirm that you have provided the correct key and try again.
//
#define FVE_E_FAILED_AUTHENTICATION _HRESULT_TYPEDEF_(0x80310027L)

//
// MessageId: FVE_E_NOT_OS_VOLUME
//
// MessageText:
//
// The drive specified is not the operating system drive.
//
#define FVE_E_NOT_OS_VOLUME _HRESULT_TYPEDEF_(0x80310028L)

//
// MessageId: FVE_E_AUTOUNLOCK_ENABLED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be turned off on the operating system drive until the auto unlock feature has been disabled for the fixed data drives and removable data drives associated with this computer.
//
#define FVE_E_AUTOUNLOCK_ENABLED _HRESULT_TYPEDEF_(0x80310029L)

//
// MessageId: FVE_E_WRONG_BOOTSECTOR
//
// MessageText:
//
// The system partition boot sector does not perform Trusted Platform Module (TPM) measurements. Use the Bootrec.exe tool in the Windows Recovery Environment to update or repair the boot sector.
//
#define FVE_E_WRONG_BOOTSECTOR _HRESULT_TYPEDEF_(0x8031002AL)

//
// MessageId: FVE_E_WRONG_SYSTEM_FS
//
// MessageText:
//
// BitLocker Drive Encryption operating system drives must be formatted with the NTFS file system in order to be encrypted. Convert the drive to NTFS, and then turn on BitLocker.
//
#define FVE_E_WRONG_SYSTEM_FS _HRESULT_TYPEDEF_(0x8031002BL)

//
// MessageId: FVE_E_POLICY_PASSWORD_REQUIRED
//
// MessageText:
//
// Group Policy settings require that a recovery password be specified before encrypting the drive.
//
#define FVE_E_POLICY_PASSWORD_REQUIRED _HRESULT_TYPEDEF_(0x8031002CL)

//
// MessageId: FVE_E_CANNOT_SET_FVEK_ENCRYPTED
//
// MessageText:
//
// The drive encryption algorithm and key cannot be set on a previously encrypted drive. To encrypt this drive with BitLocker Drive Encryption, remove the previous encryption and then turn on BitLocker.
//
#define FVE_E_CANNOT_SET_FVEK_ENCRYPTED _HRESULT_TYPEDEF_(0x8031002DL)

//
// MessageId: FVE_E_CANNOT_ENCRYPT_NO_KEY
//
// MessageText:
//
// BitLocker Drive Encryption cannot encrypt the specified drive because an encryption key is not available. Add a key protector to encrypt this drive.
//
#define FVE_E_CANNOT_ENCRYPT_NO_KEY _HRESULT_TYPEDEF_(0x8031002EL)

//
// MessageId: FVE_E_BOOTABLE_CDDVD
//
// MessageText:
//
// BitLocker Drive Encryption detected bootable media (CD or DVD) in the computer. Remove the media and restart the computer before configuring BitLocker.
//
#define FVE_E_BOOTABLE_CDDVD _HRESULT_TYPEDEF_(0x80310030L)

//
// MessageId: FVE_E_PROTECTOR_EXISTS
//
// MessageText:
//
// This key protector cannot be added. Only one key protector of this type is allowed for this drive.
//
#define FVE_E_PROTECTOR_EXISTS _HRESULT_TYPEDEF_(0x80310031L)

//
// MessageId: FVE_E_RELATIVE_PATH
//
// MessageText:
//
// The recovery password file was not found because a relative path was specified. Recovery passwords must be saved to a fully qualified path. Environment variables configured on the computer can be used in the path.
//
#define FVE_E_RELATIVE_PATH _HRESULT_TYPEDEF_(0x80310032L)

//
// MessageId: FVE_E_PROTECTOR_NOT_FOUND
//
// MessageText:
//
// The specified key protector was not found on the drive. Try another key protector.
//
#define FVE_E_PROTECTOR_NOT_FOUND _HRESULT_TYPEDEF_(0x80310033L)

//
// MessageId: FVE_E_INVALID_KEY_FORMAT
//
// MessageText:
//
// The recovery key provided is corrupt and cannot be used to access the drive. An alternative recovery method, such as recovery password, a data recovery agent, or a backup version of the recovery key must be used to recover access to the drive.
//
#define FVE_E_INVALID_KEY_FORMAT _HRESULT_TYPEDEF_(0x80310034L)

//
// MessageId: FVE_E_INVALID_PASSWORD_FORMAT
//
// MessageText:
//
// The format of the recovery password provided is invalid. BitLocker recovery passwords are 48 digits. Verify that the recovery password is in the correct format and then try again.
//
#define FVE_E_INVALID_PASSWORD_FORMAT _HRESULT_TYPEDEF_(0x80310035L)

//
// MessageId: FVE_E_FIPS_RNG_CHECK_FAILED
//
// MessageText:
//
// The random number generator check test failed.
//
#define FVE_E_FIPS_RNG_CHECK_FAILED _HRESULT_TYPEDEF_(0x80310036L)

//
// MessageId: FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents a local recovery password from being generated or used by BitLocker Drive Encryption. When operating in FIPS-compliant mode, BitLocker recovery options can be either a recovery key stored on a USB drive or recovery through a data recovery agent.
//
#define FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD _HRESULT_TYPEDEF_(0x80310037L)

//
// MessageId: FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents the recovery password from being saved to Active Directory. When operating in FIPS-compliant mode, BitLocker recovery options can be either a recovery key stored on a USB drive or recovery through a data recovery agent. Check your Group Policy settings configuration.
//
#define FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT _HRESULT_TYPEDEF_(0x80310038L)

//
// MessageId: FVE_E_NOT_DECRYPTED
//
// MessageText:
//
// The drive must be fully decrypted to complete this operation.
//
#define FVE_E_NOT_DECRYPTED _HRESULT_TYPEDEF_(0x80310039L)

//
// MessageId: FVE_E_INVALID_PROTECTOR_TYPE
//
// MessageText:
//
// The key protector specified cannot be used for this operation.
//
#define FVE_E_INVALID_PROTECTOR_TYPE _HRESULT_TYPEDEF_(0x8031003AL)

//
// MessageId: FVE_E_NO_PROTECTORS_TO_TEST
//
// MessageText:
//
// No key protectors exist on the drive to perform the hardware test.
//
#define FVE_E_NO_PROTECTORS_TO_TEST _HRESULT_TYPEDEF_(0x8031003BL)

//
// MessageId: FVE_E_KEYFILE_NOT_FOUND
//
// MessageText:
//
// The BitLocker startup key or recovery password cannot be found on the USB device. Verify that you have the correct USB device, that the USB device is plugged into the computer on an active USB port, restart the computer, and then try again. If the problem persists, contact the computer manufacturer for BIOS upgrade instructions.
//
#define FVE_E_KEYFILE_NOT_FOUND _HRESULT_TYPEDEF_(0x8031003CL)

//
// MessageId: FVE_E_KEYFILE_INVALID
//
// MessageText:
//
// The BitLocker startup key or recovery password file provided is corrupt or invalid. Verify that you have the correct startup key or recovery password file and try again.
//
#define FVE_E_KEYFILE_INVALID _HRESULT_TYPEDEF_(0x8031003DL)

//
// MessageId: FVE_E_KEYFILE_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the startup key or recovery password. Verify that you have the correct startup key or recovery password and try again.
//
#define FVE_E_KEYFILE_NO_VMK _HRESULT_TYPEDEF_(0x8031003EL)

//
// MessageId: FVE_E_TPM_DISABLED
//
// MessageText:
//
// The Trusted Platform Module (TPM) is disabled. The TPM must be enabled, initialized, and have valid ownership before it can be used with BitLocker Drive Encryption.
//
#define FVE_E_TPM_DISABLED _HRESULT_TYPEDEF_(0x8031003FL)

//
// MessageId: FVE_E_NOT_ALLOWED_IN_SAFE_MODE
//
// MessageText:
//
// The BitLocker configuration of the specified drive cannot be managed because this computer is currently operating in Safe Mode. While in Safe Mode, BitLocker Drive Encryption can only be used for recovery purposes.
//
#define FVE_E_NOT_ALLOWED_IN_SAFE_MODE _HRESULT_TYPEDEF_(0x80310040L)

//
// MessageId: FVE_E_TPM_INVALID_PCR
//
// MessageText:
//
// The Trusted Platform Module (TPM) was not able to unlock the drive because the system boot information has changed or a PIN was not provided correctly. Verify that the drive has not been tampered with and that changes to the system boot information were caused by a trusted source. After verifying that the drive is safe to access, use the BitLocker recovery console to unlock the drive and then suspend and resume BitLocker to update system boot information that BitLocker associates with this drive.
//
#define FVE_E_TPM_INVALID_PCR _HRESULT_TYPEDEF_(0x80310041L)

//
// MessageId: FVE_E_TPM_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the Trusted Platform Module (TPM).
//
#define FVE_E_TPM_NO_VMK _HRESULT_TYPEDEF_(0x80310042L)

//
// MessageId: FVE_E_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained from the Trusted Platform Module (TPM) and PIN.
//
#define FVE_E_PIN_INVALID _HRESULT_TYPEDEF_(0x80310043L)

//
// MessageId: FVE_E_AUTH_INVALID_APPLICATION
//
// MessageText:
//
// A boot application has changed since BitLocker Drive Encryption was enabled.
//
#define FVE_E_AUTH_INVALID_APPLICATION _HRESULT_TYPEDEF_(0x80310044L)

//
// MessageId: FVE_E_AUTH_INVALID_CONFIG
//
// MessageText:
//
// The Boot Configuration Data (BCD) settings have changed since BitLocker Drive Encryption was enabled.
//
#define FVE_E_AUTH_INVALID_CONFIG _HRESULT_TYPEDEF_(0x80310045L)

//
// MessageId: FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prohibits the use of unencrypted keys, which prevents BitLocker from being suspended on this drive. Please contact your domain administrator for more information.
//
#define FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310046L)

//
// MessageId: FVE_E_FS_NOT_EXTENDED
//
// MessageText:
//
// This drive cannot be encrypted by BitLocker Drive Encryption because the file system does not extend to the end of the drive. Repartition this drive and then try again.
//
#define FVE_E_FS_NOT_EXTENDED _HRESULT_TYPEDEF_(0x80310047L)

//
// MessageId: FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be enabled on the operating system drive. Contact the computer manufacturer for BIOS upgrade instructions.
//
#define FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80310048L)

//
// MessageId: FVE_E_NO_LICENSE
//
// MessageText:
//
// This version of Windows does not include BitLocker Drive Encryption. To use BitLocker Drive Encryption, please upgrade the operating system.
//
#define FVE_E_NO_LICENSE _HRESULT_TYPEDEF_(0x80310049L)

//
// MessageId: FVE_E_NOT_ON_STACK
//
// MessageText:
//
// BitLocker Drive Encryption cannot be used because critical BitLocker system files are missing or corrupted. Use Windows Startup Repair to restore these files to your computer.
//
#define FVE_E_NOT_ON_STACK _HRESULT_TYPEDEF_(0x8031004AL)

//
// MessageId: FVE_E_FS_MOUNTED
//
// MessageText:
//
// The drive cannot be locked when the drive is in use.
//
#define FVE_E_FS_MOUNTED _HRESULT_TYPEDEF_(0x8031004BL)

//
// MessageId: FVE_E_TOKEN_NOT_IMPERSONATED
//
// MessageText:
//
// The access token associated with the current thread is not an impersonated token.
//
#define FVE_E_TOKEN_NOT_IMPERSONATED _HRESULT_TYPEDEF_(0x8031004CL)

//
// MessageId: FVE_E_DRY_RUN_FAILED
//
// MessageText:
//
// The BitLocker encryption key cannot be obtained. Verify that the Trusted Platform Module (TPM) is enabled and ownership has been taken. If this computer does not have a TPM, verify that the USB drive is inserted and available.
//
#define FVE_E_DRY_RUN_FAILED _HRESULT_TYPEDEF_(0x8031004DL)

//
// MessageId: FVE_E_REBOOT_REQUIRED
//
// MessageText:
//
// You must restart your computer before continuing with BitLocker Drive Encryption.
//
#define FVE_E_REBOOT_REQUIRED _HRESULT_TYPEDEF_(0x8031004EL)

//
// MessageId: FVE_E_DEBUGGER_ENABLED
//
// MessageText:
//
// Drive encryption cannot occur while boot debugging is enabled. Use the bcdedit command-line tool to turn off boot debugging.
//
#define FVE_E_DEBUGGER_ENABLED _HRESULT_TYPEDEF_(0x8031004FL)

//
// MessageId: FVE_E_RAW_ACCESS
//
// MessageText:
//
// No action was taken as BitLocker Drive Encryption is in raw access mode.
//
#define FVE_E_RAW_ACCESS _HRESULT_TYPEDEF_(0x80310050L)

//
// MessageId: FVE_E_RAW_BLOCKED
//
// MessageText:
//
// BitLocker Drive Encryption cannot enter raw access mode for this drive because the drive is currently in use.
//
#define FVE_E_RAW_BLOCKED _HRESULT_TYPEDEF_(0x80310051L)

//
// MessageId: FVE_E_BCD_APPLICATIONS_PATH_INCORRECT
//
// MessageText:
//
// The path specified in the Boot Configuration Data (BCD) for a BitLocker Drive Encryption integrity-protected application is incorrect. Please verify and correct your BCD settings and try again.
//
#define FVE_E_BCD_APPLICATIONS_PATH_INCORRECT _HRESULT_TYPEDEF_(0x80310052L)

//
// MessageId: FVE_E_NOT_ALLOWED_IN_VERSION
//
// MessageText:
//
// BitLocker Drive Encryption can only be used for recovery purposes when the computer is running Windows Recovery Environment.
//
#define FVE_E_NOT_ALLOWED_IN_VERSION _HRESULT_TYPEDEF_(0x80310053L)

//
// MessageId: FVE_E_NO_AUTOUNLOCK_MASTER_KEY
//
// MessageText:
//
// The auto-unlock master key was not available from the operating system drive.
//
#define FVE_E_NO_AUTOUNLOCK_MASTER_KEY _HRESULT_TYPEDEF_(0x80310054L)

//
// MessageId: FVE_E_MOR_FAILED
//
// MessageText:
//
// The system firmware failed to enable clearing of system memory when the computer was restarted.
//
#define FVE_E_MOR_FAILED _HRESULT_TYPEDEF_(0x80310055L)

//
// MessageId: FVE_E_HIDDEN_VOLUME
//
// MessageText:
//
// The hidden drive cannot be encrypted.
//
#define FVE_E_HIDDEN_VOLUME _HRESULT_TYPEDEF_(0x80310056L)

//
// MessageId: FVE_E_TRANSIENT_STATE
//
// MessageText:
//
// BitLocker encryption keys were ignored because the drive was in a transient state.
//
#define FVE_E_TRANSIENT_STATE _HRESULT_TYPEDEF_(0x80310057L)

//
// MessageId: FVE_E_PUBKEY_NOT_ALLOWED
//
// MessageText:
//
// Public key based protectors are not allowed on this drive.
//
#define FVE_E_PUBKEY_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310058L)

//
// MessageId: FVE_E_VOLUME_HANDLE_OPEN
//
// MessageText:
//
// BitLocker Drive Encryption is already performing an operation on this drive. Please complete all operations before continuing.
//
#define FVE_E_VOLUME_HANDLE_OPEN _HRESULT_TYPEDEF_(0x80310059L)

//
// MessageId: FVE_E_NO_FEATURE_LICENSE
//
// MessageText:
//
// This version of Windows does not support this feature of BitLocker Drive Encryption. To use this feature, upgrade the operating system..
//
#define FVE_E_NO_FEATURE_LICENSE _HRESULT_TYPEDEF_(0x8031005AL)

//
// MessageId: FVE_E_INVALID_STARTUP_OPTIONS
//
// MessageText:
//
// The Group Policy settings for BitLocker startup options are in conflict and cannot be applied. Contact your system administrator for more information.
//
#define FVE_E_INVALID_STARTUP_OPTIONS _HRESULT_TYPEDEF_(0x8031005BL)

//
// MessageId: FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a recovery password.
//
#define FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED _HRESULT_TYPEDEF_(0x8031005CL)

//
// MessageId: FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a recovery password.
//
#define FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED _HRESULT_TYPEDEF_(0x8031005DL)

//
// MessageId: FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a recovery key.
//
#define FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED _HRESULT_TYPEDEF_(0x8031005EL)

//
// MessageId: FVE_E_POLICY_RECOVERY_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a recovery key.
//
#define FVE_E_POLICY_RECOVERY_KEY_REQUIRED _HRESULT_TYPEDEF_(0x8031005FL)

//
// MessageId: FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a PIN at startup. Please choose a different BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310060L)

//
// MessageId: FVE_E_POLICY_STARTUP_PIN_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a PIN at startup. Please choose this BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_PIN_REQUIRED _HRESULT_TYPEDEF_(0x80310061L)

//
// MessageId: FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a startup key. Please choose a different BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310062L)

//
// MessageId: FVE_E_POLICY_STARTUP_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a startup key. Please choose this BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_KEY_REQUIRED _HRESULT_TYPEDEF_(0x80310063L)

//
// MessageId: FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the use of a startup key and PIN. Please choose a different BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310064L)

//
// MessageId: FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of a startup key and PIN. Please choose this BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED _HRESULT_TYPEDEF_(0x80310065L)

//
// MessageId: FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED
//
// MessageText:
//
// Group policy does not permit the use of TPM-only at startup. Please choose a different BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310066L)

//
// MessageId: FVE_E_POLICY_STARTUP_TPM_REQUIRED
//
// MessageText:
//
// Group Policy settings require the use of TPM-only at startup. Please choose this BitLocker startup option.
//
#define FVE_E_POLICY_STARTUP_TPM_REQUIRED _HRESULT_TYPEDEF_(0x80310067L)

//
// MessageId: FVE_E_POLICY_INVALID_PIN_LENGTH
//
// MessageText:
//
// The PIN provided does not meet minimum or maximum length requirements.
//
#define FVE_E_POLICY_INVALID_PIN_LENGTH _HRESULT_TYPEDEF_(0x80310068L)

//
// MessageId: FVE_E_KEY_PROTECTOR_NOT_SUPPORTED
//
// MessageText:
//
// The key protector is not supported by the version of BitLocker Drive Encryption currently on the drive. Upgrade the drive to add the key protector.
//
#define FVE_E_KEY_PROTECTOR_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80310069L)

//
// MessageId: FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit the creation of a password.
//
#define FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED _HRESULT_TYPEDEF_(0x8031006AL)

//
// MessageId: FVE_E_POLICY_PASSPHRASE_REQUIRED
//
// MessageText:
//
// Group Policy settings require the creation of a password.
//
#define FVE_E_POLICY_PASSPHRASE_REQUIRED _HRESULT_TYPEDEF_(0x8031006BL)

//
// MessageId: FVE_E_FIPS_PREVENTS_PASSPHRASE
//
// MessageText:
//
// The Group Policy setting requiring FIPS compliance prevents passwords from being generated or used. Please contact your system administrator for more information.
//
#define FVE_E_FIPS_PREVENTS_PASSPHRASE _HRESULT_TYPEDEF_(0x8031006CL)

//
// MessageId: FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED
//
// MessageText:
//
// A password cannot be added to the operating system drive.
//
#define FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED _HRESULT_TYPEDEF_(0x8031006DL)

//
// MessageId: FVE_E_INVALID_BITLOCKER_OID
//
// MessageText:
//
// The BitLocker object identifier (OID) on the drive appears to be invalid or corrupt. Use manage-BDE to reset the OID on this drive.
//
#define FVE_E_INVALID_BITLOCKER_OID _HRESULT_TYPEDEF_(0x8031006EL)

//
// MessageId: FVE_E_VOLUME_TOO_SMALL
//
// MessageText:
//
// The drive is too small to be protected using BitLocker Drive Encryption.
//
#define FVE_E_VOLUME_TOO_SMALL _HRESULT_TYPEDEF_(0x8031006FL)

//
// MessageId: FVE_E_DV_NOT_SUPPORTED_ON_FS
//
// MessageText:
//
// The selected discovery drive type is incompatible with the file system on the drive. BitLocker To Go discovery drives must be created on FAT formatted drives.
//
#define FVE_E_DV_NOT_SUPPORTED_ON_FS _HRESULT_TYPEDEF_(0x80310070L)

//
// MessageId: FVE_E_DV_NOT_ALLOWED_BY_GP
//
// MessageText:
//
// The selected discovery drive type is not allowed by the computer's Group Policy settings. Verify that Group Policy settings allow the creation of discovery drives for use with BitLocker To Go.
//
#define FVE_E_DV_NOT_ALLOWED_BY_GP _HRESULT_TYPEDEF_(0x80310071L)

//
// MessageId: FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit user certificates such as smart cards to be used with BitLocker Drive Encryption.
//
#define FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310072L)

//
// MessageId: FVE_E_POLICY_USER_CERTIFICATE_REQUIRED
//
// MessageText:
//
// Group Policy settings require that you have a valid user certificate, such as a smart card, to be used with BitLocker Drive Encryption.
//
#define FVE_E_POLICY_USER_CERTIFICATE_REQUIRED _HRESULT_TYPEDEF_(0x80310073L)

//
// MessageId: FVE_E_POLICY_USER_CERT_MUST_BE_HW
//
// MessageText:
//
// Group Policy settings requires that you use a smart card-based key protector with BitLocker Drive Encryption.
//
#define FVE_E_POLICY_USER_CERT_MUST_BE_HW _HRESULT_TYPEDEF_(0x80310074L)

//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit BitLocker-protected fixed data drives to be automatically unlocked.
//
#define FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310075L)

//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit BitLocker-protected removable data drives to be automatically unlocked.
//
#define FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310076L)

//
// MessageId: FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit you to configure BitLocker Drive Encryption on removable data drives.
//
#define FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310077L)

//
// MessageId: FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit you to turn on BitLocker Drive Encryption on removable data drives. Please contact your system administrator if you need to turn on BitLocker.
//
#define FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310078L)

//
// MessageId: FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group Policy settings do not permit turning off BitLocker Drive Encryption on removable data drives. Please contact your system administrator if you need to turn off BitLocker.
//
#define FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310079L)

//
// MessageId: FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH
//
// MessageText:
//
// Your password does not meet minimum password length requirements. By default, passwords must be at least 8 characters in length. Check with your system administrator for the password length requirement in your organization.
//
#define FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH _HRESULT_TYPEDEF_(0x80310080L)

//
// MessageId: FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE
//
// MessageText:
//
// Your password does not meet the complexity requirements set by your system administrator. Try adding upper and lowercase characters, numbers, and symbols.
//
#define FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE _HRESULT_TYPEDEF_(0x80310081L)

//
// MessageId: FVE_E_RECOVERY_PARTITION
//
// MessageText:
//
// This drive cannot be encrypted because it is reserved for Windows System Recovery Options.
//
#define FVE_E_RECOVERY_PARTITION _HRESULT_TYPEDEF_(0x80310082L)

//
// MessageId: FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because of conflicting Group Policy settings. BitLocker cannot be configured to automatically unlock fixed data drives when user recovery options are disabled. If you want BitLocker-protected fixed data drives to be automatically unlocked after key validation has occurred, please ask your system administrator to resolve the settings conflict before enabling BitLocker.
//
#define FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON _HRESULT_TYPEDEF_(0x80310083L)

//
// MessageId: FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because of conflicting Group Policy settings. BitLocker cannot be configured to automatically unlock removable data drives when user recovery option are disabled. If you want BitLocker-protected removable data drives to be automatically unlocked after key validation has occured, please ask your system administrator to resolve the settings conflict before enabling BitLocker.
//
#define FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON _HRESULT_TYPEDEF_(0x80310084L)

//
// MessageId: FVE_E_NON_BITLOCKER_OID
//
// MessageText:
//
// The Enhanced Key Usage (EKU) attribute of the specified certificate does not permit it to be used for BitLocker Drive Encryption. BitLocker does not require that a certificate have an EKU attribute, but if one is configured it must be set to an object identifier (OID) that matches the OID configured for BitLocker.
//
#define FVE_E_NON_BITLOCKER_OID _HRESULT_TYPEDEF_(0x80310085L)

//
// MessageId: FVE_E_POLICY_PROHIBITS_SELFSIGNED
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive as currently configured because of Group Policy settings. The certificate you provided for drive encryption is self-signed. Current Group Policy settings do not permit the use of self-signed certificates. Obtain a new certificate from your certification authority before attempting to enable BitLocker.
//
#define FVE_E_POLICY_PROHIBITS_SELFSIGNED _HRESULT_TYPEDEF_(0x80310086L)

//
// MessageId: FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED
//
// MessageText:
//
// BitLocker Encryption cannot be applied to this drive because of conflicting Group Policy settings. When write access to drives not protected by BitLocker is denied, the use of a USB startup key cannot be required. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
#define FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED _HRESULT_TYPEDEF_(0x80310087L)

//
// MessageId: FVE_E_CONV_RECOVERY_FAILED
//
// MessageText:
//
// BitLocker Drive Encryption failed to recover from an abruptly terminated conversion. This could be due to either all conversion logs being corrupted or the media being write-protected.
//
#define FVE_E_CONV_RECOVERY_FAILED _HRESULT_TYPEDEF_(0x80310088L)

//
// MessageId: FVE_E_VIRTUALIZED_SPACE_TOO_BIG
//
// MessageText:
//
// The requested virtualization size is too big.
//
#define FVE_E_VIRTUALIZED_SPACE_TOO_BIG _HRESULT_TYPEDEF_(0x80310089L)

//
// MessageId: FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on operating system drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
#define FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON _HRESULT_TYPEDEF_(0x80310090L)

//
// MessageId: FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on fixed data drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
#define FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON _HRESULT_TYPEDEF_(0x80310091L)

//
// MessageId: FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON
//
// MessageText:
//
// BitLocker Drive Encryption cannot be applied to this drive because there are conflicting Group Policy settings for recovery options on removable data drives. Storing recovery information to Active Directory Domain Services cannot be required when the generation of recovery passwords is not permitted. Please have your system administrator resolve these policy conflicts before attempting to enable BitLocker.
//
#define FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON _HRESULT_TYPEDEF_(0x80310092L)

//
// MessageId: FVE_E_NON_BITLOCKER_KU
//
// MessageText:
//
// The Key Usage (KU) attribute of the specified certificate does not permit it to be used for BitLocker Drive Encryption. BitLocker does not require that a certificate have a KU attribute, but if one is configured it must be set to either Key Encipherment or Key Agreement.
//
#define FVE_E_NON_BITLOCKER_KU _HRESULT_TYPEDEF_(0x80310093L)

//
// MessageId: FVE_E_PRIVATEKEY_AUTH_FAILED
//
// MessageText:
//
// The private key associated with the specified certificate cannot be authorized. The private key authorization was either not provided or the provided authorization was invalid.
//
#define FVE_E_PRIVATEKEY_AUTH_FAILED _HRESULT_TYPEDEF_(0x80310094L)

//
// MessageId: FVE_E_REMOVAL_OF_DRA_FAILED
//
// MessageText:
//
// Removal of the data recovery agent certificate must be done using the Certificates snap-in.
//
#define FVE_E_REMOVAL_OF_DRA_FAILED _HRESULT_TYPEDEF_(0x80310095L)

//
// MessageId: FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME
//
// MessageText:
//
// This drive was encrypted using the version of BitLocker Drive Encryption included with Windows Vista and Windows Server 2008 which does not support organizational identifiers. To specify organizational identifiers for this drive upgrade the drive encryption to the latest version using the "manage-bde -upgrade" command.
//
#define FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME _HRESULT_TYPEDEF_(0x80310096L)

//
// MessageId: FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME
//
// MessageText:
//
// The drive cannot be locked because it is automatically unlocked on this computer.  Remove the automatic unlock protector to lock this drive.
//
#define FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME _HRESULT_TYPEDEF_(0x80310097L)

//
// MessageId: FVE_E_FIPS_HASH_KDF_NOT_ALLOWED
//
// MessageText:
//
// The default BitLocker Key Derivation Function SP800-56A for ECC smart cards is not supported by your smart card. The Group Policy setting requiring FIPS-compliance prevents BitLocker from using any other key derivation function for encryption. You have to use a FIPS compliant smart card in FIPS restricted environments.
//
#define FVE_E_FIPS_HASH_KDF_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80310098L)

//
// MessageId: FVE_E_ENH_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key could not be obtained from the Trusted Platform Module (TPM) and enhanced PIN. Try using a PIN containing only numerals.
//
#define FVE_E_ENH_PIN_INVALID _HRESULT_TYPEDEF_(0x80310099L)

//
// MessageId: FVE_E_INVALID_PIN_CHARS
//
// MessageText:
//
// The requested TPM PIN contains invalid characters.
//
#define FVE_E_INVALID_PIN_CHARS _HRESULT_TYPEDEF_(0x8031009AL)

//
// MessageId: FVE_E_INVALID_DATUM_TYPE
//
// MessageText:
//
// The management information stored on the drive contained an unknown type. If you are using an old version of Windows, try accessing the drive from the latest version.
//
#define FVE_E_INVALID_DATUM_TYPE _HRESULT_TYPEDEF_(0x8031009BL)

//
// =======================================================
// Windows Filtering Platform Error Messages
// =======================================================
//
//
// MessageId: FWP_E_CALLOUT_NOT_FOUND
//
// MessageText:
//
// The callout does not exist.
//
#define FWP_E_CALLOUT_NOT_FOUND _HRESULT_TYPEDEF_(0x80320001L)

//
// MessageId: FWP_E_CONDITION_NOT_FOUND
//
// MessageText:
//
// The filter condition does not exist.
//
#define FWP_E_CONDITION_NOT_FOUND _HRESULT_TYPEDEF_(0x80320002L)

//
// MessageId: FWP_E_FILTER_NOT_FOUND
//
// MessageText:
//
// The filter does not exist.
//
#define FWP_E_FILTER_NOT_FOUND _HRESULT_TYPEDEF_(0x80320003L)

//
// MessageId: FWP_E_LAYER_NOT_FOUND
//
// MessageText:
//
// The layer does not exist.
//
#define FWP_E_LAYER_NOT_FOUND _HRESULT_TYPEDEF_(0x80320004L)

//
// MessageId: FWP_E_PROVIDER_NOT_FOUND
//
// MessageText:
//
// The provider does not exist.
//
#define FWP_E_PROVIDER_NOT_FOUND _HRESULT_TYPEDEF_(0x80320005L)

//
// MessageId: FWP_E_PROVIDER_CONTEXT_NOT_FOUND
//
// MessageText:
//
// The provider context does not exist.
//
#define FWP_E_PROVIDER_CONTEXT_NOT_FOUND _HRESULT_TYPEDEF_(0x80320006L)

//
// MessageId: FWP_E_SUBLAYER_NOT_FOUND
//
// MessageText:
//
// The sublayer does not exist.
//
#define FWP_E_SUBLAYER_NOT_FOUND _HRESULT_TYPEDEF_(0x80320007L)

//
// MessageId: FWP_E_NOT_FOUND
//
// MessageText:
//
// The object does not exist.
//
#define FWP_E_NOT_FOUND _HRESULT_TYPEDEF_(0x80320008L)

//
// MessageId: FWP_E_ALREADY_EXISTS
//
// MessageText:
//
// An object with that GUID or LUID already exists.
//
#define FWP_E_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x80320009L)

//
// MessageId: FWP_E_IN_USE
//
// MessageText:
//
// The object is referenced by other objects so cannot be deleted.
//
#define FWP_E_IN_USE _HRESULT_TYPEDEF_(0x8032000AL)

//
// MessageId: FWP_E_DYNAMIC_SESSION_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within a dynamic session.
//
#define FWP_E_DYNAMIC_SESSION_IN_PROGRESS _HRESULT_TYPEDEF_(0x8032000BL)

//
// MessageId: FWP_E_WRONG_SESSION
//
// MessageText:
//
// The call was made from the wrong session so cannot be completed.
//
#define FWP_E_WRONG_SESSION _HRESULT_TYPEDEF_(0x8032000CL)

//
// MessageId: FWP_E_NO_TXN_IN_PROGRESS
//
// MessageText:
//
// The call must be made from within an explicit transaction.
//
#define FWP_E_NO_TXN_IN_PROGRESS _HRESULT_TYPEDEF_(0x8032000DL)

//
// MessageId: FWP_E_TXN_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within an explicit transaction.
//
#define FWP_E_TXN_IN_PROGRESS _HRESULT_TYPEDEF_(0x8032000EL)

//
// MessageId: FWP_E_TXN_ABORTED
//
// MessageText:
//
// The explicit transaction has been forcibly cancelled.
//
#define FWP_E_TXN_ABORTED _HRESULT_TYPEDEF_(0x8032000FL)

//
// MessageId: FWP_E_SESSION_ABORTED
//
// MessageText:
//
// The session has been cancelled.
//
#define FWP_E_SESSION_ABORTED _HRESULT_TYPEDEF_(0x80320010L)

//
// MessageId: FWP_E_INCOMPATIBLE_TXN
//
// MessageText:
//
// The call is not allowed from within a read-only transaction.
//
#define FWP_E_INCOMPATIBLE_TXN _HRESULT_TYPEDEF_(0x80320011L)

//
// MessageId: FWP_E_TIMEOUT
//
// MessageText:
//
// The call timed out while waiting to acquire the transaction lock.
//
#define FWP_E_TIMEOUT _HRESULT_TYPEDEF_(0x80320012L)

//
// MessageId: FWP_E_NET_EVENTS_DISABLED
//
// MessageText:
//
// Collection of network diagnostic events is disabled.
//
#define FWP_E_NET_EVENTS_DISABLED _HRESULT_TYPEDEF_(0x80320013L)

//
// MessageId: FWP_E_INCOMPATIBLE_LAYER
//
// MessageText:
//
// The operation is not supported by the specified layer.
//
#define FWP_E_INCOMPATIBLE_LAYER _HRESULT_TYPEDEF_(0x80320014L)

//
// MessageId: FWP_E_KM_CLIENTS_ONLY
//
// MessageText:
//
// The call is allowed for kernel-mode callers only.
//
#define FWP_E_KM_CLIENTS_ONLY _HRESULT_TYPEDEF_(0x80320015L)

//
// MessageId: FWP_E_LIFETIME_MISMATCH
//
// MessageText:
//
// The call tried to associate two objects with incompatible lifetimes.
//
#define FWP_E_LIFETIME_MISMATCH _HRESULT_TYPEDEF_(0x80320016L)

//
// MessageId: FWP_E_BUILTIN_OBJECT
//
// MessageText:
//
// The object is built in so cannot be deleted.
//
#define FWP_E_BUILTIN_OBJECT _HRESULT_TYPEDEF_(0x80320017L)

//
// MessageId: FWP_E_TOO_MANY_CALLOUTS
//
// MessageText:
//
// The maximum number of callouts has been reached.
//
#define FWP_E_TOO_MANY_CALLOUTS _HRESULT_TYPEDEF_(0x80320018L)

//
// MessageId: FWP_E_NOTIFICATION_DROPPED
//
// MessageText:
//
// A notification could not be delivered because a message queue is at its maximum capacity.
//
#define FWP_E_NOTIFICATION_DROPPED _HRESULT_TYPEDEF_(0x80320019L)

//
// MessageId: FWP_E_TRAFFIC_MISMATCH
//
// MessageText:
//
// The traffic parameters do not match those for the security association context.
//
#define FWP_E_TRAFFIC_MISMATCH _HRESULT_TYPEDEF_(0x8032001AL)

//
// MessageId: FWP_E_INCOMPATIBLE_SA_STATE
//
// MessageText:
//
// The call is not allowed for the current security association state.
//
#define FWP_E_INCOMPATIBLE_SA_STATE _HRESULT_TYPEDEF_(0x8032001BL)

//
// MessageId: FWP_E_NULL_POINTER
//
// MessageText:
//
// A required pointer is null.
//
#define FWP_E_NULL_POINTER _HRESULT_TYPEDEF_(0x8032001CL)

//
// MessageId: FWP_E_INVALID_ENUMERATOR
//
// MessageText:
//
// An enumerator is not valid.
//
#define FWP_E_INVALID_ENUMERATOR _HRESULT_TYPEDEF_(0x8032001DL)

//
// MessageId: FWP_E_INVALID_FLAGS
//
// MessageText:
//
// The flags field contains an invalid value.
//
#define FWP_E_INVALID_FLAGS _HRESULT_TYPEDEF_(0x8032001EL)

//
// MessageId: FWP_E_INVALID_NET_MASK
//
// MessageText:
//
// A network mask is not valid.
//
#define FWP_E_INVALID_NET_MASK _HRESULT_TYPEDEF_(0x8032001FL)

//
// MessageId: FWP_E_INVALID_RANGE
//
// MessageText:
//
// An FWP_RANGE is not valid.
//
#define FWP_E_INVALID_RANGE _HRESULT_TYPEDEF_(0x80320020L)

//
// MessageId: FWP_E_INVALID_INTERVAL
//
// MessageText:
//
// The time interval is not valid.
//
#define FWP_E_INVALID_INTERVAL _HRESULT_TYPEDEF_(0x80320021L)

//
// MessageId: FWP_E_ZERO_LENGTH_ARRAY
//
// MessageText:
//
// An array that must contain at least one element is zero length.
//
#define FWP_E_ZERO_LENGTH_ARRAY _HRESULT_TYPEDEF_(0x80320022L)

//
// MessageId: FWP_E_NULL_DISPLAY_NAME
//
// MessageText:
//
// The displayData.name field cannot be null.
//
#define FWP_E_NULL_DISPLAY_NAME _HRESULT_TYPEDEF_(0x80320023L)

//
// MessageId: FWP_E_INVALID_ACTION_TYPE
//
// MessageText:
//
// The action type is not one of the allowed action types for a filter.
//
#define FWP_E_INVALID_ACTION_TYPE _HRESULT_TYPEDEF_(0x80320024L)

//
// MessageId: FWP_E_INVALID_WEIGHT
//
// MessageText:
//
// The filter weight is not valid.
//
#define FWP_E_INVALID_WEIGHT _HRESULT_TYPEDEF_(0x80320025L)

//
// MessageId: FWP_E_MATCH_TYPE_MISMATCH
//
// MessageText:
//
// A filter condition contains a match type that is not compatible with the operands.
//
#define FWP_E_MATCH_TYPE_MISMATCH _HRESULT_TYPEDEF_(0x80320026L)

//
// MessageId: FWP_E_TYPE_MISMATCH
//
// MessageText:
//
// An FWP_VALUE or FWPM_CONDITION_VALUE is of the wrong type.
//
#define FWP_E_TYPE_MISMATCH _HRESULT_TYPEDEF_(0x80320027L)

//
// MessageId: FWP_E_OUT_OF_BOUNDS
//
// MessageText:
//
// An integer value is outside the allowed range.
//
#define FWP_E_OUT_OF_BOUNDS _HRESULT_TYPEDEF_(0x80320028L)

//
// MessageId: FWP_E_RESERVED
//
// MessageText:
//
// A reserved field is non-zero.
//
#define FWP_E_RESERVED _HRESULT_TYPEDEF_(0x80320029L)

//
// MessageId: FWP_E_DUPLICATE_CONDITION
//
// MessageText:
//
// A filter cannot contain multiple conditions operating on a single field.
//
#define FWP_E_DUPLICATE_CONDITION _HRESULT_TYPEDEF_(0x8032002AL)

//
// MessageId: FWP_E_DUPLICATE_KEYMOD
//
// MessageText:
//
// A policy cannot contain the same keying module more than once.
//
#define FWP_E_DUPLICATE_KEYMOD _HRESULT_TYPEDEF_(0x8032002BL)

//
// MessageId: FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The action type is not compatible with the layer.
//
#define FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER _HRESULT_TYPEDEF_(0x8032002CL)

//
// MessageId: FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER
//
// MessageText:
//
// The action type is not compatible with the sublayer.
//
#define FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER _HRESULT_TYPEDEF_(0x8032002DL)

//
// MessageId: FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The raw context or the provider context is not compatible with the layer.
//
#define FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER _HRESULT_TYPEDEF_(0x8032002EL)

//
// MessageId: FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT
//
// MessageText:
//
// The raw context or the provider context is not compatible with the callout.
//
#define FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT _HRESULT_TYPEDEF_(0x8032002FL)

//
// MessageId: FWP_E_INCOMPATIBLE_AUTH_METHOD
//
// MessageText:
//
// The authentication method is not compatible with the policy type.
//
#define FWP_E_INCOMPATIBLE_AUTH_METHOD _HRESULT_TYPEDEF_(0x80320030L)

//
// MessageId: FWP_E_INCOMPATIBLE_DH_GROUP
//
// MessageText:
//
// The Diffie-Hellman group is not compatible with the policy type.
//
#define FWP_E_INCOMPATIBLE_DH_GROUP _HRESULT_TYPEDEF_(0x80320031L)

//
// MessageId: FWP_E_EM_NOT_SUPPORTED
//
// MessageText:
//
// An IKE policy cannot contain an Extended Mode policy.
//
#define FWP_E_EM_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80320032L)

//
// MessageId: FWP_E_NEVER_MATCH
//
// MessageText:
//
// The enumeration template or subscription will never match any objects.
//
#define FWP_E_NEVER_MATCH _HRESULT_TYPEDEF_(0x80320033L)

//
// MessageId: FWP_E_PROVIDER_CONTEXT_MISMATCH
//
// MessageText:
//
// The provider context is of the wrong type.
//
#define FWP_E_PROVIDER_CONTEXT_MISMATCH _HRESULT_TYPEDEF_(0x80320034L)

//
// MessageId: FWP_E_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
#define FWP_E_INVALID_PARAMETER _HRESULT_TYPEDEF_(0x80320035L)

//
// MessageId: FWP_E_TOO_MANY_SUBLAYERS
//
// MessageText:
//
// The maximum number of sublayers has been reached.
//
#define FWP_E_TOO_MANY_SUBLAYERS _HRESULT_TYPEDEF_(0x80320036L)

//
// MessageId: FWP_E_CALLOUT_NOTIFICATION_FAILED
//
// MessageText:
//
// The notification function for a callout returned an error.
//
#define FWP_E_CALLOUT_NOTIFICATION_FAILED _HRESULT_TYPEDEF_(0x80320037L)

//
// MessageId: FWP_E_INVALID_AUTH_TRANSFORM
//
// MessageText:
//
// The IPsec authentication transform is not valid.
//
#define FWP_E_INVALID_AUTH_TRANSFORM _HRESULT_TYPEDEF_(0x80320038L)

//
// MessageId: FWP_E_INVALID_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not valid.
//
#define FWP_E_INVALID_CIPHER_TRANSFORM _HRESULT_TYPEDEF_(0x80320039L)

//
// MessageId: FWP_E_DROP_NOICMP
//
// MessageText:
//
// The packet should be dropped, no ICMP should be sent.
//
#define FWP_E_DROP_NOICMP _HRESULT_TYPEDEF_(0x80320104L)

//
// MessageId: FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not compatible with the policy.
//
#define FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM _HRESULT_TYPEDEF_(0x8032003AL)

//
// MessageId: FWP_E_INVALID_TRANSFORM_COMBINATION
//
// MessageText:
//
// The combination of IPsec transform types is not valid.
//
#define FWP_E_INVALID_TRANSFORM_COMBINATION _HRESULT_TYPEDEF_(0x8032003BL)

//
// MessageId: FWP_E_DUPLICATE_AUTH_METHOD
//
// MessageText:
//
// A policy cannot contain the same auth method more than once.
//
#define FWP_E_DUPLICATE_AUTH_METHOD _HRESULT_TYPEDEF_(0x8032003CL)


///////////////////////////////////////////////////
//                                               //
//       Web Services Platform Error Codes       //
//                                               //
///////////////////////////////////////////////////

//
// MessageId: WS_S_ASYNC
//
// MessageText:
//
// The function call is completing asynchronously.
//
#define WS_S_ASYNC _HRESULT_TYPEDEF_(0x003D0000L)

//
// MessageId: WS_S_END
//
// MessageText:
//
// There are no more messages available on the channel.
//
#define WS_S_END _HRESULT_TYPEDEF_(0x003D0001L)

//
// MessageId: WS_E_INVALID_FORMAT
//
// MessageText:
//
// The input data was not in the expected format or did not have the expected value.
//
#define WS_E_INVALID_FORMAT _HRESULT_TYPEDEF_(0x803D0000L)

//
// MessageId: WS_E_OBJECT_FAULTED
//
// MessageText:
//
// The operation could not be completed because the object is in a faulted state due to a previous error.
//
#define WS_E_OBJECT_FAULTED _HRESULT_TYPEDEF_(0x803D0001L)

//
// MessageId: WS_E_NUMERIC_OVERFLOW
//
// MessageText:
//
// The operation could not be completed because it would lead to numeric overflow.
//
#define WS_E_NUMERIC_OVERFLOW _HRESULT_TYPEDEF_(0x803D0002L)

//
// MessageId: WS_E_INVALID_OPERATION
//
// MessageText:
//
// The operation is not allowed due to the current state of the object.
//
#define WS_E_INVALID_OPERATION _HRESULT_TYPEDEF_(0x803D0003L)

//
// MessageId: WS_E_OPERATION_ABORTED
//
// MessageText:
//
// The operation was aborted.
//
#define WS_E_OPERATION_ABORTED _HRESULT_TYPEDEF_(0x803D0004L)

//
// MessageId: WS_E_ENDPOINT_ACCESS_DENIED
//
// MessageText:
//
// Access was denied by the remote endpoint.
//
#define WS_E_ENDPOINT_ACCESS_DENIED _HRESULT_TYPEDEF_(0x803D0005L)

//
// MessageId: WS_E_OPERATION_TIMED_OUT
//
// MessageText:
//
// The operation did not complete within the time allotted.
//
#define WS_E_OPERATION_TIMED_OUT _HRESULT_TYPEDEF_(0x803D0006L)

//
// MessageId: WS_E_OPERATION_ABANDONED
//
// MessageText:
//
// The operation was abandoned.
//
#define WS_E_OPERATION_ABANDONED _HRESULT_TYPEDEF_(0x803D0007L)

//
// MessageId: WS_E_QUOTA_EXCEEDED
//
// MessageText:
//
// A quota was exceeded.
//
#define WS_E_QUOTA_EXCEEDED _HRESULT_TYPEDEF_(0x803D0008L)

//
// MessageId: WS_E_NO_TRANSLATION_AVAILABLE
//
// MessageText:
//
// The information was not available in the specified language.
//
#define WS_E_NO_TRANSLATION_AVAILABLE _HRESULT_TYPEDEF_(0x803D0009L)

//
// MessageId: WS_E_SECURITY_VERIFICATION_FAILURE
//
// MessageText:
//
// Security verification was not successful for the received data.
//
#define WS_E_SECURITY_VERIFICATION_FAILURE _HRESULT_TYPEDEF_(0x803D000AL)

//
// MessageId: WS_E_ADDRESS_IN_USE
//
// MessageText:
//
// The address is already being used.
//
#define WS_E_ADDRESS_IN_USE _HRESULT_TYPEDEF_(0x803D000BL)

//
// MessageId: WS_E_ADDRESS_NOT_AVAILABLE
//
// MessageText:
//
// The address is not valid for this context.
//
#define WS_E_ADDRESS_NOT_AVAILABLE _HRESULT_TYPEDEF_(0x803D000CL)

//
// MessageId: WS_E_ENDPOINT_NOT_FOUND
//
// MessageText:
//
// The remote endpoint does not exist or could not be located.
//
#define WS_E_ENDPOINT_NOT_FOUND _HRESULT_TYPEDEF_(0x803D000DL)

//
// MessageId: WS_E_ENDPOINT_NOT_AVAILABLE
//
// MessageText:
//
// The remote endpoint is not currently in service at this location.
//
#define WS_E_ENDPOINT_NOT_AVAILABLE _HRESULT_TYPEDEF_(0x803D000EL)

//
// MessageId: WS_E_ENDPOINT_FAILURE
//
// MessageText:
//
// The remote endpoint could not process the request.
//
#define WS_E_ENDPOINT_FAILURE _HRESULT_TYPEDEF_(0x803D000FL)

//
// MessageId: WS_E_ENDPOINT_UNREACHABLE
//
// MessageText:
//
// The remote endpoint was not reachable.
//
#define WS_E_ENDPOINT_UNREACHABLE _HRESULT_TYPEDEF_(0x803D0010L)

//
// MessageId: WS_E_ENDPOINT_ACTION_NOT_SUPPORTED
//
// MessageText:
//
// The operation was not supported by the remote endpoint.
//
#define WS_E_ENDPOINT_ACTION_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x803D0011L)

//
// MessageId: WS_E_ENDPOINT_TOO_BUSY
//
// MessageText:
//
// The remote endpoint is unable to process the request due to being overloaded.
//
#define WS_E_ENDPOINT_TOO_BUSY _HRESULT_TYPEDEF_(0x803D0012L)

//
// MessageId: WS_E_ENDPOINT_FAULT_RECEIVED
//
// MessageText:
//
// A message containing a fault was received from the remote endpoint.
//
#define WS_E_ENDPOINT_FAULT_RECEIVED _HRESULT_TYPEDEF_(0x803D0013L)

//
// MessageId: WS_E_ENDPOINT_DISCONNECTED
//
// MessageText:
//
// The connection with the remote endpoint was terminated.
//
#define WS_E_ENDPOINT_DISCONNECTED _HRESULT_TYPEDEF_(0x803D0014L)

//
// MessageId: WS_E_PROXY_FAILURE
//
// MessageText:
//
// The HTTP proxy server could not process the request.
//
#define WS_E_PROXY_FAILURE _HRESULT_TYPEDEF_(0x803D0015L)

//
// MessageId: WS_E_PROXY_ACCESS_DENIED
//
// MessageText:
//
// Access was denied by the HTTP proxy server.
//
#define WS_E_PROXY_ACCESS_DENIED _HRESULT_TYPEDEF_(0x803D0016L)

//
// MessageId: WS_E_NOT_SUPPORTED
//
// MessageText:
//
// The requested feature is not available on this platform.
//
#define WS_E_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x803D0017L)

//
// MessageId: WS_E_PROXY_REQUIRES_BASIC_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'basic'.
//
#define WS_E_PROXY_REQUIRES_BASIC_AUTH _HRESULT_TYPEDEF_(0x803D0018L)

//
// MessageId: WS_E_PROXY_REQUIRES_DIGEST_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'digest'.
//
#define WS_E_PROXY_REQUIRES_DIGEST_AUTH _HRESULT_TYPEDEF_(0x803D0019L)

//
// MessageId: WS_E_PROXY_REQUIRES_NTLM_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'NTLM'.
//
#define WS_E_PROXY_REQUIRES_NTLM_AUTH _HRESULT_TYPEDEF_(0x803D001AL)

//
// MessageId: WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH
//
// MessageText:
//
// The HTTP proxy server requires HTTP authentication scheme 'negotiate'.
//
#define WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH _HRESULT_TYPEDEF_(0x803D001BL)

//
// MessageId: WS_E_SERVER_REQUIRES_BASIC_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'basic'.
//
#define WS_E_SERVER_REQUIRES_BASIC_AUTH _HRESULT_TYPEDEF_(0x803D001CL)

//
// MessageId: WS_E_SERVER_REQUIRES_DIGEST_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'digest'.
//
#define WS_E_SERVER_REQUIRES_DIGEST_AUTH _HRESULT_TYPEDEF_(0x803D001DL)

//
// MessageId: WS_E_SERVER_REQUIRES_NTLM_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'NTLM'.
//
#define WS_E_SERVER_REQUIRES_NTLM_AUTH _HRESULT_TYPEDEF_(0x803D001EL)

//
// MessageId: WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH
//
// MessageText:
//
// The remote endpoint requires HTTP authentication scheme 'negotiate'.
//
#define WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH _HRESULT_TYPEDEF_(0x803D001FL)

//
// MessageId: WS_E_INVALID_ENDPOINT_URL
//
// MessageText:
//
// The endpoint address URL is invalid.
//
#define WS_E_INVALID_ENDPOINT_URL _HRESULT_TYPEDEF_(0x803D0020L)

//
// MessageId: WS_E_OTHER
//
// MessageText:
//
// Unrecognized error occured in the Windows Web Services framework.
//
#define WS_E_OTHER _HRESULT_TYPEDEF_(0x803D0021L)

//
// MessageId: WS_E_SECURITY_TOKEN_EXPIRED
//
// MessageText:
//
// A security token was rejected by the server because it has expired.
//
#define WS_E_SECURITY_TOKEN_EXPIRED _HRESULT_TYPEDEF_(0x803D0022L)

//
// MessageId: WS_E_SECURITY_SYSTEM_FAILURE
//
// MessageText:
//
// A security operation failed in the Windows Web Services framework.
//
#define WS_E_SECURITY_SYSTEM_FAILURE _HRESULT_TYPEDEF_(0x803D0023L)


//
// NDIS error codes (ndis.sys)
//





#define _NDIS_ERROR_TYPEDEF_(_sc) (DWORD)(_sc)


//
// MessageId: ERROR_NDIS_INTERFACE_CLOSING
//
// MessageText:
//
// The binding to the network interface is being closed.
//
#define ERROR_NDIS_INTERFACE_CLOSING _NDIS_ERROR_TYPEDEF_(0x80340002L)

//
// MessageId: ERROR_NDIS_BAD_VERSION
//
// MessageText:
//
// An invalid version was specified.
//
#define ERROR_NDIS_BAD_VERSION _NDIS_ERROR_TYPEDEF_(0x80340004L)

//
// MessageId: ERROR_NDIS_BAD_CHARACTERISTICS
//
// MessageText:
//
// An invalid characteristics table was used.
//
#define ERROR_NDIS_BAD_CHARACTERISTICS _NDIS_ERROR_TYPEDEF_(0x80340005L)

//
// MessageId: ERROR_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
// Failed to find the network interface or network interface is not ready.
//
#define ERROR_NDIS_ADAPTER_NOT_FOUND _NDIS_ERROR_TYPEDEF_(0x80340006L)

//
// MessageId: ERROR_NDIS_OPEN_FAILED
//
// MessageText:
//
// Failed to open the network interface.
//
#define ERROR_NDIS_OPEN_FAILED _NDIS_ERROR_TYPEDEF_(0x80340007L)

//
// MessageId: ERROR_NDIS_DEVICE_FAILED
//
// MessageText:
//
// Network interface has encountered an internal unrecoverable failure.
//
#define ERROR_NDIS_DEVICE_FAILED _NDIS_ERROR_TYPEDEF_(0x80340008L)

//
// MessageId: ERROR_NDIS_MULTICAST_FULL
//
// MessageText:
//
// The multicast list on the network interface is full.
//
#define ERROR_NDIS_MULTICAST_FULL _NDIS_ERROR_TYPEDEF_(0x80340009L)

//
// MessageId: ERROR_NDIS_MULTICAST_EXISTS
//
// MessageText:
//
// An attempt was made to add a duplicate multicast address to the list.
//
#define ERROR_NDIS_MULTICAST_EXISTS _NDIS_ERROR_TYPEDEF_(0x8034000AL)

//
// MessageId: ERROR_NDIS_MULTICAST_NOT_FOUND
//
// MessageText:
//
// At attempt was made to remove a multicast address that was never added.
//
#define ERROR_NDIS_MULTICAST_NOT_FOUND _NDIS_ERROR_TYPEDEF_(0x8034000BL)

//
// MessageId: ERROR_NDIS_REQUEST_ABORTED
//
// MessageText:
//
// Netowork interface aborted the request.
//
#define ERROR_NDIS_REQUEST_ABORTED _NDIS_ERROR_TYPEDEF_(0x8034000CL)

//
// MessageId: ERROR_NDIS_RESET_IN_PROGRESS
//
// MessageText:
//
// Network interface can not process the request because it is being reset.
//
#define ERROR_NDIS_RESET_IN_PROGRESS _NDIS_ERROR_TYPEDEF_(0x8034000DL)

//
// MessageId: ERROR_NDIS_NOT_SUPPORTED
//
// MessageText:
//
// Netword interface does not support this request.
//
#define ERROR_NDIS_NOT_SUPPORTED _NDIS_ERROR_TYPEDEF_(0x803400BBL)

//
// MessageId: ERROR_NDIS_INVALID_PACKET
//
// MessageText:
//
// An attempt was made to send an invalid packet on a network interface.
//
#define ERROR_NDIS_INVALID_PACKET _NDIS_ERROR_TYPEDEF_(0x8034000FL)

//
// MessageId: ERROR_NDIS_ADAPTER_NOT_READY
//
// MessageText:
//
// Network interface is not ready to complete this operation.
//
#define ERROR_NDIS_ADAPTER_NOT_READY _NDIS_ERROR_TYPEDEF_(0x80340011L)

//
// MessageId: ERROR_NDIS_INVALID_LENGTH
//
// MessageText:
//
// The length of the buffer submitted for this operation is not valid.
//
#define ERROR_NDIS_INVALID_LENGTH _NDIS_ERROR_TYPEDEF_(0x80340014L)

//
// MessageId: ERROR_NDIS_INVALID_DATA
//
// MessageText:
//
// The data used for this operation is not valid.
//
#define ERROR_NDIS_INVALID_DATA _NDIS_ERROR_TYPEDEF_(0x80340015L)

//
// MessageId: ERROR_NDIS_BUFFER_TOO_SHORT
//
// MessageText:
//
// The length of buffer submitted for this operation is too small.
//
#define ERROR_NDIS_BUFFER_TOO_SHORT _NDIS_ERROR_TYPEDEF_(0x80340016L)

//
// MessageId: ERROR_NDIS_INVALID_OID
//
// MessageText:
//
// Network interface does not support this OID (Object Identifier)
//
#define ERROR_NDIS_INVALID_OID _NDIS_ERROR_TYPEDEF_(0x80340017L)

//
// MessageId: ERROR_NDIS_ADAPTER_REMOVED
//
// MessageText:
//
// The network interface has been removed.
//
#define ERROR_NDIS_ADAPTER_REMOVED _NDIS_ERROR_TYPEDEF_(0x80340018L)

//
// MessageId: ERROR_NDIS_UNSUPPORTED_MEDIA
//
// MessageText:
//
// Network interface does not support this media type.
//
#define ERROR_NDIS_UNSUPPORTED_MEDIA _NDIS_ERROR_TYPEDEF_(0x80340019L)

//
// MessageId: ERROR_NDIS_GROUP_ADDRESS_IN_USE
//
// MessageText:
//
// An attempt was made to remove a token ring group address that is in use by other components.
//
#define ERROR_NDIS_GROUP_ADDRESS_IN_USE _NDIS_ERROR_TYPEDEF_(0x8034001AL)

//
// MessageId: ERROR_NDIS_FILE_NOT_FOUND
//
// MessageText:
//
// An attempt was made to map a file that can not be found.
//
#define ERROR_NDIS_FILE_NOT_FOUND _NDIS_ERROR_TYPEDEF_(0x8034001BL)

//
// MessageId: ERROR_NDIS_ERROR_READING_FILE
//
// MessageText:
//
// An error occured while NDIS tried to map the file.
//
#define ERROR_NDIS_ERROR_READING_FILE _NDIS_ERROR_TYPEDEF_(0x8034001CL)

//
// MessageId: ERROR_NDIS_ALREADY_MAPPED
//
// MessageText:
//
// An attempt was made to map a file that is alreay mapped.
//
#define ERROR_NDIS_ALREADY_MAPPED _NDIS_ERROR_TYPEDEF_(0x8034001DL)

//
// MessageId: ERROR_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
// An attempt to allocate a hardware resource failed because the resource is used by another component.
//
#define ERROR_NDIS_RESOURCE_CONFLICT _NDIS_ERROR_TYPEDEF_(0x8034001EL)

//
// MessageId: ERROR_NDIS_MEDIA_DISCONNECTED
//
// MessageText:
//
// The I/O operation failed because network media is disconnected or wireless access point is out of range.
//
#define ERROR_NDIS_MEDIA_DISCONNECTED _NDIS_ERROR_TYPEDEF_(0x8034001FL)

//
// MessageId: ERROR_NDIS_INVALID_ADDRESS
//
// MessageText:
//
// The network address used in the request is invalid.
//
#define ERROR_NDIS_INVALID_ADDRESS _NDIS_ERROR_TYPEDEF_(0x80340022L)

//
// MessageId: ERROR_NDIS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
// The specified request is not a valid operation for the target device.
//
#define ERROR_NDIS_INVALID_DEVICE_REQUEST _NDIS_ERROR_TYPEDEF_(0x80340010L)

//
// MessageId: ERROR_NDIS_PAUSED
//
// MessageText:
//
// The offload operation on the network interface has been paused.
//
#define ERROR_NDIS_PAUSED _NDIS_ERROR_TYPEDEF_(0x8034002AL)

//
// MessageId: ERROR_NDIS_INTERFACE_NOT_FOUND
//
// MessageText:
//
// Network interface was not found.
//
#define ERROR_NDIS_INTERFACE_NOT_FOUND _NDIS_ERROR_TYPEDEF_(0x8034002BL)

//
// MessageId: ERROR_NDIS_UNSUPPORTED_REVISION
//
// MessageText:
//
// The revision number specified in the structure is not supported.
//
#define ERROR_NDIS_UNSUPPORTED_REVISION _NDIS_ERROR_TYPEDEF_(0x8034002CL)

//
// MessageId: ERROR_NDIS_INVALID_PORT
//
// MessageText:
//
// The specified port does not exist on this network interface.
//
#define ERROR_NDIS_INVALID_PORT _NDIS_ERROR_TYPEDEF_(0x8034002DL)

//
// MessageId: ERROR_NDIS_INVALID_PORT_STATE
//
// MessageText:
//
// The current state of the specified port on this network interface does not support the requested operation.
//
#define ERROR_NDIS_INVALID_PORT_STATE _NDIS_ERROR_TYPEDEF_(0x8034002EL)

//
// MessageId: ERROR_NDIS_LOW_POWER_STATE
//
// MessageText:
//
// The miniport adapter is in low power state.
//
#define ERROR_NDIS_LOW_POWER_STATE _NDIS_ERROR_TYPEDEF_(0x8034002FL)


//
// NDIS error codes (802.11 wireless LAN)
//

//
// MessageId: ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED
//
// MessageText:
//
// The wireless local area network interface is in auto configuration mode and doesn't support the requested parameter change operation.
//
#define ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED _NDIS_ERROR_TYPEDEF_(0x80342000L)

//
// MessageId: ERROR_NDIS_DOT11_MEDIA_IN_USE
//
// MessageText:
//
// The wireless local area network interface is busy and can not perform the requested operation.
//
#define ERROR_NDIS_DOT11_MEDIA_IN_USE _NDIS_ERROR_TYPEDEF_(0x80342001L)

//
// MessageId: ERROR_NDIS_DOT11_POWER_STATE_INVALID
//
// MessageText:
//
// The wireless local area network interface is power down and doesn't support the requested operation.
//
#define ERROR_NDIS_DOT11_POWER_STATE_INVALID _NDIS_ERROR_TYPEDEF_(0x80342002L)

//
// MessageId: ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL
//
// MessageText:
//
// The list of wake on LAN patterns is full.
//
#define ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL _NDIS_ERROR_TYPEDEF_(0x80342003L)

//
// MessageId: ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL
//
// MessageText:
//
// The list of low power protocol offloads is full.
//
#define ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL _NDIS_ERROR_TYPEDEF_(0x80342004L)

//
// NDIS informational code (ndis.sys)
//

//
// MessageId: ERROR_NDIS_INDICATION_REQUIRED
//
// MessageText:
//
// The request will be completed later by NDIS status indication.
//
#define ERROR_NDIS_INDICATION_REQUIRED _NDIS_ERROR_TYPEDEF_(0x00340001L)

//
// NDIS Chimney Offload codes (ndis.sys)
//

//
// MessageId: ERROR_NDIS_OFFLOAD_POLICY
//
// MessageText:
//
// The TCP connection is not offloadable because of a local policy setting.
//
#define ERROR_NDIS_OFFLOAD_POLICY _NDIS_ERROR_TYPEDEF_(0xC034100FL)

//
// MessageId: ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED
//
// MessageText:
//
// The TCP connection is not offloadable by the Chimney Offload target.
//
#define ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED _NDIS_ERROR_TYPEDEF_(0xC0341012L)

//
// MessageId: ERROR_NDIS_OFFLOAD_PATH_REJECTED
//
// MessageText:
//
// The IP Path object is not in an offloadable state.
//
#define ERROR_NDIS_OFFLOAD_PATH_REJECTED _NDIS_ERROR_TYPEDEF_(0xC0341013L)

//
// Hypervisor error codes
//

//
// MessageId: ERROR_HV_INVALID_HYPERCALL_CODE
//
// MessageText:
//
// The hypervisor does not support the operation because the specified hypercall code is not supported.
//
#define ERROR_HV_INVALID_HYPERCALL_CODE _NDIS_ERROR_TYPEDEF_(0xC0350002L)

//
// MessageId: ERROR_HV_INVALID_HYPERCALL_INPUT
//
// MessageText:
//
// The hypervisor does not support the operation because the encoding for the hypercall input register is not supported.
//
#define ERROR_HV_INVALID_HYPERCALL_INPUT _NDIS_ERROR_TYPEDEF_(0xC0350003L)

//
// MessageId: ERROR_HV_INVALID_ALIGNMENT
//
// MessageText:
//
// The hypervisor could not perform the operation beacuse a parameter has an invalid alignment.
//
#define ERROR_HV_INVALID_ALIGNMENT _NDIS_ERROR_TYPEDEF_(0xC0350004L)

//
// MessageId: ERROR_HV_INVALID_PARAMETER
//
// MessageText:
//
// The hypervisor could not perform the operation beacuse an invalid parameter was specified.
//
#define ERROR_HV_INVALID_PARAMETER _NDIS_ERROR_TYPEDEF_(0xC0350005L)

//
// MessageId: ERROR_HV_ACCESS_DENIED
//
// MessageText:
//
// Access to the specified object was denied.
//
#define ERROR_HV_ACCESS_DENIED _NDIS_ERROR_TYPEDEF_(0xC0350006L)

//
// MessageId: ERROR_HV_INVALID_PARTITION_STATE
//
// MessageText:
//
// The hypervisor could not perform the operation because the partition is entering or in an invalid state.
//
#define ERROR_HV_INVALID_PARTITION_STATE _NDIS_ERROR_TYPEDEF_(0xC0350007L)

//
// MessageId: ERROR_HV_OPERATION_DENIED
//
// MessageText:
//
// The operation is not allowed in the current state.
//
#define ERROR_HV_OPERATION_DENIED _NDIS_ERROR_TYPEDEF_(0xC0350008L)

//
// MessageId: ERROR_HV_UNKNOWN_PROPERTY
//
// MessageText:
//
// The hypervisor does not recognize the specified partition property.
//
#define ERROR_HV_UNKNOWN_PROPERTY _NDIS_ERROR_TYPEDEF_(0xC0350009L)

//
// MessageId: ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The specified value of a partition property is out of range or violates an invariant.
//
#define ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE _NDIS_ERROR_TYPEDEF_(0xC035000AL)

//
// MessageId: ERROR_HV_INSUFFICIENT_MEMORY
//
// MessageText:
//
// There is not enough memory in the hypervisor pool to complete the operation.
//
#define ERROR_HV_INSUFFICIENT_MEMORY _NDIS_ERROR_TYPEDEF_(0xC035000BL)

//
// MessageId: ERROR_HV_PARTITION_TOO_DEEP
//
// MessageText:
//
// The maximum partition depth has been exceeded for the partition hierarchy.
//
#define ERROR_HV_PARTITION_TOO_DEEP _NDIS_ERROR_TYPEDEF_(0xC035000CL)

//
// MessageId: ERROR_HV_INVALID_PARTITION_ID
//
// MessageText:
//
// A partition with the specified partition Id does not exist.
//
#define ERROR_HV_INVALID_PARTITION_ID _NDIS_ERROR_TYPEDEF_(0xC035000DL)

//
// MessageId: ERROR_HV_INVALID_VP_INDEX
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified VP index is invalid.
//
#define ERROR_HV_INVALID_VP_INDEX _NDIS_ERROR_TYPEDEF_(0xC035000EL)

//
// MessageId: ERROR_HV_INVALID_PORT_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified port identifier is invalid.
//
#define ERROR_HV_INVALID_PORT_ID _NDIS_ERROR_TYPEDEF_(0xC0350011L)

//
// MessageId: ERROR_HV_INVALID_CONNECTION_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified connection identifier is invalid.
//
#define ERROR_HV_INVALID_CONNECTION_ID _NDIS_ERROR_TYPEDEF_(0xC0350012L)

//
// MessageId: ERROR_HV_INSUFFICIENT_BUFFERS
//
// MessageText:
//
// Not enough buffers were supplied to send a message.
//
#define ERROR_HV_INSUFFICIENT_BUFFERS _NDIS_ERROR_TYPEDEF_(0xC0350013L)

//
// MessageId: ERROR_HV_NOT_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has not been acknowledged.
//
#define ERROR_HV_NOT_ACKNOWLEDGED _NDIS_ERROR_TYPEDEF_(0xC0350014L)

//
// MessageId: ERROR_HV_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has already been acknowledged.
//
#define ERROR_HV_ACKNOWLEDGED _NDIS_ERROR_TYPEDEF_(0xC0350016L)

//
// MessageId: ERROR_HV_INVALID_SAVE_RESTORE_STATE
//
// MessageText:
//
// The indicated partition is not in a valid state for saving or restoring.
//
#define ERROR_HV_INVALID_SAVE_RESTORE_STATE _NDIS_ERROR_TYPEDEF_(0xC0350017L)

//
// MessageId: ERROR_HV_INVALID_SYNIC_STATE
//
// MessageText:
//
// The hypervisor could not complete the operation because a required feature of the synthetic interrupt controller (SynIC) was disabled.
//
#define ERROR_HV_INVALID_SYNIC_STATE _NDIS_ERROR_TYPEDEF_(0xC0350018L)

//
// MessageId: ERROR_HV_OBJECT_IN_USE
//
// MessageText:
//
// The hypervisor could not perform the operation because the object or value was either already in use or being used for a purpose that would not permit completing the operation.
//
#define ERROR_HV_OBJECT_IN_USE _NDIS_ERROR_TYPEDEF_(0xC0350019L)

//
// MessageId: ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO
//
// MessageText:
//
// The proximity domain information is invalid.
//
#define ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO _NDIS_ERROR_TYPEDEF_(0xC035001AL)

//
// MessageId: ERROR_HV_NO_DATA
//
// MessageText:
//
// An attempt to retrieve debugging data failed because none was available.
//
#define ERROR_HV_NO_DATA _NDIS_ERROR_TYPEDEF_(0xC035001BL)

//
// MessageId: ERROR_HV_INACTIVE
//
// MessageText:
//
// The physical connection being used for debuggging has not recorded any receive activity since the last operation.
//
#define ERROR_HV_INACTIVE _NDIS_ERROR_TYPEDEF_(0xC035001CL)

//
// MessageId: ERROR_HV_NO_RESOURCES
//
// MessageText:
//
// There are not enough resources to complete the operation.
//
#define ERROR_HV_NO_RESOURCES _NDIS_ERROR_TYPEDEF_(0xC035001DL)

//
// MessageId: ERROR_HV_FEATURE_UNAVAILABLE
//
// MessageText:
//
// A hypervisor feature is not available to the user.
//
#define ERROR_HV_FEATURE_UNAVAILABLE _NDIS_ERROR_TYPEDEF_(0xC035001EL)

//
// MessageId: ERROR_HV_NOT_PRESENT
//
// MessageText:
//
// No hypervisor is present on this system.
//
#define ERROR_HV_NOT_PRESENT _NDIS_ERROR_TYPEDEF_(0xC0351000L)

//
// Virtualization error codes - these codes are used by the Virtualization Infrustructure Driver (VID) and other components
//                              of the virtualization stack.
//
// Errors:
//

//
// MessageId: ERROR_VID_DUPLICATE_HANDLER
//
// MessageText:
//
// The handler for the virtualization infrastructure driver is already registered. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_DUPLICATE_HANDLER _NDIS_ERROR_TYPEDEF_(0xC0370001L)

//
// MessageId: ERROR_VID_TOO_MANY_HANDLERS
//
// MessageText:
//
// The number of registered handlers for the virtualization infrastructure driver exceeded the maximum. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_TOO_MANY_HANDLERS _NDIS_ERROR_TYPEDEF_(0xC0370002L)

//
// MessageId: ERROR_VID_QUEUE_FULL
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver is full and cannot accept new messages. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_QUEUE_FULL _NDIS_ERROR_TYPEDEF_(0xC0370003L)

//
// MessageId: ERROR_VID_HANDLER_NOT_PRESENT
//
// MessageText:
//
// No handler exists to handle the message for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_HANDLER_NOT_PRESENT _NDIS_ERROR_TYPEDEF_(0xC0370004L)

//
// MessageId: ERROR_VID_INVALID_OBJECT_NAME
//
// MessageText:
//
// The name of the partition or message queue for the virtualization infrastructure driver is invalid. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_INVALID_OBJECT_NAME _NDIS_ERROR_TYPEDEF_(0xC0370005L)

//
// MessageId: ERROR_VID_PARTITION_NAME_TOO_LONG
//
// MessageText:
//
// The partition name of the virtualization infrastructure driver exceeds the maximum.
//
#define ERROR_VID_PARTITION_NAME_TOO_LONG _NDIS_ERROR_TYPEDEF_(0xC0370006L)

//
// MessageId: ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG
//
// MessageText:
//
// The message queue name of the virtualization infrastructure driver exceeds the maximum.
//
#define ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG _NDIS_ERROR_TYPEDEF_(0xC0370007L)

//
// MessageId: ERROR_VID_PARTITION_ALREADY_EXISTS
//
// MessageText:
//
// Cannot create the partition for the virtualization infrastructure driver because another partition with the same name already exists.
//
#define ERROR_VID_PARTITION_ALREADY_EXISTS _NDIS_ERROR_TYPEDEF_(0xC0370008L)

//
// MessageId: ERROR_VID_PARTITION_DOES_NOT_EXIST
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. The requested partition does not exist. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_PARTITION_DOES_NOT_EXIST _NDIS_ERROR_TYPEDEF_(0xC0370009L)

//
// MessageId: ERROR_VID_PARTITION_NAME_NOT_FOUND
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. Could not find the requested partition. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_PARTITION_NAME_NOT_FOUND _NDIS_ERROR_TYPEDEF_(0xC037000AL)

//
// MessageId: ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS
//
// MessageText:
//
// A message queue with the same name already exists for the virtualization infrastructure driver.
//
#define ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS _NDIS_ERROR_TYPEDEF_(0xC037000BL)

//
// MessageId: ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT
//
// MessageText:
//
// The memory block page for the virtualization infrastructure driver cannot be mapped because the page map limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT _NDIS_ERROR_TYPEDEF_(0xC037000CL)

//
// MessageId: ERROR_VID_MB_STILL_REFERENCED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is still being used and cannot be destroyed.
//
#define ERROR_VID_MB_STILL_REFERENCED _NDIS_ERROR_TYPEDEF_(0xC037000DL)

//
// MessageId: ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED
//
// MessageText:
//
// Cannot unlock the page array for the guest operating system memory address because it does not match a previous lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED _NDIS_ERROR_TYPEDEF_(0xC037000EL)

//
// MessageId: ERROR_VID_INVALID_NUMA_SETTINGS
//
// MessageText:
//
// The non-uniform memory access (NUMA) node settings do not match the system NUMA topology. In order to start the virtual machine, you will need to modify the NUMA configuration. For detailed information, see http://go.microsoft.com/fwlink/?LinkId=92362.
//
#define ERROR_VID_INVALID_NUMA_SETTINGS _NDIS_ERROR_TYPEDEF_(0xC037000FL)

//
// MessageId: ERROR_VID_INVALID_NUMA_NODE_INDEX
//
// MessageText:
//
// The non-uniform memory access (NUMA) node index does not match a valid index in the system NUMA topology.
//
#define ERROR_VID_INVALID_NUMA_NODE_INDEX _NDIS_ERROR_TYPEDEF_(0xC0370010L)

//
// MessageId: ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is already associated with a message queue.
//
#define ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED _NDIS_ERROR_TYPEDEF_(0xC0370011L)

//
// MessageId: ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE
//
// MessageText:
//
// The handle is not a valid memory block handle for the virtualization infrastructure driver.
//
#define ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE _NDIS_ERROR_TYPEDEF_(0xC0370012L)

//
// MessageId: ERROR_VID_PAGE_RANGE_OVERFLOW
//
// MessageText:
//
// The request exceeded the memory block page limit for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_PAGE_RANGE_OVERFLOW _NDIS_ERROR_TYPEDEF_(0xC0370013L)

//
// MessageId: ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE
//
// MessageText:
//
// The handle is not a valid message queue handle for the virtualization infrastructure driver.
//
#define ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE _NDIS_ERROR_TYPEDEF_(0xC0370014L)

//
// MessageId: ERROR_VID_INVALID_GPA_RANGE_HANDLE
//
// MessageText:
//
// The handle is not a valid page range handle for the virtualization infrastructure driver.
//
#define ERROR_VID_INVALID_GPA_RANGE_HANDLE _NDIS_ERROR_TYPEDEF_(0xC0370015L)

//
// MessageId: ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE
//
// MessageText:
//
// Cannot install client notifications because no message queue for the virtualization infrastructure driver is associated with the memory block.
//
#define ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE _NDIS_ERROR_TYPEDEF_(0xC0370016L)

//
// MessageId: ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED
//
// MessageText:
//
// The request to lock or map a memory block page failed because the virtualization infrastructure driver memory block limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED _NDIS_ERROR_TYPEDEF_(0xC0370017L)

//
// MessageId: ERROR_VID_INVALID_PPM_HANDLE
//
// MessageText:
//
// The handle is not a valid parent partition mapping handle for the virtualization infrastructure driver.
//
#define ERROR_VID_INVALID_PPM_HANDLE _NDIS_ERROR_TYPEDEF_(0xC0370018L)

//
// MessageId: ERROR_VID_MBPS_ARE_LOCKED
//
// MessageText:
//
// Notifications cannot be created on the memory block because it is use.
//
#define ERROR_VID_MBPS_ARE_LOCKED _NDIS_ERROR_TYPEDEF_(0xC0370019L)

//
// MessageId: ERROR_VID_MESSAGE_QUEUE_CLOSED
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver has been closed. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_MESSAGE_QUEUE_CLOSED _NDIS_ERROR_TYPEDEF_(0xC037001AL)

//
// MessageId: ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED
//
// MessageText:
//
// Cannot add a virtual processor to the partition because the maximum has been reached.
//
#define ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED _NDIS_ERROR_TYPEDEF_(0xC037001BL)

//
// MessageId: ERROR_VID_STOP_PENDING
//
// MessageText:
//
// Cannot stop the virtual processor immediately because of a pending intercept.
//
#define ERROR_VID_STOP_PENDING _NDIS_ERROR_TYPEDEF_(0xC037001CL)

//
// MessageId: ERROR_VID_INVALID_PROCESSOR_STATE
//
// MessageText:
//
// Invalid state for the virtual processor. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_INVALID_PROCESSOR_STATE _NDIS_ERROR_TYPEDEF_(0xC037001DL)

//
// MessageId: ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT
//
// MessageText:
//
// The maximum number of kernel mode clients for the virtualization infrastructure driver has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT _NDIS_ERROR_TYPEDEF_(0xC037001EL)

//
// MessageId: ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED
//
// MessageText:
//
// This kernel mode interface for the virtualization infrastructure driver has already been initialized. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED _NDIS_ERROR_TYPEDEF_(0xC037001FL)

//
// MessageId: ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET
//
// MessageText:
//
// Cannot set or reset the memory block property more than once for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET _NDIS_ERROR_TYPEDEF_(0xC0370020L)

//
// MessageId: ERROR_VID_MMIO_RANGE_DESTROYED
//
// MessageText:
//
// The memory mapped I/O for this page range no longer exists. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_MMIO_RANGE_DESTROYED _NDIS_ERROR_TYPEDEF_(0xC0370021L)

//
// MessageId: ERROR_VID_INVALID_CHILD_GPA_PAGE_SET
//
// MessageText:
//
// The lock or unlock request uses an invalid guest operating system memory address. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_INVALID_CHILD_GPA_PAGE_SET _NDIS_ERROR_TYPEDEF_(0xC0370022L)

//
// MessageId: ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED
//
// MessageText:
//
// Cannot destroy or reuse the reserve page set for the virtualization infrastructure driver because it is in use. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED _NDIS_ERROR_TYPEDEF_(0xC0370023L)

//
// MessageId: ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL
//
// MessageText:
//
// The reserve page set for the virtualization infrastructure driver is too small to use in the lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL _NDIS_ERROR_TYPEDEF_(0xC0370024L)

//
// MessageId: ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE
//
// MessageText:
//
// Cannot lock or map the memory block page for the virtualization infrastructure driver because it has already been locked using a reserve page set page. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE _NDIS_ERROR_TYPEDEF_(0xC0370025L)

//
// MessageId: ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT
//
// MessageText:
//
// Cannot create the memory block for the virtualization infrastructure driver because the requested number of pages exceeded the limit. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
#define ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT _NDIS_ERROR_TYPEDEF_(0xC0370026L)

//
// MessageId: ERROR_VID_SAVED_STATE_CORRUPT
//
// MessageText:
//
// Cannot restore this virtual machine because the saved state data cannot be read. Delete the saved state data and then try to start the virtual machine.
//
#define ERROR_VID_SAVED_STATE_CORRUPT _NDIS_ERROR_TYPEDEF_(0xC0370027L)

//
// MessageId: ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM
//
// MessageText:
//
// Cannot restore this virtual machine because an item read from the saved state data is not recognized. Delete the saved state data and then try to start the virtual machine.
//
#define ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM _NDIS_ERROR_TYPEDEF_(0xC0370028L)

//
// MessageId: ERROR_VID_SAVED_STATE_INCOMPATIBLE
//
// MessageText:
//
// Cannot restore this virtual machine to the saved state because of hypervisor incompatibility. Delete the saved state data and then try to start the virtual machine.
//
#define ERROR_VID_SAVED_STATE_INCOMPATIBLE _NDIS_ERROR_TYPEDEF_(0xC0370029L)

//
// Warnings:
//
//
// MessageId: ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED
//
// MessageText:
//
// A virtual machine is running with its memory allocated across multiple NUMA nodes. This does not indicate a problem unless the performance of your virtual machine is unusually slow. If you are experiencing performance problems, you may need to modify the NUMA configuration. For detailed information, see http://go.microsoft.com/fwlink/?LinkId=92362.
//
#define ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED _NDIS_ERROR_TYPEDEF_(0x80370001L)


//
// Volume manager error codes mapped from status codes
//

//
// WARNINGS
//
//
// MessageId: ERROR_VOLMGR_INCOMPLETE_REGENERATION
//
// MessageText:
//
// The regeneration operation was not able to copy all data from the active plexes due to bad sectors.
//
#define ERROR_VOLMGR_INCOMPLETE_REGENERATION _NDIS_ERROR_TYPEDEF_(0x80380001L)

//
// MessageId: ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION
//
// MessageText:
//
// One or more disks were not fully migrated to the target pack. They may or may not require reimport after fixing the hardware problems.
//
#define ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION _NDIS_ERROR_TYPEDEF_(0x80380002L)

//
// ERRORS
//
//
// MessageId: ERROR_VOLMGR_DATABASE_FULL
//
// MessageText:
//
// The configuration database is full.
//
#define ERROR_VOLMGR_DATABASE_FULL _NDIS_ERROR_TYPEDEF_(0xC0380001L)

//
// MessageId: ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED
//
// MessageText:
//
// The configuration data on the disk is corrupted.
//
#define ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED _NDIS_ERROR_TYPEDEF_(0xC0380002L)

//
// MessageId: ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC
//
// MessageText:
//
// The configuration on the disk is not insync with the in-memory configuration.
//
#define ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC _NDIS_ERROR_TYPEDEF_(0xC0380003L)

//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED
//
// MessageText:
//
// A majority of disks failed to be updated with the new configuration.
//
#define ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED _NDIS_ERROR_TYPEDEF_(0xC0380004L)

//
// MessageId: ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME
//
// MessageText:
//
// The disk contains non-simple volumes.
//
#define ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME _NDIS_ERROR_TYPEDEF_(0xC0380005L)

//
// MessageId: ERROR_VOLMGR_DISK_DUPLICATE
//
// MessageText:
//
// The same disk was specified more than once in the migration list.
//
#define ERROR_VOLMGR_DISK_DUPLICATE _NDIS_ERROR_TYPEDEF_(0xC0380006L)

//
// MessageId: ERROR_VOLMGR_DISK_DYNAMIC
//
// MessageText:
//
// The disk is already dynamic.
//
#define ERROR_VOLMGR_DISK_DYNAMIC _NDIS_ERROR_TYPEDEF_(0xC0380007L)

//
// MessageId: ERROR_VOLMGR_DISK_ID_INVALID
//
// MessageText:
//
// The specified disk id is invalid. There are no disks with the specified disk id.
//
#define ERROR_VOLMGR_DISK_ID_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380008L)

//
// MessageId: ERROR_VOLMGR_DISK_INVALID
//
// MessageText:
//
// The specified disk is an invalid disk. Operation cannot complete on an invalid disk.
//
#define ERROR_VOLMGR_DISK_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380009L)

//
// MessageId: ERROR_VOLMGR_DISK_LAST_VOTER
//
// MessageText:
//
// The specified disk(s) cannot be removed since it is the last remaining voter.
//
#define ERROR_VOLMGR_DISK_LAST_VOTER _NDIS_ERROR_TYPEDEF_(0xC038000AL)

//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_INVALID
//
// MessageText:
//
// The specified disk has an invalid disk layout.
//
#define ERROR_VOLMGR_DISK_LAYOUT_INVALID _NDIS_ERROR_TYPEDEF_(0xC038000BL)

//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS
//
// MessageText:
//
// The disk layout contains non-basic partitions which appear after basic paritions. This is an invalid disk layout.
//
#define ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS _NDIS_ERROR_TYPEDEF_(0xC038000CL)

//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED
//
// MessageText:
//
// The disk layout contains partitions which are not cylinder aligned.
//
#define ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED _NDIS_ERROR_TYPEDEF_(0xC038000DL)

//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL
//
// MessageText:
//
// The disk layout contains partitions which are samller than the minimum size.
//
#define ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL _NDIS_ERROR_TYPEDEF_(0xC038000EL)

//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS
//
// MessageText:
//
// The disk layout contains primary partitions in between logical drives. This is an invalid disk layout.
//
#define ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS _NDIS_ERROR_TYPEDEF_(0xC038000FL)

//
// MessageId: ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS
//
// MessageText:
//
// The disk layout contains more than the maximum number of supported partitions.
//
#define ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS _NDIS_ERROR_TYPEDEF_(0xC0380010L)

//
// MessageId: ERROR_VOLMGR_DISK_MISSING
//
// MessageText:
//
// The specified disk is missing. The operation cannot complete on a missing disk.
//
#define ERROR_VOLMGR_DISK_MISSING _NDIS_ERROR_TYPEDEF_(0xC0380011L)

//
// MessageId: ERROR_VOLMGR_DISK_NOT_EMPTY
//
// MessageText:
//
// The specified disk is not empty.
//
#define ERROR_VOLMGR_DISK_NOT_EMPTY _NDIS_ERROR_TYPEDEF_(0xC0380012L)

//
// MessageId: ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough usable space for this operation.
//
#define ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE _NDIS_ERROR_TYPEDEF_(0xC0380013L)

//
// MessageId: ERROR_VOLMGR_DISK_REVECTORING_FAILED
//
// MessageText:
//
// The force revectoring of bad sectors failed.
//
#define ERROR_VOLMGR_DISK_REVECTORING_FAILED _NDIS_ERROR_TYPEDEF_(0xC0380014L)

//
// MessageId: ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID
//
// MessageText:
//
// The specified disk has an invalid sector size.
//
#define ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380015L)

//
// MessageId: ERROR_VOLMGR_DISK_SET_NOT_CONTAINED
//
// MessageText:
//
// The specified disk set contains volumes which exist on disks outside of the set.
//
#define ERROR_VOLMGR_DISK_SET_NOT_CONTAINED _NDIS_ERROR_TYPEDEF_(0xC0380016L)

//
// MessageId: ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one member of a plex.
//
#define ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS _NDIS_ERROR_TYPEDEF_(0xC0380017L)

//
// MessageId: ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one plex.
//
#define ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES _NDIS_ERROR_TYPEDEF_(0xC0380018L)

//
// MessageId: ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED
//
// MessageText:
//
// Dynamic disks are not supported on this system.
//
#define ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED _NDIS_ERROR_TYPEDEF_(0xC0380019L)

//
// MessageId: ERROR_VOLMGR_EXTENT_ALREADY_USED
//
// MessageText:
//
// The specified extent is already used by other volumes.
//
#define ERROR_VOLMGR_EXTENT_ALREADY_USED _NDIS_ERROR_TYPEDEF_(0xC038001AL)

//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS
//
// MessageText:
//
// The specified volume is retained and can only be extended into a contiguous extent. The specified extent to grow the volume is not contiguous with the specified volume.
//
#define ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS _NDIS_ERROR_TYPEDEF_(0xC038001BL)

//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION
//
// MessageText:
//
// The specified volume extent is not within the public region of the disk.
//
#define ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION _NDIS_ERROR_TYPEDEF_(0xC038001CL)

//
// MessageId: ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED
//
// MessageText:
//
// The specifed volume extent is not sector aligned.
//
#define ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED _NDIS_ERROR_TYPEDEF_(0xC038001DL)

//
// MessageId: ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION
//
// MessageText:
//
// The specified parition overlaps an EBR (the first track of an extended partition on a MBR disks).
//
#define ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION _NDIS_ERROR_TYPEDEF_(0xC038001EL)

//
// MessageId: ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH
//
// MessageText:
//
// The specified extent lengths cannot be used to construct a volume with specified length.
//
#define ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH _NDIS_ERROR_TYPEDEF_(0xC038001FL)

//
// MessageId: ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support fault tolerant volumes.
//
#define ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED _NDIS_ERROR_TYPEDEF_(0xC0380020L)

//
// MessageId: ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID
//
// MessageText:
//
// The specified interleave length is invalid.
//
#define ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380021L)

//
// MessageId: ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS
//
// MessageText:
//
// There is already a maximum number of registered users.
//
#define ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS _NDIS_ERROR_TYPEDEF_(0xC0380022L)

//
// MessageId: ERROR_VOLMGR_MEMBER_IN_SYNC
//
// MessageText:
//
// The specified member is already in-sync with the other active members. It does not need to be regenerated.
//
#define ERROR_VOLMGR_MEMBER_IN_SYNC _NDIS_ERROR_TYPEDEF_(0xC0380023L)

//
// MessageId: ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE
//
// MessageText:
//
// The same member index was specified more than once.
//
#define ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE _NDIS_ERROR_TYPEDEF_(0xC0380024L)

//
// MessageId: ERROR_VOLMGR_MEMBER_INDEX_INVALID
//
// MessageText:
//
// The specified member index is greater or equal than the number of members in the volume plex.
//
#define ERROR_VOLMGR_MEMBER_INDEX_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380025L)

//
// MessageId: ERROR_VOLMGR_MEMBER_MISSING
//
// MessageText:
//
// The specified member is missing. It cannot be regenerated.
//
#define ERROR_VOLMGR_MEMBER_MISSING _NDIS_ERROR_TYPEDEF_(0xC0380026L)

//
// MessageId: ERROR_VOLMGR_MEMBER_NOT_DETACHED
//
// MessageText:
//
// The specified member is not detached. Cannot replace a member which is not detached.
//
#define ERROR_VOLMGR_MEMBER_NOT_DETACHED _NDIS_ERROR_TYPEDEF_(0xC0380027L)

//
// MessageId: ERROR_VOLMGR_MEMBER_REGENERATING
//
// MessageText:
//
// The specified member is already regenerating.
//
#define ERROR_VOLMGR_MEMBER_REGENERATING _NDIS_ERROR_TYPEDEF_(0xC0380028L)

//
// MessageId: ERROR_VOLMGR_ALL_DISKS_FAILED
//
// MessageText:
//
// All disks belonging to the pack failed.
//
#define ERROR_VOLMGR_ALL_DISKS_FAILED _NDIS_ERROR_TYPEDEF_(0xC0380029L)

//
// MessageId: ERROR_VOLMGR_NO_REGISTERED_USERS
//
// MessageText:
//
// There are currently no registered users for notifications. The task number is irrelevant unless there are registered users.
//
#define ERROR_VOLMGR_NO_REGISTERED_USERS _NDIS_ERROR_TYPEDEF_(0xC038002AL)

//
// MessageId: ERROR_VOLMGR_NO_SUCH_USER
//
// MessageText:
//
// The specified notification user does not exist. Failed to unregister user for notifications.
//
#define ERROR_VOLMGR_NO_SUCH_USER _NDIS_ERROR_TYPEDEF_(0xC038002BL)

//
// MessageId: ERROR_VOLMGR_NOTIFICATION_RESET
//
// MessageText:
//
// The notifications have been reset. Notifications for the current user are invalid. Unregister and re-register for notifications.
//
#define ERROR_VOLMGR_NOTIFICATION_RESET _NDIS_ERROR_TYPEDEF_(0xC038002CL)

//
// MessageId: ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID
//
// MessageText:
//
// The specified number of members is invalid.
//
#define ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID _NDIS_ERROR_TYPEDEF_(0xC038002DL)

//
// MessageId: ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID
//
// MessageText:
//
// The specified number of plexes is invalid.
//
#define ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID _NDIS_ERROR_TYPEDEF_(0xC038002EL)

//
// MessageId: ERROR_VOLMGR_PACK_DUPLICATE
//
// MessageText:
//
// The specified source and target packs are identical.
//
#define ERROR_VOLMGR_PACK_DUPLICATE _NDIS_ERROR_TYPEDEF_(0xC038002FL)

//
// MessageId: ERROR_VOLMGR_PACK_ID_INVALID
//
// MessageText:
//
// The specified pack id is invalid. There are no packs with the specified pack id.
//
#define ERROR_VOLMGR_PACK_ID_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380030L)

//
// MessageId: ERROR_VOLMGR_PACK_INVALID
//
// MessageText:
//
// The specified pack is the invalid pack. The operation cannot complete with the invalid pack.
//
#define ERROR_VOLMGR_PACK_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380031L)

//
// MessageId: ERROR_VOLMGR_PACK_NAME_INVALID
//
// MessageText:
//
// The specified pack name is invalid.
//
#define ERROR_VOLMGR_PACK_NAME_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380032L)

//
// MessageId: ERROR_VOLMGR_PACK_OFFLINE
//
// MessageText:
//
// The specified pack is offline.
//
#define ERROR_VOLMGR_PACK_OFFLINE _NDIS_ERROR_TYPEDEF_(0xC0380033L)

//
// MessageId: ERROR_VOLMGR_PACK_HAS_QUORUM
//
// MessageText:
//
// The specified pack already has a quorum of healthy disks.
//
#define ERROR_VOLMGR_PACK_HAS_QUORUM _NDIS_ERROR_TYPEDEF_(0xC0380034L)

//
// MessageId: ERROR_VOLMGR_PACK_WITHOUT_QUORUM
//
// MessageText:
//
// The pack does not have a quorum of healthy disks.
//
#define ERROR_VOLMGR_PACK_WITHOUT_QUORUM _NDIS_ERROR_TYPEDEF_(0xC0380035L)

//
// MessageId: ERROR_VOLMGR_PARTITION_STYLE_INVALID
//
// MessageText:
//
// The specified disk has an unsupported partition style. Only MBR and GPT partition styles are supported.
//
#define ERROR_VOLMGR_PARTITION_STYLE_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380036L)

//
// MessageId: ERROR_VOLMGR_PARTITION_UPDATE_FAILED
//
// MessageText:
//
// Failed to update the disk's partition layout.
//
#define ERROR_VOLMGR_PARTITION_UPDATE_FAILED _NDIS_ERROR_TYPEDEF_(0xC0380037L)

//
// MessageId: ERROR_VOLMGR_PLEX_IN_SYNC
//
// MessageText:
//
// The specified plex is already in-sync with the other active plexes. It does not need to be regenerated.
//
#define ERROR_VOLMGR_PLEX_IN_SYNC _NDIS_ERROR_TYPEDEF_(0xC0380038L)

//
// MessageId: ERROR_VOLMGR_PLEX_INDEX_DUPLICATE
//
// MessageText:
//
// The same plex index was specified more than once.
//
#define ERROR_VOLMGR_PLEX_INDEX_DUPLICATE _NDIS_ERROR_TYPEDEF_(0xC0380039L)

//
// MessageId: ERROR_VOLMGR_PLEX_INDEX_INVALID
//
// MessageText:
//
// The specified plex index is greater or equal than the number of plexes in the volume.
//
#define ERROR_VOLMGR_PLEX_INDEX_INVALID _NDIS_ERROR_TYPEDEF_(0xC038003AL)

//
// MessageId: ERROR_VOLMGR_PLEX_LAST_ACTIVE
//
// MessageText:
//
// The specified plex is the last active plex in the volume. The plex cannot be removed or else the volume will go offline.
//
#define ERROR_VOLMGR_PLEX_LAST_ACTIVE _NDIS_ERROR_TYPEDEF_(0xC038003BL)

//
// MessageId: ERROR_VOLMGR_PLEX_MISSING
//
// MessageText:
//
// The specified plex is missing.
//
#define ERROR_VOLMGR_PLEX_MISSING _NDIS_ERROR_TYPEDEF_(0xC038003CL)

//
// MessageId: ERROR_VOLMGR_PLEX_REGENERATING
//
// MessageText:
//
// The specified plex is currently regenerating.
//
#define ERROR_VOLMGR_PLEX_REGENERATING _NDIS_ERROR_TYPEDEF_(0xC038003DL)

//
// MessageId: ERROR_VOLMGR_PLEX_TYPE_INVALID
//
// MessageText:
//
// The specified plex type is invalid.
//
#define ERROR_VOLMGR_PLEX_TYPE_INVALID _NDIS_ERROR_TYPEDEF_(0xC038003EL)

//
// MessageId: ERROR_VOLMGR_PLEX_NOT_RAID5
//
// MessageText:
//
// The operation is only supported on RAID-5 plexes.
//
#define ERROR_VOLMGR_PLEX_NOT_RAID5 _NDIS_ERROR_TYPEDEF_(0xC038003FL)

//
// MessageId: ERROR_VOLMGR_PLEX_NOT_SIMPLE
//
// MessageText:
//
// The operation is only supported on simple plexes.
//
#define ERROR_VOLMGR_PLEX_NOT_SIMPLE _NDIS_ERROR_TYPEDEF_(0xC0380040L)

//
// MessageId: ERROR_VOLMGR_STRUCTURE_SIZE_INVALID
//
// MessageText:
//
// The Size fields in the VM_VOLUME_LAYOUT input structure are incorrectly set.
//
#define ERROR_VOLMGR_STRUCTURE_SIZE_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380041L)

//
// MessageId: ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS
//
// MessageText:
//
// There is already a pending request for notifications. Wait for the existing request to return before requesting for more notifications.
//
#define ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS _NDIS_ERROR_TYPEDEF_(0xC0380042L)

//
// MessageId: ERROR_VOLMGR_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// There is currently a transaction in process.
//
#define ERROR_VOLMGR_TRANSACTION_IN_PROGRESS _NDIS_ERROR_TYPEDEF_(0xC0380043L)

//
// MessageId: ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE
//
// MessageText:
//
// An unexpected layout change occurred outside of the volume manager.
//
#define ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE _NDIS_ERROR_TYPEDEF_(0xC0380044L)

//
// MessageId: ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK
//
// MessageText:
//
// The specified volume contains a missing disk.
//
#define ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK _NDIS_ERROR_TYPEDEF_(0xC0380045L)

//
// MessageId: ERROR_VOLMGR_VOLUME_ID_INVALID
//
// MessageText:
//
// The specified volume id is invalid. There are no volumes with the specified volume id.
//
#define ERROR_VOLMGR_VOLUME_ID_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380046L)

//
// MessageId: ERROR_VOLMGR_VOLUME_LENGTH_INVALID
//
// MessageText:
//
// The specified volume length is invalid.
//
#define ERROR_VOLMGR_VOLUME_LENGTH_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380047L)

//
// MessageId: ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The specified size for the volume is not a multiple of the sector size.
//
#define ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE _NDIS_ERROR_TYPEDEF_(0xC0380048L)

//
// MessageId: ERROR_VOLMGR_VOLUME_NOT_MIRRORED
//
// MessageText:
//
// The operation is only supported on mirrored volumes.
//
#define ERROR_VOLMGR_VOLUME_NOT_MIRRORED _NDIS_ERROR_TYPEDEF_(0xC0380049L)

//
// MessageId: ERROR_VOLMGR_VOLUME_NOT_RETAINED
//
// MessageText:
//
// The specified volume does not have a retain partition.
//
#define ERROR_VOLMGR_VOLUME_NOT_RETAINED _NDIS_ERROR_TYPEDEF_(0xC038004AL)

//
// MessageId: ERROR_VOLMGR_VOLUME_OFFLINE
//
// MessageText:
//
// The specified volume is offline.
//
#define ERROR_VOLMGR_VOLUME_OFFLINE _NDIS_ERROR_TYPEDEF_(0xC038004BL)

//
// MessageId: ERROR_VOLMGR_VOLUME_RETAINED
//
// MessageText:
//
// The specified volume already has a retain partition.
//
#define ERROR_VOLMGR_VOLUME_RETAINED _NDIS_ERROR_TYPEDEF_(0xC038004CL)

//
// MessageId: ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID
//
// MessageText:
//
// The specified number of extents is invalid.
//
#define ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID _NDIS_ERROR_TYPEDEF_(0xC038004DL)

//
// MessageId: ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE
//
// MessageText:
//
// All disks participating to the volume must have the same sector size.
//
#define ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE _NDIS_ERROR_TYPEDEF_(0xC038004EL)

//
// MessageId: ERROR_VOLMGR_BAD_BOOT_DISK
//
// MessageText:
//
// The boot disk experienced failures.
//
#define ERROR_VOLMGR_BAD_BOOT_DISK _NDIS_ERROR_TYPEDEF_(0xC038004FL)

//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_OFFLINE
//
// MessageText:
//
// The configuration of the pack is offline.
//
#define ERROR_VOLMGR_PACK_CONFIG_OFFLINE _NDIS_ERROR_TYPEDEF_(0xC0380050L)

//
// MessageId: ERROR_VOLMGR_PACK_CONFIG_ONLINE
//
// MessageText:
//
// The configuration of the pack is online.
//
#define ERROR_VOLMGR_PACK_CONFIG_ONLINE _NDIS_ERROR_TYPEDEF_(0xC0380051L)

//
// MessageId: ERROR_VOLMGR_NOT_PRIMARY_PACK
//
// MessageText:
//
// The specified pack is not the primary pack.
//
#define ERROR_VOLMGR_NOT_PRIMARY_PACK _NDIS_ERROR_TYPEDEF_(0xC0380052L)

//
// MessageId: ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED
//
// MessageText:
//
// All disks failed to be updated with the new content of the log.
//
#define ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED _NDIS_ERROR_TYPEDEF_(0xC0380053L)

//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID
//
// MessageText:
//
// The specified number of disks in a plex is invalid.
//
#define ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380054L)

//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID
//
// MessageText:
//
// The specified number of disks in a plex member is invalid.
//
#define ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID _NDIS_ERROR_TYPEDEF_(0xC0380055L)

//
// MessageId: ERROR_VOLMGR_VOLUME_MIRRORED
//
// MessageText:
//
// The operation is not supported on mirrored volumes.
//
#define ERROR_VOLMGR_VOLUME_MIRRORED _NDIS_ERROR_TYPEDEF_(0xC0380056L)

//
// MessageId: ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED
//
// MessageText:
//
// The operation is only supported on simple and spanned plexes.
//
#define ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED _NDIS_ERROR_TYPEDEF_(0xC0380057L)

//
// MessageId: ERROR_VOLMGR_NO_VALID_LOG_COPIES
//
// MessageText:
//
// The pack has no valid log copies.
//
#define ERROR_VOLMGR_NO_VALID_LOG_COPIES _NDIS_ERROR_TYPEDEF_(0xC0380058L)

//
// MessageId: ERROR_VOLMGR_PRIMARY_PACK_PRESENT
//
// MessageText:
//
// A primary pack is already present.
//
#define ERROR_VOLMGR_PRIMARY_PACK_PRESENT _NDIS_ERROR_TYPEDEF_(0xC0380059L)

//
// MessageId: ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID
//
// MessageText:
//
// The specified number of disks is invalid.
//
#define ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID _NDIS_ERROR_TYPEDEF_(0xC038005AL)

//
// MessageId: ERROR_VOLMGR_MIRROR_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support mirrored volumes.
//
#define ERROR_VOLMGR_MIRROR_NOT_SUPPORTED _NDIS_ERROR_TYPEDEF_(0xC038005BL)

//
// MessageId: ERROR_VOLMGR_RAID5_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support RAID-5 volumes.
//
#define ERROR_VOLMGR_RAID5_NOT_SUPPORTED _NDIS_ERROR_TYPEDEF_(0xC038005CL)


//
// Boot Code Data (BCD) error codes
//

//
// MessageId: ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED
//
// MessageText:
//
// Some BCD entries were not imported correctly from the BCD store.
//
#define ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED _NDIS_ERROR_TYPEDEF_(0x80390001L)

//
// MessageId: ERROR_BCD_TOO_MANY_ELEMENTS
//
// MessageText:
//
// Entries enumerated have exceeded the allowed threshold.
//
#define ERROR_BCD_TOO_MANY_ELEMENTS _NDIS_ERROR_TYPEDEF_(0xC0390002L)

//
// MessageId: ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED
//
// MessageText:
//
// Some BCD entries were not synchronized correctly with the firmware.
//
#define ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED _NDIS_ERROR_TYPEDEF_(0x80390003L)

//
// Vhd error codes - These codes are used by the virtual hard diskparser component.
//
//
// Errors:
//

//
// MessageId: ERROR_VHD_DRIVE_FOOTER_MISSING
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer is missing.
//
#define ERROR_VHD_DRIVE_FOOTER_MISSING _NDIS_ERROR_TYPEDEF_(0xC03A0001L)

//
// MessageId: ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer checksum does not match the on-disk checksum.
//
#define ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH _NDIS_ERROR_TYPEDEF_(0xC03A0002L)

//
// MessageId: ERROR_VHD_DRIVE_FOOTER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer in the virtual hard disk is corrupted.
//
#define ERROR_VHD_DRIVE_FOOTER_CORRUPT _NDIS_ERROR_TYPEDEF_(0xC03A0003L)

//
// MessageId: ERROR_VHD_FORMAT_UNKNOWN
//
// MessageText:
//
// The system does not recognize the file format of this virtual hard disk.
//
#define ERROR_VHD_FORMAT_UNKNOWN _NDIS_ERROR_TYPEDEF_(0xC03A0004L)

//
// MessageId: ERROR_VHD_FORMAT_UNSUPPORTED_VERSION
//
// MessageText:
//
// The version does not support this version of the file format.
//
#define ERROR_VHD_FORMAT_UNSUPPORTED_VERSION _NDIS_ERROR_TYPEDEF_(0xC03A0005L)

//
// MessageId: ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header checksum does not match the on-disk checksum.
//
#define ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH _NDIS_ERROR_TYPEDEF_(0xC03A0006L)

//
// MessageId: ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION
//
// MessageText:
//
// The system does not support this version of the virtual hard disk.This version of the sparse header is not supported.
//
#define ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION _NDIS_ERROR_TYPEDEF_(0xC03A0007L)

//
// MessageId: ERROR_VHD_SPARSE_HEADER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header in the virtual hard disk is corrupt.
//
#define ERROR_VHD_SPARSE_HEADER_CORRUPT _NDIS_ERROR_TYPEDEF_(0xC03A0008L)

//
// MessageId: ERROR_VHD_BLOCK_ALLOCATION_FAILURE
//
// MessageText:
//
// Failed to write to the virtual hard disk failed because the system failed to allocate a new block in the virtual hard disk.
//
#define ERROR_VHD_BLOCK_ALLOCATION_FAILURE _NDIS_ERROR_TYPEDEF_(0xC03A0009L)

//
// MessageId: ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The block allocation table in the virtual hard disk is corrupt.
//
#define ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT _NDIS_ERROR_TYPEDEF_(0xC03A000AL)

//
// MessageId: ERROR_VHD_INVALID_BLOCK_SIZE
//
// MessageText:
//
// The system does not support this version of the virtual hard disk. The block size is invalid.
//
#define ERROR_VHD_INVALID_BLOCK_SIZE _NDIS_ERROR_TYPEDEF_(0xC03A000BL)

//
// MessageId: ERROR_VHD_BITMAP_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The block bitmap does not match with the block data present in the virtual hard disk.
//
#define ERROR_VHD_BITMAP_MISMATCH _NDIS_ERROR_TYPEDEF_(0xC03A000CL)

//
// MessageId: ERROR_VHD_PARENT_VHD_NOT_FOUND
//
// MessageText:
//
// The chain of virtual hard disks is broken. The system cannot locate the parent virtual hard disk for the differencing disk.
//
#define ERROR_VHD_PARENT_VHD_NOT_FOUND _NDIS_ERROR_TYPEDEF_(0xC03A000DL)

//
// MessageId: ERROR_VHD_CHILD_PARENT_ID_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the identifiers of the parent virtual hard disk and differencing disk.
//
#define ERROR_VHD_CHILD_PARENT_ID_MISMATCH _NDIS_ERROR_TYPEDEF_(0xC03A000EL)

//
// MessageId: ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. The time stamp of the parent virtual hard disk does not match the time stamp of the differencing disk.
//
#define ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH _NDIS_ERROR_TYPEDEF_(0xC03A000FL)

//
// MessageId: ERROR_VHD_METADATA_READ_FAILURE
//
// MessageText:
//
// Failed to read the metadata of the virtual hard disk.
//
#define ERROR_VHD_METADATA_READ_FAILURE _NDIS_ERROR_TYPEDEF_(0xC03A0010L)

//
// MessageId: ERROR_VHD_METADATA_WRITE_FAILURE
//
// MessageText:
//
// Failed to write to the metadata of the virtual hard disk.
//
#define ERROR_VHD_METADATA_WRITE_FAILURE _NDIS_ERROR_TYPEDEF_(0xC03A0011L)

//
// MessageId: ERROR_VHD_INVALID_SIZE
//
// MessageText:
//
// The size of the virtual hard disk is not valid.
//
#define ERROR_VHD_INVALID_SIZE _NDIS_ERROR_TYPEDEF_(0xC03A0012L)

//
// MessageId: ERROR_VHD_INVALID_FILE_SIZE
//
// MessageText:
//
// The file size of this virtual hard disk is not valid.
//
#define ERROR_VHD_INVALID_FILE_SIZE _NDIS_ERROR_TYPEDEF_(0xC03A0013L)

//
// MessageId: ERROR_VIRTDISK_PROVIDER_NOT_FOUND
//
// MessageText:
//
// A virtual disk support provider for the specified file was not found.
//
#define ERROR_VIRTDISK_PROVIDER_NOT_FOUND _NDIS_ERROR_TYPEDEF_(0xC03A0014L)

//
// MessageId: ERROR_VIRTDISK_NOT_VIRTUAL_DISK
//
// MessageText:
//
// The specified disk is not a virtual disk.
//
#define ERROR_VIRTDISK_NOT_VIRTUAL_DISK _NDIS_ERROR_TYPEDEF_(0xC03A0015L)

//
// MessageId: ERROR_VHD_PARENT_VHD_ACCESS_DENIED
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. The process has not been granted access rights to the parent virtual hard disk for the differencing disk.
//
#define ERROR_VHD_PARENT_VHD_ACCESS_DENIED _NDIS_ERROR_TYPEDEF_(0xC03A0016L)

//
// MessageId: ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the virtual sizes of the parent virtual hard disk and differencing disk.
//
#define ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH _NDIS_ERROR_TYPEDEF_(0xC03A0017L)

//
// MessageId: ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. A differencing disk is indicated in its own parent chain.
//
#define ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED _NDIS_ERROR_TYPEDEF_(0xC03A0018L)

//
// MessageId: ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. There was an error opening a virtual hard disk further up the chain.
//
#define ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT _NDIS_ERROR_TYPEDEF_(0xC03A0019L)

//
// MessageId: ERROR_VIRTUAL_DISK_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a virtual disk system limitation.  Virtual disks are only supported on NTFS volumes and must be both uncompressed and unencrypted.
//
#define ERROR_VIRTUAL_DISK_LIMITATION _NDIS_ERROR_TYPEDEF_(0xC03A001AL)

//
// MessageId: ERROR_VHD_INVALID_TYPE
//
// MessageText:
//
// The requested operation cannot be performed on a virtual disk of this type.
//
#define ERROR_VHD_INVALID_TYPE _NDIS_ERROR_TYPEDEF_(0xC03A001BL)

//
// MessageId: ERROR_VHD_INVALID_STATE
//
// MessageText:
//
// The requested operation cannot be performed on the virtual disk in its current state.
//
#define ERROR_VHD_INVALID_STATE _NDIS_ERROR_TYPEDEF_(0xC03A001CL)

//
// MessageId: ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE
//
// MessageText:
//
// The sector size of the physical disk on which the virtual disk resides is not supported.
//
#define ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE _NDIS_ERROR_TYPEDEF_(0xC03A001DL)

//
// Warnings:
//
//
// MessageId: ERROR_QUERY_STORAGE_ERROR
//
// MessageText:
//
// The virtualization storage subsystem has generated an error.
//
#define ERROR_QUERY_STORAGE_ERROR _NDIS_ERROR_TYPEDEF_(0x803A0001L)

//
// =======================================================
// Facility Scripted Diagnostics (SDIAG) Error Messages
// =======================================================
//
//
// MessageId: SDIAG_E_CANCELLED
//
// MessageText:
//
// The operation was cancelled.
//
#define SDIAG_E_CANCELLED _NDIS_ERROR_TYPEDEF_(0x803C0100L)

//
// MessageId: SDIAG_E_SCRIPT
//
// MessageText:
//
// An error occurred when running a PowerShell script.
//
#define SDIAG_E_SCRIPT _NDIS_ERROR_TYPEDEF_(0x803C0101L)

//
// MessageId: SDIAG_E_POWERSHELL
//
// MessageText:
//
// An error occurred when interacting with PowerShell runtime.
//
#define SDIAG_E_POWERSHELL _NDIS_ERROR_TYPEDEF_(0x803C0102L)

//
// MessageId: SDIAG_E_MANAGEDHOST
//
// MessageText:
//
// An error occurred in the Scripted Diagnostic Managed Host.
//
#define SDIAG_E_MANAGEDHOST _NDIS_ERROR_TYPEDEF_(0x803C0103L)

//
// MessageId: SDIAG_E_NOVERIFIER
//
// MessageText:
//
// The troubleshooting pack does not contain a required verifier to complete the verification.
//
#define SDIAG_E_NOVERIFIER _NDIS_ERROR_TYPEDEF_(0x803C0104L)

//
// MessageId: SDIAG_S_CANNOTRUN
//
// MessageText:
//
// The troubleshooting pack cannot be executed on this system.
//
#define SDIAG_S_CANNOTRUN _NDIS_ERROR_TYPEDEF_(0x003C0105L)

//
// MessageId: SDIAG_E_DISABLED
//
// MessageText:
//
// Scripted diagnostics is disabled by group policy.
//
#define SDIAG_E_DISABLED _NDIS_ERROR_TYPEDEF_(0x803C0106L)

//
// MessageId: SDIAG_E_TRUST
//
// MessageText:
//
// Trust validation of the troubleshooting pack failed.
//
#define SDIAG_E_TRUST _NDIS_ERROR_TYPEDEF_(0x803C0107L)

//
// MessageId: SDIAG_E_CANNOTRUN
//
// MessageText:
//
// The troubleshooting pack cannot be executed on this system.
//
#define SDIAG_E_CANNOTRUN _NDIS_ERROR_TYPEDEF_(0x803C0108L)

//
// MessageId: SDIAG_E_VERSION
//
// MessageText:
//
// This version of the troubleshooting pack is not supported.
//
#define SDIAG_E_VERSION _NDIS_ERROR_TYPEDEF_(0x803C0109L)

//
// MessageId: SDIAG_E_RESOURCE
//
// MessageText:
//
// A required resource cannot be loaded.
//
#define SDIAG_E_RESOURCE _NDIS_ERROR_TYPEDEF_(0x803C010AL)

//
// MessageId: SDIAG_E_ROOTCAUSE
//
// MessageText:
//
// The troubleshooting pack reported information for a root cause without adding the root cause.
//
#define SDIAG_E_ROOTCAUSE _NDIS_ERROR_TYPEDEF_(0x803C010BL)


//
// MBN error codes
//

//
// MessageId: E_MBN_CONTEXT_NOT_ACTIVATED
//
// MessageText:
//
// Context is not activated.
//
#define E_MBN_CONTEXT_NOT_ACTIVATED _HRESULT_TYPEDEF_(0x80548201L)

//
// MessageId: E_MBN_BAD_SIM
//
// MessageText:
//
// Bad SIM is inserted.
//
#define E_MBN_BAD_SIM _HRESULT_TYPEDEF_(0x80548202L)

//
// MessageId: E_MBN_DATA_CLASS_NOT_AVAILABLE
//
// MessageText:
//
// Requested data class is not avaialable.
//
#define E_MBN_DATA_CLASS_NOT_AVAILABLE _HRESULT_TYPEDEF_(0x80548203L)

//
// MessageId: E_MBN_INVALID_ACCESS_STRING
//
// MessageText:
//
// Access point name (APN) or Access string is incorrect.
//
#define E_MBN_INVALID_ACCESS_STRING _HRESULT_TYPEDEF_(0x80548204L)

//
// MessageId: E_MBN_MAX_ACTIVATED_CONTEXTS
//
// MessageText:
//
// Max activated contexts have reached.
//
#define E_MBN_MAX_ACTIVATED_CONTEXTS _HRESULT_TYPEDEF_(0x80548205L)

//
// MessageId: E_MBN_PACKET_SVC_DETACHED
//
// MessageText:
//
// Device is in packet detach state.
//
#define E_MBN_PACKET_SVC_DETACHED _HRESULT_TYPEDEF_(0x80548206L)

//
// MessageId: E_MBN_PROVIDER_NOT_VISIBLE
//
// MessageText:
//
// Provider is not visible.
//
#define E_MBN_PROVIDER_NOT_VISIBLE _HRESULT_TYPEDEF_(0x80548207L)

//
// MessageId: E_MBN_RADIO_POWER_OFF
//
// MessageText:
//
// Radio is powered off.
//
#define E_MBN_RADIO_POWER_OFF _HRESULT_TYPEDEF_(0x80548208L)

//
// MessageId: E_MBN_SERVICE_NOT_ACTIVATED
//
// MessageText:
//
// MBN subscription is not activated.
//
#define E_MBN_SERVICE_NOT_ACTIVATED _HRESULT_TYPEDEF_(0x80548209L)

//
// MessageId: E_MBN_SIM_NOT_INSERTED
//
// MessageText:
//
// SIM is not inserted.
//
#define E_MBN_SIM_NOT_INSERTED _HRESULT_TYPEDEF_(0x8054820AL)

//
// MessageId: E_MBN_VOICE_CALL_IN_PROGRESS
//
// MessageText:
//
// Voice call in progress.
//
#define E_MBN_VOICE_CALL_IN_PROGRESS _HRESULT_TYPEDEF_(0x8054820BL)

//
// MessageId: E_MBN_INVALID_CACHE
//
// MessageText:
//
// Visible provider cache is invalid.
//
#define E_MBN_INVALID_CACHE _HRESULT_TYPEDEF_(0x8054820CL)

//
// MessageId: E_MBN_NOT_REGISTERED
//
// MessageText:
//
// Device is not registered.
//
#define E_MBN_NOT_REGISTERED _HRESULT_TYPEDEF_(0x8054820DL)

//
// MessageId: E_MBN_PROVIDERS_NOT_FOUND
//
// MessageText:
//
// Providers not found.
//
#define E_MBN_PROVIDERS_NOT_FOUND _HRESULT_TYPEDEF_(0x8054820EL)

//
// MessageId: E_MBN_PIN_NOT_SUPPORTED
//
// MessageText:
//
// Pin is not supported.
//
#define E_MBN_PIN_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x8054820FL)

//
// MessageId: E_MBN_PIN_REQUIRED
//
// MessageText:
//
// Pin is required.
//
#define E_MBN_PIN_REQUIRED _HRESULT_TYPEDEF_(0x80548210L)

//
// MessageId: E_MBN_PIN_DISABLED
//
// MessageText:
//
// PIN is disabled.
//
#define E_MBN_PIN_DISABLED _HRESULT_TYPEDEF_(0x80548211L)

//
// MessageId: E_MBN_FAILURE
//
// MessageText:
//
// Generic Failure.
//
#define E_MBN_FAILURE _HRESULT_TYPEDEF_(0x80548212L)

// Profile related error messages
//
// MessageId: E_MBN_INVALID_PROFILE
//
// MessageText:
//
// Profile is invalid.
//
#define E_MBN_INVALID_PROFILE _HRESULT_TYPEDEF_(0x80548218L)

//
// MessageId: E_MBN_DEFAULT_PROFILE_EXIST
//
// MessageText:
//
// Default profile exist.
//
#define E_MBN_DEFAULT_PROFILE_EXIST _HRESULT_TYPEDEF_(0x80548219L)

// SMS related error messages
//
// MessageId: E_MBN_SMS_ENCODING_NOT_SUPPORTED
//
// MessageText:
//
// SMS encoding is not supported.
//
#define E_MBN_SMS_ENCODING_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80548220L)

//
// MessageId: E_MBN_SMS_FILTER_NOT_SUPPORTED
//
// MessageText:
//
// SMS filter is not supported.
//
#define E_MBN_SMS_FILTER_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80548221L)

//
// MessageId: E_MBN_SMS_INVALID_MEMORY_INDEX
//
// MessageText:
//
// Invalid SMS memory index is used.
//
#define E_MBN_SMS_INVALID_MEMORY_INDEX _HRESULT_TYPEDEF_(0x80548222L)

//
// MessageId: E_MBN_SMS_LANG_NOT_SUPPORTED
//
// MessageText:
//
// SMS language is not supported.
//
#define E_MBN_SMS_LANG_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80548223L)

//
// MessageId: E_MBN_SMS_MEMORY_FAILURE
//
// MessageText:
//
// SMS memory failure occurred.
//
#define E_MBN_SMS_MEMORY_FAILURE _HRESULT_TYPEDEF_(0x80548224L)

//
// MessageId: E_MBN_SMS_NETWORK_TIMEOUT
//
// MessageText:
//
// SMS network timeout happened.
//
#define E_MBN_SMS_NETWORK_TIMEOUT _HRESULT_TYPEDEF_(0x80548225L)

//
// MessageId: E_MBN_SMS_UNKNOWN_SMSC_ADDRESS
//
// MessageText:
//
// Unknown SMSC address is used.
//
#define E_MBN_SMS_UNKNOWN_SMSC_ADDRESS _HRESULT_TYPEDEF_(0x80548226L)

//
// MessageId: E_MBN_SMS_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// SMS format is not supported.
//
#define E_MBN_SMS_FORMAT_NOT_SUPPORTED _HRESULT_TYPEDEF_(0x80548227L)

//
// MessageId: E_MBN_SMS_OPERATION_NOT_ALLOWED
//
// MessageText:
//
// SMS operation is not allowed.
//
#define E_MBN_SMS_OPERATION_NOT_ALLOWED _HRESULT_TYPEDEF_(0x80548228L)

//
// MessageId: E_MBN_SMS_MEMORY_FULL
//
// MessageText:
//
// Device SMS memory is full.
//
#define E_MBN_SMS_MEMORY_FULL _HRESULT_TYPEDEF_(0x80548229L)


//
// UI error codes
//

//
// MessageId: UI_E_CREATE_FAILED
//
// MessageText:
//
// The object could not be created.
//
#define UI_E_CREATE_FAILED _HRESULT_TYPEDEF_(0x802A0001L)

//
// MessageId: UI_E_SHUTDOWN_CALLED
//
// MessageText:
//
// Shutdown was already called on this object or the object that owns it.
//
#define UI_E_SHUTDOWN_CALLED _HRESULT_TYPEDEF_(0x802A0002L)

//
// MessageId: UI_E_ILLEGAL_REENTRANCY
//
// MessageText:
//
// This method cannot be called during this type of callback.
//
#define UI_E_ILLEGAL_REENTRANCY _HRESULT_TYPEDEF_(0x802A0003L)

//
// MessageId: UI_E_OBJECT_SEALED
//
// MessageText:
//
// This object has been sealed, so this change is no longer allowed.
//
#define UI_E_OBJECT_SEALED _HRESULT_TYPEDEF_(0x802A0004L)

//
// MessageId: UI_E_VALUE_NOT_SET
//
// MessageText:
//
// The requested value was never set.
//
#define UI_E_VALUE_NOT_SET _HRESULT_TYPEDEF_(0x802A0005L)

//
// MessageId: UI_E_VALUE_NOT_DETERMINED
//
// MessageText:
//
// The requested value cannot be determined.
//
#define UI_E_VALUE_NOT_DETERMINED _HRESULT_TYPEDEF_(0x802A0006L)

//
// MessageId: UI_E_INVALID_OUTPUT
//
// MessageText:
//
// A callback returned an invalid output parameter.
//
#define UI_E_INVALID_OUTPUT _HRESULT_TYPEDEF_(0x802A0007L)

//
// MessageId: UI_E_BOOLEAN_EXPECTED
//
// MessageText:
//
// A callback returned a success code other than S_OK or S_FALSE.
//
#define UI_E_BOOLEAN_EXPECTED _HRESULT_TYPEDEF_(0x802A0008L)

//
// MessageId: UI_E_DIFFERENT_OWNER
//
// MessageText:
//
// A parameter that should be owned by this object is owned by a different object.
//
#define UI_E_DIFFERENT_OWNER _HRESULT_TYPEDEF_(0x802A0009L)

//
// MessageId: UI_E_AMBIGUOUS_MATCH
//
// MessageText:
//
// More than one item matched the search criteria.
//
#define UI_E_AMBIGUOUS_MATCH _HRESULT_TYPEDEF_(0x802A000AL)

//
// MessageId: UI_E_FP_OVERFLOW
//
// MessageText:
//
// A floating-point overflow occurred.
//
#define UI_E_FP_OVERFLOW _HRESULT_TYPEDEF_(0x802A000BL)

//
// MessageId: UI_E_WRONG_THREAD
//
// MessageText:
//
// This method can only be called from the thread that created the object.
//
#define UI_E_WRONG_THREAD _HRESULT_TYPEDEF_(0x802A000CL)

//
// MessageId: UI_E_STORYBOARD_ACTIVE
//
// MessageText:
//
// The storyboard is currently in the schedule.
//
#define UI_E_STORYBOARD_ACTIVE _HRESULT_TYPEDEF_(0x802A0101L)

//
// MessageId: UI_E_STORYBOARD_NOT_PLAYING
//
// MessageText:
//
// The storyboard is not playing.
//
#define UI_E_STORYBOARD_NOT_PLAYING _HRESULT_TYPEDEF_(0x802A0102L)

//
// MessageId: UI_E_START_KEYFRAME_AFTER_END
//
// MessageText:
//
// The start keyframe might occur after the end keyframe.
//
#define UI_E_START_KEYFRAME_AFTER_END _HRESULT_TYPEDEF_(0x802A0103L)

//
// MessageId: UI_E_END_KEYFRAME_NOT_DETERMINED
//
// MessageText:
//
// It might not be possible to determine the end keyframe time when the start keyframe is reached.
//
#define UI_E_END_KEYFRAME_NOT_DETERMINED _HRESULT_TYPEDEF_(0x802A0104L)

//
// MessageId: UI_E_LOOPS_OVERLAP
//
// MessageText:
//
// Two repeated portions of a storyboard might overlap.
//
#define UI_E_LOOPS_OVERLAP _HRESULT_TYPEDEF_(0x802A0105L)

//
// MessageId: UI_E_TRANSITION_ALREADY_USED
//
// MessageText:
//
// The transition has already been added to a storyboard.
//
#define UI_E_TRANSITION_ALREADY_USED _HRESULT_TYPEDEF_(0x802A0106L)

//
// MessageId: UI_E_TRANSITION_NOT_IN_STORYBOARD
//
// MessageText:
//
// The transition has not been added to a storyboard.
//
#define UI_E_TRANSITION_NOT_IN_STORYBOARD _HRESULT_TYPEDEF_(0x802A0107L)

//
// MessageId: UI_E_TRANSITION_ECLIPSED
//
// MessageText:
//
// The transition might eclipse the beginning of another transition in the storyboard.
//
#define UI_E_TRANSITION_ECLIPSED _HRESULT_TYPEDEF_(0x802A0108L)

//
// MessageId: UI_E_TIME_BEFORE_LAST_UPDATE
//
// MessageText:
//
// The given time is earlier than the time passed to the last update.
//
#define UI_E_TIME_BEFORE_LAST_UPDATE _HRESULT_TYPEDEF_(0x802A0109L)

//
// MessageId: UI_E_TIMER_CLIENT_ALREADY_CONNECTED
//
// MessageText:
//
// This client is already connected to a timer.
//
#define UI_E_TIMER_CLIENT_ALREADY_CONNECTED _HRESULT_TYPEDEF_(0x802A010AL)
# 13704 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h" 2

/* Abnormal termination codes */

#define TC_NORMAL 0
#define TC_HARDERR 1
#define TC_GP_TRAP 2
#define TC_SIGNAL 3


//
// Power Management APIs
//

#define AC_LINE_OFFLINE 0x00
#define AC_LINE_ONLINE 0x01
#define AC_LINE_BACKUP_POWER 0x02
#define AC_LINE_UNKNOWN 0xFF

#define BATTERY_FLAG_HIGH 0x01
#define BATTERY_FLAG_LOW 0x02
#define BATTERY_FLAG_CRITICAL 0x04
#define BATTERY_FLAG_CHARGING 0x08
#define BATTERY_FLAG_NO_BATTERY 0x80
#define BATTERY_FLAG_UNKNOWN 0xFF

#define BATTERY_PERCENTAGE_UNKNOWN 0xFF

#define BATTERY_LIFE_UNKNOWN 0xFFFFFFFF

typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;


BOOL

GetSystemPowerStatus(
    LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );


BOOL

SetSystemPowerState(
    BOOL fSuspend,
    BOOL fForce
    );




//
// Very Large Memory API Subset
//


BOOL

AllocateUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );




BOOL

AllocateUserPhysicalPagesNuma(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray,
    DWORD nndPreferred
    );




BOOL

FreeUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );


BOOL

MapUserPhysicalPages(
    PVOID VirtualAddress,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );


BOOL

MapUserPhysicalPagesScatter(
    PVOID *VirtualAddresses,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    );



HANDLE

CreateJobObjectA(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCSTR lpName
    );


HANDLE

CreateJobObjectW(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCWSTR lpName
    );



#define CreateJobObject CreateJobObjectA




HANDLE

OpenJobObjectA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );


HANDLE

OpenJobObjectW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );



#define OpenJobObject OpenJobObjectA



BOOL

AssignProcessToJobObject(
    HANDLE hJob,
    HANDLE hProcess
    );


BOOL

TerminateJobObject(
    HANDLE hJob,
    UINT uExitCode
    );


BOOL

QueryInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength,
    LPDWORD lpReturnLength
    );


BOOL

SetInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength
    );




BOOL

IsProcessInJob (
    HANDLE ProcessHandle,
    HANDLE JobHandle,
    PBOOL Result
    );




BOOL

CreateJobSet (
    ULONG NumJob,
    PJOB_SET_ARRAY UserJobSet,
    ULONG Flags);



PVOID

AddVectoredExceptionHandler (
    ULONG First,
    PVECTORED_EXCEPTION_HANDLER Handler
    );


ULONG

RemoveVectoredExceptionHandler (
    PVOID Handle
    );



PVOID

AddVectoredContinueHandler (
    ULONG First,
    PVECTORED_EXCEPTION_HANDLER Handler
    );


ULONG

RemoveVectoredContinueHandler (
    PVOID Handle
    );

//
// New Volume Mount Point API.
//



HANDLE

FindFirstVolumeA(
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );


HANDLE

FindFirstVolumeW(
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );



#define FindFirstVolume FindFirstVolumeA



BOOL

FindNextVolumeA(
    HANDLE hFindVolume,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );

BOOL

FindNextVolumeW(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );



#define FindNextVolume FindNextVolumeA



BOOL

FindVolumeClose(
    HANDLE hFindVolume
    );



HANDLE

FindFirstVolumeMountPointA(
    LPCSTR lpszRootPathName,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );


HANDLE

FindFirstVolumeMountPointW(
    LPCWSTR lpszRootPathName,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );



#define FindFirstVolumeMountPoint FindFirstVolumeMountPointA



BOOL

FindNextVolumeMountPointA(
    HANDLE hFindVolumeMountPoint,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );

BOOL

FindNextVolumeMountPointW(
    HANDLE hFindVolumeMountPoint,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );



#define FindNextVolumeMountPoint FindNextVolumeMountPointA



BOOL

FindVolumeMountPointClose(
    HANDLE hFindVolumeMountPoint
    );


BOOL

SetVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPCSTR lpszVolumeName
    );

BOOL

SetVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPCWSTR lpszVolumeName
    );



#define SetVolumeMountPoint SetVolumeMountPointA



BOOL

DeleteVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint
    );

BOOL

DeleteVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint
    );



#define DeleteVolumeMountPoint DeleteVolumeMountPointA



BOOL

GetVolumeNameForVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );

BOOL

GetVolumeNameForVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );



#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointA



BOOL

GetVolumePathNameA(
    LPCSTR lpszFileName,
    LPSTR lpszVolumePathName,
    DWORD cchBufferLength
    );

BOOL

GetVolumePathNameW(
    LPCWSTR lpszFileName,
    LPWSTR lpszVolumePathName,
    DWORD cchBufferLength
    );



#define GetVolumePathName GetVolumePathNameA







BOOL

GetVolumePathNamesForVolumeNameA(
    LPCSTR lpszVolumeName,
    LPCH lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );

BOOL

GetVolumePathNamesForVolumeNameW(
    LPCWSTR lpszVolumeName,
    LPWCH lpszVolumePathNames,
    DWORD cchBufferLength,
    PDWORD lpcchReturnLength
    );



#define GetVolumePathNamesForVolumeName GetVolumePathNamesForVolumeNameA






#define ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID (0x00000001)
#define ACTCTX_FLAG_LANGID_VALID (0x00000002)
#define ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID (0x00000004)
#define ACTCTX_FLAG_RESOURCE_NAME_VALID (0x00000008)
#define ACTCTX_FLAG_SET_PROCESS_DEFAULT (0x00000010)
#define ACTCTX_FLAG_APPLICATION_NAME_VALID (0x00000020)
#define ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF (0x00000040)
#define ACTCTX_FLAG_HMODULE_VALID (0x00000080)

typedef struct tagACTCTXA {
    ULONG cbSize;
    DWORD dwFlags;
    LPCSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCSTR lpAssemblyDirectory;
    LPCSTR lpResourceName;
    LPCSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG cbSize;
    DWORD dwFlags;
    LPCWSTR lpSource;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    LPCWSTR lpAssemblyDirectory;
    LPCWSTR lpResourceName;
    LPCWSTR lpApplicationName;
    HMODULE hModule;
} ACTCTXW, *PACTCTXW;




typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;


typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;



typedef PCACTCTXA PCACTCTX;






HANDLE

CreateActCtxA(
    PCACTCTXA pActCtx
    );


HANDLE

CreateActCtxW(
    PCACTCTXW pActCtx
    );



#define CreateActCtx CreateActCtxA



void

AddRefActCtx(
    HANDLE hActCtx
    );



void

ReleaseActCtx(
    HANDLE hActCtx
    );


BOOL

ZombifyActCtx(
    HANDLE hActCtx
    );



BOOL

ActivateActCtx(
    HANDLE hActCtx,
    ULONG_PTR *lpCookie
    );


#define DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION (0x00000001)


BOOL

DeactivateActCtx(
    DWORD dwFlags,
    ULONG_PTR ulCookie
    );


BOOL

GetCurrentActCtx(
    HANDLE *lphActCtx);


typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
// 2600 stops here
    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;

#define FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX (0x00000001)
#define FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS (0x00000002)
#define FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA (0x00000004)




BOOL

FindActCtxSectionStringA(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    );

BOOL

FindActCtxSectionStringW(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCWSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    );



#define FindActCtxSectionString FindActCtxSectionStringA



BOOL

FindActCtxSectionGuid(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    const GUID *lpGuidToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    );





typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE hActCtx;
    DWORD dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;

#define ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED 1




#define QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX (0x00000004)
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE (0x00000008)
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS (0x00000010)
#define QUERY_ACTCTX_FLAG_NO_ADDREF (0x80000000)



//
// switch (ulInfoClass)
//
//  case ActivationContextBasicInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_BASIC_INFORMATION
//
//  case ActivationContextDetailedInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_DETAILED_INFORMATION
//
//  case AssemblyDetailedInformationInActivationContext:
//    pvSubInstance is of type PULONG
//      *pvSubInstance < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//    pvBuffer is of type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
//
//  case FileInformationInAssemblyOfAssemblyInActivationContext:
//    pvSubInstance is of type PACTIVATION_CONTEXT_QUERY_INDEX
//      pvSubInstance->ulAssemblyIndex < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//      pvSubInstance->ulFileIndexInAssembly < ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION::ulFileCount
//    pvBuffer is of type PASSEMBLY_FILE_DETAILED_INFORMATION
//
//  case RunlevelInformationInActivationContext :
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
//
// String are placed after the structs.
//

BOOL

QueryActCtxW(
    DWORD dwFlags,
    HANDLE hActCtx,
    PVOID pvSubInstance,
    ULONG ulInfoClass,
    PVOID pvBuffer,
    SIZE_T cbBuffer,
    SIZE_T *pcbWrittenOrRequired
    );

typedef BOOL ( * PQUERYACTCTXW_FUNC)(
    DWORD dwFlags,
    HANDLE hActCtx,
    PVOID pvSubInstance,
    ULONG ulInfoClass,
    PVOID pvBuffer,
    SIZE_T cbBuffer,
    SIZE_T *pcbWrittenOrRequired
    );





BOOL

ProcessIdToSessionId(
    DWORD dwProcessId,
    DWORD *pSessionId
    );




DWORD

WTSGetActiveConsoleSessionId(
    void
    );


BOOL

IsWow64Process(
    HANDLE hProcess,
    PBOOL Wow64Process
    );




BOOL

GetLogicalProcessorInformation(
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
    PDWORD ReturnedLength
    );




BOOL

GetLogicalProcessorInformationEx(
    LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
    PDWORD ReturnedLength
    );


WORD

GetActiveProcessorGroupCount(
    void
    );


WORD

GetMaximumProcessorGroupCount(
    void
    );


DWORD

GetActiveProcessorCount(
    WORD GroupNumber
    );


DWORD

GetMaximumProcessorCount(
    WORD GroupNumber
    );



//
// NUMA Information routines.
//


BOOL

GetNumaHighestNodeNumber(
    PULONG HighestNodeNumber
    );


BOOL

GetNumaProcessorNode(
    UCHAR Processor,
    PUCHAR NodeNumber
    );




BOOL

GetNumaNodeNumberFromHandle(
    HANDLE hFile,
    PUSHORT NodeNumber
    );






BOOL

GetNumaProcessorNodeEx(
    PPROCESSOR_NUMBER Processor,
    PUSHORT NodeNumber
    );




BOOL

GetNumaNodeProcessorMask(
    UCHAR Node,
    PULONGLONG ProcessorMask
    );




BOOL

GetNumaNodeProcessorMaskEx(
    USHORT Node,
    PGROUP_AFFINITY ProcessorMask
    );




BOOL

GetNumaAvailableMemoryNode(
    UCHAR Node,
    PULONGLONG AvailableBytes
    );




BOOL

GetNumaAvailableMemoryNodeEx(
    USHORT Node,
    PULONGLONG AvailableBytes
    );






BOOL

GetNumaProximityNode(
    ULONG ProximityId,
    PUCHAR NodeNumber
    );






BOOL

GetNumaProximityNodeEx(
    ULONG ProximityId,
    PUSHORT NodeNumber
    );



//
// Application restart and data recovery callback
//
typedef DWORD ( *APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);

//
// Max length of commandline in characters (including the NULL character that can be registered for restart)
//
#define RESTART_MAX_CMD_LINE 1024

//
// Do not restart the process for termination due to application crashes
//
#define RESTART_NO_CRASH 1

//
// Do not restart the process for termination due to application hangs
//
#define RESTART_NO_HANG 2

//
// Do not restart the process for termination due to patch installations
//
#define RESTART_NO_PATCH 4

//
// Do not restart the process when the system is rebooted due to patch installations
//
#define RESTART_NO_REBOOT 8


HRESULT

RegisterApplicationRecoveryCallback(
    APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
    PVOID pvParameter,
    DWORD dwPingInterval,
    DWORD dwFlags
    );


HRESULT

UnregisterApplicationRecoveryCallback(void);


HRESULT

RegisterApplicationRestart(
    PCWSTR pwzCommandline,
    DWORD dwFlags
    );


HRESULT

UnregisterApplicationRestart(void);

#define RECOVERY_DEFAULT_PING_INTERVAL 5000
#define RECOVERY_MAX_PING_INTERVAL (5 * 60 * 1000)


HRESULT

GetApplicationRecoveryCallback(
    HANDLE hProcess,
    APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
    PVOID* ppvParameter,
    PDWORD pdwPingInterval,
    PDWORD pdwFlags
    );


HRESULT

GetApplicationRestartSettings(
    HANDLE hProcess,
    PWSTR pwzCommandline,
    PDWORD pcchSize,
    PDWORD pdwFlags
    );


HRESULT

ApplicationRecoveryInProgress(
    PBOOL pbCancelled
    );


void

ApplicationRecoveryFinished(
    BOOL bSuccess
    );


typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;

typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;

typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;

typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;

typedef struct _FILE_RENAME_INFO {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;

typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;

typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;

typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;

typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;

typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;

typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFileA;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;

typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;

typedef enum _PRIORITY_HINT {
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow,
      IoPriorityHintNormal,
      MaximumIoPriorityHintType
} PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;

// Structure and constants must match those in ntioapi_x.w

#define REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK 0x00000001
#define REMOTE_PROTOCOL_INFO_FLAG_OFFLINE 0x00000002

typedef struct _FILE_REMOTE_PROTOCOL_INFO
{
    // Structure Version
    USHORT StructureVersion; // 1
    USHORT StructureSize; // sizeof(FILE_REMOTE_PROTOCOL_INFO)

    DWORD Protocol; // Protocol (WNNC_NET_*) defined in wnnc.h or ntifs.h.

    // Protocol Version & Type
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;

    USHORT Reserved;

    // Protocol-Generic Information
    DWORD Flags;

    struct {
        DWORD Reserved[8];
    } GenericReserved;

    // Protocol specific information

    struct {
        DWORD Reserved[16];
    } ProtocolSpecificReserved;

} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;



BOOL

SetFileInformationByHandle(
    HANDLE hFile,
    FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
    LPVOID lpFileInformation,
    DWORD dwBufferSize
);


BOOL

GetFileInformationByHandleEx(
    HANDLE hFile,
    FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
    LPVOID lpFileInformation,
    DWORD dwBufferSize
);

typedef enum _FILE_ID_TYPE {
      FileIdType,
      ObjectIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;

typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize; // Size of the struct
    FILE_ID_TYPE Type; // Describes the type of identifier passed in.
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;
    } u;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;



HANDLE

OpenFileById (
    HANDLE hVolumeHint,
    LPFILE_ID_DESCRIPTOR lpFileId,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes
    );




//
//  Flags to be passed into CREATE_SYMBOLIC_LINK
//

#define SYMBOLIC_LINK_FLAG_DIRECTORY (0x1)

#define VALID_SYMBOLIC_LINK_FLAGS SYMBOLIC_LINK_FLAG_DIRECTORY


BOOLEAN

CreateSymbolicLinkA (
    LPCSTR lpSymlinkFileName,
    LPCSTR lpTargetFileName,
    DWORD dwFlags
    );

BOOLEAN

CreateSymbolicLinkW (
    LPCWSTR lpSymlinkFileName,
    LPCWSTR lpTargetFileName,
    DWORD dwFlags
    );



#define CreateSymbolicLink CreateSymbolicLinkA



BOOLEAN

CreateSymbolicLinkTransactedA (
    LPCSTR lpSymlinkFileName,
    LPCSTR lpTargetFileName,
    DWORD dwFlags,
    HANDLE hTransaction
    );

BOOLEAN

CreateSymbolicLinkTransactedW (
    LPCWSTR lpSymlinkFileName,
    LPCWSTR lpTargetFileName,
    DWORD dwFlags,
    HANDLE hTransaction
    );



#define CreateSymbolicLinkTransacted CreateSymbolicLinkTransactedA



DWORD

GetFinalPathNameByHandleA (
    HANDLE hFile,
    LPSTR lpszFilePath,
    DWORD cchFilePath,
    DWORD dwFlags
);

DWORD

GetFinalPathNameByHandleW (
    HANDLE hFile,
    LPWSTR lpszFilePath,
    DWORD cchFilePath,
    DWORD dwFlags
);



#define GetFinalPathNameByHandle GetFinalPathNameByHandleA








BOOL

QueryActCtxSettingsW(
    DWORD dwFlags,
    HANDLE hActCtx,
    PCWSTR settingsNameSpace,
    PCWSTR settingName,
    PWSTR pvBuffer,
    SIZE_T dwBuffer,
    SIZE_T *pdwWrittenOrRequired
    );






BOOL

ReplacePartitionUnit (
    PWSTR TargetPartition,
    PWSTR SparePartition,
    ULONG Flags
    );







BOOL

AddSecureMemoryCacheCallback(
    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );


BOOL

RemoveSecureMemoryCacheCallback(
    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );







BOOL

CopyExtendedContext(
    PCONTEXT_EX Destination,
    DWORD ContextFlags,
    PCONTEXT_EX Source
    );



BOOL

InitializeExtendedContext(
    PVOID Context,
    DWORD ContextFlags,
    PCONTEXT_EX* ContextEx
    );


DWORD64

GetEnabledExtendedFeatures(
    DWORD64 FeatureMask
    );



BOOL

GetExtendedContextLength(
    DWORD ContextFlags,
    PDWORD ContextLength
    );


DWORD64

GetExtendedFeaturesMask(
    PCONTEXT_EX ContextEx
    );


PVOID

LocateExtendedFeature(
    PCONTEXT_EX ContextEx,
    DWORD FeatureId,
    PDWORD Length
    );


PCONTEXT

LocateLegacyContext(
    PCONTEXT_EX ContextEx,
    PDWORD Length
    );


void

SetExtendedFeaturesMask(
    PCONTEXT_EX ContextEx,
    DWORD64 FeatureMask
    );


DWORD

EnableThreadProfiling(
    HANDLE ThreadHandle,
    DWORD Flags,
    DWORD64 HardwareCounters,
    HANDLE *PerformanceDataHandle
    );


DWORD

DisableThreadProfiling(
    HANDLE PerformanceDataHandle
    );


DWORD

QueryThreadProfiling(
    HANDLE ThreadHandle,
    PBOOLEAN Enabled
    );


DWORD

ReadThreadProfilingData(
    HANDLE PerformanceDataHandle,
    DWORD Flags,
    PPERFORMANCE_DATA PerformanceData
    );
# 15181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    winbase_interlockedcplusplus.h



Abstract:



    C++ function overloads in place of "manual name mangling".

    This file is meant to be #included by winbase.h or any other file declaring the signed interlocked functions.



Author:



    Jay Krell (JayKrell) April 2002



--*/
# 15203 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#define MICROSOFT_WINDOWS_WINBASE_INTERLOCKED_CPLUSPLUS_H_INCLUDED 






/*

To turn off/hide the contents of this file:

 #define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0

*/
# 15216 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS (_WIN32_WINNT >= 0x0502 || !defined(_WINBASE_))
# 15457 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winbase.h"
#undef MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS
#define MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
# 157 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 1
/**************************************************************************

*                                                                         *

* wingdi.h -- GDI procedure declarations, constant definitions and macros *

*                                                                         *

* Copyright (c) Microsoft Corp. All rights reserved.                      *

*                                                                         *

**************************************************************************/
# 10 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
#define _WINGDI_ 


       
# 25 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
//
// Define API decoration for direct importing of DLL references.
//


#define WINGDIAPI DECLSPEC_IMPORT




//
// Define API decoration for direct importing of DLL references.
//


#define WINSPOOLAPI DECLSPEC_IMPORT
# 57 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
/* Binary raster ops */
#define R2_BLACK 1
#define R2_NOTMERGEPEN 2
#define R2_MASKNOTPEN 3
#define R2_NOTCOPYPEN 4
#define R2_MASKPENNOT 5
#define R2_NOT 6
#define R2_XORPEN 7
#define R2_NOTMASKPEN 8
#define R2_MASKPEN 9
#define R2_NOTXORPEN 10
#define R2_NOP 11
#define R2_MERGENOTPEN 12
#define R2_COPYPEN 13
#define R2_MERGEPENNOT 14
#define R2_MERGEPEN 15
#define R2_WHITE 16
#define R2_LAST 16

/* Ternary raster operations */
#define SRCCOPY (DWORD)0x00CC0020
#define SRCPAINT (DWORD)0x00EE0086
#define SRCAND (DWORD)0x008800C6
#define SRCINVERT (DWORD)0x00660046
#define SRCERASE (DWORD)0x00440328
#define NOTSRCCOPY (DWORD)0x00330008
#define NOTSRCERASE (DWORD)0x001100A6
#define MERGECOPY (DWORD)0x00C000CA
#define MERGEPAINT (DWORD)0x00BB0226
#define PATCOPY (DWORD)0x00F00021
#define PATPAINT (DWORD)0x00FB0A09
#define PATINVERT (DWORD)0x005A0049
#define DSTINVERT (DWORD)0x00550009
#define BLACKNESS (DWORD)0x00000042
#define WHITENESS (DWORD)0x00FF0062


#define NOMIRRORBITMAP (DWORD)0x80000000
#define CAPTUREBLT (DWORD)0x40000000



/* Quaternary raster codes */
#define MAKEROP4(fore,back) (DWORD)((((back) << 8) & 0xFF000000) | (fore))



#define GDI_ERROR (0xFFFFFFFFL)

#define HGDI_ERROR (LongToHandle(0xFFFFFFFFL))




/* Region Flags */
#define ERROR 0
#define NULLREGION 1
#define SIMPLEREGION 2
#define COMPLEXREGION 3
#define RGN_ERROR ERROR

/* CombineRgn() Styles */
#define RGN_AND 1
#define RGN_OR 2
#define RGN_XOR 3
#define RGN_DIFF 4
#define RGN_COPY 5
#define RGN_MIN RGN_AND
#define RGN_MAX RGN_COPY

/* StretchBlt() Modes */
#define BLACKONWHITE 1
#define WHITEONBLACK 2
#define COLORONCOLOR 3
#define HALFTONE 4
#define MAXSTRETCHBLTMODE 4


/* New StretchBlt() Modes */
#define STRETCH_ANDSCANS BLACKONWHITE
#define STRETCH_ORSCANS WHITEONBLACK
#define STRETCH_DELETESCANS COLORONCOLOR
#define STRETCH_HALFTONE HALFTONE


/* PolyFill() Modes */
#define ALTERNATE 1
#define WINDING 2
#define POLYFILL_LAST 2

/* Layout Orientation Options */

#define LAYOUT_RTL 0x00000001
#define LAYOUT_BTT 0x00000002
#define LAYOUT_VBH 0x00000004
#define LAYOUT_ORIENTATIONMASK (LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH)
#define LAYOUT_BITMAPORIENTATIONPRESERVED 0x00000008


/* Text Alignment Options */
#define TA_NOUPDATECP 0
#define TA_UPDATECP 1

#define TA_LEFT 0
#define TA_RIGHT 2
#define TA_CENTER 6

#define TA_TOP 0
#define TA_BOTTOM 8
#define TA_BASELINE 24

#define TA_RTLREADING 256
#define TA_MASK (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)




#define VTA_BASELINE TA_BASELINE
#define VTA_LEFT TA_BOTTOM
#define VTA_RIGHT TA_TOP
#define VTA_CENTER TA_CENTER
#define VTA_BOTTOM TA_RIGHT
#define VTA_TOP TA_LEFT

#define ETO_OPAQUE 0x0002
#define ETO_CLIPPED 0x0004

#define ETO_GLYPH_INDEX 0x0010
#define ETO_RTLREADING 0x0080
#define ETO_NUMERICSLOCAL 0x0400
#define ETO_NUMERICSLATIN 0x0800
#define ETO_IGNORELANGUAGE 0x1000


#define ETO_PDY 0x2000


#define ETO_REVERSE_INDEX_MAP 0x10000


#define ASPECT_FILTERING 0x0001

/* Bounds Accumulation APIs */

#define DCB_RESET 0x0001
#define DCB_ACCUMULATE 0x0002
#define DCB_DIRTY DCB_ACCUMULATE
#define DCB_SET (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE 0x0004
#define DCB_DISABLE 0x0008



/* Metafile Functions */
#define META_SETBKCOLOR 0x0201
#define META_SETBKMODE 0x0102
#define META_SETMAPMODE 0x0103
#define META_SETROP2 0x0104
#define META_SETRELABS 0x0105
#define META_SETPOLYFILLMODE 0x0106
#define META_SETSTRETCHBLTMODE 0x0107
#define META_SETTEXTCHAREXTRA 0x0108
#define META_SETTEXTCOLOR 0x0209
#define META_SETTEXTJUSTIFICATION 0x020A
#define META_SETWINDOWORG 0x020B
#define META_SETWINDOWEXT 0x020C
#define META_SETVIEWPORTORG 0x020D
#define META_SETVIEWPORTEXT 0x020E
#define META_OFFSETWINDOWORG 0x020F
#define META_SCALEWINDOWEXT 0x0410
#define META_OFFSETVIEWPORTORG 0x0211
#define META_SCALEVIEWPORTEXT 0x0412
#define META_LINETO 0x0213
#define META_MOVETO 0x0214
#define META_EXCLUDECLIPRECT 0x0415
#define META_INTERSECTCLIPRECT 0x0416
#define META_ARC 0x0817
#define META_ELLIPSE 0x0418
#define META_FLOODFILL 0x0419
#define META_PIE 0x081A
#define META_RECTANGLE 0x041B
#define META_ROUNDRECT 0x061C
#define META_PATBLT 0x061D
#define META_SAVEDC 0x001E
#define META_SETPIXEL 0x041F
#define META_OFFSETCLIPRGN 0x0220
#define META_TEXTOUT 0x0521
#define META_BITBLT 0x0922
#define META_STRETCHBLT 0x0B23
#define META_POLYGON 0x0324
#define META_POLYLINE 0x0325
#define META_ESCAPE 0x0626
#define META_RESTOREDC 0x0127
#define META_FILLREGION 0x0228
#define META_FRAMEREGION 0x0429
#define META_INVERTREGION 0x012A
#define META_PAINTREGION 0x012B
#define META_SELECTCLIPREGION 0x012C
#define META_SELECTOBJECT 0x012D
#define META_SETTEXTALIGN 0x012E
#define META_CHORD 0x0830
#define META_SETMAPPERFLAGS 0x0231
#define META_EXTTEXTOUT 0x0a32
#define META_SETDIBTODEV 0x0d33
#define META_SELECTPALETTE 0x0234
#define META_REALIZEPALETTE 0x0035
#define META_ANIMATEPALETTE 0x0436
#define META_SETPALENTRIES 0x0037
#define META_POLYPOLYGON 0x0538
#define META_RESIZEPALETTE 0x0139
#define META_DIBBITBLT 0x0940
#define META_DIBSTRETCHBLT 0x0b41
#define META_DIBCREATEPATTERNBRUSH 0x0142
#define META_STRETCHDIB 0x0f43
#define META_EXTFLOODFILL 0x0548

#define META_SETLAYOUT 0x0149

#define META_DELETEOBJECT 0x01f0
#define META_CREATEPALETTE 0x00f7
#define META_CREATEPATTERNBRUSH 0x01F9
#define META_CREATEPENINDIRECT 0x02FA
#define META_CREATEFONTINDIRECT 0x02FB
#define META_CREATEBRUSHINDIRECT 0x02FC
#define META_CREATEREGION 0x06FF


typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;




/* GDI Escapes */
#define NEWFRAME 1
#define ABORTDOC 2
#define NEXTBAND 3
#define SETCOLORTABLE 4
#define GETCOLORTABLE 5
#define FLUSHOUTPUT 6
#define DRAFTMODE 7
#define QUERYESCSUPPORT 8
#define SETABORTPROC 9
#define STARTDOC 10
#define ENDDOC 11
#define GETPHYSPAGESIZE 12
#define GETPRINTINGOFFSET 13
#define GETSCALINGFACTOR 14
#define MFCOMMENT 15
#define GETPENWIDTH 16
#define SETCOPYCOUNT 17
#define SELECTPAPERSOURCE 18
#define DEVICEDATA 19
#define PASSTHROUGH 19
#define GETTECHNOLGY 20
#define GETTECHNOLOGY 20
#define SETLINECAP 21
#define SETLINEJOIN 22
#define SETMITERLIMIT 23
#define BANDINFO 24
#define DRAWPATTERNRECT 25
#define GETVECTORPENSIZE 26
#define GETVECTORBRUSHSIZE 27
#define ENABLEDUPLEX 28
#define GETSETPAPERBINS 29
#define GETSETPRINTORIENT 30
#define ENUMPAPERBINS 31
#define SETDIBSCALING 32
#define EPSPRINTING 33
#define ENUMPAPERMETRICS 34
#define GETSETPAPERMETRICS 35
#define POSTSCRIPT_DATA 37
#define POSTSCRIPT_IGNORE 38
#define MOUSETRAILS 39
#define GETDEVICEUNITS 42

#define GETEXTENDEDTEXTMETRICS 256
#define GETEXTENTTABLE 257
#define GETPAIRKERNTABLE 258
#define GETTRACKKERNTABLE 259
#define EXTTEXTOUT 512
#define GETFACENAME 513
#define DOWNLOADFACE 514
#define ENABLERELATIVEWIDTHS 768
#define ENABLEPAIRKERNING 769
#define SETKERNTRACK 770
#define SETALLJUSTVALUES 771
#define SETCHARSET 772

#define STRETCHBLT 2048
#define METAFILE_DRIVER 2049
#define GETSETSCREENPARAMS 3072
#define QUERYDIBSUPPORT 3073
#define BEGIN_PATH 4096
#define CLIP_TO_PATH 4097
#define END_PATH 4098
#define EXT_DEVICE_CAPS 4099
#define RESTORE_CTM 4100
#define SAVE_CTM 4101
#define SET_ARC_DIRECTION 4102
#define SET_BACKGROUND_COLOR 4103
#define SET_POLY_MODE 4104
#define SET_SCREEN_ANGLE 4105
#define SET_SPREAD 4106
#define TRANSFORM_CTM 4107
#define SET_CLIP_BOX 4108
#define SET_BOUNDS 4109
#define SET_MIRROR_MODE 4110
#define OPENCHANNEL 4110
#define DOWNLOADHEADER 4111
#define CLOSECHANNEL 4112
#define POSTSCRIPT_PASSTHROUGH 4115
#define ENCAPSULATED_POSTSCRIPT 4116

#define POSTSCRIPT_IDENTIFY 4117
#define POSTSCRIPT_INJECTION 4118

#define CHECKJPEGFORMAT 4119
#define CHECKPNGFORMAT 4120

#define GET_PS_FEATURESETTING 4121

#define GDIPLUS_TS_QUERYVER 4122
#define GDIPLUS_TS_RECORD 4123

/*

 * Return Values for MILCORE_TS_QUERYVER

 */
#define MILCORE_TS_QUERYVER_RESULT_FALSE 0x0
#define MILCORE_TS_QUERYVER_RESULT_TRUE 0x7FFFFFFF



#define SPCLPASSTHROUGH2 4568

/*

 * Parameters for POSTSCRIPT_IDENTIFY escape

 */
# 402 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
#define PSIDENT_GDICENTRIC 0
#define PSIDENT_PSCENTRIC 1

/*

 * Header structure for the input buffer to POSTSCRIPT_INJECTION escape

 */
# 409 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct _PSINJECTDATA {

    DWORD DataBytes; /* number of raw data bytes (NOT including this header) */
    WORD InjectionPoint; /* injection point */
    WORD PageNumber; /* page number to apply the injection */

    /* Followed by raw data to be injected */

} PSINJECTDATA, *PPSINJECTDATA;

/*

 * Constants for PSINJECTDATA.InjectionPoint field

 */
# 423 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
#define PSINJECT_BEGINSTREAM 1
#define PSINJECT_PSADOBE 2
#define PSINJECT_PAGESATEND 3
#define PSINJECT_PAGES 4

#define PSINJECT_DOCNEEDEDRES 5
#define PSINJECT_DOCSUPPLIEDRES 6
#define PSINJECT_PAGEORDER 7
#define PSINJECT_ORIENTATION 8
#define PSINJECT_BOUNDINGBOX 9
#define PSINJECT_DOCUMENTPROCESSCOLORS 10

#define PSINJECT_COMMENTS 11
#define PSINJECT_BEGINDEFAULTS 12
#define PSINJECT_ENDDEFAULTS 13
#define PSINJECT_BEGINPROLOG 14
#define PSINJECT_ENDPROLOG 15
#define PSINJECT_BEGINSETUP 16
#define PSINJECT_ENDSETUP 17
#define PSINJECT_TRAILER 18
#define PSINJECT_EOF 19
#define PSINJECT_ENDSTREAM 20
#define PSINJECT_DOCUMENTPROCESSCOLORSATEND 21

#define PSINJECT_PAGENUMBER 100
#define PSINJECT_BEGINPAGESETUP 101
#define PSINJECT_ENDPAGESETUP 102
#define PSINJECT_PAGETRAILER 103
#define PSINJECT_PLATECOLOR 104

#define PSINJECT_SHOWPAGE 105
#define PSINJECT_PAGEBBOX 106
#define PSINJECT_ENDPAGECOMMENTS 107

#define PSINJECT_VMSAVE 200
#define PSINJECT_VMRESTORE 201

/*

 * InjectionPoint for publisher mode PScript5 OEM plugin to

 * generate DSC comment for included font resource

 */
# 464 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
#define PSINJECT_DLFONT 0xdddddddd

/*

 * Parameter for GET_PS_FEATURESETTING escape

 */
# 470 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
#define FEATURESETTING_NUP 0
#define FEATURESETTING_OUTPUT 1
#define FEATURESETTING_PSLEVEL 2
#define FEATURESETTING_CUSTPAPER 3
#define FEATURESETTING_MIRROR 4
#define FEATURESETTING_NEGATIVE 5
#define FEATURESETTING_PROTOCOL 6


//
// The range of selectors between FEATURESETTING_PRIVATE_BEGIN and
// FEATURESETTING_PRIVATE_END is reserved by Microsoft for private use
//
#define FEATURESETTING_PRIVATE_BEGIN 0x1000
#define FEATURESETTING_PRIVATE_END 0x1FFF


/*

 * Information about output options

 */
# 491 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;

/*

 * Information about custom paper size

 */
# 502 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;

/* Value returned for FEATURESETTING_PROTOCOL */
#define PSPROTOCOL_ASCII 0
#define PSPROTOCOL_BCP 1
#define PSPROTOCOL_TBCP 2
#define PSPROTOCOL_BINARY 3

/* Flag returned from QUERYDIBSUPPORT */
#define QDI_SETDIBITS 1
#define QDI_GETDIBITS 2
#define QDI_DIBTOSCREEN 4
#define QDI_STRETCHDIB 8

/* Spooler Error Codes */
#define SP_NOTREPORTED 0x4000
#define SP_ERROR (-1)
#define SP_APPABORT (-2)
#define SP_USERABORT (-3)
#define SP_OUTOFDISK (-4)
#define SP_OUTOFMEMORY (-5)

#define PR_JOBSTATUS 0x0000

/* Object Definitions for EnumObjects() */
#define OBJ_PEN 1
#define OBJ_BRUSH 2
#define OBJ_DC 3
#define OBJ_METADC 4
#define OBJ_PAL 5
#define OBJ_FONT 6
#define OBJ_BITMAP 7
#define OBJ_REGION 8
#define OBJ_METAFILE 9
#define OBJ_MEMDC 10
#define OBJ_EXTPEN 11
#define OBJ_ENHMETADC 12
#define OBJ_ENHMETAFILE 13
#define OBJ_COLORSPACE 14

#define GDI_OBJ_LAST OBJ_COLORSPACE

/* xform stuff */
#define MWT_IDENTITY 1
#define MWT_LEFTMULTIPLY 2
#define MWT_RIGHTMULTIPLY 3

#define MWT_MIN MWT_IDENTITY
#define MWT_MAX MWT_RIGHTMULTIPLY

#define _XFORM_ 
typedef struct tagXFORM
  {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
  } XFORM, *PXFORM, *LPXFORM;

/* Bitmap Header Definition */
typedef struct tagBITMAP
  {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    LPVOID bmBits;
  } BITMAP, *PBITMAP, *NPBITMAP, *LPBITMAP;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack1.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack1.h



Abstract:



    This file turns 1 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack1.h"
#pragma pack(1)
# 584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagRGBTRIPLE {
        BYTE rgbtBlue;
        BYTE rgbtGreen;
        BYTE rgbtRed;
} RGBTRIPLE, *PRGBTRIPLE, *NPRGBTRIPLE, *LPRGBTRIPLE;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 590 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2

typedef struct tagRGBQUAD {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbReserved;
} RGBQUAD;
typedef RGBQUAD * LPRGBQUAD;



/* Image Color Matching color definitions */

#define CS_ENABLE 0x00000001L
#define CS_DISABLE 0x00000002L
#define CS_DELETE_TRANSFORM 0x00000003L

/* Logcolorspace signature */

#define LCS_SIGNATURE 'PSOC'

/* Logcolorspace lcsType values */

#define LCS_sRGB 'sRGB'
#define LCS_WINDOWS_COLOR_SPACE 'Win '

typedef LONG LCSCSTYPE;
#define LCS_CALIBRATED_RGB 0x00000000L

typedef LONG LCSGAMUTMATCH;
#define LCS_GM_BUSINESS 0x00000001L
#define LCS_GM_GRAPHICS 0x00000002L
#define LCS_GM_IMAGES 0x00000004L
#define LCS_GM_ABS_COLORIMETRIC 0x00000008L

/* ICM Defines for results from CheckColorInGamut() */
#define CM_OUT_OF_GAMUT 255
#define CM_IN_GAMUT 0

/* UpdateICMRegKey Constants               */
#define ICM_ADDPROFILE 1
#define ICM_DELETEPROFILE 2
#define ICM_QUERYPROFILE 3
#define ICM_SETDEFAULTPROFILE 4
#define ICM_REGISTERICMATCHER 5
#define ICM_UNREGISTERICMATCHER 6
#define ICM_QUERYMATCH 7

/* Macros to retrieve CMYK values from a COLORREF */
#define GetKValue(cmyk) ((BYTE)(cmyk))
#define GetYValue(cmyk) ((BYTE)((cmyk)>> 8))
#define GetMValue(cmyk) ((BYTE)((cmyk)>>16))
#define GetCValue(cmyk) ((BYTE)((cmyk)>>24))

#define CMYK(c,m,y,k) ((COLORREF)((((BYTE)(k)|((WORD)((BYTE)(y))<<8))|(((DWORD)(BYTE)(m))<<16))|(((DWORD)(BYTE)(c))<<24)))

typedef long FXPT16DOT16, *LPFXPT16DOT16;
typedef long FXPT2DOT30, *LPFXPT2DOT30;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of CIEXYZ.

typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
        CIEXYZ ciexyzRed;
        CIEXYZ ciexyzGreen;
        CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE *LPCIEXYZTRIPLE;

// The next structures the logical color space. Unlike pens and brushes,
// but like palettes, there is only one way to create a LogColorSpace.
// A pointer to it must be passed, its elements can't be pushed as
// arguments.

typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;




typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;




/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER {
        DWORD bcSize; /* used to get to color table */
        WORD bcWidth;
        WORD bcHeight;
        WORD bcPlanes;
        WORD bcBitCount;
} BITMAPCOREHEADER, *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER{
        DWORD biSize;
        LONG biWidth;
        LONG biHeight;
        WORD biPlanes;
        WORD biBitCount;
        DWORD biCompression;
        DWORD biSizeImage;
        LONG biXPelsPerMeter;
        LONG biYPelsPerMeter;
        DWORD biClrUsed;
        DWORD biClrImportant;
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;


typedef struct {
        DWORD bV4Size;
        LONG bV4Width;
        LONG bV4Height;
        WORD bV4Planes;
        WORD bV4BitCount;
        DWORD bV4V4Compression;
        DWORD bV4SizeImage;
        LONG bV4XPelsPerMeter;
        LONG bV4YPelsPerMeter;
        DWORD bV4ClrUsed;
        DWORD bV4ClrImportant;
        DWORD bV4RedMask;
        DWORD bV4GreenMask;
        DWORD bV4BlueMask;
        DWORD bV4AlphaMask;
        DWORD bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD bV4GammaRed;
        DWORD bV4GammaGreen;
        DWORD bV4GammaBlue;
} BITMAPV4HEADER, *LPBITMAPV4HEADER, *PBITMAPV4HEADER;



typedef struct {
        DWORD bV5Size;
        LONG bV5Width;
        LONG bV5Height;
        WORD bV5Planes;
        WORD bV5BitCount;
        DWORD bV5Compression;
        DWORD bV5SizeImage;
        LONG bV5XPelsPerMeter;
        LONG bV5YPelsPerMeter;
        DWORD bV5ClrUsed;
        DWORD bV5ClrImportant;
        DWORD bV5RedMask;
        DWORD bV5GreenMask;
        DWORD bV5BlueMask;
        DWORD bV5AlphaMask;
        DWORD bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD bV5GammaRed;
        DWORD bV5GammaGreen;
        DWORD bV5GammaBlue;
        DWORD bV5Intent;
        DWORD bV5ProfileData;
        DWORD bV5ProfileSize;
        DWORD bV5Reserved;
} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

// Values for bV5CSType
#define PROFILE_LINKED 'LINK'
#define PROFILE_EMBEDDED 'MBED'


/* constants for the biCompression field */
#define BI_RGB 0L
#define BI_RLE8 1L
#define BI_RLE4 2L
#define BI_BITFIELDS 3L
#define BI_JPEG 4L
#define BI_PNG 5L



typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[1];
} BITMAPINFO, *LPBITMAPINFO, *PBITMAPINFO;

typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO, *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack2.h



Abstract:



    This file turns 2 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 809 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagBITMAPFILEHEADER {
        WORD bfType;
        DWORD bfSize;
        WORD bfReserved1;
        WORD bfReserved2;
        DWORD bfOffBits;
} BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 817 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2

#define MAKEPOINTS(l) (*((POINTS FAR *)&(l)))



typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;

typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO, *NPCHARSETINFO, *LPCHARSETINFO;

#define TCI_SRCCHARSET 1
#define TCI_SRCCODEPAGE 2
#define TCI_SRCFONTSIG 3

#define TCI_SRCLOCALE 0x1000


typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;







/* Clipboard Metafile Picture Structure */
typedef struct tagHANDLETABLE
  {
    HGDIOBJ objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE, *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD rdSize;
    WORD rdFunction;
    WORD rdParm[1];
  } METARECORD;
typedef struct tagMETARECORD *PMETARECORD;
typedef struct tagMETARECORD *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    LONG mm;
    LONG xExt;
    LONG yExt;
    HMETAFILE hMF;
  } METAFILEPICT, *LPMETAFILEPICT;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack2.h



Abstract:



    This file turns 2 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 879 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagMETAHEADER
{
    WORD mtType;
    WORD mtHeaderSize;
    WORD mtVersion;
    DWORD mtSize;
    WORD mtNoObjects;
    DWORD mtMaxRecord;
    WORD mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER *PMETAHEADER;
typedef struct tagMETAHEADER *LPMETAHEADER;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 893 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2

/* Enhanced Metafile structures */
typedef struct tagENHMETARECORD
{
    DWORD iType; // Record type EMR_XXX
    DWORD nSize; // Record size in bytes
    DWORD dParm[1]; // Parameters
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD iType; // Record typeEMR_HEADER
    DWORD nSize; // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    RECTL rclFrame; // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD dSignature; // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD nVersion; // Version number
    DWORD nBytes; // Size of the metafile in bytes
    DWORD nRecords; // Number of records in the metafile
    WORD nHandles; // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD sReserved; // Reserved.  Must be zero.
    DWORD nDescription; // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD offDescription; // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD nPalEntries; // Number of entries in the metafile palette.
    SIZEL szlDevice; // Size of the reference device in pels
    SIZEL szlMillimeters; // Size of the reference device in millimeters

    DWORD cbPixelFormat; // Size of PIXELFORMATDESCRIPTOR information
                                // This is 0 if no pixel format is set
    DWORD offPixelFormat; // Offset to PIXELFORMATDESCRIPTOR
                                // This is 0 if no pixel format is set
    DWORD bOpenGL; // TRUE if OpenGL commands are present in
                                // the metafile, otherwise FALSE


    SIZEL szlMicrometers; // Size of the reference device in micrometers


} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;





/* tmPitchAndFamily flags */
#define TMPF_FIXED_PITCH 0x01
#define TMPF_VECTOR 0x02
#define TMPF_DEVICE 0x08
#define TMPF_TRUETYPE 0x04

//
// BCHAR definition for APPs
//



    typedef BYTE BCHAR;



#define _TEXTMETRIC_DEFINED 
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack4.h



Abstract:



    This file turns 4 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 959 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagTEXTMETRICA
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA, *NPTEXTMETRICA, *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW, *NPTEXTMETRICW, *LPTEXTMETRICW;






typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 1017 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2


/* ntmFlags field flags */
#define NTM_REGULAR 0x00000040L
#define NTM_BOLD 0x00000020L
#define NTM_ITALIC 0x00000001L

/* new in NT 5.0 */

#define NTM_NONNEGATIVE_AC 0x00010000
#define NTM_PS_OPENTYPE 0x00020000
#define NTM_TT_OPENTYPE 0x00040000
#define NTM_MULTIPLEMASTER 0x00080000
#define NTM_TYPE1 0x00100000
#define NTM_DSIG 0x00200000

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack4.h



Abstract:



    This file turns 4 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack4.h"
#pragma pack(4)
# 1034 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2
typedef struct tagNEWTEXTMETRICA
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    BYTE tmFirstChar;
    BYTE tmLastChar;
    BYTE tmDefaultChar;
    BYTE tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, *NPNEWTEXTMETRICA, *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    DWORD ntmFlags;
    UINT ntmSizeEM;
    UINT ntmCellHeight;
    UINT ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW, *NPNEWTEXTMETRICW, *LPNEWTEXTMETRICW;






typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 1100 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h" 2


typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA ntmTm;
    FONTSIGNATURE ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW ntmTm;
    FONTSIGNATURE ntmFontSig;
}NEWTEXTMETRICEXW;



typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;




/* GDI Logical Objects: */

/* Pel Array */
typedef struct tagPELARRAY
  {
    LONG paXCount;
    LONG paYCount;
    LONG paXExt;
    LONG paYExt;
    BYTE paRGBs;
  } PELARRAY, *PPELARRAY, *NPPELARRAY, *LPPELARRAY;

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
  {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG_PTR lbHatch;
  } LOGBRUSH, *PLOGBRUSH, *NPLOGBRUSH, *LPLOGBRUSH;

typedef struct tagLOGBRUSH32
  {
    UINT lbStyle;
    COLORREF lbColor;
    ULONG lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;

typedef LOGBRUSH PATTERN;
typedef PATTERN *PPATTERN;
typedef PATTERN *NPPATTERN;
typedef PATTERN *LPPATTERN;

/* Logical Pen */
typedef struct tagLOGPEN
  {
    UINT lopnStyle;
    POINT lopnWidth;
    COLORREF lopnColor;
  } LOGPEN, *PLOGPEN, *NPLOGPEN, *LPLOGPEN;

typedef struct tagEXTLOGPEN {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG_PTR elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN, *NPEXTLOGPEN, *LPEXTLOGPEN;

typedef struct tagEXTLOGPEN32 {
    DWORD elpPenStyle;
    DWORD elpWidth;
    UINT elpBrushStyle;
    COLORREF elpColor;
    ULONG elpHatch;
    DWORD elpNumEntries;
    DWORD elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32, *NPEXTLOGPEN32, *LPEXTLOGPEN32;


#define _PALETTEENTRY_DEFINED 
typedef struct tagPALETTEENTRY {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
} PALETTEENTRY, *PPALETTEENTRY, *LPPALETTEENTRY;



#define _LOGPALETTE_DEFINED 
/* Logical Palette */
typedef struct tagLOGPALETTE {
    WORD palVersion;
    WORD palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE, *NPLOGPALETTE, *LPLOGPALETTE;



/* Logical Font */
#define LF_FACESIZE 32

typedef struct tagLOGFONTA
{
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[32];
} LOGFONTA, *PLOGFONTA, *NPLOGFONTA, *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[32];
} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;






typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;


#define LF_FULLFACESIZE 64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
} ENUMLOGFONTA, * LPENUMLOGFONTA;
/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
} ENUMLOGFONTW, * LPENUMLOGFONTW;




typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;



typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    BYTE elfScript[32];
} ENUMLOGFONTEXA, *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    WCHAR elfScript[32];
} ENUMLOGFONTEXW, *LPENUMLOGFONTEXW;




typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;



#define OUT_DEFAULT_PRECIS 0
#define OUT_STRING_PRECIS 1
#define OUT_CHARACTER_PRECIS 2
#define OUT_STROKE_PRECIS 3
#define OUT_TT_PRECIS 4
#define OUT_DEVICE_PRECIS 5
#define OUT_RASTER_PRECIS 6
#define OUT_TT_ONLY_PRECIS 7
#define OUT_OUTLINE_PRECIS 8
#define OUT_SCREEN_OUTLINE_PRECIS 9
#define OUT_PS_ONLY_PRECIS 10

#define CLIP_DEFAULT_PRECIS 0
#define CLIP_CHARACTER_PRECIS 1
#define CLIP_STROKE_PRECIS 2
#define CLIP_MASK 0xf
#define CLIP_LH_ANGLES (1<<4)
#define CLIP_TT_ALWAYS (2<<4)

#define CLIP_DFA_DISABLE (4<<4)

#define CLIP_EMBEDDED (8<<4)

#define DEFAULT_QUALITY 0
#define DRAFT_QUALITY 1
#define PROOF_QUALITY 2

#define NONANTIALIASED_QUALITY 3
#define ANTIALIASED_QUALITY 4



#define CLEARTYPE_QUALITY 5
#define CLEARTYPE_NATURAL_QUALITY 6


#define DEFAULT_PITCH 0
#define FIXED_PITCH 1
#define VARIABLE_PITCH 2

#define MONO_FONT 8


#define ANSI_CHARSET 0
#define DEFAULT_CHARSET 1
#define SYMBOL_CHARSET 2
#define SHIFTJIS_CHARSET 128
#define HANGEUL_CHARSET 129
#define HANGUL_CHARSET 129
#define GB2312_CHARSET 134
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET 255

#define JOHAB_CHARSET 130
#define HEBREW_CHARSET 177
#define ARABIC_CHARSET 178
#define GREEK_CHARSET 161
#define TURKISH_CHARSET 162
#define VIETNAMESE_CHARSET 163
#define THAI_CHARSET 222
#define EASTEUROPE_CHARSET 238
#define RUSSIAN_CHARSET 204

#define MAC_CHARSET 77
#define BALTIC_CHARSET 186

#define FS_LATIN1 0x00000001L
#define FS_LATIN2 0x00000002L
#define FS_CYRILLIC 0x00000004L
#define FS_GREEK 0x00000008L
#define FS_TURKISH 0x00000010L
#define FS_HEBREW 0x00000020L
#define FS_ARABIC 0x00000040L
#define FS_BALTIC 0x00000080L
#define FS_VIETNAMESE 0x00000100L
#define FS_THAI 0x00010000L
#define FS_JISJAPAN 0x00020000L
#define FS_CHINESESIMP 0x00040000L
#define FS_WANSUNG 0x00080000L
#define FS_CHINESETRAD 0x00100000L
#define FS_JOHAB 0x00200000L
#define FS_SYMBOL 0x80000000L


/* Font Families */
#define FF_DONTCARE (0<<4)
#define FF_ROMAN (1<<4)
                                    /* Times Roman, Century Schoolbook, etc. */
#define FF_SWISS (2<<4)
                                    /* Helvetica, Swiss, etc. */
#define FF_MODERN (3<<4)
                                    /* Pica, Elite, Courier, etc. */
#define FF_SCRIPT (4<<4)
#define FF_DECORATIVE (5<<4)

/* Font Weights */
#define FW_DONTCARE 0
#define FW_THIN 100
#define FW_EXTRALIGHT 200
#define FW_LIGHT 300
#define FW_NORMAL 400
#define FW_MEDIUM 500
#define FW_SEMIBOLD 600
#define FW_BOLD 700
#define FW_EXTRABOLD 800
#define FW_HEAVY 900

#define FW_ULTRALIGHT FW_EXTRALIGHT
#define FW_REGULAR FW_NORMAL
#define FW_DEMIBOLD FW_SEMIBOLD
#define FW_ULTRABOLD FW_EXTRABOLD
#define FW_BLACK FW_HEAVY

#define PANOSE_COUNT 10
#define PAN_FAMILYTYPE_INDEX 0
#define PAN_SERIFSTYLE_INDEX 1
#define PAN_WEIGHT_INDEX 2
#define PAN_PROPORTION_INDEX 3
#define PAN_CONTRAST_INDEX 4
#define PAN_STROKEVARIATION_INDEX 5
#define PAN_ARMSTYLE_INDEX 6
#define PAN_LETTERFORM_INDEX 7
#define PAN_MIDLINE_INDEX 8
#define PAN_XHEIGHT_INDEX 9

#define PAN_CULTURE_LATIN 0

typedef struct tagPANOSE
{
    BYTE bFamilyType;
    BYTE bSerifStyle;
    BYTE bWeight;
    BYTE bProportion;
    BYTE bContrast;
    BYTE bStrokeVariation;
    BYTE bArmStyle;
    BYTE bLetterform;
    BYTE bMidline;
    BYTE bXHeight;
} PANOSE, * LPPANOSE;

#define PAN_ANY 0
#define PAN_NO_FIT 1

#define PAN_FAMILY_TEXT_DISPLAY 2
#define PAN_FAMILY_SCRIPT 3
#define PAN_FAMILY_DECORATIVE 4
#define PAN_FAMILY_PICTORIAL 5

#define PAN_SERIF_COVE 2
#define PAN_SERIF_OBTUSE_COVE 3
#define PAN_SERIF_SQUARE_COVE 4
#define PAN_SERIF_OBTUSE_SQUARE_COVE 5
#define PAN_SERIF_SQUARE 6
#define PAN_SERIF_THIN 7
#define PAN_SERIF_BONE 8
#define PAN_SERIF_EXAGGERATED 9
#define PAN_SERIF_TRIANGLE 10
#define PAN_SERIF_NORMAL_SANS 11
#define PAN_SERIF_OBTUSE_SANS 12
#define PAN_SERIF_PERP_SANS 13
#define PAN_SERIF_FLARED 14
#define PAN_SERIF_ROUNDED 15

#define PAN_WEIGHT_VERY_LIGHT 2
#define PAN_WEIGHT_LIGHT 3
#define PAN_WEIGHT_THIN 4
#define PAN_WEIGHT_BOOK 5
#define PAN_WEIGHT_MEDIUM 6
#define PAN_WEIGHT_DEMI 7
#define PAN_WEIGHT_BOLD 8
#define PAN_WEIGHT_HEAVY 9
#define PAN_WEIGHT_BLACK 10
#define PAN_WEIGHT_NORD 11

#define PAN_PROP_OLD_STYLE 2
#define PAN_PROP_MODERN 3
#define PAN_PROP_EVEN_WIDTH 4
#define PAN_PROP_EXPANDED 5
#define PAN_PROP_CONDENSED 6
#define PAN_PROP_VERY_EXPANDED 7
#define PAN_PROP_VERY_CONDENSED 8
#define PAN_PROP_MONOSPACED 9

#define PAN_CONTRAST_NONE 2
#define PAN_CONTRAST_VERY_LOW 3
#define PAN_CONTRAST_LOW 4
#define PAN_CONTRAST_MEDIUM_LOW 5
#define PAN_CONTRAST_MEDIUM 6
#define PAN_CONTRAST_MEDIUM_HIGH 7
#define PAN_CONTRAST_HIGH 8
#define PAN_CONTRAST_VERY_HIGH 9

#define PAN_STROKE_GRADUAL_DIAG 2
#define PAN_STROKE_GRADUAL_TRAN 3
#define PAN_STROKE_GRADUAL_VERT 4
#define PAN_STROKE_GRADUAL_HORZ 5
#define PAN_STROKE_RAPID_VERT 6
#define PAN_STROKE_RAPID_HORZ 7
#define PAN_STROKE_INSTANT_VERT 8

#define PAN_STRAIGHT_ARMS_HORZ 2
#define PAN_STRAIGHT_ARMS_WEDGE 3
#define PAN_STRAIGHT_ARMS_VERT 4
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF 5
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF 6
#define PAN_BENT_ARMS_HORZ 7
#define PAN_BENT_ARMS_WEDGE 8
#define PAN_BENT_ARMS_VERT 9
#define PAN_BENT_ARMS_SINGLE_SERIF 10
#define PAN_BENT_ARMS_DOUBLE_SERIF 11

#define PAN_LETT_NORMAL_CONTACT 2
#define PAN_LETT_NORMAL_WEIGHTED 3
#define PAN_LETT_NORMAL_BOXED 4
#define PAN_LETT_NORMAL_FLATTENED 5
#define PAN_LETT_NORMAL_ROUNDED 6
#define PAN_LETT_NORMAL_OFF_CENTER 7
#define PAN_LETT_NORMAL_SQUARE 8
#define PAN_LETT_OBLIQUE_CONTACT 9
#define PAN_LETT_OBLIQUE_WEIGHTED 10
#define PAN_LETT_OBLIQUE_BOXED 11
#define PAN_LETT_OBLIQUE_FLATTENED 12
#define PAN_LETT_OBLIQUE_ROUNDED 13
#define PAN_LETT_OBLIQUE_OFF_CENTER 14
#define PAN_LETT_OBLIQUE_SQUARE 15

#define PAN_MIDLINE_STANDARD_TRIMMED 2
#define PAN_MIDLINE_STANDARD_POINTED 3
#define PAN_MIDLINE_STANDARD_SERIFED 4
#define PAN_MIDLINE_HIGH_TRIMMED 5
#define PAN_MIDLINE_HIGH_POINTED 6
#define PAN_MIDLINE_HIGH_SERIFED 7
#define PAN_MIDLINE_CONSTANT_TRIMMED 8
#define PAN_MIDLINE_CONSTANT_POINTED 9
#define PAN_MIDLINE_CONSTANT_SERIFED 10
#define PAN_MIDLINE_LOW_TRIMMED 11
#define PAN_MIDLINE_LOW_POINTED 12
#define PAN_MIDLINE_LOW_SERIFED 13

#define PAN_XHEIGHT_CONSTANT_SMALL 2
#define PAN_XHEIGHT_CONSTANT_STD 3
#define PAN_XHEIGHT_CONSTANT_LARGE 4
#define PAN_XHEIGHT_DUCKING_SMALL 5
#define PAN_XHEIGHT_DUCKING_STD 6
#define PAN_XHEIGHT_DUCKING_LARGE 7


#define ELF_VENDOR_SIZE 4

/* The extended logical font       */
/* An extension of the ENUMLOGFONT */

typedef struct tagEXTLOGFONTA {
    LOGFONTA elfLogFont;
    BYTE elfFullName[64];
    BYTE elfStyle[32];
    DWORD elfVersion; /* 0 for the first release of NT */
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture; /* 0 for Latin                   */
    PANOSE elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA, *NPEXTLOGFONTA, *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW elfLogFont;
    WCHAR elfFullName[64];
    WCHAR elfStyle[32];
    DWORD elfVersion; /* 0 for the first release of NT */
    DWORD elfStyleSize;
    DWORD elfMatch;
    DWORD elfReserved;
    BYTE elfVendorId[4];
    DWORD elfCulture; /* 0 for Latin                   */
    PANOSE elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW, *NPEXTLOGFONTW, *LPEXTLOGFONTW;






typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;


#define ELF_VERSION 0
#define ELF_CULTURE_LATIN 0

/* EnumFonts Masks */
#define RASTER_FONTTYPE 0x0001
#define DEVICE_FONTTYPE 0x0002
#define TRUETYPE_FONTTYPE 0x0004

#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))
#define PALETTERGB(r,g,b) (0x02000000 | RGB(r,g,b))
#define PALETTEINDEX(i) ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))

/* palette entry flags */

#define PC_RESERVED 0x01
#define PC_EXPLICIT 0x02
#define PC_NOCOLLAPSE 0x04

#define GetRValue(rgb) (LOBYTE(rgb))
#define GetGValue(rgb) (LOBYTE(((WORD)(rgb)) >> 8))
#define GetBValue(rgb) (LOBYTE((rgb)>>16))

/* Background Modes */
#define TRANSPARENT 1
#define OPAQUE 2
#define BKMODE_LAST 2

/* Graphics Modes */

#define GM_COMPATIBLE 1
#define GM_ADVANCED 2
#define GM_LAST 2

/* PolyDraw and GetPath point types */
#define PT_CLOSEFIGURE 0x01
#define PT_LINETO 0x02
#define PT_BEZIERTO 0x04
#define PT_MOVETO 0x06

/* Mapping Modes */
#define MM_TEXT 1
#define MM_LOMETRIC 2
#define MM_HIMETRIC 3
#define MM_LOENGLISH 4
#define MM_HIENGLISH 5
#define MM_TWIPS 6
#define MM_ISOTROPIC 7
#define MM_ANISOTROPIC 8

/* Min and Max Mapping Mode values */
#define MM_MIN MM_TEXT
#define MM_MAX MM_ANISOTROPIC
#define MM_MAX_FIXEDSCALE MM_TWIPS

/* Coordinate Modes */
#define ABSOLUTE 1
#define RELATIVE 2

/* Stock Logical Objects */
#define WHITE_BRUSH 0
#define LTGRAY_BRUSH 1
#define GRAY_BRUSH 2
#define DKGRAY_BRUSH 3
#define BLACK_BRUSH 4
#define NULL_BRUSH 5
#define HOLLOW_BRUSH NULL_BRUSH
#define WHITE_PEN 6
#define BLACK_PEN 7
#define NULL_PEN 8
#define OEM_FIXED_FONT 10
#define ANSI_FIXED_FONT 11
#define ANSI_VAR_FONT 12
#define SYSTEM_FONT 13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE 15
#define SYSTEM_FIXED_FONT 16


#define DEFAULT_GUI_FONT 17



#define DC_BRUSH 18
#define DC_PEN 19



#define STOCK_LAST 19






#define CLR_INVALID 0xFFFFFFFF

/* Brush Styles */
#define BS_SOLID 0
#define BS_NULL 1
#define BS_HOLLOW BS_NULL
#define BS_HATCHED 2
#define BS_PATTERN 3
#define BS_INDEXED 4
#define BS_DIBPATTERN 5
#define BS_DIBPATTERNPT 6
#define BS_PATTERN8X8 7
#define BS_DIBPATTERN8X8 8
#define BS_MONOPATTERN 9

/* Hatch Styles */
#define HS_HORIZONTAL 0
#define HS_VERTICAL 1
#define HS_FDIAGONAL 2
#define HS_BDIAGONAL 3
#define HS_CROSS 4
#define HS_DIAGCROSS 5
#define HS_API_MAX 12

/* Pen Styles */
#define PS_SOLID 0
#define PS_DASH 1
#define PS_DOT 2
#define PS_DASHDOT 3
#define PS_DASHDOTDOT 4
#define PS_NULL 5
#define PS_INSIDEFRAME 6
#define PS_USERSTYLE 7
#define PS_ALTERNATE 8
#define PS_STYLE_MASK 0x0000000F

#define PS_ENDCAP_ROUND 0x00000000
#define PS_ENDCAP_SQUARE 0x00000100
#define PS_ENDCAP_FLAT 0x00000200
#define PS_ENDCAP_MASK 0x00000F00

#define PS_JOIN_ROUND 0x00000000
#define PS_JOIN_BEVEL 0x00001000
#define PS_JOIN_MITER 0x00002000
#define PS_JOIN_MASK 0x0000F000

#define PS_COSMETIC 0x00000000
#define PS_GEOMETRIC 0x00010000
#define PS_TYPE_MASK 0x000F0000

#define AD_COUNTERCLOCKWISE 1
#define AD_CLOCKWISE 2

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY 2
#define HORZSIZE 4
#define VERTSIZE 6
#define HORZRES 8
#define VERTRES 10
#define BITSPIXEL 12
#define PLANES 14
#define NUMBRUSHES 16
#define NUMPENS 18
#define NUMMARKERS 20
#define NUMFONTS 22
#define NUMCOLORS 24
#define PDEVICESIZE 26
#define CURVECAPS 28
#define LINECAPS 30
#define POLYGONALCAPS 32
#define TEXTCAPS 34
#define CLIPCAPS 36
#define RASTERCAPS 38
#define ASPECTX 40
#define ASPECTY 42
#define ASPECTXY 44

#define LOGPIXELSX 88
#define LOGPIXELSY 90

#define SIZEPALETTE 104
#define NUMRESERVED 106
#define COLORRES 108

// Printing related DeviceCaps. These replace the appropriate Escapes

#define PHYSICALWIDTH 110
#define PHYSICALHEIGHT 111
#define PHYSICALOFFSETX 112
#define PHYSICALOFFSETY 113
#define SCALINGFACTORX 114
#define SCALINGFACTORY 115

// Display driver specific

#define VREFRESH 116
                             /* display device (for displays only) in Hz*/
#define DESKTOPVERTRES 117
                             /* pixels                                  */
#define DESKTOPHORZRES 118
                             /* pixels                                  */
#define BLTALIGNMENT 119


#define SHADEBLENDCAPS 120
#define COLORMGMTCAPS 121




/* Device Capability Masks: */

/* Device Technologies */
#define DT_PLOTTER 0
#define DT_RASDISPLAY 1
#define DT_RASPRINTER 2
#define DT_RASCAMERA 3
#define DT_CHARSTREAM 4
#define DT_METAFILE 5
#define DT_DISPFILE 6

/* Curve Capabilities */
#define CC_NONE 0
#define CC_CIRCLES 1
#define CC_PIE 2
#define CC_CHORD 4
#define CC_ELLIPSES 8
#define CC_WIDE 16
#define CC_STYLED 32
#define CC_WIDESTYLED 64
#define CC_INTERIORS 128
#define CC_ROUNDRECT 256

/* Line Capabilities */
#define LC_NONE 0
#define LC_POLYLINE 2
#define LC_MARKER 4
#define LC_POLYMARKER 8
#define LC_WIDE 16
#define LC_STYLED 32
#define LC_WIDESTYLED 64
#define LC_INTERIORS 128

/* Polygonal Capabilities */
#define PC_NONE 0
#define PC_POLYGON 1
#define PC_RECTANGLE 2
#define PC_WINDPOLYGON 4
#define PC_TRAPEZOID 4
#define PC_SCANLINE 8
#define PC_WIDE 16
#define PC_STYLED 32
#define PC_WIDESTYLED 64
#define PC_INTERIORS 128
#define PC_POLYPOLYGON 256
#define PC_PATHS 512

/* Clipping Capabilities */
#define CP_NONE 0
#define CP_RECTANGLE 1
#define CP_REGION 2

/* Text Capabilities */
#define TC_OP_CHARACTER 0x00000001
#define TC_OP_STROKE 0x00000002
#define TC_CP_STROKE 0x00000004
#define TC_CR_90 0x00000008
#define TC_CR_ANY 0x00000010
#define TC_SF_X_YINDEP 0x00000020
#define TC_SA_DOUBLE 0x00000040
#define TC_SA_INTEGER 0x00000080
#define TC_SA_CONTIN 0x00000100
#define TC_EA_DOUBLE 0x00000200
#define TC_IA_ABLE 0x00000400
#define TC_UA_ABLE 0x00000800
#define TC_SO_ABLE 0x00001000
#define TC_RA_ABLE 0x00002000
#define TC_VA_ABLE 0x00004000
#define TC_RESERVED 0x00008000
#define TC_SCROLLBLT 0x00010000



/* Raster Capabilities */
#define RC_NONE 
#define RC_BITBLT 1
#define RC_BANDING 2
#define RC_SCALING 4
#define RC_BITMAP64 8
#define RC_GDI20_OUTPUT 0x0010
#define RC_GDI20_STATE 0x0020
#define RC_SAVEBITMAP 0x0040
#define RC_DI_BITMAP 0x0080
#define RC_PALETTE 0x0100
#define RC_DIBTODEV 0x0200
#define RC_BIGFONT 0x0400
#define RC_STRETCHBLT 0x0800
#define RC_FLOODFILL 0x1000
#define RC_STRETCHDIB 0x2000
#define RC_OP_DX_OUTPUT 0x4000
#define RC_DEVBITS 0x8000



/* Shading and blending caps */
#define SB_NONE 0x00000000
#define SB_CONST_ALPHA 0x00000001
#define SB_PIXEL_ALPHA 0x00000002
#define SB_PREMULT_ALPHA 0x00000004

#define SB_GRAD_RECT 0x00000010
#define SB_GRAD_TRI 0x00000020

/* Color Management caps */
#define CM_NONE 0x00000000
#define CM_DEVICE_ICM 0x00000001
#define CM_GAMMA_RAMP 0x00000002
#define CM_CMYK_COLOR 0x00000004




/* DIB color table identifiers */

#define DIB_RGB_COLORS 0
#define DIB_PAL_COLORS 1

/* constants for Get/SetSystemPaletteUse() */

#define SYSPAL_ERROR 0
#define SYSPAL_STATIC 1
#define SYSPAL_NOSTATIC 2
#define SYSPAL_NOSTATIC256 3

/* constants for CreateDIBitmap */
#define CBM_INIT 0x04L

/* ExtFloodFill style flags */
#define FLOODFILLBORDER 0
#define FLOODFILLSURFACE 1

/* size of a device name string */
#define CCHDEVICENAME 32

/* size of a form name string */
#define CCHFORMNAME 32


typedef struct _devicemodeA {
    BYTE dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      /* printer only fields */
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      /* display only fields */
      struct {
        POINTL dmPosition;
        DWORD dmDisplayOrientation;
        DWORD dmDisplayFixedOutput;
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    };
    DWORD dmDisplayFrequency;

    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;

    DWORD dmPanningWidth;
    DWORD dmPanningHeight;


} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      /* printer only fields */
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      /* display only fields */
      struct {
        POINTL dmPosition;
        DWORD dmDisplayOrientation;
        DWORD dmDisplayFixedOutput;
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union {
        DWORD dmDisplayFlags;
        DWORD dmNup;
    };
    DWORD dmDisplayFrequency;

    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;

    DWORD dmPanningWidth;
    DWORD dmPanningHeight;


} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;






typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
# 2158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
/* current version of specification */

#define DM_SPECVERSION 0x0401






/* field selection bits */
#define DM_ORIENTATION 0x00000001L
#define DM_PAPERSIZE 0x00000002L
#define DM_PAPERLENGTH 0x00000004L
#define DM_PAPERWIDTH 0x00000008L
#define DM_SCALE 0x00000010L

#define DM_POSITION 0x00000020L
#define DM_NUP 0x00000040L


#define DM_DISPLAYORIENTATION 0x00000080L

#define DM_COPIES 0x00000100L
#define DM_DEFAULTSOURCE 0x00000200L
#define DM_PRINTQUALITY 0x00000400L
#define DM_COLOR 0x00000800L
#define DM_DUPLEX 0x00001000L
#define DM_YRESOLUTION 0x00002000L
#define DM_TTOPTION 0x00004000L
#define DM_COLLATE 0x00008000L
#define DM_FORMNAME 0x00010000L
#define DM_LOGPIXELS 0x00020000L
#define DM_BITSPERPEL 0x00040000L
#define DM_PELSWIDTH 0x00080000L
#define DM_PELSHEIGHT 0x00100000L
#define DM_DISPLAYFLAGS 0x00200000L
#define DM_DISPLAYFREQUENCY 0x00400000L

#define DM_ICMMETHOD 0x00800000L
#define DM_ICMINTENT 0x01000000L
#define DM_MEDIATYPE 0x02000000L
#define DM_DITHERTYPE 0x04000000L
#define DM_PANNINGWIDTH 0x08000000L
#define DM_PANNINGHEIGHT 0x10000000L


#define DM_DISPLAYFIXEDOUTPUT 0x20000000L



/* orientation selections */
#define DMORIENT_PORTRAIT 1
#define DMORIENT_LANDSCAPE 2

/* paper selections */
#define DMPAPER_FIRST DMPAPER_LETTER
#define DMPAPER_LETTER 1
#define DMPAPER_LETTERSMALL 2
#define DMPAPER_TABLOID 3
#define DMPAPER_LEDGER 4
#define DMPAPER_LEGAL 5
#define DMPAPER_STATEMENT 6
#define DMPAPER_EXECUTIVE 7
#define DMPAPER_A3 8
#define DMPAPER_A4 9
#define DMPAPER_A4SMALL 10
#define DMPAPER_A5 11
#define DMPAPER_B4 12
#define DMPAPER_B5 13
#define DMPAPER_FOLIO 14
#define DMPAPER_QUARTO 15
#define DMPAPER_10X14 16
#define DMPAPER_11X17 17
#define DMPAPER_NOTE 18
#define DMPAPER_ENV_9 19
#define DMPAPER_ENV_10 20
#define DMPAPER_ENV_11 21
#define DMPAPER_ENV_12 22
#define DMPAPER_ENV_14 23
#define DMPAPER_CSHEET 24
#define DMPAPER_DSHEET 25
#define DMPAPER_ESHEET 26
#define DMPAPER_ENV_DL 27
#define DMPAPER_ENV_C5 28
#define DMPAPER_ENV_C3 29
#define DMPAPER_ENV_C4 30
#define DMPAPER_ENV_C6 31
#define DMPAPER_ENV_C65 32
#define DMPAPER_ENV_B4 33
#define DMPAPER_ENV_B5 34
#define DMPAPER_ENV_B6 35
#define DMPAPER_ENV_ITALY 36
#define DMPAPER_ENV_MONARCH 37
#define DMPAPER_ENV_PERSONAL 38
#define DMPAPER_FANFOLD_US 39
#define DMPAPER_FANFOLD_STD_GERMAN 40
#define DMPAPER_FANFOLD_LGL_GERMAN 41

#define DMPAPER_ISO_B4 42
#define DMPAPER_JAPANESE_POSTCARD 43
#define DMPAPER_9X11 44
#define DMPAPER_10X11 45
#define DMPAPER_15X11 46
#define DMPAPER_ENV_INVITE 47
#define DMPAPER_RESERVED_48 48
#define DMPAPER_RESERVED_49 49
#define DMPAPER_LETTER_EXTRA 50
#define DMPAPER_LEGAL_EXTRA 51
#define DMPAPER_TABLOID_EXTRA 52
#define DMPAPER_A4_EXTRA 53
#define DMPAPER_LETTER_TRANSVERSE 54
#define DMPAPER_A4_TRANSVERSE 55
#define DMPAPER_LETTER_EXTRA_TRANSVERSE 56
#define DMPAPER_A_PLUS 57
#define DMPAPER_B_PLUS 58
#define DMPAPER_LETTER_PLUS 59
#define DMPAPER_A4_PLUS 60
#define DMPAPER_A5_TRANSVERSE 61
#define DMPAPER_B5_TRANSVERSE 62
#define DMPAPER_A3_EXTRA 63
#define DMPAPER_A5_EXTRA 64
#define DMPAPER_B5_EXTRA 65
#define DMPAPER_A2 66
#define DMPAPER_A3_TRANSVERSE 67
#define DMPAPER_A3_EXTRA_TRANSVERSE 68



#define DMPAPER_DBL_JAPANESE_POSTCARD 69
#define DMPAPER_A6 70
#define DMPAPER_JENV_KAKU2 71
#define DMPAPER_JENV_KAKU3 72
#define DMPAPER_JENV_CHOU3 73
#define DMPAPER_JENV_CHOU4 74
#define DMPAPER_LETTER_ROTATED 75
#define DMPAPER_A3_ROTATED 76
#define DMPAPER_A4_ROTATED 77
#define DMPAPER_A5_ROTATED 78
#define DMPAPER_B4_JIS_ROTATED 79
#define DMPAPER_B5_JIS_ROTATED 80
#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81
#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82
#define DMPAPER_A6_ROTATED 83
#define DMPAPER_JENV_KAKU2_ROTATED 84
#define DMPAPER_JENV_KAKU3_ROTATED 85
#define DMPAPER_JENV_CHOU3_ROTATED 86
#define DMPAPER_JENV_CHOU4_ROTATED 87
#define DMPAPER_B6_JIS 88
#define DMPAPER_B6_JIS_ROTATED 89
#define DMPAPER_12X11 90
#define DMPAPER_JENV_YOU4 91
#define DMPAPER_JENV_YOU4_ROTATED 92
#define DMPAPER_P16K 93
#define DMPAPER_P32K 94
#define DMPAPER_P32KBIG 95
#define DMPAPER_PENV_1 96
#define DMPAPER_PENV_2 97
#define DMPAPER_PENV_3 98
#define DMPAPER_PENV_4 99
#define DMPAPER_PENV_5 100
#define DMPAPER_PENV_6 101
#define DMPAPER_PENV_7 102
#define DMPAPER_PENV_8 103
#define DMPAPER_PENV_9 104
#define DMPAPER_PENV_10 105
#define DMPAPER_P16K_ROTATED 106
#define DMPAPER_P32K_ROTATED 107
#define DMPAPER_P32KBIG_ROTATED 108
#define DMPAPER_PENV_1_ROTATED 109
#define DMPAPER_PENV_2_ROTATED 110
#define DMPAPER_PENV_3_ROTATED 111
#define DMPAPER_PENV_4_ROTATED 112
#define DMPAPER_PENV_5_ROTATED 113
#define DMPAPER_PENV_6_ROTATED 114
#define DMPAPER_PENV_7_ROTATED 115
#define DMPAPER_PENV_8_ROTATED 116
#define DMPAPER_PENV_9_ROTATED 117
#define DMPAPER_PENV_10_ROTATED 118



#define DMPAPER_LAST DMPAPER_PENV_10_ROTATED






#define DMPAPER_USER 256

/* bin selections */
#define DMBIN_FIRST DMBIN_UPPER
#define DMBIN_UPPER 1
#define DMBIN_ONLYONE 1
#define DMBIN_LOWER 2
#define DMBIN_MIDDLE 3
#define DMBIN_MANUAL 4
#define DMBIN_ENVELOPE 5
#define DMBIN_ENVMANUAL 6
#define DMBIN_AUTO 7
#define DMBIN_TRACTOR 8
#define DMBIN_SMALLFMT 9
#define DMBIN_LARGEFMT 10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE 14
#define DMBIN_FORMSOURCE 15
#define DMBIN_LAST DMBIN_FORMSOURCE

#define DMBIN_USER 256

/* print qualities */
#define DMRES_DRAFT (-1)
#define DMRES_LOW (-2)
#define DMRES_MEDIUM (-3)
#define DMRES_HIGH (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME 1
#define DMCOLOR_COLOR 2

/* duplex enable */
#define DMDUP_SIMPLEX 1
#define DMDUP_VERTICAL 2
#define DMDUP_HORIZONTAL 3

/* TrueType options */
#define DMTT_BITMAP 1
#define DMTT_DOWNLOAD 2
#define DMTT_SUBDEV 3

#define DMTT_DOWNLOAD_OUTLINE 4


/* Collation selections */
#define DMCOLLATE_FALSE 0
#define DMCOLLATE_TRUE 1


/* DEVMODE dmDisplayOrientation specifiations */
#define DMDO_DEFAULT 0
#define DMDO_90 1
#define DMDO_180 2
#define DMDO_270 3

/* DEVMODE dmDisplayFixedOutput specifiations */
#define DMDFO_DEFAULT 0
#define DMDFO_STRETCH 1
#define DMDFO_CENTER 2


/* DEVMODE dmDisplayFlags flags */

// #define DM_GRAYSCALE            0x00000001 /* This flag is no longer valid */
#define DM_INTERLACED 0x00000002
#define DMDISPLAYFLAGS_TEXTMODE 0x00000004

/* dmNup , multiple logical page per physical page options */
#define DMNUP_SYSTEM 1
#define DMNUP_ONEUP 2


/* ICM methods */
#define DMICMMETHOD_NONE 1
#define DMICMMETHOD_SYSTEM 2
#define DMICMMETHOD_DRIVER 3
#define DMICMMETHOD_DEVICE 4

#define DMICMMETHOD_USER 256

/* ICM Intents */
#define DMICM_SATURATE 1
#define DMICM_CONTRAST 2
#define DMICM_COLORIMETRIC 3
#define DMICM_ABS_COLORIMETRIC 4

#define DMICM_USER 256

/* Media types */

#define DMMEDIA_STANDARD 1
#define DMMEDIA_TRANSPARENCY 2
#define DMMEDIA_GLOSSY 3

#define DMMEDIA_USER 256

/* Dither types */
#define DMDITHER_NONE 1
#define DMDITHER_COARSE 2
#define DMDITHER_FINE 3
#define DMDITHER_LINEART 4
#define DMDITHER_ERRORDIFFUSION 5
#define DMDITHER_RESERVED6 6
#define DMDITHER_RESERVED7 7
#define DMDITHER_RESERVED8 8
#define DMDITHER_RESERVED9 9
#define DMDITHER_GRAYSCALE 10

#define DMDITHER_USER 256


typedef struct _DISPLAY_DEVICEA {
    DWORD cb;
    CHAR DeviceName[32];
    CHAR DeviceString[128];
    DWORD StateFlags;
    CHAR DeviceID[128];
    CHAR DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD cb;
    WCHAR DeviceName[32];
    WCHAR DeviceString[128];
    DWORD StateFlags;
    WCHAR DeviceID[128];
    WCHAR DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;





typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;


#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER 0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE 0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER 0x00000008
#define DISPLAY_DEVICE_VGA_COMPATIBLE 0x00000010

#define DISPLAY_DEVICE_REMOVABLE 0x00000020

#define DISPLAY_DEVICE_MODESPRUNED 0x08000000

#define DISPLAY_DEVICE_REMOTE 0x04000000
#define DISPLAY_DEVICE_DISCONNECT 0x02000000

#define DISPLAY_DEVICE_TS_COMPATIBLE 0x00200000

#define DISPLAY_DEVICE_UNSAFE_MODES_ON 0x00080000


/* Child device state */

#define DISPLAY_DEVICE_ACTIVE 0x00000001
#define DISPLAY_DEVICE_ATTACHED 0x00000002




#define DISPLAYCONFIG_MAXPATH 1024
                                          // Max adapter (16) * Max source (16) *
                                          // Max clone pre source (4)

typedef struct DISPLAYCONFIG_RATIONAL
{
    UINT32 Numerator;
    UINT32 Denominator;
} DISPLAYCONFIG_RATIONAL;

typedef enum
{
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY;

typedef enum
{
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_SCANLINE_ORDERING;

typedef struct DISPLAYCONFIG_2DREGION
{
    UINT32 cx;
    UINT32 cy;
} DISPLAYCONFIG_2DREGION;

typedef struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO
{
    UINT64 pixelRate;
    DISPLAYCONFIG_RATIONAL hSyncFreq;
    DISPLAYCONFIG_RATIONAL vSyncFreq;
    DISPLAYCONFIG_2DREGION activeSize;
    DISPLAYCONFIG_2DREGION totalSize;
    UINT32 videoStandard;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
} DISPLAYCONFIG_VIDEO_SIGNAL_INFO;

typedef enum
{
    DISPLAYCONFIG_SCALING_IDENTITY = 1,
    DISPLAYCONFIG_SCALING_CENTERED = 2,
    DISPLAYCONFIG_SCALING_STRETCHED = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
    DISPLAYCONFIG_SCALING_CUSTOM = 5,
    DISPLAYCONFIG_SCALING_PREFERRED = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_SCALING;

typedef enum
{
    DISPLAYCONFIG_ROTATION_IDENTITY = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_ROTATION;

typedef enum
{
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_MODE_INFO_TYPE;

typedef enum
{
    DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = 0xffffffff
} DISPLAYCONFIG_PIXELFORMAT;

typedef struct DISPLAYCONFIG_SOURCE_MODE
{
    UINT32 width;
    UINT32 height;
    DISPLAYCONFIG_PIXELFORMAT pixelFormat;
    POINTL position;
} DISPLAYCONFIG_SOURCE_MODE;

typedef struct DISPLAYCONFIG_TARGET_MODE
{
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo;
} DISPLAYCONFIG_TARGET_MODE;

typedef struct DISPLAYCONFIG_MODE_INFO
{
    DISPLAYCONFIG_MODE_INFO_TYPE infoType;
    UINT32 id;
    LUID adapterId;
    union
    {
        DISPLAYCONFIG_TARGET_MODE targetMode;
        DISPLAYCONFIG_SOURCE_MODE sourceMode;
    };
} DISPLAYCONFIG_MODE_INFO;

#define DISPLAYCONFIG_PATH_MODE_IDX_INVALID 0xffffffff

typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO
{
    LUID adapterId;
    UINT32 id;
    UINT32 modeInfoIdx;
    UINT32 statusFlags;
} DISPLAYCONFIG_PATH_SOURCE_INFO;

//
// Flags for source info structure (from OS to application through QDC)
//

#define DISPLAYCONFIG_SOURCE_IN_USE 0x00000001

typedef struct DISPLAYCONFIG_PATH_TARGET_INFO
{
    LUID adapterId;
    UINT32 id;
    UINT32 modeInfoIdx;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    DISPLAYCONFIG_ROTATION rotation;
    DISPLAYCONFIG_SCALING scaling;
    DISPLAYCONFIG_RATIONAL refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
    BOOL targetAvailable;
    UINT32 statusFlags;
} DISPLAYCONFIG_PATH_TARGET_INFO;

//
// Status flags for target info structure (from OS to application through QDC)
//
#define DISPLAYCONFIG_TARGET_IN_USE 0x00000001
#define DISPLAYCONFIG_TARGET_FORCIBLE 0x00000002
#define DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_BOOT 0x00000004
#define DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_PATH 0x00000008
#define DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_SYSTEM 0x00000010

typedef struct DISPLAYCONFIG_PATH_INFO
{
    DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO targetInfo;
    UINT32 flags;
} DISPLAYCONFIG_PATH_INFO;

//
// Flags for path info structure (from OS to application through QDC)
//

#define DISPLAYCONFIG_PATH_ACTIVE 0x00000001

typedef enum
{
      DISPLAYCONFIG_TOPOLOGY_INTERNAL = 0x00000001,
      DISPLAYCONFIG_TOPOLOGY_CLONE = 0x00000002,
      DISPLAYCONFIG_TOPOLOGY_EXTEND = 0x00000004,
      DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 0x00000008,
      DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_TOPOLOGY_ID;

typedef enum
{
      DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
      DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
      DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
      DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_DEVICE_INFO_TYPE;

typedef struct DISPLAYCONFIG_DEVICE_INFO_HEADER
{
    DISPLAYCONFIG_DEVICE_INFO_TYPE type;
    UINT32 size;
    LUID adapterId;
    UINT32 id;
} DISPLAYCONFIG_DEVICE_INFO_HEADER;

typedef struct DISPLAYCONFIG_SOURCE_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    WCHAR viewGdiDeviceName[32];
} DISPLAYCONFIG_SOURCE_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS
{
    union
    {
        struct
        {
            UINT32 friendlyNameFromEdid : 1;
            UINT32 friendlyNameForced : 1;
            UINT32 edidIdsValid : 1;
            UINT32 reserved : 29;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    UINT16 edidManufactureId;
    UINT16 edidProductCodeId;
    UINT32 connectorInstance;
    WCHAR monitorFriendlyDeviceName[64];
    WCHAR monitorDevicePath[128];
} DISPLAYCONFIG_TARGET_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_PREFERRED_MODE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    UINT32 width;
    UINT32 height;
    DISPLAYCONFIG_TARGET_MODE targetMode;
} DISPLAYCONFIG_TARGET_PREFERRED_MODE;

typedef struct DISPLAYCONFIG_ADAPTER_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    WCHAR adapterDevicePath[128];
} DISPLAYCONFIG_ADAPTER_NAME;

typedef struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    union
    {
        struct
        {
            UINT32 bootPersistenceOn : 1;
            UINT32 reserved : 31;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_SET_TARGET_PERSISTENCE;

//
// Definitions to be used by GetDisplayConfigBufferSizes and QueryDisplayConfig.
//

#define QDC_ALL_PATHS 0x00000001
#define QDC_ONLY_ACTIVE_PATHS 0x00000002
#define QDC_DATABASE_CURRENT 0x00000004

//
// Definitions used by SetDisplayConfig.
//

#define SDC_TOPOLOGY_INTERNAL 0x00000001
#define SDC_TOPOLOGY_CLONE 0x00000002
#define SDC_TOPOLOGY_EXTEND 0x00000004
#define SDC_TOPOLOGY_EXTERNAL 0x00000008
#define SDC_TOPOLOGY_SUPPLIED 0x00000010
#define SDC_USE_DATABASE_CURRENT (SDC_TOPOLOGY_INTERNAL | SDC_TOPOLOGY_CLONE | SDC_TOPOLOGY_EXTEND | SDC_TOPOLOGY_EXTERNAL)

#define SDC_USE_SUPPLIED_DISPLAY_CONFIG 0x00000020
#define SDC_VALIDATE 0x00000040
#define SDC_APPLY 0x00000080
#define SDC_NO_OPTIMIZATION 0x00000100
#define SDC_SAVE_TO_DATABASE 0x00000200
#define SDC_ALLOW_CHANGES 0x00000400
#define SDC_PATH_PERSIST_IF_REQUIRED 0x00000800
#define SDC_FORCE_MODE_ENUMERATION 0x00001000
#define SDC_ALLOW_PATH_ORDER_CHANGES 0x00002000




/* GetRegionData/ExtCreateRegion */

#define RDH_RECTANGLES 1

typedef struct _RGNDATAHEADER {
    DWORD dwSize;
    DWORD iType;
    DWORD nCount;
    DWORD nRgnSize;
    RECT rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER rdh;
    char Buffer[1];
} RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;


/* for GetRandomRgn */
#define SYSRGN 4


typedef struct _ABC {
    int abcA;
    UINT abcB;
    int abcC;
} ABC, *PABC, *NPABC, *LPABC;

typedef struct _ABCFLOAT {
    FLOAT abcfA;
    FLOAT abcfB;
    FLOAT abcfC;
} ABCFLOAT, *PABCFLOAT, *NPABCFLOAT, *LPABCFLOAT;






typedef struct _OUTLINETEXTMETRICA {
    UINT otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
     int otmsCharSlopeRise;
     int otmsCharSlopeRun;
     int otmItalicAngle;
    UINT otmEMSquare;
     int otmAscent;
     int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
     int otmMacAscent;
     int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
     int otmsStrikeoutPosition;
     int otmsUnderscoreSize;
     int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA, *NPOUTLINETEXTMETRICA, *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE otmFiller;
    PANOSE otmPanoseNumber;
    UINT otmfsSelection;
    UINT otmfsType;
     int otmsCharSlopeRise;
     int otmsCharSlopeRun;
     int otmItalicAngle;
    UINT otmEMSquare;
     int otmAscent;
     int otmDescent;
    UINT otmLineGap;
    UINT otmsCapEmHeight;
    UINT otmsXHeight;
    RECT otmrcFontBox;
     int otmMacAscent;
     int otmMacDescent;
    UINT otmMacLineGap;
    UINT otmusMinimumPPEM;
    POINT otmptSubscriptSize;
    POINT otmptSubscriptOffset;
    POINT otmptSuperscriptSize;
    POINT otmptSuperscriptOffset;
    UINT otmsStrikeoutSize;
     int otmsStrikeoutPosition;
     int otmsUnderscoreSize;
     int otmsUnderscorePosition;
    PSTR otmpFamilyName;
    PSTR otmpFaceName;
    PSTR otmpStyleName;
    PSTR otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW, *NPOUTLINETEXTMETRICW, *LPOUTLINETEXTMETRICW;






typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
# 2928 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef struct tagPOLYTEXTA
{
    int x;
    int y;
    UINT n;
    LPCSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int *pdx;
} POLYTEXTA, *PPOLYTEXTA, *NPPOLYTEXTA, *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int x;
    int y;
    UINT n;
    LPCWSTR lpstr;
    UINT uiFlags;
    RECT rcl;
    int *pdx;
} POLYTEXTW, *PPOLYTEXTW, *NPPOLYTEXTW, *LPPOLYTEXTW;






typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;


typedef struct _FIXED {

    WORD fract;
    short value;




} FIXED;


typedef struct _MAT2 {
     FIXED eM11;
     FIXED eM12;
     FIXED eM21;
     FIXED eM22;
} MAT2, *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT gmBlackBoxX;
    UINT gmBlackBoxY;
    POINT gmptGlyphOrigin;
    short gmCellIncX;
    short gmCellIncY;
} GLYPHMETRICS, *LPGLYPHMETRICS;

//  GetGlyphOutline constants

#define GGO_METRICS 0
#define GGO_BITMAP 1
#define GGO_NATIVE 2
#define GGO_BEZIER 3


#define GGO_GRAY2_BITMAP 4
#define GGO_GRAY4_BITMAP 5
#define GGO_GRAY8_BITMAP 6
#define GGO_GLYPH_INDEX 0x0080



#define GGO_UNHINTED 0x0100


#define TT_POLYGON_TYPE 24

#define TT_PRIM_LINE 1
#define TT_PRIM_QSPLINE 2
#define TT_PRIM_CSPLINE 3

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD wType;
    WORD cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD cb;
    DWORD dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, * LPTTPOLYGONHEADER;



#define GCP_DBCS 0x0001
#define GCP_REORDER 0x0002
#define GCP_USEKERNING 0x0008
#define GCP_GLYPHSHAPE 0x0010
#define GCP_LIGATE 0x0020
////#define GCP_GLYPHINDEXING  0x0080
#define GCP_DIACRITIC 0x0100
#define GCP_KASHIDA 0x0400
#define GCP_ERROR 0x8000
#define FLI_MASK 0x103B

#define GCP_JUSTIFY 0x00010000L
////#define GCP_NODIACRITICS   0x00020000L
#define FLI_GLYPHS 0x00040000L
#define GCP_CLASSIN 0x00080000L
#define GCP_MAXEXTENT 0x00100000L
#define GCP_JUSTIFYIN 0x00200000L
#define GCP_DISPLAYZWG 0x00400000L
#define GCP_SYMSWAPOFF 0x00800000L
#define GCP_NUMERICOVERRIDE 0x01000000L
#define GCP_NEUTRALOVERRIDE 0x02000000L
#define GCP_NUMERICSLATIN 0x04000000L
#define GCP_NUMERICSLOCAL 0x08000000L

#define GCPCLASS_LATIN 1
#define GCPCLASS_HEBREW 2
#define GCPCLASS_ARABIC 2
#define GCPCLASS_NEUTRAL 3
#define GCPCLASS_LOCALNUMBER 4
#define GCPCLASS_LATINNUMBER 5
#define GCPCLASS_LATINNUMERICTERMINATOR 6
#define GCPCLASS_LATINNUMERICSEPARATOR 7
#define GCPCLASS_NUMERICSEPARATOR 8
#define GCPCLASS_PREBOUNDLTR 0x80
#define GCPCLASS_PREBOUNDRTL 0x40
#define GCPCLASS_POSTBOUNDLTR 0x20
#define GCPCLASS_POSTBOUNDRTL 0x10

#define GCPGLYPH_LINKBEFORE 0x8000
#define GCPGLYPH_LINKAFTER 0x4000


typedef struct tagGCP_RESULTSA
    {
    DWORD lStructSize;
    LPSTR lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
    } GCP_RESULTSA, * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD lStructSize;
    LPWSTR lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR lpClass;
    LPWSTR lpGlyphs;
    UINT nGlyphs;
    int nMaxFit;
    } GCP_RESULTSW, * LPGCP_RESULTSW;




typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;



typedef struct _RASTERIZER_STATUS {
    short nSize;
    short wFlags;
    short nLanguageID;
} RASTERIZER_STATUS, *LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE 0x0001
#define TT_ENABLED 0x0002

/* Pixel format descriptor */
typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerType;
    BYTE bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR, *LPPIXELFORMATDESCRIPTOR;

/* pixel types */
#define PFD_TYPE_RGBA 0
#define PFD_TYPE_COLORINDEX 1

/* layer types */
#define PFD_MAIN_PLANE 0
#define PFD_OVERLAY_PLANE 1
#define PFD_UNDERLAY_PLANE (-1)

/* PIXELFORMATDESCRIPTOR flags */
#define PFD_DOUBLEBUFFER 0x00000001
#define PFD_STEREO 0x00000002
#define PFD_DRAW_TO_WINDOW 0x00000004
#define PFD_DRAW_TO_BITMAP 0x00000008
#define PFD_SUPPORT_GDI 0x00000010
#define PFD_SUPPORT_OPENGL 0x00000020
#define PFD_GENERIC_FORMAT 0x00000040
#define PFD_NEED_PALETTE 0x00000080
#define PFD_NEED_SYSTEM_PALETTE 0x00000100
#define PFD_SWAP_EXCHANGE 0x00000200
#define PFD_SWAP_COPY 0x00000400
#define PFD_SWAP_LAYER_BUFFERS 0x00000800
#define PFD_GENERIC_ACCELERATED 0x00001000
#define PFD_SUPPORT_DIRECTDRAW 0x00002000
#define PFD_DIRECT3D_ACCELERATED 0x00004000
#define PFD_SUPPORT_COMPOSITION 0x00008000

/* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only */
#define PFD_DEPTH_DONTCARE 0x20000000
#define PFD_DOUBLEBUFFER_DONTCARE 0x40000000
#define PFD_STEREO_DONTCARE 0x80000000



typedef int (* OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM);
typedef int (* OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM);



#define OLDFONTENUMPROC OLDFONTENUMPROCA
# 3201 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef OLDFONTENUMPROCA FONTENUMPROCA;
typedef OLDFONTENUMPROCW FONTENUMPROCW;



typedef FONTENUMPROCA FONTENUMPROC;


typedef int (* GOBJENUMPROC)(LPVOID, LPARAM);
typedef void (* LINEDDAPROC)(int, int, LPARAM);
# 3226 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
 int AddFontResourceA( LPCSTR);
 int AddFontResourceW( LPCWSTR);



#define AddFontResource AddFontResourceA


 BOOL AnimatePalette( HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY * ppe);
 BOOL Arc( HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
 BOOL BitBlt( HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
 BOOL CancelDC( HDC hdc);
 BOOL Chord( HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
 int ChoosePixelFormat( HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd);
 HMETAFILE CloseMetaFile( HDC hdc);
 int CombineRgn( HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode);
 HMETAFILE CopyMetaFileA( HMETAFILE, LPCSTR);
 HMETAFILE CopyMetaFileW( HMETAFILE, LPCWSTR);



#define CopyMetaFile CopyMetaFileA

 HBITMAP CreateBitmap( int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits);
 HBITMAP CreateBitmapIndirect( const BITMAP *pbm);
 HBRUSH CreateBrushIndirect( const LOGBRUSH *plbrush);
 HBITMAP CreateCompatibleBitmap( HDC hdc, int cx, int cy);
 HBITMAP CreateDiscardableBitmap( HDC hdc, int cx, int cy);
 HDC CreateCompatibleDC( HDC hdc);
 HDC CreateDCA( LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA * pdm);
 HDC CreateDCW( LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW * pdm);



#define CreateDC CreateDCA

 HBITMAP CreateDIBitmap( HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage);
 HBRUSH CreateDIBPatternBrush( HGLOBAL h, UINT iUsage);
 HBRUSH CreateDIBPatternBrushPt( const void *lpPackedDIB, UINT iUsage);
 HRGN CreateEllipticRgn( int x1, int y1, int x2, int y2);
 HRGN CreateEllipticRgnIndirect( const RECT *lprect);
 HFONT CreateFontIndirectA( const LOGFONTA *lplf);
 HFONT CreateFontIndirectW( const LOGFONTW *lplf);



#define CreateFontIndirect CreateFontIndirectA

 HFONT CreateFontA( int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
                             DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
                             DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
 HFONT CreateFontW( int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic,
                             DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision,
                             DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);



#define CreateFont CreateFontA


 HBRUSH CreateHatchBrush( int iHatch, COLORREF color);
 HDC CreateICA( LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA * pdm);
 HDC CreateICW( LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW * pdm);



#define CreateIC CreateICA

 HDC CreateMetaFileA( LPCSTR pszFile);
 HDC CreateMetaFileW( LPCWSTR pszFile);



#define CreateMetaFile CreateMetaFileA

 HPALETTE CreatePalette( const LOGPALETTE * plpal);
 HPEN CreatePen( int iStyle, int cWidth, COLORREF color);
 HPEN CreatePenIndirect( const LOGPEN *plpen);
 HRGN CreatePolyPolygonRgn( const POINT *pptl,
                                                const INT *pc,
                                                int cPoly,
                                                int iMode);
 HBRUSH CreatePatternBrush( HBITMAP hbm);
 HRGN CreateRectRgn( int x1, int y1, int x2, int y2);
 HRGN CreateRectRgnIndirect( const RECT *lprect);
 HRGN CreateRoundRectRgn( int x1, int y1, int x2, int y2, int w, int h);
 BOOL CreateScalableFontResourceA( DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath);
 BOOL CreateScalableFontResourceW( DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath);



#define CreateScalableFontResource CreateScalableFontResourceA

 HBRUSH CreateSolidBrush( COLORREF color);

 BOOL DeleteDC( HDC hdc);
 BOOL DeleteMetaFile( HMETAFILE hmf);
 BOOL DeleteObject( HGDIOBJ ho);
 int DescribePixelFormat( HDC hdc,
                                            int iPixelFormat,
                                            UINT nBytes,
                                            LPPIXELFORMATDESCRIPTOR ppfd);

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()

 * functions for Win 3.1 compatibility

 */
# 3333 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
typedef UINT (* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD (* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

/* mode selections for the device mode function */
#define DM_UPDATE 1
#define DM_COPY 2
#define DM_PROMPT 4
#define DM_MODIFY 8

#define DM_IN_BUFFER DM_MODIFY
#define DM_IN_PROMPT DM_PROMPT
#define DM_OUT_BUFFER DM_COPY
#define DM_OUT_DEFAULT DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS 1
#define DC_PAPERS 2
#define DC_PAPERSIZE 3
#define DC_MINEXTENT 4
#define DC_MAXEXTENT 5
#define DC_BINS 6
#define DC_DUPLEX 7
#define DC_SIZE 8
#define DC_EXTRA 9
#define DC_VERSION 10
#define DC_DRIVER 11
#define DC_BINNAMES 12
#define DC_ENUMRESOLUTIONS 13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE 15
#define DC_PAPERNAMES 16
#define DC_ORIENTATION 17
#define DC_COPIES 18

#define DC_BINADJUST 19
#define DC_EMF_COMPLIANT 20
#define DC_DATATYPE_PRODUCED 21
#define DC_COLLATE 22
#define DC_MANUFACTURER 23
#define DC_MODEL 24



#define DC_PERSONALITY 25
#define DC_PRINTRATE 26
#define DC_PRINTRATEUNIT 27
#define PRINTRATEUNIT_PPM 1
#define PRINTRATEUNIT_CPS 2
#define PRINTRATEUNIT_LPM 3
#define PRINTRATEUNIT_IPM 4
#define DC_PRINTERMEM 28
#define DC_MEDIAREADY 29
#define DC_STAPLE 30
#define DC_PRINTRATEPPM 31
#define DC_COLORDEVICE 32
#define DC_NUP 33

#define DC_MEDIATYPENAMES 34
#define DC_MEDIATYPES 35



/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP 0x0000001L
#define DCTT_DOWNLOAD 0x0000002L
#define DCTT_SUBDEV 0x0000004L

#define DCTT_DOWNLOAD_OUTLINE 0x0000008L

/* return values for DC_BINADJUST */
#define DCBA_FACEUPNONE 0x0000
#define DCBA_FACEUPCENTER 0x0001
#define DCBA_FACEUPLEFT 0x0002
#define DCBA_FACEUPRIGHT 0x0003
#define DCBA_FACEDOWNNONE 0x0100
#define DCBA_FACEDOWNCENTER 0x0101
#define DCBA_FACEDOWNLEFT 0x0102
#define DCBA_FACEDOWNRIGHT 0x0103



int

DeviceCapabilitiesA(
    LPCSTR pDevice,
    LPCSTR pPort,
    WORD fwCapability,
    LPSTR pOutput,
    const DEVMODEA *pDevMode
    );

int

DeviceCapabilitiesW(
    LPCWSTR pDevice,
    LPCWSTR pPort,
    WORD fwCapability,
    LPWSTR pOutput,
    const DEVMODEW *pDevMode
    );



#define DeviceCapabilities DeviceCapabilitiesA


 int DrawEscape( HDC hdc,
                                    int iEscape,
                                    int cjIn,
                                    LPCSTR lpIn);

 BOOL Ellipse( HDC hdc, int left, int top, int right, int bottom);


 int EnumFontFamiliesExA( HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags);
 int EnumFontFamiliesExW( HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags);



#define EnumFontFamiliesEx EnumFontFamiliesExA



 int EnumFontFamiliesA( HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
 int EnumFontFamiliesW( HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);



#define EnumFontFamilies EnumFontFamiliesA

 int EnumFontsA( HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
 int EnumFontsW( HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);



#define EnumFonts EnumFontsA



 int EnumObjects( HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam);





 BOOL EqualRgn( HRGN hrgn1, HRGN hrgn2);
 int Escape( HDC hdc,
                                int iEscape,
                                int cjIn,
                                LPCSTR pvIn,
                                LPVOID pvOut);
 int ExtEscape( HDC hdc,
                                    int iEscape,
                                    int cjInput,
                                    LPCSTR lpInData,
                                    int cjOutput,
                                    LPSTR lpOutData);
 int ExcludeClipRect( HDC hdc, int left, int top, int right, int bottom);
 HRGN ExtCreateRegion( const XFORM * lpx, DWORD nCount, const RGNDATA * lpData);
 BOOL ExtFloodFill( HDC hdc, int x, int y, COLORREF color, UINT type);
 BOOL FillRgn( HDC hdc, HRGN hrgn, HBRUSH hbr);
 BOOL FloodFill( HDC hdc, int x, int y, COLORREF color);
 BOOL FrameRgn( HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h);
 int GetROP2( HDC hdc);
 BOOL GetAspectRatioFilterEx( HDC hdc, LPSIZE lpsize);
 COLORREF GetBkColor( HDC hdc);


 COLORREF GetDCBrushColor( HDC hdc);
 COLORREF GetDCPenColor( HDC hdc);



int

GetBkMode(
    HDC hdc
    );


LONG

GetBitmapBits(
    HBITMAP hbit,
    LONG cb,
    LPVOID lpvBits
    );

 BOOL GetBitmapDimensionEx( HBITMAP hbit, LPSIZE lpsize);
 UINT GetBoundsRect( HDC hdc, LPRECT lprect, UINT flags);

 BOOL GetBrushOrgEx( HDC hdc, LPPOINT lppt);

 BOOL GetCharWidthA( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
 BOOL GetCharWidthW( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);



#define GetCharWidth GetCharWidthA

 BOOL GetCharWidth32A( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
 BOOL GetCharWidth32W( HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);



#define GetCharWidth32 GetCharWidth32A

 BOOL GetCharWidthFloatA( HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
 BOOL GetCharWidthFloatW( HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);



#define GetCharWidthFloat GetCharWidthFloatA


 BOOL GetCharABCWidthsA( HDC hdc,
                                            UINT wFirst,
                                            UINT wLast,
                                            LPABC lpABC);
 BOOL GetCharABCWidthsW( HDC hdc,
                                            UINT wFirst,
                                            UINT wLast,
                                            LPABC lpABC);



#define GetCharABCWidths GetCharABCWidthsA


 BOOL GetCharABCWidthsFloatA( HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
 BOOL GetCharABCWidthsFloatW( HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);



#define GetCharABCWidthsFloat GetCharABCWidthsFloatA

 int GetClipBox( HDC hdc, LPRECT lprect);
 int GetClipRgn( HDC hdc, HRGN hrgn);
 int GetMetaRgn( HDC hdc, HRGN hrgn);
 HGDIOBJ GetCurrentObject( HDC hdc, UINT type);
 BOOL GetCurrentPositionEx( HDC hdc, LPPOINT lppt);
 int GetDeviceCaps( HDC hdc, int index);
 int GetDIBits( HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage); // SAL actual size of lpbmi is computed from structure elements


 DWORD GetFontData ( HDC hdc,
                                        DWORD dwTable,
                                        DWORD dwOffset,
                                        PVOID pvBuffer,
                                        DWORD cjBuffer
                                        );

 DWORD GetGlyphOutlineA( HDC hdc,
                                            UINT uChar,
                                            UINT fuFormat,
                                            LPGLYPHMETRICS lpgm,
                                            DWORD cjBuffer,
                                            LPVOID pvBuffer,
                                            const MAT2 *lpmat2
                                        );
 DWORD GetGlyphOutlineW( HDC hdc,
                                            UINT uChar,
                                            UINT fuFormat,
                                            LPGLYPHMETRICS lpgm,
                                            DWORD cjBuffer,
                                            LPVOID pvBuffer,
                                            const MAT2 *lpmat2
                                        );



#define GetGlyphOutline GetGlyphOutlineA


 int GetGraphicsMode( HDC hdc);
 int GetMapMode( HDC hdc);
 UINT GetMetaFileBitsEx( HMETAFILE hMF, UINT cbBuffer, LPVOID lpData);
 HMETAFILE GetMetaFileA( LPCSTR lpName);
 HMETAFILE GetMetaFileW( LPCWSTR lpName);



#define GetMetaFile GetMetaFileA

 COLORREF GetNearestColor( HDC hdc, COLORREF color);
 UINT GetNearestPaletteIndex( HPALETTE h, COLORREF color);
 DWORD GetObjectType( HGDIOBJ h);



 UINT GetOutlineTextMetricsA( HDC hdc,
                                                UINT cjCopy,
                                                LPOUTLINETEXTMETRICA potm);
 UINT GetOutlineTextMetricsW( HDC hdc,
                                                UINT cjCopy,
                                                LPOUTLINETEXTMETRICW potm);



#define GetOutlineTextMetrics GetOutlineTextMetricsA





 UINT GetPaletteEntries( HPALETTE hpal,
                                            UINT iStart,
                                            UINT cEntries,
                                            LPPALETTEENTRY pPalEntries);
 COLORREF GetPixel( HDC hdc, int x, int y);
 int GetPixelFormat( HDC hdc);
 int GetPolyFillMode( HDC hdc);
 BOOL GetRasterizerCaps( LPRASTERIZER_STATUS lpraststat,
                                            UINT cjBytes);

 int GetRandomRgn ( HDC hdc, HRGN hrgn, INT i);
 DWORD GetRegionData( HRGN hrgn,
                                        DWORD nCount,
                                        LPRGNDATA lpRgnData);
 int GetRgnBox( HRGN hrgn, LPRECT lprc);
 HGDIOBJ GetStockObject( int i);
 int GetStretchBltMode( HDC hdc);

UINT

GetSystemPaletteEntries(
    HDC hdc,
    UINT iStart,
    UINT cEntries,
    LPPALETTEENTRY pPalEntries
    );

 UINT GetSystemPaletteUse( HDC hdc);
 int GetTextCharacterExtra( HDC hdc);
 UINT GetTextAlign( HDC hdc);
 COLORREF GetTextColor( HDC hdc);


BOOL

GetTextExtentPointA(
    HDC hdc,
    LPCSTR lpString,
    int c,
    LPSIZE lpsz
    );

BOOL

GetTextExtentPointW(
    HDC hdc,
    LPCWSTR lpString,
    int c,
    LPSIZE lpsz
    );



#define GetTextExtentPoint GetTextExtentPointA



BOOL

GetTextExtentPoint32A(
    HDC hdc,
    LPCSTR lpString,
    int c,
    LPSIZE psizl
    );

BOOL

GetTextExtentPoint32W(
    HDC hdc,
    LPCWSTR lpString,
    int c,
    LPSIZE psizl
    );



#define GetTextExtentPoint32 GetTextExtentPoint32A



BOOL

GetTextExtentExPointA(
    HDC hdc,
    LPCSTR lpszString,
    int cchString,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT lpnDx,
    LPSIZE lpSize
    );

BOOL

GetTextExtentExPointW(
    HDC hdc,
    LPCWSTR lpszString,
    int cchString,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT lpnDx,
    LPSIZE lpSize
    );



#define GetTextExtentExPoint GetTextExtentExPointA



 int GetTextCharset( HDC hdc);
 int GetTextCharsetInfo( HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
 BOOL TranslateCharsetInfo( DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
 DWORD GetFontLanguageInfo( HDC hdc);
 DWORD GetCharacterPlacementA( HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags);
 DWORD GetCharacterPlacementW( HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags);



#define GetCharacterPlacement GetCharacterPlacementA





typedef struct tagWCRANGE
{
    WCHAR wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;


typedef struct tagGLYPHSET
{
    DWORD cbThis;
    DWORD flAccel;
    DWORD cGlyphsSupported;
    DWORD cRanges;
    WCRANGE ranges[1];
} GLYPHSET, *PGLYPHSET, *LPGLYPHSET;

/* flAccel flags for the GLYPHSET structure above */

#define GS_8BIT_INDICES 0x00000001

/* flags for GetGlyphIndices */

#define GGI_MARK_NONEXISTING_GLYPHS 0X0001

 DWORD GetFontUnicodeRanges( HDC hdc, LPGLYPHSET lpgs);
 DWORD GetGlyphIndicesA( HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl);
 DWORD GetGlyphIndicesW( HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl);



#define GetGlyphIndices GetGlyphIndicesA

 BOOL GetTextExtentPointI( HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize);
 BOOL GetTextExtentExPointI ( HDC hdc,
                                                LPWORD lpwszString,
                                                int cwchString,
                                                int nMaxExtent,
                                                LPINT lpnFit,
                                                LPINT lpnDx,
                                                LPSIZE lpSize
                                                );

 BOOL GetCharWidthI( HDC hdc,
                                        UINT giFirst,
                                        UINT cgi,
                                        LPWORD pgi,
                                        LPINT piWidths
                                        );

 BOOL GetCharABCWidthsI( HDC hdc,
                                            UINT giFirst,
                                            UINT cgi,
                                            LPWORD pgi,
                                            LPABC pabc
                                        );


#define STAMP_DESIGNVECTOR (0x8000000 + 'd' + ('v' << 8))
#define STAMP_AXESLIST (0x8000000 + 'a' + ('l' << 8))
#define MM_MAX_NUMAXES 16



typedef struct tagDESIGNVECTOR
{
    DWORD dvReserved;
    DWORD dvNumAxes;
    LONG dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR;

 int AddFontResourceExA( LPCSTR name, DWORD fl, PVOID res);
 int AddFontResourceExW( LPCWSTR name, DWORD fl, PVOID res);



#define AddFontResourceEx AddFontResourceExA

 BOOL RemoveFontResourceExA( LPCSTR name, DWORD fl, PVOID pdv);
 BOOL RemoveFontResourceExW( LPCWSTR name, DWORD fl, PVOID pdv);



#define RemoveFontResourceEx RemoveFontResourceExA

 HANDLE AddFontMemResourceEx( PVOID pFileView,
                                                DWORD cjSize,
                                                PVOID pvResrved,
                                                DWORD* pNumFonts);

 BOOL RemoveFontMemResourceEx( HANDLE h);
#define FR_PRIVATE 0x10
#define FR_NOT_ENUM 0x20

// The actual size of the DESIGNVECTOR and ENUMLOGFONTEXDV structures
// is determined by dvNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed

#define MM_MAX_AXES_NAMELEN 16

typedef struct tagAXISINFOA
{
    LONG axMinValue;
    LONG axMaxValue;
    BYTE axAxisName[16];
} AXISINFOA, *PAXISINFOA, *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG axMinValue;
    LONG axMaxValue;
    WCHAR axAxisName[16];
} AXISINFOW, *PAXISINFOW, *LPAXISINFOW;





typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;


typedef struct tagAXESLISTA
{
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOA axlAxisInfo[16];
} AXESLISTA, *PAXESLISTA, *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD axlReserved;
    DWORD axlNumAxes;
    AXISINFOW axlAxisInfo[16];
} AXESLISTW, *PAXESLISTW, *LPAXESLISTW;





typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;


// The actual size of the AXESLIST and ENUMTEXTMETRIC structure is
// determined by axlNumAxes,
// MM_MAX_NUMAXES only detemines the maximal size allowed

typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, *LPENUMLOGFONTEXDVW;





typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;


 HFONT CreateFontIndirectExA( const ENUMLOGFONTEXDVA *);
 HFONT CreateFontIndirectExW( const ENUMLOGFONTEXDVW *);



#define CreateFontIndirectEx CreateFontIndirectExA



typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA, *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW, *LPENUMTEXTMETRICW;





typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;





 BOOL GetViewportExtEx( HDC hdc, LPSIZE lpsize);
 BOOL GetViewportOrgEx( HDC hdc, LPPOINT lppoint);
 BOOL GetWindowExtEx( HDC hdc, LPSIZE lpsize);
 BOOL GetWindowOrgEx( HDC hdc, LPPOINT lppoint);

 int IntersectClipRect( HDC hdc, int left, int top, int right, int bottom);
 BOOL InvertRgn( HDC hdc, HRGN hrgn);
 BOOL LineDDA( int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data);
 BOOL LineTo( HDC hdc, int x, int y);
 BOOL MaskBlt( HDC hdcDest, int xDest, int yDest, int width, int height,
              HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop);
 BOOL PlgBlt( HDC hdcDest, const POINT * lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width,
                     int height, HBITMAP hbmMask, int xMask, int yMask);

 int OffsetClipRgn( HDC hdc, int x, int y);
 int OffsetRgn( HRGN hrgn, int x, int y);
 BOOL PatBlt( HDC hdc, int x, int y, int w, int h, DWORD rop);
 BOOL Pie( HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
 BOOL PlayMetaFile( HDC hdc, HMETAFILE hmf);
 BOOL PaintRgn( HDC hdc, HRGN hrgn);
 BOOL PolyPolygon( HDC hdc, const POINT *apt, const INT *asz, int csz);
 BOOL PtInRegion( HRGN hrgn, int x, int y);
 BOOL PtVisible( HDC hdc, int x, int y);
 BOOL RectInRegion( HRGN hrgn, const RECT * lprect);
 BOOL RectVisible( HDC hdc, const RECT * lprect);
 BOOL Rectangle( HDC hdc, int left, int top, int right, int bottom);
 BOOL RestoreDC( HDC hdc, int nSavedDC);
 HDC ResetDCA( HDC hdc, const DEVMODEA * lpdm);
 HDC ResetDCW( HDC hdc, const DEVMODEW * lpdm);



#define ResetDC ResetDCA

 UINT RealizePalette( HDC hdc);
 BOOL RemoveFontResourceA( LPCSTR lpFileName);
 BOOL RemoveFontResourceW( LPCWSTR lpFileName);



#define RemoveFontResource RemoveFontResourceA

 BOOL RoundRect( HDC hdc, int left, int top, int right, int bottom, int width, int height);
 BOOL ResizePalette( HPALETTE hpal, UINT n);

 int SaveDC( HDC hdc);
 int SelectClipRgn( HDC hdc, HRGN hrgn);
 int ExtSelectClipRgn( HDC hdc, HRGN hrgn, int mode);
 int SetMetaRgn( HDC hdc);
 HGDIOBJ SelectObject( HDC hdc, HGDIOBJ h);
 HPALETTE SelectPalette( HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
 COLORREF SetBkColor( HDC hdc, COLORREF color);


 COLORREF SetDCBrushColor( HDC hdc, COLORREF color);
 COLORREF SetDCPenColor( HDC hdc, COLORREF color);


 int SetBkMode( HDC hdc, int mode);


LONG
SetBitmapBits(
    HBITMAP hbm,
    DWORD cb,
    const void *pvBits);

 UINT SetBoundsRect( HDC hdc, const RECT * lprect, UINT flags);
 int SetDIBits( HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO * lpbmi, UINT ColorUse);
 int SetDIBitsToDevice( HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc,
        int ySrc, UINT StartScan, UINT cLines, const void * lpvBits, const BITMAPINFO * lpbmi, UINT ColorUse);
 DWORD SetMapperFlags( HDC hdc, DWORD flags);
 int SetGraphicsMode( HDC hdc, int iMode);
 int SetMapMode( HDC hdc, int iMode);


 DWORD SetLayout( HDC hdc, DWORD l);
 DWORD GetLayout( HDC hdc);


 HMETAFILE SetMetaFileBitsEx( UINT cbBuffer, const BYTE *lpData);
 UINT SetPaletteEntries( HPALETTE hpal,
                                            UINT iStart,
                                            UINT cEntries,
                                            const PALETTEENTRY *pPalEntries);
 COLORREF SetPixel( HDC hdc, int x, int y, COLORREF color);
 BOOL SetPixelV( HDC hdc, int x, int y, COLORREF color);
 BOOL SetPixelFormat( HDC hdc, int format, const PIXELFORMATDESCRIPTOR * ppfd);
 int SetPolyFillMode( HDC hdc, int mode);
 BOOL StretchBlt( HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
 BOOL SetRectRgn( HRGN hrgn, int left, int top, int right, int bottom);
 int StretchDIBits( HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight,
        const void * lpBits, const BITMAPINFO * lpbmi, UINT iUsage, DWORD rop);
 int SetROP2( HDC hdc, int rop2);
 int SetStretchBltMode( HDC hdc, int mode);
 UINT SetSystemPaletteUse( HDC hdc, UINT use);
 int SetTextCharacterExtra( HDC hdc, int extra);
 COLORREF SetTextColor( HDC hdc, COLORREF color);
 UINT SetTextAlign( HDC hdc, UINT align);
 BOOL SetTextJustification( HDC hdc, int extra, int count);
 BOOL UpdateColors( HDC hdc);
# 4098 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
//
// image blt
//

typedef USHORT COLOR16;

typedef struct _TRIVERTEX
{
    LONG x;
    LONG y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;

typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;

typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;

typedef struct _BLENDFUNCTION
{
    BYTE BlendOp;
    BYTE BlendFlags;
    BYTE SourceConstantAlpha;
    BYTE AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;


//
// currentlly defined blend function
//

#define AC_SRC_OVER 0x00

//
// alpha format flags
//

#define AC_SRC_ALPHA 0x01

 BOOL AlphaBlend(
    HDC hdcDest,
    int xoriginDest,
    int yoriginDest,
    int wDest,
    int hDest,
    HDC hdcSrc,
    int xoriginSrc,
    int yoriginSrc,
    int wSrc,
    int hSrc,
    BLENDFUNCTION ftn);

 BOOL TransparentBlt(
    HDC hdcDest,
    int xoriginDest,
    int yoriginDest,
    int wDest,
    int hDest,
    HDC hdcSrc,
    int xoriginSrc,
    int yoriginSrc,
    int wSrc,
    int hSrc,
    UINT crTransparent);


//
// gradient drawing modes
//

#define GRADIENT_FILL_RECT_H 0x00000000
#define GRADIENT_FILL_RECT_V 0x00000001
#define GRADIENT_FILL_TRIANGLE 0x00000002
#define GRADIENT_FILL_OP_FLAG 0x000000ff


BOOL

GradientFill(
    HDC hdc,
    PTRIVERTEX pVertex,
    ULONG nVertex,
    PVOID pMesh,
    ULONG nMesh,
    ULONG ulMode
    );






 BOOL GdiAlphaBlend( HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);

 BOOL GdiTransparentBlt( HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc,
                                           int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);

 BOOL GdiGradientFill( HDC hdc,
                                        PTRIVERTEX pVertex,
                                        ULONG nVertex,
                                        PVOID pMesh,
                                        ULONG nCount,
                                        ULONG ulMode);







 BOOL PlayMetaFileRecord( HDC hdc,
                                            LPHANDLETABLE lpHandleTable,
                                            LPMETARECORD lpMR,
                                            UINT noObjs);

typedef int (* MFENUMPROC)( HDC hdc, HANDLETABLE * lpht, METARECORD * lpMR, int nObj, LPARAM param);
 BOOL EnumMetaFile( HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param);

typedef int (* ENHMFENUMPROC)( HDC hdc, HANDLETABLE * lpht, const ENHMETARECORD * lpmr, int nHandles, LPARAM data);

// Enhanced Metafile Function Declarations

 HENHMETAFILE CloseEnhMetaFile( HDC hdc);
 HENHMETAFILE CopyEnhMetaFileA( HENHMETAFILE hEnh, LPCSTR lpFileName);
 HENHMETAFILE CopyEnhMetaFileW( HENHMETAFILE hEnh, LPCWSTR lpFileName);



#define CopyEnhMetaFile CopyEnhMetaFileA

 HDC CreateEnhMetaFileA( HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc);
 HDC CreateEnhMetaFileW( HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc);



#define CreateEnhMetaFile CreateEnhMetaFileA

 BOOL DeleteEnhMetaFile( HENHMETAFILE hmf);
 BOOL EnumEnhMetaFile( HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc,
                                        LPVOID param, const RECT * lpRect);
 HENHMETAFILE GetEnhMetaFileA( LPCSTR lpName);
 HENHMETAFILE GetEnhMetaFileW( LPCWSTR lpName);



#define GetEnhMetaFile GetEnhMetaFileA

 UINT GetEnhMetaFileBits( HENHMETAFILE hEMF,
                                            UINT nSize,
                                            LPBYTE lpData);
 UINT GetEnhMetaFileDescriptionA( HENHMETAFILE hemf,
                                                    UINT cchBuffer,
                                                    LPSTR lpDescription);
 UINT GetEnhMetaFileDescriptionW( HENHMETAFILE hemf,
                                                    UINT cchBuffer,
                                                    LPWSTR lpDescription);



#define GetEnhMetaFileDescription GetEnhMetaFileDescriptionA

 UINT GetEnhMetaFileHeader( HENHMETAFILE hemf,
                                                UINT nSize,
                                                LPENHMETAHEADER lpEnhMetaHeader);
 UINT GetEnhMetaFilePaletteEntries( HENHMETAFILE hemf,
                                                    UINT nNumEntries,
                                                    LPPALETTEENTRY lpPaletteEntries);

 UINT GetEnhMetaFilePixelFormat( HENHMETAFILE hemf,
                                                    UINT cbBuffer,
                                                    PIXELFORMATDESCRIPTOR *ppfd);
 UINT GetWinMetaFileBits( HENHMETAFILE hemf,
                                            UINT cbData16,
                                            LPBYTE pData16,
                                            INT iMapMode,
                                            HDC hdcRef);
 BOOL PlayEnhMetaFile( HDC hdc, HENHMETAFILE hmf, const RECT * lprect);
 BOOL PlayEnhMetaFileRecord( HDC hdc,
                                                LPHANDLETABLE pht,
                                                const ENHMETARECORD *pmr,
                                                UINT cht);

 HENHMETAFILE SetEnhMetaFileBits( UINT nSize,
                                                    const BYTE * pb);

 HENHMETAFILE SetWinMetaFileBits( UINT nSize,
                                                    const BYTE *lpMeta16Data,
                                                    HDC hdcRef,
                                                    const METAFILEPICT *lpMFP);
 BOOL GdiComment( HDC hdc, UINT nSize, const BYTE *lpData);





 BOOL GetTextMetricsA( HDC hdc, LPTEXTMETRICA lptm);
 BOOL GetTextMetricsW( HDC hdc, LPTEXTMETRICW lptm);



#define GetTextMetrics GetTextMetricsA
# 4334 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
/* new GDI */

typedef struct tagDIBSECTION {
    BITMAP dsBm;
    BITMAPINFOHEADER dsBmih;
    DWORD dsBitfields[3];
    HANDLE dshSection;
    DWORD dsOffset;
} DIBSECTION, *LPDIBSECTION, *PDIBSECTION;


 BOOL AngleArc( HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle);
 BOOL PolyPolyline( HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz);
 BOOL GetWorldTransform( HDC hdc, LPXFORM lpxf);
 BOOL SetWorldTransform( HDC hdc, const XFORM * lpxf);
 BOOL ModifyWorldTransform( HDC hdc, const XFORM * lpxf, DWORD mode);
 BOOL CombineTransform( LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2);
 HBITMAP CreateDIBSection( HDC hdc, const BITMAPINFO *lpbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);

 UINT GetDIBColorTable( HDC hdc,
                                        UINT iStart,
                                        UINT cEntries,
                                        RGBQUAD *prgbq);
 UINT SetDIBColorTable( HDC hdc,
                                        UINT iStart,
                                        UINT cEntries,
                                        const RGBQUAD *prgbq);

/* Flags value for COLORADJUSTMENT */
#define CA_NEGATIVE 0x0001
#define CA_LOG_FILTER 0x0002

/* IlluminantIndex values */
#define ILLUMINANT_DEVICE_DEFAULT 0
#define ILLUMINANT_A 1
#define ILLUMINANT_B 2
#define ILLUMINANT_C 3
#define ILLUMINANT_D50 4
#define ILLUMINANT_D55 5
#define ILLUMINANT_D65 6
#define ILLUMINANT_D75 7
#define ILLUMINANT_F2 8
#define ILLUMINANT_MAX_INDEX ILLUMINANT_F2

#define ILLUMINANT_TUNGSTEN ILLUMINANT_A
#define ILLUMINANT_DAYLIGHT ILLUMINANT_C
#define ILLUMINANT_FLUORESCENT ILLUMINANT_F2
#define ILLUMINANT_NTSC ILLUMINANT_C

/* Min and max for RedGamma, GreenGamma, BlueGamma */
#define RGB_GAMMA_MIN (WORD)02500
#define RGB_GAMMA_MAX (WORD)65000

/* Min and max for ReferenceBlack and ReferenceWhite */
#define REFERENCE_WHITE_MIN (WORD)6000
#define REFERENCE_WHITE_MAX (WORD)10000
#define REFERENCE_BLACK_MIN (WORD)0
#define REFERENCE_BLACK_MAX (WORD)4000

/* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint */
#define COLOR_ADJ_MIN (SHORT)-100
#define COLOR_ADJ_MAX (SHORT)100

typedef struct tagCOLORADJUSTMENT {
    WORD caSize;
    WORD caFlags;
    WORD caIlluminantIndex;
    WORD caRedGamma;
    WORD caGreenGamma;
    WORD caBlueGamma;
    WORD caReferenceBlack;
    WORD caReferenceWhite;
    SHORT caContrast;
    SHORT caBrightness;
    SHORT caColorfulness;
    SHORT caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT, *LPCOLORADJUSTMENT;

 BOOL SetColorAdjustment( HDC hdc, const COLORADJUSTMENT *lpca);
 BOOL GetColorAdjustment( HDC hdc, LPCOLORADJUSTMENT lpca);
 HPALETTE CreateHalftonePalette( HDC hdc);


typedef BOOL (* ABORTPROC)( HDC, int);




typedef struct _DOCINFOA {
    int cbSize;
    LPCSTR lpszDocName;
    LPCSTR lpszOutput;

    LPCSTR lpszDatatype;
    DWORD fwType;

} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int cbSize;
    LPCWSTR lpszDocName;
    LPCWSTR lpszOutput;

    LPCWSTR lpszDatatype;
    DWORD fwType;

} DOCINFOW, *LPDOCINFOW;




typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;



#define DI_APPBANDING 0x00000001
#define DI_ROPS_READ_DESTINATION 0x00000002


 int StartDocA( HDC hdc, const DOCINFOA *lpdi);
 int StartDocW( HDC hdc, const DOCINFOW *lpdi);



#define StartDoc StartDocA

 int EndDoc( HDC hdc);
 int StartPage( HDC hdc);
 int EndPage( HDC hdc);
 int AbortDoc( HDC hdc);
 int SetAbortProc( HDC hdc, ABORTPROC proc);

 BOOL AbortPath( HDC hdc);
 BOOL ArcTo( HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
 BOOL BeginPath( HDC hdc);
 BOOL CloseFigure( HDC hdc);
 BOOL EndPath( HDC hdc);
 BOOL FillPath( HDC hdc);
 BOOL FlattenPath( HDC hdc);
 int GetPath( HDC hdc, LPPOINT apt, LPBYTE aj, int cpt);
 HRGN PathToRegion( HDC hdc);
 BOOL PolyDraw( HDC hdc, const POINT * apt, const BYTE * aj, int cpt);
 BOOL SelectClipPath( HDC hdc, int mode);
 int SetArcDirection( HDC hdc, int dir);
 BOOL SetMiterLimit( HDC hdc, FLOAT limit, PFLOAT old);
 BOOL StrokeAndFillPath( HDC hdc);
 BOOL StrokePath( HDC hdc);
 BOOL WidenPath( HDC hdc);
 HPEN ExtCreatePen( DWORD iPenStyle,
                                    DWORD cWidth,
                                    const LOGBRUSH *plbrush,
                                    DWORD cStyle,
                                    const DWORD *pstyle);
 BOOL GetMiterLimit( HDC hdc, PFLOAT plimit);
 int GetArcDirection( HDC hdc);

 int GetObjectA( HANDLE h, int c, LPVOID pv);
 int GetObjectW( HANDLE h, int c, LPVOID pv);



#define GetObject GetObjectA
# 4520 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wingdi.h"
 BOOL MoveToEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL TextOutA( HDC hdc, int x, int y, LPCSTR lpString, int c);
 BOOL TextOutW( HDC hdc, int x, int y, LPCWSTR lpString, int c);



#define TextOut TextOutA

 BOOL ExtTextOutA( HDC hdc, int x, int y, UINT options, const RECT * lprect, LPCSTR lpString, UINT c, const INT * lpDx);
 BOOL ExtTextOutW( HDC hdc, int x, int y, UINT options, const RECT * lprect, LPCWSTR lpString, UINT c, const INT * lpDx);



#define ExtTextOut ExtTextOutA

 BOOL PolyTextOutA( HDC hdc, const POLYTEXTA * ppt, int nstrings);
 BOOL PolyTextOutW( HDC hdc, const POLYTEXTW * ppt, int nstrings);



#define PolyTextOut PolyTextOutA


 HRGN CreatePolygonRgn( const POINT *pptl,
                                            int cPoint,
                                            int iMode);
 BOOL DPtoLP( HDC hdc, LPPOINT lppt, int c);
 BOOL LPtoDP( HDC hdc, LPPOINT lppt, int c);
 BOOL Polygon( HDC hdc, const POINT *apt, int cpt);
 BOOL Polyline( HDC hdc, const POINT *apt, int cpt);

 BOOL PolyBezier( HDC hdc, const POINT * apt, DWORD cpt);
 BOOL PolyBezierTo( HDC hdc, const POINT * apt, DWORD cpt);
 BOOL PolylineTo( HDC hdc, const POINT * apt, DWORD cpt);

 BOOL SetViewportExtEx( HDC hdc, int x, int y, LPSIZE lpsz);
 BOOL SetViewportOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL SetWindowExtEx( HDC hdc, int x, int y, LPSIZE lpsz);
 BOOL SetWindowOrgEx( HDC hdc, int x, int y, LPPOINT lppt);

 BOOL OffsetViewportOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL OffsetWindowOrgEx( HDC hdc, int x, int y, LPPOINT lppt);
 BOOL ScaleViewportExtEx( HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz);
 BOOL ScaleWindowExtEx( HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz);
 BOOL SetBitmapDimensionEx( HBITMAP hbm, int w, int h, LPSIZE lpsz);
 BOOL SetBrushOrgEx( HDC hdc, int x, int y, LPPOINT lppt);

 int GetTextFaceA( HDC hdc, int c, LPSTR lpName);
 int GetTextFaceW( HDC hdc, int c, LPWSTR lpName);



#define GetTextFace GetTextFaceA


#define FONTMAPPER_MAX 10

typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

 DWORD GetKerningPairsA( HDC hdc,
                                            DWORD nPairs,
                                            LPKERNINGPAIR lpKernPair);
 DWORD GetKerningPairsW( HDC hdc,
                                            DWORD nPairs,
                                            LPKERNINGPAIR lpKernPair);



#define GetKerningPairs GetKerningPairsA



 BOOL GetDCOrgEx( HDC hdc, LPPOINT lppt);
 BOOL FixBrushOrgEx( HDC hdc, int x, int y, LPPOINT ptl);
 BOOL UnrealizeObject( HGDIOBJ h);

 BOOL GdiFlush(void);
 DWORD GdiSetBatchLimit( DWORD dw);
 DWORD GdiGetBatchLimit(void);



#define ICM_OFF 1
#define ICM_ON 2
#define ICM_QUERY 3
#define ICM_DONE_OUTSIDEDC 4

typedef int (* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (* ICMENUMPROCW)(LPWSTR, LPARAM);



#define ICMENUMPROC ICMENUMPROCA


 int SetICMMode( HDC hdc, int mode);
 BOOL CheckColorsInGamut( HDC hdc,
                                                    LPRGBTRIPLE lpRGBTriple,
                                                    LPVOID dlpBuffer,
                                                    DWORD nCount);

 HCOLORSPACE GetColorSpace( HDC hdc);
 BOOL GetLogColorSpaceA( HCOLORSPACE hColorSpace,
                                                LPLOGCOLORSPACEA lpBuffer,
                                                DWORD nSize);
 BOOL GetLogColorSpaceW( HCOLORSPACE hColorSpace,
                                                LPLOGCOLORSPACEW lpBuffer,
                                                DWORD nSize);



#define GetLogColorSpace GetLogColorSpaceA


 HCOLORSPACE CreateColorSpaceA( LPLOGCOLORSPACEA lplcs);
 HCOLORSPACE CreateColorSpaceW( LPLOGCOLORSPACEW lplcs);



#define CreateColorSpace CreateColorSpaceA

 HCOLORSPACE SetColorSpace( HDC hdc, HCOLORSPACE hcs);
 BOOL DeleteColorSpace( HCOLORSPACE hcs);
 BOOL GetICMProfileA( HDC hdc,
                                                LPDWORD pBufSize,
                                                LPSTR pszFilename);
 BOOL GetICMProfileW( HDC hdc,
                                                LPDWORD pBufSize,
                                                LPWSTR pszFilename);



#define GetICMProfile GetICMProfileA


 BOOL SetICMProfileA( HDC hdc, LPSTR lpFileName);
 BOOL SetICMProfileW( HDC hdc, LPWSTR lpFileName);



#define SetICMProfile SetICMProfileA

 BOOL GetDeviceGammaRamp( HDC hdc, LPVOID lpRamp);
 BOOL SetDeviceGammaRamp( HDC hdc, LPVOID lpRamp);
 BOOL ColorMatchToTarget( HDC hdc, HDC hdcTarget, DWORD action);
 int EnumICMProfilesA( HDC hdc, ICMENUMPROCA proc, LPARAM param);
 int EnumICMProfilesW( HDC hdc, ICMENUMPROCW proc, LPARAM param);



#define EnumICMProfiles EnumICMProfilesA

// The Win95 update API UpdateICMRegKeyA is deprecated to set last error to ERROR_NOT_SUPPORTED and return FALSE
 BOOL UpdateICMRegKeyA( DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command);
// The Win95 update API UpdateICMRegKeyW is deprecated to set last error to ERROR_NOT_SUPPORTED and return FALSE
 BOOL UpdateICMRegKeyW( DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command);



#define UpdateICMRegKey UpdateICMRegKeyA

#pragma deprecated (UpdateICMRegKeyW)
#pragma deprecated (UpdateICMRegKeyA)




 BOOL ColorCorrectPalette( HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num);




// Enhanced metafile constants.


#define ENHMETA_SIGNATURE 0x464D4520




// Stock object flag used in the object handle index in the enhanced
// metafile records.
// E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH)
// represents the stock object BLACK_BRUSH.

#define ENHMETA_STOCK_OBJECT 0x80000000

// Enhanced metafile record types.

#define EMR_HEADER 1
#define EMR_POLYBEZIER 2
#define EMR_POLYGON 3
#define EMR_POLYLINE 4
#define EMR_POLYBEZIERTO 5
#define EMR_POLYLINETO 6
#define EMR_POLYPOLYLINE 7
#define EMR_POLYPOLYGON 8
#define EMR_SETWINDOWEXTEX 9
#define EMR_SETWINDOWORGEX 10
#define EMR_SETVIEWPORTEXTEX 11
#define EMR_SETVIEWPORTORGEX 12
#define EMR_SETBRUSHORGEX 13
#define EMR_EOF 14
#define EMR_SETPIXELV 15
#define EMR_SETMAPPERFLAGS 16
#define EMR_SETMAPMODE 17
#define EMR_SETBKMODE 18
#define EMR_SETPOLYFILLMODE 19
#define EMR_SETROP2 20
#define EMR_SETSTRETCHBLTMODE 21
#define EMR_SETTEXTALIGN 22
#define EMR_SETCOLORADJUSTMENT 23
#define EMR_SETTEXTCOLOR 24
#define EMR_SETBKCOLOR 25
#define EMR_OFFSETCLIPRGN 26
#define EMR_MOVETOEX 27
#define EMR_SETMETARGN 28
#define EMR_EXCLUDECLIPRECT 29
#define EMR_INTERSECTCLIPRECT 30
#define EMR_SCALEVIEWPORTEXTEX 31
#define EMR_SCALEWINDOWEXTEX 32
#define EMR_SAVEDC 33
#define EMR_RESTOREDC 34
#define EMR_SETWORLDTRANSFORM 35
#define EMR_MODIFYWORLDTRANSFORM 36
#define EMR_SELECTOBJECT 37
#define EMR_CREATEPEN 38
#define EMR_CREATEBRUSHINDIRECT 39
#define EMR_DELETEOBJECT 40
#define EMR_ANGLEARC 41
#define EMR_ELLIPSE 42
#define EMR_RECTANGLE 43
#define EMR_ROUNDRECT 44
#define EMR_ARC 45
#define EMR_CHORD 46
#define EMR_PIE 47
#define EMR_SELECTPALETTE 48
#define EMR_CREATEPALETTE 49
#define EMR_SETPALETTEENTRIES 50
#define EMR_RESIZEPALETTE 51
#define EMR_REALIZEPALETTE 52
#define EMR_EXTFLOODFILL 53
#define EMR_LINETO 54
#define EMR_ARCTO 55
#define EMR_POLYDRAW 56
#define EMR_SETARCDIRECTION 57
#define EMR_SETMITERLIMIT 58
#define EMR_BEGINPATH 59
#define EMR_ENDPATH 60
#define EMR_CLOSEFIGURE 61
#define EMR_FILLPATH 62
#define EMR_STROKEANDFILLPATH 63
#define EMR_STROKEPATH 64
#define EMR_FLATTENPATH 65
#define EMR_WIDENPATH 66
#define EMR_SELECTCLIPPATH 67
#define EMR_ABORTPATH 68

#define EMR_GDICOMMENT 70
#define EMR_FILLRGN 71
#define EMR_FRAMERGN 72
#define EMR_INVERTRGN 73
#define EMR_PAINTRGN 74
#define EMR_EXTSELECTCLIPRGN 75
#define EMR_BITBLT 76
#define EMR_STRETCHBLT 77
#define EMR_MASKBLT 78
#define EMR_PLGBLT 79
#define EMR_SETDIBITSTODEVICE 80
#define EMR_STRETCHDIBITS 81
#define EMR_EXTCREATEFONTINDIRECTW 82
#define EMR_EXTTEXTOUTA 83
#define EMR_EXTTEXTOUTW 84
#define EMR_POLYBEZIER16 85
#define EMR_POLYGON16 86
#define EMR_POLYLINE16 87
#define EMR_POLYBEZIERTO16 88
#define EMR_POLYLINETO16 89
#define EMR_POLYPOLYLINE16 90
#define EMR_POLYPOLYGON16 91
#define EMR_POLYDRAW16 92
#define EMR_CREATEMONOBRUSH 93
#define EMR_CREATEDIBPATTERNBRUSHPT 94
#define EMR_EXTCREATEPEN 95
#define EMR_POLYTEXTOUTA 96
#define EMR_POLYTEXTOUTW 97


#define EMR_SETICMMODE 98
#define EMR_CREATECOLORSPACE 99
#define EMR_SETCOLORSPACE 100
#define EMR_DELETECOLORSPACE 101
#define EMR_GLSRECORD 102
#define EMR_GLSBOUNDEDRECORD 103
#define EMR_PIXELFORMAT 104



#define EMR_RESERVED_105 105
#define EMR_RESERVED_106 106
#define EMR_RESERVED_107 107
#define EMR_RESERVED_108 108
#define EMR_RESERVED_109 109
#define EMR_RESERVED_110 110
#define EMR_COLORCORRECTPALETTE 111
#define EMR_SETICMPROFILEA 112
#define EMR_SETICMPROFILEW 113
#define EMR_ALPHABLEND 114
#define EMR_SETLAYOUT 115
#define EMR_TRANSPARENTBLT 116

#define EMR_RESERVED_117 117

#define EMR_GRADIENTFILL 118
#define EMR_RESERVED_119 119
#define EMR_RESERVED_120 120
#define EMR_COLORMATCHTOTARGETW 121
#define EMR_CREATECOLORSPACEW 122


#define EMR_MIN 1


#define EMR_MAX 122






// Base record type for the enhanced metafile.

typedef struct tagEMR
{
    DWORD iType; // Enhanced metafile record type
    DWORD nSize; // Length of the record in bytes.
                                // This must be a multiple of 4.
} EMR, *PEMR;

// Base text record type for the enhanced metafile.

typedef struct tagEMRTEXT
{
    POINTL ptlReference;
    DWORD nChars;
    DWORD offString; // Offset to the string
    DWORD fOptions;
    RECTL rcl;
    DWORD offDx; // Offset to the inter-character spacing array.
                                // This is always given.
} EMRTEXT, *PEMRTEXT;

// Record structures for the enhanced metafile.

typedef struct tagABORTPATH
{
    EMR emr;
} EMRABORTPATH, *PEMRABORTPATH,
  EMRBEGINPATH, *PEMRBEGINPATH,
  EMRENDPATH, *PEMRENDPATH,
  EMRCLOSEFIGURE, *PEMRCLOSEFIGURE,
  EMRFLATTENPATH, *PEMRFLATTENPATH,
  EMRWIDENPATH, *PEMRWIDENPATH,
  EMRSETMETARGN, *PEMRSETMETARGN,
  EMRSAVEDC, *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR emr;
    DWORD iMode;
} EMRSELECTCLIPPATH, *PEMRSELECTCLIPPATH,
  EMRSETBKMODE, *PEMRSETBKMODE,
  EMRSETMAPMODE, *PEMRSETMAPMODE,

  EMRSETLAYOUT, *PEMRSETLAYOUT,

  EMRSETPOLYFILLMODE, *PEMRSETPOLYFILLMODE,
  EMRSETROP2, *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE, *PEMRSETICMMODE,
  EMRSETTEXTALIGN, *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR emr;
    FLOAT eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR emr;
    LONG iRelative; // Specifies a relative instance
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR emr;
    DWORD iArcDirection; // Specifies the arc direction in the
                                // advanced graphics mode.
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR emr;
    DWORD dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR emr;
    COLORREF crColor;
} EMRSETBKCOLOR, *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR emr;
    DWORD ihObject; // Object handle index
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

typedef struct tagEMRSELECTPALETTE
{
    EMR emr;
    DWORD ihPal; // Palette handle index, background mode only
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR emr;
    DWORD ihPal; // Palette handle index
    DWORD cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR emr;
    DWORD ihPal; // Palette handle index
    DWORD iStart;
    DWORD cEntries;
    PALETTEENTRY aPalEntries[1];// The peFlags fields do not contain any flags
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR emr;
    DWORD cbData; // Size of data in bytes
    BYTE Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR emr;
    DWORD nPalEntries; // Number of palette entries
    DWORD offPalEntries; // Offset to the palette entries
    DWORD nSizeLast; // Same as nSize and must be the last DWORD
                                // of the record.  The palette entries,
                                // if exist, precede this field.
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR emr;
    POINTL ptl;
} EMRLINETO, *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR emr;
    POINTL ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
} EMRFILLPATH, *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH, *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR emr;
    RECTL rclClip;
} EMREXCLUDECLIPRECT, *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR emr;
    POINTL ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX, *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX, *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR emr;
    SIZEL szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX, *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR emr;
    LONG xNum;
    LONG xDenom;
    LONG yNum;
    LONG yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX, *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR emr;
    XFORM xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR emr;
    XFORM xform;
    DWORD iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR emr;
    POINTL ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR emr;
    POINTL ptlStart;
    COLORREF crColor;
    DWORD iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR emr;
    RECTL rclBox; // Inclusive-inclusive bounding rectangle
} EMRELLIPSE, *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;


typedef struct tagEMRROUNDRECT
{
    EMR emr;
    RECTL rclBox; // Inclusive-inclusive bounding rectangle
    SIZEL szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR emr;
    RECTL rclBox; // Inclusive-inclusive bounding rectangle
    POINTL ptlStart;
    POINTL ptlEnd;
} EMRARC, *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE, *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR emr;
    POINTL ptlCenter;
    DWORD nRadius;
    FLOAT eStartAngle;
    FLOAT eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cptl;
    POINTL aptl[1];
} EMRPOLYLINE, *PEMRPOLYLINE,
  EMRPOLYBEZIER, *PEMRPOLYBEZIER,
  EMRPOLYGON, *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO, *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cpts;
    POINTS apts[1];
} EMRPOLYLINE16, *PEMRPOLYLINE16,
  EMRPOLYBEZIER16, *PEMRPOLYBEZIER16,
  EMRPOLYGON16, *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16, *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cptl; // Number of points
    POINTL aptl[1]; // Array of points
    BYTE abTypes[1]; // Array of point types
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cpts; // Number of points
    POINTS apts[1]; // Array of points
    BYTE abTypes[1]; // Array of point types
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD nPolys; // Number of polys
    DWORD cptl; // Total number of points in all polys
    DWORD aPolyCounts[1]; // Array of point counts for each poly
    POINTL aptl[1]; // Array of points
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON, *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD nPolys; // Number of polys
    DWORD cpts; // Total number of points in all polys
    DWORD aPolyCounts[1]; // Array of point counts for each poly
    POINTS apts[1]; // Array of points
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16, *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cbRgnData; // Size of region data in bytes
    BYTE RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN, *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cbRgnData; // Size of region data in bytes
    DWORD ihBrush; // Brush handle index
    BYTE RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD cbRgnData; // Size of region data in bytes
    DWORD ihBrush; // Brush handle index
    SIZEL szlStroke;
    BYTE RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;

typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR emr;
    DWORD cbRgnData; // Size of region data in bytes
    DWORD iMode;
    BYTE RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD iGraphicsMode; // Current graphics mode
    FLOAT exScale; // X and Y scales from Page units to .01mm units
    FLOAT eyScale; //   if graphics mode is GM_COMPATIBLE.
    EMRTEXT emrtext; // This is followed by the string and spacing
                                // array
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD iGraphicsMode; // Current graphics mode
    FLOAT exScale; // X and Y scales from Page units to .01mm units
    FLOAT eyScale; //   if graphics mode is GM_COMPATIBLE.
    LONG cStrings;
    EMRTEXT aemrtext[1]; // Array of EMRTEXT structures.  This is
                                // followed by the strings and spacing arrays.
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG cxSrc;
    LONG cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG xMask;
    LONG yMask;
    DWORD iUsageMask; // Mask bitmap info color table usage
    DWORD offBmiMask; // Offset to the mask BITMAPINFO structure if any
    DWORD cbBmiMask; // Size of the mask BITMAPINFO structure if any
    DWORD offBitsMask; // Offset to the mask bitmap bits if any
    DWORD cbBitsMask; // Size of the mask bitmap bits if any
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    POINTL aptlDest[3];
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG xMask;
    LONG yMask;
    DWORD iUsageMask; // Mask bitmap info color table usage
    DWORD offBmiMask; // Offset to the mask BITMAPINFO structure if any
    DWORD cbBmiMask; // Size of the mask BITMAPINFO structure if any
    DWORD offBitsMask; // Offset to the mask bitmap bits if any
    DWORD cbBitsMask; // Size of the mask bitmap bits if any
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    DWORD iUsageSrc; // Source bitmap info color table usage
    DWORD iStartScan;
    DWORD cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG xSrc;
    LONG ySrc;
    LONG cxSrc;
    LONG cySrc;
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    DWORD iUsageSrc; // Source bitmap info color table usage
    DWORD dwRop;
    LONG cxDest;
    LONG cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR emr;
    DWORD ihFont; // Font handle index
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

typedef struct tagEMRCREATEPALETTE
{
    EMR emr;
    DWORD ihPal; // Palette handle index
    LOGPALETTE lgpl; // The peFlags fields in the palette entries
                                // do not contain any flags
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

typedef struct tagEMRCREATEPEN
{
    EMR emr;
    DWORD ihPen; // Pen handle index
    LOGPEN lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR emr;
    DWORD ihPen; // Pen handle index
    DWORD offBmi; // Offset to the BITMAPINFO structure if any
    DWORD cbBmi; // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD offBits; // Offset to the brush bitmap bits if any
    DWORD cbBits; // Size of the brush bitmap bits if any
    EXTLOGPEN32 elp; // The extended pen with the style array.
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR emr;
    DWORD ihBrush; // Brush handle index
    LOGBRUSH32 lb; // The style must be BS_SOLID, BS_HOLLOW,
                                 // BS_NULL or BS_HATCHED.
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR emr;
    DWORD ihBrush; // Brush handle index
    DWORD iUsage; // Bitmap info color table usage
    DWORD offBmi; // Offset to the BITMAPINFO structure
    DWORD cbBmi; // Size of the BITMAPINFO structure
    DWORD offBits; // Offset to the bitmap bits
    DWORD cbBits; // Size of the bitmap bits
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR emr;
    DWORD ihBrush; // Brush handle index
    DWORD iUsage; // Bitmap info color table usage
    DWORD offBmi; // Offset to the BITMAPINFO structure
    DWORD cbBmi; // Size of the BITMAPINFO structure
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD offBits; // Offset to the bitmap bits
    DWORD cbBits; // Size of the bitmap bits
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    DWORD dSignature; // Format signature, e.g. ENHMETA_SIGNATURE.
    DWORD nVersion; // Format version number.
    DWORD cbData; // Size of data in bytes.
    DWORD offData; // Offset to data from GDICOMMENT_IDENTIFIER.
                                // It must begin at a DWORD offset.
} EMRFORMAT, *PEMRFORMAT;



typedef struct tagEMRGLSRECORD
{
    EMR emr;
    DWORD cbData; // Size of data in bytes
    BYTE Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;

typedef struct tagEMRGLSBOUNDEDRECORD
{
    EMR emr;
    RECTL rclBounds; // Bounds in recording coordinates
    DWORD cbData; // Size of data in bytes
    BYTE Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;

typedef struct tagEMRPIXELFORMAT
{
    EMR emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;

typedef struct tagEMRCREATECOLORSPACE
{
    EMR emr;
    DWORD ihCS; // ColorSpace handle index
    LOGCOLORSPACEA lcs; // Ansi version of LOGCOLORSPACE
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

typedef struct tagEMRSETCOLORSPACE
{
    EMR emr;
    DWORD ihCS; // ColorSpace handle index
} EMRSETCOLORSPACE, *PEMRSETCOLORSPACE,
  EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;





typedef struct tagEMREXTESCAPE
{
    EMR emr;
    INT iEscape; // Escape code
    INT cbEscData; // Size of escape data
    BYTE EscData[1]; // Escape data
} EMREXTESCAPE, *PEMREXTESCAPE,
  EMRDRAWESCAPE, *PEMRDRAWESCAPE;

typedef struct tagEMRNAMEDESCAPE
{
    EMR emr;
    INT iEscape; // Escape code
    INT cbDriver; // Size of driver name
    INT cbEscData; // Size of escape data
    BYTE EscData[1]; // Driver name and Escape data
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;

#define SETICMPROFILE_EMBEDED 0x00000001

typedef struct tagEMRSETICMPROFILE
{
    EMR emr;
    DWORD dwFlags; // flags
    DWORD cbName; // Size of desired profile name
    DWORD cbData; // Size of raw profile data if attached
    BYTE Data[1]; // Array size is cbName + cbData
} EMRSETICMPROFILE, *PEMRSETICMPROFILE,
  EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
  EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;

#define CREATECOLORSPACE_EMBEDED 0x00000001

typedef struct tagEMRCREATECOLORSPACEW
{
    EMR emr;
    DWORD ihCS; // ColorSpace handle index
    LOGCOLORSPACEW lcs; // Unicode version of logical color space structure
    DWORD dwFlags; // flags
    DWORD cbData; // size of raw source profile data if attached
    BYTE Data[1]; // Array size is cbData
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;

#define COLORMATCHTOTARGET_EMBEDED 0x00000001

typedef struct tagCOLORMATCHTOTARGET
{
    EMR emr;
    DWORD dwAction; // CS_ENABLE, CS_DISABLE or CS_DELETE_TRANSFORM
    DWORD dwFlags; // flags
    DWORD cbName; // Size of desired target profile name
    DWORD cbData; // Size of raw target profile data if attached
    BYTE Data[1]; // Array size is cbName + cbData
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;

typedef struct tagCOLORCORRECTPALETTE
{
    EMR emr;
    DWORD ihPalette; // Palette handle index
    DWORD nFirstEntry; // Index of first entry to correct
    DWORD nPalEntries; // Number of palette entries to correct
    DWORD nReserved; // Reserved
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;

typedef struct tagEMRALPHABLEND
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG cxSrc;
    LONG cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;

typedef struct tagEMRGRADIENTFILL
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    DWORD nVer;
    DWORD nTri;
    ULONG ulMode;
    TRIVERTEX Ver[1];
}EMRGRADIENTFILL,*PEMRGRADIENTFILL;

typedef struct tagEMRTRANSPARENTBLT
{
    EMR emr;
    RECTL rclBounds; // Inclusive-inclusive bounds in device units
    LONG xDest;
    LONG yDest;
    LONG cxDest;
    LONG cyDest;
    DWORD dwRop;
    LONG xSrc;
    LONG ySrc;
    XFORM xformSrc; // Source DC transform
    COLORREF crBkColorSrc; // Source DC BkColor in RGB
    DWORD iUsageSrc; // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD offBmiSrc; // Offset to the source BITMAPINFO structure
    DWORD cbBmiSrc; // Size of the source BITMAPINFO structure
    DWORD offBitsSrc; // Offset to the source bitmap bits
    DWORD cbBitsSrc; // Size of the source bitmap bits
    LONG cxSrc;
    LONG cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;




#define GDICOMMENT_IDENTIFIER 0x43494447
#define GDICOMMENT_WINDOWS_METAFILE 0x80000001
#define GDICOMMENT_BEGINGROUP 0x00000002
#define GDICOMMENT_ENDGROUP 0x00000003
#define GDICOMMENT_MULTIFORMATS 0x40000004
#define EPS_SIGNATURE 0x46535045
#define GDICOMMENT_UNICODE_STRING 0x00000040
#define GDICOMMENT_UNICODE_END 0x00000080




// OpenGL wgl prototypes

 BOOL wglCopyContext(HGLRC, HGLRC, UINT);
 HGLRC wglCreateContext(HDC);
 HGLRC wglCreateLayerContext(HDC, int);
 BOOL wglDeleteContext(HGLRC);
 HGLRC wglGetCurrentContext(void);
 HDC wglGetCurrentDC(void);
 PROC wglGetProcAddress(LPCSTR);
 BOOL wglMakeCurrent(HDC, HGLRC);
 BOOL wglShareLists(HGLRC, HGLRC);
 BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
 BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);



#define wglUseFontBitmaps wglUseFontBitmapsA

 BOOL SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT x;
    FLOAT y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT gmfBlackBoxX;
    FLOAT gmfBlackBoxY;
    POINTFLOAT gmfptGlyphOrigin;
    FLOAT gmfCellIncX;
    FLOAT gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT, *LPGLYPHMETRICSFLOAT;

#define WGL_FONT_LINES 0
#define WGL_FONT_POLYGONS 1
 BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
 BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);



#define wglUseFontOutlines wglUseFontOutlinesA


/* Layer plane descriptor */
typedef struct tagLAYERPLANEDESCRIPTOR { // lpd
    WORD nSize;
    WORD nVersion;
    DWORD dwFlags;
    BYTE iPixelType;
    BYTE cColorBits;
    BYTE cRedBits;
    BYTE cRedShift;
    BYTE cGreenBits;
    BYTE cGreenShift;
    BYTE cBlueBits;
    BYTE cBlueShift;
    BYTE cAlphaBits;
    BYTE cAlphaShift;
    BYTE cAccumBits;
    BYTE cAccumRedBits;
    BYTE cAccumGreenBits;
    BYTE cAccumBlueBits;
    BYTE cAccumAlphaBits;
    BYTE cDepthBits;
    BYTE cStencilBits;
    BYTE cAuxBuffers;
    BYTE iLayerPlane;
    BYTE bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR, *LPLAYERPLANEDESCRIPTOR;

/* LAYERPLANEDESCRIPTOR flags */
#define LPD_DOUBLEBUFFER 0x00000001
#define LPD_STEREO 0x00000002
#define LPD_SUPPORT_GDI 0x00000010
#define LPD_SUPPORT_OPENGL 0x00000020
#define LPD_SHARE_DEPTH 0x00000040
#define LPD_SHARE_STENCIL 0x00000080
#define LPD_SHARE_ACCUM 0x00000100
#define LPD_SWAP_EXCHANGE 0x00000200
#define LPD_SWAP_COPY 0x00000400
#define LPD_TRANSPARENT 0x00001000

#define LPD_TYPE_RGBA 0
#define LPD_TYPE_COLORINDEX 1

/* wglSwapLayerBuffers flags */
#define WGL_SWAP_MAIN_PLANE 0x00000001
#define WGL_SWAP_OVERLAY1 0x00000002
#define WGL_SWAP_OVERLAY2 0x00000004
#define WGL_SWAP_OVERLAY3 0x00000008
#define WGL_SWAP_OVERLAY4 0x00000010
#define WGL_SWAP_OVERLAY5 0x00000020
#define WGL_SWAP_OVERLAY6 0x00000040
#define WGL_SWAP_OVERLAY7 0x00000080
#define WGL_SWAP_OVERLAY8 0x00000100
#define WGL_SWAP_OVERLAY9 0x00000200
#define WGL_SWAP_OVERLAY10 0x00000400
#define WGL_SWAP_OVERLAY11 0x00000800
#define WGL_SWAP_OVERLAY12 0x00001000
#define WGL_SWAP_OVERLAY13 0x00002000
#define WGL_SWAP_OVERLAY14 0x00004000
#define WGL_SWAP_OVERLAY15 0x00008000
#define WGL_SWAP_UNDERLAY1 0x00010000
#define WGL_SWAP_UNDERLAY2 0x00020000
#define WGL_SWAP_UNDERLAY3 0x00040000
#define WGL_SWAP_UNDERLAY4 0x00080000
#define WGL_SWAP_UNDERLAY5 0x00100000
#define WGL_SWAP_UNDERLAY6 0x00200000
#define WGL_SWAP_UNDERLAY7 0x00400000
#define WGL_SWAP_UNDERLAY8 0x00800000
#define WGL_SWAP_UNDERLAY9 0x01000000
#define WGL_SWAP_UNDERLAY10 0x02000000
#define WGL_SWAP_UNDERLAY11 0x04000000
#define WGL_SWAP_UNDERLAY12 0x08000000
#define WGL_SWAP_UNDERLAY13 0x10000000
#define WGL_SWAP_UNDERLAY14 0x20000000
#define WGL_SWAP_UNDERLAY15 0x40000000

 BOOL wglDescribeLayerPlane(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
 int wglSetLayerPaletteEntries(HDC, int, int, int,
                                                 const COLORREF *);
 int wglGetLayerPaletteEntries(HDC, int, int, int,
                                                 COLORREF *);
 BOOL wglRealizeLayerPalette(HDC, int, BOOL);
 BOOL wglSwapLayerBuffers(HDC, UINT);



typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP, *LPWGLSWAP;

#define WGL_SWAPMULTIPLE_MAX 16

 DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *);
# 158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 1
/****************************************************************************

*                                                                           *

* winuser.h -- USER procedure declarations, constant definitions and macros *

*                                                                           *

* Copyright (c) Microsoft Corporation. All rights reserved.                 *

*                                                                           *

****************************************************************************/
# 12 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define _WINUSER_ 



       

//
// Define API decoration for direct importing of DLL references.
//


#define WINUSERAPI DECLSPEC_IMPORT
#define WINABLEAPI DECLSPEC_IMPORT
# 46 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;



typedef MENUTEMPLATEA MENUTEMPLATE;

typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;



typedef LPMENUTEMPLATEA LPMENUTEMPLATE;


typedef LRESULT (* WNDPROC)(HWND, UINT, WPARAM, LPARAM);



typedef INT_PTR (* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
typedef void (* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
typedef BOOL (* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void (* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

typedef BOOL (* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

typedef int (* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);


typedef BOOL (* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
# 117 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef PROPENUMPROCA PROPENUMPROC;
typedef PROPENUMPROCEXA PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA EDITWORDBREAKPROC;




typedef BOOL (* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (* NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;
# 151 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef WINSTAENUMPROCA WINSTAENUMPROC;
typedef DESKTOPENUMPROCA DESKTOPENUMPROC;



#define IS_INTRESOURCE(_r) ((((ULONG_PTR)(_r)) >> 16) == 0)
#define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
#define MAKEINTRESOURCEW(i) ((LPWSTR)((ULONG_PTR)((WORD)(i))))



#define MAKEINTRESOURCE MAKEINTRESOURCEA




/*

 * Predefined Resource Types

 */
# 170 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RT_CURSOR MAKEINTRESOURCE(1)
#define RT_BITMAP MAKEINTRESOURCE(2)
#define RT_ICON MAKEINTRESOURCE(3)
#define RT_MENU MAKEINTRESOURCE(4)
#define RT_DIALOG MAKEINTRESOURCE(5)
#define RT_STRING MAKEINTRESOURCE(6)
#define RT_FONTDIR MAKEINTRESOURCE(7)
#define RT_FONT MAKEINTRESOURCE(8)
#define RT_ACCELERATOR MAKEINTRESOURCE(9)
#define RT_RCDATA MAKEINTRESOURCE(10)
#define RT_MESSAGETABLE MAKEINTRESOURCE(11)

#define DIFFERENCE 11
#define RT_GROUP_CURSOR MAKEINTRESOURCE((ULONG_PTR)(RT_CURSOR) + DIFFERENCE)
#define RT_GROUP_ICON MAKEINTRESOURCE((ULONG_PTR)(RT_ICON) + DIFFERENCE)
#define RT_VERSION MAKEINTRESOURCE(16)
#define RT_DLGINCLUDE MAKEINTRESOURCE(17)

#define RT_PLUGPLAY MAKEINTRESOURCE(19)
#define RT_VXD MAKEINTRESOURCE(20)
#define RT_ANICURSOR MAKEINTRESOURCE(21)
#define RT_ANIICON MAKEINTRESOURCE(22)

#define RT_HTML MAKEINTRESOURCE(23)
# 202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RT_MANIFEST MAKEINTRESOURCE(24)
#define CREATEPROCESS_MANIFEST_RESOURCE_ID MAKEINTRESOURCE( 1)
#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(2)
#define ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(3)
#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID MAKEINTRESOURCE( 1 )
#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID MAKEINTRESOURCE(16 )
# 218 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

int

wvsprintfA(
    LPSTR,
    LPCSTR,
    va_list arglist);

int

wvsprintfW(
    LPWSTR,
    LPCWSTR,
    va_list arglist);



#define wvsprintf wvsprintfA



int

wsprintfA(
    LPSTR,
    LPCSTR,
    ...);

int

wsprintfW(
    LPWSTR,
    LPCWSTR,
    ...);



#define wsprintf wsprintfA







/*

 * SPI_SETDESKWALLPAPER defined constants

 */
# 266 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SETWALLPAPER_DEFAULT ((LPWSTR)-1)



/*

 * Scroll Bar Constants

 */
# 273 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SB_HORZ 0
#define SB_VERT 1
#define SB_CTL 2
#define SB_BOTH 3

/*

 * Scroll Bar Commands

 */
# 281 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SB_LINEUP 0
#define SB_LINELEFT 0
#define SB_LINEDOWN 1
#define SB_LINERIGHT 1
#define SB_PAGEUP 2
#define SB_PAGELEFT 2
#define SB_PAGEDOWN 3
#define SB_PAGERIGHT 3
#define SB_THUMBPOSITION 4
#define SB_THUMBTRACK 5
#define SB_TOP 6
#define SB_LEFT 6
#define SB_BOTTOM 7
#define SB_RIGHT 7
#define SB_ENDSCROLL 8






/*

 * ShowWindow() Commands

 */
# 305 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SW_HIDE 0
#define SW_SHOWNORMAL 1
#define SW_NORMAL 1
#define SW_SHOWMINIMIZED 2
#define SW_SHOWMAXIMIZED 3
#define SW_MAXIMIZE 3
#define SW_SHOWNOACTIVATE 4
#define SW_SHOW 5
#define SW_MINIMIZE 6
#define SW_SHOWMINNOACTIVE 7
#define SW_SHOWNA 8
#define SW_RESTORE 9
#define SW_SHOWDEFAULT 10
#define SW_FORCEMINIMIZE 11
#define SW_MAX 11


/*

 * Old ShowWindow() Commands

 */
# 325 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HIDE_WINDOW 0
#define SHOW_OPENWINDOW 1
#define SHOW_ICONWINDOW 2
#define SHOW_FULLSCREEN 3
#define SHOW_OPENNOACTIVATE 4

/*

 * Identifiers for the WM_SHOWWINDOW message

 */
# 334 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SW_PARENTCLOSING 1
#define SW_OTHERZOOM 2
#define SW_PARENTOPENING 3
#define SW_OTHERUNZOOM 4





/*

 * AnimateWindow() Commands

 */
# 346 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define AW_HOR_POSITIVE 0x00000001
#define AW_HOR_NEGATIVE 0x00000002
#define AW_VER_POSITIVE 0x00000004
#define AW_VER_NEGATIVE 0x00000008
#define AW_CENTER 0x00000010
#define AW_HIDE 0x00010000
#define AW_ACTIVATE 0x00020000
#define AW_SLIDE 0x00040000
#define AW_BLEND 0x00080000




/*

 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags

 */
# 362 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define KF_EXTENDED 0x0100
#define KF_DLGMODE 0x0800
#define KF_MENUMODE 0x1000
#define KF_ALTDOWN 0x2000
#define KF_REPEAT 0x4000
#define KF_UP 0x8000




/*

 * Virtual Keys, Standard Set

 */
# 375 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_LBUTTON 0x01
#define VK_RBUTTON 0x02
#define VK_CANCEL 0x03
#define VK_MBUTTON 0x04


#define VK_XBUTTON1 0x05
#define VK_XBUTTON2 0x06


/*

 * 0x07 : unassigned

 */
# 389 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_BACK 0x08
#define VK_TAB 0x09

/*

 * 0x0A - 0x0B : reserved

 */
# 396 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_CLEAR 0x0C
#define VK_RETURN 0x0D

#define VK_SHIFT 0x10
#define VK_CONTROL 0x11
#define VK_MENU 0x12
#define VK_PAUSE 0x13
#define VK_CAPITAL 0x14

#define VK_KANA 0x15
#define VK_HANGEUL 0x15
#define VK_HANGUL 0x15
#define VK_JUNJA 0x17
#define VK_FINAL 0x18
#define VK_HANJA 0x19
#define VK_KANJI 0x19

#define VK_ESCAPE 0x1B

#define VK_CONVERT 0x1C
#define VK_NONCONVERT 0x1D
#define VK_ACCEPT 0x1E
#define VK_MODECHANGE 0x1F

#define VK_SPACE 0x20
#define VK_PRIOR 0x21
#define VK_NEXT 0x22
#define VK_END 0x23
#define VK_HOME 0x24
#define VK_LEFT 0x25
#define VK_UP 0x26
#define VK_RIGHT 0x27
#define VK_DOWN 0x28
#define VK_SELECT 0x29
#define VK_PRINT 0x2A
#define VK_EXECUTE 0x2B
#define VK_SNAPSHOT 0x2C
#define VK_INSERT 0x2D
#define VK_DELETE 0x2E
#define VK_HELP 0x2F

/*

 * VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)

 * 0x40 : unassigned

 * VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)

 */
# 443 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_LWIN 0x5B
#define VK_RWIN 0x5C
#define VK_APPS 0x5D

/*

 * 0x5E : reserved

 */
# 451 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_SLEEP 0x5F

#define VK_NUMPAD0 0x60
#define VK_NUMPAD1 0x61
#define VK_NUMPAD2 0x62
#define VK_NUMPAD3 0x63
#define VK_NUMPAD4 0x64
#define VK_NUMPAD5 0x65
#define VK_NUMPAD6 0x66
#define VK_NUMPAD7 0x67
#define VK_NUMPAD8 0x68
#define VK_NUMPAD9 0x69
#define VK_MULTIPLY 0x6A
#define VK_ADD 0x6B
#define VK_SEPARATOR 0x6C
#define VK_SUBTRACT 0x6D
#define VK_DECIMAL 0x6E
#define VK_DIVIDE 0x6F
#define VK_F1 0x70
#define VK_F2 0x71
#define VK_F3 0x72
#define VK_F4 0x73
#define VK_F5 0x74
#define VK_F6 0x75
#define VK_F7 0x76
#define VK_F8 0x77
#define VK_F9 0x78
#define VK_F10 0x79
#define VK_F11 0x7A
#define VK_F12 0x7B
#define VK_F13 0x7C
#define VK_F14 0x7D
#define VK_F15 0x7E
#define VK_F16 0x7F
#define VK_F17 0x80
#define VK_F18 0x81
#define VK_F19 0x82
#define VK_F20 0x83
#define VK_F21 0x84
#define VK_F22 0x85
#define VK_F23 0x86
#define VK_F24 0x87

/*

 * 0x88 - 0x8F : unassigned

 */
# 498 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_NUMLOCK 0x90
#define VK_SCROLL 0x91

/*

 * NEC PC-9800 kbd definitions

 */
# 504 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_OEM_NEC_EQUAL 0x92

/*

 * Fujitsu/OASYS kbd definitions

 */
# 509 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_OEM_FJ_JISHO 0x92
#define VK_OEM_FJ_MASSHOU 0x93
#define VK_OEM_FJ_TOUROKU 0x94
#define VK_OEM_FJ_LOYA 0x95
#define VK_OEM_FJ_ROYA 0x96

/*

 * 0x97 - 0x9F : unassigned

 */
# 519 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.

 * Used only as parameters to GetAsyncKeyState() and GetKeyState().

 * No other API or message will distinguish left and right keys in this way.

 */
# 524 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_LSHIFT 0xA0
#define VK_RSHIFT 0xA1
#define VK_LCONTROL 0xA2
#define VK_RCONTROL 0xA3
#define VK_LMENU 0xA4
#define VK_RMENU 0xA5


#define VK_BROWSER_BACK 0xA6
#define VK_BROWSER_FORWARD 0xA7
#define VK_BROWSER_REFRESH 0xA8
#define VK_BROWSER_STOP 0xA9
#define VK_BROWSER_SEARCH 0xAA
#define VK_BROWSER_FAVORITES 0xAB
#define VK_BROWSER_HOME 0xAC

#define VK_VOLUME_MUTE 0xAD
#define VK_VOLUME_DOWN 0xAE
#define VK_VOLUME_UP 0xAF
#define VK_MEDIA_NEXT_TRACK 0xB0
#define VK_MEDIA_PREV_TRACK 0xB1
#define VK_MEDIA_STOP 0xB2
#define VK_MEDIA_PLAY_PAUSE 0xB3
#define VK_LAUNCH_MAIL 0xB4
#define VK_LAUNCH_MEDIA_SELECT 0xB5
#define VK_LAUNCH_APP1 0xB6
#define VK_LAUNCH_APP2 0xB7



/*

 * 0xB8 - 0xB9 : reserved

 */
# 558 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_OEM_1 0xBA
#define VK_OEM_PLUS 0xBB
#define VK_OEM_COMMA 0xBC
#define VK_OEM_MINUS 0xBD
#define VK_OEM_PERIOD 0xBE
#define VK_OEM_2 0xBF
#define VK_OEM_3 0xC0

/*

 * 0xC1 - 0xD7 : reserved

 */
# 570 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * 0xD8 - 0xDA : unassigned

 */
# 574 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_OEM_4 0xDB
#define VK_OEM_5 0xDC
#define VK_OEM_6 0xDD
#define VK_OEM_7 0xDE
#define VK_OEM_8 0xDF

/*

 * 0xE0 : reserved

 */
# 584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Various extended or enhanced keyboards

 */
# 587 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_OEM_AX 0xE1
#define VK_OEM_102 0xE2
#define VK_ICO_HELP 0xE3
#define VK_ICO_00 0xE4


#define VK_PROCESSKEY 0xE5


#define VK_ICO_CLEAR 0xE6



#define VK_PACKET 0xE7


/*

 * 0xE8 : unassigned

 */
# 607 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Nokia/Ericsson definitions

 */
# 610 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define VK_OEM_RESET 0xE9
#define VK_OEM_JUMP 0xEA
#define VK_OEM_PA1 0xEB
#define VK_OEM_PA2 0xEC
#define VK_OEM_PA3 0xED
#define VK_OEM_WSCTRL 0xEE
#define VK_OEM_CUSEL 0xEF
#define VK_OEM_ATTN 0xF0
#define VK_OEM_FINISH 0xF1
#define VK_OEM_COPY 0xF2
#define VK_OEM_AUTO 0xF3
#define VK_OEM_ENLW 0xF4
#define VK_OEM_BACKTAB 0xF5

#define VK_ATTN 0xF6
#define VK_CRSEL 0xF7
#define VK_EXSEL 0xF8
#define VK_EREOF 0xF9
#define VK_PLAY 0xFA
#define VK_ZOOM 0xFB
#define VK_NONAME 0xFC
#define VK_PA1 0xFD
#define VK_OEM_CLEAR 0xFE

/*

 * 0xFF : reserved

 */




/*

 * SetWindowsHook() codes

 */
# 646 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WH_MIN (-1)
#define WH_MSGFILTER (-1)
#define WH_JOURNALRECORD 0
#define WH_JOURNALPLAYBACK 1
#define WH_KEYBOARD 2
#define WH_GETMESSAGE 3
#define WH_CALLWNDPROC 4
#define WH_CBT 5
#define WH_SYSMSGFILTER 6
#define WH_MOUSE 7



#define WH_DEBUG 9
#define WH_SHELL 10
#define WH_FOREGROUNDIDLE 11

#define WH_CALLWNDPROCRET 12



#define WH_KEYBOARD_LL 13
#define WH_MOUSE_LL 14




#define WH_MAX 14







#define WH_MINHOOK WH_MIN
#define WH_MAXHOOK WH_MAX

/*

 * Hook Codes

 */
# 687 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HC_ACTION 0
#define HC_GETNEXT 1
#define HC_SKIP 2
#define HC_NOREMOVE 3
#define HC_NOREM HC_NOREMOVE
#define HC_SYSMODALON 4
#define HC_SYSMODALOFF 5

/*

 * CBT Hook Codes

 */
# 698 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HCBT_MOVESIZE 0
#define HCBT_MINMAX 1
#define HCBT_QS 2
#define HCBT_CREATEWND 3
#define HCBT_DESTROYWND 4
#define HCBT_ACTIVATE 5
#define HCBT_CLICKSKIPPED 6
#define HCBT_KEYSKIPPED 7
#define HCBT_SYSCOMMAND 8
#define HCBT_SETFOCUS 9

/*

 * HCBT_CREATEWND parameters pointed to by lParam

 */
# 712 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
/*

 * HCBT_CREATEWND parameters pointed to by lParam

 */
# 720 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;




typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;


/*

 * HCBT_ACTIVATE structure pointed to by lParam

 */
# 736 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL fMouse;
    HWND hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;


/*

 * WTSSESSION_NOTIFICATION struct pointed by lParam, for WM_WTSSESSION_CHANGE

 */
# 746 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagWTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;

} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;

/*

 * codes passed in WPARAM for WM_WTSSESSION_CHANGE

 */
# 757 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WTS_CONSOLE_CONNECT 0x1
#define WTS_CONSOLE_DISCONNECT 0x2
#define WTS_REMOTE_CONNECT 0x3
#define WTS_REMOTE_DISCONNECT 0x4
#define WTS_SESSION_LOGON 0x5
#define WTS_SESSION_LOGOFF 0x6
#define WTS_SESSION_LOCK 0x7
#define WTS_SESSION_UNLOCK 0x8
#define WTS_SESSION_REMOTE_CONTROL 0x9



/*

 * WH_MSGFILTER Filter Proc Codes

 */
# 772 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MSGF_DIALOGBOX 0
#define MSGF_MESSAGEBOX 1
#define MSGF_MENU 2
#define MSGF_SCROLLBAR 5
#define MSGF_NEXTWINDOW 6
#define MSGF_MAX 8
#define MSGF_USER 4096

/*

 * Shell support

 */
# 783 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HSHELL_WINDOWCREATED 1
#define HSHELL_WINDOWDESTROYED 2
#define HSHELL_ACTIVATESHELLWINDOW 3


#define HSHELL_WINDOWACTIVATED 4
#define HSHELL_GETMINRECT 5
#define HSHELL_REDRAW 6
#define HSHELL_TASKMAN 7
#define HSHELL_LANGUAGE 8
#define HSHELL_SYSMENU 9
#define HSHELL_ENDTASK 10


#define HSHELL_ACCESSIBILITYSTATE 11
#define HSHELL_APPCOMMAND 12



#define HSHELL_WINDOWREPLACED 13
#define HSHELL_WINDOWREPLACING 14



#define HSHELL_HIGHBIT 0x8000
#define HSHELL_FLASH (HSHELL_REDRAW|HSHELL_HIGHBIT)
#define HSHELL_RUDEAPPACTIVATED (HSHELL_WINDOWACTIVATED|HSHELL_HIGHBIT)


/* cmd for HSHELL_APPCOMMAND and WM_APPCOMMAND */
#define APPCOMMAND_BROWSER_BACKWARD 1
#define APPCOMMAND_BROWSER_FORWARD 2
#define APPCOMMAND_BROWSER_REFRESH 3
#define APPCOMMAND_BROWSER_STOP 4
#define APPCOMMAND_BROWSER_SEARCH 5
#define APPCOMMAND_BROWSER_FAVORITES 6
#define APPCOMMAND_BROWSER_HOME 7
#define APPCOMMAND_VOLUME_MUTE 8
#define APPCOMMAND_VOLUME_DOWN 9
#define APPCOMMAND_VOLUME_UP 10
#define APPCOMMAND_MEDIA_NEXTTRACK 11
#define APPCOMMAND_MEDIA_PREVIOUSTRACK 12
#define APPCOMMAND_MEDIA_STOP 13
#define APPCOMMAND_MEDIA_PLAY_PAUSE 14
#define APPCOMMAND_LAUNCH_MAIL 15
#define APPCOMMAND_LAUNCH_MEDIA_SELECT 16
#define APPCOMMAND_LAUNCH_APP1 17
#define APPCOMMAND_LAUNCH_APP2 18
#define APPCOMMAND_BASS_DOWN 19
#define APPCOMMAND_BASS_BOOST 20
#define APPCOMMAND_BASS_UP 21
#define APPCOMMAND_TREBLE_DOWN 22
#define APPCOMMAND_TREBLE_UP 23

#define APPCOMMAND_MICROPHONE_VOLUME_MUTE 24
#define APPCOMMAND_MICROPHONE_VOLUME_DOWN 25
#define APPCOMMAND_MICROPHONE_VOLUME_UP 26
#define APPCOMMAND_HELP 27
#define APPCOMMAND_FIND 28
#define APPCOMMAND_NEW 29
#define APPCOMMAND_OPEN 30
#define APPCOMMAND_CLOSE 31
#define APPCOMMAND_SAVE 32
#define APPCOMMAND_PRINT 33
#define APPCOMMAND_UNDO 34
#define APPCOMMAND_REDO 35
#define APPCOMMAND_COPY 36
#define APPCOMMAND_CUT 37
#define APPCOMMAND_PASTE 38
#define APPCOMMAND_REPLY_TO_MAIL 39
#define APPCOMMAND_FORWARD_MAIL 40
#define APPCOMMAND_SEND_MAIL 41
#define APPCOMMAND_SPELL_CHECK 42
#define APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE 43
#define APPCOMMAND_MIC_ON_OFF_TOGGLE 44
#define APPCOMMAND_CORRECTION_LIST 45
#define APPCOMMAND_MEDIA_PLAY 46
#define APPCOMMAND_MEDIA_PAUSE 47
#define APPCOMMAND_MEDIA_RECORD 48
#define APPCOMMAND_MEDIA_FAST_FORWARD 49
#define APPCOMMAND_MEDIA_REWIND 50
#define APPCOMMAND_MEDIA_CHANNEL_UP 51
#define APPCOMMAND_MEDIA_CHANNEL_DOWN 52


#define APPCOMMAND_DELETE 53
#define APPCOMMAND_DWM_FLIP3D 54


#define FAPPCOMMAND_MOUSE 0x8000
#define FAPPCOMMAND_KEY 0
#define FAPPCOMMAND_OEM 0x1000
#define FAPPCOMMAND_MASK 0xF000

#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#define GET_DEVICE_LPARAM(lParam) ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))
#define GET_MOUSEORKEY_LPARAM GET_DEVICE_LPARAM
#define GET_FLAGS_LPARAM(lParam) (LOWORD(lParam))
#define GET_KEYSTATE_LPARAM(lParam) GET_FLAGS_LPARAM(lParam)


typedef struct
{
    HWND hwnd;
    RECT rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;

/*

 * Message Structure used in Journaling

 */
# 893 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagEVENTMSG {
    UINT message;
    UINT paramL;
    UINT paramH;
    DWORD time;
    HWND hwnd;
} EVENTMSG, *PEVENTMSGMSG, *NPEVENTMSGMSG, *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG, *NPEVENTMSG, *LPEVENTMSG;

/*

 * Message structure used by WH_CALLWNDPROC

 */
# 906 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCWPSTRUCT {
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPSTRUCT, *PCWPSTRUCT, *NPCWPSTRUCT, *LPCWPSTRUCT;


/*

 * Message structure used by WH_CALLWNDPROCRET

 */
# 917 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT, *NPCWPRETSTRUCT, *LPCWPRETSTRUCT;





/*

 * Low level hook flags

 */
# 933 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define LLKHF_EXTENDED (KF_EXTENDED >> 8)
#define LLKHF_INJECTED 0x00000010
#define LLKHF_ALTDOWN (KF_ALTDOWN >> 8)
#define LLKHF_UP (KF_UP >> 8)

#define LLMHF_INJECTED 0x00000001

/*

 * Structure used by WH_KEYBOARD_LL

 */
# 943 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagKBDLLHOOKSTRUCT {
    DWORD vkCode;
    DWORD scanCode;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;

/*

 * Structure used by WH_MOUSE_LL

 */
# 954 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMSLLHOOKSTRUCT {
    POINT pt;
    DWORD mouseData;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;



/*

 * Structure used by WH_DEBUG

 */
# 967 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagDEBUGHOOKINFO
{
    DWORD idThread;
    DWORD idThreadInstaller;
    LPARAM lParam;
    WPARAM wParam;
    int code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, *NPDEBUGHOOKINFO, * LPDEBUGHOOKINFO;

/*

 * Structure used by WH_MOUSE

 */
# 979 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMOUSEHOOKSTRUCT {
    POINT pt;
    HWND hwnd;
    UINT wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT, *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;
# 993 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMOUSEHOOKSTRUCTEX
{
    MOUSEHOOKSTRUCT;
    DWORD mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;




/*

 * Structure used by WH_HARDWARE

 */
# 1005 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagHARDWAREHOOKSTRUCT {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
} HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;



/*

 * Keyboard Layout API

 */
# 1017 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HKL_PREV 0
#define HKL_NEXT 1


#define KLF_ACTIVATE 0x00000001
#define KLF_SUBSTITUTE_OK 0x00000002
#define KLF_REORDER 0x00000008

#define KLF_REPLACELANG 0x00000010
#define KLF_NOTELLSHELL 0x00000080

#define KLF_SETFORPROCESS 0x00000100

#define KLF_SHIFTLOCK 0x00010000
#define KLF_RESET 0x40000000




/*

 * Bits in wParam of WM_INPUTLANGCHANGEREQUEST message

 */
# 1039 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define INPUTLANGCHANGE_SYSCHARSET 0x0001
#define INPUTLANGCHANGE_FORWARD 0x0002
#define INPUTLANGCHANGE_BACKWARD 0x0004


/*

 * Size of KeyboardLayoutName (number of characters), including nul terminator

 */
# 1047 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define KL_NAMELENGTH 9


HKL

LoadKeyboardLayoutA(
    LPCSTR pwszKLID,
    UINT Flags);

HKL

LoadKeyboardLayoutW(
    LPCWSTR pwszKLID,
    UINT Flags);



#define LoadKeyboardLayout LoadKeyboardLayoutA





HKL

ActivateKeyboardLayout(
    HKL hkl,
    UINT Flags);
# 1085 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

int

ToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    const BYTE *lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags,
    HKL dwhkl);



BOOL

UnloadKeyboardLayout(
    HKL hkl);


BOOL

GetKeyboardLayoutNameA(
    LPSTR pwszKLID);

BOOL

GetKeyboardLayoutNameW(
    LPWSTR pwszKLID);



#define GetKeyboardLayoutName GetKeyboardLayoutNameA




int

GetKeyboardLayoutList(
    int nBuff,
    HKL *lpList);


HKL

GetKeyboardLayout(
    DWORD idThread);






typedef struct tagMOUSEMOVEPOINT {
    int x;
    int y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, * LPMOUSEMOVEPOINT;

/*

 * Values for resolution parameter of GetMouseMovePointsEx

 */
# 1149 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GMMP_USE_DISPLAY_POINTS 1
#define GMMP_USE_HIGH_RESOLUTION_POINTS 2


int

GetMouseMovePointsEx(
    UINT cbSize,
    LPMOUSEMOVEPOINT lppt,
    LPMOUSEMOVEPOINT lpptBuf,
    int nBufPoints,
    DWORD resolution);




/*

 * Desktop-specific access flags

 */
# 1168 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DESKTOP_READOBJECTS 0x0001L
#define DESKTOP_CREATEWINDOW 0x0002L
#define DESKTOP_CREATEMENU 0x0004L
#define DESKTOP_HOOKCONTROL 0x0008L
#define DESKTOP_JOURNALRECORD 0x0010L
#define DESKTOP_JOURNALPLAYBACK 0x0020L
#define DESKTOP_ENUMERATE 0x0040L
#define DESKTOP_WRITEOBJECTS 0x0080L
#define DESKTOP_SWITCHDESKTOP 0x0100L

/*

 * Desktop-specific control flags

 */
# 1181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DF_ALLOWOTHERACCOUNTHOOK 0x0001L





HDESK

CreateDesktopA(
    LPCSTR lpszDesktop,
    LPCSTR lpszDevice,
    DEVMODEA* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);

HDESK

CreateDesktopW(
    LPCWSTR lpszDesktop,
    LPCWSTR lpszDevice,
    DEVMODEW* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);



#define CreateDesktop CreateDesktopA



HDESK

CreateDesktopExA(
    LPCSTR lpszDesktop,
    LPCSTR lpszDevice,
    DEVMODEA* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa,
    ULONG ulHeapSize,
    PVOID pvoid);

HDESK

CreateDesktopExW(
    LPCWSTR lpszDesktop,
    LPCWSTR lpszDevice,
    DEVMODEW* pDevmode,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa,
    ULONG ulHeapSize,
    PVOID pvoid);



#define CreateDesktopEx CreateDesktopExA






HDESK

OpenDesktopA(
    LPCSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);

HDESK

OpenDesktopW(
    LPCWSTR lpszDesktop,
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);



#define OpenDesktop OpenDesktopA



HDESK

OpenInputDesktop(
    DWORD dwFlags,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);



BOOL

EnumDesktopsA(
    HWINSTA hwinsta,
    DESKTOPENUMPROCA lpEnumFunc,
    LPARAM lParam);

BOOL

EnumDesktopsW(
    HWINSTA hwinsta,
    DESKTOPENUMPROCW lpEnumFunc,
    LPARAM lParam);



#define EnumDesktops EnumDesktopsA



BOOL

EnumDesktopWindows(
    HDESK hDesktop,
    WNDENUMPROC lpfn,
    LPARAM lParam);


BOOL

SwitchDesktop(
    HDESK hDesktop);



BOOL

SetThreadDesktop(
     HDESK hDesktop);


BOOL

CloseDesktop(
    HDESK hDesktop);


HDESK

GetThreadDesktop(
    DWORD dwThreadId);




/*

 * Windowstation-specific access flags

 */
# 1335 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WINSTA_ENUMDESKTOPS 0x0001L
#define WINSTA_READATTRIBUTES 0x0002L
#define WINSTA_ACCESSCLIPBOARD 0x0004L
#define WINSTA_CREATEDESKTOP 0x0008L
#define WINSTA_WRITEATTRIBUTES 0x0010L
#define WINSTA_ACCESSGLOBALATOMS 0x0020L
#define WINSTA_EXITWINDOWS 0x0040L
#define WINSTA_ENUMERATE 0x0100L
#define WINSTA_READSCREEN 0x0200L

#define WINSTA_ALL_ACCESS (WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES | WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | WINSTA_ENUMERATE | WINSTA_READSCREEN)



/*

 * Windowstation creation flags.

 */
# 1352 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CWF_CREATE_ONLY 0x00000001

/*

 * Windowstation-specific attribute flags

 */
# 1357 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WSF_VISIBLE 0x0001L


HWINSTA

CreateWindowStationA(
    LPCSTR lpwinsta,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);

HWINSTA

CreateWindowStationW(
    LPCWSTR lpwinsta,
    DWORD dwFlags,
    ACCESS_MASK dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpsa);



#define CreateWindowStation CreateWindowStationA



HWINSTA

OpenWindowStationA(
    LPCSTR lpszWinSta,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);

HWINSTA

OpenWindowStationW(
    LPCWSTR lpszWinSta,
    BOOL fInherit,
    ACCESS_MASK dwDesiredAccess);



#define OpenWindowStation OpenWindowStationA



BOOL

EnumWindowStationsA(
    WINSTAENUMPROCA lpEnumFunc,
    LPARAM lParam);

BOOL

EnumWindowStationsW(
    WINSTAENUMPROCW lpEnumFunc,
    LPARAM lParam);



#define EnumWindowStations EnumWindowStationsA



BOOL

CloseWindowStation(
    HWINSTA hWinSta);


BOOL

SetProcessWindowStation(
    HWINSTA hWinSta);


HWINSTA

GetProcessWindowStation(
    void);





BOOL

SetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID);


BOOL

GetUserObjectSecurity(
    HANDLE hObj,
    PSECURITY_INFORMATION pSIRequested,
    PSECURITY_DESCRIPTOR pSID,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);

#define UOI_FLAGS 1
#define UOI_NAME 2
#define UOI_TYPE 3
#define UOI_USER_SID 4

#define UOI_HEAPSIZE 5
#define UOI_IO 6


typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;


BOOL

GetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);

BOOL

GetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded);



#define GetUserObjectInformation GetUserObjectInformationA



BOOL

SetUserObjectInformationA(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);

BOOL

SetUserObjectInformationW(
    HANDLE hObj,
    int nIndex,
    PVOID pvInfo,
    DWORD nLength);



#define SetUserObjectInformation SetUserObjectInformationA





typedef struct tagWNDCLASSEXA {
    UINT cbSize;
    /* Win 3.x */
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;
    /* Win 4.0 */
    HICON hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA, *NPWNDCLASSEXA, *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT cbSize;
    /* Win 3.x */
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
    /* Win 4.0 */
    HICON hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW, *NPWNDCLASSEXW, *LPWNDCLASSEXW;






typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;



typedef struct tagWNDCLASSA {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCSTR lpszMenuName;
    LPCSTR lpszClassName;
} WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
} WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;






typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;



BOOL

IsHungAppWindow(
    HWND hwnd);




void

DisableProcessWindowsGhosting(
    void);





/*

 * Message structure

 */
# 1624 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMSG {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;



} MSG, *PMSG, *NPMSG, *LPMSG;

#define POINTSTOPOINT(pt,pts) { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts); (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); }



#define POINTTOPOINTS(pt) (MAKELONG((short)((pt).x), (short)((pt).y)))
#define MAKEWPARAM(l,h) ((WPARAM)(DWORD)MAKELONG(l, h))
#define MAKELPARAM(l,h) ((LPARAM)(DWORD)MAKELONG(l, h))
#define MAKELRESULT(l,h) ((LRESULT)(DWORD)MAKELONG(l, h))






/*

 * Window field offsets for GetWindowLong()

 */
# 1653 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GWL_WNDPROC (-4)
#define GWL_HINSTANCE (-6)
#define GWL_HWNDPARENT (-8)
#define GWL_STYLE (-16)
#define GWL_EXSTYLE (-20)
#define GWL_USERDATA (-21)
#define GWL_ID (-12)



#undef GWL_WNDPROC
#undef GWL_HINSTANCE
#undef GWL_HWNDPARENT
#undef GWL_USERDATA



#define GWLP_WNDPROC (-4)
#define GWLP_HINSTANCE (-6)
#define GWLP_HWNDPARENT (-8)
#define GWLP_USERDATA (-21)
#define GWLP_ID (-12)

/*

 * Class field offsets for GetClassLong()

 */
# 1679 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GCL_MENUNAME (-8)
#define GCL_HBRBACKGROUND (-10)
#define GCL_HCURSOR (-12)
#define GCL_HICON (-14)
#define GCL_HMODULE (-16)
#define GCL_CBWNDEXTRA (-18)
#define GCL_CBCLSEXTRA (-20)
#define GCL_WNDPROC (-24)
#define GCL_STYLE (-26)
#define GCW_ATOM (-32)


#define GCL_HICONSM (-34)




#undef GCL_MENUNAME
#undef GCL_HBRBACKGROUND
#undef GCL_HCURSOR
#undef GCL_HICON
#undef GCL_HMODULE
#undef GCL_WNDPROC
#undef GCL_HICONSM



#define GCLP_MENUNAME (-8)
#define GCLP_HBRBACKGROUND (-10)
#define GCLP_HCURSOR (-12)
#define GCLP_HICON (-14)
#define GCLP_HMODULE (-16)
#define GCLP_WNDPROC (-24)
#define GCLP_HICONSM (-34)






/*

 * Window Messages

 */
# 1723 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WM_NULL 0x0000
#define WM_CREATE 0x0001
#define WM_DESTROY 0x0002
#define WM_MOVE 0x0003
#define WM_SIZE 0x0005

#define WM_ACTIVATE 0x0006
/*

 * WM_ACTIVATE state values

 */
# 1733 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WA_INACTIVE 0
#define WA_ACTIVE 1
#define WA_CLICKACTIVE 2

#define WM_SETFOCUS 0x0007
#define WM_KILLFOCUS 0x0008
#define WM_ENABLE 0x000A
#define WM_SETREDRAW 0x000B
#define WM_SETTEXT 0x000C
#define WM_GETTEXT 0x000D
#define WM_GETTEXTLENGTH 0x000E
#define WM_PAINT 0x000F
#define WM_CLOSE 0x0010

#define WM_QUERYENDSESSION 0x0011
#define WM_QUERYOPEN 0x0013
#define WM_ENDSESSION 0x0016

#define WM_QUIT 0x0012
#define WM_ERASEBKGND 0x0014
#define WM_SYSCOLORCHANGE 0x0015
#define WM_SHOWWINDOW 0x0018
#define WM_WININICHANGE 0x001A

#define WM_SETTINGCHANGE WM_WININICHANGE



#define WM_DEVMODECHANGE 0x001B
#define WM_ACTIVATEAPP 0x001C
#define WM_FONTCHANGE 0x001D
#define WM_TIMECHANGE 0x001E
#define WM_CANCELMODE 0x001F
#define WM_SETCURSOR 0x0020
#define WM_MOUSEACTIVATE 0x0021
#define WM_CHILDACTIVATE 0x0022
#define WM_QUEUESYNC 0x0023

#define WM_GETMINMAXINFO 0x0024
/*

 * Struct pointed to by WM_GETMINMAXINFO lParam

 */
# 1775 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;

#define WM_PAINTICON 0x0026
#define WM_ICONERASEBKGND 0x0027
#define WM_NEXTDLGCTL 0x0028
#define WM_SPOOLERSTATUS 0x002A
#define WM_DRAWITEM 0x002B
#define WM_MEASUREITEM 0x002C
#define WM_DELETEITEM 0x002D
#define WM_VKEYTOITEM 0x002E
#define WM_CHARTOITEM 0x002F
#define WM_SETFONT 0x0030
#define WM_GETFONT 0x0031
#define WM_SETHOTKEY 0x0032
#define WM_GETHOTKEY 0x0033
#define WM_QUERYDRAGICON 0x0037
#define WM_COMPAREITEM 0x0039


#define WM_GETOBJECT 0x003D


#define WM_COMPACTING 0x0041
#define WM_COMMNOTIFY 0x0044
#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

#define WM_POWER 0x0048
/*

 * wParam for WM_POWER window message and DRV_POWER driver notification

 */
# 1812 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define PWR_OK 1
#define PWR_FAIL (-1)
#define PWR_SUSPENDREQUEST 1
#define PWR_SUSPENDRESUME 2
#define PWR_CRITICALRESUME 3

#define WM_COPYDATA 0x004A
#define WM_CANCELJOURNAL 0x004B


/*

 * lParam of WM_COPYDATA message points to...

 */
# 1825 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;


typedef struct tagMDINEXTMENU
{
    HMENU hmenuIn;
    HMENU hmenuNext;
    HWND hwndNext;
} MDINEXTMENU, * PMDINEXTMENU, * LPMDINEXTMENU;




#define WM_NOTIFY 0x004E
#define WM_INPUTLANGCHANGEREQUEST 0x0050
#define WM_INPUTLANGCHANGE 0x0051
#define WM_TCARD 0x0052
#define WM_HELP 0x0053
#define WM_USERCHANGED 0x0054
#define WM_NOTIFYFORMAT 0x0055

#define NFR_ANSI 1
#define NFR_UNICODE 2
#define NF_QUERY 3
#define NF_REQUERY 4

#define WM_CONTEXTMENU 0x007B
#define WM_STYLECHANGING 0x007C
#define WM_STYLECHANGED 0x007D
#define WM_DISPLAYCHANGE 0x007E
#define WM_GETICON 0x007F
#define WM_SETICON 0x0080


#define WM_NCCREATE 0x0081
#define WM_NCDESTROY 0x0082
#define WM_NCCALCSIZE 0x0083
#define WM_NCHITTEST 0x0084
#define WM_NCPAINT 0x0085
#define WM_NCACTIVATE 0x0086
#define WM_GETDLGCODE 0x0087

#define WM_SYNCPAINT 0x0088

#define WM_NCMOUSEMOVE 0x00A0
#define WM_NCLBUTTONDOWN 0x00A1
#define WM_NCLBUTTONUP 0x00A2
#define WM_NCLBUTTONDBLCLK 0x00A3
#define WM_NCRBUTTONDOWN 0x00A4
#define WM_NCRBUTTONUP 0x00A5
#define WM_NCRBUTTONDBLCLK 0x00A6
#define WM_NCMBUTTONDOWN 0x00A7
#define WM_NCMBUTTONUP 0x00A8
#define WM_NCMBUTTONDBLCLK 0x00A9




#define WM_NCXBUTTONDOWN 0x00AB
#define WM_NCXBUTTONUP 0x00AC
#define WM_NCXBUTTONDBLCLK 0x00AD




#define WM_INPUT_DEVICE_CHANGE 0x00FE



#define WM_INPUT 0x00FF


#define WM_KEYFIRST 0x0100
#define WM_KEYDOWN 0x0100
#define WM_KEYUP 0x0101
#define WM_CHAR 0x0102
#define WM_DEADCHAR 0x0103
#define WM_SYSKEYDOWN 0x0104
#define WM_SYSKEYUP 0x0105
#define WM_SYSCHAR 0x0106
#define WM_SYSDEADCHAR 0x0107

#define WM_UNICHAR 0x0109
#define WM_KEYLAST 0x0109
#define UNICODE_NOCHAR 0xFFFF





#define WM_IME_STARTCOMPOSITION 0x010D
#define WM_IME_ENDCOMPOSITION 0x010E
#define WM_IME_COMPOSITION 0x010F
#define WM_IME_KEYLAST 0x010F


#define WM_INITDIALOG 0x0110
#define WM_COMMAND 0x0111
#define WM_SYSCOMMAND 0x0112
#define WM_TIMER 0x0113
#define WM_HSCROLL 0x0114
#define WM_VSCROLL 0x0115
#define WM_INITMENU 0x0116
#define WM_INITMENUPOPUP 0x0117

#define WM_GESTURE 0x0119
#define WM_GESTURENOTIFY 0x011A

#define WM_MENUSELECT 0x011F
#define WM_MENUCHAR 0x0120
#define WM_ENTERIDLE 0x0121


#define WM_MENURBUTTONUP 0x0122
#define WM_MENUDRAG 0x0123
#define WM_MENUGETOBJECT 0x0124
#define WM_UNINITMENUPOPUP 0x0125
#define WM_MENUCOMMAND 0x0126



#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE 0x0129

/*

 * LOWORD(wParam) values in WM_*UISTATE*

 */
# 1957 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define UIS_SET 1
#define UIS_CLEAR 2
#define UIS_INITIALIZE 3

/*

 * HIWORD(wParam) values in WM_*UISTATE*

 */
# 1964 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define UISF_HIDEFOCUS 0x1
#define UISF_HIDEACCEL 0x2

#define UISF_ACTIVE 0x4







#define WM_CTLCOLORMSGBOX 0x0132
#define WM_CTLCOLOREDIT 0x0133
#define WM_CTLCOLORLISTBOX 0x0134
#define WM_CTLCOLORBTN 0x0135
#define WM_CTLCOLORDLG 0x0136
#define WM_CTLCOLORSCROLLBAR 0x0137
#define WM_CTLCOLORSTATIC 0x0138
#define MN_GETHMENU 0x01E1

#define WM_MOUSEFIRST 0x0200
#define WM_MOUSEMOVE 0x0200
#define WM_LBUTTONDOWN 0x0201
#define WM_LBUTTONUP 0x0202
#define WM_LBUTTONDBLCLK 0x0203
#define WM_RBUTTONDOWN 0x0204
#define WM_RBUTTONUP 0x0205
#define WM_RBUTTONDBLCLK 0x0206
#define WM_MBUTTONDOWN 0x0207
#define WM_MBUTTONUP 0x0208
#define WM_MBUTTONDBLCLK 0x0209

#define WM_MOUSEWHEEL 0x020A


#define WM_XBUTTONDOWN 0x020B
#define WM_XBUTTONUP 0x020C
#define WM_XBUTTONDBLCLK 0x020D


#define WM_MOUSEHWHEEL 0x020E



#define WM_MOUSELAST 0x020E
# 2019 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/* Value for rolling one detent */
#define WHEEL_DELTA 120
#define GET_WHEEL_DELTA_WPARAM(wParam) ((short)HIWORD(wParam))

/* Setting to scroll one page for SPI_GET/SETWHEELSCROLLLINES */
#define WHEEL_PAGESCROLL (UINT_MAX)



#define GET_KEYSTATE_WPARAM(wParam) (LOWORD(wParam))
#define GET_NCHITTEST_WPARAM(wParam) ((short)LOWORD(wParam))
#define GET_XBUTTON_WPARAM(wParam) (HIWORD(wParam))

/* XButton values are WORD flags */
#define XBUTTON1 0x0001
#define XBUTTON2 0x0002
/* Were there to be an XBUTTON3, its value would be 0x0004 */


#define WM_PARENTNOTIFY 0x0210
#define WM_ENTERMENULOOP 0x0211
#define WM_EXITMENULOOP 0x0212


#define WM_NEXTMENU 0x0213
#define WM_SIZING 0x0214
#define WM_CAPTURECHANGED 0x0215
#define WM_MOVING 0x0216





#define WM_POWERBROADCAST 0x0218


#define PBT_APMQUERYSUSPEND 0x0000
#define PBT_APMQUERYSTANDBY 0x0001

#define PBT_APMQUERYSUSPENDFAILED 0x0002
#define PBT_APMQUERYSTANDBYFAILED 0x0003

#define PBT_APMSUSPEND 0x0004
#define PBT_APMSTANDBY 0x0005

#define PBT_APMRESUMECRITICAL 0x0006
#define PBT_APMRESUMESUSPEND 0x0007
#define PBT_APMRESUMESTANDBY 0x0008

#define PBTF_APMRESUMEFROMFAILURE 0x00000001

#define PBT_APMBATTERYLOW 0x0009
#define PBT_APMPOWERSTATUSCHANGE 0x000A

#define PBT_APMOEMEVENT 0x000B


#define PBT_APMRESUMEAUTOMATIC 0x0012


#define PBT_POWERSETTINGCHANGE 0x8013
typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;
# 2095 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WM_DEVICECHANGE 0x0219


#define WM_MDICREATE 0x0220
#define WM_MDIDESTROY 0x0221
#define WM_MDIACTIVATE 0x0222
#define WM_MDIRESTORE 0x0223
#define WM_MDINEXT 0x0224
#define WM_MDIMAXIMIZE 0x0225
#define WM_MDITILE 0x0226
#define WM_MDICASCADE 0x0227
#define WM_MDIICONARRANGE 0x0228
#define WM_MDIGETACTIVE 0x0229


#define WM_MDISETMENU 0x0230
#define WM_ENTERSIZEMOVE 0x0231
#define WM_EXITSIZEMOVE 0x0232
#define WM_DROPFILES 0x0233
#define WM_MDIREFRESHMENU 0x0234


#define WM_TOUCH 0x0240




#define WM_IME_SETCONTEXT 0x0281
#define WM_IME_NOTIFY 0x0282
#define WM_IME_CONTROL 0x0283
#define WM_IME_COMPOSITIONFULL 0x0284
#define WM_IME_SELECT 0x0285
#define WM_IME_CHAR 0x0286


#define WM_IME_REQUEST 0x0288


#define WM_IME_KEYDOWN 0x0290
#define WM_IME_KEYUP 0x0291



#define WM_MOUSEHOVER 0x02A1
#define WM_MOUSELEAVE 0x02A3


#define WM_NCMOUSEHOVER 0x02A0
#define WM_NCMOUSELEAVE 0x02A2



#define WM_WTSSESSION_CHANGE 0x02B1

#define WM_TABLET_FIRST 0x02c0
#define WM_TABLET_LAST 0x02df


#define WM_CUT 0x0300
#define WM_COPY 0x0301
#define WM_PASTE 0x0302
#define WM_CLEAR 0x0303
#define WM_UNDO 0x0304
#define WM_RENDERFORMAT 0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307
#define WM_DRAWCLIPBOARD 0x0308
#define WM_PAINTCLIPBOARD 0x0309
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_SIZECLIPBOARD 0x030B
#define WM_ASKCBFORMATNAME 0x030C
#define WM_CHANGECBCHAIN 0x030D
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_QUERYNEWPALETTE 0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED 0x0311
#define WM_HOTKEY 0x0312


#define WM_PRINT 0x0317
#define WM_PRINTCLIENT 0x0318



#define WM_APPCOMMAND 0x0319



#define WM_THEMECHANGED 0x031A




#define WM_CLIPBOARDUPDATE 0x031D



#define WM_DWMCOMPOSITIONCHANGED 0x031E
#define WM_DWMNCRENDERINGCHANGED 0x031F
#define WM_DWMCOLORIZATIONCOLORCHANGED 0x0320
#define WM_DWMWINDOWMAXIMIZEDCHANGE 0x0321



#define WM_DWMSENDICONICTHUMBNAIL 0x0323
#define WM_DWMSENDICONICLIVEPREVIEWBITMAP 0x0326




#define WM_GETTITLEBARINFOEX 0x033F




#define WM_HANDHELDFIRST 0x0358
#define WM_HANDHELDLAST 0x035F

#define WM_AFXFIRST 0x0360
#define WM_AFXLAST 0x037F


#define WM_PENWINFIRST 0x0380
#define WM_PENWINLAST 0x038F



#define WM_APP 0x8000



/*

 * NOTE: All Message Numbers below 0x0400 are RESERVED.

 *

 * Private Window Messages Start Here:

 */
# 2231 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WM_USER 0x0400



/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT 1
#define WMSZ_RIGHT 2
#define WMSZ_TOP 3
#define WMSZ_TOPLEFT 4
#define WMSZ_TOPRIGHT 5
#define WMSZ_BOTTOM 6
#define WMSZ_BOTTOMLEFT 7
#define WMSZ_BOTTOMRIGHT 8




/*

 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes

 */
# 2251 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HTERROR (-2)
#define HTTRANSPARENT (-1)
#define HTNOWHERE 0
#define HTCLIENT 1
#define HTCAPTION 2
#define HTSYSMENU 3
#define HTGROWBOX 4
#define HTSIZE HTGROWBOX
#define HTMENU 5
#define HTHSCROLL 6
#define HTVSCROLL 7
#define HTMINBUTTON 8
#define HTMAXBUTTON 9
#define HTLEFT 10
#define HTRIGHT 11
#define HTTOP 12
#define HTTOPLEFT 13
#define HTTOPRIGHT 14
#define HTBOTTOM 15
#define HTBOTTOMLEFT 16
#define HTBOTTOMRIGHT 17
#define HTBORDER 18
#define HTREDUCE HTMINBUTTON
#define HTZOOM HTMAXBUTTON
#define HTSIZEFIRST HTLEFT
#define HTSIZELAST HTBOTTOMRIGHT

#define HTOBJECT 19
#define HTCLOSE 20
#define HTHELP 21



/*

 * SendMessageTimeout values

 */
# 2287 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SMTO_NORMAL 0x0000
#define SMTO_BLOCK 0x0001
#define SMTO_ABORTIFHUNG 0x0002

#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008


#define SMTO_ERRORONEXIT 0x0020




/*

 * WM_MOUSEACTIVATE Return Codes

 */
# 2302 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MA_ACTIVATE 1
#define MA_ACTIVATEANDEAT 2
#define MA_NOACTIVATE 3
#define MA_NOACTIVATEANDEAT 4

/*

 * WM_SETICON / WM_GETICON Type Codes

 */
# 2310 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ICON_SMALL 0
#define ICON_BIG 1

#define ICON_SMALL2 2




UINT

RegisterWindowMessageA(
    LPCSTR lpString);

UINT

RegisterWindowMessageW(
    LPCWSTR lpString);



#define RegisterWindowMessage RegisterWindowMessageA



/*

 * WM_SIZE message wParam values

 */
# 2337 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SIZE_RESTORED 0
#define SIZE_MINIMIZED 1
#define SIZE_MAXIMIZED 2
#define SIZE_MAXSHOW 3
#define SIZE_MAXHIDE 4

/*

 * Obsolete constant names

 */
# 2346 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SIZENORMAL SIZE_RESTORED
#define SIZEICONIC SIZE_MINIMIZED
#define SIZEFULLSCREEN SIZE_MAXIMIZED
#define SIZEZOOMSHOW SIZE_MAXSHOW
#define SIZEZOOMHIDE SIZE_MAXHIDE

/*

 * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam

 */
# 2355 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagWINDOWPOS {
    HWND hwnd;
    HWND hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    UINT flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;

/*

 * WM_NCCALCSIZE parameter structure

 */
# 2368 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagNCCALCSIZE_PARAMS {
    RECT rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

/*

 * WM_NCCALCSIZE "window valid rect" return values

 */
# 2376 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WVR_ALIGNTOP 0x0010
#define WVR_ALIGNLEFT 0x0020
#define WVR_ALIGNBOTTOM 0x0040
#define WVR_ALIGNRIGHT 0x0080
#define WVR_HREDRAW 0x0100
#define WVR_VREDRAW 0x0200
#define WVR_REDRAW (WVR_HREDRAW | WVR_VREDRAW)

#define WVR_VALIDRECTS 0x0400




/*

 * Key State Masks for Mouse Messages

 */
# 2392 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MK_LBUTTON 0x0001
#define MK_RBUTTON 0x0002
#define MK_SHIFT 0x0004
#define MK_CONTROL 0x0008
#define MK_MBUTTON 0x0010

#define MK_XBUTTON1 0x0020
#define MK_XBUTTON2 0x0040
# 2408 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define TME_HOVER 0x00000001
#define TME_LEAVE 0x00000002

#define TME_NONCLIENT 0x00000010

#define TME_QUERY 0x40000000
#define TME_CANCEL 0x80000000


#define HOVER_DEFAULT 0xFFFFFFFF



typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;


BOOL

TrackMouseEvent(
    LPTRACKMOUSEEVENT lpEventTrack);
# 2446 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Window Styles

 */
# 2449 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WS_OVERLAPPED 0x00000000L
#define WS_POPUP 0x80000000L
#define WS_CHILD 0x40000000L
#define WS_MINIMIZE 0x20000000L
#define WS_VISIBLE 0x10000000L
#define WS_DISABLED 0x08000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_MAXIMIZE 0x01000000L
#define WS_CAPTION 0x00C00000L
#define WS_BORDER 0x00800000L
#define WS_DLGFRAME 0x00400000L
#define WS_VSCROLL 0x00200000L
#define WS_HSCROLL 0x00100000L
#define WS_SYSMENU 0x00080000L
#define WS_THICKFRAME 0x00040000L
#define WS_GROUP 0x00020000L
#define WS_TABSTOP 0x00010000L

#define WS_MINIMIZEBOX 0x00020000L
#define WS_MAXIMIZEBOX 0x00010000L


#define WS_TILED WS_OVERLAPPED
#define WS_ICONIC WS_MINIMIZE
#define WS_SIZEBOX WS_THICKFRAME
#define WS_TILEDWINDOW WS_OVERLAPPEDWINDOW

/*

 * Common Window Styles

 */
# 2480 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)






#define WS_POPUPWINDOW (WS_POPUP | WS_BORDER | WS_SYSMENU)



#define WS_CHILDWINDOW (WS_CHILD)

/*

 * Extended Window Styles

 */
# 2496 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WS_EX_DLGMODALFRAME 0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L
#define WS_EX_TOPMOST 0x00000008L
#define WS_EX_ACCEPTFILES 0x00000010L
#define WS_EX_TRANSPARENT 0x00000020L

#define WS_EX_MDICHILD 0x00000040L
#define WS_EX_TOOLWINDOW 0x00000080L
#define WS_EX_WINDOWEDGE 0x00000100L
#define WS_EX_CLIENTEDGE 0x00000200L
#define WS_EX_CONTEXTHELP 0x00000400L




#define WS_EX_RIGHT 0x00001000L
#define WS_EX_LEFT 0x00000000L
#define WS_EX_RTLREADING 0x00002000L
#define WS_EX_LTRREADING 0x00000000L
#define WS_EX_LEFTSCROLLBAR 0x00004000L
#define WS_EX_RIGHTSCROLLBAR 0x00000000L

#define WS_EX_CONTROLPARENT 0x00010000L
#define WS_EX_STATICEDGE 0x00020000L
#define WS_EX_APPWINDOW 0x00040000L


#define WS_EX_OVERLAPPEDWINDOW (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)




#define WS_EX_LAYERED 0x00080000





#define WS_EX_NOINHERITLAYOUT 0x00100000L
#define WS_EX_LAYOUTRTL 0x00400000L



#define WS_EX_COMPOSITED 0x02000000L


#define WS_EX_NOACTIVATE 0x08000000L



/*

 * Class styles

 */
# 2550 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CS_VREDRAW 0x0001
#define CS_HREDRAW 0x0002
#define CS_DBLCLKS 0x0008
#define CS_OWNDC 0x0020
#define CS_CLASSDC 0x0040
#define CS_PARENTDC 0x0080
#define CS_NOCLOSE 0x0200
#define CS_SAVEBITS 0x0800
#define CS_BYTEALIGNCLIENT 0x1000
#define CS_BYTEALIGNWINDOW 0x2000
#define CS_GLOBALCLASS 0x4000

#define CS_IME 0x00010000

#define CS_DROPSHADOW 0x00020000






/* WM_PRINT flags */
#define PRF_CHECKVISIBLE 0x00000001L
#define PRF_NONCLIENT 0x00000002L
#define PRF_CLIENT 0x00000004L
#define PRF_ERASEBKGND 0x00000008L
#define PRF_CHILDREN 0x00000010L
#define PRF_OWNED 0x00000020L

/* 3D border styles */
#define BDR_RAISEDOUTER 0x0001
#define BDR_SUNKENOUTER 0x0002
#define BDR_RAISEDINNER 0x0004
#define BDR_SUNKENINNER 0x0008

#define BDR_OUTER (BDR_RAISEDOUTER | BDR_SUNKENOUTER)
#define BDR_INNER (BDR_RAISEDINNER | BDR_SUNKENINNER)
#define BDR_RAISED (BDR_RAISEDOUTER | BDR_RAISEDINNER)
#define BDR_SUNKEN (BDR_SUNKENOUTER | BDR_SUNKENINNER)


#define EDGE_RAISED (BDR_RAISEDOUTER | BDR_RAISEDINNER)
#define EDGE_SUNKEN (BDR_SUNKENOUTER | BDR_SUNKENINNER)
#define EDGE_ETCHED (BDR_SUNKENOUTER | BDR_RAISEDINNER)
#define EDGE_BUMP (BDR_RAISEDOUTER | BDR_SUNKENINNER)

/* Border flags */
#define BF_LEFT 0x0001
#define BF_TOP 0x0002
#define BF_RIGHT 0x0004
#define BF_BOTTOM 0x0008

#define BF_TOPLEFT (BF_TOP | BF_LEFT)
#define BF_TOPRIGHT (BF_TOP | BF_RIGHT)
#define BF_BOTTOMLEFT (BF_BOTTOM | BF_LEFT)
#define BF_BOTTOMRIGHT (BF_BOTTOM | BF_RIGHT)
#define BF_RECT (BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM)

#define BF_DIAGONAL 0x0010

// For diagonal lines, the BF_RECT flags specify the end point of the
// vector bounded by the rectangle parameter.
#define BF_DIAGONAL_ENDTOPRIGHT (BF_DIAGONAL | BF_TOP | BF_RIGHT)
#define BF_DIAGONAL_ENDTOPLEFT (BF_DIAGONAL | BF_TOP | BF_LEFT)
#define BF_DIAGONAL_ENDBOTTOMLEFT (BF_DIAGONAL | BF_BOTTOM | BF_LEFT)
#define BF_DIAGONAL_ENDBOTTOMRIGHT (BF_DIAGONAL | BF_BOTTOM | BF_RIGHT)


#define BF_MIDDLE 0x0800
#define BF_SOFT 0x1000
#define BF_ADJUST 0x2000
#define BF_FLAT 0x4000
#define BF_MONO 0x8000



BOOL

DrawEdge(
    HDC hdc,
    LPRECT qrc,
    UINT edge,
    UINT grfFlags);

/* flags for DrawFrameControl */

#define DFC_CAPTION 1
#define DFC_MENU 2
#define DFC_SCROLL 3
#define DFC_BUTTON 4

#define DFC_POPUPMENU 5


#define DFCS_CAPTIONCLOSE 0x0000
#define DFCS_CAPTIONMIN 0x0001
#define DFCS_CAPTIONMAX 0x0002
#define DFCS_CAPTIONRESTORE 0x0003
#define DFCS_CAPTIONHELP 0x0004

#define DFCS_MENUARROW 0x0000
#define DFCS_MENUCHECK 0x0001
#define DFCS_MENUBULLET 0x0002
#define DFCS_MENUARROWRIGHT 0x0004
#define DFCS_SCROLLUP 0x0000
#define DFCS_SCROLLDOWN 0x0001
#define DFCS_SCROLLLEFT 0x0002
#define DFCS_SCROLLRIGHT 0x0003
#define DFCS_SCROLLCOMBOBOX 0x0005
#define DFCS_SCROLLSIZEGRIP 0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK 0x0000
#define DFCS_BUTTONRADIOIMAGE 0x0001
#define DFCS_BUTTONRADIOMASK 0x0002
#define DFCS_BUTTONRADIO 0x0004
#define DFCS_BUTTON3STATE 0x0008
#define DFCS_BUTTONPUSH 0x0010

#define DFCS_INACTIVE 0x0100
#define DFCS_PUSHED 0x0200
#define DFCS_CHECKED 0x0400


#define DFCS_TRANSPARENT 0x0800
#define DFCS_HOT 0x1000


#define DFCS_ADJUSTRECT 0x2000
#define DFCS_FLAT 0x4000
#define DFCS_MONO 0x8000


BOOL

DrawFrameControl(
    HDC,
    LPRECT,
    UINT,
    UINT);


/* flags for DrawCaption */
#define DC_ACTIVE 0x0001
#define DC_SMALLCAP 0x0002
#define DC_ICON 0x0004
#define DC_TEXT 0x0008
#define DC_INBUTTON 0x0010

#define DC_GRADIENT 0x0020


#define DC_BUTTONS 0x1000



BOOL

DrawCaption(
    HWND hwnd,
    HDC hdc,
    const RECT * lprect,
    UINT flags);


#define IDANI_OPEN 1
#define IDANI_CAPTION 3


BOOL

DrawAnimatedRects(
    HWND hwnd,
    int idAni,
    const RECT *lprcFrom,
    const RECT *lprcTo);






/*

 * Predefined Clipboard Formats

 */
# 2735 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CF_TEXT 1
#define CF_BITMAP 2
#define CF_METAFILEPICT 3
#define CF_SYLK 4
#define CF_DIF 5
#define CF_TIFF 6
#define CF_OEMTEXT 7
#define CF_DIB 8
#define CF_PALETTE 9
#define CF_PENDATA 10
#define CF_RIFF 11
#define CF_WAVE 12
#define CF_UNICODETEXT 13
#define CF_ENHMETAFILE 14

#define CF_HDROP 15
#define CF_LOCALE 16


#define CF_DIBV5 17



#define CF_MAX 18






#define CF_OWNERDISPLAY 0x0080
#define CF_DSPTEXT 0x0081
#define CF_DSPBITMAP 0x0082
#define CF_DSPMETAFILEPICT 0x0083
#define CF_DSPENHMETAFILE 0x008E

/*

 * "Private" formats don't get GlobalFree()'d

 */
# 2774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CF_PRIVATEFIRST 0x0200
#define CF_PRIVATELAST 0x02FF

/*

 * "GDIOBJ" formats do get DeleteObject()'d

 */
# 2780 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CF_GDIOBJFIRST 0x0300
#define CF_GDIOBJLAST 0x03FF




/*

 * Defines for the fVirt field of the Accelerator table structure.

 */
# 2789 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define FVIRTKEY TRUE
#define FNOINVERT 0x02
#define FSHIFT 0x04
#define FCONTROL 0x08
#define FALT 0x10

typedef struct tagACCEL {

    BYTE fVirt; /* Also called the flags field */
    WORD key;
    WORD cmd;





} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCSTR lpszName;
    LPCSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID lpCreateParams;
    HINSTANCE hInstance;
    HMENU hMenu;
    HWND hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    LONG style;
    LPCWSTR lpszName;
    LPCWSTR lpszClass;
    DWORD dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;




typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;


typedef struct tagWINDOWPLACEMENT {
    UINT length;
    UINT flags;
    UINT showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;



} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION 0x0001
#define WPF_RESTORETOMAXIMIZED 0x0002

#define WPF_ASYNCWINDOWPLACEMENT 0x0004



typedef struct tagNMHDR
{
    HWND hwndFrom;
    UINT_PTR idFrom;
    UINT code; // NM_ code
} NMHDR;
typedef NMHDR * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD styleOld;
    DWORD styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;



/*

 * Owner draw control types

 */
# 2891 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ODT_MENU 1
#define ODT_LISTBOX 2
#define ODT_COMBOBOX 3
#define ODT_BUTTON 4

#define ODT_STATIC 5


/*

 * Owner draw actions

 */
# 2902 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ODA_DRAWENTIRE 0x0001
#define ODA_SELECT 0x0002
#define ODA_FOCUS 0x0004

/*

 * Owner draw state

 */
# 2909 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ODS_SELECTED 0x0001
#define ODS_GRAYED 0x0002
#define ODS_DISABLED 0x0004
#define ODS_CHECKED 0x0008
#define ODS_FOCUS 0x0010

#define ODS_DEFAULT 0x0020
#define ODS_COMBOBOXEDIT 0x1000


#define ODS_HOTLIGHT 0x0040
#define ODS_INACTIVE 0x0080

#define ODS_NOACCEL 0x0100
#define ODS_NOFOCUSRECT 0x0200



/*

 * MEASUREITEMSTRUCT for ownerdraw

 */
# 2930 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMEASUREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemWidth;
    UINT itemHeight;
    ULONG_PTR itemData;
} MEASUREITEMSTRUCT, *PMEASUREITEMSTRUCT, *LPMEASUREITEMSTRUCT;

/*

 * DRAWITEMSTRUCT for ownerdraw

 */
# 2942 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagDRAWITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemAction;
    UINT itemState;
    HWND hwndItem;
    HDC hDC;
    RECT rcItem;
    ULONG_PTR itemData;
} DRAWITEMSTRUCT, *PDRAWITEMSTRUCT, *LPDRAWITEMSTRUCT;

/*

 * DELETEITEMSTRUCT for ownerdraw

 */
# 2957 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagDELETEITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    HWND hwndItem;
    ULONG_PTR itemData;
} DELETEITEMSTRUCT, *PDELETEITEMSTRUCT, *LPDELETEITEMSTRUCT;

/*

 * COMPAREITEMSTUCT for ownerdraw sorting

 */
# 2968 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCOMPAREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    HWND hwndItem;
    UINT itemID1;
    ULONG_PTR itemData1;
    UINT itemID2;
    ULONG_PTR itemData2;
    DWORD dwLocaleId;
} COMPAREITEMSTRUCT, *PCOMPAREITEMSTRUCT, *LPCOMPAREITEMSTRUCT;



/*

 * Message Function Templates

 */
# 2985 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

GetMessageA(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);

BOOL

GetMessageW(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax);



#define GetMessage GetMessageA
# 3032 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

TranslateMessage(
    const MSG *lpMsg);


LRESULT

DispatchMessageA(
    const MSG *lpMsg);

LRESULT

DispatchMessageW(
    const MSG *lpMsg);



#define DispatchMessage DispatchMessageA
# 3072 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

SetMessageQueue(
    int cMessagesMax);


BOOL

PeekMessageA(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);

BOOL

PeekMessageW(
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);



#define PeekMessage PeekMessageA



/*

 * PeekMessage() Options

 */
# 3106 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define PM_NOREMOVE 0x0000
#define PM_REMOVE 0x0001
#define PM_NOYIELD 0x0002

#define PM_QS_INPUT (QS_INPUT << 16)
#define PM_QS_POSTMESSAGE ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) << 16)
#define PM_QS_PAINT (QS_PAINT << 16)
#define PM_QS_SENDMESSAGE (QS_SENDMESSAGE << 16)






BOOL

RegisterHotKey(
    HWND hWnd,
    int id,
    UINT fsModifiers,
    UINT vk);


BOOL

UnregisterHotKey(
    HWND hWnd,
    int id);

#define MOD_ALT 0x0001
#define MOD_CONTROL 0x0002
#define MOD_SHIFT 0x0004
#define MOD_WIN 0x0008

#define MOD_NOREPEAT 0x4000



#define IDHOT_SNAPWINDOW (-1)
#define IDHOT_SNAPDESKTOP (-2)
# 3158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ENDSESSION_LOGOFF 0x80000000

#define ENDSESSION_CRITICAL 0x40000000

#define ENDSESSION_CLOSEAPP 0x00000001


#define EWX_LOGOFF 0
#define EWX_SHUTDOWN 0x00000001
#define EWX_REBOOT 0x00000002
#define EWX_FORCE 0x00000004
#define EWX_POWEROFF 0x00000008

#define EWX_FORCEIFHUNG 0x00000010

#define EWX_QUICKRESOLVE 0x00000020

#define EWX_RESTARTAPPS 0x00000040



#define ExitWindows(dwReserved,Code) ExitWindowsEx(EWX_LOGOFF, 0xFFFFFFFF)





BOOL

ExitWindowsEx(
    UINT uFlags,
    DWORD dwReason);


BOOL

SwapMouseButton(
    BOOL fSwap);


DWORD

GetMessagePos(
    void);


LONG

GetMessageTime(
    void);


LPARAM

GetMessageExtraInfo(
    void);



BOOL

IsWow64Message(
    void);




LPARAM

SetMessageExtraInfo(
    LPARAM lParam);



LRESULT

SendMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT

SendMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define SendMessage SendMessageA
# 3279 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

LRESULT

SendMessageTimeoutA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PDWORD_PTR lpdwResult);

LRESULT

SendMessageTimeoutW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PDWORD_PTR lpdwResult);



#define SendMessageTimeout SendMessageTimeoutA



BOOL

SendNotifyMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

BOOL

SendNotifyMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define SendNotifyMessage SendNotifyMessageA



BOOL

SendMessageCallbackA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData);

BOOL

SendMessageCallbackW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData);



#define SendMessageCallback SendMessageCallbackA



typedef struct {
    UINT cbSize;
    HDESK hdesk;
    HWND hwnd;
    LUID luid;
} BSMINFO, *PBSMINFO;


long

BroadcastSystemMessageExA(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pbsmInfo);

long

BroadcastSystemMessageExW(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    PBSMINFO pbsmInfo);



#define BroadcastSystemMessageEx BroadcastSystemMessageExA







long

BroadcastSystemMessageA(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

long

BroadcastSystemMessageW(
    DWORD flags,
    LPDWORD lpInfo,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define BroadcastSystemMessage BroadcastSystemMessageA
# 3430 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
//Broadcast Special Message Recipient list
#define BSM_ALLCOMPONENTS 0x00000000
#define BSM_VXDS 0x00000001
#define BSM_NETDRIVER 0x00000002
#define BSM_INSTALLABLEDRIVERS 0x00000004
#define BSM_APPLICATIONS 0x00000008
#define BSM_ALLDESKTOPS 0x00000010

//Broadcast Special Message Flags
#define BSF_QUERY 0x00000001
#define BSF_IGNORECURRENTTASK 0x00000002
#define BSF_FLUSHDISK 0x00000004
#define BSF_NOHANG 0x00000008
#define BSF_POSTMESSAGE 0x00000010
#define BSF_FORCEIFHUNG 0x00000020
#define BSF_NOTIMEOUTIFNOTHUNG 0x00000040

#define BSF_ALLOWSFW 0x00000080
#define BSF_SENDNOTIFYMESSAGE 0x00000100


#define BSF_RETURNHDESK 0x00000200
#define BSF_LUID 0x00000400


#define BROADCAST_QUERY_DENY 0x424D5144


// RegisterDeviceNotification


typedef PVOID HDEVNOTIFY;
typedef HDEVNOTIFY *PHDEVNOTIFY;

#define DEVICE_NOTIFY_WINDOW_HANDLE 0x00000000
#define DEVICE_NOTIFY_SERVICE_HANDLE 0x00000001

#define DEVICE_NOTIFY_ALL_INTERFACE_CLASSES 0x00000004



HDEVNOTIFY

RegisterDeviceNotificationA(
    HANDLE hRecipient,
    LPVOID NotificationFilter,
    DWORD Flags);

HDEVNOTIFY

RegisterDeviceNotificationW(
    HANDLE hRecipient,
    LPVOID NotificationFilter,
    DWORD Flags);



#define RegisterDeviceNotification RegisterDeviceNotificationA



BOOL

UnregisterDeviceNotification(
    HDEVNOTIFY Handle
    );





#define _HPOWERNOTIFY_DEF_ 

typedef PVOID HPOWERNOTIFY;
typedef HPOWERNOTIFY *PHPOWERNOTIFY;




HPOWERNOTIFY

RegisterPowerSettingNotification(
    HANDLE hRecipient,
    LPCGUID PowerSettingGuid,
    DWORD Flags
    );


BOOL

UnregisterPowerSettingNotification(
    HPOWERNOTIFY Handle
    );





BOOL

PostMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

BOOL

PostMessageW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define PostMessage PostMessageA



BOOL

PostThreadMessageA(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

BOOL

PostThreadMessageW(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define PostThreadMessage PostThreadMessageA


#define PostAppMessageA(idThread,wMsg,wParam,lParam) PostThreadMessageA((DWORD)idThread, wMsg, wParam, lParam)

#define PostAppMessageW(idThread,wMsg,wParam,lParam) PostThreadMessageW((DWORD)idThread, wMsg, wParam, lParam)




#define PostAppMessage PostAppMessageA


/*

 * Special HWND value for use with PostMessage() and SendMessage()

 */
# 3584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HWND_BROADCAST ((HWND)0xffff)


#define HWND_MESSAGE ((HWND)-3)



BOOL

AttachThreadInput(
    DWORD idAttach,
    DWORD idAttachTo,
    BOOL fAttach);



BOOL

ReplyMessage(
    LRESULT lResult);


BOOL

WaitMessage(
    void);



DWORD

WaitForInputIdle(
    HANDLE hProcess,
    DWORD dwMilliseconds);



LRESULT





DefWindowProcA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);


LRESULT





DefWindowProcW(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define DefWindowProc DefWindowProcA



void

PostQuitMessage(
    int nExitCode);




LRESULT

CallWindowProcA(
    WNDPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT

CallWindowProcW(
    WNDPROC lpPrevWndFunc,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define CallWindowProc CallWindowProcA
# 3711 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

InSendMessage(
    void);



DWORD

InSendMessageEx(
    LPVOID lpReserved);

/*

 * InSendMessageEx return value

 */
# 3727 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ISMEX_NOSEND 0x00000000
#define ISMEX_SEND 0x00000001
#define ISMEX_NOTIFY 0x00000002
#define ISMEX_CALLBACK 0x00000004
#define ISMEX_REPLIED 0x00000008



UINT

GetDoubleClickTime(
    void);


BOOL

SetDoubleClickTime(
    UINT);


ATOM

RegisterClassA(
    const WNDCLASSA *lpWndClass);

ATOM

RegisterClassW(
    const WNDCLASSW *lpWndClass);



#define RegisterClass RegisterClassA



BOOL

UnregisterClassA(
    LPCSTR lpClassName,
    HINSTANCE hInstance);

BOOL

UnregisterClassW(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);



#define UnregisterClass UnregisterClassA



BOOL

GetClassInfoA(
    HINSTANCE hInstance,
    LPCSTR lpClassName,
    LPWNDCLASSA lpWndClass);

BOOL

GetClassInfoW(
    HINSTANCE hInstance,
    LPCWSTR lpClassName,
    LPWNDCLASSW lpWndClass);



#define GetClassInfo GetClassInfoA




ATOM

RegisterClassExA(
    const WNDCLASSEXA *);

ATOM

RegisterClassExW(
    const WNDCLASSEXW *);



#define RegisterClassEx RegisterClassExA



BOOL

GetClassInfoExA(
    HINSTANCE hInstance,
    LPCSTR lpszClass,
    LPWNDCLASSEXA lpwcx);

BOOL

GetClassInfoExW(
    HINSTANCE hInstance,
    LPCWSTR lpszClass,
    LPWNDCLASSEXW lpwcx);



#define GetClassInfoEx GetClassInfoExA




#define CW_USEDEFAULT ((int)0x80000000)

/*

 * Special value for CreateWindow, et al.

 */
# 3844 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HWND_DESKTOP ((HWND)0)


typedef BOOLEAN ( * PREGISTERCLASSNAMEW)(LPCWSTR);



HWND

CreateWindowExA(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

HWND

CreateWindowExW(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);



#define CreateWindowEx CreateWindowExA


#define CreateWindowA(lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam) CreateWindowExA(0L, lpClassName, lpWindowName, dwStyle, x, y,nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)



#define CreateWindowW(lpClassName,lpWindowName,dwStyle,x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam) CreateWindowExW(0L, lpClassName, lpWindowName, dwStyle, x, y,nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam)






#define CreateWindow CreateWindowA



BOOL

IsWindow(
    HWND hWnd);



BOOL

IsMenu(
    HMENU hMenu);


BOOL

IsChild(
    HWND hWndParent,
    HWND hWnd);


BOOL

DestroyWindow(
    HWND hWnd);


BOOL

ShowWindow(
    HWND hWnd,
    int nCmdShow);



BOOL

AnimateWindow(
    HWND hWnd,
    DWORD dwTime,
    DWORD dwFlags);






BOOL

UpdateLayeredWindow(
    HWND hWnd,
    HDC hdcDst,
    POINT* pptDst,
    SIZE* psize,
    HDC hdcSrc,
    POINT* pptSrc,
    COLORREF crKey,
    BLENDFUNCTION* pblend,
    DWORD dwFlags);

/*

 * Layered Window Update information

 */
# 3965 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagUPDATELAYEREDWINDOWINFO
{
    DWORD cbSize;
    HDC hdcDst;
    const POINT* pptDst;
    const SIZE* psize;
    HDC hdcSrc;
    const POINT* pptSrc;
    COLORREF crKey;
    const BLENDFUNCTION* pblend;
    DWORD dwFlags;
    const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;






BOOL

UpdateLayeredWindowIndirect(
    HWND hWnd,
    const UPDATELAYEREDWINDOWINFO* pULWInfo);





BOOL

GetLayeredWindowAttributes(
    HWND hwnd,
    COLORREF* pcrKey,
    BYTE* pbAlpha,
    DWORD* pdwFlags);

#define PW_CLIENTONLY 0x00000001



BOOL

PrintWindow(
    HWND hwnd,
    HDC hdcBlt,
    UINT nFlags);




BOOL

SetLayeredWindowAttributes(
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);

#define LWA_COLORKEY 0x00000001
#define LWA_ALPHA 0x00000002


#define ULW_COLORKEY 0x00000001
#define ULW_ALPHA 0x00000002
#define ULW_OPAQUE 0x00000004

#define ULW_EX_NORESIZE 0x00000008






BOOL

ShowWindowAsync(
    HWND hWnd,
    int nCmdShow);



BOOL

FlashWindow(
    HWND hWnd,
    BOOL bInvert);


typedef struct {
    UINT cbSize;
    HWND hwnd;
    DWORD dwFlags;
    UINT uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;


BOOL

FlashWindowEx(
    PFLASHWINFO pfwi);

#define FLASHW_STOP 0
#define FLASHW_CAPTION 0x00000001
#define FLASHW_TRAY 0x00000002
#define FLASHW_ALL (FLASHW_CAPTION | FLASHW_TRAY)
#define FLASHW_TIMER 0x00000004
#define FLASHW_TIMERNOFG 0x0000000C




BOOL

ShowOwnedPopups(
    HWND hWnd,
    BOOL fShow);


BOOL

OpenIcon(
    HWND hWnd);


BOOL

CloseWindow(
    HWND hWnd);


BOOL

MoveWindow(
    HWND hWnd,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    BOOL bRepaint);


BOOL

SetWindowPos(
    HWND hWnd,
    HWND hWndInsertAfter,
    int X,
    int Y,
    int cx,
    int cy,
    UINT uFlags);


BOOL

GetWindowPlacement(
    HWND hWnd,
    WINDOWPLACEMENT *lpwndpl);


BOOL

SetWindowPlacement(
    HWND hWnd,
    const WINDOWPLACEMENT *lpwndpl);


#define WDA_NONE 0x00000000
#define WDA_MONITOR 0x00000001



BOOL

GetWindowDisplayAffinity(
    HWND hWnd,
    DWORD* pdwAffinity);


BOOL

SetWindowDisplayAffinity(
    HWND hWnd,
    DWORD dwAffinity);






HDWP

BeginDeferWindowPos(
    int nNumWindows);


HDWP

DeferWindowPos(
    HDWP hWinPosInfo,
    HWND hWnd,
    HWND hWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);


BOOL

EndDeferWindowPos(
    HDWP hWinPosInfo);




BOOL

IsWindowVisible(
    HWND hWnd);


BOOL

IsIconic(
    HWND hWnd);


BOOL

AnyPopup(
    void);


BOOL

BringWindowToTop(
    HWND hWnd);


BOOL

IsZoomed(
    HWND hWnd);

/*

 * SetWindowPos Flags

 */
# 4216 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SWP_NOSIZE 0x0001
#define SWP_NOMOVE 0x0002
#define SWP_NOZORDER 0x0004
#define SWP_NOREDRAW 0x0008
#define SWP_NOACTIVATE 0x0010
#define SWP_FRAMECHANGED 0x0020
#define SWP_SHOWWINDOW 0x0040
#define SWP_HIDEWINDOW 0x0080
#define SWP_NOCOPYBITS 0x0100
#define SWP_NOOWNERZORDER 0x0200
#define SWP_NOSENDCHANGING 0x0400

#define SWP_DRAWFRAME SWP_FRAMECHANGED
#define SWP_NOREPOSITION SWP_NOOWNERZORDER


#define SWP_DEFERERASE 0x2000
#define SWP_ASYNCWINDOWPOS 0x4000



#define HWND_TOP ((HWND)0)
#define HWND_BOTTOM ((HWND)1)
#define HWND_TOPMOST ((HWND)-1)
#define HWND_NOTOPMOST ((HWND)-2)



/*

 * WARNING:

 * The following structures must NOT be DWORD padded because they are

 * followed by strings, etc that do not have to be DWORD aligned.

 */
# 4249 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    pshpack2.h



Abstract:



    This file turns 2 byte packing of structures on.  (That is, it disables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.  For Microsoft

    compatible compilers, this files uses the push option to the pack pragma

    so that the poppack.h include file can restore the previous packing

    reliably.



    The file poppack.h is the complement to this file.



--*/
# 31 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/pshpack2.h"
#pragma pack(2)
# 4250 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 2

/*

 * original NT 32 bit dialog template:

 */
# 4254 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;
typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;



typedef LPDLGTEMPLATEA LPDLGTEMPLATE;

typedef const DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEW;



typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;


/*

 * 32 bit Dialog item template.

 */
# 4281 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;



typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;

typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;



typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;



# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h" 1
/*++



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    poppack.h



Abstract:



    This file turns packing of structures off.  (That is, it enables

    automatic alignment of structure fields.)  An include file is needed

    because various compilers do this in different ways.



    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h

    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one

    correspondence.



    For Microsoft compatible compilers, this file uses the pop option

    to the pack pragma so that it can restore the previous saved by the

    pshpack?.h include file.



--*/
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/poppack.h"
#pragma pack()
# 4307 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 2


HWND

CreateDialogParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);

HWND

CreateDialogParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);



#define CreateDialogParam CreateDialogParamA



HWND

CreateDialogIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);

HWND

CreateDialogIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW lpTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);



#define CreateDialogIndirectParam CreateDialogIndirectParamA


#define CreateDialogA(hInstance,lpName,hWndParent,lpDialogFunc) CreateDialogParamA(hInstance, lpName, hWndParent, lpDialogFunc, 0L)

#define CreateDialogW(hInstance,lpName,hWndParent,lpDialogFunc) CreateDialogParamW(hInstance, lpName, hWndParent, lpDialogFunc, 0L)




#define CreateDialog CreateDialogA


#define CreateDialogIndirectA(hInstance,lpTemplate,hWndParent,lpDialogFunc) CreateDialogIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)

#define CreateDialogIndirectW(hInstance,lpTemplate,hWndParent,lpDialogFunc) CreateDialogIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)




#define CreateDialogIndirect CreateDialogIndirectA



INT_PTR

DialogBoxParamA(
    HINSTANCE hInstance,
    LPCSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);

INT_PTR

DialogBoxParamW(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);



#define DialogBoxParam DialogBoxParamA



INT_PTR

DialogBoxIndirectParamA(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEA hDialogTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);

INT_PTR

DialogBoxIndirectParamW(
    HINSTANCE hInstance,
    LPCDLGTEMPLATEW hDialogTemplate,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);



#define DialogBoxIndirectParam DialogBoxIndirectParamA


#define DialogBoxA(hInstance,lpTemplate,hWndParent,lpDialogFunc) DialogBoxParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)

#define DialogBoxW(hInstance,lpTemplate,hWndParent,lpDialogFunc) DialogBoxParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)




#define DialogBox DialogBoxA


#define DialogBoxIndirectA(hInstance,lpTemplate,hWndParent,lpDialogFunc) DialogBoxIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)

#define DialogBoxIndirectW(hInstance,lpTemplate,hWndParent,lpDialogFunc) DialogBoxIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L)




#define DialogBoxIndirect DialogBoxIndirectA



BOOL

EndDialog(
    HWND hDlg,
    INT_PTR nResult);


HWND

GetDlgItem(
    HWND hDlg,
    int nIDDlgItem);


BOOL

SetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    UINT uValue,
    BOOL bSigned);


UINT

GetDlgItemInt(
    HWND hDlg,
    int nIDDlgItem,
    BOOL *lpTranslated,
    BOOL bSigned);


BOOL

SetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPCSTR lpString);

BOOL

SetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString);



#define SetDlgItemText SetDlgItemTextA



UINT

GetDlgItemTextA(
    HWND hDlg,
    int nIDDlgItem,
    LPSTR lpString,
    int cchMax);

UINT

GetDlgItemTextW(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int cchMax);



#define GetDlgItemText GetDlgItemTextA



BOOL

CheckDlgButton(
    HWND hDlg,
    int nIDButton,
    UINT uCheck);


BOOL

CheckRadioButton(
    HWND hDlg,
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);


UINT

IsDlgButtonChecked(
    HWND hDlg,
    int nIDButton);


LRESULT

SendDlgItemMessageA(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT

SendDlgItemMessageW(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define SendDlgItemMessage SendDlgItemMessageA



HWND

GetNextDlgGroupItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);


HWND

GetNextDlgTabItem(
    HWND hDlg,
    HWND hCtl,
    BOOL bPrevious);


int

GetDlgCtrlID(
    HWND hWnd);


long

GetDialogBaseUnits(void);



LRESULT





DefDlgProcA(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);


LRESULT





DefDlgProcW(
    HWND hDlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);



#define DefDlgProc DefDlgProcA


/*

 * Window extra byted needed for private dialog classes.

 */
# 4629 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DLGWINDOWEXTRA 30
# 4638 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

CallMsgFilterA(
    LPMSG lpMsg,
    int nCode);

BOOL

CallMsgFilterW(
    LPMSG lpMsg,
    int nCode);



#define CallMsgFilter CallMsgFilterA






/*

 * Clipboard Manager Functions

 */
# 4664 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

OpenClipboard(
    HWND hWndNewOwner);


BOOL

CloseClipboard(
    void);





DWORD

GetClipboardSequenceNumber(
    void);




HWND

GetClipboardOwner(
    void);


HWND

SetClipboardViewer(
    HWND hWndNewViewer);


HWND

GetClipboardViewer(
    void);


BOOL

ChangeClipboardChain(
    HWND hWndRemove,
    HWND hWndNewNext);


HANDLE

SetClipboardData(
    UINT uFormat,
    HANDLE hMem);


HANDLE

GetClipboardData(
    UINT uFormat);


UINT

RegisterClipboardFormatA(
    LPCSTR lpszFormat);

UINT

RegisterClipboardFormatW(
    LPCWSTR lpszFormat);



#define RegisterClipboardFormat RegisterClipboardFormatA



int

CountClipboardFormats(
    void);


UINT

EnumClipboardFormats(
    UINT format);


int

GetClipboardFormatNameA(
    UINT format,
    LPSTR lpszFormatName,
    int cchMaxCount);

int

GetClipboardFormatNameW(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);



#define GetClipboardFormatName GetClipboardFormatNameA



BOOL

EmptyClipboard(
    void);


BOOL

IsClipboardFormatAvailable(
    UINT format);


int

GetPriorityClipboardFormat(
    UINT *paFormatPriorityList,
    int cFormats);


HWND

GetOpenClipboardWindow(
    void);



BOOL

AddClipboardFormatListener(
    HWND hwnd);


BOOL

RemoveClipboardFormatListener(
    HWND hwnd);


BOOL

GetUpdatedClipboardFormats(
    PUINT lpuiFormats,
    UINT cFormats,
    PUINT pcFormatsOut);



/*

 * Character Translation Routines

 */
# 4825 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

CharToOemA(
    LPCSTR pSrc,
    LPSTR pDst);

BOOL

CharToOemW(
    LPCWSTR pSrc,
    LPSTR pDst);



#define CharToOem CharToOemA




BOOL

OemToCharA(
    LPCSTR pSrc,
    LPSTR pDst);


BOOL

OemToCharW(
    LPCSTR pSrc,
    LPWSTR pDst);



#define OemToChar OemToCharA



BOOL

CharToOemBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);

BOOL

CharToOemBuffW(
    LPCWSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);



#define CharToOemBuff CharToOemBuffA



BOOL

OemToCharBuffA(
    LPCSTR lpszSrc,
    LPSTR lpszDst,
    DWORD cchDstLength);

BOOL

OemToCharBuffW(
    LPCSTR lpszSrc,
    LPWSTR lpszDst,
    DWORD cchDstLength);



#define OemToCharBuff OemToCharBuffA



LPSTR

CharUpperA(
    LPSTR lpsz);

LPWSTR

CharUpperW(
    LPWSTR lpsz);



#define CharUpper CharUpperA



DWORD

CharUpperBuffA(
    LPSTR lpsz,
    DWORD cchLength);

DWORD

CharUpperBuffW(
    LPWSTR lpsz,
    DWORD cchLength);



#define CharUpperBuff CharUpperBuffA



LPSTR

CharLowerA(
    LPSTR lpsz);

LPWSTR

CharLowerW(
    LPWSTR lpsz);



#define CharLower CharLowerA



DWORD

CharLowerBuffA(
    LPSTR lpsz,
    DWORD cchLength);

DWORD

CharLowerBuffW(
    LPWSTR lpsz,
    DWORD cchLength);



#define CharLowerBuff CharLowerBuffA



LPSTR

CharNextA(
    LPCSTR lpsz);

LPWSTR

CharNextW(
    LPCWSTR lpsz);



#define CharNext CharNextA



LPSTR

CharPrevA(
    LPCSTR lpszStart,
    LPCSTR lpszCurrent);

LPWSTR

CharPrevW(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);



#define CharPrev CharPrevA




LPSTR

CharNextExA(
     WORD CodePage,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);


LPSTR

CharPrevExA(
     WORD CodePage,
     LPCSTR lpStart,
     LPCSTR lpCurrentChar,
     DWORD dwFlags);


/*

 * Compatibility defines for character translation routines

 */
# 5027 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define AnsiToOem CharToOemA
#define OemToAnsi OemToCharA
#define AnsiToOemBuff CharToOemBuffA
#define OemToAnsiBuff OemToCharBuffA
#define AnsiUpper CharUpperA
#define AnsiUpperBuff CharUpperBuffA
#define AnsiLower CharLowerA
#define AnsiLowerBuff CharLowerBuffA
#define AnsiNext CharNextA
#define AnsiPrev CharPrevA


/*

 * Language dependent Routines

 */
# 5043 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

IsCharAlphaA(
    CHAR ch);

BOOL

IsCharAlphaW(
    WCHAR ch);



#define IsCharAlpha IsCharAlphaA



BOOL

IsCharAlphaNumericA(
    CHAR ch);

BOOL

IsCharAlphaNumericW(
    WCHAR ch);



#define IsCharAlphaNumeric IsCharAlphaNumericA



BOOL

IsCharUpperA(
    CHAR ch);

BOOL

IsCharUpperW(
    WCHAR ch);



#define IsCharUpper IsCharUpperA



BOOL

IsCharLowerA(
    CHAR ch);

BOOL

IsCharLowerW(
    WCHAR ch);



#define IsCharLower IsCharLowerA





HWND

SetFocus(
    HWND hWnd);


HWND

GetActiveWindow(
    void);


HWND

GetFocus(
    void);


UINT

GetKBCodePage(
    void);


SHORT

GetKeyState(
    int nVirtKey);


SHORT

GetAsyncKeyState(
    int vKey);


BOOL

GetKeyboardState(
    PBYTE lpKeyState);


BOOL

SetKeyboardState(
    LPBYTE lpKeyState);


int

GetKeyNameTextA(
    LONG lParam,
    LPSTR lpString,
    int cchSize);

int

GetKeyNameTextW(
    LONG lParam,
    LPWSTR lpString,
    int cchSize);



#define GetKeyNameText GetKeyNameTextA



int

GetKeyboardType(
    int nTypeFlag);


int

ToAscii(
    UINT uVirtKey,
    UINT uScanCode,
    const BYTE *lpKeyState,
    LPWORD lpChar,
    UINT uFlags);



int

ToAsciiEx(
    UINT uVirtKey,
    UINT uScanCode,
    const BYTE *lpKeyState,
    LPWORD lpChar,
    UINT uFlags,
    HKL dwhkl);



int

ToUnicode(
    UINT wVirtKey,
    UINT wScanCode,
    const BYTE *lpKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wFlags);


DWORD

OemKeyScan(
    WORD wOemChar);


SHORT

VkKeyScanA(
    CHAR ch);

SHORT

VkKeyScanW(
    WCHAR ch);



#define VkKeyScan VkKeyScanA




SHORT

VkKeyScanExA(
    CHAR ch,
    HKL dwhkl);

SHORT

VkKeyScanExW(
    WCHAR ch,
    HKL dwhkl);



#define VkKeyScanEx VkKeyScanExA


#define KEYEVENTF_EXTENDEDKEY 0x0001
#define KEYEVENTF_KEYUP 0x0002

#define KEYEVENTF_UNICODE 0x0004
#define KEYEVENTF_SCANCODE 0x0008



void

keybd_event(
    BYTE bVk,
    BYTE bScan,
    DWORD dwFlags,
    ULONG_PTR dwExtraInfo);

#define MOUSEEVENTF_MOVE 0x0001
#define MOUSEEVENTF_LEFTDOWN 0x0002
#define MOUSEEVENTF_LEFTUP 0x0004
#define MOUSEEVENTF_RIGHTDOWN 0x0008
#define MOUSEEVENTF_RIGHTUP 0x0010
#define MOUSEEVENTF_MIDDLEDOWN 0x0020
#define MOUSEEVENTF_MIDDLEUP 0x0040
#define MOUSEEVENTF_XDOWN 0x0080
#define MOUSEEVENTF_XUP 0x0100
#define MOUSEEVENTF_WHEEL 0x0800

#define MOUSEEVENTF_HWHEEL 0x01000


#define MOUSEEVENTF_MOVE_NOCOALESCE 0x2000

#define MOUSEEVENTF_VIRTUALDESK 0x4000
#define MOUSEEVENTF_ABSOLUTE 0x8000


void

mouse_event(
    DWORD dwFlags,
    DWORD dx,
    DWORD dy,
    DWORD dwData,
    ULONG_PTR dwExtraInfo);



typedef struct tagMOUSEINPUT {
    LONG dx;
    LONG dy;
    DWORD mouseData;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD wVk;
    WORD wScan;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, * LPKEYBDINPUT;

typedef struct tagHARDWAREINPUT {
    DWORD uMsg;
    WORD wParamL;
    WORD wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, * LPHARDWAREINPUT;

#define INPUT_MOUSE 0
#define INPUT_KEYBOARD 1
#define INPUT_HARDWARE 2

typedef struct tagINPUT {
    DWORD type;

    union
    {
        MOUSEINPUT mi;
        KEYBDINPUT ki;
        HARDWAREINPUT hi;
    };
} INPUT, *PINPUT, * LPINPUT;


UINT

SendInput(
    UINT cInputs, // number of input in the array
    LPINPUT pInputs, // array of inputs
    int cbSize); // sizeof(INPUT)





/*

 * Touch Input defines and functions

 */
# 5359 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Touch input handle

 */
# 5362 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
struct HTOUCHINPUT__{int unused;}; typedef struct HTOUCHINPUT__ *HTOUCHINPUT;

typedef struct tagTOUCHINPUT {
    LONG x;
    LONG y;
    HANDLE hSource;
    DWORD dwID;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwTime;
    ULONG_PTR dwExtraInfo;
    DWORD cxContact;
    DWORD cyContact;
} TOUCHINPUT, *PTOUCHINPUT;
typedef TOUCHINPUT const * PCTOUCHINPUT;


/*

 * Conversion of touch input coordinates to pixels

 */
# 5382 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define TOUCH_COORD_TO_PIXEL(l) ((l) / 100)

/*

 * Touch input flag values (TOUCHINPUT.dwFlags)

 */
# 5387 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define TOUCHEVENTF_MOVE 0x0001
#define TOUCHEVENTF_DOWN 0x0002
#define TOUCHEVENTF_UP 0x0004
#define TOUCHEVENTF_INRANGE 0x0008
#define TOUCHEVENTF_PRIMARY 0x0010
#define TOUCHEVENTF_NOCOALESCE 0x0020
#define TOUCHEVENTF_PEN 0x0040
#define TOUCHEVENTF_PALM 0x0080

/*

 * Touch input mask values (TOUCHINPUT.dwMask)

 */
# 5399 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define TOUCHINPUTMASKF_TIMEFROMSYSTEM 0x0001
#define TOUCHINPUTMASKF_EXTRAINFO 0x0002
#define TOUCHINPUTMASKF_CONTACTAREA 0x0004


BOOL

GetTouchInputInfo(
    HTOUCHINPUT hTouchInput, // input event handle; from touch message lParam
    UINT cInputs, // number of elements in the array
    PTOUCHINPUT pInputs, // array of touch inputs
    int cbSize); // sizeof(TOUCHINPUT)


BOOL

CloseTouchInputHandle(
    HTOUCHINPUT hTouchInput); // input event handle; from touch message lParam


/*

 * RegisterTouchWindow flag values

 */
# 5422 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define TWF_FINETOUCH (0x00000001)
#define TWF_WANTPALM (0x00000002)


BOOL

RegisterTouchWindow(
    HWND hwnd,
    ULONG ulFlags);


BOOL

UnregisterTouchWindow(
    HWND hwnd);


BOOL

IsTouchWindow(
    HWND hwnd,
    PULONG pulFlags);




typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;


BOOL

GetLastInputInfo(
    PLASTINPUTINFO plii);



UINT

MapVirtualKeyA(
    UINT uCode,
    UINT uMapType);

UINT

MapVirtualKeyW(
    UINT uCode,
    UINT uMapType);



#define MapVirtualKey MapVirtualKeyA




UINT

MapVirtualKeyExA(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);

UINT

MapVirtualKeyExW(
    UINT uCode,
    UINT uMapType,
    HKL dwhkl);



#define MapVirtualKeyEx MapVirtualKeyExA


#define MAPVK_VK_TO_VSC (0)
#define MAPVK_VSC_TO_VK (1)
#define MAPVK_VK_TO_CHAR (2)
#define MAPVK_VSC_TO_VK_EX (3)


#define MAPVK_VK_TO_VSC_EX (4)



BOOL

GetInputState(
    void);


DWORD

GetQueueStatus(
    UINT flags);



HWND

GetCapture(
    void);


HWND

SetCapture(
    HWND hWnd);


BOOL

ReleaseCapture(
    void);


DWORD

MsgWaitForMultipleObjects(
    DWORD nCount,
    const HANDLE *pHandles,
    BOOL fWaitAll,
    DWORD dwMilliseconds,
    DWORD dwWakeMask);


DWORD

MsgWaitForMultipleObjectsEx(
    DWORD nCount,
    const HANDLE *pHandles,
    DWORD dwMilliseconds,
    DWORD dwWakeMask,
    DWORD dwFlags);


#define MWMO_WAITALL 0x0001
#define MWMO_ALERTABLE 0x0002
#define MWMO_INPUTAVAILABLE 0x0004

/*

 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()

 */
# 5567 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define QS_KEY 0x0001
#define QS_MOUSEMOVE 0x0002
#define QS_MOUSEBUTTON 0x0004
#define QS_POSTMESSAGE 0x0008
#define QS_TIMER 0x0010
#define QS_PAINT 0x0020
#define QS_SENDMESSAGE 0x0040
#define QS_HOTKEY 0x0080
#define QS_ALLPOSTMESSAGE 0x0100

#define QS_RAWINPUT 0x0400


#define QS_MOUSE (QS_MOUSEMOVE | QS_MOUSEBUTTON)



#define QS_INPUT (QS_MOUSE | QS_KEY | QS_RAWINPUT)







#define QS_ALLEVENTS (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY)





#define QS_ALLINPUT (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY | QS_SENDMESSAGE)







#define USER_TIMER_MAXIMUM 0x7FFFFFFF
#define USER_TIMER_MINIMUM 0x0000000A

/*

 * Windows Functions

 */
# 5613 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

UINT_PTR

SetTimer(
    HWND hWnd,
    UINT_PTR nIDEvent,
    UINT uElapse,
    TIMERPROC lpTimerFunc);


BOOL

KillTimer(
    HWND hWnd,
    UINT_PTR uIDEvent);


BOOL

IsWindowUnicode(
    HWND hWnd);


BOOL

EnableWindow(
    HWND hWnd,
    BOOL bEnable);


BOOL

IsWindowEnabled(
    HWND hWnd);


HACCEL

LoadAcceleratorsA(
    HINSTANCE hInstance,
    LPCSTR lpTableName);

HACCEL

LoadAcceleratorsW(
    HINSTANCE hInstance,
    LPCWSTR lpTableName);



#define LoadAccelerators LoadAcceleratorsA



HACCEL

CreateAcceleratorTableA(
    LPACCEL paccel,
    int cAccel);

HACCEL

CreateAcceleratorTableW(
    LPACCEL paccel,
    int cAccel);



#define CreateAcceleratorTable CreateAcceleratorTableA



BOOL

DestroyAcceleratorTable(
    HACCEL hAccel);


int

CopyAcceleratorTableA(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);

int

CopyAcceleratorTableW(
    HACCEL hAccelSrc,
    LPACCEL lpAccelDst,
    int cAccelEntries);



#define CopyAcceleratorTable CopyAcceleratorTableA





int

TranslateAcceleratorA(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);

int

TranslateAcceleratorW(
    HWND hWnd,
    HACCEL hAccTable,
    LPMSG lpMsg);



#define TranslateAccelerator TranslateAcceleratorA






/*

 * GetSystemMetrics() codes

 */
# 5740 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SM_CXSCREEN 0
#define SM_CYSCREEN 1
#define SM_CXVSCROLL 2
#define SM_CYHSCROLL 3
#define SM_CYCAPTION 4
#define SM_CXBORDER 5
#define SM_CYBORDER 6
#define SM_CXDLGFRAME 7
#define SM_CYDLGFRAME 8
#define SM_CYVTHUMB 9
#define SM_CXHTHUMB 10
#define SM_CXICON 11
#define SM_CYICON 12
#define SM_CXCURSOR 13
#define SM_CYCURSOR 14
#define SM_CYMENU 15
#define SM_CXFULLSCREEN 16
#define SM_CYFULLSCREEN 17
#define SM_CYKANJIWINDOW 18
#define SM_MOUSEPRESENT 19
#define SM_CYVSCROLL 20
#define SM_CXHSCROLL 21
#define SM_DEBUG 22
#define SM_SWAPBUTTON 23
#define SM_RESERVED1 24
#define SM_RESERVED2 25
#define SM_RESERVED3 26
#define SM_RESERVED4 27
#define SM_CXMIN 28
#define SM_CYMIN 29
#define SM_CXSIZE 30
#define SM_CYSIZE 31
#define SM_CXFRAME 32
#define SM_CYFRAME 33
#define SM_CXMINTRACK 34
#define SM_CYMINTRACK 35
#define SM_CXDOUBLECLK 36
#define SM_CYDOUBLECLK 37
#define SM_CXICONSPACING 38
#define SM_CYICONSPACING 39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS 41
#define SM_DBCSENABLED 42
#define SM_CMOUSEBUTTONS 43


#define SM_CXFIXEDFRAME SM_CXDLGFRAME
#define SM_CYFIXEDFRAME SM_CYDLGFRAME
#define SM_CXSIZEFRAME SM_CXFRAME
#define SM_CYSIZEFRAME SM_CYFRAME

#define SM_SECURE 44
#define SM_CXEDGE 45
#define SM_CYEDGE 46
#define SM_CXMINSPACING 47
#define SM_CYMINSPACING 48
#define SM_CXSMICON 49
#define SM_CYSMICON 50
#define SM_CYSMCAPTION 51
#define SM_CXSMSIZE 52
#define SM_CYSMSIZE 53
#define SM_CXMENUSIZE 54
#define SM_CYMENUSIZE 55
#define SM_ARRANGE 56
#define SM_CXMINIMIZED 57
#define SM_CYMINIMIZED 58
#define SM_CXMAXTRACK 59
#define SM_CYMAXTRACK 60
#define SM_CXMAXIMIZED 61
#define SM_CYMAXIMIZED 62
#define SM_NETWORK 63
#define SM_CLEANBOOT 67
#define SM_CXDRAG 68
#define SM_CYDRAG 69

#define SM_SHOWSOUNDS 70

#define SM_CXMENUCHECK 71
#define SM_CYMENUCHECK 72
#define SM_SLOWMACHINE 73
#define SM_MIDEASTENABLED 74



#define SM_MOUSEWHEELPRESENT 75


#define SM_XVIRTUALSCREEN 76
#define SM_YVIRTUALSCREEN 77
#define SM_CXVIRTUALSCREEN 78
#define SM_CYVIRTUALSCREEN 79
#define SM_CMONITORS 80
#define SM_SAMEDISPLAYFORMAT 81


#define SM_IMMENABLED 82


#define SM_CXFOCUSBORDER 83
#define SM_CYFOCUSBORDER 84



#define SM_TABLETPC 86
#define SM_MEDIACENTER 87
#define SM_STARTER 88
#define SM_SERVERR2 89



#define SM_MOUSEHORIZONTALWHEELPRESENT 91
#define SM_CXPADDEDBORDER 92




#define SM_DIGITIZER 94
#define SM_MAXIMUMTOUCHES 95
# 5869 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SM_CMETRICS 97



#define SM_REMOTESESSION 0x1000



#define SM_SHUTTINGDOWN 0x2000



#define SM_REMOTECONTROL 0x2001



#define SM_CARETBLINKINGENABLED 0x2002






int

GetSystemMetrics(
    int nIndex);







HMENU

LoadMenuA(
    HINSTANCE hInstance,
    LPCSTR lpMenuName);

HMENU

LoadMenuW(
    HINSTANCE hInstance,
    LPCWSTR lpMenuName);



#define LoadMenu LoadMenuA



HMENU

LoadMenuIndirectA(
    const MENUTEMPLATEA *lpMenuTemplate);

HMENU

LoadMenuIndirectW(
    const MENUTEMPLATEW *lpMenuTemplate);



#define LoadMenuIndirect LoadMenuIndirectA



HMENU

GetMenu(
    HWND hWnd);


BOOL

SetMenu(
    HWND hWnd,
    HMENU hMenu);


BOOL

ChangeMenuA(
    HMENU hMenu,
    UINT cmd,
    LPCSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);

BOOL

ChangeMenuW(
    HMENU hMenu,
    UINT cmd,
    LPCWSTR lpszNewItem,
    UINT cmdInsert,
    UINT flags);



#define ChangeMenu ChangeMenuA



BOOL

HiliteMenuItem(
    HWND hWnd,
    HMENU hMenu,
    UINT uIDHiliteItem,
    UINT uHilite);


int

GetMenuStringA(
    HMENU hMenu,
    UINT uIDItem,
    LPSTR lpString,
    int cchMax,
    UINT flags);

int

GetMenuStringW(
    HMENU hMenu,
    UINT uIDItem,
    LPWSTR lpString,
    int cchMax,
    UINT flags);



#define GetMenuString GetMenuStringA



UINT

GetMenuState(
    HMENU hMenu,
    UINT uId,
    UINT uFlags);


BOOL

DrawMenuBar(
    HWND hWnd);


#define PMB_ACTIVE 0x00000001





HMENU

GetSystemMenu(
    HWND hWnd,
    BOOL bRevert);



HMENU

CreateMenu(
    void);


HMENU

CreatePopupMenu(
    void);


BOOL

DestroyMenu(
    HMENU hMenu);


DWORD

CheckMenuItem(
    HMENU hMenu,
    UINT uIDCheckItem,
    UINT uCheck);


BOOL

EnableMenuItem(
    HMENU hMenu,
    UINT uIDEnableItem,
    UINT uEnable);


HMENU

GetSubMenu(
    HMENU hMenu,
    int nPos);


UINT

GetMenuItemID(
    HMENU hMenu,
    int nPos);


int

GetMenuItemCount(
    HMENU hMenu);


BOOL

InsertMenuA(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCSTR lpNewItem);

BOOL

InsertMenuW(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCWSTR lpNewItem);



#define InsertMenu InsertMenuA



BOOL

AppendMenuA(
    HMENU hMenu,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCSTR lpNewItem);

BOOL

AppendMenuW(
    HMENU hMenu,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCWSTR lpNewItem);



#define AppendMenu AppendMenuA



BOOL

ModifyMenuA(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCSTR lpNewItem);

BOOL

ModifyMenuW(
    HMENU hMnu,
    UINT uPosition,
    UINT uFlags,
    UINT_PTR uIDNewItem,
    LPCWSTR lpNewItem);



#define ModifyMenu ModifyMenuA



BOOL
 RemoveMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);


BOOL

DeleteMenu(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags);


BOOL

SetMenuItemBitmaps(
    HMENU hMenu,
    UINT uPosition,
    UINT uFlags,
    HBITMAP hBitmapUnchecked,
    HBITMAP hBitmapChecked);


LONG

GetMenuCheckMarkDimensions(
    void);


BOOL

TrackPopupMenu(
    HMENU hMenu,
    UINT uFlags,
    int x,
    int y,
    int nReserved,
    HWND hWnd,
    const RECT *prcRect);


/* return codes for WM_MENUCHAR */
#define MNC_IGNORE 0
#define MNC_CLOSE 1
#define MNC_EXECUTE 2
#define MNC_SELECT 3

typedef struct tagTPMPARAMS
{
    UINT cbSize; /* Size of structure */
    RECT rcExclude; /* Screen coordinates of rectangle to exclude when positioning */
} TPMPARAMS;
typedef TPMPARAMS *LPTPMPARAMS;


BOOL

TrackPopupMenuEx(
    HMENU,
    UINT,
    int,
    int,
    HWND,
    LPTPMPARAMS);




BOOL

CalculatePopupWindowPosition(
    const POINT *anchorPoint,
    const SIZE *windowSize,
    UINT /* TPM_XXX values */ flags,
    RECT *excludeRect,
    RECT *popupWindowPosition);





#define MNS_NOCHECK 0x80000000
#define MNS_MODELESS 0x40000000
#define MNS_DRAGDROP 0x20000000
#define MNS_AUTODISMISS 0x10000000
#define MNS_NOTIFYBYPOS 0x08000000
#define MNS_CHECKORBMP 0x04000000

#define MIM_MAXHEIGHT 0x00000001
#define MIM_BACKGROUND 0x00000002
#define MIM_HELPID 0x00000004
#define MIM_MENUDATA 0x00000008
#define MIM_STYLE 0x00000010
#define MIM_APPLYTOSUBMENUS 0x80000000

typedef struct tagMENUINFO
{
    DWORD cbSize;
    DWORD fMask;
    DWORD dwStyle;
    UINT cyMax;
    HBRUSH hbrBack;
    DWORD dwContextHelpID;
    ULONG_PTR dwMenuData;
} MENUINFO, *LPMENUINFO;
typedef MENUINFO const *LPCMENUINFO;


BOOL

GetMenuInfo(
    HMENU,
    LPMENUINFO);


BOOL

SetMenuInfo(
    HMENU,
    LPCMENUINFO);


BOOL

EndMenu(
        void);

/*

 * WM_MENUDRAG return values.

 */
# 6291 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MND_CONTINUE 0
#define MND_ENDMENU 1

typedef struct tagMENUGETOBJECTINFO
{
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, * PMENUGETOBJECTINFO;

/*

 * MENUGETOBJECTINFO dwFlags values

 */
# 6306 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MNGOF_TOPGAP 0x00000001
#define MNGOF_BOTTOMGAP 0x00000002

/*

 * WM_MENUGETOBJECT return values

 */
# 6312 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MNGO_NOINTERFACE 0x00000000
#define MNGO_NOERROR 0x00000001



#define MIIM_STATE 0x00000001
#define MIIM_ID 0x00000002
#define MIIM_SUBMENU 0x00000004
#define MIIM_CHECKMARKS 0x00000008
#define MIIM_TYPE 0x00000010
#define MIIM_DATA 0x00000020



#define MIIM_STRING 0x00000040
#define MIIM_BITMAP 0x00000080
#define MIIM_FTYPE 0x00000100

#define HBMMENU_CALLBACK ((HBITMAP) -1)
#define HBMMENU_SYSTEM ((HBITMAP) 1)
#define HBMMENU_MBAR_RESTORE ((HBITMAP) 2)
#define HBMMENU_MBAR_MINIMIZE ((HBITMAP) 3)
#define HBMMENU_MBAR_CLOSE ((HBITMAP) 5)
#define HBMMENU_MBAR_CLOSE_D ((HBITMAP) 6)
#define HBMMENU_MBAR_MINIMIZE_D ((HBITMAP) 7)
#define HBMMENU_POPUP_CLOSE ((HBITMAP) 8)
#define HBMMENU_POPUP_RESTORE ((HBITMAP) 9)
#define HBMMENU_POPUP_MAXIMIZE ((HBITMAP) 10)
#define HBMMENU_POPUP_MINIMIZE ((HBITMAP) 11)



typedef struct tagMENUITEMINFOA
{
    UINT cbSize;
    UINT fMask;
    UINT fType; // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT fState; // used if MIIM_STATE
    UINT wID; // used if MIIM_ID
    HMENU hSubMenu; // used if MIIM_SUBMENU
    HBITMAP hbmpChecked; // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData; // used if MIIM_DATA
    LPSTR dwTypeData; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT cch; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)

    HBITMAP hbmpItem; // used if MIIM_BITMAP

} MENUITEMINFOA, *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT cbSize;
    UINT fMask;
    UINT fType; // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT fState; // used if MIIM_STATE
    UINT wID; // used if MIIM_ID
    HMENU hSubMenu; // used if MIIM_SUBMENU
    HBITMAP hbmpChecked; // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked; // used if MIIM_CHECKMARKS
    ULONG_PTR dwItemData; // used if MIIM_DATA
    LPWSTR dwTypeData; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT cch; // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)

    HBITMAP hbmpItem; // used if MIIM_BITMAP

} MENUITEMINFOW, *LPMENUITEMINFOW;




typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;

typedef MENUITEMINFOA const *LPCMENUITEMINFOA;
typedef MENUITEMINFOW const *LPCMENUITEMINFOW;



typedef LPCMENUITEMINFOA LPCMENUITEMINFO;




BOOL

InsertMenuItemA(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPCMENUITEMINFOA lpmi);

BOOL

InsertMenuItemW(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPCMENUITEMINFOW lpmi);



#define InsertMenuItem InsertMenuItemA



BOOL

GetMenuItemInfoA(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPMENUITEMINFOA lpmii);

BOOL

GetMenuItemInfoW(
    HMENU hmenu,
    UINT item,
    BOOL fByPosition,
    LPMENUITEMINFOW lpmii);



#define GetMenuItemInfo GetMenuItemInfoA



BOOL

SetMenuItemInfoA(
    HMENU hmenu,
    UINT item,
    BOOL fByPositon,
    LPCMENUITEMINFOA lpmii);

BOOL

SetMenuItemInfoW(
    HMENU hmenu,
    UINT item,
    BOOL fByPositon,
    LPCMENUITEMINFOW lpmii);



#define SetMenuItemInfo SetMenuItemInfoA



#define GMDI_USEDISABLED 0x0001L
#define GMDI_GOINTOPOPUPS 0x0002L


UINT

GetMenuDefaultItem(
    HMENU hMenu,
    UINT fByPos,
    UINT gmdiFlags);


BOOL

SetMenuDefaultItem(
    HMENU hMenu,
    UINT uItem,
    UINT fByPos);


BOOL

GetMenuItemRect(
    HWND hWnd,
    HMENU hMenu,
    UINT uItem,
    LPRECT lprcItem);


int

MenuItemFromPoint(
    HWND hWnd,
    HMENU hMenu,
    POINT ptScreen);


/*

 * Flags for TrackPopupMenu

 */
# 6501 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define TPM_LEFTBUTTON 0x0000L
#define TPM_RIGHTBUTTON 0x0002L
#define TPM_LEFTALIGN 0x0000L
#define TPM_CENTERALIGN 0x0004L
#define TPM_RIGHTALIGN 0x0008L

#define TPM_TOPALIGN 0x0000L
#define TPM_VCENTERALIGN 0x0010L
#define TPM_BOTTOMALIGN 0x0020L

#define TPM_HORIZONTAL 0x0000L
#define TPM_VERTICAL 0x0040L
#define TPM_NONOTIFY 0x0080L
#define TPM_RETURNCMD 0x0100L


#define TPM_RECURSE 0x0001L
#define TPM_HORPOSANIMATION 0x0400L
#define TPM_HORNEGANIMATION 0x0800L
#define TPM_VERPOSANIMATION 0x1000L
#define TPM_VERNEGANIMATION 0x2000L

#define TPM_NOANIMATION 0x4000L


#define TPM_LAYOUTRTL 0x8000L



#define TPM_WORKAREA 0x10000L







//
// Drag-and-drop support
// Obsolete - use OLE instead
//
typedef struct tagDROPSTRUCT
{
    HWND hwndSource;
    HWND hwndSink;
    DWORD wFmt;
    ULONG_PTR dwData;
    POINT ptDrop;
    DWORD dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;

#define DOF_EXECUTABLE 0x8001
#define DOF_DOCUMENT 0x8002
#define DOF_DIRECTORY 0x8003
#define DOF_MULTIPLE 0x8004
#define DOF_PROGMAN 0x0001
#define DOF_SHELLDATA 0x0002

#define DO_DROPFILE 0x454C4946L
#define DO_PRINTFILE 0x544E5250L


DWORD

DragObject(
    HWND hwndParent,
    HWND hwndFrom,
    UINT fmt,
    ULONG_PTR data,
    HCURSOR hcur);


BOOL

DragDetect(
    HWND hwnd,
    POINT pt);



BOOL

DrawIcon(
    HDC hDC,
    int X,
    int Y,
    HICON hIcon);



/*

 * DrawText() Format Flags

 */
# 6594 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DT_TOP 0x00000000
#define DT_LEFT 0x00000000
#define DT_CENTER 0x00000001
#define DT_RIGHT 0x00000002
#define DT_VCENTER 0x00000004
#define DT_BOTTOM 0x00000008
#define DT_WORDBREAK 0x00000010
#define DT_SINGLELINE 0x00000020
#define DT_EXPANDTABS 0x00000040
#define DT_TABSTOP 0x00000080
#define DT_NOCLIP 0x00000100
#define DT_EXTERNALLEADING 0x00000200
#define DT_CALCRECT 0x00000400
#define DT_NOPREFIX 0x00000800
#define DT_INTERNAL 0x00001000


#define DT_EDITCONTROL 0x00002000
#define DT_PATH_ELLIPSIS 0x00004000
#define DT_END_ELLIPSIS 0x00008000
#define DT_MODIFYSTRING 0x00010000
#define DT_RTLREADING 0x00020000
#define DT_WORD_ELLIPSIS 0x00040000

#define DT_NOFULLWIDTHCHARBREAK 0x00080000

#define DT_HIDEPREFIX 0x00100000
#define DT_PREFIXONLY 0x00200000



typedef struct tagDRAWTEXTPARAMS
{
    UINT cbSize;
    int iTabLength;
    int iLeftMargin;
    int iRightMargin;
    UINT uiLengthDrawn;
} DRAWTEXTPARAMS, *LPDRAWTEXTPARAMS;




int

DrawTextA(
    HDC hdc,
    LPCSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format);

int

DrawTextW(
    HDC hdc,
    LPCWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format);



#define DrawText DrawTextA
# 6688 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

int

DrawTextExA(
    HDC hdc,
    LPSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp);

int

DrawTextExW(
    HDC hdc,
    LPWSTR lpchText,
    int cchText,
    LPRECT lprc,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp);



#define DrawTextEx DrawTextExA






BOOL

GrayStringA(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);

BOOL

GrayStringW(
    HDC hDC,
    HBRUSH hBrush,
    GRAYSTRINGPROC lpOutputFunc,
    LPARAM lpData,
    int nCount,
    int X,
    int Y,
    int nWidth,
    int nHeight);



#define GrayString GrayStringA



/* Monolithic state-drawing routine */
/* Image type */
#define DST_COMPLEX 0x0000
#define DST_TEXT 0x0001
#define DST_PREFIXTEXT 0x0002
#define DST_ICON 0x0003
#define DST_BITMAP 0x0004

/* State type */
#define DSS_NORMAL 0x0000
#define DSS_UNION 0x0010
#define DSS_DISABLED 0x0020
#define DSS_MONO 0x0080

#define DSS_HIDEPREFIX 0x0200
#define DSS_PREFIXONLY 0x0400

#define DSS_RIGHT 0x8000


BOOL

DrawStateA(
    HDC hdc,
    HBRUSH hbrFore,
    DRAWSTATEPROC qfnCallBack,
    LPARAM lData,
    WPARAM wData,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);

BOOL

DrawStateW(
    HDC hdc,
    HBRUSH hbrFore,
    DRAWSTATEPROC qfnCallBack,
    LPARAM lData,
    WPARAM wData,
    int x,
    int y,
    int cx,
    int cy,
    UINT uFlags);



#define DrawState DrawStateA




LONG

TabbedTextOutA(
    HDC hdc,
    int x,
    int y,
    LPCSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions,
    int nTabOrigin);

LONG

TabbedTextOutW(
    HDC hdc,
    int x,
    int y,
    LPCWSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions,
    int nTabOrigin);



#define TabbedTextOut TabbedTextOutA



DWORD

GetTabbedTextExtentA(
    HDC hdc,
    LPCSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions);

DWORD

GetTabbedTextExtentW(
    HDC hdc,
    LPCWSTR lpString,
    int chCount,
    int nTabPositions,
    const INT *lpnTabStopPositions);



#define GetTabbedTextExtent GetTabbedTextExtentA



BOOL

UpdateWindow(
    HWND hWnd);


HWND

SetActiveWindow(
    HWND hWnd);


HWND

GetForegroundWindow(
    void);



BOOL

PaintDesktop(
    HDC hdc);


void

SwitchToThisWindow(
    HWND hwnd,
    BOOL fUnknown);




BOOL

SetForegroundWindow(
    HWND hWnd);



BOOL

AllowSetForegroundWindow(
    DWORD dwProcessId);

#define ASFW_ANY ((DWORD)-1)


BOOL

LockSetForegroundWindow(
    UINT uLockCode);

#define LSFW_LOCK 1
#define LSFW_UNLOCK 2




HWND

WindowFromDC(
    HDC hDC);


HDC

GetDC(
    HWND hWnd);


HDC

GetDCEx(
    HWND hWnd,
    HRGN hrgnClip,
    DWORD flags);

/*

 * GetDCEx() flags

 */
# 6941 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DCX_WINDOW 0x00000001L
#define DCX_CACHE 0x00000002L
#define DCX_NORESETATTRS 0x00000004L
#define DCX_CLIPCHILDREN 0x00000008L
#define DCX_CLIPSIBLINGS 0x00000010L
#define DCX_PARENTCLIP 0x00000020L
#define DCX_EXCLUDERGN 0x00000040L
#define DCX_INTERSECTRGN 0x00000080L
#define DCX_EXCLUDEUPDATE 0x00000100L
#define DCX_INTERSECTUPDATE 0x00000200L
#define DCX_LOCKWINDOWUPDATE 0x00000400L

#define DCX_VALIDATE 0x00200000L


HDC

GetWindowDC(
    HWND hWnd);


int

ReleaseDC(
    HWND hWnd,
    HDC hDC);


HDC

BeginPaint(
    HWND hWnd,
    LPPAINTSTRUCT lpPaint);


BOOL

EndPaint(
    HWND hWnd,
    const PAINTSTRUCT *lpPaint);


BOOL

GetUpdateRect(
    HWND hWnd,
    LPRECT lpRect,
    BOOL bErase);


int

GetUpdateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);


int

SetWindowRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bRedraw);



int

GetWindowRgn(
    HWND hWnd,
    HRGN hRgn);




int

GetWindowRgnBox(
    HWND hWnd,
    LPRECT lprc);




int

ExcludeUpdateRgn(
    HDC hDC,
    HWND hWnd);


BOOL

InvalidateRect(
    HWND hWnd,
    const RECT *lpRect,
    BOOL bErase);


BOOL

ValidateRect(
    HWND hWnd,
    const RECT *lpRect);


BOOL

InvalidateRgn(
    HWND hWnd,
    HRGN hRgn,
    BOOL bErase);


BOOL

ValidateRgn(
    HWND hWnd,
    HRGN hRgn);



BOOL

RedrawWindow(
    HWND hWnd,
    const RECT *lprcUpdate,
    HRGN hrgnUpdate,
    UINT flags);

/*

 * RedrawWindow() flags

 */
# 7075 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RDW_INVALIDATE 0x0001
#define RDW_INTERNALPAINT 0x0002
#define RDW_ERASE 0x0004

#define RDW_VALIDATE 0x0008
#define RDW_NOINTERNALPAINT 0x0010
#define RDW_NOERASE 0x0020

#define RDW_NOCHILDREN 0x0040
#define RDW_ALLCHILDREN 0x0080

#define RDW_UPDATENOW 0x0100
#define RDW_ERASENOW 0x0200

#define RDW_FRAME 0x0400
#define RDW_NOFRAME 0x0800


/*

 * LockWindowUpdate API

 */
# 7097 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

LockWindowUpdate(
    HWND hWndLock);


BOOL

ScrollWindow(
    HWND hWnd,
    int XAmount,
    int YAmount,
    const RECT *lpRect,
    const RECT *lpClipRect);


BOOL

ScrollDC(
    HDC hDC,
    int dx,
    int dy,
    const RECT *lprcScroll,
    const RECT *lprcClip,
    HRGN hrgnUpdate,
    LPRECT lprcUpdate);


int

ScrollWindowEx(
    HWND hWnd,
    int dx,
    int dy,
    const RECT *prcScroll,
    const RECT *prcClip,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);

#define SW_SCROLLCHILDREN 0x0001
#define SW_INVALIDATE 0x0002
#define SW_ERASE 0x0004

#define SW_SMOOTHSCROLL 0x0010





int

SetScrollPos(
    HWND hWnd,
    int nBar,
    int nPos,
    BOOL bRedraw);


int

GetScrollPos(
    HWND hWnd,
    int nBar);


BOOL

SetScrollRange(
    HWND hWnd,
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw);


BOOL

GetScrollRange(
    HWND hWnd,
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos);


BOOL

ShowScrollBar(
    HWND hWnd,
    int wBar,
    BOOL bShow);


BOOL

EnableScrollBar(
    HWND hWnd,
    UINT wSBflags,
    UINT wArrows);


/*

 * EnableScrollBar() flags

 */
# 7202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ESB_ENABLE_BOTH 0x0000
#define ESB_DISABLE_BOTH 0x0003

#define ESB_DISABLE_LEFT 0x0001
#define ESB_DISABLE_RIGHT 0x0002

#define ESB_DISABLE_UP 0x0001
#define ESB_DISABLE_DOWN 0x0002

#define ESB_DISABLE_LTUP ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN ESB_DISABLE_RIGHT





BOOL

SetPropA(
    HWND hWnd,
    LPCSTR lpString,
    HANDLE hData);

BOOL

SetPropW(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);



#define SetProp SetPropA



HANDLE

GetPropA(
    HWND hWnd,
    LPCSTR lpString);

HANDLE

GetPropW(
    HWND hWnd,
    LPCWSTR lpString);



#define GetProp GetPropA



HANDLE

RemovePropA(
    HWND hWnd,
    LPCSTR lpString);

HANDLE

RemovePropW(
    HWND hWnd,
    LPCWSTR lpString);



#define RemoveProp RemovePropA



int

EnumPropsExA(
    HWND hWnd,
    PROPENUMPROCEXA lpEnumFunc,
    LPARAM lParam);

int

EnumPropsExW(
    HWND hWnd,
    PROPENUMPROCEXW lpEnumFunc,
    LPARAM lParam);



#define EnumPropsEx EnumPropsExA



int

EnumPropsA(
    HWND hWnd,
    PROPENUMPROCA lpEnumFunc);

int

EnumPropsW(
    HWND hWnd,
    PROPENUMPROCW lpEnumFunc);



#define EnumProps EnumPropsA



BOOL

SetWindowTextA(
    HWND hWnd,
    LPCSTR lpString);

BOOL

SetWindowTextW(
    HWND hWnd,
    LPCWSTR lpString);



#define SetWindowText SetWindowTextA



int

GetWindowTextA(
    HWND hWnd,
    LPSTR lpString,
    int nMaxCount);

int

GetWindowTextW(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount);



#define GetWindowText GetWindowTextA



int

GetWindowTextLengthA(
    HWND hWnd);

int

GetWindowTextLengthW(
    HWND hWnd);



#define GetWindowTextLength GetWindowTextLengthA



BOOL

GetClientRect(
    HWND hWnd,
    LPRECT lpRect);


BOOL

GetWindowRect(
    HWND hWnd,
    LPRECT lpRect);


BOOL

AdjustWindowRect(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu);


BOOL

AdjustWindowRectEx(
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu,
    DWORD dwExStyle);



#define HELPINFO_WINDOW 0x0001
#define HELPINFO_MENUITEM 0x0002
typedef struct tagHELPINFO /* Structure pointed to by lParam of WM_HELP */
{
    UINT cbSize; /* Size in bytes of this struct  */
    int iContextType; /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int iCtrlId; /* Control Id or a Menu item Id. */
    HANDLE hItemHandle; /* hWnd of control or hMenu.     */
    DWORD_PTR dwContextId; /* Context Id associated with this item */
    POINT MousePos; /* Mouse Position in screen co-ordinates */
} HELPINFO, *LPHELPINFO;


BOOL

SetWindowContextHelpId(
    HWND,
    DWORD);


DWORD

GetWindowContextHelpId(
    HWND);


BOOL

SetMenuContextHelpId(
    HMENU,
    DWORD);


DWORD

GetMenuContextHelpId(
    HMENU);






/*

 * MessageBox() Flags

 */
# 7444 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MB_OK 0x00000000L
#define MB_OKCANCEL 0x00000001L
#define MB_ABORTRETRYIGNORE 0x00000002L
#define MB_YESNOCANCEL 0x00000003L
#define MB_YESNO 0x00000004L
#define MB_RETRYCANCEL 0x00000005L

#define MB_CANCELTRYCONTINUE 0x00000006L



#define MB_ICONHAND 0x00000010L
#define MB_ICONQUESTION 0x00000020L
#define MB_ICONEXCLAMATION 0x00000030L
#define MB_ICONASTERISK 0x00000040L


#define MB_USERICON 0x00000080L
#define MB_ICONWARNING MB_ICONEXCLAMATION
#define MB_ICONERROR MB_ICONHAND


#define MB_ICONINFORMATION MB_ICONASTERISK
#define MB_ICONSTOP MB_ICONHAND

#define MB_DEFBUTTON1 0x00000000L
#define MB_DEFBUTTON2 0x00000100L
#define MB_DEFBUTTON3 0x00000200L

#define MB_DEFBUTTON4 0x00000300L


#define MB_APPLMODAL 0x00000000L
#define MB_SYSTEMMODAL 0x00001000L
#define MB_TASKMODAL 0x00002000L

#define MB_HELP 0x00004000L


#define MB_NOFOCUS 0x00008000L
#define MB_SETFOREGROUND 0x00010000L
#define MB_DEFAULT_DESKTOP_ONLY 0x00020000L


#define MB_TOPMOST 0x00040000L
#define MB_RIGHT 0x00080000L
#define MB_RTLREADING 0x00100000L





#define MB_SERVICE_NOTIFICATION 0x00200000L



#define MB_SERVICE_NOTIFICATION_NT3X 0x00040000L


#define MB_TYPEMASK 0x0000000FL
#define MB_ICONMASK 0x000000F0L
#define MB_DEFMASK 0x00000F00L
#define MB_MODEMASK 0x00003000L
#define MB_MISCMASK 0x0000C000L


int

MessageBoxA(
    HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType);

int

MessageBoxW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);



#define MessageBox MessageBoxA
# 7555 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

int

MessageBoxExA(
    HWND hWnd,
    LPCSTR lpText,
    LPCSTR lpCaption,
    UINT uType,
    WORD wLanguageId);

int

MessageBoxExW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType,
    WORD wLanguageId);



#define MessageBoxEx MessageBoxExA




typedef void ( *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT cbSize;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCSTR lpszText;
    LPCSTR lpszCaption;
    DWORD dwStyle;
    LPCSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT cbSize;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCWSTR lpszText;
    LPCWSTR lpszCaption;
    DWORD dwStyle;
    LPCWSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;





typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;



int

MessageBoxIndirectA(
    const MSGBOXPARAMSA * lpmbp);

int

MessageBoxIndirectW(
    const MSGBOXPARAMSW * lpmbp);



#define MessageBoxIndirect MessageBoxIndirectA





BOOL

MessageBeep(
    UINT uType);





int

ShowCursor(
    BOOL bShow);


BOOL

SetCursorPos(
    int X,
    int Y);



BOOL

SetPhysicalCursorPos(
    int X,
    int Y);



HCURSOR

SetCursor(
    HCURSOR hCursor);


BOOL

GetCursorPos(
    LPPOINT lpPoint);



BOOL

GetPhysicalCursorPos(
    LPPOINT lpPoint);



BOOL

ClipCursor(
    const RECT *lpRect);


BOOL

GetClipCursor(
    LPRECT lpRect);


HCURSOR

GetCursor(
    void);


BOOL

CreateCaret(
    HWND hWnd,
    HBITMAP hBitmap,
    int nWidth,
    int nHeight);


UINT

GetCaretBlinkTime(
    void);


BOOL

SetCaretBlinkTime(
    UINT uMSeconds);


BOOL

DestroyCaret(
    void);


BOOL

HideCaret(
    HWND hWnd);


BOOL

ShowCaret(
    HWND hWnd);


BOOL

SetCaretPos(
    int X,
    int Y);


BOOL

GetCaretPos(
    LPPOINT lpPoint);


BOOL

ClientToScreen(
    HWND hWnd,
    LPPOINT lpPoint);


BOOL

ScreenToClient(
    HWND hWnd,
    LPPOINT lpPoint);



BOOL

LogicalToPhysicalPoint(
    HWND hWnd,
    LPPOINT lpPoint);


BOOL

PhysicalToLogicalPoint(
    HWND hWnd,
    LPPOINT lpPoint);




int

MapWindowPoints(
    HWND hWndFrom,
    HWND hWndTo,
    LPPOINT lpPoints,
    UINT cPoints);


HWND

WindowFromPoint(
    POINT Point);



HWND

WindowFromPhysicalPoint(
    POINT Point);



HWND

ChildWindowFromPoint(
    HWND hWndParent,
    POINT Point);


#define CWP_ALL 0x0000
#define CWP_SKIPINVISIBLE 0x0001
#define CWP_SKIPDISABLED 0x0002
#define CWP_SKIPTRANSPARENT 0x0004


HWND

ChildWindowFromPointEx(
    HWND hwnd,
    POINT pt,
    UINT flags);




/*

 * Color Types

 */
# 7839 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CTLCOLOR_MSGBOX 0
#define CTLCOLOR_EDIT 1
#define CTLCOLOR_LISTBOX 2
#define CTLCOLOR_BTN 3
#define CTLCOLOR_DLG 4
#define CTLCOLOR_SCROLLBAR 5
#define CTLCOLOR_STATIC 6
#define CTLCOLOR_MAX 7

#define COLOR_SCROLLBAR 0
#define COLOR_BACKGROUND 1
#define COLOR_ACTIVECAPTION 2
#define COLOR_INACTIVECAPTION 3
#define COLOR_MENU 4
#define COLOR_WINDOW 5
#define COLOR_WINDOWFRAME 6
#define COLOR_MENUTEXT 7
#define COLOR_WINDOWTEXT 8
#define COLOR_CAPTIONTEXT 9
#define COLOR_ACTIVEBORDER 10
#define COLOR_INACTIVEBORDER 11
#define COLOR_APPWORKSPACE 12
#define COLOR_HIGHLIGHT 13
#define COLOR_HIGHLIGHTTEXT 14
#define COLOR_BTNFACE 15
#define COLOR_BTNSHADOW 16
#define COLOR_GRAYTEXT 17
#define COLOR_BTNTEXT 18
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT 20


#define COLOR_3DDKSHADOW 21
#define COLOR_3DLIGHT 22
#define COLOR_INFOTEXT 23
#define COLOR_INFOBK 24



#define COLOR_HOTLIGHT 26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28

#define COLOR_MENUHILIGHT 29
#define COLOR_MENUBAR 30




#define COLOR_DESKTOP COLOR_BACKGROUND
#define COLOR_3DFACE COLOR_BTNFACE
#define COLOR_3DSHADOW COLOR_BTNSHADOW
#define COLOR_3DHIGHLIGHT COLOR_BTNHIGHLIGHT
#define COLOR_3DHILIGHT COLOR_BTNHIGHLIGHT
#define COLOR_BTNHILIGHT COLOR_BTNHIGHLIGHT




DWORD

GetSysColor(
    int nIndex);



HBRUSH

GetSysColorBrush(
    int nIndex);





BOOL

SetSysColors(
    int cElements,
    const INT * lpaElements,
    const COLORREF * lpaRgbValues);




BOOL

DrawFocusRect(
    HDC hDC,
    const RECT * lprc);


int

FillRect(
    HDC hDC,
    const RECT *lprc,
    HBRUSH hbr);


int

FrameRect(
    HDC hDC,
    const RECT *lprc,
    HBRUSH hbr);


BOOL

InvertRect(
    HDC hDC,
    const RECT *lprc);


BOOL

SetRect(
    LPRECT lprc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom);


BOOL

SetRectEmpty(
    LPRECT lprc);


BOOL

CopyRect(
    LPRECT lprcDst,
    const RECT *lprcSrc);


BOOL

InflateRect(
    LPRECT lprc,
    int dx,
    int dy);


BOOL

IntersectRect(
    LPRECT lprcDst,
    const RECT *lprcSrc1,
    const RECT *lprcSrc2);


BOOL

UnionRect(
    LPRECT lprcDst,
    const RECT *lprcSrc1,
    const RECT *lprcSrc2);


BOOL

SubtractRect(
    LPRECT lprcDst,
    const RECT *lprcSrc1,
    const RECT *lprcSrc2);


BOOL

OffsetRect(
    LPRECT lprc,
    int dx,
    int dy);


BOOL

IsRectEmpty(
    const RECT *lprc);


BOOL

EqualRect(
    const RECT *lprc1,
    const RECT *lprc2);


BOOL

PtInRect(
    const RECT *lprc,
    POINT pt);




WORD

GetWindowWord(
    HWND hWnd,
    int nIndex);


WORD

SetWindowWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);


LONG

GetWindowLongA(
    HWND hWnd,
    int nIndex);

LONG

GetWindowLongW(
    HWND hWnd,
    int nIndex);



#define GetWindowLong GetWindowLongA



LONG

SetWindowLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);

LONG

SetWindowLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);



#define SetWindowLong SetWindowLongA





LONG_PTR

GetWindowLongPtrA(
    HWND hWnd,
    int nIndex);

LONG_PTR

GetWindowLongPtrW(
    HWND hWnd,
    int nIndex);



#define GetWindowLongPtr GetWindowLongPtrA



LONG_PTR

SetWindowLongPtrA(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);

LONG_PTR

SetWindowLongPtrW(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);



#define SetWindowLongPtr SetWindowLongPtrA
# 8151 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

WORD

GetClassWord(
    HWND hWnd,
    int nIndex);


WORD

SetClassWord(
    HWND hWnd,
    int nIndex,
    WORD wNewWord);


DWORD

GetClassLongA(
    HWND hWnd,
    int nIndex);

DWORD

GetClassLongW(
    HWND hWnd,
    int nIndex);



#define GetClassLong GetClassLongA



DWORD

SetClassLongA(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);

DWORD

SetClassLongW(
    HWND hWnd,
    int nIndex,
    LONG dwNewLong);



#define SetClassLong SetClassLongA





ULONG_PTR

GetClassLongPtrA(
    HWND hWnd,
    int nIndex);

ULONG_PTR

GetClassLongPtrW(
    HWND hWnd,
    int nIndex);



#define GetClassLongPtr GetClassLongPtrA



ULONG_PTR

SetClassLongPtrA(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);

ULONG_PTR

SetClassLongPtrW(
    HWND hWnd,
    int nIndex,
    LONG_PTR dwNewLong);



#define SetClassLongPtr SetClassLongPtrA
# 8267 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

GetProcessDefaultLayout(
    DWORD *pdwDefaultLayout);


BOOL

SetProcessDefaultLayout(
    DWORD dwDefaultLayout);



HWND

GetDesktopWindow(
    void);



HWND

GetParent(
    HWND hWnd);


HWND

SetParent(
    HWND hWndChild,
    HWND hWndNewParent);


BOOL

EnumChildWindows(
    HWND hWndParent,
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);


HWND

FindWindowA(
    LPCSTR lpClassName,
    LPCSTR lpWindowName);

HWND

FindWindowW(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName);



#define FindWindow FindWindowA




HWND

FindWindowExA(
    HWND hWndParent,
    HWND hWndChildAfter,
    LPCSTR lpszClass,
    LPCSTR lpszWindow);

HWND

FindWindowExW(
    HWND hWndParent,
    HWND hWndChildAfter,
    LPCWSTR lpszClass,
    LPCWSTR lpszWindow);



#define FindWindowEx FindWindowExA



HWND

GetShellWindow(
    void);





BOOL

RegisterShellHookWindow(
    HWND hwnd);


BOOL

DeregisterShellHookWindow(
    HWND hwnd);


BOOL

EnumWindows(
    WNDENUMPROC lpEnumFunc,
    LPARAM lParam);


BOOL

EnumThreadWindows(
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam);

#define EnumTaskWindows(hTask,lpfn,lParam) EnumThreadWindows(HandleToUlong(hTask), lpfn, lParam)


int

GetClassNameA(
    HWND hWnd,
    LPSTR lpClassName,
    int nMaxCount
    );

int

GetClassNameW(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount
    );



#define GetClassName GetClassNameA
# 8433 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

HWND

GetTopWindow(
    HWND hWnd);

#define GetNextWindow(hWnd,wCmd) GetWindow(hWnd, wCmd)
#define GetSysModalWindow() (NULL)
#define SetSysModalWindow(hWnd) (NULL)


DWORD

GetWindowThreadProcessId(
    HWND hWnd,
    LPDWORD lpdwProcessId);



BOOL

IsGUIThread(
    BOOL bConvert);




#define GetWindowTask(hWnd) ((HANDLE)(DWORD_PTR)GetWindowThreadProcessId(hWnd, NULL))



HWND

GetLastActivePopup(
    HWND hWnd);

/*

 * GetWindow() Constants

 */
# 8472 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GW_HWNDFIRST 0
#define GW_HWNDLAST 1
#define GW_HWNDNEXT 2
#define GW_HWNDPREV 3
#define GW_OWNER 4
#define GW_CHILD 5



#define GW_ENABLEDPOPUP 6
#define GW_MAX 6



HWND

GetWindow(
    HWND hWnd,
    UINT uCmd);







HHOOK

SetWindowsHookA(
    int nFilterType,
    HOOKPROC pfnFilterProc);

HHOOK

SetWindowsHookW(
    int nFilterType,
    HOOKPROC pfnFilterProc);



#define SetWindowsHook SetWindowsHookA
# 8537 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

UnhookWindowsHook(
    int nCode,
    HOOKPROC pfnFilterProc);


HHOOK

SetWindowsHookExA(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);

HHOOK

SetWindowsHookExW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);



#define SetWindowsHookEx SetWindowsHookExA



BOOL

UnhookWindowsHookEx(
    HHOOK hhk);


LRESULT

CallNextHookEx(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam);

/*

 * Macros for source-level compatibility with old functions.

 */
# 8585 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DefHookProc(nCode,wParam,lParam,phhk) CallNextHookEx(*phhk, nCode, wParam, lParam)
# 8596 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*

 * Menu flags for Add/Check/EnableMenuItem()

 */
# 8600 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MF_INSERT 0x00000000L
#define MF_CHANGE 0x00000080L
#define MF_APPEND 0x00000100L
#define MF_DELETE 0x00000200L
#define MF_REMOVE 0x00001000L

#define MF_BYCOMMAND 0x00000000L
#define MF_BYPOSITION 0x00000400L

#define MF_SEPARATOR 0x00000800L

#define MF_ENABLED 0x00000000L
#define MF_GRAYED 0x00000001L
#define MF_DISABLED 0x00000002L

#define MF_UNCHECKED 0x00000000L
#define MF_CHECKED 0x00000008L
#define MF_USECHECKBITMAPS 0x00000200L

#define MF_STRING 0x00000000L
#define MF_BITMAP 0x00000004L
#define MF_OWNERDRAW 0x00000100L

#define MF_POPUP 0x00000010L
#define MF_MENUBARBREAK 0x00000020L
#define MF_MENUBREAK 0x00000040L

#define MF_UNHILITE 0x00000000L
#define MF_HILITE 0x00000080L


#define MF_DEFAULT 0x00001000L

#define MF_SYSMENU 0x00002000L
#define MF_HELP 0x00004000L

#define MF_RIGHTJUSTIFY 0x00004000L


#define MF_MOUSESELECT 0x00008000L

#define MF_END 0x00000080L




#define MFT_STRING MF_STRING
#define MFT_BITMAP MF_BITMAP
#define MFT_MENUBARBREAK MF_MENUBARBREAK
#define MFT_MENUBREAK MF_MENUBREAK
#define MFT_OWNERDRAW MF_OWNERDRAW
#define MFT_RADIOCHECK 0x00000200L
#define MFT_SEPARATOR MF_SEPARATOR
#define MFT_RIGHTORDER 0x00002000L
#define MFT_RIGHTJUSTIFY MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED 0x00000003L
#define MFS_DISABLED MFS_GRAYED
#define MFS_CHECKED MF_CHECKED
#define MFS_HILITE MF_HILITE
#define MFS_ENABLED MF_ENABLED
#define MFS_UNCHECKED MF_UNCHECKED
#define MFS_UNHILITE MF_UNHILITE
#define MFS_DEFAULT MF_DEFAULT






BOOL

CheckMenuRadioItem(
    HMENU hmenu,
    UINT first,
    UINT last,
    UINT check,
    UINT flags);


/*

 * Menu item resource format

 */
# 8684 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct { // version 0
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;
#define MF_END 0x00000080L





/*

 * System Menu Command Values

 */
# 8703 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SC_SIZE 0xF000
#define SC_MOVE 0xF010
#define SC_MINIMIZE 0xF020
#define SC_MAXIMIZE 0xF030
#define SC_NEXTWINDOW 0xF040
#define SC_PREVWINDOW 0xF050
#define SC_CLOSE 0xF060
#define SC_VSCROLL 0xF070
#define SC_HSCROLL 0xF080
#define SC_MOUSEMENU 0xF090
#define SC_KEYMENU 0xF100
#define SC_ARRANGE 0xF110
#define SC_RESTORE 0xF120
#define SC_TASKLIST 0xF130
#define SC_SCREENSAVE 0xF140
#define SC_HOTKEY 0xF150

#define SC_DEFAULT 0xF160
#define SC_MONITORPOWER 0xF170
#define SC_CONTEXTHELP 0xF180
#define SC_SEPARATOR 0xF00F



#define SCF_ISSECURE 0x00000001


#define GET_SC_WPARAM(wParam) ((int)wParam & 0xFFF0)

/*

 * Obsolete names

 */
# 8735 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SC_ICON SC_MINIMIZE
#define SC_ZOOM SC_MAXIMIZE



/*

 * Resource Loading Routines

 */
# 8744 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

HBITMAP

LoadBitmapA(
    HINSTANCE hInstance,
    LPCSTR lpBitmapName);

HBITMAP

LoadBitmapW(
    HINSTANCE hInstance,
    LPCWSTR lpBitmapName);



#define LoadBitmap LoadBitmapA



HCURSOR

LoadCursorA(
    HINSTANCE hInstance,
    LPCSTR lpCursorName);

HCURSOR

LoadCursorW(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName);



#define LoadCursor LoadCursorA



HCURSOR

LoadCursorFromFileA(
    LPCSTR lpFileName);

HCURSOR

LoadCursorFromFileW(
    LPCWSTR lpFileName);



#define LoadCursorFromFile LoadCursorFromFileA



HCURSOR

CreateCursor(
    HINSTANCE hInst,
    int xHotSpot,
    int yHotSpot,
    int nWidth,
    int nHeight,
    const void *pvANDPlane,
    const void *pvXORPlane);


BOOL

DestroyCursor(
    HCURSOR hCursor);


#define CopyCursor(pcur) ((HCURSOR)CopyIcon((HICON)(pcur)))
# 8824 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Standard Cursor IDs

 */
# 8827 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define IDC_ARROW MAKEINTRESOURCE(32512)
#define IDC_IBEAM MAKEINTRESOURCE(32513)
#define IDC_WAIT MAKEINTRESOURCE(32514)
#define IDC_CROSS MAKEINTRESOURCE(32515)
#define IDC_UPARROW MAKEINTRESOURCE(32516)
#define IDC_SIZE MAKEINTRESOURCE(32640)
#define IDC_ICON MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE MAKEINTRESOURCE(32642)
#define IDC_SIZENESW MAKEINTRESOURCE(32643)
#define IDC_SIZEWE MAKEINTRESOURCE(32644)
#define IDC_SIZENS MAKEINTRESOURCE(32645)
#define IDC_SIZEALL MAKEINTRESOURCE(32646)
#define IDC_NO MAKEINTRESOURCE(32648)

#define IDC_HAND MAKEINTRESOURCE(32649)

#define IDC_APPSTARTING MAKEINTRESOURCE(32650)

#define IDC_HELP MAKEINTRESOURCE(32651)



BOOL

SetSystemCursor(
    HCURSOR hcur,
    DWORD id);

typedef struct _ICONINFO {
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;


HICON

LoadIconA(
    HINSTANCE hInstance,
    LPCSTR lpIconName);

HICON

LoadIconW(
    HINSTANCE hInstance,
    LPCWSTR lpIconName);



#define LoadIcon LoadIconA




UINT

PrivateExtractIconsA(
    LPCSTR szFileName,
    int nIconIndex,
    int cxIcon,
    int cyIcon,
    HICON *phicon,
    UINT *piconid,
    UINT nIcons,
    UINT flags);

UINT

PrivateExtractIconsW(
    LPCWSTR szFileName,
    int nIconIndex,
    int cxIcon,
    int cyIcon,
    HICON *phicon,
    UINT *piconid,
    UINT nIcons,
    UINT flags);



#define PrivateExtractIcons PrivateExtractIconsA



HICON

CreateIcon(
    HINSTANCE hInstance,
    int nWidth,
    int nHeight,
    BYTE cPlanes,
    BYTE cBitsPixel,
    const BYTE *lpbANDbits,
    const BYTE *lpbXORbits);


BOOL

DestroyIcon(
    HICON hIcon);


int

LookupIconIdFromDirectory(
    PBYTE presbits,
    BOOL fIcon);



int

LookupIconIdFromDirectoryEx(
    PBYTE presbits,
    BOOL fIcon,
    int cxDesired,
    int cyDesired,
    UINT Flags);



HICON

CreateIconFromResource(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL fIcon,
    DWORD dwVer);



HICON

CreateIconFromResourceEx(
    PBYTE presbits,
    DWORD dwResSize,
    BOOL fIcon,
    DWORD dwVer,
    int cxDesired,
    int cyDesired,
    UINT Flags);

/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;
    BYTE Planes;
    BYTE BitsPixel;
} CURSORSHAPE, *LPCURSORSHAPE;


#define IMAGE_BITMAP 0
#define IMAGE_ICON 1
#define IMAGE_CURSOR 2

#define IMAGE_ENHMETAFILE 3

#define LR_DEFAULTCOLOR 0x00000000
#define LR_MONOCHROME 0x00000001
#define LR_COLOR 0x00000002
#define LR_COPYRETURNORG 0x00000004
#define LR_COPYDELETEORG 0x00000008
#define LR_LOADFROMFILE 0x00000010
#define LR_LOADTRANSPARENT 0x00000020
#define LR_DEFAULTSIZE 0x00000040
#define LR_VGACOLOR 0x00000080
#define LR_LOADMAP3DCOLORS 0x00001000
#define LR_CREATEDIBSECTION 0x00002000
#define LR_COPYFROMRESOURCE 0x00004000
#define LR_SHARED 0x00008000


HANDLE

LoadImageA(
    HINSTANCE hInst,
    LPCSTR name,
    UINT type,
    int cx,
    int cy,
    UINT fuLoad);

HANDLE

LoadImageW(
    HINSTANCE hInst,
    LPCWSTR name,
    UINT type,
    int cx,
    int cy,
    UINT fuLoad);



#define LoadImage LoadImageA



HANDLE

CopyImage(
    HANDLE h,
    UINT type,
    int cx,
    int cy,
    UINT flags);

#define DI_MASK 0x0001
#define DI_IMAGE 0x0002
#define DI_NORMAL 0x0003
#define DI_COMPAT 0x0004
#define DI_DEFAULTSIZE 0x0008

#define DI_NOMIRROR 0x0010


 BOOL DrawIconEx(
    HDC hdc,
    int xLeft,
    int yTop,
    HICON hIcon,
    int cxWidth,
    int cyWidth,
    UINT istepIfAniCur,
    HBRUSH hbrFlickerFreeDraw,
    UINT diFlags);




HICON

CreateIconIndirect(
    PICONINFO piconinfo);


HICON

CopyIcon(
    HICON hIcon);


BOOL

GetIconInfo(
    HICON hIcon,
    PICONINFO piconinfo);


typedef struct _ICONINFOEXA {
    DWORD cbSize;
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD wResID;
    CHAR szModName[260];
    CHAR szResName[260];
} ICONINFOEXA, *PICONINFOEXA;
typedef struct _ICONINFOEXW {
    DWORD cbSize;
    BOOL fIcon;
    DWORD xHotspot;
    DWORD yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD wResID;
    WCHAR szModName[260];
    WCHAR szResName[260];
} ICONINFOEXW, *PICONINFOEXW;




typedef ICONINFOEXA ICONINFOEX;
typedef PICONINFOEXA PICONINFOEX;



BOOL

GetIconInfoExA(
    HICON hicon,
    PICONINFOEXA piconinfo);

BOOL

GetIconInfoExW(
    HICON hicon,
    PICONINFOEXW piconinfo);



#define GetIconInfoEx GetIconInfoExA




#define RES_ICON 1
#define RES_CURSOR 2
# 9221 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ORD_LANGDRIVER 1





/*

 * Standard Icon IDs

 */
# 9243 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define IDI_APPLICATION MAKEINTRESOURCE(32512)
#define IDI_HAND MAKEINTRESOURCE(32513)
#define IDI_QUESTION MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION MAKEINTRESOURCE(32515)
#define IDI_ASTERISK MAKEINTRESOURCE(32516)

#define IDI_WINLOGO MAKEINTRESOURCE(32517)


#define IDI_SHIELD MAKEINTRESOURCE(32518)




#define IDI_WARNING IDI_EXCLAMATION
#define IDI_ERROR IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK







int

LoadStringA(
    HINSTANCE hInstance,
    UINT uID,
    LPSTR lpBuffer,
    int cchBufferMax);

int

LoadStringW(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int cchBufferMax);



#define LoadString LoadStringA



/*

 * Dialog Box Command IDs

 */
# 9292 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define IDOK 1
#define IDCANCEL 2
#define IDABORT 3
#define IDRETRY 4
#define IDIGNORE 5
#define IDYES 6
#define IDNO 7

#define IDCLOSE 8
#define IDHELP 9



#define IDTRYAGAIN 10
#define IDCONTINUE 11




#define IDTIMEOUT 32000






/*

 * Control Manager Structures and Definitions

 */


/*

 * Edit Control Styles

 */
# 9328 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ES_LEFT 0x0000L
#define ES_CENTER 0x0001L
#define ES_RIGHT 0x0002L
#define ES_MULTILINE 0x0004L
#define ES_UPPERCASE 0x0008L
#define ES_LOWERCASE 0x0010L
#define ES_PASSWORD 0x0020L
#define ES_AUTOVSCROLL 0x0040L
#define ES_AUTOHSCROLL 0x0080L
#define ES_NOHIDESEL 0x0100L
#define ES_OEMCONVERT 0x0400L
#define ES_READONLY 0x0800L
#define ES_WANTRETURN 0x1000L

#define ES_NUMBER 0x2000L





/*

 * Edit Control Notification Codes

 */
# 9351 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EN_SETFOCUS 0x0100
#define EN_KILLFOCUS 0x0200
#define EN_CHANGE 0x0300
#define EN_UPDATE 0x0400
#define EN_ERRSPACE 0x0500
#define EN_MAXTEXT 0x0501
#define EN_HSCROLL 0x0601
#define EN_VSCROLL 0x0602


#define EN_ALIGN_LTR_EC 0x0700
#define EN_ALIGN_RTL_EC 0x0701



/* Edit control EM_SETMARGIN parameters */
#define EC_LEFTMARGIN 0x0001
#define EC_RIGHTMARGIN 0x0002
#define EC_USEFONTINFO 0xffff



/* wParam of EM_GET/SETIMESTATUS  */
#define EMSIS_COMPOSITIONSTRING 0x0001

/* lParam for EMSIS_COMPOSITIONSTRING  */
#define EIMES_GETCOMPSTRATONCE 0x0001
#define EIMES_CANCELCOMPSTRINFOCUS 0x0002
#define EIMES_COMPLETECOMPSTRKILLFOCUS 0x0004





/*

 * Edit Control Messages

 */
# 9388 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EM_GETSEL 0x00B0
#define EM_SETSEL 0x00B1
#define EM_GETRECT 0x00B2
#define EM_SETRECT 0x00B3
#define EM_SETRECTNP 0x00B4
#define EM_SCROLL 0x00B5
#define EM_LINESCROLL 0x00B6
#define EM_SCROLLCARET 0x00B7
#define EM_GETMODIFY 0x00B8
#define EM_SETMODIFY 0x00B9
#define EM_GETLINECOUNT 0x00BA
#define EM_LINEINDEX 0x00BB
#define EM_SETHANDLE 0x00BC
#define EM_GETHANDLE 0x00BD
#define EM_GETTHUMB 0x00BE
#define EM_LINELENGTH 0x00C1
#define EM_REPLACESEL 0x00C2
#define EM_GETLINE 0x00C4
#define EM_LIMITTEXT 0x00C5
#define EM_CANUNDO 0x00C6
#define EM_UNDO 0x00C7
#define EM_FMTLINES 0x00C8
#define EM_LINEFROMCHAR 0x00C9
#define EM_SETTABSTOPS 0x00CB
#define EM_SETPASSWORDCHAR 0x00CC
#define EM_EMPTYUNDOBUFFER 0x00CD
#define EM_GETFIRSTVISIBLELINE 0x00CE
#define EM_SETREADONLY 0x00CF
#define EM_SETWORDBREAKPROC 0x00D0
#define EM_GETWORDBREAKPROC 0x00D1
#define EM_GETPASSWORDCHAR 0x00D2

#define EM_SETMARGINS 0x00D3
#define EM_GETMARGINS 0x00D4
#define EM_SETLIMITTEXT EM_LIMITTEXT
#define EM_GETLIMITTEXT 0x00D5
#define EM_POSFROMCHAR 0x00D6
#define EM_CHARFROMPOS 0x00D7



#define EM_SETIMESTATUS 0x00D8
#define EM_GETIMESTATUS 0x00D9





/*

 * EDITWORDBREAKPROC code values

 */
# 9439 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WB_LEFT 0
#define WB_RIGHT 1
#define WB_ISDELIMITER 2


/*

 * Button Control Styles

 */
# 9447 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define BS_PUSHBUTTON 0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX 0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON 0x00000004L
#define BS_3STATE 0x00000005L
#define BS_AUTO3STATE 0x00000006L
#define BS_GROUPBOX 0x00000007L
#define BS_USERBUTTON 0x00000008L
#define BS_AUTORADIOBUTTON 0x00000009L
#define BS_PUSHBOX 0x0000000AL
#define BS_OWNERDRAW 0x0000000BL
#define BS_TYPEMASK 0x0000000FL
#define BS_LEFTTEXT 0x00000020L

#define BS_TEXT 0x00000000L
#define BS_ICON 0x00000040L
#define BS_BITMAP 0x00000080L
#define BS_LEFT 0x00000100L
#define BS_RIGHT 0x00000200L
#define BS_CENTER 0x00000300L
#define BS_TOP 0x00000400L
#define BS_BOTTOM 0x00000800L
#define BS_VCENTER 0x00000C00L
#define BS_PUSHLIKE 0x00001000L
#define BS_MULTILINE 0x00002000L
#define BS_NOTIFY 0x00004000L
#define BS_FLAT 0x00008000L
#define BS_RIGHTBUTTON BS_LEFTTEXT


/*

 * User Button Notification Codes

 */
# 9481 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define BN_CLICKED 0
#define BN_PAINT 1
#define BN_HILITE 2
#define BN_UNHILITE 3
#define BN_DISABLE 4
#define BN_DOUBLECLICKED 5

#define BN_PUSHED BN_HILITE
#define BN_UNPUSHED BN_UNHILITE
#define BN_DBLCLK BN_DOUBLECLICKED
#define BN_SETFOCUS 6
#define BN_KILLFOCUS 7


/*

 * Button Control Messages

 */
# 9498 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define BM_GETCHECK 0x00F0
#define BM_SETCHECK 0x00F1
#define BM_GETSTATE 0x00F2
#define BM_SETSTATE 0x00F3
#define BM_SETSTYLE 0x00F4

#define BM_CLICK 0x00F5
#define BM_GETIMAGE 0x00F6
#define BM_SETIMAGE 0x00F7


#define BM_SETDONTCLICK 0x00F8



#define BST_UNCHECKED 0x0000
#define BST_CHECKED 0x0001
#define BST_INDETERMINATE 0x0002
#define BST_PUSHED 0x0004
#define BST_FOCUS 0x0008


/*

 * Static Control Constants

 */
# 9523 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SS_LEFT 0x00000000L
#define SS_CENTER 0x00000001L
#define SS_RIGHT 0x00000002L
#define SS_ICON 0x00000003L
#define SS_BLACKRECT 0x00000004L
#define SS_GRAYRECT 0x00000005L
#define SS_WHITERECT 0x00000006L
#define SS_BLACKFRAME 0x00000007L
#define SS_GRAYFRAME 0x00000008L
#define SS_WHITEFRAME 0x00000009L
#define SS_USERITEM 0x0000000AL
#define SS_SIMPLE 0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL

#define SS_OWNERDRAW 0x0000000DL
#define SS_BITMAP 0x0000000EL
#define SS_ENHMETAFILE 0x0000000FL
#define SS_ETCHEDHORZ 0x00000010L
#define SS_ETCHEDVERT 0x00000011L
#define SS_ETCHEDFRAME 0x00000012L
#define SS_TYPEMASK 0x0000001FL


#define SS_REALSIZECONTROL 0x00000040L

#define SS_NOPREFIX 0x00000080L

#define SS_NOTIFY 0x00000100L
#define SS_CENTERIMAGE 0x00000200L
#define SS_RIGHTJUST 0x00000400L
#define SS_REALSIZEIMAGE 0x00000800L
#define SS_SUNKEN 0x00001000L
#define SS_EDITCONTROL 0x00002000L
#define SS_ENDELLIPSIS 0x00004000L
#define SS_PATHELLIPSIS 0x00008000L
#define SS_WORDELLIPSIS 0x0000C000L
#define SS_ELLIPSISMASK 0x0000C000L





/*

 * Static Control Mesages

 */
# 9568 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define STM_SETICON 0x0170
#define STM_GETICON 0x0171

#define STM_SETIMAGE 0x0172
#define STM_GETIMAGE 0x0173
#define STN_CLICKED 0
#define STN_DBLCLK 1
#define STN_ENABLE 2
#define STN_DISABLE 3

#define STM_MSGMAX 0x0174


/*

 * Dialog window class

 */
# 9584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WC_DIALOG (MAKEINTATOM(0x8002))

/*

 * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows

 */
# 9589 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DWL_MSGRESULT 0
#define DWL_DLGPROC 4
#define DWL_USER 8



#undef DWL_MSGRESULT
#undef DWL_DLGPROC
#undef DWL_USER



#define DWLP_MSGRESULT 0
#define DWLP_DLGPROC DWLP_MSGRESULT + sizeof(LRESULT)
#define DWLP_USER DWLP_DLGPROC + sizeof(DLGPROC)

/*

 * Dialog Manager Routines

 */


BOOL

IsDialogMessageA(
    HWND hDlg,
    LPMSG lpMsg);

BOOL

IsDialogMessageW(
    HWND hDlg,
    LPMSG lpMsg);



#define IsDialogMessage IsDialogMessageA





BOOL

MapDialogRect(
    HWND hDlg,
    LPRECT lpRect);


int

DlgDirListA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);

int

DlgDirListW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT uFileType);



#define DlgDirList DlgDirListA


/*

 * DlgDirList, DlgDirListComboBox flags values

 */
# 9665 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DDL_READWRITE 0x0000
#define DDL_READONLY 0x0001
#define DDL_HIDDEN 0x0002
#define DDL_SYSTEM 0x0004
#define DDL_DIRECTORY 0x0010
#define DDL_ARCHIVE 0x0020

#define DDL_POSTMSGS 0x2000
#define DDL_DRIVES 0x4000
#define DDL_EXCLUSIVE 0x8000


BOOL

DlgDirSelectExA(
    HWND hwndDlg,
    LPSTR lpString,
    int chCount,
    int idListBox);

BOOL

DlgDirSelectExW(
    HWND hwndDlg,
    LPWSTR lpString,
    int chCount,
    int idListBox);



#define DlgDirSelectEx DlgDirSelectExA



int

DlgDirListComboBoxA(
    HWND hDlg,
    LPSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);

int

DlgDirListComboBoxW(
    HWND hDlg,
    LPWSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT uFiletype);



#define DlgDirListComboBox DlgDirListComboBoxA



BOOL

DlgDirSelectComboBoxExA(
    HWND hwndDlg,
    LPSTR lpString,
    int cchOut,
    int idComboBox);

BOOL

DlgDirSelectComboBoxExW(
    HWND hwndDlg,
    LPWSTR lpString,
    int cchOut,
    int idComboBox);



#define DlgDirSelectComboBoxEx DlgDirSelectComboBoxExA




/*

 * Dialog Styles

 */
# 9749 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DS_ABSALIGN 0x01L
#define DS_SYSMODAL 0x02L
#define DS_LOCALEDIT 0x20L
#define DS_SETFONT 0x40L
#define DS_MODALFRAME 0x80L
#define DS_NOIDLEMSG 0x100L
#define DS_SETFOREGROUND 0x200L



#define DS_3DLOOK 0x0004L
#define DS_FIXEDSYS 0x0008L
#define DS_NOFAILCREATE 0x0010L
#define DS_CONTROL 0x0400L
#define DS_CENTER 0x0800L
#define DS_CENTERMOUSE 0x1000L
#define DS_CONTEXTHELP 0x2000L

#define DS_SHELLFONT (DS_SETFONT | DS_FIXEDSYS)







#define DM_GETDEFID (WM_USER+0)
#define DM_SETDEFID (WM_USER+1)


#define DM_REPOSITION (WM_USER+2)

/*

 * Returned in HIWORD() of DM_GETDEFID result if msg is supported

 */
# 9784 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DC_HASDEFID 0x534B

/*

 * Dialog Codes

 */
# 9789 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define DLGC_WANTARROWS 0x0001
#define DLGC_WANTTAB 0x0002
#define DLGC_WANTALLKEYS 0x0004
#define DLGC_WANTMESSAGE 0x0004
#define DLGC_HASSETSEL 0x0008
#define DLGC_DEFPUSHBUTTON 0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON 0x0040
#define DLGC_WANTCHARS 0x0080
#define DLGC_STATIC 0x0100
#define DLGC_BUTTON 0x2000

#define LB_CTLCODE 0L

/*

 * Listbox Return Values

 */
# 9806 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define LB_OKAY 0
#define LB_ERR (-1)
#define LB_ERRSPACE (-2)

/*

**  The idStaticPath parameter to DlgDirList can have the following values

**  ORed if the list box should show other details of the files along with

**  the name of the files;

*/
# 9815 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
                                  /* all other details also will be returned */


/*

 * Listbox Notification Codes

 */
# 9821 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define LBN_ERRSPACE (-2)
#define LBN_SELCHANGE 1
#define LBN_DBLCLK 2
#define LBN_SELCANCEL 3
#define LBN_SETFOCUS 4
#define LBN_KILLFOCUS 5





/*

 * Listbox messages

 */
# 9835 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define LB_ADDSTRING 0x0180
#define LB_INSERTSTRING 0x0181
#define LB_DELETESTRING 0x0182
#define LB_SELITEMRANGEEX 0x0183
#define LB_RESETCONTENT 0x0184
#define LB_SETSEL 0x0185
#define LB_SETCURSEL 0x0186
#define LB_GETSEL 0x0187
#define LB_GETCURSEL 0x0188
#define LB_GETTEXT 0x0189
#define LB_GETTEXTLEN 0x018A
#define LB_GETCOUNT 0x018B
#define LB_SELECTSTRING 0x018C
#define LB_DIR 0x018D
#define LB_GETTOPINDEX 0x018E
#define LB_FINDSTRING 0x018F
#define LB_GETSELCOUNT 0x0190
#define LB_GETSELITEMS 0x0191
#define LB_SETTABSTOPS 0x0192
#define LB_GETHORIZONTALEXTENT 0x0193
#define LB_SETHORIZONTALEXTENT 0x0194
#define LB_SETCOLUMNWIDTH 0x0195
#define LB_ADDFILE 0x0196
#define LB_SETTOPINDEX 0x0197
#define LB_GETITEMRECT 0x0198
#define LB_GETITEMDATA 0x0199
#define LB_SETITEMDATA 0x019A
#define LB_SELITEMRANGE 0x019B
#define LB_SETANCHORINDEX 0x019C
#define LB_GETANCHORINDEX 0x019D
#define LB_SETCARETINDEX 0x019E
#define LB_GETCARETINDEX 0x019F
#define LB_SETITEMHEIGHT 0x01A0
#define LB_GETITEMHEIGHT 0x01A1
#define LB_FINDSTRINGEXACT 0x01A2
#define LB_SETLOCALE 0x01A5
#define LB_GETLOCALE 0x01A6
#define LB_SETCOUNT 0x01A7

#define LB_INITSTORAGE 0x01A8
#define LB_ITEMFROMPOINT 0x01A9







#define LB_GETLISTBOXINFO 0x01B2



#define LB_MSGMAX 0x01B3
# 9901 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Listbox Styles

 */
# 9904 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define LBS_NOTIFY 0x0001L
#define LBS_SORT 0x0002L
#define LBS_NOREDRAW 0x0004L
#define LBS_MULTIPLESEL 0x0008L
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS 0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#define LBS_NODATA 0x2000L

#define LBS_NOSEL 0x4000L

#define LBS_COMBOBOX 0x8000L

#define LBS_STANDARD (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)





/*

 * Combo Box return Values

 */
# 9932 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CB_OKAY 0
#define CB_ERR (-1)
#define CB_ERRSPACE (-2)


/*

 * Combo Box Notification Codes

 */
# 9940 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CBN_ERRSPACE (-1)
#define CBN_SELCHANGE 1
#define CBN_DBLCLK 2
#define CBN_SETFOCUS 3
#define CBN_KILLFOCUS 4
#define CBN_EDITCHANGE 5
#define CBN_EDITUPDATE 6
#define CBN_DROPDOWN 7
#define CBN_CLOSEUP 8
#define CBN_SELENDOK 9
#define CBN_SELENDCANCEL 10



/*

 * Combo Box styles

 */
# 9957 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CBS_SIMPLE 0x0001L
#define CBS_DROPDOWN 0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT 0x0080L
#define CBS_SORT 0x0100L
#define CBS_HASSTRINGS 0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L

#define CBS_UPPERCASE 0x2000L
#define CBS_LOWERCASE 0x4000L





/*

 * Combo Box messages

 */
# 9980 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CB_GETEDITSEL 0x0140
#define CB_LIMITTEXT 0x0141
#define CB_SETEDITSEL 0x0142
#define CB_ADDSTRING 0x0143
#define CB_DELETESTRING 0x0144
#define CB_DIR 0x0145
#define CB_GETCOUNT 0x0146
#define CB_GETCURSEL 0x0147
#define CB_GETLBTEXT 0x0148
#define CB_GETLBTEXTLEN 0x0149
#define CB_INSERTSTRING 0x014A
#define CB_RESETCONTENT 0x014B
#define CB_FINDSTRING 0x014C
#define CB_SELECTSTRING 0x014D
#define CB_SETCURSEL 0x014E
#define CB_SHOWDROPDOWN 0x014F
#define CB_GETITEMDATA 0x0150
#define CB_SETITEMDATA 0x0151
#define CB_GETDROPPEDCONTROLRECT 0x0152
#define CB_SETITEMHEIGHT 0x0153
#define CB_GETITEMHEIGHT 0x0154
#define CB_SETEXTENDEDUI 0x0155
#define CB_GETEXTENDEDUI 0x0156
#define CB_GETDROPPEDSTATE 0x0157
#define CB_FINDSTRINGEXACT 0x0158
#define CB_SETLOCALE 0x0159
#define CB_GETLOCALE 0x015A

#define CB_GETTOPINDEX 0x015b
#define CB_SETTOPINDEX 0x015c
#define CB_GETHORIZONTALEXTENT 0x015d
#define CB_SETHORIZONTALEXTENT 0x015e
#define CB_GETDROPPEDWIDTH 0x015f
#define CB_SETDROPPEDWIDTH 0x0160
#define CB_INITSTORAGE 0x0161






#define CB_GETCOMBOBOXINFO 0x0164



#define CB_MSGMAX 0x0165
# 10040 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Scroll Bar Styles

 */
# 10043 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SBS_HORZ 0x0000L
#define SBS_VERT 0x0001L
#define SBS_TOPALIGN 0x0002L
#define SBS_LEFTALIGN 0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN 0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX 0x0008L

#define SBS_SIZEGRIP 0x0010L





/*

 * Scroll bar messages

 */
# 10063 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SBM_SETPOS 0x00E0
#define SBM_GETPOS 0x00E1
#define SBM_SETRANGE 0x00E2
#define SBM_SETRANGEREDRAW 0x00E6
#define SBM_GETRANGE 0x00E3
#define SBM_ENABLE_ARROWS 0x00E4

#define SBM_SETSCROLLINFO 0x00E9
#define SBM_GETSCROLLINFO 0x00EA



#define SBM_GETSCROLLBARINFO 0x00EB



#define SIF_RANGE 0x0001
#define SIF_PAGE 0x0002
#define SIF_POS 0x0004
#define SIF_DISABLENOSCROLL 0x0008
#define SIF_TRACKPOS 0x0010
#define SIF_ALL (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)

typedef struct tagSCROLLINFO
{
    UINT cbSize;
    UINT fMask;
    int nMin;
    int nMax;
    UINT nPage;
    int nPos;
    int nTrackPos;
} SCROLLINFO, *LPSCROLLINFO;
typedef SCROLLINFO const *LPCSCROLLINFO;


int

SetScrollInfo(
    HWND hwnd,
    int nBar,
    LPCSCROLLINFO lpsi,
    BOOL redraw);


BOOL

GetScrollInfo(
    HWND hwnd,
    int nBar,
    LPSCROLLINFO lpsi);







/*

 * MDI client style bits

 */
# 10124 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MDIS_ALLCHILDSTYLES 0x0001

/*

 * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.

 */
# 10129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MDITILE_VERTICAL 0x0000
#define MDITILE_HORIZONTAL 0x0001
#define MDITILE_SKIPDISABLED 0x0002

#define MDITILE_ZORDER 0x0004


typedef struct tagMDICREATESTRUCTA {
    LPCSTR szClass;
    LPCSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam; /* app-defined stuff */
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR szClass;
    LPCWSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam; /* app-defined stuff */
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;




typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;


typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;


LRESULT

DefFrameProcA(
    HWND hWnd,
    HWND hWndMDIClient,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT

DefFrameProcW(
    HWND hWnd,
    HWND hWndMDIClient,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);



#define DefFrameProc DefFrameProcA




LRESULT





DefMDIChildProcA(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);


LRESULT





DefMDIChildProcW(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);



#define DefMDIChildProc DefMDIChildProcA





BOOL

TranslateMDISysAccel(
    HWND hWndClient,
    LPMSG lpMsg);




UINT

ArrangeIconicWindows(
    HWND hWnd);


HWND

CreateMDIWindowA(
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam);

HWND

CreateMDIWindowW(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HINSTANCE hInstance,
    LPARAM lParam);



#define CreateMDIWindow CreateMDIWindowA




WORD

TileWindows(
    HWND hwndParent,
    UINT wHow,
    const RECT * lpRect,
    UINT cKids,
    const HWND * lpKids);


WORD
 CascadeWindows(
    HWND hwndParent,
    UINT wHow,
    const RECT * lpRect,
    UINT cKids,
    const HWND * lpKids);






/****** Help support ********************************************************/



typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {

    DWORD mkSize;



    CHAR mkKeylist;
    CHAR szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {

    DWORD mkSize;



    WCHAR mkKeylist;
    WCHAR szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;





typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;


typedef struct tagHELPWININFOA {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    CHAR rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    WCHAR rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;





typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;



/*

 * Commands to pass to WinHelp()

 */
# 10368 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define HELP_CONTEXT 0x0001L
#define HELP_QUIT 0x0002L
#define HELP_INDEX 0x0003L
#define HELP_CONTENTS 0x0003L
#define HELP_HELPONHELP 0x0004L
#define HELP_SETINDEX 0x0005L
#define HELP_SETCONTENTS 0x0005L
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE 0x0009L
#define HELP_KEY 0x0101L
#define HELP_COMMAND 0x0102L
#define HELP_PARTIALKEY 0x0105L
#define HELP_MULTIKEY 0x0201L
#define HELP_SETWINPOS 0x0203L

#define HELP_CONTEXTMENU 0x000a
#define HELP_FINDER 0x000b
#define HELP_WM_HELP 0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD 0x8000
#define HELP_TCARD_DATA 0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011

// These are in winhelp.h in Win95.
#define IDH_NO_HELP 28440
#define IDH_MISSING_CONTEXT 28441
#define IDH_GENERIC_HELP_BUTTON 28442
#define IDH_OK 28443
#define IDH_CANCEL 28444
#define IDH_HELP 28445






BOOL

WinHelpA(
    HWND hWndMain,
    LPCSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData);

BOOL

WinHelpW(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData);



#define WinHelp WinHelpA






#define GR_GDIOBJECTS 0
#define GR_USEROBJECTS 1


#define GR_GDIOBJECTS_PEAK 2
#define GR_USEROBJECTS_PEAK 4



#define GR_GLOBAL ((HANDLE)-2)




DWORD

GetGuiResources(
    HANDLE hProcess,
    DWORD uiFlags);





/*

 * Parameter for SystemParametersInfo.

 */
# 10458 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SPI_GETBEEP 0x0001
#define SPI_SETBEEP 0x0002
#define SPI_GETMOUSE 0x0003
#define SPI_SETMOUSE 0x0004
#define SPI_GETBORDER 0x0005
#define SPI_SETBORDER 0x0006
#define SPI_GETKEYBOARDSPEED 0x000A
#define SPI_SETKEYBOARDSPEED 0x000B
#define SPI_LANGDRIVER 0x000C
#define SPI_ICONHORIZONTALSPACING 0x000D
#define SPI_GETSCREENSAVETIMEOUT 0x000E
#define SPI_SETSCREENSAVETIMEOUT 0x000F
#define SPI_GETSCREENSAVEACTIVE 0x0010
#define SPI_SETSCREENSAVEACTIVE 0x0011
#define SPI_GETGRIDGRANULARITY 0x0012
#define SPI_SETGRIDGRANULARITY 0x0013
#define SPI_SETDESKWALLPAPER 0x0014
#define SPI_SETDESKPATTERN 0x0015
#define SPI_GETKEYBOARDDELAY 0x0016
#define SPI_SETKEYBOARDDELAY 0x0017
#define SPI_ICONVERTICALSPACING 0x0018
#define SPI_GETICONTITLEWRAP 0x0019
#define SPI_SETICONTITLEWRAP 0x001A
#define SPI_GETMENUDROPALIGNMENT 0x001B
#define SPI_SETMENUDROPALIGNMENT 0x001C
#define SPI_SETDOUBLECLKWIDTH 0x001D
#define SPI_SETDOUBLECLKHEIGHT 0x001E
#define SPI_GETICONTITLELOGFONT 0x001F
#define SPI_SETDOUBLECLICKTIME 0x0020
#define SPI_SETMOUSEBUTTONSWAP 0x0021
#define SPI_SETICONTITLELOGFONT 0x0022
#define SPI_GETFASTTASKSWITCH 0x0023
#define SPI_SETFASTTASKSWITCH 0x0024

#define SPI_SETDRAGFULLWINDOWS 0x0025
#define SPI_GETDRAGFULLWINDOWS 0x0026
#define SPI_GETNONCLIENTMETRICS 0x0029
#define SPI_SETNONCLIENTMETRICS 0x002A
#define SPI_GETMINIMIZEDMETRICS 0x002B
#define SPI_SETMINIMIZEDMETRICS 0x002C
#define SPI_GETICONMETRICS 0x002D
#define SPI_SETICONMETRICS 0x002E
#define SPI_SETWORKAREA 0x002F
#define SPI_GETWORKAREA 0x0030
#define SPI_SETPENWINDOWS 0x0031

#define SPI_GETHIGHCONTRAST 0x0042
#define SPI_SETHIGHCONTRAST 0x0043
#define SPI_GETKEYBOARDPREF 0x0044
#define SPI_SETKEYBOARDPREF 0x0045
#define SPI_GETSCREENREADER 0x0046
#define SPI_SETSCREENREADER 0x0047
#define SPI_GETANIMATION 0x0048
#define SPI_SETANIMATION 0x0049
#define SPI_GETFONTSMOOTHING 0x004A
#define SPI_SETFONTSMOOTHING 0x004B
#define SPI_SETDRAGWIDTH 0x004C
#define SPI_SETDRAGHEIGHT 0x004D
#define SPI_SETHANDHELD 0x004E
#define SPI_GETLOWPOWERTIMEOUT 0x004F
#define SPI_GETPOWEROFFTIMEOUT 0x0050
#define SPI_SETLOWPOWERTIMEOUT 0x0051
#define SPI_SETPOWEROFFTIMEOUT 0x0052
#define SPI_GETLOWPOWERACTIVE 0x0053
#define SPI_GETPOWEROFFACTIVE 0x0054
#define SPI_SETLOWPOWERACTIVE 0x0055
#define SPI_SETPOWEROFFACTIVE 0x0056
#define SPI_SETCURSORS 0x0057
#define SPI_SETICONS 0x0058
#define SPI_GETDEFAULTINPUTLANG 0x0059
#define SPI_SETDEFAULTINPUTLANG 0x005A
#define SPI_SETLANGTOGGLE 0x005B
#define SPI_GETWINDOWSEXTENSION 0x005C
#define SPI_SETMOUSETRAILS 0x005D
#define SPI_GETMOUSETRAILS 0x005E
#define SPI_SETSCREENSAVERRUNNING 0x0061
#define SPI_SCREENSAVERRUNNING SPI_SETSCREENSAVERRUNNING

#define SPI_GETFILTERKEYS 0x0032
#define SPI_SETFILTERKEYS 0x0033
#define SPI_GETTOGGLEKEYS 0x0034
#define SPI_SETTOGGLEKEYS 0x0035
#define SPI_GETMOUSEKEYS 0x0036
#define SPI_SETMOUSEKEYS 0x0037
#define SPI_GETSHOWSOUNDS 0x0038
#define SPI_SETSHOWSOUNDS 0x0039
#define SPI_GETSTICKYKEYS 0x003A
#define SPI_SETSTICKYKEYS 0x003B
#define SPI_GETACCESSTIMEOUT 0x003C
#define SPI_SETACCESSTIMEOUT 0x003D

#define SPI_GETSERIALKEYS 0x003E
#define SPI_SETSERIALKEYS 0x003F

#define SPI_GETSOUNDSENTRY 0x0040
#define SPI_SETSOUNDSENTRY 0x0041

#define SPI_GETSNAPTODEFBUTTON 0x005F
#define SPI_SETSNAPTODEFBUTTON 0x0060


#define SPI_GETMOUSEHOVERWIDTH 0x0062
#define SPI_SETMOUSEHOVERWIDTH 0x0063
#define SPI_GETMOUSEHOVERHEIGHT 0x0064
#define SPI_SETMOUSEHOVERHEIGHT 0x0065
#define SPI_GETMOUSEHOVERTIME 0x0066
#define SPI_SETMOUSEHOVERTIME 0x0067
#define SPI_GETWHEELSCROLLLINES 0x0068
#define SPI_SETWHEELSCROLLLINES 0x0069
#define SPI_GETMENUSHOWDELAY 0x006A
#define SPI_SETMENUSHOWDELAY 0x006B


#define SPI_GETWHEELSCROLLCHARS 0x006C
#define SPI_SETWHEELSCROLLCHARS 0x006D


#define SPI_GETSHOWIMEUI 0x006E
#define SPI_SETSHOWIMEUI 0x006F




#define SPI_GETMOUSESPEED 0x0070
#define SPI_SETMOUSESPEED 0x0071
#define SPI_GETSCREENSAVERRUNNING 0x0072
#define SPI_GETDESKWALLPAPER 0x0073



#define SPI_GETAUDIODESCRIPTION 0x0074
#define SPI_SETAUDIODESCRIPTION 0x0075

#define SPI_GETSCREENSAVESECURE 0x0076
#define SPI_SETSCREENSAVESECURE 0x0077



#define SPI_GETHUNGAPPTIMEOUT 0x0078
#define SPI_SETHUNGAPPTIMEOUT 0x0079
#define SPI_GETWAITTOKILLTIMEOUT 0x007A
#define SPI_SETWAITTOKILLTIMEOUT 0x007B
#define SPI_GETWAITTOKILLSERVICETIMEOUT 0x007C
#define SPI_SETWAITTOKILLSERVICETIMEOUT 0x007D
#define SPI_GETMOUSEDOCKTHRESHOLD 0x007E
#define SPI_SETMOUSEDOCKTHRESHOLD 0x007F
#define SPI_GETPENDOCKTHRESHOLD 0x0080
#define SPI_SETPENDOCKTHRESHOLD 0x0081
#define SPI_GETWINARRANGING 0x0082
#define SPI_SETWINARRANGING 0x0083
#define SPI_GETMOUSEDRAGOUTTHRESHOLD 0x0084
#define SPI_SETMOUSEDRAGOUTTHRESHOLD 0x0085
#define SPI_GETPENDRAGOUTTHRESHOLD 0x0086
#define SPI_SETPENDRAGOUTTHRESHOLD 0x0087
#define SPI_GETMOUSESIDEMOVETHRESHOLD 0x0088
#define SPI_SETMOUSESIDEMOVETHRESHOLD 0x0089
#define SPI_GETPENSIDEMOVETHRESHOLD 0x008A
#define SPI_SETPENSIDEMOVETHRESHOLD 0x008B
#define SPI_GETDRAGFROMMAXIMIZE 0x008C
#define SPI_SETDRAGFROMMAXIMIZE 0x008D
#define SPI_GETSNAPSIZING 0x008E
#define SPI_SETSNAPSIZING 0x008F
#define SPI_GETDOCKMOVING 0x0090
#define SPI_SETDOCKMOVING 0x0091




#define SPI_GETACTIVEWINDOWTRACKING 0x1000
#define SPI_SETACTIVEWINDOWTRACKING 0x1001
#define SPI_GETMENUANIMATION 0x1002
#define SPI_SETMENUANIMATION 0x1003
#define SPI_GETCOMBOBOXANIMATION 0x1004
#define SPI_SETCOMBOBOXANIMATION 0x1005
#define SPI_GETLISTBOXSMOOTHSCROLLING 0x1006
#define SPI_SETLISTBOXSMOOTHSCROLLING 0x1007
#define SPI_GETGRADIENTCAPTIONS 0x1008
#define SPI_SETGRADIENTCAPTIONS 0x1009
#define SPI_GETKEYBOARDCUES 0x100A
#define SPI_SETKEYBOARDCUES 0x100B
#define SPI_GETMENUUNDERLINES SPI_GETKEYBOARDCUES
#define SPI_SETMENUUNDERLINES SPI_SETKEYBOARDCUES
#define SPI_GETACTIVEWNDTRKZORDER 0x100C
#define SPI_SETACTIVEWNDTRKZORDER 0x100D
#define SPI_GETHOTTRACKING 0x100E
#define SPI_SETHOTTRACKING 0x100F
#define SPI_GETMENUFADE 0x1012
#define SPI_SETMENUFADE 0x1013
#define SPI_GETSELECTIONFADE 0x1014
#define SPI_SETSELECTIONFADE 0x1015
#define SPI_GETTOOLTIPANIMATION 0x1016
#define SPI_SETTOOLTIPANIMATION 0x1017
#define SPI_GETTOOLTIPFADE 0x1018
#define SPI_SETTOOLTIPFADE 0x1019
#define SPI_GETCURSORSHADOW 0x101A
#define SPI_SETCURSORSHADOW 0x101B

#define SPI_GETMOUSESONAR 0x101C
#define SPI_SETMOUSESONAR 0x101D
#define SPI_GETMOUSECLICKLOCK 0x101E
#define SPI_SETMOUSECLICKLOCK 0x101F
#define SPI_GETMOUSEVANISH 0x1020
#define SPI_SETMOUSEVANISH 0x1021
#define SPI_GETFLATMENU 0x1022
#define SPI_SETFLATMENU 0x1023
#define SPI_GETDROPSHADOW 0x1024
#define SPI_SETDROPSHADOW 0x1025
#define SPI_GETBLOCKSENDINPUTRESETS 0x1026
#define SPI_SETBLOCKSENDINPUTRESETS 0x1027


#define SPI_GETUIEFFECTS 0x103E
#define SPI_SETUIEFFECTS 0x103F


#define SPI_GETDISABLEOVERLAPPEDCONTENT 0x1040
#define SPI_SETDISABLEOVERLAPPEDCONTENT 0x1041
#define SPI_GETCLIENTAREAANIMATION 0x1042
#define SPI_SETCLIENTAREAANIMATION 0x1043
#define SPI_GETCLEARTYPE 0x1048
#define SPI_SETCLEARTYPE 0x1049
#define SPI_GETSPEECHRECOGNITION 0x104A
#define SPI_SETSPEECHRECOGNITION 0x104B


#define SPI_GETFOREGROUNDLOCKTIMEOUT 0x2000
#define SPI_SETFOREGROUNDLOCKTIMEOUT 0x2001
#define SPI_GETACTIVEWNDTRKTIMEOUT 0x2002
#define SPI_SETACTIVEWNDTRKTIMEOUT 0x2003
#define SPI_GETFOREGROUNDFLASHCOUNT 0x2004
#define SPI_SETFOREGROUNDFLASHCOUNT 0x2005
#define SPI_GETCARETWIDTH 0x2006
#define SPI_SETCARETWIDTH 0x2007


#define SPI_GETMOUSECLICKLOCKTIME 0x2008
#define SPI_SETMOUSECLICKLOCKTIME 0x2009
#define SPI_GETFONTSMOOTHINGTYPE 0x200A
#define SPI_SETFONTSMOOTHINGTYPE 0x200B

/* constants for SPI_GETFONTSMOOTHINGTYPE and SPI_SETFONTSMOOTHINGTYPE: */
#define FE_FONTSMOOTHINGSTANDARD 0x0001
#define FE_FONTSMOOTHINGCLEARTYPE 0x0002

#define SPI_GETFONTSMOOTHINGCONTRAST 0x200C
#define SPI_SETFONTSMOOTHINGCONTRAST 0x200D

#define SPI_GETFOCUSBORDERWIDTH 0x200E
#define SPI_SETFOCUSBORDERWIDTH 0x200F
#define SPI_GETFOCUSBORDERHEIGHT 0x2010
#define SPI_SETFOCUSBORDERHEIGHT 0x2011

#define SPI_GETFONTSMOOTHINGORIENTATION 0x2012
#define SPI_SETFONTSMOOTHINGORIENTATION 0x2013

/* constants for SPI_GETFONTSMOOTHINGORIENTATION and SPI_SETFONTSMOOTHINGORIENTATION: */
#define FE_FONTSMOOTHINGORIENTATIONBGR 0x0000
#define FE_FONTSMOOTHINGORIENTATIONRGB 0x0001



#define SPI_GETMINIMUMHITRADIUS 0x2014
#define SPI_SETMINIMUMHITRADIUS 0x2015
#define SPI_GETMESSAGEDURATION 0x2016
#define SPI_SETMESSAGEDURATION 0x2017




/*

 * Flags

 */
# 10730 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SPIF_UPDATEINIFILE 0x0001
#define SPIF_SENDWININICHANGE 0x0002
#define SPIF_SENDCHANGE SPIF_SENDWININICHANGE


#define METRICS_USEDEFAULT -1


typedef struct tagNONCLIENTMETRICSA
{
    UINT cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;

    int iPaddedBorderWidth;

} NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, * LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;

    int iPaddedBorderWidth;

} NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, * LPNONCLIENTMETRICSW;





typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;




#define ARW_BOTTOMLEFT 0x0000L
#define ARW_BOTTOMRIGHT 0x0001L
#define ARW_TOPLEFT 0x0002L
#define ARW_TOPRIGHT 0x0003L
#define ARW_STARTMASK 0x0003L
#define ARW_STARTRIGHT 0x0001L
#define ARW_STARTTOP 0x0002L

#define ARW_LEFT 0x0000L
#define ARW_RIGHT 0x0000L
#define ARW_UP 0x0004L
#define ARW_DOWN 0x0004L
#define ARW_HIDE 0x0008L

typedef struct tagMINIMIZEDMETRICS
{
    UINT cbSize;
    int iWidth;
    int iHorzGap;
    int iVertGap;
    int iArrange;
} MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;



typedef struct tagICONMETRICSA
{
    UINT cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTA lfFont;
} ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTW lfFont;
} ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;





typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;




typedef struct tagANIMATIONINFO
{
    UINT cbSize;
    int iMinAnimate;
} ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT cbSize;
    DWORD dwFlags;
    LPSTR lpszActivePort;
    LPSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
} SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR lpszActivePort;
    LPWSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
} SERIALKEYSW, *LPSERIALKEYSW;




typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;


/* flags for SERIALKEYS dwFlags field */
#define SERKF_SERIALKEYSON 0x00000001
#define SERKF_AVAILABLE 0x00000002
#define SERKF_INDICATOR 0x00000004


typedef struct tagHIGHCONTRASTA
{
    UINT cbSize;
    DWORD dwFlags;
    LPSTR lpszDefaultScheme;
} HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT cbSize;
    DWORD dwFlags;
    LPWSTR lpszDefaultScheme;
} HIGHCONTRASTW, *LPHIGHCONTRASTW;




typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;


/* flags for HIGHCONTRAST dwFlags field */
#define HCF_HIGHCONTRASTON 0x00000001
#define HCF_AVAILABLE 0x00000002
#define HCF_HOTKEYACTIVE 0x00000004
#define HCF_CONFIRMHOTKEY 0x00000008
#define HCF_HOTKEYSOUND 0x00000010
#define HCF_INDICATOR 0x00000020
#define HCF_HOTKEYAVAILABLE 0x00000040
#define HCF_LOGONDESKTOP 0x00000100
#define HCF_DEFAULTDESKTOP 0x00000200

/* Flags for ChangeDisplaySettings */
#define CDS_UPDATEREGISTRY 0x00000001
#define CDS_TEST 0x00000002
#define CDS_FULLSCREEN 0x00000004
#define CDS_GLOBAL 0x00000008
#define CDS_SET_PRIMARY 0x00000010
#define CDS_VIDEOPARAMETERS 0x00000020

#define CDS_ENABLE_UNSAFE_MODES 0x00000100
#define CDS_DISABLE_UNSAFE_MODES 0x00000200

#define CDS_RESET 0x40000000
#define CDS_RESET_EX 0x20000000
#define CDS_NORESET 0x10000000

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/tvout.h" 1
/*++



Copyright (c) Microsoft Corporation. All rights reserved.

*/
# 7 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/tvout.h"
#define __TVOUT__ 
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/tvout.h"
typedef struct _VIDEOPARAMETERS {
    GUID Guid; // GUID for this structure
    ULONG dwOffset; // leave it 0 for now.
    ULONG dwCommand; // VP_COMMAND_*            SET or GET
    ULONG dwFlags; // bitfield, defined below SET or GET
    ULONG dwMode; // bitfield, defined below SET or GET
    ULONG dwTVStandard; // bitfield, defined below SET or GET
    ULONG dwAvailableModes; // bitfield, defined below GET
    ULONG dwAvailableTVStandard; // bitfield, defined below GET
    ULONG dwFlickerFilter; // value                   SET or GET
    ULONG dwOverScanX; // value                   SET or GET
    ULONG dwOverScanY; //                         SET or GET
    ULONG dwMaxUnscaledX; // value                   SET or GET
    ULONG dwMaxUnscaledY; //                         SET or GET
    ULONG dwPositionX; // value                   SET or GET
    ULONG dwPositionY; //                         SET or GET
    ULONG dwBrightness; // value                   SET or GET
    ULONG dwContrast; // value                   SET or GET
    ULONG dwCPType; // copy protection type    SET or GET
    ULONG dwCPCommand; // VP_CP_CMD_
    ULONG dwCPStandard; // what TV standards CP is available on. GET
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits; // (a dword for alignment) SET(bits 0 and 1 valid).
    UCHAR bOEMCopyProtection[256]; // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;

#define VP_COMMAND_GET 0x0001
                                        // returned Flags = 0 if not supported.
#define VP_COMMAND_SET 0x0002

#define VP_FLAGS_TV_MODE 0x0001
#define VP_FLAGS_TV_STANDARD 0x0002
#define VP_FLAGS_FLICKER 0x0004
#define VP_FLAGS_OVERSCAN 0x0008
#define VP_FLAGS_MAX_UNSCALED 0x0010
#define VP_FLAGS_POSITION 0x0020
#define VP_FLAGS_BRIGHTNESS 0x0040
#define VP_FLAGS_CONTRAST 0x0080
#define VP_FLAGS_COPYPROTECT 0x0100

#define VP_MODE_WIN_GRAPHICS 0x0001
#define VP_MODE_TV_PLAYBACK 0x0002

#define VP_TV_STANDARD_NTSC_M 0x0001
#define VP_TV_STANDARD_NTSC_M_J 0x0002
#define VP_TV_STANDARD_PAL_B 0x0004
#define VP_TV_STANDARD_PAL_D 0x0008
#define VP_TV_STANDARD_PAL_H 0x0010
#define VP_TV_STANDARD_PAL_I 0x0020
#define VP_TV_STANDARD_PAL_M 0x0040
#define VP_TV_STANDARD_PAL_N 0x0080
#define VP_TV_STANDARD_SECAM_B 0x0100
#define VP_TV_STANDARD_SECAM_D 0x0200
#define VP_TV_STANDARD_SECAM_G 0x0400
#define VP_TV_STANDARD_SECAM_H 0x0800
#define VP_TV_STANDARD_SECAM_K 0x1000
#define VP_TV_STANDARD_SECAM_K1 0x2000
#define VP_TV_STANDARD_SECAM_L 0x4000
#define VP_TV_STANDARD_WIN_VGA 0x8000
// and the rest
#define VP_TV_STANDARD_NTSC_433 0x00010000
#define VP_TV_STANDARD_PAL_G 0x00020000
#define VP_TV_STANDARD_PAL_60 0x00040000
#define VP_TV_STANDARD_SECAM_L1 0x00080000

#define VP_CP_TYPE_APS_TRIGGER 0x0001
#define VP_CP_TYPE_MACROVISION 0x0002

#define VP_CP_CMD_ACTIVATE 0x0001
#define VP_CP_CMD_DEACTIVATE 0x0002
#define VP_CP_CMD_CHANGE 0x0004
# 10932 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h" 2

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL 0
#define DISP_CHANGE_RESTART 1
#define DISP_CHANGE_FAILED -1
#define DISP_CHANGE_BADMODE -2
#define DISP_CHANGE_NOTUPDATED -3
#define DISP_CHANGE_BADFLAGS -4
#define DISP_CHANGE_BADPARAM -5

#define DISP_CHANGE_BADDUALVIEW -6






LONG

ChangeDisplaySettingsA(
    DEVMODEA* lpDevMode,
    DWORD dwFlags);

LONG

ChangeDisplaySettingsW(
    DEVMODEW* lpDevMode,
    DWORD dwFlags);



#define ChangeDisplaySettings ChangeDisplaySettingsA



LONG

ChangeDisplaySettingsExA(
    LPCSTR lpszDeviceName,
    DEVMODEA* lpDevMode,
    HWND hwnd,
    DWORD dwflags,
    LPVOID lParam);

LONG

ChangeDisplaySettingsExW(
    LPCWSTR lpszDeviceName,
    DEVMODEW* lpDevMode,
    HWND hwnd,
    DWORD dwflags,
    LPVOID lParam);



#define ChangeDisplaySettingsEx ChangeDisplaySettingsExA


#define ENUM_CURRENT_SETTINGS ((DWORD)-1)
#define ENUM_REGISTRY_SETTINGS ((DWORD)-2)


BOOL

EnumDisplaySettingsA(
    LPCSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEA* lpDevMode);

BOOL

EnumDisplaySettingsW(
    LPCWSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEW* lpDevMode);



#define EnumDisplaySettings EnumDisplaySettingsA





BOOL

EnumDisplaySettingsExA(
    LPCSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEA* lpDevMode,
    DWORD dwFlags);

BOOL

EnumDisplaySettingsExW(
    LPCWSTR lpszDeviceName,
    DWORD iModeNum,
    DEVMODEW* lpDevMode,
    DWORD dwFlags);



#define EnumDisplaySettingsEx EnumDisplaySettingsExA


/* Flags for EnumDisplaySettingsEx */
#define EDS_RAWMODE 0x00000002
#define EDS_ROTATEDMODE 0x00000004


BOOL

EnumDisplayDevicesA(
    LPCSTR lpDevice,
    DWORD iDevNum,
    PDISPLAY_DEVICEA lpDisplayDevice,
    DWORD dwFlags);

BOOL

EnumDisplayDevicesW(
    LPCWSTR lpDevice,
    DWORD iDevNum,
    PDISPLAY_DEVICEW lpDisplayDevice,
    DWORD dwFlags);



#define EnumDisplayDevices EnumDisplayDevicesA


/* Flags for EnumDisplayDevices */
#define EDD_GET_DEVICE_INTERFACE_NAME 0x00000001






LONG

GetDisplayConfigBufferSizes(
    UINT32 flags,
    UINT32* numPathArrayElements,
    UINT32* numModeInfoArrayElements);


LONG

SetDisplayConfig(
    UINT32 numPathArrayElements,
    DISPLAYCONFIG_PATH_INFO* pathArray,
    UINT32 numModeInfoArrayElements,
    DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    UINT32 flags);


LONG

QueryDisplayConfig(
    UINT32 flags,
    UINT32* numPathArrayElements,
    DISPLAYCONFIG_PATH_INFO* pathArray,
    UINT32* numModeInfoArrayElements,
    DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);


LONG

DisplayConfigGetDeviceInfo(
    DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);


LONG

DisplayConfigSetDeviceInfo(
    DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);








BOOL

SystemParametersInfoA(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);

BOOL

SystemParametersInfoW(
    UINT uiAction,
    UINT uiParam,
    PVOID pvParam,
    UINT fWinIni);



#define SystemParametersInfo SystemParametersInfoA





/*

 * Accessibility support

 */
# 11145 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagFILTERKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec; // Acceptance Delay
    DWORD iDelayMSec; // Delay Until Repeat
    DWORD iRepeatMSec; // Repeat Rate
    DWORD iBounceMSec; // Debounce Time
} FILTERKEYS, *LPFILTERKEYS;

/*

 * FILTERKEYS dwFlags field

 */
# 11158 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define FKF_FILTERKEYSON 0x00000001
#define FKF_AVAILABLE 0x00000002
#define FKF_HOTKEYACTIVE 0x00000004
#define FKF_CONFIRMHOTKEY 0x00000008
#define FKF_HOTKEYSOUND 0x00000010
#define FKF_INDICATOR 0x00000020
#define FKF_CLICKON 0x00000040

typedef struct tagSTICKYKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;

/*

 * STICKYKEYS dwFlags field

 */
# 11175 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SKF_STICKYKEYSON 0x00000001
#define SKF_AVAILABLE 0x00000002
#define SKF_HOTKEYACTIVE 0x00000004
#define SKF_CONFIRMHOTKEY 0x00000008
#define SKF_HOTKEYSOUND 0x00000010
#define SKF_INDICATOR 0x00000020
#define SKF_AUDIBLEFEEDBACK 0x00000040
#define SKF_TRISTATE 0x00000080
#define SKF_TWOKEYSOFF 0x00000100

#define SKF_LALTLATCHED 0x10000000
#define SKF_LCTLLATCHED 0x04000000
#define SKF_LSHIFTLATCHED 0x01000000
#define SKF_RALTLATCHED 0x20000000
#define SKF_RCTLLATCHED 0x08000000
#define SKF_RSHIFTLATCHED 0x02000000
#define SKF_LWINLATCHED 0x40000000
#define SKF_RWINLATCHED 0x80000000
#define SKF_LALTLOCKED 0x00100000
#define SKF_LCTLLOCKED 0x00040000
#define SKF_LSHIFTLOCKED 0x00010000
#define SKF_RALTLOCKED 0x00200000
#define SKF_RCTLLOCKED 0x00080000
#define SKF_RSHIFTLOCKED 0x00020000
#define SKF_LWINLOCKED 0x00400000
#define SKF_RWINLOCKED 0x00800000


typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;

/*

 * MOUSEKEYS dwFlags field

 */
# 11217 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MKF_MOUSEKEYSON 0x00000001
#define MKF_AVAILABLE 0x00000002
#define MKF_HOTKEYACTIVE 0x00000004
#define MKF_CONFIRMHOTKEY 0x00000008
#define MKF_HOTKEYSOUND 0x00000010
#define MKF_INDICATOR 0x00000020
#define MKF_MODIFIERS 0x00000040
#define MKF_REPLACENUMBERS 0x00000080

#define MKF_LEFTBUTTONSEL 0x10000000
#define MKF_RIGHTBUTTONSEL 0x20000000
#define MKF_LEFTBUTTONDOWN 0x01000000
#define MKF_RIGHTBUTTONDOWN 0x02000000
#define MKF_MOUSEMODE 0x80000000


typedef struct tagACCESSTIMEOUT
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;

/*

 * ACCESSTIMEOUT dwFlags field

 */
# 11243 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ATF_TIMEOUTON 0x00000001
#define ATF_ONOFFFEEDBACK 0x00000002

/* values for SOUNDSENTRY iFSGrafEffect field */
#define SSGF_NONE 0
#define SSGF_DISPLAY 3

/* values for SOUNDSENTRY iFSTextEffect field */
#define SSTF_NONE 0
#define SSTF_CHARS 1
#define SSTF_BORDER 2
#define SSTF_DISPLAY 3

/* values for SOUNDSENTRY iWindowsEffect field */
#define SSWF_NONE 0
#define SSWF_TITLE 1
#define SSWF_WINDOW 2
#define SSWF_DISPLAY 3
#define SSWF_CUSTOM 4

typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;




typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;


/*

 * SOUNDSENTRY dwFlags field

 */
# 11304 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SSF_SOUNDSENTRYON 0x00000001
#define SSF_AVAILABLE 0x00000002
#define SSF_INDICATOR 0x00000004



BOOL

SoundSentry(void);


typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;

/*

 * TOGGLEKEYS dwFlags field

 */
# 11324 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define TKF_TOGGLEKEYSON 0x00000001
#define TKF_AVAILABLE 0x00000002
#define TKF_HOTKEYACTIVE 0x00000004
#define TKF_CONFIRMHOTKEY 0x00000008
#define TKF_HOTKEYSOUND 0x00000010
#define TKF_INDICATOR 0x00000020


typedef struct tagAUDIODESCRIPTION {
    UINT cbSize; // sizeof(AudioDescriptionType)
    BOOL Enabled; // On/Off
    LCID Locale; // locale ID for language
} AUDIODESCRIPTION, *LPAUDIODESCRIPTION;



/*

 * Set debug level

 */
# 11344 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

void

SetDebugErrorLevel(
    DWORD dwLevel);

/*

 * SetLastErrorEx() types.

 */
# 11354 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SLE_ERROR 0x00000001
#define SLE_MINORERROR 0x00000002
#define SLE_WARNING 0x00000003


void

SetLastErrorEx(
    DWORD dwErrCode,
    DWORD dwType);


int

InternalGetWindowText(
    HWND hWnd,
    LPWSTR pString,
    int cchMaxCount);




BOOL

EndTask(
    HWND hWnd,
    BOOL fShutDown,
    BOOL fForce);



BOOL

CancelShutdown(
    void);




/*

 * Multimonitor API.

 */
# 11397 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MONITOR_DEFAULTTONULL 0x00000000
#define MONITOR_DEFAULTTOPRIMARY 0x00000001
#define MONITOR_DEFAULTTONEAREST 0x00000002


HMONITOR

MonitorFromPoint(
    POINT pt,
    DWORD dwFlags);


HMONITOR

MonitorFromRect(
    LPCRECT lprc,
    DWORD dwFlags);


HMONITOR

MonitorFromWindow(
    HWND hwnd,
    DWORD dwFlags);

#define MONITORINFOF_PRIMARY 0x00000001





typedef struct tagMONITORINFO
{
    DWORD cbSize;
    RECT rcMonitor;
    RECT rcWork;
    DWORD dwFlags;
} MONITORINFO, *LPMONITORINFO;
# 11453 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMONITORINFOEXA
{
    MONITORINFO;
    CHAR szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW
{
    MONITORINFO;
    WCHAR szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;




typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;




BOOL

GetMonitorInfoA(
    HMONITOR hMonitor,
    LPMONITORINFO lpmi);

BOOL

GetMonitorInfoW(
    HMONITOR hMonitor,
    LPMONITORINFO lpmi);



#define GetMonitorInfo GetMonitorInfoA


typedef BOOL (* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);


BOOL

EnumDisplayMonitors(
    HDC hdc,
    LPCRECT lprcClip,
    MONITORENUMPROC lpfnEnum,
    LPARAM dwData);




/*

 * WinEvents - Active Accessibility hooks

 */
# 11508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

void

NotifyWinEvent(
    DWORD event,
    HWND hwnd,
    LONG idObject,
    LONG idChild);

typedef void (* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD event,
    HWND hwnd,
    LONG idObject,
    LONG idChild,
    DWORD idEventThread,
    DWORD dwmsEventTime);


HWINEVENTHOOK

SetWinEventHook(
    DWORD eventMin,
    DWORD eventMax,
    HMODULE hmodWinEventProc,
    WINEVENTPROC pfnWinEventProc,
    DWORD idProcess,
    DWORD idThread,
    DWORD dwFlags);



BOOL

IsWinEventHookInstalled(
    DWORD event);


/*

 * dwFlags for SetWinEventHook

 */
# 11549 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define WINEVENT_OUTOFCONTEXT 0x0000
#define WINEVENT_SKIPOWNTHREAD 0x0001
#define WINEVENT_SKIPOWNPROCESS 0x0002
#define WINEVENT_INCONTEXT 0x0004


BOOL

UnhookWinEvent(
    HWINEVENTHOOK hWinEventHook);

/*

 * idObject values for WinEventProc and NotifyWinEvent

 */
# 11564 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * hwnd + idObject can be used with OLEACC.DLL's OleGetObjectFromWindow()

 * to get an interface pointer to the container.  indexChild is the item

 * within the container in question.  Setup a VARIANT with vt VT_I4 and

 * lVal the indexChild and pass that in to all methods.  Then you

 * are raring to go.

 */
# 11573 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Common object IDs (cookies, only for sending WM_GETOBJECT to get at the

 * thing in question).  Positive IDs are reserved for apps (app specific),

 * negative IDs are system things and are global, 0 means "just little old

 * me".

 */
# 11579 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CHILDID_SELF 0
#define INDEXID_OBJECT 0
#define INDEXID_CONTAINER 0

/*

 * Reserved IDs for system objects

 */
# 11586 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define OBJID_WINDOW ((LONG)0x00000000)
#define OBJID_SYSMENU ((LONG)0xFFFFFFFF)
#define OBJID_TITLEBAR ((LONG)0xFFFFFFFE)
#define OBJID_MENU ((LONG)0xFFFFFFFD)
#define OBJID_CLIENT ((LONG)0xFFFFFFFC)
#define OBJID_VSCROLL ((LONG)0xFFFFFFFB)
#define OBJID_HSCROLL ((LONG)0xFFFFFFFA)
#define OBJID_SIZEGRIP ((LONG)0xFFFFFFF9)
#define OBJID_CARET ((LONG)0xFFFFFFF8)
#define OBJID_CURSOR ((LONG)0xFFFFFFF7)
#define OBJID_ALERT ((LONG)0xFFFFFFF6)
#define OBJID_SOUND ((LONG)0xFFFFFFF5)
#define OBJID_QUERYCLASSNAMEIDX ((LONG)0xFFFFFFF4)
#define OBJID_NATIVEOM ((LONG)0xFFFFFFF0)

/*

 * EVENT DEFINITION

 */
# 11604 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_MIN 0x00000001
#define EVENT_MAX 0x7FFFFFFF

/*

 *  EVENT_SYSTEM_SOUND

 *  Sent when a sound is played.  Currently nothing is generating this, we

 *  this event when a system sound (for menus, etc) is played.  Apps

 *  generate this, if accessible, when a private sound is played.  For

 *  example, if Mail plays a "New Mail" sound.

 *

 *  System Sounds:

 *  (Generated by PlaySoundEvent in USER itself)

 *      hwnd            is NULL

 *      idObject        is OBJID_SOUND

 *      idChild         is sound child ID if one

 *  App Sounds:

 *  (PlaySoundEvent won't generate notification; up to app)

 *      hwnd + idObject gets interface pointer to Sound object

 *      idChild identifies the sound in question

 *  are going to be cleaning up the SOUNDSENTRY feature in the control panel

 *  and will use this at that time.  Applications implementing WinEvents

 *  are perfectly welcome to use it.  Clients of IAccessible* will simply

 *  turn around and get back a non-visual object that describes the sound.

 */
# 11628 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_SOUND 0x0001

/*

 * EVENT_SYSTEM_ALERT

 * System Alerts:

 * (Generated by MessageBox() calls for example)

 *      hwnd            is hwndMessageBox

 *      idObject        is OBJID_ALERT

 * App Alerts:

 * (Generated whenever)

 *      hwnd+idObject gets interface pointer to Alert

 */
# 11640 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_ALERT 0x0002

/*

 * EVENT_SYSTEM_FOREGROUND

 * Sent when the foreground (active) window changes, even if it is changing

 * to another window in the same thread as the previous one.

 *      hwnd            is hwndNewForeground

 *      idObject        is OBJID_WINDOW

 *      idChild    is INDEXID_OBJECT

 */
# 11650 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_FOREGROUND 0x0003

/*

 * Menu

 *      hwnd            is window (top level window or popup menu window)

 *      idObject        is ID of control (OBJID_MENU, OBJID_SYSMENU, OBJID_SELF for popup)

 *      idChild         is CHILDID_SELF

 *

 * EVENT_SYSTEM_MENUSTART

 * EVENT_SYSTEM_MENUEND

 * For MENUSTART, hwnd+idObject+idChild refers to the control with the menu bar,

 *  or the control bringing up the context menu.

 *

 * Sent when entering into and leaving from menu mode (system, app bar, and

 * track popups).

 */
# 11666 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_MENUSTART 0x0004
#define EVENT_SYSTEM_MENUEND 0x0005

/*

 * EVENT_SYSTEM_MENUPOPUPSTART

 * EVENT_SYSTEM_MENUPOPUPEND

 * Sent when a menu popup comes up and just before it is taken down.  Note

 * that for a call to TrackPopupMenu(), a client will see EVENT_SYSTEM_MENUSTART

 * followed almost immediately by EVENT_SYSTEM_MENUPOPUPSTART for the popup

 * being shown.

 *

 * For MENUPOPUP, hwnd+idObject+idChild refers to the NEW popup coming up, not the

 * parent item which is hierarchical.  You can get the parent menu/popup by

 * asking for the accParent object.

 */
# 11681 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_MENUPOPUPSTART 0x0006
#define EVENT_SYSTEM_MENUPOPUPEND 0x0007


/*

 * EVENT_SYSTEM_CAPTURESTART

 * EVENT_SYSTEM_CAPTUREEND

 * Sent when a window takes the capture and releases the capture.

 */
# 11690 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_CAPTURESTART 0x0008
#define EVENT_SYSTEM_CAPTUREEND 0x0009

/*

 * Move Size

 * EVENT_SYSTEM_MOVESIZESTART

 * EVENT_SYSTEM_MOVESIZEEND

 * Sent when a window enters and leaves move-size dragging mode.

 */
# 11699 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_MOVESIZESTART 0x000A
#define EVENT_SYSTEM_MOVESIZEEND 0x000B

/*

 * Context Help

 * EVENT_SYSTEM_CONTEXTHELPSTART

 * EVENT_SYSTEM_CONTEXTHELPEND

 * Sent when a window enters and leaves context sensitive help mode.

 */
# 11708 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_CONTEXTHELPSTART 0x000C
#define EVENT_SYSTEM_CONTEXTHELPEND 0x000D

/*

 * Drag & Drop

 * EVENT_SYSTEM_DRAGDROPSTART

 * EVENT_SYSTEM_DRAGDROPEND

 * Send the START notification just before going into drag&drop loop.  Send

 * the END notification just after canceling out.

 * Note that it is up to apps and OLE to generate this, since the system

 * doesn't know.  Like EVENT_SYSTEM_SOUND, it will be a while before this

 * is prevalent.

 */
# 11721 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_DRAGDROPSTART 0x000E
#define EVENT_SYSTEM_DRAGDROPEND 0x000F

/*

 * Dialog

 * Send the START notification right after the dialog is completely

 *  initialized and visible.  Send the END right before the dialog

 *  is hidden and goes away.

 * EVENT_SYSTEM_DIALOGSTART

 * EVENT_SYSTEM_DIALOGEND

 */
# 11732 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_DIALOGSTART 0x0010
#define EVENT_SYSTEM_DIALOGEND 0x0011

/*

 * EVENT_SYSTEM_SCROLLING

 * EVENT_SYSTEM_SCROLLINGSTART

 * EVENT_SYSTEM_SCROLLINGEND

 * Sent when beginning and ending the tracking of a scrollbar in a window,

 * and also for scrollbar controls.

 */
# 11742 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_SCROLLINGSTART 0x0012
#define EVENT_SYSTEM_SCROLLINGEND 0x0013

/*

 * Alt-Tab Window

 * Send the START notification right after the switch window is initialized

 * and visible.  Send the END right before it is hidden and goes away.

 * EVENT_SYSTEM_SWITCHSTART

 * EVENT_SYSTEM_SWITCHEND

 */
# 11752 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_SWITCHSTART 0x0014
#define EVENT_SYSTEM_SWITCHEND 0x0015

/*

 * EVENT_SYSTEM_MINIMIZESTART

 * EVENT_SYSTEM_MINIMIZEEND

 * Sent when a window minimizes and just before it restores.

 */
# 11760 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_SYSTEM_MINIMIZESTART 0x0016
#define EVENT_SYSTEM_MINIMIZEEND 0x0017



#define EVENT_SYSTEM_DESKTOPSWITCH 0x0020




#define EVENT_SYSTEM_END 0x00FF

#define EVENT_OEM_DEFINED_START 0x0101
#define EVENT_OEM_DEFINED_END 0x01FF

#define EVENT_UIA_EVENTID_START 0x4E00
#define EVENT_UIA_EVENTID_END 0x4EFF

#define EVENT_UIA_PROPID_START 0x7500
#define EVENT_UIA_PROPID_END 0x75FF



#define EVENT_CONSOLE_CARET 0x4001
#define EVENT_CONSOLE_UPDATE_REGION 0x4002
#define EVENT_CONSOLE_UPDATE_SIMPLE 0x4003
#define EVENT_CONSOLE_UPDATE_SCROLL 0x4004
#define EVENT_CONSOLE_LAYOUT 0x4005
#define EVENT_CONSOLE_START_APPLICATION 0x4006
#define EVENT_CONSOLE_END_APPLICATION 0x4007

/*

 * Flags for EVENT_CONSOLE_START/END_APPLICATION.

 */
# 11795 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CONSOLE_APPLICATION_16BIT 0x0000




/*

 * Flags for EVENT_CONSOLE_CARET

 */
# 11803 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define CONSOLE_CARET_SELECTION 0x0001
#define CONSOLE_CARET_VISIBLE 0x0002



#define EVENT_CONSOLE_END 0x40FF


/*

 * Object events

 *

 * The system AND apps generate these.  The system generates these for

 * real windows.  Apps generate these for objects within their window which

 * act like a separate control, e.g. an item in a list view.

 *

 * When the system generate them, dwParam2 is always WMOBJID_SELF.  When

 * apps generate them, apps put the has-meaning-to-the-app-only ID value

 * in dwParam2.

 * For all events, if you want detailed accessibility information, callers

 * should

 *      * Call AccessibleObjectFromWindow() with the hwnd, idObject parameters

 *          of the event, and IID_IAccessible as the REFIID, to get back an

 *          IAccessible* to talk to

 *      * Initialize and fill in a VARIANT as VT_I4 with lVal the idChild

 *          parameter of the event.

 *      * If idChild isn't zero, call get_accChild() in the container to see

 *          if the child is an object in its own right.  If so, you will get

 *          back an IDispatch* object for the child.  You should release the

 *          parent, and call QueryInterface() on the child object to get its

 *          IAccessible*.  Then you talk directly to the child.  Otherwise,

 *          if get_accChild() returns you nothing, you should continue to

 *          use the child VARIANT.  You will ask the container for the properties

 *          of the child identified by the VARIANT.  In other words, the

 *          child in this case is accessible but not a full-blown object.

 *          Like a button on a titlebar which is 'small' and has no children.

 */
# 11840 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * For all EVENT_OBJECT events,

 *      hwnd is the dude to Send the WM_GETOBJECT message to (unless NULL,

 *          see above for system things)

 *      idObject is the ID of the object that can resolve any queries a

 *          client might have.  It's a way to deal with windowless controls,

 *          controls that are just drawn on the screen in some larger parent

 *          window (like SDM), or standard frame elements of a window.

 *      idChild is the piece inside of the object that is affected.  This

 *          allows clients to access things that are too small to have full

 *          blown objects in their own right.  Like the thumb of a scrollbar.

 *          The hwnd/idObject pair gets you to the container, the dude you

 *          probably want to talk to most of the time anyway.  The idChild

 *          can then be passed into the acc properties to get the name/value

 *          of it as needed.

 *

 * Example #1:

 *      System propagating a listbox selection change

 *      EVENT_OBJECT_SELECTION

 *          hwnd == listbox hwnd

 *          idObject == OBJID_WINDOW

 *          idChild == new selected item, or CHILDID_SELF if

 *              nothing now selected within container.

 *      Word '97 propagating a listbox selection change

 *          hwnd == SDM window

 *          idObject == SDM ID to get at listbox 'control'

 *          idChild == new selected item, or CHILDID_SELF if

 *              nothing

 *

 * Example #2:

 *      System propagating a menu item selection on the menu bar

 *      EVENT_OBJECT_SELECTION

 *          hwnd == top level window

 *          idObject == OBJID_MENU

 *          idChild == ID of child menu bar item selected

 *

 * Example #3:

 *      System propagating a dropdown coming off of said menu bar item

 *      EVENT_OBJECT_CREATE

 *          hwnd == popup item

 *          idObject == OBJID_WINDOW

 *          idChild == CHILDID_SELF

 *

 * Example #4:

 *

 * For EVENT_OBJECT_REORDER, the object referred to by hwnd/idObject is the

 * PARENT container in which the zorder is occurring.  This is because if

 * one child is zordering, all of them are changing their relative zorder.

 */
# 11889 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_OBJECT_CREATE 0x8000
#define EVENT_OBJECT_DESTROY 0x8001
#define EVENT_OBJECT_SHOW 0x8002
#define EVENT_OBJECT_HIDE 0x8003
#define EVENT_OBJECT_REORDER 0x8004
/*

 * NOTE:

 * Minimize the number of notifications!

 *

 * When you are hiding a parent object, obviously all child objects are no

 * longer visible on screen.  They still have the same "visible" status,

 * but are not truly visible.  Hence do not send HIDE notifications for the

 * children also.  One implies all.  The same goes for SHOW.

 */
# 11905 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_OBJECT_FOCUS 0x8005
#define EVENT_OBJECT_SELECTION 0x8006
#define EVENT_OBJECT_SELECTIONADD 0x8007
#define EVENT_OBJECT_SELECTIONREMOVE 0x8008
#define EVENT_OBJECT_SELECTIONWITHIN 0x8009

/*

 * NOTES:

 * There is only one "focused" child item in a parent.  This is the place

 * keystrokes are going at a given moment.  Hence only send a notification

 * about where the NEW focus is going.  A NEW item getting the focus already

 * implies that the OLD item is losing it.

 *

 * SELECTION however can be multiple.  Hence the different SELECTION

 * notifications.  Here's when to use each:

 *

 * (1) Send a SELECTION notification in the simple single selection

 *     case (like the focus) when the item with the selection is

 *     merely moving to a different item within a container.  hwnd + ID

 *     is the container control, idChildItem is the new child with the

 *     selection.

 *

 * (2) Send a SELECTIONADD notification when a new item has simply been added

 *     to the selection within a container.  This is appropriate when the

 *     number of newly selected items is very small.  hwnd + ID is the

 *     container control, idChildItem is the new child added to the selection.

 *

 * (3) Send a SELECTIONREMOVE notification when a new item has simply been

 *     removed from the selection within a container.  This is appropriate

 *     when the number of newly selected items is very small, just like

 *     SELECTIONADD.  hwnd + ID is the container control, idChildItem is the

 *     new child removed from the selection.

 *

 * (4) Send a SELECTIONWITHIN notification when the selected items within a

 *     control have changed substantially.  Rather than propagate a large

 *     number of changes to reflect removal for some items, addition of

 *     others, just tell somebody who cares that a lot happened.  It will

 *     be faster an easier for somebody watching to just turn around and

 *     query the container control what the new bunch of selected items

 *     are.

 */
# 11947 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_OBJECT_STATECHANGE 0x800A
/*

 * Examples of when to send an EVENT_OBJECT_STATECHANGE include

 *      * It is being enabled/disabled (USER does for windows)

 *      * It is being pressed/released (USER does for buttons)

 *      * It is being checked/unchecked (USER does for radio/check buttons)

 */
# 11954 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_OBJECT_LOCATIONCHANGE 0x800B

/*

 * Note:

 * A LOCATIONCHANGE is not sent for every child object when the parent

 * changes shape/moves.  Send one notification for the topmost object

 * that is changing.  For example, if the user resizes a top level window,

 * USER will generate a LOCATIONCHANGE for it, but not for the menu bar,

 * title bar, scrollbars, etc.  that are also changing shape/moving.

 *

 * In other words, it only generates LOCATIONCHANGE notifications for

 * real windows that are moving/sizing.  It will not generate a LOCATIONCHANGE

 * for every non-floating child window when the parent moves (the children are

 * logically moving also on screen, but not relative to the parent).

 *

 * Now, if the app itself resizes child windows as a result of being

 * sized, USER will generate LOCATIONCHANGEs for those dudes also because

 * it doesn't know better.

 *

 * Note also that USER will generate LOCATIONCHANGE notifications for two

 * non-window sys objects:

 *      (1) System caret

 *      (2) Cursor

 */
# 11979 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_OBJECT_NAMECHANGE 0x800C
#define EVENT_OBJECT_DESCRIPTIONCHANGE 0x800D
#define EVENT_OBJECT_VALUECHANGE 0x800E
#define EVENT_OBJECT_PARENTCHANGE 0x800F
#define EVENT_OBJECT_HELPCHANGE 0x8010
#define EVENT_OBJECT_DEFACTIONCHANGE 0x8011
#define EVENT_OBJECT_ACCELERATORCHANGE 0x8012


#define EVENT_OBJECT_INVOKED 0x8013
#define EVENT_OBJECT_TEXTSELECTIONCHANGED 0x8014

/*

 * EVENT_OBJECT_CONTENTSCROLLED

 * Sent when ending the scrolling of a window object.

 *

 * Unlike the similar event (EVENT_SYSTEM_SCROLLEND), this event will be

 * associated with the scrolling window itself. There is no difference

 * between horizontal or vertical scrolling.

 *

 * This event should be posted whenever scroll action is completed, including

 * when it is scrolled by scroll bars, mouse wheel, or keyboard navigations.

 *

 *   example:

 *          hwnd == window that is scrolling

 *          idObject == OBJID_CLIENT

 *          idChild == CHILDID_SELF

 */
# 12007 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define EVENT_OBJECT_CONTENTSCROLLED 0x8015



#define EVENT_SYSTEM_ARRANGMENTPREVIEW 0x8016



#define EVENT_OBJECT_END 0x80FF

#define EVENT_AIA_START 0xA000
#define EVENT_AIA_END 0xAFFF



/*

 * Child IDs

 */
/*

 * System Sounds (idChild of system SOUND notification)

 */
# 12030 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define SOUND_SYSTEM_STARTUP 1
#define SOUND_SYSTEM_SHUTDOWN 2
#define SOUND_SYSTEM_BEEP 3
#define SOUND_SYSTEM_ERROR 4
#define SOUND_SYSTEM_QUESTION 5
#define SOUND_SYSTEM_WARNING 6
#define SOUND_SYSTEM_INFORMATION 7
#define SOUND_SYSTEM_MAXIMIZE 8
#define SOUND_SYSTEM_MINIMIZE 9
#define SOUND_SYSTEM_RESTOREUP 10
#define SOUND_SYSTEM_RESTOREDOWN 11
#define SOUND_SYSTEM_APPSTART 12
#define SOUND_SYSTEM_FAULT 13
#define SOUND_SYSTEM_APPEND 14
#define SOUND_SYSTEM_MENUCOMMAND 15
#define SOUND_SYSTEM_MENUPOPUP 16
#define CSOUND_SYSTEM 16

/*

 * System Alerts (indexChild of system ALERT notification)

 */
# 12051 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define ALERT_SYSTEM_INFORMATIONAL 1
#define ALERT_SYSTEM_WARNING 2
#define ALERT_SYSTEM_ERROR 3
#define ALERT_SYSTEM_QUERY 4
#define ALERT_SYSTEM_CRITICAL 5
#define CALERT_SYSTEM 6

typedef struct tagGUITHREADINFO
{
    DWORD cbSize;
    DWORD flags;
    HWND hwndActive;
    HWND hwndFocus;
    HWND hwndCapture;
    HWND hwndMenuOwner;
    HWND hwndMoveSize;
    HWND hwndCaret;
    RECT rcCaret;
} GUITHREADINFO, *PGUITHREADINFO, * LPGUITHREADINFO;

#define GUI_CARETBLINKING 0x00000001
#define GUI_INMOVESIZE 0x00000002
#define GUI_INMENUMODE 0x00000004
#define GUI_SYSTEMMENUMODE 0x00000008
#define GUI_POPUPMENUMODE 0x00000010


#define GUI_16BITTASK 0x00000000






BOOL

GetGUIThreadInfo(
    DWORD idThread,
    PGUITHREADINFO pgui);


BOOL

BlockInput(
    BOOL fBlockIt);



#define USER_DEFAULT_SCREEN_DPI 96


BOOL

SetProcessDPIAware(
    void);


BOOL

IsProcessDPIAware(
    void);



UINT

GetWindowModuleFileNameA(
    HWND hwnd,
    LPSTR pszFileName,
    UINT cchFileNameMax);

UINT

GetWindowModuleFileNameW(
    HWND hwnd,
    LPWSTR pszFileName,
    UINT cchFileNameMax);



#define GetWindowModuleFileName GetWindowModuleFileNameA



#define STATE_SYSTEM_UNAVAILABLE 0x00000001
#define STATE_SYSTEM_SELECTED 0x00000002
#define STATE_SYSTEM_FOCUSED 0x00000004
#define STATE_SYSTEM_PRESSED 0x00000008
#define STATE_SYSTEM_CHECKED 0x00000010
#define STATE_SYSTEM_MIXED 0x00000020
#define STATE_SYSTEM_INDETERMINATE STATE_SYSTEM_MIXED
#define STATE_SYSTEM_READONLY 0x00000040
#define STATE_SYSTEM_HOTTRACKED 0x00000080
#define STATE_SYSTEM_DEFAULT 0x00000100
#define STATE_SYSTEM_EXPANDED 0x00000200
#define STATE_SYSTEM_COLLAPSED 0x00000400
#define STATE_SYSTEM_BUSY 0x00000800
#define STATE_SYSTEM_FLOATING 0x00001000
#define STATE_SYSTEM_MARQUEED 0x00002000
#define STATE_SYSTEM_ANIMATED 0x00004000
#define STATE_SYSTEM_INVISIBLE 0x00008000
#define STATE_SYSTEM_OFFSCREEN 0x00010000
#define STATE_SYSTEM_SIZEABLE 0x00020000
#define STATE_SYSTEM_MOVEABLE 0x00040000
#define STATE_SYSTEM_SELFVOICING 0x00080000
#define STATE_SYSTEM_FOCUSABLE 0x00100000
#define STATE_SYSTEM_SELECTABLE 0x00200000
#define STATE_SYSTEM_LINKED 0x00400000
#define STATE_SYSTEM_TRAVERSED 0x00800000
#define STATE_SYSTEM_MULTISELECTABLE 0x01000000
#define STATE_SYSTEM_EXTSELECTABLE 0x02000000
#define STATE_SYSTEM_ALERT_LOW 0x04000000
#define STATE_SYSTEM_ALERT_MEDIUM 0x08000000
#define STATE_SYSTEM_ALERT_HIGH 0x10000000
#define STATE_SYSTEM_PROTECTED 0x20000000
#define STATE_SYSTEM_VALID 0x3FFFFFFF


#define CCHILDREN_TITLEBAR 5
#define CCHILDREN_SCROLLBAR 5

/*

 * Information about the global cursor.

 */
# 12175 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCURSORINFO
{
    DWORD cbSize;
    DWORD flags;
    HCURSOR hCursor;
    POINT ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

#define CURSOR_SHOWING 0x00000001


BOOL

GetCursorInfo(
    PCURSORINFO pci);

/*

 * Window information snapshot

 */
# 12194 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;

#define WS_ACTIVECAPTION 0x0001


BOOL

GetWindowInfo(
    HWND hwnd,
    PWINDOWINFO pwi);

/*

 * Titlebar information.

 */
# 12220 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;


BOOL

GetTitleBarInfo(
    HWND hwnd,
    PTITLEBARINFO pti);


typedef struct tagTITLEBARINFOEX
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
    RECT rgrect[5 + 1];
} TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;


/*

 * Menubar information

 */
# 12247 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar; // rect of bar, popup, item
    HMENU hMenu; // real menu handle of bar, popup
    HWND hwndMenu; // hwnd of item submenu if one
    BOOL fBarFocused:1; // bar, popup has the focus
    BOOL fFocused:1; // item has the focus
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;


BOOL

GetMenuBarInfo(
    HWND hwnd,
    LONG idObject,
    LONG idItem,
    PMENUBARINFO pmbi);

/*

 * Scrollbar information

 */
# 12269 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[5 + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;


BOOL

GetScrollBarInfo(
    HWND hwnd,
    LONG idObject,
    PSCROLLBARINFO psbi);

/*

 * Combobox information

 */
# 12291 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;


BOOL

GetComboBoxInfo(
    HWND hwndCombo,
    PCOMBOBOXINFO pcbi);

/*

 * The "real" ancestor window

 */
# 12312 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GA_PARENT 1
#define GA_ROOT 2
#define GA_ROOTOWNER 3


HWND

GetAncestor(
    HWND hwnd,
    UINT gaFlags);


/*

 * This gets the REAL child window at the point.  If it is in the dead

 * space of a group box, it will try a sibling behind it.  But static

 * fields will get returned.  In other words, it is kind of a cross between

 * ChildWindowFromPointEx and WindowFromPoint.

 */
# 12330 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

HWND

RealChildWindowFromPoint(
    HWND hwndParent,
    POINT ptParentClientCoords);


/*

 * This gets the name of the window TYPE, not class.  This allows us to

 * recognize ThunderButton32 et al.

 */
# 12342 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

UINT

RealGetWindowClassA(
    HWND hwnd,
    LPSTR ptszClassName,
    UINT cchClassNameMax);
/*

 * This gets the name of the window TYPE, not class.  This allows us to

 * recognize ThunderButton32 et al.

 */
# 12353 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

UINT

RealGetWindowClassW(
    HWND hwnd,
    LPWSTR ptszClassName,
    UINT cchClassNameMax);



#define RealGetWindowClass RealGetWindowClassA


/*

 * Alt-Tab Switch window information.

 */
# 12369 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;


BOOL

GetAltTabInfoA(
    HWND hwnd,
    int iItem,
    PALTTABINFO pati,
    LPSTR pszItemText,
    UINT cchItemText);

BOOL

GetAltTabInfoW(
    HWND hwnd,
    int iItem,
    PALTTABINFO pati,
    LPWSTR pszItemText,
    UINT cchItemText);



#define GetAltTabInfo GetAltTabInfoA


/*

 * Listbox information.

 * Returns the number of items per row.

 */
# 12410 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

DWORD

GetListBoxInfo(
    HWND hwnd);







BOOL

LockWorkStation(
    void);





BOOL

UserHandleGrantAccess(
    HANDLE hUserHandle,
    HANDLE hJob,
    BOOL bGrant);





/*

 * Raw Input Messages.

 */
# 12446 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
struct HRAWINPUT__{int unused;}; typedef struct HRAWINPUT__ *HRAWINPUT;

/*

 * WM_INPUT wParam

 */
# 12452 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Use this macro to get the input code from wParam.

 */
# 12455 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GET_RAWINPUT_CODE_WPARAM(wParam) ((wParam) & 0xff)

/*

 * The input is in the regular message flow,

 * the app is required to call DefWindowProc

 * so that the system can perform clean ups.

 */
# 12462 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RIM_INPUT 0

/*

 * The input is sink only. The app is expected

 * to behave nicely.

 */
# 12468 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RIM_INPUTSINK 1


/*

 * Raw Input data header

 */
# 12474 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWINPUTHEADER {
    DWORD dwType;
    DWORD dwSize;
    HANDLE hDevice;
    WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;

/*

 * Type of the raw input

 */
# 12484 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RIM_TYPEMOUSE 0
#define RIM_TYPEKEYBOARD 1
#define RIM_TYPEHID 2

/*

 * Raw format of the mouse input

 */
# 12491 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWMOUSE {
    /*

     * Indicator flags.

     */
# 12495 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT usFlags;

    /*

     * The transition state of the mouse buttons.

     */
# 12500 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    union {
        ULONG ulButtons;
        struct {
            USHORT usButtonFlags;
            USHORT usButtonData;
        };
    };


    /*

     * The raw state of the mouse buttons.

     */
# 12512 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    ULONG ulRawButtons;

    /*

     * The signed relative or absolute motion in the X direction.

     */
# 12517 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    LONG lLastX;

    /*

     * The signed relative or absolute motion in the Y direction.

     */
# 12522 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    LONG lLastY;

    /*

     * Device-specific additional information for the event.

     */
# 12527 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    ULONG ulExtraInformation;

} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;

/*

 * Define the mouse button state indicators.

 */
# 12535 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RI_MOUSE_LEFT_BUTTON_DOWN 0x0001
#define RI_MOUSE_LEFT_BUTTON_UP 0x0002
#define RI_MOUSE_RIGHT_BUTTON_DOWN 0x0004
#define RI_MOUSE_RIGHT_BUTTON_UP 0x0008
#define RI_MOUSE_MIDDLE_BUTTON_DOWN 0x0010
#define RI_MOUSE_MIDDLE_BUTTON_UP 0x0020

#define RI_MOUSE_BUTTON_1_DOWN RI_MOUSE_LEFT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_1_UP RI_MOUSE_LEFT_BUTTON_UP
#define RI_MOUSE_BUTTON_2_DOWN RI_MOUSE_RIGHT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_2_UP RI_MOUSE_RIGHT_BUTTON_UP
#define RI_MOUSE_BUTTON_3_DOWN RI_MOUSE_MIDDLE_BUTTON_DOWN
#define RI_MOUSE_BUTTON_3_UP RI_MOUSE_MIDDLE_BUTTON_UP

#define RI_MOUSE_BUTTON_4_DOWN 0x0040
#define RI_MOUSE_BUTTON_4_UP 0x0080
#define RI_MOUSE_BUTTON_5_DOWN 0x0100
#define RI_MOUSE_BUTTON_5_UP 0x0200

/*

 * If usButtonFlags has RI_MOUSE_WHEEL, the wheel delta is stored in usButtonData.

 * Take it as a signed value.

 */
# 12558 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RI_MOUSE_WHEEL 0x0400

/*

 * Define the mouse indicator flags.

 */
# 12563 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MOUSE_MOVE_RELATIVE 0
#define MOUSE_MOVE_ABSOLUTE 1
#define MOUSE_VIRTUAL_DESKTOP 0x02
#define MOUSE_ATTRIBUTES_CHANGED 0x04

#define MOUSE_MOVE_NOCOALESCE 0x08


/*

 * Raw format of the keyboard input

 */
# 12574 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWKEYBOARD {
    /*

     * The "make" scan code (key depression).

     */
# 12578 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT MakeCode;

    /*

     * The flags field indicates a "break" (key release) and other

     * miscellaneous scan code information defined in ntddkbd.h.

     */
# 12584 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT Flags;

    USHORT Reserved;

    /*

     * Windows message compatible information

     */
# 12591 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT VKey;
    UINT Message;

    /*

     * Device-specific additional information for the event.

     */
# 12597 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    ULONG ExtraInformation;


} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;


/*

 * Define the keyboard overrun MakeCode.

 */
# 12607 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define KEYBOARD_OVERRUN_MAKE_CODE 0xFF

/*

 * Define the keyboard input data Flags.

 */
# 12612 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RI_KEY_MAKE 0
#define RI_KEY_BREAK 1
#define RI_KEY_E0 2
#define RI_KEY_E1 4
#define RI_KEY_TERMSRV_SET_LED 8
#define RI_KEY_TERMSRV_SHADOW 0x10


/*

 * Raw format of the input from Human Input Devices

 */
# 12623 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWHID {
    DWORD dwSizeHid; // byte size of each report
    DWORD dwCount; // number of input packed
    BYTE bRawData[1];
} RAWHID, *PRAWHID, *LPRAWHID;

/*

 * RAWINPUT data structure.

 */
# 12632 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWINPUT {
    RAWINPUTHEADER header;
    union {
        RAWMOUSE mouse;
        RAWKEYBOARD keyboard;
        RAWHID hid;
    } data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;


#define RAWINPUT_ALIGN(x) (((x) + sizeof(QWORD) - 1) & ~(sizeof(QWORD) - 1))




#define NEXTRAWINPUTBLOCK(ptr) ((PRAWINPUT)RAWINPUT_ALIGN((ULONG_PTR)((PBYTE)(ptr) + (ptr)->header.dwSize)))

/*

 * Flags for GetRawInputData

 */
# 12653 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RID_INPUT 0x10000003
#define RID_HEADER 0x10000005


UINT

GetRawInputData(
    HRAWINPUT hRawInput,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize,
    UINT cbSizeHeader);

/*

 * Raw Input Device Information

 */
# 12669 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define RIDI_PREPARSEDDATA 0x20000005
#define RIDI_DEVICENAME 0x20000007
#define RIDI_DEVICEINFO 0x2000000b

typedef struct tagRID_DEVICE_INFO_MOUSE {
    DWORD dwId;
    DWORD dwNumberOfButtons;
    DWORD dwSampleRate;
    BOOL fHasHorizontalWheel;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;

typedef struct tagRID_DEVICE_INFO_KEYBOARD {
    DWORD dwType;
    DWORD dwSubType;
    DWORD dwKeyboardMode;
    DWORD dwNumberOfFunctionKeys;
    DWORD dwNumberOfIndicators;
    DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;

typedef struct tagRID_DEVICE_INFO_HID {
    DWORD dwVendorId;
    DWORD dwProductId;
    DWORD dwVersionNumber;

    /*

     * Top level collection UsagePage and Usage

     */
# 12697 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
    USHORT usUsagePage;
    USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;

typedef struct tagRID_DEVICE_INFO {
    DWORD cbSize;
    DWORD dwType;
    union {
        RID_DEVICE_INFO_MOUSE mouse;
        RID_DEVICE_INFO_KEYBOARD keyboard;
        RID_DEVICE_INFO_HID hid;
    };
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;


UINT

GetRawInputDeviceInfoA(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize);

UINT

GetRawInputDeviceInfoW(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize);



#define GetRawInputDeviceInfo GetRawInputDeviceInfoA



/*

 * Raw Input Bulk Read: GetRawInputBuffer

 */
# 12737 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

UINT

GetRawInputBuffer(
    PRAWINPUT pData,
    PUINT pcbSize,
    UINT cbSizeHeader);

/*

 * Raw Input request APIs

 */
# 12748 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagRAWINPUTDEVICE {
    USHORT usUsagePage; // Toplevel collection UsagePage
    USHORT usUsage; // Toplevel collection Usage
    DWORD dwFlags;
    HWND hwndTarget; // Target hwnd. NULL = follows keyboard focus
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;

typedef const RAWINPUTDEVICE* PCRAWINPUTDEVICE;

#define RIDEV_REMOVE 0x00000001
#define RIDEV_EXCLUDE 0x00000010
#define RIDEV_PAGEONLY 0x00000020
#define RIDEV_NOLEGACY 0x00000030
#define RIDEV_INPUTSINK 0x00000100
#define RIDEV_CAPTUREMOUSE 0x00000200
#define RIDEV_NOHOTKEYS 0x00000200
#define RIDEV_APPKEYS 0x00000400

#define RIDEV_EXINPUTSINK 0x00001000
#define RIDEV_DEVNOTIFY 0x00002000

#define RIDEV_EXMODEMASK 0x000000F0

#define RIDEV_EXMODE(mode) ((mode) & RIDEV_EXMODEMASK)


/*

 * Flags for the WM_INPUT_DEVICE_CHANGE message.

 */
# 12777 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GIDC_ARRIVAL 1
#define GIDC_REMOVAL 2



#define GET_DEVICE_CHANGE_WPARAM(wParam) (LOWORD(wParam))





BOOL

RegisterRawInputDevices(
    PCRAWINPUTDEVICE pRawInputDevices,
    UINT uiNumDevices,
    UINT cbSize);


UINT

GetRegisteredRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    PUINT puiNumDevices,
    UINT cbSize);


typedef struct tagRAWINPUTDEVICELIST {
    HANDLE hDevice;
    DWORD dwType;
} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;


UINT

GetRawInputDeviceList(
    PRAWINPUTDEVICELIST pRawInputDeviceList,
    PUINT puiNumDevices,
    UINT cbSize);


LRESULT

DefRawInputProc(
    PRAWINPUT* paRawInput,
    INT nInput,
    UINT cbSizeHeader);






/*

 * Message Filter

 */
# 12834 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MSGFLT_ADD 1
#define MSGFLT_REMOVE 2


BOOL

ChangeWindowMessageFilter(
    UINT message,
    DWORD dwFlag);





/*

 * Message filter info values (CHANGEFILTERSTRUCT.ExtStatus)

 */
# 12851 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MSGFLTINFO_NONE (0)
#define MSGFLTINFO_ALREADYALLOWED_FORWND (1)
#define MSGFLTINFO_ALREADYDISALLOWED_FORWND (2)
#define MSGFLTINFO_ALLOWED_HIGHER (3)

typedef struct tagCHANGEFILTERSTRUCT {
    DWORD cbSize;
    DWORD ExtStatus;
} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;

/*

 * Message filter action values (action parameter to ChangeWindowMessageFilterEx)

 */
# 12864 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define MSGFLT_RESET (0)
#define MSGFLT_ALLOW (1)
#define MSGFLT_DISALLOW (2)


BOOL

ChangeWindowMessageFilterEx(
    HWND hwnd, // Window
    UINT message, // WM_ message
    DWORD action, // Message filter action value
    PCHANGEFILTERSTRUCT pChangeFilterStruct); // Optional






/*

 * Gesture defines and functions

 */
# 12886 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Gesture information handle

 */
# 12889 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
struct HGESTUREINFO__{int unused;}; typedef struct HGESTUREINFO__ *HGESTUREINFO;


/*

 * Gesture flags - GESTUREINFO.dwFlags

 */
# 12895 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GF_BEGIN 0x00000001
#define GF_INERTIA 0x00000002
#define GF_END 0x00000004

/*

 * Gesture IDs

 */
# 12902 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GID_BEGIN 1
#define GID_END 2
#define GID_ZOOM 3
#define GID_PAN 4
#define GID_ROTATE 5
#define GID_TWOFINGERTAP 6
#define GID_PRESSANDTAP 7
#define GID_ROLLOVER GID_PRESSANDTAP

/*

 * Gesture information structure

 *   - Pass the HGESTUREINFO received in the WM_GESTURE message lParam into the

 *     GetGestureInfo function to retrieve this information.

 *   - If cbExtraArgs is non-zero, pass the HGESTUREINFO received in the WM_GESTURE

 *     message lParam into the GetGestureExtraArgs function to retrieve extended

 *     argument information.

 */
# 12919 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagGESTUREINFO {
    UINT cbSize; // size, in bytes, of this structure (including variable length Args field)
    DWORD dwFlags; // see GF_* flags
    DWORD dwID; // gesture ID, see GID_* defines
    HWND hwndTarget; // handle to window targeted by this gesture
    POINTS ptsLocation; // current location of this gesture
    DWORD dwInstanceID; // internally used
    DWORD dwSequenceID; // internally used
    ULONGLONG ullArguments; // arguments for gestures whose arguments fit in 8 BYTES
    UINT cbExtraArgs; // size, in bytes, of extra arguments, if any, that accompany this gesture
} GESTUREINFO, *PGESTUREINFO;
typedef GESTUREINFO const * PCGESTUREINFO;


/*

 * Gesture notification structure

 *   - The WM_GESTURENOTIFY message lParam contains a pointer to this structure.

 *   - The WM_GESTURENOTIFY message notifies a window that gesture recognition is

 *     in progress and a gesture will be generated if one is recognized under the

 *     current gesture settings.

 */
# 12940 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagGESTURENOTIFYSTRUCT {
    UINT cbSize; // size, in bytes, of this structure
    DWORD dwFlags; // unused
    HWND hwndTarget; // handle to window targeted by the gesture
    POINTS ptsLocation; // starting location
    DWORD dwInstanceID; // internally used
} GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;

/*

 * Gesture argument helpers

 *   - Angle should be a double in the range of -2pi to +2pi

 *   - Argument should be an unsigned 16-bit value

 */
# 12953 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GID_ROTATE_ANGLE_TO_ARGUMENT(_arg_) ((USHORT)((((_arg_) + 2.0 * 3.14159265) / (4.0 * 3.14159265)) * 65535.0))
#define GID_ROTATE_ANGLE_FROM_ARGUMENT(_arg_) ((((double)(_arg_) / 65535.0) * 4.0 * 3.14159265) - 2.0 * 3.14159265)

/*

 * Gesture information retrieval

 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.

 */
# 12960 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

GetGestureInfo(
    HGESTUREINFO hGestureInfo,
    PGESTUREINFO pGestureInfo);

/*

 * Gesture extra arguments retrieval

 *   - HGESTUREINFO is received by a window in the lParam of a WM_GESTURE message.

 *   - Size, in bytes, of the extra argument data is available in the cbExtraArgs

 *     field of the GESTUREINFO structure retrieved using the GetGestureInfo function.

 */
# 12973 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

GetGestureExtraArgs(
    HGESTUREINFO hGestureInfo,
    UINT cbExtraArgs,
    PBYTE pExtraArgs);

/*

 * Gesture information handle management

 *   - If an application processes the WM_GESTURE message, then once it is done

 *     with the associated HGESTUREINFO, the application is responsible for

 *     closing the handle using this function. Failure to do so may result in

 *     process memory leaks.

 *   - If the message is instead passed to DefWindowProc, or is forwarded using

 *     one of the PostMessage or SendMessage class of API functions, the handle

 *     is transfered with the message and need not be closed by the application.

 */
# 12991 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"

BOOL

CloseGestureInfoHandle(
    HGESTUREINFO hGestureInfo);


/*

 * Gesture configuration structure

 *   - Used in SetGestureConfig and GetGestureConfig

 *   - Note that any setting not included in either GESTURECONFIG.dwWant or

 *     GESTURECONFIG.dwBlock will use the parent window's preferences or

 *     system defaults.

 */
# 13005 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
typedef struct tagGESTURECONFIG {
    DWORD dwID; // gesture ID
    DWORD dwWant; // settings related to gesture ID that are to be turned on
    DWORD dwBlock; // settings related to gesture ID that are to be turned off
} GESTURECONFIG, *PGESTURECONFIG;

/*

 * Gesture configuration flags - GESTURECONFIG.dwWant or GESTURECONFIG.dwBlock

 */
# 13015 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
/*

 * Common gesture configuration flags - set GESTURECONFIG.dwID to zero

 */
# 13018 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GC_ALLGESTURES 0x00000001

/*

 * Zoom gesture configuration flags - set GESTURECONFIG.dwID to GID_ZOOM

 */
# 13023 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GC_ZOOM 0x00000001

/*

 * Pan gesture configuration flags - set GESTURECONFIG.dwID to GID_PAN

 */
# 13028 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GC_PAN 0x00000001
#define GC_PAN_WITH_SINGLE_FINGER_VERTICALLY 0x00000002
#define GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY 0x00000004
#define GC_PAN_WITH_GUTTER 0x00000008
#define GC_PAN_WITH_INERTIA 0x00000010

/*

 * Rotate gesture configuration flags - set GESTURECONFIG.dwID to GID_ROTATE

 */
# 13037 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GC_ROTATE 0x00000001

/*

 * Two finger tap gesture configuration flags - set GESTURECONFIG.dwID to GID_TWOFINGERTAP

 */
# 13042 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GC_TWOFINGERTAP 0x00000001

/*

 * PressAndTap gesture configuration flags - set GESTURECONFIG.dwID to GID_PRESSANDTAP

 */
# 13047 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define GC_PRESSANDTAP 0x00000001
#define GC_ROLLOVER GC_PRESSANDTAP

#define GESTURECONFIGMAXCOUNT 256
                                                        // in a single call to SetGestureConfig / GetGestureConfig


BOOL

SetGestureConfig(
    HWND hwnd, // window for which configuration is specified
    DWORD dwReserved, // reserved, must be 0
    UINT cIDs, // count of GESTURECONFIG structures
    PGESTURECONFIG pGestureConfig, // array of GESTURECONFIG structures, dwIDs will be processed in the
                                                        // order specified and repeated occurances will overwrite previous ones
    UINT cbSize); // sizeof(GESTURECONFIG)


#define GCF_INCLUDE_ANCESTORS 0x00000001
                                                        // for the specified window and it's parent window chain


BOOL

GetGestureConfig(
    HWND hwnd, // window for which configuration is required
    DWORD dwReserved, // reserved, must be 0
    DWORD dwFlags, // see GCF_* flags
    PUINT pcIDs, // *pcIDs contains the size, in number of GESTURECONFIG structures,
                                                        // of the buffer pointed to by pGestureConfig
    PGESTURECONFIG pGestureConfig,
                                                        // pointer to buffer to receive the returned array of GESTURECONFIG structures
    UINT cbSize); // sizeof(GESTURECONFIG)







/*

 * GetSystemMetrics(SM_DIGITIZER) flag values

 */
# 13090 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winuser.h"
#define NID_INTEGRATED_TOUCH 0x00000001
#define NID_EXTERNAL_TOUCH 0x00000002
#define NID_INTEGRATED_PEN 0x00000004
#define NID_EXTERNAL_PEN 0x00000008
#define NID_MULTI_INPUT 0x00000040
#define NID_READY 0x00000080




#define MAX_STR_BLOCKREASON 256


BOOL

ShutdownBlockReasonCreate(
    HWND hWnd,
    LPCWSTR pwszReason);


BOOL

ShutdownBlockReasonQuery(
    HWND hWnd,
    LPWSTR pwszBuff,
    DWORD *pcchBuff);


BOOL

ShutdownBlockReasonDestroy(
    HWND hWnd);
# 159 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h" 1
/*++



Copyright (c) Microsoft Corporation  All rights reserved.



Module Name:



    winnls.h



Abstract:



    Procedure declarations, constant definitions, and macros for the

    NLS component.



--*/
# 18 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
#define _WINNLS_ 
# 34 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
#define WINNORMALIZEAPI DECLSPEC_IMPORT






////////////////////////////////////////////////////////////////////////////
//
//  Constants
//
//  Define all constants for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////

//
//  String Length Maximums.
//
#define MAX_LEADBYTES 12
#define MAX_DEFAULTCHAR 2

//
//  Surrogate pairs
//
//  Conversion examples:
//
//  A) The first character in the Surrogate range (D800, DC00) as UTF-32:
//
//  1.  D800: binary 1101100000000000  (lower ten bits: 0000000000)
//  2.  DC00: binary 1101110000000000  (lower ten bits: 0000000000)
//  3.  Concatenate 0000000000+0000000000 = 0x0000
//  4.  Add 0x10000
//
//  Result: U+10000. This is correct, since the first character in the Supplementary character
//  range immediately follows the last code point in the 16-bit UTF-16 range (U+FFFF)
//
//  B) A UTF-32 code point such as U+2040A (this a CJK character in CJK Extension B), and wish
//  to convert it in UTF-16:
//
//  1.  Subtract 0x10000 - Result: 0x1040A
//  2.  Split into two ten-bit pieces: 0001000001 0000001010
//  3.  Add 1101100000000000 (0xD800) to the high 10 bits piece (0001000001) - Result: 1101100001000001 (0xD841)
//  4.  Add 1101110000000000 (0xDC00) to the low 10 bits piece (0000001010) - Result: 1101110000001010 (0xDC0A)
//
//  RESULT: The surrogate pair: U+D841, U+DC0A
//
//  Special Unicode code point values, for use with UTF-16 surrogate pairs.
//
#define HIGH_SURROGATE_START 0xd800
#define HIGH_SURROGATE_END 0xdbff
#define LOW_SURROGATE_START 0xdc00
#define LOW_SURROGATE_END 0xdfff


//
//  MBCS and Unicode Translation Flags.
//
#define MB_PRECOMPOSED 0x00000001
#define MB_COMPOSITE 0x00000002
#define MB_USEGLYPHCHARS 0x00000004
#define MB_ERR_INVALID_CHARS 0x00000008

#define WC_COMPOSITECHECK 0x00000200
#define WC_DISCARDNS 0x00000010
#define WC_SEPCHARS 0x00000020
#define WC_DEFAULTCHAR 0x00000040

#define WC_ERR_INVALID_CHARS 0x00000080



#define WC_NO_BEST_FIT_CHARS 0x00000400



//
//  Character Type Flags.
//
#define CT_CTYPE1 0x00000001
#define CT_CTYPE2 0x00000002
#define CT_CTYPE3 0x00000004

//
//  CType 1 Flag Bits.
//
#define C1_UPPER 0x0001
#define C1_LOWER 0x0002
#define C1_DIGIT 0x0004
#define C1_SPACE 0x0008
#define C1_PUNCT 0x0010
#define C1_CNTRL 0x0020
#define C1_BLANK 0x0040
#define C1_XDIGIT 0x0080
#define C1_ALPHA 0x0100
#define C1_DEFINED 0x0200

//
//  CType 2 Flag Bits.
//
#define C2_LEFTTORIGHT 0x0001
#define C2_RIGHTTOLEFT 0x0002

#define C2_EUROPENUMBER 0x0003
#define C2_EUROPESEPARATOR 0x0004
#define C2_EUROPETERMINATOR 0x0005
#define C2_ARABICNUMBER 0x0006
#define C2_COMMONSEPARATOR 0x0007

#define C2_BLOCKSEPARATOR 0x0008
#define C2_SEGMENTSEPARATOR 0x0009
#define C2_WHITESPACE 0x000A
#define C2_OTHERNEUTRAL 0x000B

#define C2_NOTAPPLICABLE 0x0000

//
//  CType 3 Flag Bits.
//
#define C3_NONSPACING 0x0001
#define C3_DIACRITIC 0x0002
#define C3_VOWELMARK 0x0004
#define C3_SYMBOL 0x0008

#define C3_KATAKANA 0x0010
#define C3_HIRAGANA 0x0020
#define C3_HALFWIDTH 0x0040
#define C3_FULLWIDTH 0x0080
#define C3_IDEOGRAPH 0x0100
#define C3_KASHIDA 0x0200
#define C3_LEXICAL 0x0400
#define C3_HIGHSURROGATE 0x0800
#define C3_LOWSURROGATE 0x1000

#define C3_ALPHA 0x8000

#define C3_NOTAPPLICABLE 0x0000


//
//  String Flags.
//
#define NORM_IGNORECASE 0x00000001
#define NORM_IGNORENONSPACE 0x00000002
#define NORM_IGNORESYMBOLS 0x00000004

#define LINGUISTIC_IGNORECASE 0x00000010
#define LINGUISTIC_IGNOREDIACRITIC 0x00000020

#define NORM_IGNOREKANATYPE 0x00010000
#define NORM_IGNOREWIDTH 0x00020000
#define NORM_LINGUISTIC_CASING 0x08000000


//
//  Locale Independent Mapping Flags.
//
#define MAP_FOLDCZONE 0x00000010
#define MAP_PRECOMPOSED 0x00000020
#define MAP_COMPOSITE 0x00000040
#define MAP_FOLDDIGITS 0x00000080


#define MAP_EXPAND_LIGATURES 0x00002000


//
//  Locale Dependent Mapping Flags.
//
#define LCMAP_LOWERCASE 0x00000100
#define LCMAP_UPPERCASE 0x00000200

#define LCMAP_TITLECASE 0x00000300


#define LCMAP_SORTKEY 0x00000400
#define LCMAP_BYTEREV 0x00000800

#define LCMAP_HIRAGANA 0x00100000
#define LCMAP_KATAKANA 0x00200000
#define LCMAP_HALFWIDTH 0x00400000
#define LCMAP_FULLWIDTH 0x00800000

#define LCMAP_LINGUISTIC_CASING 0x01000000

#define LCMAP_SIMPLIFIED_CHINESE 0x02000000
#define LCMAP_TRADITIONAL_CHINESE 0x04000000


//
//  Search Flags
//
#define FIND_STARTSWITH 0x00100000
#define FIND_ENDSWITH 0x00200000
#define FIND_FROMSTART 0x00400000
#define FIND_FROMEND 0x00800000


//
//  Language Group Enumeration Flags.
//
#define LGRPID_INSTALLED 0x00000001
#define LGRPID_SUPPORTED 0x00000002


//
//  Locale Enumeration Flags.
//
#define LCID_INSTALLED 0x00000001
#define LCID_SUPPORTED 0x00000002
#define LCID_ALTERNATE_SORTS 0x00000004



//
//  Named based enumeration flags.
//
#define LOCALE_ALL 0
#define LOCALE_WINDOWS 0x00000001
#define LOCALE_SUPPLEMENTAL 0x00000002
#define LOCALE_ALTERNATE_SORTS 0x00000004
#define LOCALE_REPLACEMENT 0x00000008


#define LOCALE_NEUTRALDATA 0x00000010
#define LOCALE_SPECIFICDATA 0x00000020


//
//  Code Page Enumeration Flags.
//
#define CP_INSTALLED 0x00000001
#define CP_SUPPORTED 0x00000002


//
//  Sorting Flags.
//
//    WORD Sort:    culturally correct sort
//                  hyphen and apostrophe are special cased
//                  example: "coop" and "co-op" will sort together in a list
//
//                        co_op     <-------  underscore (symbol)
//                        coat
//                        comb
//                        coop
//                        co-op     <-------  hyphen (punctuation)
//                        cork
//                        went
//                        were
//                        we're     <-------  apostrophe (punctuation)
//
//
//    STRING Sort:  hyphen and apostrophe will sort with all other symbols
//
//                        co-op     <-------  hyphen (punctuation)
//                        co_op     <-------  underscore (symbol)
//                        coat
//                        comb
//                        coop
//                        cork
//                        we're     <-------  apostrophe (punctuation)
//                        went
//                        were
//
#define SORT_STRINGSORT 0x00001000

//  Sort digits as numbers (ie: 2 comes before 10)

#define SORT_DIGITSASNUMBERS 0x00000008



//
//  Compare String Return Values.
//
#define CSTR_LESS_THAN 1
#define CSTR_EQUAL 2
#define CSTR_GREATER_THAN 3


//
//  Code Page Default Values.
//
#define CP_ACP 0
#define CP_OEMCP 1
#define CP_MACCP 2
#define CP_THREAD_ACP 3
#define CP_SYMBOL 42

#define CP_UTF7 65000
#define CP_UTF8 65001


//
//  Country/Region Codes.
//
#define CTRY_DEFAULT 0

#define CTRY_ALBANIA 355
#define CTRY_ALGERIA 213
#define CTRY_ARGENTINA 54
#define CTRY_ARMENIA 374
#define CTRY_AUSTRALIA 61
#define CTRY_AUSTRIA 43
#define CTRY_AZERBAIJAN 994
#define CTRY_BAHRAIN 973
#define CTRY_BELARUS 375
#define CTRY_BELGIUM 32
#define CTRY_BELIZE 501
#define CTRY_BOLIVIA 591
#define CTRY_BRAZIL 55
#define CTRY_BRUNEI_DARUSSALAM 673
#define CTRY_BULGARIA 359
#define CTRY_CANADA 2
#define CTRY_CARIBBEAN 1
#define CTRY_CHILE 56
#define CTRY_COLOMBIA 57
#define CTRY_COSTA_RICA 506
#define CTRY_CROATIA 385
#define CTRY_CZECH 420
#define CTRY_DENMARK 45
#define CTRY_DOMINICAN_REPUBLIC 1
#define CTRY_ECUADOR 593
#define CTRY_EGYPT 20
#define CTRY_EL_SALVADOR 503
#define CTRY_ESTONIA 372
#define CTRY_FAEROE_ISLANDS 298
#define CTRY_FINLAND 358
#define CTRY_FRANCE 33
#define CTRY_GEORGIA 995
#define CTRY_GERMANY 49
#define CTRY_GREECE 30
#define CTRY_GUATEMALA 502
#define CTRY_HONDURAS 504
#define CTRY_HONG_KONG 852
#define CTRY_HUNGARY 36
#define CTRY_ICELAND 354
#define CTRY_INDIA 91
#define CTRY_INDONESIA 62
#define CTRY_IRAN 981
#define CTRY_IRAQ 964
#define CTRY_IRELAND 353
#define CTRY_ISRAEL 972
#define CTRY_ITALY 39
#define CTRY_JAMAICA 1
#define CTRY_JAPAN 81
#define CTRY_JORDAN 962
#define CTRY_KAZAKSTAN 7
#define CTRY_KENYA 254
#define CTRY_KUWAIT 965
#define CTRY_KYRGYZSTAN 996
#define CTRY_LATVIA 371
#define CTRY_LEBANON 961
#define CTRY_LIBYA 218
#define CTRY_LIECHTENSTEIN 41
#define CTRY_LITHUANIA 370
#define CTRY_LUXEMBOURG 352
#define CTRY_MACAU 853
#define CTRY_MACEDONIA 389
#define CTRY_MALAYSIA 60
#define CTRY_MALDIVES 960
#define CTRY_MEXICO 52
#define CTRY_MONACO 33
#define CTRY_MONGOLIA 976
#define CTRY_MOROCCO 212
#define CTRY_NETHERLANDS 31
#define CTRY_NEW_ZEALAND 64
#define CTRY_NICARAGUA 505
#define CTRY_NORWAY 47
#define CTRY_OMAN 968
#define CTRY_PAKISTAN 92
#define CTRY_PANAMA 507
#define CTRY_PARAGUAY 595
#define CTRY_PERU 51
#define CTRY_PHILIPPINES 63
#define CTRY_POLAND 48
#define CTRY_PORTUGAL 351
#define CTRY_PRCHINA 86
#define CTRY_PUERTO_RICO 1
#define CTRY_QATAR 974
#define CTRY_ROMANIA 40
#define CTRY_RUSSIA 7
#define CTRY_SAUDI_ARABIA 966
#define CTRY_SERBIA 381
#define CTRY_SINGAPORE 65
#define CTRY_SLOVAK 421
#define CTRY_SLOVENIA 386
#define CTRY_SOUTH_AFRICA 27
#define CTRY_SOUTH_KOREA 82
#define CTRY_SPAIN 34
#define CTRY_SWEDEN 46
#define CTRY_SWITZERLAND 41
#define CTRY_SYRIA 963
#define CTRY_TAIWAN 886
#define CTRY_TATARSTAN 7
#define CTRY_THAILAND 66
#define CTRY_TRINIDAD_Y_TOBAGO 1
#define CTRY_TUNISIA 216
#define CTRY_TURKEY 90
#define CTRY_UAE 971
#define CTRY_UKRAINE 380
#define CTRY_UNITED_KINGDOM 44
#define CTRY_UNITED_STATES 1
#define CTRY_URUGUAY 598
#define CTRY_UZBEKISTAN 7
#define CTRY_VENEZUELA 58
#define CTRY_VIET_NAM 84
#define CTRY_YEMEN 967
#define CTRY_ZIMBABWE 263


//
//  Locale Types.
//
//  These types are used for the GetLocaleInfo NLS API routine.
//  Some of these types are also used for the SetLocaleInfo NLS API routine.
//

//
//  The following LCTypes may be used in combination with any other LCTypes.
//
//    LOCALE_NOUSEROVERRIDE is also used in GetTimeFormat and
//    GetDateFormat.
//
//    LOCALE_USE_CP_ACP is used in many of the A (Ansi) apis that need
//    to do string translation.
//
//    LOCALE_RETURN_NUMBER will return the result from GetLocaleInfo as a
//    number instead of a string.  This flag is only valid for the LCTypes
//    beginning with LOCALE_I.
//
#define LOCALE_NOUSEROVERRIDE 0x80000000
#define LOCALE_USE_CP_ACP 0x40000000


#define LOCALE_RETURN_NUMBER 0x20000000



#define LOCALE_RETURN_GENITIVE_NAMES 0x10000000
#define LOCALE_ALLOW_NEUTRAL_NAMES 0x08000000


//
//  The following LCTypes are mutually exclusive in that they may NOT
//  be used in combination with each other.
//

//
// These are the various forms of the name of the locale:
//
#define LOCALE_SLOCALIZEDDISPLAYNAME 0x00000002

#define LOCALE_SENGLISHDISPLAYNAME 0x00000072
#define LOCALE_SNATIVEDISPLAYNAME 0x00000073



#define LOCALE_SLOCALIZEDLANGUAGENAME 0x0000006f

#define LOCALE_SENGLISHLANGUAGENAME 0x00001001
#define LOCALE_SNATIVELANGUAGENAME 0x00000004

#define LOCALE_SLOCALIZEDCOUNTRYNAME 0x00000006
#define LOCALE_SENGLISHCOUNTRYNAME 0x00001002
#define LOCALE_SNATIVECOUNTRYNAME 0x00000008

//
// Legacy labels for the locale name values
//
#define LOCALE_SLANGUAGE 0x00000002

#define LOCALE_SLANGDISPLAYNAME 0x0000006f

#define LOCALE_SENGLANGUAGE 0x00001001
#define LOCALE_SNATIVELANGNAME 0x00000004
#define LOCALE_SCOUNTRY 0x00000006
#define LOCALE_SENGCOUNTRY 0x00001002
#define LOCALE_SNATIVECTRYNAME 0x00000008

// Additional LCTypes
#define LOCALE_ILANGUAGE 0x00000001

#define LOCALE_SABBREVLANGNAME 0x00000003

#define LOCALE_ICOUNTRY 0x00000005
#define LOCALE_SABBREVCTRYNAME 0x00000007
#define LOCALE_IGEOID 0x0000005B

#define LOCALE_IDEFAULTLANGUAGE 0x00000009
#define LOCALE_IDEFAULTCOUNTRY 0x0000000A
#define LOCALE_IDEFAULTCODEPAGE 0x0000000B
#define LOCALE_IDEFAULTANSICODEPAGE 0x00001004
#define LOCALE_IDEFAULTMACCODEPAGE 0x00001011

#define LOCALE_SLIST 0x0000000C
#define LOCALE_IMEASURE 0x0000000D

#define LOCALE_SDECIMAL 0x0000000E
#define LOCALE_STHOUSAND 0x0000000F
#define LOCALE_SGROUPING 0x00000010
#define LOCALE_IDIGITS 0x00000011
#define LOCALE_ILZERO 0x00000012
#define LOCALE_INEGNUMBER 0x00001010
#define LOCALE_SNATIVEDIGITS 0x00000013

#define LOCALE_SCURRENCY 0x00000014
#define LOCALE_SINTLSYMBOL 0x00000015
#define LOCALE_SMONDECIMALSEP 0x00000016
#define LOCALE_SMONTHOUSANDSEP 0x00000017
#define LOCALE_SMONGROUPING 0x00000018
#define LOCALE_ICURRDIGITS 0x00000019
#define LOCALE_IINTLCURRDIGITS 0x0000001A
#define LOCALE_ICURRENCY 0x0000001B
#define LOCALE_INEGCURR 0x0000001C

#define LOCALE_SDATE 0x0000001D
#define LOCALE_STIME 0x0000001E
#define LOCALE_SSHORTDATE 0x0000001F
#define LOCALE_SLONGDATE 0x00000020
#define LOCALE_STIMEFORMAT 0x00001003
#define LOCALE_IDATE 0x00000021
#define LOCALE_ILDATE 0x00000022
#define LOCALE_ITIME 0x00000023
#define LOCALE_ITIMEMARKPOSN 0x00001005
#define LOCALE_ICENTURY 0x00000024
#define LOCALE_ITLZERO 0x00000025
#define LOCALE_IDAYLZERO 0x00000026
#define LOCALE_IMONLZERO 0x00000027
#define LOCALE_S1159 0x00000028
#define LOCALE_S2359 0x00000029

#define LOCALE_ICALENDARTYPE 0x00001009
#define LOCALE_IOPTIONALCALENDAR 0x0000100B
#define LOCALE_IFIRSTDAYOFWEEK 0x0000100C
#define LOCALE_IFIRSTWEEKOFYEAR 0x0000100D

#define LOCALE_SDAYNAME1 0x0000002A
#define LOCALE_SDAYNAME2 0x0000002B
#define LOCALE_SDAYNAME3 0x0000002C
#define LOCALE_SDAYNAME4 0x0000002D
#define LOCALE_SDAYNAME5 0x0000002E
#define LOCALE_SDAYNAME6 0x0000002F
#define LOCALE_SDAYNAME7 0x00000030
#define LOCALE_SABBREVDAYNAME1 0x00000031
#define LOCALE_SABBREVDAYNAME2 0x00000032
#define LOCALE_SABBREVDAYNAME3 0x00000033
#define LOCALE_SABBREVDAYNAME4 0x00000034
#define LOCALE_SABBREVDAYNAME5 0x00000035
#define LOCALE_SABBREVDAYNAME6 0x00000036
#define LOCALE_SABBREVDAYNAME7 0x00000037
#define LOCALE_SMONTHNAME1 0x00000038
#define LOCALE_SMONTHNAME2 0x00000039
#define LOCALE_SMONTHNAME3 0x0000003A
#define LOCALE_SMONTHNAME4 0x0000003B
#define LOCALE_SMONTHNAME5 0x0000003C
#define LOCALE_SMONTHNAME6 0x0000003D
#define LOCALE_SMONTHNAME7 0x0000003E
#define LOCALE_SMONTHNAME8 0x0000003F
#define LOCALE_SMONTHNAME9 0x00000040
#define LOCALE_SMONTHNAME10 0x00000041
#define LOCALE_SMONTHNAME11 0x00000042
#define LOCALE_SMONTHNAME12 0x00000043
#define LOCALE_SMONTHNAME13 0x0000100E
#define LOCALE_SABBREVMONTHNAME1 0x00000044
#define LOCALE_SABBREVMONTHNAME2 0x00000045
#define LOCALE_SABBREVMONTHNAME3 0x00000046
#define LOCALE_SABBREVMONTHNAME4 0x00000047
#define LOCALE_SABBREVMONTHNAME5 0x00000048
#define LOCALE_SABBREVMONTHNAME6 0x00000049
#define LOCALE_SABBREVMONTHNAME7 0x0000004A
#define LOCALE_SABBREVMONTHNAME8 0x0000004B
#define LOCALE_SABBREVMONTHNAME9 0x0000004C
#define LOCALE_SABBREVMONTHNAME10 0x0000004D
#define LOCALE_SABBREVMONTHNAME11 0x0000004E
#define LOCALE_SABBREVMONTHNAME12 0x0000004F
#define LOCALE_SABBREVMONTHNAME13 0x0000100F

#define LOCALE_SPOSITIVESIGN 0x00000050
#define LOCALE_SNEGATIVESIGN 0x00000051
#define LOCALE_IPOSSIGNPOSN 0x00000052
#define LOCALE_INEGSIGNPOSN 0x00000053
#define LOCALE_IPOSSYMPRECEDES 0x00000054
#define LOCALE_IPOSSEPBYSPACE 0x00000055
#define LOCALE_INEGSYMPRECEDES 0x00000056
#define LOCALE_INEGSEPBYSPACE 0x00000057


#define LOCALE_FONTSIGNATURE 0x00000058
#define LOCALE_SISO639LANGNAME 0x00000059
#define LOCALE_SISO3166CTRYNAME 0x0000005A



#define LOCALE_IDEFAULTEBCDICCODEPAGE 0x00001012
#define LOCALE_IPAPERSIZE 0x0000100A
#define LOCALE_SENGCURRNAME 0x00001007
#define LOCALE_SNATIVECURRNAME 0x00001008
#define LOCALE_SYEARMONTH 0x00001006
#define LOCALE_SSORTNAME 0x00001013
#define LOCALE_IDIGITSUBSTITUTION 0x00001014




#define LOCALE_SNAME 0x0000005c
#define LOCALE_SDURATION 0x0000005d
#define LOCALE_SKEYBOARDSTOINSTALL 0x0000005e
#define LOCALE_SSHORTESTDAYNAME1 0x00000060
#define LOCALE_SSHORTESTDAYNAME2 0x00000061
#define LOCALE_SSHORTESTDAYNAME3 0x00000062
#define LOCALE_SSHORTESTDAYNAME4 0x00000063
#define LOCALE_SSHORTESTDAYNAME5 0x00000064
#define LOCALE_SSHORTESTDAYNAME6 0x00000065
#define LOCALE_SSHORTESTDAYNAME7 0x00000066
#define LOCALE_SISO639LANGNAME2 0x00000067
#define LOCALE_SISO3166CTRYNAME2 0x00000068
#define LOCALE_SNAN 0x00000069
#define LOCALE_SPOSINFINITY 0x0000006a
#define LOCALE_SNEGINFINITY 0x0000006b
#define LOCALE_SSCRIPTS 0x0000006c
#define LOCALE_SPARENT 0x0000006d
#define LOCALE_SCONSOLEFALLBACKNAME 0x0000006e



#define LOCALE_IREADINGLAYOUT 0x00000070
                                                   // 0 - Left to right (eg en-US)
                                                   // 1 - Right to left (eg arabic locales)
                                                   // 2 - Vertical top to bottom with columns to the left and also left to right (ja-JP locales)
                                                   // 3 - Vertical top to bottom with columns proceeding to the right
#define LOCALE_INEUTRAL 0x00000071
#define LOCALE_INEGATIVEPERCENT 0x00000074
#define LOCALE_IPOSITIVEPERCENT 0x00000075
#define LOCALE_SPERCENT 0x00000076
#define LOCALE_SPERMILLE 0x00000077
#define LOCALE_SMONTHDAY 0x00000078
#define LOCALE_SSHORTTIME 0x00000079
#define LOCALE_SOPENTYPELANGUAGETAG 0x0000007a
#define LOCALE_SSORTLOCALE 0x0000007b


//
//  Time Flags for GetTimeFormat.
//
#define TIME_NOMINUTESORSECONDS 0x00000001
#define TIME_NOSECONDS 0x00000002
#define TIME_NOTIMEMARKER 0x00000004
#define TIME_FORCE24HOURFORMAT 0x00000008


//
//  Date Flags for GetDateFormat.
//
#define DATE_SHORTDATE 0x00000001
#define DATE_LONGDATE 0x00000002
#define DATE_USE_ALT_CALENDAR 0x00000004


#define DATE_YEARMONTH 0x00000008
#define DATE_LTRREADING 0x00000010
#define DATE_RTLREADING 0x00000020



#define DATE_AUTOLAYOUT 0x00000040


//
//  Calendar Types.
//
//  These types are used for the EnumCalendarInfo and GetCalendarInfo
//  NLS API routines.
//  Some of these types are also used for the SetCalendarInfo NLS API
//  routine.
//

//
//  The following CalTypes may be used in combination with any other CalTypes.
//
//    CAL_NOUSEROVERRIDE
//
//    CAL_USE_CP_ACP is used in the A (Ansi) apis that need to do string
//    translation.
//
//    CAL_RETURN_NUMBER will return the result from GetCalendarInfo as a
//    number instead of a string.  This flag is only valid for the CalTypes
//    beginning with CAL_I.
//

#define CAL_NOUSEROVERRIDE LOCALE_NOUSEROVERRIDE
#define CAL_USE_CP_ACP LOCALE_USE_CP_ACP
#define CAL_RETURN_NUMBER LOCALE_RETURN_NUMBER



#define CAL_RETURN_GENITIVE_NAMES LOCALE_RETURN_GENITIVE_NAMES


//
//  The following CalTypes are mutually exclusive in that they may NOT
//  be used in combination with each other.
//
#define CAL_ICALINTVALUE 0x00000001
#define CAL_SCALNAME 0x00000002
#define CAL_IYEAROFFSETRANGE 0x00000003
#define CAL_SERASTRING 0x00000004
#define CAL_SSHORTDATE 0x00000005
#define CAL_SLONGDATE 0x00000006
#define CAL_SDAYNAME1 0x00000007
#define CAL_SDAYNAME2 0x00000008
#define CAL_SDAYNAME3 0x00000009
#define CAL_SDAYNAME4 0x0000000a
#define CAL_SDAYNAME5 0x0000000b
#define CAL_SDAYNAME6 0x0000000c
#define CAL_SDAYNAME7 0x0000000d
#define CAL_SABBREVDAYNAME1 0x0000000e
#define CAL_SABBREVDAYNAME2 0x0000000f
#define CAL_SABBREVDAYNAME3 0x00000010
#define CAL_SABBREVDAYNAME4 0x00000011
#define CAL_SABBREVDAYNAME5 0x00000012
#define CAL_SABBREVDAYNAME6 0x00000013
#define CAL_SABBREVDAYNAME7 0x00000014
// Note that in the hebrew calendar the leap month name is always returned as the 7th month
#define CAL_SMONTHNAME1 0x00000015
#define CAL_SMONTHNAME2 0x00000016
#define CAL_SMONTHNAME3 0x00000017
#define CAL_SMONTHNAME4 0x00000018
#define CAL_SMONTHNAME5 0x00000019
#define CAL_SMONTHNAME6 0x0000001a
#define CAL_SMONTHNAME7 0x0000001b
#define CAL_SMONTHNAME8 0x0000001c
#define CAL_SMONTHNAME9 0x0000001d
#define CAL_SMONTHNAME10 0x0000001e
#define CAL_SMONTHNAME11 0x0000001f
#define CAL_SMONTHNAME12 0x00000020
#define CAL_SMONTHNAME13 0x00000021
#define CAL_SABBREVMONTHNAME1 0x00000022
#define CAL_SABBREVMONTHNAME2 0x00000023
#define CAL_SABBREVMONTHNAME3 0x00000024
#define CAL_SABBREVMONTHNAME4 0x00000025
#define CAL_SABBREVMONTHNAME5 0x00000026
#define CAL_SABBREVMONTHNAME6 0x00000027
#define CAL_SABBREVMONTHNAME7 0x00000028
#define CAL_SABBREVMONTHNAME8 0x00000029
#define CAL_SABBREVMONTHNAME9 0x0000002a
#define CAL_SABBREVMONTHNAME10 0x0000002b
#define CAL_SABBREVMONTHNAME11 0x0000002c
#define CAL_SABBREVMONTHNAME12 0x0000002d
#define CAL_SABBREVMONTHNAME13 0x0000002e


#define CAL_SYEARMONTH 0x0000002f
#define CAL_ITWODIGITYEARMAX 0x00000030



#define CAL_SSHORTESTDAYNAME1 0x00000031
#define CAL_SSHORTESTDAYNAME2 0x00000032
#define CAL_SSHORTESTDAYNAME3 0x00000033
#define CAL_SSHORTESTDAYNAME4 0x00000034
#define CAL_SSHORTESTDAYNAME5 0x00000035
#define CAL_SSHORTESTDAYNAME6 0x00000036
#define CAL_SSHORTESTDAYNAME7 0x00000037



#define CAL_SMONTHDAY 0x00000038
#define CAL_SABBREVERASTRING 0x00000039


//
//  Calendar Enumeration Value.
//
#define ENUM_ALL_CALENDARS 0xffffffff


//
//  Calendar ID Values.
//
#define CAL_GREGORIAN 1
#define CAL_GREGORIAN_US 2
#define CAL_JAPAN 3
#define CAL_TAIWAN 4
#define CAL_KOREA 5
#define CAL_HIJRI 6
#define CAL_THAI 7
#define CAL_HEBREW 8
#define CAL_GREGORIAN_ME_FRENCH 9
#define CAL_GREGORIAN_ARABIC 10
#define CAL_GREGORIAN_XLIT_ENGLISH 11
#define CAL_GREGORIAN_XLIT_FRENCH 12
#define CAL_UMALQURA 23


//
//  Language Group ID Values.
//
#define LGRPID_WESTERN_EUROPE 0x0001
#define LGRPID_CENTRAL_EUROPE 0x0002
#define LGRPID_BALTIC 0x0003
#define LGRPID_GREEK 0x0004
#define LGRPID_CYRILLIC 0x0005
#define LGRPID_TURKIC 0x0006
#define LGRPID_TURKISH 0x0006
#define LGRPID_JAPANESE 0x0007
#define LGRPID_KOREAN 0x0008
#define LGRPID_TRADITIONAL_CHINESE 0x0009
#define LGRPID_SIMPLIFIED_CHINESE 0x000a
#define LGRPID_THAI 0x000b
#define LGRPID_HEBREW 0x000c
#define LGRPID_ARABIC 0x000d
#define LGRPID_VIETNAMESE 0x000e
#define LGRPID_INDIC 0x000f
#define LGRPID_GEORGIAN 0x0010
#define LGRPID_ARMENIAN 0x0011



//
//  MUI function flag values
//
#define MUI_LANGUAGE_ID 0x4
#define MUI_LANGUAGE_NAME 0x8
#define MUI_MERGE_SYSTEM_FALLBACK 0x10
#define MUI_MERGE_USER_FALLBACK 0x20
#define MUI_UI_FALLBACK MUI_MERGE_SYSTEM_FALLBACK | MUI_MERGE_USER_FALLBACK
#define MUI_THREAD_LANGUAGES 0x40
#define MUI_CONSOLE_FILTER 0x100
#define MUI_COMPLEX_SCRIPT_FILTER 0x200
#define MUI_RESET_FILTERS 0x001
#define MUI_USER_PREFERRED_UI_LANGUAGES 0x10
#define MUI_USE_INSTALLED_LANGUAGES 0x20
#define MUI_USE_SEARCH_ALL_LANGUAGES 0x40
#define MUI_LANG_NEUTRAL_PE_FILE 0x100
#define MUI_NON_LANG_NEUTRAL_FILE 0x200
#define MUI_MACHINE_LANGUAGE_SETTINGS 0x400
#define MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL 0x001
#define MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN 0x002
#define MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI 0x004
#define MUI_QUERY_TYPE 0x001
#define MUI_QUERY_CHECKSUM 0x002
#define MUI_QUERY_LANGUAGE_NAME 0x004
#define MUI_QUERY_RESOURCE_TYPES 0x008
#define MUI_FILEINFO_VERSION 0x001

#define MUI_FULL_LANGUAGE 0x01
#define MUI_PARTIAL_LANGUAGE 0x02
#define MUI_LIP_LANGUAGE 0x04
#define MUI_LANGUAGE_INSTALLED 0x20
#define MUI_LANGUAGE_LICENSED 0x40

//
// MUI_CALLBACK_FLAG defines are duplicated in rtlmui.h
//

#define MUI_CALLBACK_ALL_FLAGS MUI_CALLBACK_FLAG_UPGRADED_INSTALLATION

//
// MUI_CALLBACK_ flags are duplicated in rtlmui.h
//



////////////////////////////////////////////////////////////////////////////
//
//  Typedefs
//
//  Define all types for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////

//
//  Language Group ID.
//
typedef DWORD LGRPID;


//
//  Locale type constant.
//
typedef DWORD LCTYPE;


//
//  Calendar type constant.
//
typedef DWORD CALTYPE;


//
//  Calendar ID.
//
typedef DWORD CALID;


//
//  CP Info.
//

typedef struct _cpinfo {
    UINT MaxCharSize; // max length (in bytes) of a char
    BYTE DefaultChar[2]; // default character
    BYTE LeadByte[12]; // lead byte ranges
} CPINFO, *LPCPINFO;

typedef struct _cpinfoexA {
    UINT MaxCharSize; // max length (in bytes) of a char
    BYTE DefaultChar[2]; // default character (MB)
    BYTE LeadByte[12]; // lead byte ranges
    WCHAR UnicodeDefaultChar; // default character (Unicode)
    UINT CodePage; // code page id
    CHAR CodePageName[260]; // code page name (Unicode)
} CPINFOEXA, *LPCPINFOEXA;
typedef struct _cpinfoexW {
    UINT MaxCharSize; // max length (in bytes) of a char
    BYTE DefaultChar[2]; // default character (MB)
    BYTE LeadByte[12]; // lead byte ranges
    WCHAR UnicodeDefaultChar; // default character (Unicode)
    UINT CodePage; // code page id
    WCHAR CodePageName[260]; // code page name (Unicode)
} CPINFOEXW, *LPCPINFOEXW;




typedef CPINFOEXA CPINFOEX;
typedef LPCPINFOEXA LPCPINFOEX;



//
//  Number format.
//

typedef struct _numberfmtA {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPSTR lpDecimalSep; // ptr to decimal separator string
    LPSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative number ordering
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPWSTR lpDecimalSep; // ptr to decimal separator string
    LPWSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative number ordering
} NUMBERFMTW, *LPNUMBERFMTW;




typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;



//
//  Currency format.
//

typedef struct _currencyfmtA {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPSTR lpDecimalSep; // ptr to decimal separator string
    LPSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative currency ordering
    UINT PositiveOrder; // positive currency ordering
    LPSTR lpCurrencySymbol; // ptr to currency symbol string
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT NumDigits; // number of decimal digits
    UINT LeadingZero; // if leading zero in decimal fields
    UINT Grouping; // group size left of decimal
    LPWSTR lpDecimalSep; // ptr to decimal separator string
    LPWSTR lpThousandSep; // ptr to thousand separator string
    UINT NegativeOrder; // negative currency ordering
    UINT PositiveOrder; // positive currency ordering
    LPWSTR lpCurrencySymbol; // ptr to currency symbol string
} CURRENCYFMTW, *LPCURRENCYFMTW;




typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;


//
//  NLS function capabilities
//

enum SYSNLS_FUNCTION{
    COMPARE_STRING = 0x0001,
};
typedef DWORD NLS_FUNCTION;


//
//  NLS version structure.
//

typedef struct _nlsversioninfo{
    DWORD dwNLSVersionInfoSize; // 12 bytes
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;
} NLSVERSIONINFO, *LPNLSVERSIONINFO;

// This is to be deprecated, please use the NLSVERSIONINFO
// structure above in the future.  The difference is that
// the effective ID is more robust.
typedef struct _nlsversioninfoex{
    DWORD dwNLSVersionInfoSize; // sizeof(NLSVERSIONINFOEX) == 32 bytes
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;
    DWORD dwEffectiveId; // Use NLSVERSIONINFO instead
    GUID guidCustomVersion;
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;

//
//  GEO defines
//

typedef LONG GEOID;
typedef DWORD GEOTYPE;
typedef DWORD GEOCLASS;

#define GEOID_NOT_AVAILABLE -1

//
//  GEO information types for clients to query
//

enum SYSGEOTYPE {
    GEO_NATION = 0x0001,
    GEO_LATITUDE = 0x0002,
    GEO_LONGITUDE = 0x0003,
    GEO_ISO2 = 0x0004,
    GEO_ISO3 = 0x0005,
    GEO_RFC1766 = 0x0006,
    GEO_LCID = 0x0007,
    GEO_FRIENDLYNAME= 0x0008,
    GEO_OFFICIALNAME= 0x0009,
    GEO_TIMEZONES = 0x000A,
    GEO_OFFICIALLANGUAGES = 0x000B,
};

//
//  More GEOCLASS defines will be listed here
//

enum SYSGEOCLASS {
    GEOCLASS_NATION = 16,
    GEOCLASS_REGION = 14,
};


//
//  Normalization forms
//

typedef enum _NORM_FORM {
    NormalizationOther = 0, // Not supported
    NormalizationC = 0x1, // Each base plus combining characters to the canonical precomposed equivalent.
    NormalizationD = 0x2, // Each precomposed character to its canonical decomposed equivalent.
    NormalizationKC = 0x5, // Each base plus combining characters to the canonical precomposed
                                   //   equivalents and all compatibility characters to their equivalents.
    NormalizationKD = 0x6 // Each precomposed character to its canonical decomposed equivalent
                                   //   and all compatibility characters to their equivalents.
} NORM_FORM;

//
// IDN (International Domain Name) Flags
//
#define IDN_ALLOW_UNASSIGNED 0x01
#define IDN_USE_STD3_ASCII_RULES 0x02

#define VS_ALLOW_LATIN 0x0001

#define GSS_ALLOW_INHERITED_COMMON 0x0001


//
//  Enumeration function constants.
//



typedef BOOL (* LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);
typedef BOOL (* LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
typedef BOOL (* UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
typedef BOOL (* LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL (* CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL (* DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (* DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (* TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (* CALINFO_ENUMPROCA)(LPSTR);
typedef BOOL (* CALINFO_ENUMPROCEXA)(LPSTR, CALID);

typedef BOOL (* LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);
typedef BOOL (* LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
typedef BOOL (* UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (* LOCALE_ENUMPROCW)(LPWSTR);
typedef BOOL (* CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL (* DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (* DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (* TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (* CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (* CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (* GEO_ENUMPROC)(GEOID);
# 1191 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
#define LANGUAGEGROUP_ENUMPROC LANGUAGEGROUP_ENUMPROCA
#define LANGGROUPLOCALE_ENUMPROC LANGGROUPLOCALE_ENUMPROCA
#define UILANGUAGE_ENUMPROC UILANGUAGE_ENUMPROCA
#define LOCALE_ENUMPROC LOCALE_ENUMPROCA
#define CODEPAGE_ENUMPROC CODEPAGE_ENUMPROCA
#define DATEFMT_ENUMPROC DATEFMT_ENUMPROCA
#define DATEFMT_ENUMPROCEX DATEFMT_ENUMPROCEXA
#define TIMEFMT_ENUMPROC TIMEFMT_ENUMPROCA
#define CALINFO_ENUMPROC CALINFO_ENUMPROCA
#define CALINFO_ENUMPROCEX CALINFO_ENUMPROCEXA



//
// Information about a MUI file, used as input/output in GetFileMUIInfo
// All offsets are relative to start of the structure. Offsets with value 0 mean empty field.
//

typedef struct _FILEMUIINFO {
    DWORD dwSize; // Size of the structure including buffer size [in]
    DWORD dwVersion; // Version of the structure [in]
    DWORD dwFileType; // Type of the file [out]
    BYTE pChecksum[16]; // Checksum of the file [out]
    BYTE pServiceChecksum[16]; // Checksum of the file [out]
    DWORD dwLanguageNameOffset; // Language name of the file [out]
    DWORD dwTypeIDMainSize; // Number of TypeIDs in main module [out]
    DWORD dwTypeIDMainOffset; // Array of TypeIDs (DWORD) in main module [out]
    DWORD dwTypeNameMainOffset; // Multistring array of TypeNames in main module [out]
    DWORD dwTypeIDMUISize; // Number of TypeIDs in MUI module [out]
    DWORD dwTypeIDMUIOffset; // Array of TypeIDs (DWORD) in MUI module [out]
    DWORD dwTypeNameMUIOffset; // Multistring array of TypeNames in MUI module [out]
    BYTE abBuffer[8]; // Buffer for extra data [in] (Size 4 is for padding)
} FILEMUIINFO, *PFILEMUIINFO;



////////////////////////////////////////////////////////////////////////////
//
//  Macros
//
//  Define all macros for the NLS component here.
//
////////////////////////////////////////////////////////////////////////////

//
//  Macros to determine whether a character is a high or low surrogate,
//  and whether two code points make up a surrogate pair (a high surrogate
//  and a low surrogate).
//
#define IS_HIGH_SURROGATE(wch) (((wch) >= HIGH_SURROGATE_START) && ((wch) <= HIGH_SURROGATE_END))
#define IS_LOW_SURROGATE(wch) (((wch) >= LOW_SURROGATE_START) && ((wch) <= LOW_SURROGATE_END))
#define IS_SURROGATE_PAIR(hs,ls) (IS_HIGH_SURROGATE(hs) && IS_LOW_SURROGATE(ls))

// ----------------------------------------------------------------------
// The following macros retrieve information from a MUIFILEINFO structure
//
// Gets the culture name (LPWSTR), NULL if not initialized
#define FILEMUIINFO_GET_CULTURE(pInfo) ((LPWSTR)((pInfo->dwLanguageNameOffset>0)?(ULONG_PTR)pInfo+pInfo->dwLanguageNameOffset:NULL))

//
// Gets the main module types array (DWORD[]), NULL if not initialized
#define FILEMUIINFO_GET_MAIN_TYPEIDS(pInfo) ((DWORD*)((pInfo->dwTypeIDMainOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeIDMainOffset:NULL))

//
// Gets the main module type array element iType (DWORD), the array is not initialized or index is out of bounds
#define FILEMUIINFO_GET_MAIN_TYPEID(pInfo,iType) (((iType<pInfo->dwTypeIDMainSize)&&(pInfo->dwTypeIDMainOffset>0))?*((DWORD*)((ULONG_PTR)pInfo+pInfo->dwTypeIDMainOffset)+iType):0)

//
// Gets the main module names multistring array (LPWSTR), NULL if not initialized
#define FILEMUIINFO_GET_MAIN_TYPENAMES(pInfo) ((LPWSTR)((pInfo->dwTypeNameMainOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeNameMainOffset:NULL))

//
// Gets the mui module types array (DWORD[]), NULL if not initialized
#define FILEMUIINFO_GET_MUI_TYPEIDS(pInfo) ((DWORD*)((pInfo->dwTypeIDMUIOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeIDMUIOffset:NULL))

//
// Gets the mui module type array element iType (DWORD), the array is not initialized or index is out of bounds
#define FILEMUIINFO_GET_MUI_TYPEID(pInfo,iType) (((iType<pInfo->dwTypeIDMUISize)&&(pInfo->dwTypeIDMUIOffset>0))?*((DWORD*)((ULONG_PTR)pInfo+pInfo->dwTypeIDMUIOffset)+iType):0)

//
// Gets the mui module names multistring array (LPWSTR), NULL if not initialized
#define FILEMUIINFO_GET_MUI_TYPENAMES(pInfo) ((LPWSTR)((pInfo->dwTypeNameMUIOffset>0)?(ULONG_PTR)pInfo+pInfo->dwTypeNameMUIOffset:NULL))

// ------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
//  Only prototypes for the NLS APIs should go here.
//
////////////////////////////////////////////////////////////////////////////

//
//  Code Page Dependent APIs.
//


BOOL

IsValidCodePage(
    UINT CodePage);


UINT

GetACP(void);


UINT

GetOEMCP(void);


BOOL

GetCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo);


BOOL

GetCPInfoExA(
    UINT CodePage,
    DWORD dwFlags,
    LPCPINFOEXA lpCPInfoEx);

BOOL

GetCPInfoExW(
    UINT CodePage,
    DWORD dwFlags,
    LPCPINFOEXW lpCPInfoEx);



#define GetCPInfoEx GetCPInfoExA



BOOL

IsDBCSLeadByte(
    BYTE TestChar);


BOOL

IsDBCSLeadByteEx(
    UINT CodePage,
    BYTE TestChar);


int

MultiByteToWideChar(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);


int

WideCharToMultiByte(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar);


//
//  Locale Dependent APIs.
//

// For Windows Vista and above CompareStringEx is preferred

int

CompareStringA(
    LCID Locale,
    DWORD dwCmpFlags,
    PCNZCH lpString1,
    int cchCount1,
    PCNZCH lpString2,
    int cchCount2);


int

CompareStringW(
    LCID Locale,
    DWORD dwCmpFlags,
    PCNZWCH lpString1,
    int cchCount1,
    PCNZWCH lpString2,
    int cchCount2);




#define CompareString CompareStringA
# 1433 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnls.h"
// For Windows Vista and above FindNLSStringEx is preferred

int

FindNLSString(
    LCID Locale,
    DWORD dwFindNLSStringFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    LPINT pcchFound);






int

FindStringOrdinal(
    DWORD dwFindStringOrdinalFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    BOOL bIgnoreCase);



// For Windows Vista and above LCMapStringEx is preferred

int

LCMapStringA(
    LCID Locale,
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);
// For Windows Vista and above LCMapStringEx is preferred

int

LCMapStringW(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);



#define LCMapString LCMapStringA


// For Windows Vista and above GetLocaleInfoEx is preferred

int

GetLocaleInfoA(
    LCID Locale,
    LCTYPE LCType,
    LPSTR lpLCData,
    int cchData);
// For Windows Vista and above GetLocaleInfoEx is preferred

int

GetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPWSTR lpLCData,
    int cchData);



#define GetLocaleInfo GetLocaleInfoA



BOOL

SetLocaleInfoA(
    LCID Locale,
    LCTYPE LCType,
    LPCSTR lpLCData);

BOOL

SetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPCWSTR lpLCData);



#define SetLocaleInfo SetLocaleInfoA



// For Windows Vista and above GetCalendarInfoEx is preferred

int

GetCalendarInfoA(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPSTR lpCalData,
    int cchData,
    LPDWORD lpValue);
// For Windows Vista and above GetCalendarInfoEx is preferred

int

GetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue);



#define GetCalendarInfo GetCalendarInfoA



BOOL

SetCalendarInfoA(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPCSTR lpCalData);

BOOL

SetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPCWSTR lpCalData);



#define SetCalendarInfo SetCalendarInfoA





int

LCIDToLocaleName(
    LCID Locale,
    LPWSTR lpName,
    int cchName,
    DWORD dwFlags);


LCID

LocaleNameToLCID(
    LPCWSTR lpName,
    DWORD dwFlags);



// For Windows Vista and above GetTimeFormatEx is preferred

int

GetTimeFormatA(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpTime,
    LPCSTR lpFormat,
    LPSTR lpTimeStr,
    int cchTime);
// For Windows Vista and above GetTimeFormatEx is preferred

int

GetTimeFormatW(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime);



#define GetTimeFormat GetTimeFormatA



// For Windows Vista and above GetDurationFormatEx is preferred


int

GetDurationFormat(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpDuration,
    ULONGLONG ullDuration,
    LPCWSTR lpFormat,
    LPWSTR lpDurationStr,
    int cchDuration);


// For Windows Vista and above GetDateFormatEx is preferred

int

GetDateFormatA(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpDate,
    LPCSTR lpFormat,
    LPSTR lpDateStr,
    int cchDate);
// For Windows Vista and above GetDateFormatEx is preferred

int

GetDateFormatW(
    LCID Locale,
    DWORD dwFlags,
    const SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate);



#define GetDateFormat GetDateFormatA


// For Windows Vista and above GetNumberFormatEx is preferred

int

GetNumberFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    const NUMBERFMTA *lpFormat,
    LPSTR lpNumberStr,
    int cchNumber);
// For Windows Vista and above GetNumberFormatEx is preferred

int

GetNumberFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const NUMBERFMTW *lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber);



#define GetNumberFormat GetNumberFormatA


// For Windows Vista and above GetCurrencyFormatEx is preferred

int

GetCurrencyFormatA(
    LCID Locale,
    DWORD dwFlags,
    LPCSTR lpValue,
    const CURRENCYFMTA *lpFormat,
    LPSTR lpCurrencyStr,
    int cchCurrency);
// For Windows Vista and above GetCurrencyFormatEx is preferred

int

GetCurrencyFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const CURRENCYFMTW *lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency);



#define GetCurrencyFormat GetCurrencyFormatA


// For Windows Vista and above EnumCalendarInfoExEx is preferred

BOOL

EnumCalendarInfoA(
    CALINFO_ENUMPROCA lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);
// For Windows Vista and above EnumCalendarInfoExEx is preferred

BOOL

EnumCalendarInfoW(
    CALINFO_ENUMPROCW lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);



#define EnumCalendarInfo EnumCalendarInfoA



// For Windows Vista and above EnumCalendarInfoExEx is preferred

BOOL

EnumCalendarInfoExA(
    CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);
// For Windows Vista and above EnumCalendarInfoExEx is preferred

BOOL

EnumCalendarInfoExW(
    CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType);



#define EnumCalendarInfoEx EnumCalendarInfoExA



// For Windows Vista and above EnumTimeFormatsEx is preferred

BOOL

EnumTimeFormatsA(
    TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);
// For Windows Vista and above EnumTimeFormatsEx is preferred

BOOL

EnumTimeFormatsW(
    TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);



#define EnumTimeFormats EnumTimeFormatsA


// For Windows Vista and above EnumDateFormatsExEx is preferred

BOOL

EnumDateFormatsA(
    DATEFMT_ENUMPROCA lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);
// For Windows Vista and above EnumDateFormatsExEx is preferred

BOOL

EnumDateFormatsW(
    DATEFMT_ENUMPROCW lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags);



#define EnumDateFormats EnumDateFormatsA



// For Windows Vista and above EnumDateFormatsExEx is preferred

BOOL

EnumDateFormatsExA(
    DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
    LCID Locale,
    DWORD dwFlags);
// For Windows Vista and above EnumDateFormatsExEx is preferred

BOOL

EnumDateFormatsExW(
    DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
    LCID Locale,
    DWORD dwFlags);



#define EnumDateFormatsEx EnumDateFormatsExA





BOOL

IsValidLanguageGroup(
    LGRPID LanguageGroup,
    DWORD dwFlags);


// For Windows Vista and above GetNLSVersionEx is preferred

BOOL

GetNLSVersion(
    NLS_FUNCTION Function,
    LCID Locale,
    LPNLSVERSIONINFO lpVersionInformation);


BOOL

IsNLSDefinedString(
    NLS_FUNCTION Function,
    DWORD dwFlags,
    LPNLSVERSIONINFO lpVersionInformation,
    LPCWSTR lpString,
    INT cchStr);

// For Windows Vista and above IsValidLocaleName is preferred

BOOL

IsValidLocale(
    LCID Locale,
    DWORD dwFlags);


int

GetGeoInfoA(
    GEOID Location,
    GEOTYPE GeoType,
    LPSTR lpGeoData,
    int cchData,
    LANGID LangId);

int

GetGeoInfoW(
    GEOID Location,
    GEOTYPE GeoType,
    LPWSTR lpGeoData,
    int cchData,
    LANGID LangId);



#define GetGeoInfo GetGeoInfoA



BOOL

EnumSystemGeoID(
    GEOCLASS GeoClass,
    GEOID ParentGeoId,
    GEO_ENUMPROC lpGeoEnumProc);


GEOID

GetUserGeoID(
    GEOCLASS GeoClass);


BOOL

SetUserGeoID(
    GEOID GeoId);


LCID

ConvertDefaultLocale(
    LCID Locale);


LCID

GetThreadLocale(void);


BOOL

SetThreadLocale(
    LCID Locale
    );



LANGID

GetSystemDefaultUILanguage(void);


LANGID

GetUserDefaultUILanguage(void);



LANGID

GetSystemDefaultLangID(void);


LANGID

GetUserDefaultLangID(void);


LCID

GetSystemDefaultLCID(void);


LCID

GetUserDefaultLCID(void);




LANGID

SetThreadUILanguage( LANGID LangId);





LANGID

GetThreadUILanguage(void);


BOOL

GetProcessPreferredUILanguages(
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);



BOOL

SetProcessPreferredUILanguages(
    DWORD dwFlags,
    PCZZWSTR pwszLanguagesBuffer,
    PULONG pulNumLanguages
);



BOOL

GetUserPreferredUILanguages (
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);



BOOL

GetSystemPreferredUILanguages (
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);



BOOL

GetThreadPreferredUILanguages(
    DWORD dwFlags,
    PULONG pulNumLanguages,
    PZZWSTR pwszLanguagesBuffer,
    PULONG pcchLanguagesBuffer
);



BOOL

SetThreadPreferredUILanguages(
    DWORD dwFlags,
    PCZZWSTR pwszLanguagesBuffer,
    PULONG pulNumLanguages
);



BOOL

GetFileMUIInfo(
                        DWORD dwFlags,
    PCWSTR pcwszFilePath,
    PFILEMUIINFO pFileMUIInfo,
    DWORD* pcbFileMUIInfo);


BOOL

GetFileMUIPath(
    DWORD dwFlags,
    PCWSTR pcwszFilePath ,
    PWSTR pwszLanguage,
    PULONG pcchLanguage,
    PWSTR pwszFileMUIPath,
    PULONG pcchFileMUIPath,
    PULONGLONG pululEnumerator
);



BOOL

GetUILanguageInfo(
    DWORD dwFlags,
    PCZZWSTR pwmszLanguage,
    PZZWSTR pwszFallbackLanguages,
    PDWORD pcchFallbackLanguages,
    PDWORD pAttributes
);



BOOL

NotifyUILanguageChange(
    DWORD dwFlags,
    PCWSTR pcwstrNewLanguage,
    PCWSTR pcwstrPreviousLanguage,
    DWORD dwReserved,
    PDWORD pdwStatusRtrn
);



//
//  Locale Independent APIs.
//


BOOL

GetStringTypeExA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);

BOOL

GetStringTypeExW(
    LCID Locale,
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);



#define GetStringTypeEx GetStringTypeExA


//
//  NOTE: The parameters for GetStringTypeA and GetStringTypeW are
//        NOT the same.  The W version was shipped in NT 3.1.  The
//        A version was then shipped in 16-bit OLE with the wrong
//        parameters (ported from Win95).  To be compatible, we
//        must break the relationship between the A and W versions
//        of GetStringType.  There will be NO function call for the
//        generic GetStringType.
//
//        GetStringTypeEx (above) should be used instead.
//

BOOL

GetStringTypeA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);


BOOL

GetStringTypeW(
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType);



int

FoldStringA(
    DWORD dwMapFlags,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);

int

FoldStringW(
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);



#define FoldString FoldStringA




BOOL

EnumSystemLanguageGroupsA(
    LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);

BOOL

EnumSystemLanguageGroupsW(
    LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);



#define EnumSystemLanguageGroups EnumSystemLanguageGroupsA



BOOL

EnumLanguageGroupLocalesA(
    LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam);

BOOL

EnumLanguageGroupLocalesW(
    LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam);



#define EnumLanguageGroupLocales EnumLanguageGroupLocalesA



BOOL

EnumUILanguagesA(
    UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);

BOOL

EnumUILanguagesW(
    UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam);



#define EnumUILanguages EnumUILanguagesA




BOOL

EnumSystemLocalesA(
    LOCALE_ENUMPROCA lpLocaleEnumProc,
    DWORD dwFlags);

BOOL

EnumSystemLocalesW(
    LOCALE_ENUMPROCW lpLocaleEnumProc,
    DWORD dwFlags);



#define EnumSystemLocales EnumSystemLocalesA



BOOL

EnumSystemCodePagesA(
    CODEPAGE_ENUMPROCA lpCodePageEnumProc,
    DWORD dwFlags);

BOOL

EnumSystemCodePagesW(
    CODEPAGE_ENUMPROCW lpCodePageEnumProc,
    DWORD dwFlags);



#define EnumSystemCodePages EnumSystemCodePagesA




//
// Windows API Normalization Functions
//


int
 NormalizeString( NORM_FORM NormForm,
                        LPCWSTR lpSrcString,
                        int cwSrcLength,
                        LPWSTR lpDstString,
                        int cwDstLength );


BOOL
 IsNormalizedString( NORM_FORM NormForm,
                           LPCWSTR lpString,
                           int cwLength );

//
// IDN (International Domain Name) Functions
//

int
 IdnToAscii( DWORD dwFlags,
                  LPCWSTR lpUnicodeCharStr,
                  int cchUnicodeChar,
                  LPWSTR lpASCIICharStr,
                  int cchASCIIChar);


int
 IdnToNameprepUnicode( DWORD dwFlags,
                            LPCWSTR lpUnicodeCharStr,
                            int cchUnicodeChar,
                            LPWSTR lpNameprepCharStr,
                            int cchNameprepChar);


int
 IdnToUnicode( DWORD dwFlags,
                    LPCWSTR lpASCIICharStr,
                    int cchASCIIChar,
                    LPWSTR lpUnicodeCharStr,
                    int cchUnicodeChar);


BOOL
 VerifyScripts(
    DWORD dwFlags, // optional behavior flags
    LPCWSTR lpLocaleScripts, // Locale list of scripts string
    int cchLocaleScripts, // size of locale script list string
    LPCWSTR lpTestScripts, // test scripts string
    int cchTestScripts); // size of test list string


int
 GetStringScripts(
        DWORD dwFlags, // optional behavior flags
        LPCWSTR lpString, // Unicode character input string
        int cchString, // size of input string
        LPWSTR lpScripts, // Script list output string
        int cchScripts); // size of output string




//
// String based NLS APIs
//

#define LOCALE_NAME_USER_DEFAULT NULL
#define LOCALE_NAME_INVARIANT L""
#define LOCALE_NAME_SYSTEM_DEFAULT L"!x-sys-default-locale"


int

GetLocaleInfoEx(
    LPCWSTR lpLocaleName,
    LCTYPE LCType,
    LPWSTR lpLCData,
    int cchData
);


int

GetCalendarInfoEx(
    LPCWSTR lpLocaleName,
    CALID Calendar,
    LPCWSTR lpReserved,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue
);



int

GetTimeFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime
);


int

GetDateFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate,
    LPCWSTR lpCalendar
);


int

GetDurationFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    const SYSTEMTIME *lpDuration,
    ULONGLONG ullDuration,
    LPCWSTR lpFormat,
    LPWSTR lpDurationStr,
    int cchDuration
);


int

GetNumberFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const NUMBERFMTW *lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber
);


int

GetCurrencyFormatEx(
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPCWSTR lpValue,
    const CURRENCYFMTW *lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency
);


int

GetUserDefaultLocaleName(
    LPWSTR lpLocaleName,
    int cchLocaleName
);


int

GetSystemDefaultLocaleName(
    LPWSTR lpLocaleName,
    int cchLocaleName
);


BOOL

GetNLSVersionEx(
    NLS_FUNCTION function,
    LPCWSTR lpLocaleName,
    LPNLSVERSIONINFOEX lpVersionInformation
);


int

CompareStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM lParam
);


int

FindNLSStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwFindNLSStringFlags,
    LPCWSTR lpStringSource,
    int cchSource,
    LPCWSTR lpStringValue,
    int cchValue,
    LPINT pcchFound,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM lParam
);



int

LCMapStringEx(
    LPCWSTR lpLocaleName,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    LPNLSVERSIONINFO lpVersionInformation,
    LPVOID lpReserved,
    LPARAM lParam
);


int

CompareStringOrdinal(
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    BOOL bIgnoreCase
);


BOOL

IsValidLocaleName(
    LPCWSTR lpLocaleName
);

typedef BOOL (* CALINFO_ENUMPROCEXEX)(LPWSTR, CALID, LPWSTR, LPARAM);


BOOL

EnumCalendarInfoExEx(
    CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx,
    LPCWSTR lpLocaleName,
    CALID Calendar,
    LPCWSTR lpReserved,
    CALTYPE CalType,
    LPARAM lParam
);

typedef BOOL (* DATEFMT_ENUMPROCEXEX)(LPWSTR, CALID, LPARAM);


BOOL

EnumDateFormatsExEx(
    DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx,
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPARAM lParam
);

typedef BOOL (* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);


BOOL

EnumTimeFormatsEx(
    TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx,
    LPCWSTR lpLocaleName,
    DWORD dwFlags,
    LPARAM lParam
);

typedef BOOL (* LOCALE_ENUMPROCEX)(LPWSTR, DWORD, LPARAM);


BOOL

EnumSystemLocalesEx(
    LOCALE_ENUMPROCEX lpLocaleEnumProcEx,
    DWORD dwFlags,
    LPARAM lParam,
    LPVOID lpReserved
);






int

ResolveLocaleName(
    LPCWSTR lpNameToResolve,
    LPWSTR lpLocaleName,
    int cchLocaleName
);
# 161 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wincon.h" 1
/*++ BUILD Version: 0002    // Increment this if a change has global effects



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    wincon.h



Abstract:



    This module contains the public data structures, data types,

    and procedures exported by the NT console subsystem.



Created:



    26-Oct-1990



Revision History:



--*/
# 23 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wincon.h"
#define _WINCON_ 

       
# 35 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wincon.h"
typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;

//
// ControlKeyState flags
//

#define RIGHT_ALT_PRESSED 0x0001
#define LEFT_ALT_PRESSED 0x0002
#define RIGHT_CTRL_PRESSED 0x0004
#define LEFT_CTRL_PRESSED 0x0008
#define SHIFT_PRESSED 0x0010
#define NUMLOCK_ON 0x0020
#define SCROLLLOCK_ON 0x0040
#define CAPSLOCK_ON 0x0080
#define ENHANCED_KEY 0x0100
#define NLS_DBCSCHAR 0x00010000
#define NLS_ALPHANUMERIC 0x00000000
#define NLS_KATAKANA 0x00020000
#define NLS_HIRAGANA 0x00040000
#define NLS_ROMAN 0x00400000
#define NLS_IME_CONVERSION 0x00800000
#define NLS_IME_DISABLE 0x20000000

typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;

//
// ButtonState flags
//

#define FROM_LEFT_1ST_BUTTON_PRESSED 0x0001
#define RIGHTMOST_BUTTON_PRESSED 0x0002
#define FROM_LEFT_2ND_BUTTON_PRESSED 0x0004
#define FROM_LEFT_3RD_BUTTON_PRESSED 0x0008
#define FROM_LEFT_4TH_BUTTON_PRESSED 0x0010

//
// EventFlags
//

#define MOUSE_MOVED 0x0001
#define DOUBLE_CLICK 0x0002
#define MOUSE_WHEELED 0x0004

#define MOUSE_HWHEELED 0x0008


typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;

//
//  EventType flags:
//

#define KEY_EVENT 0x0001
#define MOUSE_EVENT 0x0002
#define WINDOW_BUFFER_SIZE_EVENT 0x0004
#define MENU_EVENT 0x0008
#define FOCUS_EVENT 0x0010

typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;

//
// Attributes flags:
//

#define FOREGROUND_BLUE 0x0001
#define FOREGROUND_GREEN 0x0002
#define FOREGROUND_RED 0x0004
#define FOREGROUND_INTENSITY 0x0008
#define BACKGROUND_BLUE 0x0010
#define BACKGROUND_GREEN 0x0020
#define BACKGROUND_RED 0x0040
#define BACKGROUND_INTENSITY 0x0080
#define COMMON_LVB_LEADING_BYTE 0x0100
#define COMMON_LVB_TRAILING_BYTE 0x0200
#define COMMON_LVB_GRID_HORIZONTAL 0x0400
#define COMMON_LVB_GRID_LVERTICAL 0x0800
#define COMMON_LVB_GRID_RVERTICAL 0x1000
#define COMMON_LVB_REVERSE_VIDEO 0x4000
#define COMMON_LVB_UNDERSCORE 0x8000

#define COMMON_LVB_SBCSDBCS 0x0300


typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

typedef struct _CONSOLE_CURSOR_INFO {
    DWORD dwSize;
    BOOL bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

typedef struct _CONSOLE_FONT_INFO {
    DWORD nFont;
    COORD dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;


typedef struct _CONSOLE_FONT_INFOEX {
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[32];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;


#define HISTORY_NO_DUP_FLAG 0x1

typedef struct _CONSOLE_HISTORY_INFO {
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;


typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;

//
// Selection flags
//

#define CONSOLE_NO_SELECTION 0x0000
#define CONSOLE_SELECTION_IN_PROGRESS 0x0001
#define CONSOLE_SELECTION_NOT_EMPTY 0x0002
#define CONSOLE_MOUSE_SELECTION 0x0004
#define CONSOLE_MOUSE_DOWN 0x0008


//
// typedef for ctrl-c handler routines
//

typedef
BOOL
( *PHANDLER_ROUTINE)(
    DWORD CtrlType
    );

#define CTRL_C_EVENT 0
#define CTRL_BREAK_EVENT 1
#define CTRL_CLOSE_EVENT 2
// 3 is reserved!
// 4 is reserved!
#define CTRL_LOGOFF_EVENT 5
#define CTRL_SHUTDOWN_EVENT 6

//
//  Input Mode flags:
//

#define ENABLE_PROCESSED_INPUT 0x0001
#define ENABLE_LINE_INPUT 0x0002
#define ENABLE_ECHO_INPUT 0x0004
#define ENABLE_WINDOW_INPUT 0x0008
#define ENABLE_MOUSE_INPUT 0x0010
#define ENABLE_INSERT_MODE 0x0020
#define ENABLE_QUICK_EDIT_MODE 0x0040
#define ENABLE_EXTENDED_FLAGS 0x0080
#define ENABLE_AUTO_POSITION 0x0100

//
// Output Mode flags:
//

#define ENABLE_PROCESSED_OUTPUT 0x0001
#define ENABLE_WRAP_AT_EOL_OUTPUT 0x0002

//
// direct API definitions.
//


BOOL

PeekConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );

BOOL

PeekConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );



#define PeekConsoleInput PeekConsoleInputA



BOOL

ReadConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );

BOOL

ReadConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    );



#define ReadConsoleInput ReadConsoleInputA



BOOL

WriteConsoleInputA(
    HANDLE hConsoleInput,
    const INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );

BOOL

WriteConsoleInputW(
    HANDLE hConsoleInput,
    const INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );



#define WriteConsoleInput WriteConsoleInputA



BOOL

ReadConsoleOutputA(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );

BOOL

ReadConsoleOutputW(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    );



#define ReadConsoleOutput ReadConsoleOutputA



BOOL

WriteConsoleOutputA(
    HANDLE hConsoleOutput,
    const CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );

BOOL

WriteConsoleOutputW(
    HANDLE hConsoleOutput,
    const CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    );



#define WriteConsoleOutput WriteConsoleOutputA



BOOL

ReadConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );

BOOL

ReadConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPWSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    );



#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterA



BOOL

ReadConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    LPWORD lpAttribute,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfAttrsRead
    );


BOOL

WriteConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPCSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );

BOOL

WriteConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPCWSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );



#define WriteConsoleOutputCharacter WriteConsoleOutputCharacterA



BOOL

WriteConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    const WORD *lpAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );


BOOL

FillConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    CHAR cCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );

BOOL

FillConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    WCHAR cCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    );



#define FillConsoleOutputCharacter FillConsoleOutputCharacterA



BOOL

FillConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    WORD wAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    );


BOOL

GetConsoleMode(
    HANDLE hConsoleHandle,
    LPDWORD lpMode
    );


BOOL

GetNumberOfConsoleInputEvents(
    HANDLE hConsoleInput,
    LPDWORD lpNumberOfEvents
    );

#define CONSOLE_REAL_OUTPUT_HANDLE (LongToHandle(-2))
#define CONSOLE_REAL_INPUT_HANDLE (LongToHandle(-3))


BOOL

GetConsoleScreenBufferInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );


BOOL

GetConsoleScreenBufferInfoEx(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);


BOOL

SetConsoleScreenBufferInfoEx(
    HANDLE hConsoleOutput,
    PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);


COORD

GetLargestConsoleWindowSize(
    HANDLE hConsoleOutput
    );


BOOL

GetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );




BOOL

GetCurrentConsoleFont(
    HANDLE hConsoleOutput,
    BOOL bMaximumWindow,
    PCONSOLE_FONT_INFO lpConsoleCurrentFont
    );



BOOL

GetCurrentConsoleFontEx(
    HANDLE hConsoleOutput,
    BOOL bMaximumWindow,
    PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);


BOOL

SetCurrentConsoleFontEx(
    HANDLE hConsoleOutput,
    BOOL bMaximumWindow,
    PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);



BOOL

GetConsoleHistoryInfo(
    PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);


BOOL

SetConsoleHistoryInfo(
    PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);


COORD

GetConsoleFontSize(
    HANDLE hConsoleOutput,
    DWORD nFont
    );


BOOL

GetConsoleSelectionInfo(
    PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    );




BOOL

GetNumberOfConsoleMouseButtons(
    LPDWORD lpNumberOfMouseButtons
    );


BOOL

SetConsoleMode(
    HANDLE hConsoleHandle,
    DWORD dwMode
    );


BOOL

SetConsoleActiveScreenBuffer(
    HANDLE hConsoleOutput
    );


BOOL

FlushConsoleInputBuffer(
    HANDLE hConsoleInput
    );


BOOL

SetConsoleScreenBufferSize(
    HANDLE hConsoleOutput,
    COORD dwSize
    );


BOOL

SetConsoleCursorPosition(
    HANDLE hConsoleOutput,
    COORD dwCursorPosition
    );


BOOL

SetConsoleCursorInfo(
    HANDLE hConsoleOutput,
    const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );


BOOL

ScrollConsoleScreenBufferA(
    HANDLE hConsoleOutput,
    const SMALL_RECT *lpScrollRectangle,
    const SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    const CHAR_INFO *lpFill
    );

BOOL

ScrollConsoleScreenBufferW(
    HANDLE hConsoleOutput,
    const SMALL_RECT *lpScrollRectangle,
    const SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    const CHAR_INFO *lpFill
    );



#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferA



BOOL

SetConsoleWindowInfo(
    HANDLE hConsoleOutput,
    BOOL bAbsolute,
    const SMALL_RECT *lpConsoleWindow
    );


BOOL

SetConsoleTextAttribute(
    HANDLE hConsoleOutput,
    WORD wAttributes
    );


BOOL

SetConsoleCtrlHandler(
    PHANDLER_ROUTINE HandlerRoutine,
    BOOL Add);


BOOL

GenerateConsoleCtrlEvent(
    DWORD dwCtrlEvent,
    DWORD dwProcessGroupId);


BOOL

AllocConsole(
    void);


BOOL

FreeConsole(
    void);



BOOL

AttachConsole(
    DWORD dwProcessId);

#define ATTACH_PARENT_PROCESS ((DWORD)-1)




DWORD

GetConsoleTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize
    );

DWORD

GetConsoleTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize
    );



#define GetConsoleTitle GetConsoleTitleA




DWORD

GetConsoleOriginalTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize);

DWORD

GetConsoleOriginalTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize);



#define GetConsoleOriginalTitle GetConsoleOriginalTitleA




BOOL

SetConsoleTitleA(
    LPCSTR lpConsoleTitle
    );

BOOL

SetConsoleTitleW(
    LPCWSTR lpConsoleTitle
    );



#define SetConsoleTitle SetConsoleTitleA


typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;


BOOL

ReadConsoleA(
    HANDLE hConsoleInput,
   
       LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    PCONSOLE_READCONSOLE_CONTROL pInputControl
    );

BOOL

ReadConsoleW(
    HANDLE hConsoleInput,
   
       LPVOID lpBuffer,
    DWORD nNumberOfCharsToRead,
    LPDWORD lpNumberOfCharsRead,
    PCONSOLE_READCONSOLE_CONTROL pInputControl
    );



#define ReadConsole ReadConsoleA



BOOL

WriteConsoleA(
    HANDLE hConsoleOutput,
    const void *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved);

BOOL

WriteConsoleW(
    HANDLE hConsoleOutput,
    const void *lpBuffer,
    DWORD nNumberOfCharsToWrite,
    LPDWORD lpNumberOfCharsWritten,
    LPVOID lpReserved);



#define WriteConsole WriteConsoleA


#define CONSOLE_TEXTMODE_BUFFER 1



HANDLE

CreateConsoleScreenBuffer(
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    const SECURITY_ATTRIBUTES *lpSecurityAttributes,
    DWORD dwFlags,
    LPVOID lpScreenBufferData
    );


UINT

GetConsoleCP(
    void);


BOOL

SetConsoleCP(
    UINT wCodePageID
    );


UINT

GetConsoleOutputCP(
    void);


BOOL

SetConsoleOutputCP(
    UINT wCodePageID
    );



#define CONSOLE_FULLSCREEN 1
#define CONSOLE_FULLSCREEN_HARDWARE 2


BOOL

GetConsoleDisplayMode(
    LPDWORD lpModeFlags);

#define CONSOLE_FULLSCREEN_MODE 1
#define CONSOLE_WINDOWED_MODE 2

BOOL

SetConsoleDisplayMode(
    HANDLE hConsoleOutput,
    DWORD dwFlags,
    PCOORD lpNewScreenBufferDimensions);


HWND

GetConsoleWindow(
    void
    );






DWORD

GetConsoleProcessList(
    LPDWORD lpdwProcessList,
    DWORD dwProcessCount);

//
// Aliasing apis.
//


BOOL

AddConsoleAliasA(
    LPSTR Source,
    LPSTR Target,
    LPSTR ExeName);

BOOL

AddConsoleAliasW(
    LPWSTR Source,
    LPWSTR Target,
    LPWSTR ExeName);



#define AddConsoleAlias AddConsoleAliasA



DWORD

GetConsoleAliasA(
    LPSTR Source,
    LPSTR TargetBuffer,
    DWORD TargetBufferLength,
    LPSTR ExeName);

DWORD

GetConsoleAliasW(
    LPWSTR Source,
    LPWSTR TargetBuffer,
    DWORD TargetBufferLength,
    LPWSTR ExeName);



#define GetConsoleAlias GetConsoleAliasA



DWORD

GetConsoleAliasesLengthA(
    LPSTR ExeName);

DWORD

GetConsoleAliasesLengthW(
    LPWSTR ExeName);



#define GetConsoleAliasesLength GetConsoleAliasesLengthA



DWORD

GetConsoleAliasExesLengthA(
    void);

DWORD

GetConsoleAliasExesLengthW(
    void);



#define GetConsoleAliasExesLength GetConsoleAliasExesLengthA



DWORD

GetConsoleAliasesA(
    LPSTR AliasBuffer,
    DWORD AliasBufferLength,
    LPSTR ExeName);

DWORD

GetConsoleAliasesW(
    LPWSTR AliasBuffer,
    DWORD AliasBufferLength,
    LPWSTR ExeName);



#define GetConsoleAliases GetConsoleAliasesA



DWORD

GetConsoleAliasExesA(
    LPSTR ExeNameBuffer,
    DWORD ExeNameBufferLength);

DWORD

GetConsoleAliasExesW(
    LPWSTR ExeNameBuffer,
    DWORD ExeNameBufferLength);



#define GetConsoleAliasExes GetConsoleAliasExesA
# 164 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h" 1

/******************************************************************************                                                                             *
 *
* winver.h -    Version management functions, types, and definitions          *

*                                                                             *

*               Include file for VER.DLL.  This library is                    *

*               designed to allow version stamping of Windows executable files*

*               and of special .VER files for DOS executable files.           *

*                                                                             *

*               Copyright (c) Microsoft Corporation. All rights reserved.     *

*                                                                             *

\*****************************************************************************/
# 15 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h"
#define VER_H 

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/SpecStrings.h" 1
# 18 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/verrsrc.h" 1
/******************************************************************************                                                                             *
 *
* verrsrc.h -   Version Resource definitions                                  *

*                                                                             *

*               Include file declaring version resources in rc files          *

*                                                                             *

*               Copyright (c) Microsoft Corporation. All rights reserved.     *

*                                                                             *

\*****************************************************************************/
# 11 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/verrsrc.h"
/* ----- Symbols ----- */
#define VS_FILE_INFO RT_VERSION
#define VS_VERSION_INFO 1
#define VS_USER_DEFINED 100

/* ----- VS_VERSION.dwFileFlags ----- */

#define VS_FFI_SIGNATURE 0xFEEF04BDL



#define VS_FFI_STRUCVERSION 0x00010000L
#define VS_FFI_FILEFLAGSMASK 0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG 0x00000001L
#define VS_FF_PRERELEASE 0x00000002L
#define VS_FF_PATCHED 0x00000004L
#define VS_FF_PRIVATEBUILD 0x00000008L
#define VS_FF_INFOINFERRED 0x00000010L
#define VS_FF_SPECIALBUILD 0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN 0x00000000L
#define VOS_DOS 0x00010000L
#define VOS_OS216 0x00020000L
#define VOS_OS232 0x00030000L
#define VOS_NT 0x00040000L
#define VOS_WINCE 0x00050000L

#define VOS__BASE 0x00000000L
#define VOS__WINDOWS16 0x00000001L
#define VOS__PM16 0x00000002L
#define VOS__PM32 0x00000003L
#define VOS__WINDOWS32 0x00000004L

#define VOS_DOS_WINDOWS16 0x00010001L
#define VOS_DOS_WINDOWS32 0x00010004L
#define VOS_OS216_PM16 0x00020002L
#define VOS_OS232_PM32 0x00030003L
#define VOS_NT_WINDOWS32 0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN 0x00000000L
#define VFT_APP 0x00000001L
#define VFT_DLL 0x00000002L
#define VFT_DRV 0x00000003L
#define VFT_FONT 0x00000004L
#define VFT_VXD 0x00000005L
#define VFT_STATIC_LIB 0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN 0x00000000L
#define VFT2_DRV_PRINTER 0x00000001L
#define VFT2_DRV_KEYBOARD 0x00000002L
#define VFT2_DRV_LANGUAGE 0x00000003L
#define VFT2_DRV_DISPLAY 0x00000004L
#define VFT2_DRV_MOUSE 0x00000005L
#define VFT2_DRV_NETWORK 0x00000006L
#define VFT2_DRV_SYSTEM 0x00000007L
#define VFT2_DRV_INSTALLABLE 0x00000008L
#define VFT2_DRV_SOUND 0x00000009L
#define VFT2_DRV_COMM 0x0000000AL
#define VFT2_DRV_INPUTMETHOD 0x0000000BL
#define VFT2_DRV_VERSIONED_PRINTER 0x0000000CL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER 0x00000001L
#define VFT2_FONT_VECTOR 0x00000002L
#define VFT2_FONT_TRUETYPE 0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE 0x0001

#define VFF_CURNEDEST 0x0001
#define VFF_FILEINUSE 0x0002
#define VFF_BUFFTOOSMALL 0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL 0x0001
#define VIFF_DONTDELETEOLD 0x0002

#define VIF_TEMPFILE 0x00000001L
#define VIF_MISMATCH 0x00000002L
#define VIF_SRCOLD 0x00000004L

#define VIF_DIFFLANG 0x00000008L
#define VIF_DIFFCODEPG 0x00000010L
#define VIF_DIFFTYPE 0x00000020L

#define VIF_WRITEPROT 0x00000040L
#define VIF_FILEINUSE 0x00000080L
#define VIF_OUTOFSPACE 0x00000100L
#define VIF_ACCESSVIOLATION 0x00000200L
#define VIF_SHARINGVIOLATION 0x00000400L
#define VIF_CANNOTCREATE 0x00000800L
#define VIF_CANNOTDELETE 0x00001000L
#define VIF_CANNOTRENAME 0x00002000L
#define VIF_CANNOTDELETECUR 0x00004000L
#define VIF_OUTOFMEMORY 0x00008000L

#define VIF_CANNOTREADSRC 0x00010000L
#define VIF_CANNOTREADDST 0x00020000L

#define VIF_BUFFTOOSMALL 0x00040000L
#define VIF_CANNOTLOADLZ32 0x00080000L
#define VIF_CANNOTLOADCABINET 0x00100000L







/* 

    FILE_VER_GET_... flags are for use by 

    GetFileVersionInfoSizeEx

    GetFileVersionInfoExW

*/
# 130 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/verrsrc.h"
#define FILE_VER_GET_LOCALISED 0x01
#define FILE_VER_GET_NEUTRAL 0x02
#define FILE_VER_GET_PREFETCHED 0x04

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD dwSignature; /* e.g. 0xfeef04bd */
    DWORD dwStrucVersion; /* e.g. 0x00000042 = "0.42" */
    DWORD dwFileVersionMS; /* e.g. 0x00030075 = "3.75" */
    DWORD dwFileVersionLS; /* e.g. 0x00000031 = "0.31" */
    DWORD dwProductVersionMS; /* e.g. 0x00030010 = "3.10" */
    DWORD dwProductVersionLS; /* e.g. 0x00000031 = "0.31" */
    DWORD dwFileFlagsMask; /* = 0x3F for version "0.42" */
    DWORD dwFileFlags; /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD dwFileOS; /* e.g. VOS_DOS_WINDOWS16 */
    DWORD dwFileType; /* e.g. VFT_DRIVER */
    DWORD dwFileSubtype; /* e.g. VFT2_DRV_KEYBOARD */
    DWORD dwFileDateMS; /* e.g. 0 */
    DWORD dwFileDateLS; /* e.g. 0 */
} VS_FIXEDFILEINFO;
# 19 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h" 2
# 28 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winver.h"
/* ----- Function prototypes ----- */

DWORD

VerFindFileA(
        DWORD uFlags,
        LPCSTR szFileName,
        LPCSTR szWinDir,
        LPCSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD

VerFindFileW(
        DWORD uFlags,
        LPCWSTR szFileName,
        LPCWSTR szWinDir,
        LPCWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );



#define VerFindFile VerFindFileA


DWORD

VerInstallFileA(
        DWORD uFlags,
        LPCSTR szSrcFileName,
        LPCSTR szDestFileName,
        LPCSTR szSrcDir,
        LPCSTR szDestDir,
        LPCSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD

VerInstallFileW(
        DWORD uFlags,
        LPCWSTR szSrcFileName,
        LPCWSTR szDestFileName,
        LPCWSTR szSrcDir,
        LPCWSTR szDestDir,
        LPCWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );



#define VerInstallFile VerInstallFileA


/* Returns size of version info in bytes */
DWORD

GetFileVersionInfoSizeA(
        LPCSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle /* Information for use by GetFileVersionInfo */
        );
/* Returns size of version info in bytes */
DWORD

GetFileVersionInfoSizeW(
        LPCWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle /* Information for use by GetFileVersionInfo */
        );



#define GetFileVersionInfoSize GetFileVersionInfoSizeA


/* Read version info into buffer */
BOOL

GetFileVersionInfoA(
        LPCSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle, /* Information from GetFileVersionSize */
        DWORD dwLen, /* Length of buffer for info */
        LPVOID lpData /* Buffer to place the data structure */
        );
/* Read version info into buffer */
BOOL

GetFileVersionInfoW(
        LPCWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle, /* Information from GetFileVersionSize */
        DWORD dwLen, /* Length of buffer for info */
        LPVOID lpData /* Buffer to place the data structure */
        );



#define GetFileVersionInfo GetFileVersionInfoA


DWORD GetFileVersionInfoSizeExA( DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle);
DWORD GetFileVersionInfoSizeExW( DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle);



#define GetFileVersionInfoSizeEx GetFileVersionInfoSizeExA


BOOL GetFileVersionInfoExA( DWORD dwFlags,
                                    LPCSTR lpwstrFilename,
                                    DWORD dwHandle,
                                    DWORD dwLen,
                                    LPVOID lpData);
BOOL GetFileVersionInfoExW( DWORD dwFlags,
                                    LPCWSTR lpwstrFilename,
                                    DWORD dwHandle,
                                    DWORD dwLen,
                                    LPVOID lpData);



#define GetFileVersionInfoEx GetFileVersionInfoExA



DWORD

VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD cchLang
        );
DWORD

VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD cchLang
        );



#define VerLanguageName VerLanguageNameA


BOOL

VerQueryValueA(
        LPCVOID pBlock,
        LPCSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL

VerQueryValueW(
        LPCVOID pBlock,
        LPCWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );



#define VerQueryValue VerQueryValueA
# 165 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h" 1
/*++ BUILD Version: 0001    // Increment this if a change has global effects



Copyright (c) Microsoft Corporation.  All rights reserved.



Module Name:



    Winreg.h



Abstract:



    This module contains the function prototypes and constant, type and

    structure definitions for the Windows 32-Bit Registry API.



--*/
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h"
#define _WINREG_ 
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h"
//
// RRF - Registry Routine Flags (for RegGetValue)
//

#define RRF_RT_REG_NONE 0x00000001
#define RRF_RT_REG_SZ 0x00000002
#define RRF_RT_REG_EXPAND_SZ 0x00000004
#define RRF_RT_REG_BINARY 0x00000008
#define RRF_RT_REG_DWORD 0x00000010
#define RRF_RT_REG_MULTI_SZ 0x00000020
#define RRF_RT_REG_QWORD 0x00000040

#define RRF_RT_DWORD (RRF_RT_REG_BINARY | RRF_RT_REG_DWORD)
#define RRF_RT_QWORD (RRF_RT_REG_BINARY | RRF_RT_REG_QWORD)
#define RRF_RT_ANY 0x0000ffff

#define RRF_NOEXPAND 0x10000000
#define RRF_ZEROONFAILURE 0x20000000

//
// Flags for RegLoadAppKey
//
#define REG_PROCESS_APPKEY 0x00000001

//
// Flags for RegLoadMUIString
//
#define REG_MUI_STRING_TRUNCATE 0x00000001

//
// Requested Key access mask type.
//

typedef ACCESS_MASK REGSAM;

//
// Reserved Key Handles.
//

#define HKEY_CLASSES_ROOT (( HKEY ) (ULONG_PTR)((LONG)0x80000000) )
#define HKEY_CURRENT_USER (( HKEY ) (ULONG_PTR)((LONG)0x80000001) )
#define HKEY_LOCAL_MACHINE (( HKEY ) (ULONG_PTR)((LONG)0x80000002) )
#define HKEY_USERS (( HKEY ) (ULONG_PTR)((LONG)0x80000003) )
#define HKEY_PERFORMANCE_DATA (( HKEY ) (ULONG_PTR)((LONG)0x80000004) )
#define HKEY_PERFORMANCE_TEXT (( HKEY ) (ULONG_PTR)((LONG)0x80000050) )
#define HKEY_PERFORMANCE_NLSTEXT (( HKEY ) (ULONG_PTR)((LONG)0x80000060) )

#define HKEY_CURRENT_CONFIG (( HKEY ) (ULONG_PTR)((LONG)0x80000005) )
#define HKEY_DYN_DATA (( HKEY ) (ULONG_PTR)((LONG)0x80000006) )
#define HKEY_CURRENT_USER_LOCAL_SETTINGS (( HKEY ) (ULONG_PTR)((LONG)0x80000007) )


//
// RegConnectRegistryEx supported flags
//
#define REG_SECURE_CONNECTION 1

/*NOINC*/

#define _PROVIDER_STRUCTS_DEFINED 

#define PROVIDER_KEEPS_VALUE_LENGTH 0x1
struct val_context {
    int valuelen; // the total length of this value
    LPVOID value_context; // provider's context
    LPVOID val_buff_ptr; // where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalueA { // Provider supplied value/context.
    LPSTR pv_valuename; // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA, *PPVALUEA;
typedef struct pvalueW { // Provider supplied value/context.
    LPWSTR pv_valuename; // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW, *PPVALUEW;




typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;


typedef
DWORD
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD *total_outlen, DWORD input_blen);

typedef QUERYHANDLER *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags; // capability flags (none defined yet).
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info *PPROVIDER;

typedef struct value_entA {
    LPSTR ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA, *PVALENTA;
typedef struct value_entW {
    LPWSTR ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW, *PVALENTW;




typedef VALENTA VALENT;
typedef PVALENTA PVALENT;



/*INC*/



//
// Default values for parameters that do not exist in the Win 3.1
// compatible APIs.
//

#define WIN31_CLASS NULL

//
// API Prototypes.
//

typedef LONG LSTATUS;


LSTATUS

RegCloseKey (
    HKEY hKey
    );


LSTATUS

RegOverridePredefKey (
    HKEY hKey,
    HKEY hNewHKey
    );


LSTATUS

RegOpenUserClassesRoot(
    HANDLE hToken,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );


LSTATUS

RegOpenCurrentUser(
    REGSAM samDesired,
    PHKEY phkResult
    );


LSTATUS

RegDisablePredefinedCache(
    void
    );


LSTATUS

RegDisablePredefinedCacheEx(
    void
    );


LSTATUS

RegConnectRegistryA (
    LPCSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );

LSTATUS

RegConnectRegistryW (
    LPCWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );



#define RegConnectRegistry RegConnectRegistryA



LSTATUS

RegConnectRegistryExA (
    LPCSTR lpMachineName,
    HKEY hKey,
    ULONG Flags,
    PHKEY phkResult
    );

LSTATUS

RegConnectRegistryExW (
    LPCWSTR lpMachineName,
    HKEY hKey,
    ULONG Flags,
    PHKEY phkResult
    );



#define RegConnectRegistryEx RegConnectRegistryExA



LSTATUS

RegCreateKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

LSTATUS

RegCreateKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );



#define RegCreateKey RegCreateKeyA



LSTATUS

RegCreateKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LSTATUS

RegCreateKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );



#define RegCreateKeyEx RegCreateKeyExA



LSTATUS

RegCreateKeyTransactedA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );

LSTATUS

RegCreateKeyTransactedW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );



#define RegCreateKeyTransacted RegCreateKeyTransactedA



LSTATUS

RegDeleteKeyA (
    HKEY hKey,
    LPCSTR lpSubKey
    );

LSTATUS

RegDeleteKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );



#define RegDeleteKey RegDeleteKeyA



LSTATUS

RegDeleteKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved
    );

LSTATUS

RegDeleteKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved
    );



#define RegDeleteKeyEx RegDeleteKeyExA



LSTATUS

RegDeleteKeyTransactedA (
    HKEY hKey,
    LPCSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved,
    HANDLE hTransaction,
    PVOID pExtendedParameter
    );

LSTATUS

RegDeleteKeyTransactedW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    REGSAM samDesired,
    DWORD Reserved,
    HANDLE hTransaction,
    PVOID pExtendedParameter
    );



#define RegDeleteKeyTransacted RegDeleteKeyTransactedA



LONG

RegDisableReflectionKey (
    HKEY hBase
    );


LONG

RegEnableReflectionKey (
    HKEY hBase
    );


LONG

RegQueryReflectionKey (
    HKEY hBase,
    BOOL *bIsReflectionDisabled
    );


LSTATUS

RegDeleteValueA (
    HKEY hKey,
    LPCSTR lpValueName
    );

LSTATUS

RegDeleteValueW (
    HKEY hKey,
    LPCWSTR lpValueName
    );



#define RegDeleteValue RegDeleteValueA



LSTATUS

RegEnumKeyA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cchName
    );

LSTATUS

RegEnumKeyW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cchName
    );



#define RegEnumKey RegEnumKeyA



LSTATUS

RegEnumKeyExA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcchName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcchClass,
    PFILETIME lpftLastWriteTime
    );

LSTATUS

RegEnumKeyExW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcchName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcchClass,
    PFILETIME lpftLastWriteTime
    );



#define RegEnumKeyEx RegEnumKeyExA



LSTATUS

RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LSTATUS

RegEnumValueW (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );



#define RegEnumValue RegEnumValueA



LSTATUS

RegFlushKey (
    HKEY hKey
    );


LSTATUS

RegGetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    );


LSTATUS

RegLoadKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpFile
    );

LSTATUS

RegLoadKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpFile
    );



#define RegLoadKey RegLoadKeyA



LSTATUS

RegNotifyChangeKeyValue (
    HKEY hKey,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    HANDLE hEvent,
    BOOL fAsynchronous
    );


LSTATUS

RegOpenKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    );

LSTATUS

RegOpenKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );



#define RegOpenKey RegOpenKeyA



LSTATUS

RegOpenKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

LSTATUS

RegOpenKeyExW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );



#define RegOpenKeyEx RegOpenKeyExA



LSTATUS

RegOpenKeyTransactedA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );

LSTATUS

RegOpenKeyTransactedW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult,
    HANDLE hTransaction,
    PVOID pExtendedParemeter
    );



#define RegOpenKeyTransacted RegOpenKeyTransactedA



LSTATUS

RegQueryInfoKeyA (
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcchClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LSTATUS

RegQueryInfoKeyW (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcchClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );



#define RegQueryInfoKey RegQueryInfoKeyA



LSTATUS

RegQueryValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpData,
    PLONG lpcbData
    );

LSTATUS

RegQueryValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpData,
    PLONG lpcbData
    );



#define RegQueryValue RegQueryValueA





LSTATUS

RegQueryMultipleValuesA (
    HKEY hKey,
    PVALENTA val_list,
    DWORD num_vals,
    LPSTR lpValueBuf,
    LPDWORD ldwTotsize
    );

LSTATUS

RegQueryMultipleValuesW (
    HKEY hKey,
    PVALENTW val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD ldwTotsize
    );



#define RegQueryMultipleValues RegQueryMultipleValuesA




LSTATUS

RegQueryValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LSTATUS

RegQueryValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );



#define RegQueryValueEx RegQueryValueExA



LSTATUS

RegReplaceKeyA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpNewFile,
    LPCSTR lpOldFile
    );

LSTATUS

RegReplaceKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpNewFile,
    LPCWSTR lpOldFile
    );



#define RegReplaceKey RegReplaceKeyA



LSTATUS

RegRestoreKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    DWORD dwFlags
    );

LSTATUS

RegRestoreKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    DWORD dwFlags
    );



#define RegRestoreKey RegRestoreKeyA





LSTATUS

RegRenameKey(
    HKEY hKey,
    LPCWSTR lpSubKeyName,
    LPCWSTR lpNewKeyName
    );




LSTATUS

RegSaveKeyA (
    HKEY hKey,
    LPCSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

LSTATUS

RegSaveKeyW (
    HKEY hKey,
    LPCWSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );



#define RegSaveKey RegSaveKeyA



LSTATUS

RegSetKeySecurity (
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


LSTATUS

RegSetValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    );

LSTATUS

RegSetValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );



#define RegSetValue RegSetValueA




LSTATUS

RegSetValueExA (
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    const BYTE* lpData,
    DWORD cbData
    );

LSTATUS

RegSetValueExW (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    const BYTE* lpData,
    DWORD cbData
    );



#define RegSetValueEx RegSetValueExA



LSTATUS

RegUnLoadKeyA (
    HKEY hKey,
    LPCSTR lpSubKey
    );

LSTATUS

RegUnLoadKeyW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );



#define RegUnLoadKey RegUnLoadKeyA


//
// Utils wrappers
//



LSTATUS

RegDeleteKeyValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpValueName
    );

LSTATUS

RegDeleteKeyValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName
    );



#define RegDeleteKeyValue RegDeleteKeyValueA



LSTATUS

RegSetKeyValueA (
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpValueName,
    DWORD dwType,
    LPCVOID lpData,
    DWORD cbData
    );

LSTATUS

RegSetKeyValueW (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName,
    DWORD dwType,
    LPCVOID lpData,
    DWORD cbData
    );



#define RegSetKeyValue RegSetKeyValueA



LSTATUS

RegDeleteTreeA (
    HKEY hKey,
    LPCSTR lpSubKey
    );

LSTATUS

RegDeleteTreeW (
    HKEY hKey,
    LPCWSTR lpSubKey
    );



#define RegDeleteTree RegDeleteTreeA



LSTATUS

RegCopyTreeA (
    HKEY hKeySrc,
    LPCSTR lpSubKey,
    HKEY hKeyDest
    );

LSTATUS

RegCopyTreeW (
    HKEY hKeySrc,
    LPCWSTR lpSubKey,
    HKEY hKeyDest
    );



#define RegCopyTree RegCopyTreeA



LSTATUS

RegGetValueA (
    HKEY hkey,
    LPCSTR lpSubKey,
    LPCSTR lpValue,
    DWORD dwFlags,
    LPDWORD pdwType,
    PVOID pvData,
    LPDWORD pcbData
    );

LSTATUS

RegGetValueW (
    HKEY hkey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValue,
    DWORD dwFlags,
    LPDWORD pdwType,
    PVOID pvData,
    LPDWORD pcbData
    );



#define RegGetValue RegGetValueA



LSTATUS

RegLoadMUIStringA (
                    HKEY hKey,
                    LPCSTR pszValue,
                    LPSTR pszOutBuf,
                    DWORD cbOutBuf,
                    LPDWORD pcbData,
                    DWORD Flags,
                    LPCSTR pszDirectory
                    );

LSTATUS

RegLoadMUIStringW (
                    HKEY hKey,
                    LPCWSTR pszValue,
                    LPWSTR pszOutBuf,
                    DWORD cbOutBuf,
                    LPDWORD pcbData,
                    DWORD Flags,
                    LPCWSTR pszDirectory
                    );



#define RegLoadMUIString RegLoadMUIStringA




LSTATUS

RegLoadAppKeyA (
        LPCSTR lpFile,
        PHKEY phkResult,
        REGSAM samDesired,
        DWORD dwOptions,
        DWORD Reserved
    );

LSTATUS

RegLoadAppKeyW (
        LPCWSTR lpFile,
        PHKEY phkResult,
        REGSAM samDesired,
        DWORD dwOptions,
        DWORD Reserved
    );



#define RegLoadAppKey RegLoadAppKeyA




//
// Remoteable System Shutdown APIs
//



BOOL

InitiateSystemShutdownA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );


BOOL

InitiateSystemShutdownW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown
    );



#define InitiateSystemShutdown InitiateSystemShutdownA




BOOL

AbortSystemShutdownA(
    LPSTR lpMachineName
    );

BOOL

AbortSystemShutdownW(
    LPWSTR lpMachineName
    );



#define AbortSystemShutdown AbortSystemShutdownA


//
// defines for InitiateSystemShutdownEx reason codes
//

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h" 1
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:        reason.h
//
//  Contents:    Shutdown reason code values.
//
//  History:     8-00        Created         Hughleat
//
//--------------------------------------------------------------------

#define SENTINEL_Reason 
       

// Reason flags

// Flags used by the various UIs.
#define SHTDN_REASON_FLAG_COMMENT_REQUIRED 0x01000000
#define SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED 0x02000000
#define SHTDN_REASON_FLAG_CLEAN_UI 0x04000000
#define SHTDN_REASON_FLAG_DIRTY_UI 0x08000000

// Flags that end up in the event log code.
#define SHTDN_REASON_FLAG_USER_DEFINED 0x40000000
#define SHTDN_REASON_FLAG_PLANNED 0x80000000

// Microsoft major reasons.
#define SHTDN_REASON_MAJOR_OTHER 0x00000000
#define SHTDN_REASON_MAJOR_NONE 0x00000000
#define SHTDN_REASON_MAJOR_HARDWARE 0x00010000
#define SHTDN_REASON_MAJOR_OPERATINGSYSTEM 0x00020000
#define SHTDN_REASON_MAJOR_SOFTWARE 0x00030000
#define SHTDN_REASON_MAJOR_APPLICATION 0x00040000
#define SHTDN_REASON_MAJOR_SYSTEM 0x00050000
#define SHTDN_REASON_MAJOR_POWER 0x00060000
#define SHTDN_REASON_MAJOR_LEGACY_API 0x00070000

// Microsoft minor reasons.
#define SHTDN_REASON_MINOR_OTHER 0x00000000
#define SHTDN_REASON_MINOR_NONE 0x000000ff
#define SHTDN_REASON_MINOR_MAINTENANCE 0x00000001
#define SHTDN_REASON_MINOR_INSTALLATION 0x00000002
#define SHTDN_REASON_MINOR_UPGRADE 0x00000003
#define SHTDN_REASON_MINOR_RECONFIG 0x00000004
#define SHTDN_REASON_MINOR_HUNG 0x00000005
#define SHTDN_REASON_MINOR_UNSTABLE 0x00000006
#define SHTDN_REASON_MINOR_DISK 0x00000007
#define SHTDN_REASON_MINOR_PROCESSOR 0x00000008
#define SHTDN_REASON_MINOR_NETWORKCARD 0x00000009
#define SHTDN_REASON_MINOR_POWER_SUPPLY 0x0000000a
#define SHTDN_REASON_MINOR_CORDUNPLUGGED 0x0000000b
#define SHTDN_REASON_MINOR_ENVIRONMENT 0x0000000c
#define SHTDN_REASON_MINOR_HARDWARE_DRIVER 0x0000000d
#define SHTDN_REASON_MINOR_OTHERDRIVER 0x0000000e
#define SHTDN_REASON_MINOR_BLUESCREEN 0x0000000F
#define SHTDN_REASON_MINOR_SERVICEPACK 0x00000010
#define SHTDN_REASON_MINOR_HOTFIX 0x00000011
#define SHTDN_REASON_MINOR_SECURITYFIX 0x00000012
#define SHTDN_REASON_MINOR_SECURITY 0x00000013
#define SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY 0x00000014
#define SHTDN_REASON_MINOR_WMI 0x00000015
#define SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL 0x00000016
#define SHTDN_REASON_MINOR_HOTFIX_UNINSTALL 0x00000017
#define SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL 0x00000018
#define SHTDN_REASON_MINOR_MMC 0x00000019
#define SHTDN_REASON_MINOR_SYSTEMRESTORE 0x0000001a
#define SHTDN_REASON_MINOR_TERMSRV 0x00000020
#define SHTDN_REASON_MINOR_DC_PROMOTION 0x00000021
#define SHTDN_REASON_MINOR_DC_DEMOTION 0x00000022

#define SHTDN_REASON_UNKNOWN SHTDN_REASON_MINOR_NONE
#define SHTDN_REASON_LEGACY_API (SHTDN_REASON_MAJOR_LEGACY_API | SHTDN_REASON_FLAG_PLANNED)

// This mask cuts out UI flags.
#define SHTDN_REASON_VALID_BIT_MASK 0xc0ffffff

// Convenience flags.
#define PCLEANUI (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_CLEAN_UI)
#define UCLEANUI (SHTDN_REASON_FLAG_CLEAN_UI)
#define PDIRTYUI (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_DIRTY_UI)
#define UDIRTYUI (SHTDN_REASON_FLAG_DIRTY_UI)

/*

 * Maximum character lengths for reason name, description, problem id, and

 * comment respectively.

 */
# 89 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
#define MAX_REASON_NAME_LEN 64
#define MAX_REASON_DESC_LEN 256
#define MAX_REASON_BUGID_LEN 32
#define MAX_REASON_COMMENT_LEN 512
#define SHUTDOWN_TYPE_LEN 32

/*

 *	S.E.T. policy value

 *

 */
# 99 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
#define POLICY_SHOWREASONUI_NEVER 0
#define POLICY_SHOWREASONUI_ALWAYS 1
#define POLICY_SHOWREASONUI_WORKSTATIONONLY 2
#define POLICY_SHOWREASONUI_SERVERONLY 3


/*

 * Snapshot policy values

 */
# 108 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
#define SNAPSHOT_POLICY_NEVER 0
#define SNAPSHOT_POLICY_ALWAYS 1
#define SNAPSHOT_POLICY_UNPLANNED 2

/*

 * Maximue user defined reasons

 */
# 115 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/reason.h"
#define MAX_NUM_REASONS 256
# 1223 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winreg.h" 2
//
// Then for Historical reasons support some old symbols, internal only

#define REASON_SWINSTALL (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_INSTALLATION)
#define REASON_HWINSTALL (SHTDN_REASON_MAJOR_HARDWARE|SHTDN_REASON_MINOR_INSTALLATION)
#define REASON_SERVICEHANG (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_HUNG)
#define REASON_UNSTABLE (SHTDN_REASON_MAJOR_SYSTEM|SHTDN_REASON_MINOR_UNSTABLE)
#define REASON_SWHWRECONF (SHTDN_REASON_MAJOR_SOFTWARE|SHTDN_REASON_MINOR_RECONFIG)
#define REASON_OTHER (SHTDN_REASON_MAJOR_OTHER|SHTDN_REASON_MINOR_OTHER)
#define REASON_UNKNOWN SHTDN_REASON_UNKNOWN
#define REASON_LEGACY_API SHTDN_REASON_LEGACY_API
#define REASON_PLANNED_FLAG SHTDN_REASON_FLAG_PLANNED

//
// MAX Shutdown TimeOut == 10 Years in seconds
//
#define MAX_SHUTDOWN_TIMEOUT (10*365*24*60*60)





BOOL

InitiateSystemShutdownExA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown,
    DWORD dwReason
    );




BOOL

InitiateSystemShutdownExW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwTimeout,
    BOOL bForceAppsClosed,
    BOOL bRebootAfterShutdown,
    DWORD dwReason
    );



#define InitiateSystemShutdownEx InitiateSystemShutdownExA


//
// Shutdown flags
//

#define SHUTDOWN_FORCE_OTHERS 0x00000001
#define SHUTDOWN_FORCE_SELF 0x00000002
#define SHUTDOWN_RESTART 0x00000004
#define SHUTDOWN_POWEROFF 0x00000008
#define SHUTDOWN_NOREBOOT 0x00000010
#define SHUTDOWN_GRACE_OVERRIDE 0x00000020
#define SHUTDOWN_INSTALL_UPDATES 0x00000040
#define SHUTDOWN_RESTARTAPPS 0x00000080
#define SHUTDOWN_SKIP_SVC_PRESHUTDOWN 0x00000100



DWORD

InitiateShutdownA(
    LPSTR lpMachineName,
    LPSTR lpMessage,
    DWORD dwGracePeriod,
    DWORD dwShutdownFlags,
    DWORD dwReason
    );

DWORD

InitiateShutdownW(
    LPWSTR lpMachineName,
    LPWSTR lpMessage,
    DWORD dwGracePeriod,
    DWORD dwShutdownFlags,
    DWORD dwReason
    );



#define InitiateShutdown InitiateShutdownA



LSTATUS

RegSaveKeyExA (
    HKEY hKey,
    LPCSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD Flags
    );

LSTATUS

RegSaveKeyExW (
    HKEY hKey,
    LPCWSTR lpFile,
    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD Flags
    );



#define RegSaveKeyEx RegSaveKeyExA
# 168 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h" 1
/*++



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    winnetwk.h



Abstract:



    Standard WINNET Header File for WIN32



Environment:



    User Mode -Win32



Notes:



    optional-notes



--*/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h"
#define _WINNETWK_ 


       






//
// Network types
//

# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wnnc.h" 1
/*++



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    wnnc.h



Abstract:



    This header provides the Windows Networking WNNC_NET definitions to winnetwk.h

    and the IFS Kit.



Environment:



    User Mode / Kernel Mode



Notes:



--*/
# 22 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/wnnc.h"
// begin_ntifs

#define _WNNC_ 

//
// Network types
//

#define WNNC_NET_MSNET 0x00010000
#define WNNC_NET_SMB 0x00020000
#define WNNC_NET_NETWARE 0x00030000
#define WNNC_NET_VINES 0x00040000
#define WNNC_NET_10NET 0x00050000
#define WNNC_NET_LOCUS 0x00060000
#define WNNC_NET_SUN_PC_NFS 0x00070000
#define WNNC_NET_LANSTEP 0x00080000
#define WNNC_NET_9TILES 0x00090000
#define WNNC_NET_LANTASTIC 0x000A0000
#define WNNC_NET_AS400 0x000B0000
#define WNNC_NET_FTP_NFS 0x000C0000
#define WNNC_NET_PATHWORKS 0x000D0000
#define WNNC_NET_LIFENET 0x000E0000
#define WNNC_NET_POWERLAN 0x000F0000
#define WNNC_NET_BWNFS 0x00100000
#define WNNC_NET_COGENT 0x00110000
#define WNNC_NET_FARALLON 0x00120000
#define WNNC_NET_APPLETALK 0x00130000
#define WNNC_NET_INTERGRAPH 0x00140000
#define WNNC_NET_SYMFONET 0x00150000
#define WNNC_NET_CLEARCASE 0x00160000
#define WNNC_NET_FRONTIER 0x00170000
#define WNNC_NET_BMC 0x00180000
#define WNNC_NET_DCE 0x00190000
#define WNNC_NET_AVID 0x001A0000
#define WNNC_NET_DOCUSPACE 0x001B0000
#define WNNC_NET_MANGOSOFT 0x001C0000
#define WNNC_NET_SERNET 0x001D0000
#define WNNC_NET_RIVERFRONT1 0X001E0000
#define WNNC_NET_RIVERFRONT2 0x001F0000
#define WNNC_NET_DECORB 0x00200000
#define WNNC_NET_PROTSTOR 0x00210000
#define WNNC_NET_FJ_REDIR 0x00220000
#define WNNC_NET_DISTINCT 0x00230000
#define WNNC_NET_TWINS 0x00240000
#define WNNC_NET_RDR2SAMPLE 0x00250000
#define WNNC_NET_CSC 0x00260000
#define WNNC_NET_3IN1 0x00270000
#define WNNC_NET_EXTENDNET 0x00290000
#define WNNC_NET_STAC 0x002A0000
#define WNNC_NET_FOXBAT 0x002B0000
#define WNNC_NET_YAHOO 0x002C0000
#define WNNC_NET_EXIFS 0x002D0000
#define WNNC_NET_DAV 0x002E0000
#define WNNC_NET_KNOWARE 0x002F0000
#define WNNC_NET_OBJECT_DIRE 0x00300000
#define WNNC_NET_MASFAX 0x00310000
#define WNNC_NET_HOB_NFS 0x00320000
#define WNNC_NET_SHIVA 0x00330000
#define WNNC_NET_IBMAL 0x00340000
#define WNNC_NET_LOCK 0x00350000
#define WNNC_NET_TERMSRV 0x00360000
#define WNNC_NET_SRT 0x00370000
#define WNNC_NET_QUINCY 0x00380000
#define WNNC_NET_OPENAFS 0x00390000
#define WNNC_NET_AVID1 0X003A0000
#define WNNC_NET_DFS 0x003B0000
#define WNNC_NET_KWNP 0x003C0000
#define WNNC_NET_ZENWORKS 0x003D0000
#define WNNC_NET_DRIVEONWEB 0x003E0000
#define WNNC_NET_VMWARE 0x003F0000
#define WNNC_NET_RSFX 0x00400000
#define WNNC_NET_MFILES 0x00410000
#define WNNC_NET_MS_NFS 0x00420000
#define WNNC_NET_GOOGLE 0x00430000

#define WNNC_CRED_MANAGER 0xFFFF0000

//
// Network type aliases
//

#define WNNC_NET_LANMAN WNNC_NET_SMB



// end_ntifs
# 39 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h" 2

//
//  Network Resources.
//

#define RESOURCE_CONNECTED 0x00000001
#define RESOURCE_GLOBALNET 0x00000002
#define RESOURCE_REMEMBERED 0x00000003

#define RESOURCE_RECENT 0x00000004
#define RESOURCE_CONTEXT 0x00000005


#define RESOURCETYPE_ANY 0x00000000
#define RESOURCETYPE_DISK 0x00000001
#define RESOURCETYPE_PRINT 0x00000002

#define RESOURCETYPE_RESERVED 0x00000008

#define RESOURCETYPE_UNKNOWN 0xFFFFFFFF

#define RESOURCEUSAGE_CONNECTABLE 0x00000001
#define RESOURCEUSAGE_CONTAINER 0x00000002

#define RESOURCEUSAGE_NOLOCALDEVICE 0x00000004
#define RESOURCEUSAGE_SIBLING 0x00000008
#define RESOURCEUSAGE_ATTACHED 0x00000010
#define RESOURCEUSAGE_ALL (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_ATTACHED)

#define RESOURCEUSAGE_RESERVED 0x80000000

#define RESOURCEDISPLAYTYPE_GENERIC 0x00000000
#define RESOURCEDISPLAYTYPE_DOMAIN 0x00000001
#define RESOURCEDISPLAYTYPE_SERVER 0x00000002
#define RESOURCEDISPLAYTYPE_SHARE 0x00000003
#define RESOURCEDISPLAYTYPE_FILE 0x00000004
#define RESOURCEDISPLAYTYPE_GROUP 0x00000005

#define RESOURCEDISPLAYTYPE_NETWORK 0x00000006
#define RESOURCEDISPLAYTYPE_ROOT 0x00000007
#define RESOURCEDISPLAYTYPE_SHAREADMIN 0x00000008
#define RESOURCEDISPLAYTYPE_DIRECTORY 0x00000009

#define RESOURCEDISPLAYTYPE_TREE 0x0000000A

#define RESOURCEDISPLAYTYPE_NDSCONTAINER 0x0000000B


typedef struct _NETRESOURCEA {
    DWORD dwScope;
    DWORD dwType;
    DWORD dwDisplayType;
    DWORD dwUsage;
    LPSTR lpLocalName;
    LPSTR lpRemoteName;
    LPSTR lpComment ;
    LPSTR lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct _NETRESOURCEW {
    DWORD dwScope;
    DWORD dwType;
    DWORD dwDisplayType;
    DWORD dwUsage;
    LPWSTR lpLocalName;
    LPWSTR lpRemoteName;
    LPWSTR lpComment ;
    LPWSTR lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;




typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;



//
//  Network Connections.
//

#define NETPROPERTY_PERSISTENT 1

#define CONNECT_UPDATE_PROFILE 0x00000001
#define CONNECT_UPDATE_RECENT 0x00000002
#define CONNECT_TEMPORARY 0x00000004
#define CONNECT_INTERACTIVE 0x00000008
#define CONNECT_PROMPT 0x00000010
#define CONNECT_NEED_DRIVE 0x00000020

#define CONNECT_REFCOUNT 0x00000040
#define CONNECT_REDIRECT 0x00000080
#define CONNECT_LOCALDRIVE 0x00000100
#define CONNECT_CURRENT_MEDIA 0x00000200
#define CONNECT_DEFERRED 0x00000400
#define CONNECT_RESERVED 0xFF000000


#define CONNECT_COMMANDLINE 0x00000800
#define CONNECT_CMD_SAVECRED 0x00001000


#define CONNECT_CRED_RESET 0x00002000



DWORD
WNetAddConnectionA(
    LPCSTR lpRemoteName,
    LPCSTR lpPassword,
    LPCSTR lpLocalName
    );

DWORD
WNetAddConnectionW(
    LPCWSTR lpRemoteName,
    LPCWSTR lpPassword,
    LPCWSTR lpLocalName
    );



#define WNetAddConnection WNetAddConnectionA



DWORD
WNetAddConnection2A(
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserName,
    DWORD dwFlags
    );

DWORD
WNetAddConnection2W(
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserName,
    DWORD dwFlags
    );



#define WNetAddConnection2 WNetAddConnection2A



DWORD
WNetAddConnection3A(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserName,
    DWORD dwFlags
    );

DWORD
WNetAddConnection3W(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserName,
    DWORD dwFlags
    );



#define WNetAddConnection3 WNetAddConnection3A



DWORD
WNetCancelConnectionA(
    LPCSTR lpName,
    BOOL fForce
    );

DWORD
WNetCancelConnectionW(
    LPCWSTR lpName,
    BOOL fForce
    );



#define WNetCancelConnection WNetCancelConnectionA



DWORD
WNetCancelConnection2A(
    LPCSTR lpName,
    DWORD dwFlags,
    BOOL fForce
    );

DWORD
WNetCancelConnection2W(
    LPCWSTR lpName,
    DWORD dwFlags,
    BOOL fForce
    );



#define WNetCancelConnection2 WNetCancelConnection2A



DWORD
WNetGetConnectionA(
    LPCSTR lpLocalName,
    LPSTR lpRemoteName,
    LPDWORD lpnLength
    );

DWORD
WNetGetConnectionW(
    LPCWSTR lpLocalName,
    LPWSTR lpRemoteName,
    LPDWORD lpnLength
    );



#define WNetGetConnection WNetGetConnectionA





DWORD
WNetRestoreSingleConnectionW(
    HWND hwndParent,
    LPCWSTR lpDevice,
    BOOL fUseUI
    );
# 290 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h"

DWORD
WNetUseConnectionA(
    HWND hwndOwner,
    LPNETRESOURCEA lpNetResource,
    LPCSTR lpPassword,
    LPCSTR lpUserId,
    DWORD dwFlags,
    LPSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult
    );

DWORD
WNetUseConnectionW(
    HWND hwndOwner,
    LPNETRESOURCEW lpNetResource,
    LPCWSTR lpPassword,
    LPCWSTR lpUserId,
    DWORD dwFlags,
    LPWSTR lpAccessName,
    LPDWORD lpBufferSize,
    LPDWORD lpResult
    );



#define WNetUseConnection WNetUseConnectionA




//
//  Network Connection Dialogs.
//

DWORD
WNetConnectionDialog(
    HWND hwnd,
    DWORD dwType
    );


DWORD
WNetDisconnectDialog(
    HWND hwnd,
    DWORD dwType
    );


typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPNETRESOURCEA lpConnRes;/* Requested Resource info    */
    DWORD dwFlags; /* flags (see below) */
    DWORD dwDevNum; /* number of devices connected to */
} CONNECTDLGSTRUCTA, *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPNETRESOURCEW lpConnRes;/* Requested Resource info    */
    DWORD dwFlags; /* flags (see below) */
    DWORD dwDevNum; /* number of devices connected to */
} CONNECTDLGSTRUCTW, *LPCONNECTDLGSTRUCTW;




typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;


#define CONNDLG_RO_PATH 0x00000001
#define CONNDLG_CONN_POINT 0x00000002
#define CONNDLG_USE_MRU 0x00000004
#define CONNDLG_HIDE_BOX 0x00000008

/*

 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,

 *        then the persistence is set to whatever the user chose during

 *        a previous connection

 */
# 372 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winnetwk.h"
#define CONNDLG_PERSIST 0x00000010
#define CONNDLG_NOT_PERSIST 0x00000020


DWORD
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );

DWORD
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );



#define WNetConnectionDialog1 WNetConnectionDialog1A


typedef struct _DISCDLGSTRUCTA{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPSTR lpLocalName; /* local device name */
    LPSTR lpRemoteName; /* network resource name */
    DWORD dwFlags; /* flags */
} DISCDLGSTRUCTA, *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD cbStructure; /* size of this structure in bytes */
    HWND hwndOwner; /* owner window for the dialog */
    LPWSTR lpLocalName; /* local device name */
    LPWSTR lpRemoteName; /* network resource name */
    DWORD dwFlags; /* flags */
} DISCDLGSTRUCTW, *LPDISCDLGSTRUCTW;




typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;


#define DISC_UPDATE_PROFILE 0x00000001
#define DISC_NO_FORCE 0x00000040


DWORD
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpConnDlgStruct
    );

DWORD
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpConnDlgStruct
    );



#define WNetDisconnectDialog1 WNetDisconnectDialog1A



//
//  Network Browsing.
//


DWORD
WNetOpenEnumA(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEA lpNetResource,
    LPHANDLE lphEnum
    );

DWORD
WNetOpenEnumW(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCEW lpNetResource,
    LPHANDLE lphEnum
    );



#define WNetOpenEnum WNetOpenEnumA



DWORD
WNetEnumResourceA(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );

DWORD
WNetEnumResourceW(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );



#define WNetEnumResource WNetEnumResourceA



DWORD
WNetCloseEnum(
    HANDLE hEnum
    );



DWORD
WNetGetResourceParentA(
    LPNETRESOURCEA lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer
    );

DWORD
WNetGetResourceParentW(
    LPNETRESOURCEW lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer
    );



#define WNetGetResourceParent WNetGetResourceParentA



DWORD
WNetGetResourceInformationA(
    LPNETRESOURCEA lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPSTR *lplpSystem
    );

DWORD
WNetGetResourceInformationW(
    LPNETRESOURCEW lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPWSTR *lplpSystem
    );



#define WNetGetResourceInformation WNetGetResourceInformationA



//
//  Universal Naming.
//

#define UNIVERSAL_NAME_INFO_LEVEL 0x00000001
#define REMOTE_NAME_INFO_LEVEL 0x00000002

typedef struct _UNIVERSAL_NAME_INFOA {
    LPSTR lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct _UNIVERSAL_NAME_INFOW {
    LPWSTR lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;




typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;


typedef struct _REMOTE_NAME_INFOA {
    LPSTR lpUniversalName;
    LPSTR lpConnectionName;
    LPSTR lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct _REMOTE_NAME_INFOW {
    LPWSTR lpUniversalName;
    LPWSTR lpConnectionName;
    LPWSTR lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;




typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;



DWORD
WNetGetUniversalNameA(
    LPCSTR lpLocalPath,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );

DWORD
WNetGetUniversalNameW(
    LPCWSTR lpLocalPath,
    DWORD dwInfoLevel,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    );



#define WNetGetUniversalName WNetGetUniversalNameA


//
//  Authentication and Logon/Logoff.
//

DWORD
WNetGetUserA(
    LPCSTR lpName,
    LPSTR lpUserName,
    LPDWORD lpnLength
    );
//
//  Authentication and Logon/Logoff.
//

DWORD
WNetGetUserW(
    LPCWSTR lpName,
    LPWSTR lpUserName,
    LPDWORD lpnLength
    );



#define WNetGetUser WNetGetUserA




//
// Other.
//


#define WNFMT_MULTILINE 0x01
#define WNFMT_ABBREVIATED 0x02
#define WNFMT_INENUM 0x10
#define WNFMT_CONNECTION 0x20





DWORD
WNetGetProviderNameA(
    DWORD dwNetType,
    LPSTR lpProviderName,
    LPDWORD lpBufferSize
    );

DWORD
WNetGetProviderNameW(
    DWORD dwNetType,
    LPWSTR lpProviderName,
    LPDWORD lpBufferSize
    );



#define WNetGetProviderName WNetGetProviderNameA


typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    ULONG_PTR dwHandle;
    WORD wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT, *LPNETINFOSTRUCT;

#define NETINFO_DLL16 0x00000001
#define NETINFO_DISKRED 0x00000004
#define NETINFO_PRINTERRED 0x00000008


DWORD
WNetGetNetworkInformationA(
    LPCSTR lpProvider,
    LPNETINFOSTRUCT lpNetInfoStruct
    );

DWORD
WNetGetNetworkInformationW(
    LPCWSTR lpProvider,
    LPNETINFOSTRUCT lpNetInfoStruct
    );



#define WNetGetNetworkInformation WNetGetNetworkInformationA




//
//  Error handling.
//


DWORD
WNetGetLastErrorA(
    LPDWORD lpError,
    LPSTR lpErrorBuf,
    DWORD nErrorBufSize,
    LPSTR lpNameBuf,
    DWORD nNameBufSize
    );

DWORD
WNetGetLastErrorW(
    LPDWORD lpError,
    LPWSTR lpErrorBuf,
    DWORD nErrorBufSize,
    LPWSTR lpNameBuf,
    DWORD nNameBufSize
    );



#define WNetGetLastError WNetGetLastErrorA


//
//  STATUS CODES
//

// General

#define WN_SUCCESS NO_ERROR
#define WN_NO_ERROR NO_ERROR
#define WN_NOT_SUPPORTED ERROR_NOT_SUPPORTED
#define WN_CANCEL ERROR_CANCELLED
#define WN_RETRY ERROR_RETRY
#define WN_NET_ERROR ERROR_UNEXP_NET_ERR
#define WN_MORE_DATA ERROR_MORE_DATA
#define WN_BAD_POINTER ERROR_INVALID_ADDRESS
#define WN_BAD_VALUE ERROR_INVALID_PARAMETER
#define WN_BAD_USER ERROR_BAD_USERNAME
#define WN_BAD_PASSWORD ERROR_INVALID_PASSWORD
#define WN_ACCESS_DENIED ERROR_ACCESS_DENIED
#define WN_FUNCTION_BUSY ERROR_BUSY
#define WN_WINDOWS_ERROR ERROR_UNEXP_NET_ERR
#define WN_OUT_OF_MEMORY ERROR_NOT_ENOUGH_MEMORY
#define WN_NO_NETWORK ERROR_NO_NETWORK
#define WN_EXTENDED_ERROR ERROR_EXTENDED_ERROR
#define WN_BAD_LEVEL ERROR_INVALID_LEVEL
#define WN_BAD_HANDLE ERROR_INVALID_HANDLE

#define WN_NOT_INITIALIZING ERROR_ALREADY_INITIALIZED
#define WN_NO_MORE_DEVICES ERROR_NO_MORE_DEVICES


// Connection

#define WN_NOT_CONNECTED ERROR_NOT_CONNECTED
#define WN_OPEN_FILES ERROR_OPEN_FILES
#define WN_DEVICE_IN_USE ERROR_DEVICE_IN_USE
#define WN_BAD_NETNAME ERROR_BAD_NET_NAME
#define WN_BAD_LOCALNAME ERROR_BAD_DEVICE
#define WN_ALREADY_CONNECTED ERROR_ALREADY_ASSIGNED
#define WN_DEVICE_ERROR ERROR_GEN_FAILURE
#define WN_CONNECTION_CLOSED ERROR_CONNECTION_UNAVAIL
#define WN_NO_NET_OR_BAD_PATH ERROR_NO_NET_OR_BAD_PATH
#define WN_BAD_PROVIDER ERROR_BAD_PROVIDER
#define WN_CANNOT_OPEN_PROFILE ERROR_CANNOT_OPEN_PROFILE
#define WN_BAD_PROFILE ERROR_BAD_PROFILE
#define WN_BAD_DEV_TYPE ERROR_BAD_DEV_TYPE
#define WN_DEVICE_ALREADY_REMEMBERED ERROR_DEVICE_ALREADY_REMEMBERED
#define WN_CONNECTED_OTHER_PASSWORD ERROR_CONNECTED_OTHER_PASSWORD

#define WN_CONNECTED_OTHER_PASSWORD_DEFAULT ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT


// Enumeration

#define WN_NO_MORE_ENTRIES ERROR_NO_MORE_ITEMS
#define WN_NOT_CONTAINER ERROR_NOT_CONTAINER


// Authentication

#define WN_NOT_AUTHENTICATED ERROR_NOT_AUTHENTICATED
#define WN_NOT_LOGGED_ON ERROR_NOT_LOGGED_ON
#define WN_NOT_VALIDATED ERROR_NO_LOGON_SERVERS


//
//  For Shell
//


typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT, *LPNETCONNECTINFOSTRUCT;

#define WNCON_FORNETCARD 0x00000001
#define WNCON_NOTROUTED 0x00000002
#define WNCON_SLOWLINK 0x00000004
#define WNCON_DYNAMIC 0x00000008


DWORD
MultinetGetConnectionPerformanceA(
    LPNETRESOURCEA lpNetResource,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );

DWORD
MultinetGetConnectionPerformanceW(
    LPNETRESOURCEW lpNetResource,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );



#define MultinetGetConnectionPerformance MultinetGetConnectionPerformanceA
# 171 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 208 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h" 1
/*++



Copyright (c) 2000  Microsoft Corporation



Module Name:



    stralign.h



Abstract:



    This module contains macros and prototypes to expose the unaligned wide

    character interfaces.



    Public interfaces created or declared here include:



    ua_CharUpper()

    ua_CharUpperW()

    ua_lstrcmp()

    ua_lstrcmpW()

    ua_lstrcmpi()

    ua_lstrcmpiW()

    ua_lstrlen()

    ua_lstrlenW()

    ua_tcscpy()

    ua_tcscpy_s()

    ua_wcschr()

    ua_wcscpy()

    ua_wcscpy_s()

    ua_wcsicmp()

    ua_wcslen()

    ua_wcsrchr()



    STRUC_ALIGNED_STACK_COPY()

    TSTR_ALIGNED()

    TSTR_ALIGNED_STACK_COPY()

    WSTR_ALIGNED()

    WSTR_ALIGNED_STACK_COPY()



Author:



--*/
# 44 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
#define __STRALIGN_H_ 



#define _STRALIGN_USE_SECURE_CRT 1
# 58 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
#define _WINDOWS_INSECURE_DEPRECATE __declspec(deprecated)







//
// N.B. On AMD64 platforms the key word __unaligned is enabled, but has no
//      effect and strings can be unaligned exactly as they are on the x86.
//      Therefore, all AMD64 alignment macros are forced to produce values
//      that make the subject arguments appear as it they are aligned.
//
# 119 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
//
// The C runtime libraries expect aligned string pointers.  Following are the
// prototypes for our own, slower worker functions that accept unaligned
// UNICODE strings.
//
// Macro to determine whether a pointer to a unicode character is naturally
// aligned.
//







#define WSTR_ALIGNED(s) (((DWORD_PTR)(s) & (sizeof(WCHAR)-1)) == 0)



//
// Platform-specific prototypes for worker functions exported from kernel32.
// Do not call these directly, they do not exist on all platforms.  Instead
// use the equivalent ua_xxx() routines.
//

LPUWSTR

uaw_CharUpperW(
    LPUWSTR String
    );

int

uaw_lstrcmpW(
    PCUWSTR String1,
    PCUWSTR String2
    );

int

uaw_lstrcmpiW(
    PCUWSTR String1,
    PCUWSTR String2
    );

int

uaw_lstrlenW(
    LPCUWSTR String
    );

PUWSTR

uaw_wcschr(
    PCUWSTR String,
    WCHAR Character
    );

PUWSTR

uaw_wcscpy(
    PUWSTR Destination,
    PCUWSTR Source
    );

int

uaw_wcsicmp(
    PCUWSTR String1,
    PCUWSTR String2
    );

size_t

uaw_wcslen(
    PCUWSTR String
    );

PUWSTR

uaw_wcsrchr(
    PCUWSTR String,
    WCHAR Character
    );

//
// Following are the inline wrappers that determine the optimal worker function
// to call based on the alignment of the UNICODE string arguments.  Their
// behavior is otherwise identical to the corresponding standard run-time
// routiunes.
//


__inline
LPUWSTR
static
ua_CharUpperW(
    LPUWSTR String
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return CharUpperW( (PWSTR)String );
    } else {
        return uaw_CharUpperW( String );
    }
}



__inline
int
static
ua_lstrcmpW(
    LPCUWSTR String1,
    LPCUWSTR String2
    )
{
    if ((((DWORD_PTR)(String1) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(String2) & (sizeof(WCHAR)-1)) == 0)) {
        return lstrcmpW( (LPCWSTR)String1, (LPCWSTR)String2);
    } else {
        return uaw_lstrcmpW( String1, String2 );
    }
}



__inline
int
static
ua_lstrcmpiW(
    LPCUWSTR String1,
    LPCUWSTR String2
    )
{
    if ((((DWORD_PTR)(String1) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(String2) & (sizeof(WCHAR)-1)) == 0)) {
        return lstrcmpiW( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_lstrcmpiW( String1, String2 );
    }
}



__inline
int
static
ua_lstrlenW(
    LPCUWSTR String
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return lstrlenW( (PCWSTR)String );
    } else {
        return uaw_lstrlenW( String );
    }
}




//
// Certain run-time string functions are overloaded in C++, to avoid
// inadvertent stripping of the const attribute.
//
// The functions of interest here include: wcschr and wcsrchr.
//
// There are three flavors of these functions:
//
// Flavor  Returns    Parameter
//
// 1       PWSTR      PCWSTR
// 2       PCWSTR     PCWSTR
// 3       PWSTR      PWSTR
//
// string.h declares flavor 1 whether for C or C++.  This is the non-ANSI,
// backward compatible mode.
//
// wchar.h declares flavor 1 if C, or flavors 2 and 3 if C++.  This is the
// ANSI method.
//
// Our corresponding functions need to match what was declared.  The way
// we can tell is by looking at _WConst_return... if it is defined then
// we want to match the prototypes in wchar.h, otherwise we'll match
// the prototypes in string.h.
//


typedef WCHAR *PUWSTR_C;




//
// Here is flavor 1 or 2
//

__inline
PUWSTR_C
static
ua_wcschr(
    PCUWSTR String,
    WCHAR Character
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return wcschr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcschr(String, Character);
    }
}

__inline
PUWSTR_C
static
ua_wcsrchr(
    PCUWSTR String,
    WCHAR Character
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return wcsrchr((PCWSTR)String, Character);
    } else {
        return (PUWSTR_C)uaw_wcsrchr(String, Character);
    }
}
# 405 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
__inline
PUWSTR
static
__attribute__((deprecated))
ua_wcscpy(
    PUWSTR Destination,
    PCUWSTR Source
    )
{
    if ((((DWORD_PTR)(Source) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(Destination) & (sizeof(WCHAR)-1)) == 0)) {
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)



        return wcscpy( (PWSTR)Destination, (PCWSTR)Source );
#pragma warning(pop)
    } else {
        return uaw_wcscpy( Destination, Source );
    }
}



__inline
PUWSTR
static
ua_wcscpy_s(
    PUWSTR Destination,
    size_t DestinationSize,
    PCUWSTR Source
    )
{
    if ((((DWORD_PTR)(Source) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(Destination) & (sizeof(WCHAR)-1)) == 0)) {
        return (wcscpy_s( (PWSTR)Destination, DestinationSize, (PCWSTR)Source ) == 0 ? Destination : ((void *)0));
    } else {
        /* TODO: Need to reference uaw_wcscpy_s */
        return uaw_wcscpy( Destination, Source );
    }
}


__inline
size_t
static
ua_wcslen(
    PCUWSTR String
    )
{
    if ((((DWORD_PTR)(String) & (sizeof(WCHAR)-1)) == 0)) {
        return wcslen( (PCWSTR)String );
    } else {
        return uaw_wcslen( String );
    }
}



__inline
int
static
ua_wcsicmp(
    PCUWSTR String1,
    PCUWSTR String2
    )
{
    if ((((DWORD_PTR)(String1) & (sizeof(WCHAR)-1)) == 0) && (((DWORD_PTR)(String2) & (sizeof(WCHAR)-1)) == 0)) {
        return _wcsicmp( (LPCWSTR)String1, (LPCWSTR)String2 );
    } else {
        return uaw_wcsicmp( String1, String2 );
    }
}



//++
//
// VOID
// WSTR_ALIGNED_STACK_COPY (
//    __out PCWSTR *TargetString,
//    __in_opt  PCUWSTR SourceString
//    )
//
// VOID
// TSTR_ALIGNED_STACK_COPY (
//    __out PCTSTR *TargetString,
//    __in_opt  PCUTSTR SourceString
//    )
//
// Routine Description:
//
//    These macros set TargetString to an aligned pointer to the string
//    represented by SourceString.  If necessary, an aligned copy of
//    SourceString is copied onto the stack.
//
// Arguments:
//
//    TargetString - Supplies a pointer to a pointer to the resultant
//                   string.  This may be the same as SourceString if
//                   that argument is aligned.
//
//    SourceString - Supplies a pointer to the possibly unaligned UNICODE
//                   string.
//
// Return Value:
//
//    None.
//
// Note:
//
//    These macros may allocate memory on the stack via the CRT function
//    _alloca().  This memory is "freed" when the calling function exits.
//    As a result, do not use these macros inside of a loop that may execute
//    a large number of times - instead, use a wrapper function, or use
//    an explicit buffer like this:
//
//    TCHAR AlignedStringBuffer[ MAX_FOOSTR_CHARS ];
//    PTSTR AlignedString;
//
//    while (a < b) {
//        ...
//        if (TSTR_ALIGNED(s) {
//            AlignedString = s;
//        } else {
//            AlignedString = (PTSTR)ua_tcscpy(AlignedStringBuffer,s);
//        }
//        SomeSystemFunction(AlignedString);
//        ...
//    }
//
//
//--

//
// __UA_WSTRSIZE returns the number of bytes required to store the
// supplied null-terminated UNICODE string.
//
// __UA_LOCALCOPY accepts a pointer to unaligned data and a size.  It
// allocates an aligned buffer on the stack and copies the data into
// it, returning a pointer to the buffer.
//


#define __UA_WCSLEN ua_wcslen


#define __UA_WSTRSIZE(s) ((__UA_WCSLEN(s)+1)*sizeof(WCHAR))
#define __UA_STACKCOPY(p,s) memcpy(_alloca(s),p,s)

//
// Note that NULL is aligned.
//







//
// Use of an inline function here is not possible, as the results of
// the _alloca() will not be preserved upon return from the function.
//

#define WSTR_ALIGNED_STACK_COPY(d,s) { PCUWSTR __ua_src; size_t __ua_size; PWSTR __ua_dst; __ua_src = (s); if (WSTR_ALIGNED(__ua_src)) { __ua_dst = (PWSTR)__ua_src; } else { __ua_size = __UA_WSTRSIZE(__ua_src); __ua_dst = (PWSTR)_alloca(__ua_size); memcpy(__ua_dst,__ua_src,__ua_size); } *(d) = (PCWSTR)__ua_dst; }
# 589 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
#define ASTR_ALIGNED_STACK_COPY(d,s) (*(d) = (PCSTR)(s))

//++
//
// <type> CONST *
// STRUC_ALIGNED_STACK_COPY (
//     __in <type name>,
//     __in_opt PVOID Struc
//     )
//
// Routine Description:
//
//    This macro returns an aligned pointer to Struc, creating a local
//    copy on the stack if necessary.
//
//    This should be used only for relatively small structures, and efforts
//    should be made to align the structure properly in the first place.  Use
//    this macro only as a last resort.
//
// Arguments:
//
//    <type> - The type specifier of Struc
//
//    Struc - Supplies a pointer to the structure in question.
//
// Return Value:
//
//    Returns a const pointer to Struc if it is properly aligned, or a pointer
//    to a stack-allocated copy of Struc if it is not.
//
//--



#define __UA_STRUC_ALIGNED(t,s) (((DWORD_PTR)(s) & (TYPE_ALIGNMENT(t)-1)) == 0)


#define STRUC_ALIGNED_STACK_COPY(t,s) __UA_STRUC_ALIGNED(t,s) ? ((t const *)(s)) : ((t const *)__UA_STACKCOPY((s),sizeof(t)))
# 652 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/stralign.h"
#define TSTR_ALIGNED_STACK_COPY(d,s) ASTR_ALIGNED_STACK_COPY(d,s)
#define TSTR_ALIGNED(x) TRUE
#define ua_CharUpper CharUpperA
#define ua_lstrcmp lstrcmpA
#define ua_lstrcmpi lstrcmpiA
#define ua_lstrlen lstrlenA
#define ua_tcscpy strcpy

#define ua_tcscpy_s strcpy_s
# 209 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 221 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h" 1
/*++ BUILD Version: 0010    // Increment this if a change has global effects



Copyright (c) 1995-1998  Microsoft Corporation



Module Name:



    winsvc.h



Abstract:



    Header file for the Service Control Manager



Environment:



    User Mode - Win32



--*/
# 19 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
#define _WINSVC_ 

//
// Define API decoration for direct importing of DLL references.
//
# 37 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
//
// Constants
//

//
// Service database names
//

#define SERVICES_ACTIVE_DATABASEW L"ServicesActive"
#define SERVICES_FAILED_DATABASEW L"ServicesFailed"

#define SERVICES_ACTIVE_DATABASEA "ServicesActive"
#define SERVICES_FAILED_DATABASEA "ServicesFailed"

//
// Character to designate that a name is a group
//

#define SC_GROUP_IDENTIFIERW L'+'
#define SC_GROUP_IDENTIFIERA '+'
# 68 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
#define SERVICES_ACTIVE_DATABASE SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE SERVICES_FAILED_DATABASEA

#define SC_GROUP_IDENTIFIER SC_GROUP_IDENTIFIERA



//
// Value to indicate no change to an optional parameter
//
#define SERVICE_NO_CHANGE 0xffffffff

//
// Service State -- for Enum Requests (Bit Mask)
//
#define SERVICE_ACTIVE 0x00000001
#define SERVICE_INACTIVE 0x00000002
#define SERVICE_STATE_ALL (SERVICE_ACTIVE | SERVICE_INACTIVE)


//
// Controls
//
#define SERVICE_CONTROL_STOP 0x00000001
#define SERVICE_CONTROL_PAUSE 0x00000002
#define SERVICE_CONTROL_CONTINUE 0x00000003
#define SERVICE_CONTROL_INTERROGATE 0x00000004
#define SERVICE_CONTROL_SHUTDOWN 0x00000005
#define SERVICE_CONTROL_PARAMCHANGE 0x00000006
#define SERVICE_CONTROL_NETBINDADD 0x00000007
#define SERVICE_CONTROL_NETBINDREMOVE 0x00000008
#define SERVICE_CONTROL_NETBINDENABLE 0x00000009
#define SERVICE_CONTROL_NETBINDDISABLE 0x0000000A
#define SERVICE_CONTROL_DEVICEEVENT 0x0000000B
#define SERVICE_CONTROL_HARDWAREPROFILECHANGE 0x0000000C
#define SERVICE_CONTROL_POWEREVENT 0x0000000D
#define SERVICE_CONTROL_SESSIONCHANGE 0x0000000E
#define SERVICE_CONTROL_PRESHUTDOWN 0x0000000F
#define SERVICE_CONTROL_TIMECHANGE 0x00000010
#define SERVICE_CONTROL_TRIGGEREVENT 0x00000020

//
// Service State -- for CurrentState
//
#define SERVICE_STOPPED 0x00000001
#define SERVICE_START_PENDING 0x00000002
#define SERVICE_STOP_PENDING 0x00000003
#define SERVICE_RUNNING 0x00000004
#define SERVICE_CONTINUE_PENDING 0x00000005
#define SERVICE_PAUSE_PENDING 0x00000006
#define SERVICE_PAUSED 0x00000007

//
// Controls Accepted  (Bit Mask)
//
#define SERVICE_ACCEPT_STOP 0x00000001
#define SERVICE_ACCEPT_PAUSE_CONTINUE 0x00000002
#define SERVICE_ACCEPT_SHUTDOWN 0x00000004
#define SERVICE_ACCEPT_PARAMCHANGE 0x00000008
#define SERVICE_ACCEPT_NETBINDCHANGE 0x00000010
#define SERVICE_ACCEPT_HARDWAREPROFILECHANGE 0x00000020
#define SERVICE_ACCEPT_POWEREVENT 0x00000040
#define SERVICE_ACCEPT_SESSIONCHANGE 0x00000080
#define SERVICE_ACCEPT_PRESHUTDOWN 0x00000100
#define SERVICE_ACCEPT_TIMECHANGE 0x00000200
#define SERVICE_ACCEPT_TRIGGEREVENT 0x00000400

//
// Service Control Manager object specific access types
//
#define SC_MANAGER_CONNECT 0x0001
#define SC_MANAGER_CREATE_SERVICE 0x0002
#define SC_MANAGER_ENUMERATE_SERVICE 0x0004
#define SC_MANAGER_LOCK 0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS 0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG 0x0020

#define SC_MANAGER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SC_MANAGER_CONNECT | SC_MANAGER_CREATE_SERVICE | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_LOCK | SC_MANAGER_QUERY_LOCK_STATUS | SC_MANAGER_MODIFY_BOOT_CONFIG)
# 155 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
//
// Service object specific access type
//
#define SERVICE_QUERY_CONFIG 0x0001
#define SERVICE_CHANGE_CONFIG 0x0002
#define SERVICE_QUERY_STATUS 0x0004
#define SERVICE_ENUMERATE_DEPENDENTS 0x0008
#define SERVICE_START 0x0010
#define SERVICE_STOP 0x0020
#define SERVICE_PAUSE_CONTINUE 0x0040
#define SERVICE_INTERROGATE 0x0080
#define SERVICE_USER_DEFINED_CONTROL 0x0100

#define SERVICE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_START | SERVICE_STOP | SERVICE_PAUSE_CONTINUE | SERVICE_INTERROGATE | SERVICE_USER_DEFINED_CONTROL)
# 179 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsvc.h"
//
// Service flags for QueryServiceStatusEx
//
#define SERVICE_RUNS_IN_SYSTEM_PROCESS 0x00000001

//
// Info levels for ChangeServiceConfig2 and QueryServiceConfig2
//
#define SERVICE_CONFIG_DESCRIPTION 1
#define SERVICE_CONFIG_FAILURE_ACTIONS 2
#define SERVICE_CONFIG_DELAYED_AUTO_START_INFO 3
#define SERVICE_CONFIG_FAILURE_ACTIONS_FLAG 4
#define SERVICE_CONFIG_SERVICE_SID_INFO 5
#define SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO 6
#define SERVICE_CONFIG_PRESHUTDOWN_INFO 7
#define SERVICE_CONFIG_TRIGGER_INFO 8
#define SERVICE_CONFIG_PREFERRED_NODE 9

//
// Info levels for NotifyServiceStatusChange
//
#define SERVICE_NOTIFY_STATUS_CHANGE_1 1
#define SERVICE_NOTIFY_STATUS_CHANGE_2 2

#define SERVICE_NOTIFY_STATUS_CHANGE SERVICE_NOTIFY_STATUS_CHANGE_2

//
// Service notification masks
//
#define SERVICE_NOTIFY_STOPPED 0x00000001
#define SERVICE_NOTIFY_START_PENDING 0x00000002
#define SERVICE_NOTIFY_STOP_PENDING 0x00000004
#define SERVICE_NOTIFY_RUNNING 0x00000008
#define SERVICE_NOTIFY_CONTINUE_PENDING 0x00000010
#define SERVICE_NOTIFY_PAUSE_PENDING 0x00000020
#define SERVICE_NOTIFY_PAUSED 0x00000040
#define SERVICE_NOTIFY_CREATED 0x00000080
#define SERVICE_NOTIFY_DELETED 0x00000100
#define SERVICE_NOTIFY_DELETE_PENDING 0x00000200

//
// The following defines are for service stop reason codes
//

//
// Stop reason flags. Update SERVICE_STOP_REASON_FLAG_MAX when
// new flags are added.
//
#define SERVICE_STOP_REASON_FLAG_MIN 0x00000000
#define SERVICE_STOP_REASON_FLAG_UNPLANNED 0x10000000
#define SERVICE_STOP_REASON_FLAG_CUSTOM 0x20000000
#define SERVICE_STOP_REASON_FLAG_PLANNED 0x40000000
#define SERVICE_STOP_REASON_FLAG_MAX 0x80000000

//
// Microsoft major reasons. Update SERVICE_STOP_REASON_MAJOR_MAX when
// new codes are added.
//
#define SERVICE_STOP_REASON_MAJOR_MIN 0x00000000
#define SERVICE_STOP_REASON_MAJOR_OTHER 0x00010000
#define SERVICE_STOP_REASON_MAJOR_HARDWARE 0x00020000
#define SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM 0x00030000
#define SERVICE_STOP_REASON_MAJOR_SOFTWARE 0x00040000
#define SERVICE_STOP_REASON_MAJOR_APPLICATION 0x00050000
#define SERVICE_STOP_REASON_MAJOR_NONE 0x00060000
#define SERVICE_STOP_REASON_MAJOR_MAX 0x00070000
#define SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM 0x00400000
#define SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM 0x00ff0000

//
// Microsoft minor reasons. Update SERVICE_STOP_REASON_MINOR_MAX when
// new codes are added.
//
#define SERVICE_STOP_REASON_MINOR_MIN 0x00000000
#define SERVICE_STOP_REASON_MINOR_OTHER 0x00000001
#define SERVICE_STOP_REASON_MINOR_MAINTENANCE 0x00000002
#define SERVICE_STOP_REASON_MINOR_INSTALLATION 0x00000003
#define SERVICE_STOP_REASON_MINOR_UPGRADE 0x00000004
#define SERVICE_STOP_REASON_MINOR_RECONFIG 0x00000005
#define SERVICE_STOP_REASON_MINOR_HUNG 0x00000006
#define SERVICE_STOP_REASON_MINOR_UNSTABLE 0x00000007
#define SERVICE_STOP_REASON_MINOR_DISK 0x00000008
#define SERVICE_STOP_REASON_MINOR_NETWORKCARD 0x00000009
#define SERVICE_STOP_REASON_MINOR_ENVIRONMENT 0x0000000a
#define SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER 0x0000000b
#define SERVICE_STOP_REASON_MINOR_OTHERDRIVER 0x0000000c
#define SERVICE_STOP_REASON_MINOR_SERVICEPACK 0x0000000d
#define SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE 0x0000000e
#define SERVICE_STOP_REASON_MINOR_SECURITYFIX 0x0000000f
#define SERVICE_STOP_REASON_MINOR_SECURITY 0x00000010
#define SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY 0x00000011
#define SERVICE_STOP_REASON_MINOR_WMI 0x00000012
#define SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL 0x00000013
#define SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL 0x00000014
#define SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL 0x00000015
#define SERVICE_STOP_REASON_MINOR_MMC 0x00000016
#define SERVICE_STOP_REASON_MINOR_NONE 0x00000017
#define SERVICE_STOP_REASON_MINOR_MAX 0x00000018
#define SERVICE_STOP_REASON_MINOR_MIN_CUSTOM 0x00000100
#define SERVICE_STOP_REASON_MINOR_MAX_CUSTOM 0x0000FFFF

//
// Info levels for ControlServiceEx
//
#define SERVICE_CONTROL_STATUS_REASON_INFO 1

//
// Service SID types supported
//
#define SERVICE_SID_TYPE_NONE 0x00000000
#define SERVICE_SID_TYPE_UNRESTRICTED 0x00000001
#define SERVICE_SID_TYPE_RESTRICTED ( 0x00000002 | SERVICE_SID_TYPE_UNRESTRICTED )

//
// Service trigger types
//
#define SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL 1
#define SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY 2
#define SERVICE_TRIGGER_TYPE_DOMAIN_JOIN 3
#define SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT 4
#define SERVICE_TRIGGER_TYPE_GROUP_POLICY 5
#define SERVICE_TRIGGER_TYPE_CUSTOM 20

//
// Service trigger data types
//
#define SERVICE_TRIGGER_DATA_TYPE_BINARY 1
#define SERVICE_TRIGGER_DATA_TYPE_STRING 2

//
//  NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID & NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID are used with
//  SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY trigger.
//
extern const GUID /* 4f27f2de-14e2-430b-a549-7cd48cbc8245 */ NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID





   ;

extern const GUID /* cc4ba62a-162e-4648-847a-b6bdf993e335 */ NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID





   ;

//
//  DOMAIN_JOIN_GUID & DOMAIN_LEAVE_GUID are used with SERVICE_TRIGGER_TYPE_DOMAIN_JOIN trigger.
//
extern const GUID /* 1ce20aba-9851-4421-9430-1ddeb766e809 */ DOMAIN_JOIN_GUID





   ;

extern const GUID /* ddaf516e-58c2-4866-9574-c3b615d42ea1 */ DOMAIN_LEAVE_GUID





   ;

//
//  FIREWALL_PORT_OPEN_GUID & FIREWALL_PORT_CLOSE_GUID are used with
//  SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT trigger.
//
extern const GUID /* b7569e07-8421-4ee0-ad10-86915afdad09 */ FIREWALL_PORT_OPEN_GUID





   ;

extern const GUID /* a144ed38-8e12-4de4-9d96-e64740b1a524 */ FIREWALL_PORT_CLOSE_GUID





   ;

//
//  MACHINE_POLICY_PRESENT_GUID & USER_POLICY_PRESENT_GUID are used with
//  SERVICE_TRIGGER_TYPE_GROUP_POLICY trigger.
//
extern const GUID /* 659FCAE6-5BDB-4DA9-B1FF-CA2A178D46E0 */ MACHINE_POLICY_PRESENT_GUID





   ;

extern const GUID /* 54FB46C8-F089-464C-B1FD-59D1B62C3B50 */ USER_POLICY_PRESENT_GUID





   ;

//
// Service trigger actions
//
#define SERVICE_TRIGGER_ACTION_SERVICE_START 1
#define SERVICE_TRIGGER_ACTION_SERVICE_STOP 2

//
// argv[1] passed into ServiceMain of trigger started services
//
#define SERVICE_TRIGGER_STARTED_ARGUMENT L"TriggerStarted"

//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;
//
// Service description string
//
typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;




typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;


//
// Actions to take on service failure
//
typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE = 0,
        SC_ACTION_RESTART = 1,
        SC_ACTION_REBOOT = 2,
        SC_ACTION_RUN_COMMAND = 3
} SC_ACTION_TYPE;

typedef struct _SC_ACTION {
    SC_ACTION_TYPE Type;
    DWORD Delay;
} SC_ACTION, *LPSC_ACTION;

typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD dwResetPeriod;
    LPSTR lpRebootMsg;
    LPSTR lpCommand;



    DWORD cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD dwResetPeriod;
    LPWSTR lpRebootMsg;
    LPWSTR lpCommand;



    DWORD cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;




typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;


//
// Service delayed autostart info setting
//
typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
    BOOL fDelayedAutostart; // Delayed autostart flag
} SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;

//
// Service failure actions flag setting
//
typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
    BOOL fFailureActionsOnNonCrashFailures; // Failure actions flag
} SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;

//
// Service SID info setting
//
typedef struct _SERVICE_SID_INFO {
    DWORD dwServiceSidType; // Service SID type
} SERVICE_SID_INFO, *LPSERVICE_SID_INFO;

//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    LPSTR pmszRequiredPrivileges; // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
//
// Service required privileges information
//
typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    LPWSTR pmszRequiredPrivileges; // Required privileges multi-sz
} SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;




typedef SERVICE_REQUIRED_PRIVILEGES_INFOA SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO;


//
// Service preshutdown timeout setting
//
typedef struct _SERVICE_PRESHUTDOWN_INFO {
    DWORD dwPreshutdownTimeout; // Timeout in msecs
} SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;

//
//  Service trigger data item
//
typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    DWORD dwDataType; // Data type -- one of SERVICE_TRIGGER_DATA_TYPE_* constants



    DWORD cbData; // Size of trigger specific data



    PBYTE pData; // Trigger specific data
} SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;

//
//  Trigger-specific information
//
typedef struct _SERVICE_TRIGGER
{
    DWORD dwTriggerType; // One of SERVICE_TRIGGER_TYPE_* constants
    DWORD dwAction; // One of SERVICE_TRIGGER_ACTION_* constants
    GUID * pTriggerSubtype; // Provider GUID if the trigger type is SERVICE_TRIGGER_TYPE_CUSTOM
                                                            // Device class interface GUID if the trigger type is
                                                            // SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL



    DWORD cDataItems; // Number of data items in pDataItems array



    PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM pDataItems; // Trigger specific data
} SERVICE_TRIGGER, *PSERVICE_TRIGGER;

//
// Service trigger information
//
typedef struct _SERVICE_TRIGGER_INFO {



    DWORD cTriggers; // Number of triggers in the pTriggers array



    PSERVICE_TRIGGER pTriggers; // Array of triggers
    PBYTE pReserved; // Reserved, must be NULL
} SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;

//
// Preferred node information
//
typedef struct _SERVICE_PREFERRED_NODE_INFO {
    USHORT usPreferredNode; // Preferred node
    BOOLEAN fDelete; // Delete the preferred node setting
} SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;

//
// Time change information
//
typedef struct _SERVICE_TIMECHANGE_INFO {
    LARGE_INTEGER liNewTime; // New time
    LARGE_INTEGER liOldTime; // Old time
} SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;

//
// Handle Types
//

struct SC_HANDLE__{int unused;}; typedef struct SC_HANDLE__ *SC_HANDLE;
typedef SC_HANDLE *LPSC_HANDLE;

struct SERVICE_STATUS_HANDLE__{int unused;}; typedef struct SERVICE_STATUS_HANDLE__ *SERVICE_STATUS_HANDLE;

//
// Info levels for QueryServiceStatusEx
//

typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO = 0
} SC_STATUS_TYPE;

//
// Info levels for EnumServicesStatusEx
//
typedef enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO = 0
} SC_ENUM_TYPE;


//
// Service Status Structures
//

typedef struct _SERVICE_STATUS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;

typedef struct _SERVICE_STATUS_PROCESS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
    DWORD dwProcessId;
    DWORD dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;


//
// Service Status Enumeration Structure
//

typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR lpServiceName;
    LPSTR lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR lpServiceName;
    LPWSTR lpDisplayName;
    SERVICE_STATUS ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;




typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;


typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR lpServiceName;
    LPSTR lpDisplayName;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR lpServiceName;
    LPWSTR lpDisplayName;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;




typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;


//
// Structures for the Lock API functions
//

typedef LPVOID SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD fIsLocked;
    LPSTR lpLockOwner;
    DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD fIsLocked;
    LPWSTR lpLockOwner;
    DWORD dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;




typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;




//
// Query Service Configuration Structure
//

typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPSTR lpBinaryPathName;
    LPSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPSTR lpDependencies;
    LPSTR lpServiceStartName;
    LPSTR lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPWSTR lpBinaryPathName;
    LPWSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPWSTR lpDependencies;
    LPWSTR lpServiceStartName;
    LPWSTR lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;




typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;




//
// Function Prototype for the Service Main Function
//

typedef void ( *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD dwNumServicesArgs,
    LPWSTR *lpServiceArgVectors
    );

typedef void ( *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD dwNumServicesArgs,
    LPSTR *lpServiceArgVectors
    );




#define LPSERVICE_MAIN_FUNCTION LPSERVICE_MAIN_FUNCTIONA



//
// Service Start Table
//

typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;




typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;


//
// Prototype for the Service Control Handler Function
//

typedef void ( *LPHANDLER_FUNCTION)(
    DWORD dwControl
    );

typedef DWORD ( *LPHANDLER_FUNCTION_EX)(
    DWORD dwControl,
    DWORD dwEventType,
    LPVOID lpEventData,
    LPVOID lpContext
    );

//
// Service notification parameters
//
typedef
void
( * PFN_SC_NOTIFY_CALLBACK ) (
    PVOID pParameter
    );

//
//  Each new notify structure is a superset of the older version
//
typedef struct _SERVICE_NOTIFY_1 {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;

typedef struct _SERVICE_NOTIFY_2A {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationTriggered;
    LPSTR pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD dwVersion;
    PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
    PVOID pContext;
    DWORD dwNotificationStatus;
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationTriggered;
    LPWSTR pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;




typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;


typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;




typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;


//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    DWORD dwReason;
    LPSTR pszComment;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
//
// Service control status reason parameters
//
typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    DWORD dwReason;
    LPWSTR pszComment;
    SERVICE_STATUS_PROCESS ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;




typedef SERVICE_CONTROL_STATUS_REASON_PARAMSA SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS;


///////////////////////////////////////////////////////////////////////////
// API Function Prototypes
///////////////////////////////////////////////////////////////////////////


BOOL

ChangeServiceConfigA(
    SC_HANDLE hService,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCSTR lpBinaryPathName,
    LPCSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCSTR lpDependencies,
    LPCSTR lpServiceStartName,
    LPCSTR lpPassword,
    LPCSTR lpDisplayName
    );

BOOL

ChangeServiceConfigW(
    SC_HANDLE hService,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCWSTR lpBinaryPathName,
    LPCWSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCWSTR lpDependencies,
    LPCWSTR lpServiceStartName,
    LPCWSTR lpPassword,
    LPCWSTR lpDisplayName
    );



#define ChangeServiceConfig ChangeServiceConfigA



BOOL

ChangeServiceConfig2A(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
    LPVOID lpInfo
    );

BOOL

ChangeServiceConfig2W(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
    LPVOID lpInfo
    );



#define ChangeServiceConfig2 ChangeServiceConfig2A



BOOL

CloseServiceHandle(
    SC_HANDLE hSCObject
    );


BOOL

ControlService(
    SC_HANDLE hService,
    DWORD dwControl,
    LPSERVICE_STATUS lpServiceStatus
    );



SC_HANDLE

CreateServiceA(
    SC_HANDLE hSCManager,
    LPCSTR lpServiceName,
    LPCSTR lpDisplayName,
    DWORD dwDesiredAccess,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCSTR lpBinaryPathName,
    LPCSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCSTR lpDependencies,
    LPCSTR lpServiceStartName,
    LPCSTR lpPassword
    );


SC_HANDLE

CreateServiceW(
    SC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
    LPCWSTR lpDisplayName,
    DWORD dwDesiredAccess,
    DWORD dwServiceType,
    DWORD dwStartType,
    DWORD dwErrorControl,
    LPCWSTR lpBinaryPathName,
    LPCWSTR lpLoadOrderGroup,
    LPDWORD lpdwTagId,
    LPCWSTR lpDependencies,
    LPCWSTR lpServiceStartName,
    LPCWSTR lpPassword
    );



#define CreateService CreateServiceA



BOOL

DeleteService(
    SC_HANDLE hService
    );



BOOL

EnumDependentServicesA(
    SC_HANDLE hService,
    DWORD dwServiceState,
   
                    LPENUM_SERVICE_STATUSA lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned
    );


BOOL

EnumDependentServicesW(
    SC_HANDLE hService,
    DWORD dwServiceState,
   
                    LPENUM_SERVICE_STATUSW lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned
    );



#define EnumDependentServices EnumDependentServicesA




BOOL

EnumServicesStatusA(
    SC_HANDLE hSCManager,
    DWORD dwServiceType,
    DWORD dwServiceState,
   
                    LPENUM_SERVICE_STATUSA lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle
    );


BOOL

EnumServicesStatusW(
    SC_HANDLE hSCManager,
    DWORD dwServiceType,
    DWORD dwServiceState,
   
                    LPENUM_SERVICE_STATUSW lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle
    );



#define EnumServicesStatus EnumServicesStatusA




BOOL

EnumServicesStatusExA(
    SC_HANDLE hSCManager,
    SC_ENUM_TYPE InfoLevel,
    DWORD dwServiceType,
    DWORD dwServiceState,
   
                    LPBYTE lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle,
    LPCSTR pszGroupName
    );


BOOL

EnumServicesStatusExW(
    SC_HANDLE hSCManager,
    SC_ENUM_TYPE InfoLevel,
    DWORD dwServiceType,
    DWORD dwServiceState,
   
                    LPBYTE lpServices,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded,
    LPDWORD lpServicesReturned,
    LPDWORD lpResumeHandle,
    LPCWSTR pszGroupName
    );



#define EnumServicesStatusEx EnumServicesStatusExA




BOOL

GetServiceKeyNameA(
    SC_HANDLE hSCManager,
    LPCSTR lpDisplayName,
   
                    LPSTR lpServiceName,
    LPDWORD lpcchBuffer
    );


BOOL

GetServiceKeyNameW(
    SC_HANDLE hSCManager,
    LPCWSTR lpDisplayName,
   
                    LPWSTR lpServiceName,
    LPDWORD lpcchBuffer
    );



#define GetServiceKeyName GetServiceKeyNameA




BOOL

GetServiceDisplayNameA(
    SC_HANDLE hSCManager,
    LPCSTR lpServiceName,
   
                    LPSTR lpDisplayName,
    LPDWORD lpcchBuffer
    );


BOOL

GetServiceDisplayNameW(
    SC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
   
                    LPWSTR lpDisplayName,
    LPDWORD lpcchBuffer
    );



#define GetServiceDisplayName GetServiceDisplayNameA



SC_LOCK

LockServiceDatabase(
    SC_HANDLE hSCManager
    );


BOOL

NotifyBootConfigStatus(
    BOOL BootAcceptable
    );



SC_HANDLE

OpenSCManagerA(
    LPCSTR lpMachineName,
    LPCSTR lpDatabaseName,
    DWORD dwDesiredAccess
    );


SC_HANDLE

OpenSCManagerW(
    LPCWSTR lpMachineName,
    LPCWSTR lpDatabaseName,
    DWORD dwDesiredAccess
    );



#define OpenSCManager OpenSCManagerA




SC_HANDLE

OpenServiceA(
    SC_HANDLE hSCManager,
    LPCSTR lpServiceName,
    DWORD dwDesiredAccess
    );


SC_HANDLE

OpenServiceW(
    SC_HANDLE hSCManager,
    LPCWSTR lpServiceName,
    DWORD dwDesiredAccess
    );



#define OpenService OpenServiceA




BOOL

QueryServiceConfigA(
    SC_HANDLE hService,
   
                    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );


BOOL

QueryServiceConfigW(
    SC_HANDLE hService,
   
                    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );



#define QueryServiceConfig QueryServiceConfigA




BOOL

QueryServiceConfig2A(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
   
                    LPBYTE lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );


BOOL

QueryServiceConfig2W(
    SC_HANDLE hService,
    DWORD dwInfoLevel,
   
                    LPBYTE lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );



#define QueryServiceConfig2 QueryServiceConfig2A




BOOL

QueryServiceLockStatusA(
    SC_HANDLE hSCManager,
   
                    LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );


BOOL

QueryServiceLockStatusW(
    SC_HANDLE hSCManager,
   
                    LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );



#define QueryServiceLockStatus QueryServiceLockStatusA




BOOL

QueryServiceObjectSecurity(
    SC_HANDLE hService,
    SECURITY_INFORMATION dwSecurityInformation,
   
                    PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );



BOOL

QueryServiceStatus(
    SC_HANDLE hService,
    LPSERVICE_STATUS lpServiceStatus
    );



BOOL

QueryServiceStatusEx(
    SC_HANDLE hService,
    SC_STATUS_TYPE InfoLevel,
   
                    LPBYTE lpBuffer,
    DWORD cbBufSize,
    LPDWORD pcbBytesNeeded
    );



SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerA(
    LPCSTR lpServiceName,
   
            LPHANDLER_FUNCTION lpHandlerProc
    );


SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerW(
    LPCWSTR lpServiceName,
   
            LPHANDLER_FUNCTION lpHandlerProc
    );



#define RegisterServiceCtrlHandler RegisterServiceCtrlHandlerA




SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerExA(
    LPCSTR lpServiceName,
   
            LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext
    );


SERVICE_STATUS_HANDLE

RegisterServiceCtrlHandlerExW(
    LPCWSTR lpServiceName,
   
            LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext
    );



#define RegisterServiceCtrlHandlerEx RegisterServiceCtrlHandlerExA



BOOL

SetServiceObjectSecurity(
    SC_HANDLE hService,
    SECURITY_INFORMATION dwSecurityInformation,
    PSECURITY_DESCRIPTOR lpSecurityDescriptor
    );


BOOL

SetServiceStatus(
    SERVICE_STATUS_HANDLE hServiceStatus,
    LPSERVICE_STATUS lpServiceStatus
    );


BOOL

StartServiceCtrlDispatcherA(
    const SERVICE_TABLE_ENTRYA *lpServiceStartTable
    );

BOOL

StartServiceCtrlDispatcherW(
    const SERVICE_TABLE_ENTRYW *lpServiceStartTable
    );



#define StartServiceCtrlDispatcher StartServiceCtrlDispatcherA




BOOL

StartServiceA(
    SC_HANDLE hService,
    DWORD dwNumServiceArgs,
   
                    LPCSTR *lpServiceArgVectors
    );

BOOL

StartServiceW(
    SC_HANDLE hService,
    DWORD dwNumServiceArgs,
   
                    LPCWSTR *lpServiceArgVectors
    );



#define StartService StartServiceA



BOOL

UnlockServiceDatabase(
    SC_LOCK ScLock
    );




DWORD

NotifyServiceStatusChangeA (
    SC_HANDLE hService,
    DWORD dwNotifyMask,
    PSERVICE_NOTIFYA pNotifyBuffer
    );

DWORD

NotifyServiceStatusChangeW (
    SC_HANDLE hService,
    DWORD dwNotifyMask,
    PSERVICE_NOTIFYW pNotifyBuffer
    );



#define NotifyServiceStatusChange NotifyServiceStatusChangeA



BOOL

ControlServiceExA(
    SC_HANDLE hService,
    DWORD dwControl,
    DWORD dwInfoLevel,
    PVOID pControlParams
    );

BOOL

ControlServiceExW(
    SC_HANDLE hService,
    DWORD dwControl,
    DWORD dwInfoLevel,
    PVOID pControlParams
    );



#define ControlServiceEx ControlServiceExA
# 222 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2




# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h" 1
/************************************************************************

*                                                                       *

*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *

*                                                                       *

*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *

*                                                                       *

************************************************************************/
# 10 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define _MCX_H_ 





typedef struct _MODEMDEVCAPS {
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;

    // product and version identification
    DWORD dwModemProviderVersion;
    DWORD dwModemManufacturerOffset;
    DWORD dwModemManufacturerSize;
    DWORD dwModemModelOffset;
    DWORD dwModemModelSize;
    DWORD dwModemVersionOffset;
    DWORD dwModemVersionSize;

    // local option capabilities
    DWORD dwDialOptions; // bitmap of supported values
    DWORD dwCallSetupFailTimer; // maximum in seconds
    DWORD dwInactivityTimeout; // maximum in seconds
    DWORD dwSpeakerVolume; // bitmap of supported values
    DWORD dwSpeakerMode; // bitmap of supported values
    DWORD dwModemOptions; // bitmap of supported values
    DWORD dwMaxDTERate; // maximum value in bit/s
    DWORD dwMaxDCERate; // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;

    // static local options (read/write)
    DWORD dwCallSetupFailTimer; // seconds
    DWORD dwInactivityTimeout; // seconds
    DWORD dwSpeakerVolume; // level
    DWORD dwSpeakerMode; // mode
    DWORD dwPreferredModemOptions; // bitmap

    // negotiated options (read only) for current or last call
    DWORD dwNegotiatedModemOptions; // bitmap
    DWORD dwNegotiatedDCERate; // bit/s

    // Variable portion for proprietary expansion
    BYTE abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING 0x00000040
#define DIALOPTION_QUIET 0x00000080
#define DIALOPTION_DIALTONE 0x00000100

// SpeakerVolume for MODEMDEVCAPS
#define MDMVOLFLAG_LOW 0x00000001
#define MDMVOLFLAG_MEDIUM 0x00000002
#define MDMVOLFLAG_HIGH 0x00000004

// SpeakerVolume for MODEMSETTINGS
#define MDMVOL_LOW 0x00000000
#define MDMVOL_MEDIUM 0x00000001
#define MDMVOL_HIGH 0x00000002

// SpeakerMode for MODEMDEVCAPS
#define MDMSPKRFLAG_OFF 0x00000001
#define MDMSPKRFLAG_DIAL 0x00000002
#define MDMSPKRFLAG_ON 0x00000004
#define MDMSPKRFLAG_CALLSETUP 0x00000008

// SpeakerMode for MODEMSETTINGS
#define MDMSPKR_OFF 0x00000000
#define MDMSPKR_DIAL 0x00000001
#define MDMSPKR_ON 0x00000002
#define MDMSPKR_CALLSETUP 0x00000003

// Modem Options
#define MDM_COMPRESSION 0x00000001
#define MDM_ERROR_CONTROL 0x00000002
#define MDM_FORCED_EC 0x00000004
#define MDM_CELLULAR 0x00000008
#define MDM_FLOWCONTROL_HARD 0x00000010
#define MDM_FLOWCONTROL_SOFT 0x00000020
#define MDM_CCITT_OVERRIDE 0x00000040
#define MDM_SPEED_ADJUST 0x00000080
#define MDM_TONE_DIAL 0x00000100
#define MDM_BLIND_DIAL 0x00000200
#define MDM_V23_OVERRIDE 0x00000400
#define MDM_DIAGNOSTICS 0x00000800


//=========================================================================
//
//
//      EXTENDED MODEM OPTIONS INFORMATION
//
//      THE following macros define additional bits in dwPreferredModemOptions.
//
//      These bits specify information relevant to making ISDN and GSM
//      calls, such as which protocol to use.
//
//=========================================================================

#define MDM_MASK_BEARERMODE 0x0000f000
#define MDM_SHIFT_BEARERMODE 12

#define MDM_MASK_PROTOCOLID 0x000f0000
#define MDM_SHIFT_PROTOCOLID 16

#define MDM_MASK_PROTOCOLDATA 0x0ff00000
#define MDM_SHIFT_PROTOCOLDATA 20

//
// PROTOCOLINFO is the union of PROTOCOLID and PROTOCOLDATA ...
//
#define MDM_MASK_PROTOCOLINFO (MDM_MASK_PROTOCOLID|MDM_MASK_PROTOCOLDATA)
#define MDM_SHIFT_PROTOCOLINFO MDM_SHIFT_PROTOCOLID

//
// EXTENDEDINFO is the union of BEARERMODE and PROTOCOLINFO
//
#define MDM_MASK_EXTENDEDINFO (MDM_MASK_BEARERMODE|MDM_MASK_PROTOCOLINFO)
#define MDM_SHIFT_EXTENDEDINFO MDM_SHIFT_BEARERMODE


#define MDM_GET_BEARERMODE(_dwOptions) (((_dwOptions)&MDM_MASK_BEARERMODE) >> MDM_SHIFT_BEARERMODE)


#define MDM_SET_BEARERMODE(_dwOptions,_bm) (((_dwOptions) &= ~MDM_MASK_BEARERMODE), ((_dwOptions) |= (((_bm)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE)))



#define MDM_GET_PROTOCOLID(_dwOptions) (((_dwOptions)&MDM_MASK_PROTOCOLID) >> MDM_SHIFT_PROTOCOLID)


#define MDM_SET_PROTOCOLID(_dwOptions,_prot) (((_dwOptions) &= ~MDM_MASK_PROTOCOLID), ((_dwOptions) |= (((_prot)<<MDM_SHIFT_PROTOCOLID)&MDM_MASK_PROTOCOLID)))



#define MDM_GET_PROTOCOLDATA(_dwOptions) (((_dwOptions)&MDM_MASK_PROTOCOLDATA) >> MDM_SHIFT_PROTOCOLDATA)


#define MDM_SET_PROTOCOLDATA(_dwOptions,_pd) (((_dwOptions) &= ~MDM_MASK_PROTOCOLDATA), ((_dwOptions) |= (((_pd)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA)))



//
// MDM_GET_PROTOCOLINFO gets the protocol-id and info bits in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
#define MDM_GET_PROTOCOLINFO(_dwOptions) ((_dwOptions)&MDM_MASK_PROTOCOLINFO)


//
// MDM_SET_PROTOCOLINFO takes as its argument the protocol-id and info bits in
// their IN-PLACE form (final position within dwModemPreferredOptions)
//
#define MDM_SET_PROTOCOLINFO(_dwOptions,_pinfo) (((_dwOptions) &= ~MDM_MASK_PROTOCOLINFO), ((_dwOptions) |= ((_pinfo)&MDM_MASK_PROTOCOLINFO)))



//
// MDM_GEN_PROTOCOLINFO generates the  the protocol-id and info bits in
// their IN-PLACE form (final position  within dwModemPreferredOptions).
//
#define MDM_GEN_PROTOCOLINFO(_pid,_pdata) ((((_pid )<<MDM_SHIFT_PROTOCOLID )&MDM_MASK_PROTOCOLID ) |(((_pdata)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA))



//
// MDM_GET_EXTENDEDIONFO gets the bearermode and protocol information in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
#define MDM_GET_EXTENDEDINFO(_dwOptions) ((_dwOptions)&MDM_MASK_EXTENDEDINFO)


//
// MDM_SET_PROTOCOLINFO takes as its argument the bearermode and
// protocol bits in their IN-PLACE form (final position within
// dwModemPreferredOptions)
//
#define MDM_SET_EXTENDEDINFO(_dwOptions,_extinfo) (((_dwOptions) &= ~MDM_MASK_EXTENDEDINFO), ((_dwOptions) |= ((_extinfo) & MDM_MASK_EXTENDEDINFO)))




//
// MDM_GEN_EXTENDEDINFO generates the bearermode and protocol information
// in their IN-PLACE form (final position within dwModemPreferredOptions0.
//
#define MDM_GEN_EXTENDEDINFO(_bearermode,_pinfo) (((_pinfo)&MDM_MASK_PROTOCOLINFO ) |(((_bearermode)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE))




//=========================================================================
//  BEARER MODES
//=========================================================================
//
#define MDM_BEARERMODE_ANALOG 0x0
#define MDM_BEARERMODE_ISDN 0x1
#define MDM_BEARERMODE_GSM 0x2


//=========================================================================
//  PROTOCOL IDs
//=========================================================================
//
#define MDM_PROTOCOLID_DEFAULT 0x0
#define MDM_PROTOCOLID_HDLCPPP 0x1
#define MDM_PROTOCOLID_V128 0x2
#define MDM_PROTOCOLID_X75 0x3
#define MDM_PROTOCOLID_V110 0x4
#define MDM_PROTOCOLID_V120 0x5
#define MDM_PROTOCOLID_AUTO 0x6
#define MDM_PROTOCOLID_ANALOG 0x7
#define MDM_PROTOCOLID_GPRS 0x8
#define MDM_PROTOCOLID_PIAFS 0x9


//=========================================================================
//  HDLC PPP PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to the HDLC-PPP protocol.
// The shifts are w.r.t. the start of the PROTOCOLDATA field.

#define MDM_SHIFT_HDLCPPP_SPEED 0x0
#define MDM_MASK_HDLCPPP_SPEED 0x7

#define MDM_HDLCPPP_SPEED_DEFAULT 0x0
#define MDM_HDLCPPP_SPEED_64K 0x1
#define MDM_HDLCPPP_SPEED_56K 0x2


#define MDM_SHIFT_HDLCPPP_AUTH 0x3
#define MDM_MASK_HDLCPPP_AUTH (0x7<<3)

#define MDM_HDLCPPP_AUTH_DEFAULT 0x0
#define MDM_HDLCPPP_AUTH_NONE 0x1
#define MDM_HDLCPPP_AUTH_PAP 0x2
#define MDM_HDLCPPP_AUTH_CHAP 0x3
#define MDM_HDLCPPP_AUTH_MSCHAP 0x4


#define MDM_SHIFT_HDLCPPP_ML 0x6
#define MDM_MASK_HDLCPPP_ML (0x3<<6)

#define MDM_HDLCPPP_ML_DEFAULT 0x0
#define MDM_HDLCPPP_ML_NONE 0x1
#define MDM_HDLCPPP_ML_2 0x2

#define MDM_GEN_HDLCPPP_PROTOCOL_DATA(_speed,_auth,_ml) ((((_speed)<<MDM_SHIFT_HDLCPPP_SPEED)&MDM_MASK_HDLCPPP_SPEED) |(((_auth )<<MDM_SHIFT_HDLCPPP_AUTH )&MDM_MASK_HDLCPPP_AUTH ) |(((_ml )<<MDM_SHIFT_HDLCPPP_ML )&MDM_MASK_HDLCPPP_ML ))





#define MDM_PROTOCOL_HDLCPPP_64K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_DEFAULT ) )
# 285 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_56K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_DEFAULT ) )
# 295 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_112K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_2 ) )
# 305 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_112K_PAP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_PAP, MDM_HDLCPPP_ML_2 ) )
# 315 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_112K_CHAP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_CHAP, MDM_HDLCPPP_ML_2 ) )
# 325 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_112K_MSCHAP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_56K, MDM_HDLCPPP_AUTH_MSCHAP, MDM_HDLCPPP_ML_2 ) )
# 334 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_128K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_DEFAULT, MDM_HDLCPPP_ML_2 ) )
# 344 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_128K_PAP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_PAP, MDM_HDLCPPP_ML_2 ) )
# 354 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_128K_CHAP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_CHAP, MDM_HDLCPPP_ML_2 ) )
# 364 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_HDLCPPP_128K_MSCHAP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_HDLCPPP, MDM_GEN_HDLCPPP_PROTOCOL_DATA ( MDM_HDLCPPP_SPEED_64K, MDM_HDLCPPP_AUTH_MSCHAP, MDM_HDLCPPP_ML_2 ) )
# 374 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  V120 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================

#define MDM_SHIFT_V120_SPEED 0x0
#define MDM_MASK_V120_SPEED 0x7

#define MDM_V120_SPEED_DEFAULT 0x0
#define MDM_V120_SPEED_64K 0x1
#define MDM_V120_SPEED_56K 0x2


#define MDM_SHIFT_V120_ML 0x6
#define MDM_MASK_V120_ML (0x3<<6)

#define MDM_V120_ML_DEFAULT 0x0
#define MDM_V120_ML_NONE 0x1
#define MDM_V120_ML_2 0x2


#define MDM_GEN_V120_PROTOCOL_DATA(_speed,_ml) ((((_speed)<<MDM_SHIFT_V120_SPEED)&MDM_MASK_V120_SPEED) |(((_ml )<<MDM_SHIFT_V120_ML )&MDM_MASK_V120_ML ))




#define MDM_PROTOCOL_V120_64K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_64K, MDM_V120_ML_NONE ) )
# 411 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_V120_56K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_56K, MDM_V120_ML_NONE ) )
# 420 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_V120_112K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_56K, MDM_V120_ML_2 ) )
# 429 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_V120_128K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V120, MDM_GEN_V120_PROTOCOL_DATA ( MDM_V120_SPEED_64K, MDM_V120_ML_2 ) )
# 439 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  X75 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================


#define MDM_SHIFT_X75_DATA 0x0
#define MDM_MASK_X75_DATA 0x7

#define MDM_X75_DATA_DEFAULT 0x0
#define MDM_X75_DATA_64K 0x1
#define MDM_X75_DATA_128K 0x2
#define MDM_X75_DATA_T_70 0x3
#define MDM_X75_DATA_BTX 0x4

#define MDM_GEN_X75_PROTOCOL_DATA(_data) (((_data)<<MDM_SHIFT_X75_DATA)&MDM_MASK_X75_DATA)



#define MDM_PROTOCOL_X75_64K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_64K ) )







#define MDM_PROTOCOL_X75_128K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_128K ) )







#define MDM_PROTOCOL_X75_T_70 MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_T_70 ) )







#define MDM_PROTOCOL_X75_BTX MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_X75, MDM_GEN_X75_PROTOCOL_DATA ( MDM_X75_DATA_BTX ) )
# 493 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  V110 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================


#define MDM_SHIFT_V110_SPEED 0x0
#define MDM_MASK_V110_SPEED 0xf

#define MDM_V110_SPEED_DEFAULT 0x0
#define MDM_V110_SPEED_1DOT2K 0x1
#define MDM_V110_SPEED_2DOT4K 0x2
#define MDM_V110_SPEED_4DOT8K 0x3
#define MDM_V110_SPEED_9DOT6K 0x4
#define MDM_V110_SPEED_12DOT0K 0x5
#define MDM_V110_SPEED_14DOT4K 0x6
#define MDM_V110_SPEED_19DOT2K 0x7
#define MDM_V110_SPEED_28DOT8K 0x8
#define MDM_V110_SPEED_38DOT4K 0x9
#define MDM_V110_SPEED_57DOT6K 0xA

#define MDM_GEN_V110_PROTOCOL_DATA(_data) (((_data)<<MDM_SHIFT_V110_SPEED)&MDM_MASK_V110_SPEED)



#define MDM_PROTOCOL_V110_1DOT2K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_1DOT2K ) )







#define MDM_PROTOCOL_V110_2DOT4K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_2DOT4K ) )







#define MDM_PROTOCOL_V110_4DOT8K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_4DOT8K ) )







#define MDM_PROTOCOL_V110_9DOT6K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_9DOT6K ) )







#define MDM_PROTOCOL_V110_12DOT0K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_12DOT0K ) )







#define MDM_PROTOCOL_V110_14DOT4K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_14DOT4K ) )







#define MDM_PROTOCOL_V110_19DOT2K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_19DOT2K ) )







#define MDM_PROTOCOL_V110_28DOT8K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_28DOT8K ) )







#define MDM_PROTOCOL_V110_38DOT4K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_38DOT4K ) )







#define MDM_PROTOCOL_V110_57DOT6K MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_V110, MDM_GEN_V110_PROTOCOL_DATA ( MDM_V110_SPEED_57DOT6K ) )







//=========================================================================
//  AUTO PROTOCOL INFORMATION (ie, when the protocol is detected automatically)
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
//
// Following are specific to the AUTO-protocol
//

#define MDM_SHIFT_AUTO_SPEED 0x0
#define MDM_MASK_AUTO_SPEED 0x7
#define MDM_AUTO_SPEED_DEFAULT 0x0

#define MDM_SHIFT_AUTO_ML 0x6
#define MDM_MASK_AUTO_ML (0x3<<6)
#define MDM_AUTO_ML_DEFAULT 0x0
#define MDM_AUTO_ML_NONE 0x1
#define MDM_AUTO_ML_2 0x2

#define MDM_GEN_AUTO_PROTOCOL_DATA(_speed,_ml) ((((_speed)<<MDM_SHIFT_AUTO_SPEED)&MDM_MASK_AUTO_SPEED) |(((_ml )<<MDM_SHIFT_AUTO_ML )&MDM_MASK_AUTO_ML))




#define MDM_PROTOCOL_AUTO_1CH MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_AUTO, MDM_GEN_AUTO_PROTOCOL_DATA ( MDM_AUTO_SPEED_DEFAULT, MDM_AUTO_ML_NONE ) )
# 634 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
#define MDM_PROTOCOL_AUTO_2CH MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_AUTO, MDM_GEN_AUTO_PROTOCOL_DATA ( MDM_AUTO_SPEED_DEFAULT, MDM_AUTO_ML_2 ) )
# 643 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  ANALOG PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GSM Analog protocol
//

#define MDM_ANALOG_RLP_ON 0x0
#define MDM_ANALOG_RLP_OFF 0x1
#define MDM_ANALOG_V34 0x2

#define MDM_GEN_ANALOG_PROTOCOL_DATA(_rlp) (_rlp)



#define MDM_PROTOCOL_ANALOG_RLP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_ANALOG, MDM_GEN_ANALOG_PROTOCOL_DATA ( MDM_ANALOG_RLP_ON ) )







#define MDM_PROTOCOL_ANALOG_NRLP MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_ANALOG, MDM_GEN_ANALOG_PROTOCOL_DATA ( MDM_ANALOG_RLP_OFF ) )







//
//  v34 anolog for isdn
//
#define MDM_PROTOCOL_ANALOG_V34 MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_ANALOG, MDM_GEN_ANALOG_PROTOCOL_DATA ( MDM_ANALOG_V34 ) )
# 686 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/mcx.h"
//=========================================================================
//  GPRS PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GPRS protocol
//

#define MDM_PROTOCOL_GPRS MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_GPRS, 0 )






//=========================================================================
//  PIAFS PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to PIAFS protocol
//

#define MDM_PIAFS_INCOMING 0
#define MDM_PIAFS_OUTGOING 1

#define MDM_PROTOCOL_PIAFS_INCOMING MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_PIAFS, MDM_PIAFS_INCOMING )





#define MDM_PROTOCOL_PIAFS_OUTGOING MDM_GEN_PROTOCOLINFO( MDM_PROTOCOLID_PIAFS, MDM_PIAFS_OUTGOING )
# 227 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2



# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/imm.h" 1
/**********************************************************************/
/*      imm.h - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) Microsoft Corporation. All rights reserved.     */
/**********************************************************************/


#define _IMM_ 
# 17 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/imm.h"
#define _IMM_SDK_DEFINED_ 


struct HIMC__{int unused;}; typedef struct HIMC__ *HIMC;
struct HIMCC__{int unused;}; typedef struct HIMCC__ *HIMCC;





typedef HKL *LPHKL;
typedef UINT *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, *NPCOMPOSITIONFORM, *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, *NPCANDIDATEFORM, *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, *NPCANDIDATELIST, *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR lpReading;
    LPSTR lpWord;
} REGISTERWORDA, *PREGISTERWORDA, *NPREGISTERWORDA, *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR lpReading;
    LPWSTR lpWord;
} REGISTERWORDW, *PREGISTERWORDW, *NPREGISTERWORDW, *LPREGISTERWORDW;






typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;




typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, *NPRECONVERTSTRING, *LPRECONVERTSTRING;



#define STYLE_DESCRIPTION_SIZE 32

typedef struct tagSTYLEBUFA {
    DWORD dwStyle;
    CHAR szDescription[32];
} STYLEBUFA, *PSTYLEBUFA, *NPSTYLEBUFA, *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD dwStyle;
    WCHAR szDescription[32];
} STYLEBUFW, *PSTYLEBUFW, *NPSTYLEBUFW, *LPSTYLEBUFW;






typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;





#define IMEMENUITEM_STRING_SIZE 80

typedef struct tagIMEMENUITEMINFOA {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[80];
    HBITMAP hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, *NPIMEMENUITEMINFOA, *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[80];
    HBITMAP hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, *NPIMEMENUITEMINFOW, *LPIMEMENUITEMINFOW;






typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;


typedef struct tagIMECHARPOSITION {
    DWORD dwSize;
    DWORD dwCharPos;
    POINT pt;
    UINT cLineHeight;
    RECT rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, *NPIMECHARPOSITION, *LPIMECHARPOSITION;

typedef BOOL (* IMCENUMPROC)(HIMC, LPARAM);





// prototype of IMM API

HKL ImmInstallIMEA( LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL ImmInstallIMEW( LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);



#define ImmInstallIME ImmInstallIMEA


HWND ImmGetDefaultIMEWnd( HWND);

UINT ImmGetDescriptionA( HKL, LPSTR lpszDescription, UINT uBufLen);
UINT ImmGetDescriptionW( HKL, LPWSTR lpszDescription, UINT uBufLen);



#define ImmGetDescription ImmGetDescriptionA


UINT ImmGetIMEFileNameA( HKL, LPSTR lpszFileName, UINT uBufLen);
UINT ImmGetIMEFileNameW( HKL, LPWSTR lpszFileName, UINT uBufLen);



#define ImmGetIMEFileName ImmGetIMEFileNameA


DWORD ImmGetProperty( HKL, DWORD);

BOOL ImmIsIME( HKL);

BOOL ImmSimulateHotKey( HWND, DWORD);

HIMC ImmCreateContext(void);
BOOL ImmDestroyContext( HIMC);
HIMC ImmGetContext( HWND);
BOOL ImmReleaseContext( HWND, HIMC);
HIMC ImmAssociateContext( HWND, HIMC);

BOOL ImmAssociateContextEx( HWND, HIMC, DWORD);


LONG ImmGetCompositionStringA( HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);
LONG ImmGetCompositionStringW( HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);



#define ImmGetCompositionString ImmGetCompositionStringA


BOOL ImmSetCompositionStringA( HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
BOOL ImmSetCompositionStringW( HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);



#define ImmSetCompositionString ImmSetCompositionStringA


DWORD ImmGetCandidateListCountA( HIMC, LPDWORD lpdwListCount);
DWORD ImmGetCandidateListCountW( HIMC, LPDWORD lpdwListCount);



#define ImmGetCandidateListCount ImmGetCandidateListCountA


DWORD ImmGetCandidateListA( HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);
DWORD ImmGetCandidateListW( HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);



#define ImmGetCandidateList ImmGetCandidateListA


DWORD ImmGetGuideLineA( HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen);
DWORD ImmGetGuideLineW( HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen);



#define ImmGetGuideLine ImmGetGuideLineA


BOOL ImmGetConversionStatus( HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence);
BOOL ImmSetConversionStatus( HIMC, DWORD, DWORD);
BOOL ImmGetOpenStatus( HIMC);
BOOL ImmSetOpenStatus( HIMC, BOOL);


BOOL ImmGetCompositionFontA( HIMC, LPLOGFONTA lplf);
BOOL ImmGetCompositionFontW( HIMC, LPLOGFONTW lplf);



#define ImmGetCompositionFont ImmGetCompositionFontA


BOOL ImmSetCompositionFontA( HIMC, LPLOGFONTA lplf);
BOOL ImmSetCompositionFontW( HIMC, LPLOGFONTW lplf);



#define ImmSetCompositionFont ImmSetCompositionFontA



BOOL ImmConfigureIMEA( HKL, HWND, DWORD, LPVOID);
BOOL ImmConfigureIMEW( HKL, HWND, DWORD, LPVOID);



#define ImmConfigureIME ImmConfigureIMEA


LRESULT ImmEscapeA( HKL, HIMC, UINT, LPVOID);
LRESULT ImmEscapeW( HKL, HIMC, UINT, LPVOID);



#define ImmEscape ImmEscapeA


DWORD ImmGetConversionListA( HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);
DWORD ImmGetConversionListW( HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);



#define ImmGetConversionList ImmGetConversionListA


BOOL ImmNotifyIME( HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

BOOL ImmGetStatusWindowPos( HIMC, LPPOINT lpptPos);
BOOL ImmSetStatusWindowPos( HIMC, LPPOINT lpptPos);
BOOL ImmGetCompositionWindow( HIMC, LPCOMPOSITIONFORM lpCompForm);
BOOL ImmSetCompositionWindow( HIMC, LPCOMPOSITIONFORM lpCompForm);
BOOL ImmGetCandidateWindow( HIMC, DWORD, LPCANDIDATEFORM lpCandidate);
BOOL ImmSetCandidateWindow( HIMC, LPCANDIDATEFORM lpCandidate);

BOOL ImmIsUIMessageA( HWND, UINT, WPARAM, LPARAM);
BOOL ImmIsUIMessageW( HWND, UINT, WPARAM, LPARAM);



#define ImmIsUIMessage ImmIsUIMessageA



UINT ImmGetVirtualKey( HWND);

typedef int ( *REGISTERWORDENUMPROCA)( LPCSTR lpszReading, DWORD, LPCSTR lpszString, LPVOID);
typedef int ( *REGISTERWORDENUMPROCW)( LPCWSTR lpszReading, DWORD, LPCWSTR lpszString, LPVOID);



#define REGISTERWORDENUMPROC REGISTERWORDENUMPROCA


BOOL ImmRegisterWordA( HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
BOOL ImmRegisterWordW( HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);



#define ImmRegisterWord ImmRegisterWordA


BOOL ImmUnregisterWordA( HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
BOOL ImmUnregisterWordW( HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);



#define ImmUnregisterWord ImmUnregisterWordA


UINT ImmGetRegisterWordStyleA( HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
UINT ImmGetRegisterWordStyleW( HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);



#define ImmGetRegisterWordStyle ImmGetRegisterWordStyleA


UINT ImmEnumRegisterWordA( HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
UINT ImmEnumRegisterWordW( HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);



#define ImmEnumRegisterWord ImmEnumRegisterWordA



BOOL ImmDisableIME( DWORD);
BOOL ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD ImmGetImeMenuItemsA( HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize);
DWORD ImmGetImeMenuItemsW( HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize);



#define ImmGetImeMenuItems ImmGetImeMenuItemsA


BOOL ImmDisableTextFrameService(DWORD idThread);


// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS 0x0007
#define IMC_SETCANDIDATEPOS 0x0008
#define IMC_GETCOMPOSITIONFONT 0x0009
#define IMC_SETCOMPOSITIONFONT 0x000A
#define IMC_GETCOMPOSITIONWINDOW 0x000B
#define IMC_SETCOMPOSITIONWINDOW 0x000C
#define IMC_GETSTATUSWINDOWPOS 0x000F
#define IMC_SETSTATUSWINDOWPOS 0x0010
#define IMC_CLOSESTATUSWINDOW 0x0021
#define IMC_OPENSTATUSWINDOW 0x0022


// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE 0x0010
#define NI_CLOSECANDIDATE 0x0011
#define NI_SELECTCANDIDATESTR 0x0012
#define NI_CHANGECANDIDATELIST 0x0013
#define NI_FINALIZECONVERSIONRESULT 0x0014
#define NI_COMPOSITIONSTR 0x0015
#define NI_SETCANDIDATE_PAGESTART 0x0016
#define NI_SETCANDIDATE_PAGESIZE 0x0017
#define NI_IMEMENUSELECTED 0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW 0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW 0x80000000
#define ISC_SHOWUIGUIDELINE 0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW 0x0000000F
#define ISC_SHOWUIALL 0xC000000F


// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE 0x0001
#define CPS_CONVERT 0x0002
#define CPS_REVERT 0x0003
#define CPS_CANCEL 0x0004

// the modifiers of hot key
#define MOD_ALT 0x0001
#define MOD_CONTROL 0x0002
#define MOD_SHIFT 0x0004

#define MOD_LEFT 0x8000
#define MOD_RIGHT 0x4000

#define MOD_ON_KEYUP 0x0800
#define MOD_IGNORE_ALL_MODIFIER 0x0400


// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE 0x10
#define IME_CHOTKEY_SHAPE_TOGGLE 0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE 0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN 0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE 0x50
#define IME_KHOTKEY_HANJACONVERT 0x51
#define IME_KHOTKEY_ENGLISH 0x52

// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE 0x70
#define IME_THOTKEY_SHAPE_TOGGLE 0x71
#define IME_THOTKEY_SYMBOL_TOGGLE 0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST 0x100
#define IME_HOTKEY_DSWITCH_LAST 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST 0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR 0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION 0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE 0x202
#define IME_ITHOTKEY_RECONVERTSTRING 0x203
#define IME_HOTKEY_PRIVATE_LAST 0x21F


// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR 0x0001
#define GCS_COMPREADATTR 0x0002
#define GCS_COMPREADCLAUSE 0x0004
#define GCS_COMPSTR 0x0008
#define GCS_COMPATTR 0x0010
#define GCS_COMPCLAUSE 0x0020
#define GCS_CURSORPOS 0x0080
#define GCS_DELTASTART 0x0100
#define GCS_RESULTREADSTR 0x0200
#define GCS_RESULTREADCLAUSE 0x0400
#define GCS_RESULTSTR 0x0800
#define GCS_RESULTCLAUSE 0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR 0x2000
#define CS_NOMOVECARET 0x4000

// IME version constants
#define IMEVER_0310 0x0003000A
#define IMEVER_0400 0x00040000


// IME property bits
#define IME_PROP_AT_CARET 0x00010000
#define IME_PROP_SPECIAL_UI 0x00020000
#define IME_PROP_CANDLIST_START_FROM_1 0x00040000
#define IME_PROP_UNICODE 0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT 0x00100000


// IME UICapability bits
#define UI_CAP_2700 0x00000001
#define UI_CAP_ROT90 0x00000002
#define UI_CAP_ROTANY 0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR 0x00000001
#define SCS_CAP_MAKEREAD 0x00000002
#define SCS_CAP_SETRECONVERTSTRING 0x00000004


// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION 0x00000001
#define SELECT_CAP_SENTENCE 0x00000002


// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL 0x00000001
#define GGL_INDEX 0x00000002
#define GGL_STRING 0x00000003
#define GGL_PRIVATE 0x00000004


// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE 0x00000000
#define GL_LEVEL_FATAL 0x00000001
#define GL_LEVEL_ERROR 0x00000002
#define GL_LEVEL_WARNING 0x00000003
#define GL_LEVEL_INFORMATION 0x00000004


// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN 0x00000000
#define GL_ID_NOMODULE 0x00000001
#define GL_ID_NODICTIONARY 0x00000010
#define GL_ID_CANNOTSAVE 0x00000011
#define GL_ID_NOCONVERT 0x00000020
#define GL_ID_TYPINGERROR 0x00000021
#define GL_ID_TOOMANYSTROKE 0x00000022
#define GL_ID_READINGCONFLICT 0x00000023
#define GL_ID_INPUTREADING 0x00000024
#define GL_ID_INPUTRADICAL 0x00000025
#define GL_ID_INPUTCODE 0x00000026
#define GL_ID_INPUTSYMBOL 0x00000027
#define GL_ID_CHOOSECANDIDATE 0x00000028
#define GL_ID_REVERSECONVERSION 0x00000029
#define GL_ID_PRIVATE_FIRST 0x00008000
#define GL_ID_PRIVATE_LAST 0x0000FFFF


// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION (DWORD)(-4)
#define IGP_PROPERTY 0x00000004
#define IGP_CONVERSION 0x00000008
#define IGP_SENTENCE 0x0000000c
#define IGP_UI 0x00000010
#define IGP_SETCOMPSTR 0x00000014
#define IGP_SELECT 0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING 0x00010000
#define SCS_QUERYRECONVERTSTRING 0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT 0x00
#define ATTR_TARGET_CONVERTED 0x01
#define ATTR_CONVERTED 0x02
#define ATTR_TARGET_NOTCONVERTED 0x03
#define ATTR_INPUT_ERROR 0x04
#define ATTR_FIXEDCONVERTED 0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT 0x0000
#define CFS_RECT 0x0001
#define CFS_POINT 0x0002
#define CFS_FORCE_POSITION 0x0020
#define CFS_CANDIDATEPOS 0x0040
#define CFS_EXCLUDE 0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION 0x0001
#define GCL_REVERSECONVERSION 0x0002
#define GCL_REVERSE_LENGTH 0x0003


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ime_cmodes.h" 1
       


#define _IME_CMODES_ 

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC 0x0000
#define IME_CMODE_NATIVE 0x0001
#define IME_CMODE_CHINESE IME_CMODE_NATIVE
#define IME_CMODE_HANGUL IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA 0x0002
#define IME_CMODE_LANGUAGE 0x0003
#define IME_CMODE_FULLSHAPE 0x0008
#define IME_CMODE_ROMAN 0x0010
#define IME_CMODE_CHARCODE 0x0020
#define IME_CMODE_HANJACONVERT 0x0040
# 570 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/imm.h" 2

// bit field for conversion mode
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
#define IME_CMODE_HANGEUL IME_CMODE_NATIVE
#define IME_CMODE_SOFTKBD 0x0080
#define IME_CMODE_NOCONVERSION 0x0100
#define IME_CMODE_EUDC 0x0200
#define IME_CMODE_SYMBOL 0x0400
#define IME_CMODE_FIXED 0x0800
#define IME_CMODE_RESERVED 0xF0000000

// bit field for sentence mode
#define IME_SMODE_NONE 0x0000
#define IME_SMODE_PLAURALCLAUSE 0x0001
#define IME_SMODE_SINGLECONVERT 0x0002
#define IME_SMODE_AUTOMATIC 0x0004
#define IME_SMODE_PHRASEPREDICT 0x0008
#define IME_SMODE_CONVERSATION 0x0010
#define IME_SMODE_RESERVED 0x0000F000


// style of candidate
#define IME_CAND_UNKNOWN 0x0000
#define IME_CAND_READ 0x0001
#define IME_CAND_CODE 0x0002
#define IME_CAND_MEANING 0x0003
#define IME_CAND_RADICAL 0x0004
#define IME_CAND_STROKE 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW 0x0001
#define IMN_OPENSTATUSWINDOW 0x0002
#define IMN_CHANGECANDIDATE 0x0003
#define IMN_CLOSECANDIDATE 0x0004
#define IMN_OPENCANDIDATE 0x0005
#define IMN_SETCONVERSIONMODE 0x0006
#define IMN_SETSENTENCEMODE 0x0007
#define IMN_SETOPENSTATUS 0x0008
#define IMN_SETCANDIDATEPOS 0x0009
#define IMN_SETCOMPOSITIONFONT 0x000A
#define IMN_SETCOMPOSITIONWINDOW 0x000B
#define IMN_SETSTATUSWINDOWPOS 0x000C
#define IMN_GUIDELINE 0x000D
#define IMN_PRIVATE 0x000E


// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW 0x0001
#define IMR_CANDIDATEWINDOW 0x0002
#define IMR_COMPOSITIONFONT 0x0003
#define IMR_RECONVERTSTRING 0x0004
#define IMR_CONFIRMRECONVERTSTRING 0x0005
#define IMR_QUERYCHARPOSITION 0x0006
#define IMR_DOCUMENTFEED 0x0007


// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA (-1)
#define IMM_ERROR_GENERAL (-2)


// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL 1
#define IME_CONFIG_REGISTERWORD 2
#define IME_CONFIG_SELECTDICTIONARY 3


// flags for ImmEscape
#define IME_ESC_QUERY_SUPPORT 0x0003
#define IME_ESC_RESERVED_FIRST 0x0004
#define IME_ESC_RESERVED_LAST 0x07FF
#define IME_ESC_PRIVATE_FIRST 0x0800
#define IME_ESC_PRIVATE_LAST 0x0FFF

#define IME_ESC_SEQUENCE_TO_INTERNAL 0x1001
#define IME_ESC_GET_EUDC_DICTIONARY 0x1003
#define IME_ESC_SET_EUDC_DICTIONARY 0x1004
#define IME_ESC_MAX_KEY 0x1005
#define IME_ESC_IME_NAME 0x1006
#define IME_ESC_SYNC_HOTKEY 0x1007
#define IME_ESC_HANJA_MODE 0x1008
#define IME_ESC_AUTOMATA 0x1009
#define IME_ESC_PRIVATE_HOTKEY 0x100a
#define IME_ESC_GETHELPFILENAME 0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC 0x00000001
#define IME_REGWORD_STYLE_USER_FIRST 0x80000000
#define IME_REGWORD_STYLE_USER_LAST 0xFFFFFFFF




// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN 0x0001
#define IACE_DEFAULT 0x0010
#define IACE_IGNORENOCONTEXT 0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU 0x0001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE 0x0001
#define IGIMII_SMODE 0x0002
#define IGIMII_CONFIGURE 0x0004
#define IGIMII_TOOLS 0x0008
#define IGIMII_HELP 0x0010
#define IGIMII_OTHER 0x0020
#define IGIMII_INPUTTOOLS 0x0040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR 0x00002
#define IMFT_SUBMENU 0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED MFS_GRAYED
#define IMFS_DISABLED MFS_DISABLED
#define IMFS_CHECKED MFS_CHECKED
#define IMFS_HILITE MFS_HILITE
#define IMFS_ENABLED MFS_ENABLED
#define IMFS_UNCHECKED MFS_UNCHECKED
#define IMFS_UNHILITE MFS_UNHILITE
#define IMFS_DEFAULT MFS_DEFAULT



// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1 0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1 0x0002
# 231 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/windows.h" 2
# 67 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 2


/*

 * Define the current Winsock version. To build an earlier Winsock version

 * application redefine this value prior to including Winsock2.h.

 */




#define WINSOCK_VERSION MAKEWORD(2,2)


/*

 * Establish DLL function linkage if supported by the current build

 * environment and not previously defined.

 */
#define WINSOCK_API_LINKAGE DECLSPEC_IMPORT
# 100 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*

 * Basic system type definitions, taken from the BSD file sys/types.h.

 */
# 103 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef unsigned __int64 u_int64;


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h" 1
/*++



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    ws2def.h



Abstract:

 

    This file contains the core definitions for the Winsock2

    specification that can be used by both user-mode and 

    kernel mode modules.



    This file is included in WINSOCK2.H. User mode applications

    should include WINSOCK2.H rather than including this file

    directly. This file can not be included by a module that also

    includes WINSOCK.H.

 

Environment:



    user mode or kernel mode



--*/
# 27 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define _WS2DEF_ 
# 41 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214)

//
// Allow Winsock components to disable PREfast errors.
//
# 58 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define WS2DEF_INLINE extern inline




# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/inaddr.h" 1
/*++



Copyright (c) Microsoft Corporation



Module Name:



    inaddr.h



Environment:



    user mode or kernel mode



--*/
# 16 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/inaddr.h"
       

//
// IPv4 Internet address
// This is an 'on-wire' format structure.
//
typedef struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
#define s_addr S_un.S_addr
#define s_host S_un.S_un_b.s_b2
#define s_net S_un.S_un_b.s_b1
#define s_imp S_un.S_un_w.s_w2
#define s_impno S_un.S_un_b.s_b4
#define s_lh S_un.S_un_b.s_b3
} IN_ADDR, *PIN_ADDR, *LPIN_ADDR;
# 64 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h" 2

//#if(_WIN32_WINNT >= 0x0600)

//
// Address families.
//

typedef USHORT ADDRESS_FAMILY;

//#endif//(_WIN32_WINNT >= 0x0600)

//
// Although AF_UNSPEC is defined for backwards compatibility, using
// AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
// DISCOURAGED.  The interpretation of the "protocol" parameter
// depends on the actual address family chosen.  As environments grow
// to include more and more address families that use overlapping
// protocol values there is more and more chance of choosing an
// undesired address family when AF_UNSPEC is used.
//
#define AF_UNSPEC 0
#define AF_UNIX 1
#define AF_INET 2
#define AF_IMPLINK 3
#define AF_PUP 4
#define AF_CHAOS 5
#define AF_NS 6
#define AF_IPX AF_NS
#define AF_ISO 7
#define AF_OSI AF_ISO
#define AF_ECMA 8
#define AF_DATAKIT 9
#define AF_CCITT 10
#define AF_SNA 11
#define AF_DECnet 12
#define AF_DLI 13
#define AF_LAT 14
#define AF_HYLINK 15
#define AF_APPLETALK 16
#define AF_NETBIOS 17
#define AF_VOICEVIEW 18
#define AF_FIREFOX 19
#define AF_UNKNOWN1 20
#define AF_BAN 21
#define AF_ATM 22
#define AF_INET6 23
#define AF_CLUSTER 24
#define AF_12844 25
#define AF_IRDA 26
#define AF_NETDES 28





#define AF_TCNPROCESS 29
#define AF_TCNMESSAGE 30
#define AF_ICLFXBM 31




#define AF_BTH 32



#define AF_LINK 33
#define AF_MAX 34





//
// Socket types.
//

#define SOCK_STREAM 1
#define SOCK_DGRAM 2
#define SOCK_RAW 3
#define SOCK_RDM 4
#define SOCK_SEQPACKET 5

//
// Define a level for socket I/O controls in the same numbering space as
// IPPROTO_TCP, IPPROTO_IP, etc.
//

#define SOL_SOCKET 0xffff

//
// Define socket-level options.
//

#define SO_DEBUG 0x0001
#define SO_ACCEPTCONN 0x0002
#define SO_REUSEADDR 0x0004
#define SO_KEEPALIVE 0x0008
#define SO_DONTROUTE 0x0010
#define SO_BROADCAST 0x0020
#define SO_USELOOPBACK 0x0040
#define SO_LINGER 0x0080
#define SO_OOBINLINE 0x0100

#define SO_DONTLINGER (int)(~SO_LINGER)
#define SO_EXCLUSIVEADDRUSE ((int)(~SO_REUSEADDR))


#define SO_SNDBUF 0x1001
#define SO_RCVBUF 0x1002
#define SO_SNDLOWAT 0x1003
#define SO_RCVLOWAT 0x1004
#define SO_SNDTIMEO 0x1005
#define SO_RCVTIMEO 0x1006
#define SO_ERROR 0x1007
#define SO_TYPE 0x1008
#define SO_BSP_STATE 0x1009

#define SO_GROUP_ID 0x2001
#define SO_GROUP_PRIORITY 0x2002
#define SO_MAX_MSG_SIZE 0x2003

#define SO_CONDITIONAL_ACCEPT 0x3002
                                    // connection is not ack-ed to the
                                    // other side until conditional
                                    // function returns CF_ACCEPT
#define SO_PAUSE_ACCEPT 0x3003
#define SO_COMPARTMENT_ID 0x3004

#define SO_RANDOMIZE_PORT 0x3005
#define SO_PORT_SCALABILITY 0x3006


//
// Base constant used for defining WSK-specific options.
//

#define WSK_SO_BASE 0x4000

//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
//

#define TCP_NODELAY 0x0001

//
// Structure used to store most addresses.
//
typedef struct sockaddr {




    ADDRESS_FAMILY sa_family; // Address family.


    CHAR sa_data[14]; // Up to 14 bytes of direct address.
} SOCKADDR, *PSOCKADDR, *LPSOCKADDR;


#define __CSADDR_DEFINED__ 


/*

 * SockAddr Information

 */
# 230 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr;
    INT iSockaddrLength;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, *LPSOCKET_ADDRESS;

/*

 * Address list returned via SIO_ADDRESS_LIST_QUERY

 */
# 238 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _SOCKET_ADDRESS_LIST {
    INT iAddressCount;
    SOCKET_ADDRESS Address[1];
} SOCKET_ADDRESS_LIST, *PSOCKET_ADDRESS_LIST, *LPSOCKET_ADDRESS_LIST;



#define SIZEOF_SOCKET_ADDRESS_LIST(AddressCount) (FIELD_OFFSET(SOCKET_ADDRESS_LIST, Address) + AddressCount * sizeof(SOCKET_ADDRESS))





/*

 * CSAddr Information

 */
# 254 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO, * LPCSADDR_INFO ;


//
// Portable socket structure (RFC 2553).
//

//
// Desired design of maximum size and alignment.
// These are implementation specific.
//
#define _SS_MAXSIZE 128
#define _SS_ALIGNSIZE (sizeof(__int64))

//
// Definitions used for sockaddr_storage structure paddings design.
//


#define _SS_PAD1SIZE (_SS_ALIGNSIZE - sizeof(USHORT))
#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof(USHORT) + _SS_PAD1SIZE + _SS_ALIGNSIZE))






typedef struct sockaddr_storage {
    ADDRESS_FAMILY ss_family; // address family

    CHAR __ss_pad1[((sizeof(__int64)) - sizeof(USHORT))]; // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align; // Field to force desired structure
    CHAR __ss_pad2[(128 - (sizeof(USHORT) + ((sizeof(__int64)) - sizeof(USHORT)) + (sizeof(__int64))))]; // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_LH, *PSOCKADDR_STORAGE_LH, *LPSOCKADDR_STORAGE_LH;

typedef struct sockaddr_storage_xp {
    short ss_family; // Address family.

    CHAR __ss_pad1[((sizeof(__int64)) - sizeof(USHORT))]; // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align; // Field to force desired structure
    CHAR __ss_pad2[(128 - (sizeof(USHORT) + ((sizeof(__int64)) - sizeof(USHORT)) + (sizeof(__int64))))]; // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_XP, *PSOCKADDR_STORAGE_XP, *LPSOCKADDR_STORAGE_XP;



typedef SOCKADDR_STORAGE_LH SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, *LPSOCKADDR_STORAGE;






/*

 * WinSock 2 extension -- manifest constants for WSAIoctl()

 */
# 327 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define IOC_UNIX 0x00000000
#define IOC_WS2 0x08000000
#define IOC_PROTOCOL 0x10000000
#define IOC_VENDOR 0x18000000


/*

 * WSK-specific IO control codes are Winsock2 codes with the highest-order

 * 3 bits of the Vendor/AddressFamily-specific field set to 1.

 */
# 337 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define IOC_WSK (IOC_WS2|0x07000000)


#define _WSAIO(x,y) (IOC_VOID|(x)|(y))
#define _WSAIOR(x,y) (IOC_OUT|(x)|(y))
#define _WSAIOW(x,y) (IOC_IN|(x)|(y))
#define _WSAIORW(x,y) (IOC_INOUT|(x)|(y))

#define SIO_ASSOCIATE_HANDLE _WSAIOW(IOC_WS2,1)
#define SIO_ENABLE_CIRCULAR_QUEUEING _WSAIO(IOC_WS2,2)
#define SIO_FIND_ROUTE _WSAIOR(IOC_WS2,3)
#define SIO_FLUSH _WSAIO(IOC_WS2,4)
#define SIO_GET_BROADCAST_ADDRESS _WSAIOR(IOC_WS2,5)
#define SIO_GET_EXTENSION_FUNCTION_POINTER _WSAIORW(IOC_WS2,6)
#define SIO_GET_QOS _WSAIORW(IOC_WS2,7)
#define SIO_GET_GROUP_QOS _WSAIORW(IOC_WS2,8)
#define SIO_MULTIPOINT_LOOPBACK _WSAIOW(IOC_WS2,9)
#define SIO_MULTICAST_SCOPE _WSAIOW(IOC_WS2,10)
#define SIO_SET_QOS _WSAIOW(IOC_WS2,11)
#define SIO_SET_GROUP_QOS _WSAIOW(IOC_WS2,12)
#define SIO_TRANSLATE_HANDLE _WSAIORW(IOC_WS2,13)
#define SIO_ROUTING_INTERFACE_QUERY _WSAIORW(IOC_WS2,20)
#define SIO_ROUTING_INTERFACE_CHANGE _WSAIOW(IOC_WS2,21)
#define SIO_ADDRESS_LIST_QUERY _WSAIOR(IOC_WS2,22)
#define SIO_ADDRESS_LIST_CHANGE _WSAIO(IOC_WS2,23)
#define SIO_QUERY_TARGET_PNP_HANDLE _WSAIOR(IOC_WS2,24)


#define SIO_ADDRESS_LIST_SORT _WSAIORW(IOC_WS2,25)



#define SIO_RESERVED_1 _WSAIOW(IOC_WS2,26)
#define SIO_RESERVED_2 _WSAIOW(IOC_WS2,33)


//
// Constants and structures defined by the internet system (RFC 790)
//

//
// N.B. required for backwards compatability to support 0 = IP for the
// level argument to get/setsockopt.
//
#define IPPROTO_IP 0

//
// Protocols.  The IPv6 defines are specified in RFC 2292.
//
typedef enum {

    IPPROTO_HOPOPTS = 0, // IPv6 Hop-by-Hop options

    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_GGP = 3,

    IPPROTO_IPV4 = 4,


    IPPROTO_ST = 5,

    IPPROTO_TCP = 6,

    IPPROTO_CBT = 7,
    IPPROTO_EGP = 8,
    IPPROTO_IGP = 9,

    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,

    IPPROTO_RDP = 27,



    IPPROTO_IPV6 = 41, // IPv6 header
    IPPROTO_ROUTING = 43, // IPv6 Routing header
    IPPROTO_FRAGMENT = 44, // IPv6 fragmentation header
    IPPROTO_ESP = 50, // encapsulating security payload
    IPPROTO_AH = 51, // authentication header
    IPPROTO_ICMPV6 = 58, // ICMPv6
    IPPROTO_NONE = 59, // IPv6 no next header
    IPPROTO_DSTOPTS = 60, // IPv6 Destination options


    IPPROTO_ND = 77,

    IPPROTO_ICLFXBM = 78,


    IPPROTO_PIM = 103,
    IPPROTO_PGM = 113,
    IPPROTO_L2TP = 115,
    IPPROTO_SCTP = 132,

    IPPROTO_RAW = 255,

    IPPROTO_MAX = 256,
//
//  These are reserved for internal use by Windows.
//
    IPPROTO_RESERVED_RAW = 257,
    IPPROTO_RESERVED_IPSEC = 258,
    IPPROTO_RESERVED_IPSECOFFLOAD = 259,
    IPPROTO_RESERVED_MAX = 260
} IPPROTO, *PIPROTO;

//
// Port/socket numbers: network standard functions
//
#define IPPORT_TCPMUX 1
#define IPPORT_ECHO 7
#define IPPORT_DISCARD 9
#define IPPORT_SYSTAT 11
#define IPPORT_DAYTIME 13
#define IPPORT_NETSTAT 15
#define IPPORT_QOTD 17
#define IPPORT_MSP 18
#define IPPORT_CHARGEN 19
#define IPPORT_FTP_DATA 20
#define IPPORT_FTP 21
#define IPPORT_TELNET 23
#define IPPORT_SMTP 25
#define IPPORT_TIMESERVER 37
#define IPPORT_NAMESERVER 42
#define IPPORT_WHOIS 43
#define IPPORT_MTP 57

/*

 * Port/socket numbers: host specific functions

 */
# 469 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define IPPORT_TFTP 69
#define IPPORT_RJE 77
#define IPPORT_FINGER 79
#define IPPORT_TTYLINK 87
#define IPPORT_SUPDUP 95

/*

 * UNIX TCP sockets

 */
# 478 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define IPPORT_POP3 110
#define IPPORT_NTP 123
#define IPPORT_EPMAP 135
#define IPPORT_NETBIOS_NS 137
#define IPPORT_NETBIOS_DGM 138
#define IPPORT_NETBIOS_SSN 139
#define IPPORT_IMAP 143
#define IPPORT_SNMP 161
#define IPPORT_SNMP_TRAP 162
#define IPPORT_IMAP3 220
#define IPPORT_LDAP 389
#define IPPORT_HTTPS 443
#define IPPORT_MICROSOFT_DS 445
#define IPPORT_EXECSERVER 512
#define IPPORT_LOGINSERVER 513
#define IPPORT_CMDSERVER 514
#define IPPORT_EFSSERVER 520

/*

 * UNIX UDP sockets

 */
# 499 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define IPPORT_BIFFUDP 512
#define IPPORT_WHOSERVER 513
#define IPPORT_ROUTESERVER 520
                                        /* 520+1 also used */

/*

 * Ports < IPPORT_RESERVED are reserved for

 * privileged processes (e.g. root).

 */
# 508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define IPPORT_RESERVED 1024

#define IPPORT_REGISTERED_MIN IPPORT_RESERVED
#define IPPORT_REGISTERED_MAX 0xbfff
#define IPPORT_DYNAMIC_MIN 0xc000
#define IPPORT_DYNAMIC_MAX 0xffff


/*

 * Definitions of bits in internet address integers.

 * On subnets, the decomposition of addresses to host and net parts

 * is done according to subnet mask, not the masks here.

 *

 * N.B. RFC-compliant definitions for host-order elements are named IN_xxx,

 * while network-order elements are named IN4_xxx.

 */
# 524 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define IN_CLASSA(i) (((LONG)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET 0xff000000
#define IN_CLASSA_NSHIFT 24
#define IN_CLASSA_HOST 0x00ffffff
#define IN_CLASSA_MAX 128

#define IN_CLASSB(i) (((LONG)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET 0xffff0000
#define IN_CLASSB_NSHIFT 16
#define IN_CLASSB_HOST 0x0000ffff
#define IN_CLASSB_MAX 65536

#define IN_CLASSC(i) (((LONG)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET 0xffffff00
#define IN_CLASSC_NSHIFT 8
#define IN_CLASSC_HOST 0x000000ff

#define IN_CLASSD(i) (((long)(i) & 0xf0000000) == 0xe0000000)
#define IN_CLASSD_NET 0xf0000000
#define IN_CLASSD_NSHIFT 28
#define IN_CLASSD_HOST 0x0fffffff
#define IN_MULTICAST(i) IN_CLASSD(i)

#define INADDR_ANY (ULONG)0x00000000
#define INADDR_LOOPBACK 0x7f000001
#define INADDR_BROADCAST (ULONG)0xffffffff
#define INADDR_NONE 0xffffffff


//
// Scope ID definition
//
typedef enum {
    ScopeLevelInterface = 1,
    ScopeLevelLink = 2,
    ScopeLevelSubnet = 3,
    ScopeLevelAdmin = 4,
    ScopeLevelSite = 5,
    ScopeLevelOrganization = 8,
    ScopeLevelGlobal = 14,
    ScopeLevelCount = 16
} SCOPE_LEVEL;

typedef struct {
    union {
        struct {
            ULONG Zone : 28;
            ULONG Level : 4;
        };
        ULONG Value;
    };
} SCOPE_ID, *PSCOPE_ID;

#define SCOPEID_UNSPECIFIED_INIT { 0 }

//
// IPv4 Socket address, Internet style
//

typedef struct sockaddr_in {




    ADDRESS_FAMILY sin_family;


    USHORT sin_port;
    IN_ADDR sin_addr;
    CHAR sin_zero[8];
} SOCKADDR_IN, *PSOCKADDR_IN;

//
// Datalink (MAC) address
//
// If you don't use the entire sdl_data field, then fill it starting with the low
// bytes...
//



typedef struct sockaddr_dl {
    ADDRESS_FAMILY sdl_family;
    UCHAR sdl_data[8];
    UCHAR sdl_zero[4];
} SOCKADDR_DL, *PSOCKADDR_DL;



#define IOCPARM_MASK 0x7f
#define IOC_VOID 0x20000000
#define IOC_OUT 0x40000000
#define IOC_IN 0x80000000
#define IOC_INOUT (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &

                                           old ioctl's */
# 620 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define _IO(x,y) (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t) (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t) (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

/*

 * WinSock 2 extension -- WSABUF and QOS struct, include qos.h

 * to pull in FLOWSPEC and related definitions

 */
# 631 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _WSABUF {
    ULONG len; /* the length of the buffer */
    CHAR *buf; /* the pointer to the buffer */
} WSABUF, * LPWSABUF;

/*

 * WSAMSG -- for WSASendMsg 

 */
# 640 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
typedef struct _WSAMSG {
    LPSOCKADDR name; /* Remote address */
    INT namelen; /* Remote address length */
    LPWSABUF lpBuffers; /* Data buffer array */


    ULONG dwBufferCount; /* Number of elements in the array */




    WSABUF Control; /* Control buffer */


    ULONG dwFlags; /* Flags */




} WSAMSG, *PWSAMSG, * LPWSAMSG;

/*

 * Layout of ancillary data objects in the control buffer (RFC 2292).

 */
# 665 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define _WSACMSGHDR cmsghdr


typedef struct cmsghdr {
    SIZE_T cmsg_len;
    INT cmsg_level;
    INT cmsg_type;
    /* followed by UCHAR cmsg_data[] */
} WSACMSGHDR, *PWSACMSGHDR, *LPWSACMSGHDR;


typedef WSACMSGHDR CMSGHDR, *PCMSGHDR;


/*

 * Alignment macros for header and data members of

 * the control buffer.

 */
# 683 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define WSA_CMSGHDR_ALIGN(length) ( ((length) + TYPE_ALIGNMENT(WSACMSGHDR)-1) & (~(TYPE_ALIGNMENT(WSACMSGHDR)-1)) )



#define WSA_CMSGDATA_ALIGN(length) ( ((length) + MAX_NATURAL_ALIGNMENT-1) & (~(MAX_NATURAL_ALIGNMENT-1)) )




#define CMSGHDR_ALIGN WSA_CMSGHDR_ALIGN
#define CMSGDATA_ALIGN WSA_CMSGDATA_ALIGN


/*

 *  WSA_CMSG_FIRSTHDR

 *

 *  Returns a pointer to the first ancillary data object, 

 *  or a null pointer if there is no ancillary data in the 

 *  control buffer of the WSAMSG structure.

 *

 *  LPCMSGHDR 

 *  WSA_CMSG_FIRSTHDR (

 *      LPWSAMSG    msg

 *      );

 */
# 708 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define WSA_CMSG_FIRSTHDR(msg) ( ((msg)->Control.len >= sizeof(WSACMSGHDR)) ? (LPWSACMSGHDR)(msg)->Control.buf : (LPWSACMSGHDR)NULL )





#define CMSG_FIRSTHDR WSA_CMSG_FIRSTHDR


/* 

 *  WSA_CMSG_NXTHDR

 *

 *  Returns a pointer to the next ancillary data object,

 *  or a null if there are no more data objects.

 *

 *  LPCMSGHDR 

 *  WSA_CMSG_NEXTHDR (

 *      LPWSAMSG        msg,

 *      LPWSACMSGHDR    cmsg

 *      );

 */
# 729 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define WSA_CMSG_NXTHDR(msg,cmsg) ( ((cmsg) == NULL) ? WSA_CMSG_FIRSTHDR(msg) : ( ( ((PUCHAR)(cmsg) + WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len) + sizeof(WSACMSGHDR) ) > (PUCHAR)((msg)->Control.buf) + (msg)->Control.len ) ? (LPWSACMSGHDR)NULL : (LPWSACMSGHDR)((PUCHAR)(cmsg) + WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len)) ) )
# 742 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define CMSG_NXTHDR WSA_CMSG_NXTHDR


/* 

 *  WSA_CMSG_DATA

 *

 *  Returns a pointer to the first byte of data (what is referred 

 *  to as the cmsg_data member though it is not defined in 

 *  the structure).

 *

 *  Note that RFC 2292 defines this as CMSG_DATA, but that name

 *  is already used by wincrypt.h, and so Windows has used WSA_CMSG_DATA.

 *

 *  PUCHAR

 *  WSA_CMSG_DATA (

 *      LPWSACMSGHDR   pcmsg

 *      );

 */
# 760 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define WSA_CMSG_DATA(cmsg) ( (PUCHAR)(cmsg) + WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) )


/*

 *  WSA_CMSG_SPACE

 *

 *  Returns total size of an ancillary data object given 

 *  the amount of data. Used to allocate the correct amount 

 *  of space.

 *

 *  SIZE_T

 *  WSA_CMSG_SPACE (

 *      SIZE_T length

 *      );

 */
# 775 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define WSA_CMSG_SPACE(length) (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR) + WSA_CMSGHDR_ALIGN(length)))



#define CMSG_SPACE WSA_CMSG_SPACE


/*

 *  WSA_CMSG_LEN

 *

 *  Returns the value to store in cmsg_len given the amount of data.

 *

 *  SIZE_T

 *  WSA_CMSG_LEN (

 *      SIZE_T length

 *  );

 */
# 792 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define WSA_CMSG_LEN(length) (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) + length)



#define CMSG_LEN WSA_CMSG_LEN


/*

 * Definition for flags member of the WSAMSG structure

 * This is in addition to other MSG_xxx flags defined

 * for recv/recvfrom/send/sendto.

 */
# 804 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2def.h"
#define MSG_TRUNC 0x0100
#define MSG_CTRUNC 0x0200
#define MSG_BCAST 0x0400
#define MSG_MCAST 0x0800

//
//  Flags used in "hints" argument to getaddrinfo()
//      - AI_ADDRCONFIG is supported starting with Vista
//      - default is AI_ADDRCONFIG ON whether the flag is set or not
//        because the performance penalty in not having ADDRCONFIG in
//        the multi-protocol stack environment is severe;
//        this defaulting may be disabled by specifying the AI_ALL flag,
//        in that case AI_ADDRCONFIG must be EXPLICITLY specified to
//        enable ADDRCONFIG behavior
//

#define AI_PASSIVE 0x00000001
#define AI_CANONNAME 0x00000002
#define AI_NUMERICHOST 0x00000004
#define AI_NUMERICSERV 0x00000008

#define AI_ALL 0x00000100
#define AI_ADDRCONFIG 0x00000400
#define AI_V4MAPPED 0x00000800

#define AI_NON_AUTHORITATIVE 0x00004000
#define AI_SECURE 0x00008000
#define AI_RETURN_PREFERRED_NAMES 0x00010000

#define AI_FQDN 0x00020000
#define AI_FILESERVER 0x00040000

//
//  Structure used in getaddrinfo() call
//

typedef struct addrinfo
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    char * ai_canonname; // Canonical name for nodename
    struct sockaddr * ai_addr; // Binary address
    struct addrinfo * ai_next; // Next structure in linked list
}
ADDRINFOA, *PADDRINFOA;

typedef struct addrinfoW
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    PWSTR ai_canonname; // Canonical name for nodename
    struct sockaddr * ai_addr; // Binary address
    struct addrinfoW * ai_next; // Next structure in linked list
}
ADDRINFOW, *PADDRINFOW;



typedef struct addrinfoexA
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    char *ai_canonname; // Canonical name for nodename
    struct sockaddr *ai_addr; // Binary address
    void *ai_blob;
    size_t ai_bloblen;
    LPGUID ai_provider;
    struct addrinfoexA *ai_next; // Next structure in linked list
} ADDRINFOEXA, *PADDRINFOEXA, *LPADDRINFOEXA;

typedef struct addrinfoexW
{
    int ai_flags; // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int ai_family; // PF_xxx
    int ai_socktype; // SOCK_xxx
    int ai_protocol; // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t ai_addrlen; // Length of ai_addr
    PWSTR ai_canonname; // Canonical name for nodename
    struct sockaddr *ai_addr; // Binary address
    void *ai_blob;
    size_t ai_bloblen;
    LPGUID ai_provider;
    struct addrinfoexW *ai_next; // Next structure in linked list
} ADDRINFOEXW, *PADDRINFOEXW, *LPADDRINFOEXW;



//
// Flags for getaddrinfo()
//

// Name Spaces

#define NS_ALL (0)

#define NS_SAP (1)
#define NS_NDS (2)
#define NS_PEER_BROWSE (3)
#define NS_SLP (5)
#define NS_DHCP (6)

#define NS_TCPIP_LOCAL (10)
#define NS_TCPIP_HOSTS (11)
#define NS_DNS (12)
#define NS_NETBT (13)
#define NS_WINS (14)


#define NS_NLA (15)



#define NS_BTH (16)


#define NS_NBP (20)

#define NS_MS (30)
#define NS_STDA (31)
#define NS_NTDS (32)


#define NS_EMAIL (37)
#define NS_PNRPNAME (38)
#define NS_PNRPCLOUD (39)


#define NS_X500 (40)
#define NS_NIS (41)
#define NS_NISPLUS (42)

#define NS_WRQ (50)

#define NS_NETDES (60)

//
// Flags for getnameinfo()
//

#define NI_NOFQDN 0x01
#define NI_NUMERICHOST 0x02
#define NI_NAMEREQD 0x04
#define NI_NUMERICSERV 0x08
#define NI_DGRAM 0x10

#define NI_MAXHOST 1025
#define NI_MAXSERV 32

#pragma warning(pop)
# 113 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 2

/*

 * The new type to be used in all

 * instances which refer to sockets.

 */
# 118 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef UINT_PTR SOCKET;

/*

 * Select uses arrays of SOCKETs.  These macros manipulate such

 * arrays.  FD_SETSIZE may be defined by the user before including

 * this file, but the default here should be >= 64.

 *

 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE

 * INCLUDED IN WINSOCK2.H EXACTLY AS SHOWN HERE.

 */
# 129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define FD_SETSIZE 64


typedef struct fd_set {
        u_int fd_count; /* how many are SET? */
        SOCKET fd_array[64]; /* an array of SOCKETs */
} fd_set;

 extern int __WSAFDIsSet(SOCKET fd, fd_set *);

#define FD_CLR(fd,set) do { u_int __i; for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { if (((fd_set FAR *)(set))->fd_array[__i] == fd) { while (__i < ((fd_set FAR *)(set))->fd_count-1) { ((fd_set FAR *)(set))->fd_array[__i] = ((fd_set FAR *)(set))->fd_array[__i+1]; __i++; } ((fd_set FAR *)(set))->fd_count--; break; } } } while(0)
# 154 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define FD_SET(fd,set) do { u_int __i; for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count; __i++) { if (((fd_set FAR *)(set))->fd_array[__i] == (fd)) { break; } } if (__i == ((fd_set FAR *)(set))->fd_count) { if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) { ((fd_set FAR *)(set))->fd_array[__i] = (fd); ((fd_set FAR *)(set))->fd_count++; } } } while(0)
# 169 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd,set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*

 * Structure used in select() call, taken from the BSD file sys/time.h.

 */
# 176 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct timeval {
        long tv_sec; /* seconds */
        long tv_usec; /* and microseconds */
};

/*

 * Operations on timevals.

 *

 * NB: timercmp does not work for >= or <=.

 */
# 186 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define timerisset(tvp) ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp,uvp,cmp) ((tvp)->tv_sec cmp (uvp)->tv_sec || (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)


#define timerclear(tvp) (tvp)->tv_sec = (tvp)->tv_usec = 0

/*

 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.

 *

 *

 * Ioctl's have the command encoded in the lower word,

 * and the size of any in or out parameters in the upper

 * word.  The high 2 bits of the upper word are used

 * to encode the in/out status of the parameter; for now

 * we restrict parameters to at most 128 bytes.

 */
# 202 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define IOCPARM_MASK 0x7f
#define IOC_VOID 0x20000000
#define IOC_OUT 0x40000000
#define IOC_IN 0x80000000
#define IOC_INOUT (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &

                                           old ioctl's */
# 209 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define _IO(x,y) (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t) (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t) (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD _IOR('f', 127, u_long)
#define FIONBIO _IOW('f', 126, u_long)
#define FIOASYNC _IOW('f', 125, u_long)

/* Socket I/O Controls */
#define SIOCSHIWAT _IOW('s', 0, u_long)
#define SIOCGHIWAT _IOR('s', 1, u_long)
#define SIOCSLOWAT _IOW('s', 2, u_long)
#define SIOCGLOWAT _IOR('s', 3, u_long)
#define SIOCATMARK _IOR('s', 7, u_long)

/*

 * Structures returned by network data base library, taken from the

 * BSD file netdb.h.  All addresses are supplied in host order, and

 * returned in network order (suitable for use in system calls).

 */
# 232 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct hostent {
        char * h_name; /* official name of host */
        char * * h_aliases; /* alias list */
        short h_addrtype; /* host address type */
        short h_length; /* length of address */
        char * * h_addr_list; /* list of addresses */
#define h_addr h_addr_list[0]
};

/*

 * It is assumed here that a network number

 * fits in 32 bits.

 */
# 245 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct netent {
        char * n_name; /* official name of net */
        char * * n_aliases; /* alias list */
        short n_addrtype; /* net address type */
        u_long n_net; /* network # */
};

struct servent {
        char * s_name; /* official service name */
        char * * s_aliases; /* alias list */

        char * s_proto; /* protocol to use */
        short s_port; /* port # */




};

struct protoent {
        char * p_name; /* official protocol name */
        char * * p_aliases; /* alias list */
        short p_proto; /* protocol # */
};

/*

 * Constants and structures defined by the internet system,

 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.

 * IPv6 additions per RFC 2292.

 */
# 276 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*

 * Port/socket numbers: network standard functions

 */
# 279 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define IPPORT_ECHO 7
#define IPPORT_DISCARD 9
#define IPPORT_SYSTAT 11
#define IPPORT_DAYTIME 13
#define IPPORT_NETSTAT 15
#define IPPORT_FTP 21
#define IPPORT_TELNET 23
#define IPPORT_SMTP 25
#define IPPORT_TIMESERVER 37
#define IPPORT_NAMESERVER 42
#define IPPORT_WHOIS 43
#define IPPORT_MTP 57

/*

 * Port/socket numbers: host specific functions

 */
# 295 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define IPPORT_TFTP 69
#define IPPORT_RJE 77
#define IPPORT_FINGER 79
#define IPPORT_TTYLINK 87
#define IPPORT_SUPDUP 95

/*

 * UNIX TCP sockets

 */
# 304 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define IPPORT_EXECSERVER 512
#define IPPORT_LOGINSERVER 513
#define IPPORT_CMDSERVER 514
#define IPPORT_EFSSERVER 520

/*

 * UNIX UDP sockets

 */
# 312 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define IPPORT_BIFFUDP 512
#define IPPORT_WHOSERVER 513
#define IPPORT_ROUTESERVER 520
                                        /* 520+1 also used */

/*

 * Ports < IPPORT_RESERVED are reserved for

 * privileged processes (e.g. root).

 */
# 321 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define IPPORT_RESERVED 1024

/*

 * Link numbers

 */
# 326 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define IMPLINK_IP 155
#define IMPLINK_LOWEXPER 156
#define IMPLINK_HIGHEXPER 158
# 355 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define ADDR_ANY INADDR_ANY

#define WSADESCRIPTION_LEN 256
#define WSASYS_STATUS_LEN 128

typedef struct WSAData {
        WORD wVersion;
        WORD wHighVersion;

        unsigned short iMaxSockets;
        unsigned short iMaxUdpDg;
        char * lpVendorInfo;
        char szDescription[256 +1];
        char szSystemStatus[128 +1];







} WSADATA, * LPWSADATA;

/*

 * Definitions related to sockets: types, address families, options,

 * taken from the BSD file sys/socket.h.

 */
# 383 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*

 * This is used instead of -1, since the

 * SOCKET type is unsigned.

 */
# 387 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define INVALID_SOCKET (SOCKET)(~0)
#define SOCKET_ERROR (-1)

/*

 * The  following  may  be used in place of the address family, socket type, or

 * protocol  in  a  call  to WSASocket to indicate that the corresponding value

 * should  be taken from the supplied WSAPROTOCOL_INFO structure instead of the

 * parameter itself.

 */
# 396 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define FROM_PROTOCOL_INFO (-1)

/*

 * Types

 */
# 401 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SOCK_STREAM 1
#define SOCK_DGRAM 2
#define SOCK_RAW 3
#define SOCK_RDM 4
#define SOCK_SEQPACKET 5

/*

 * Option flags per-socket.

 */
# 410 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SO_DEBUG 0x0001
#define SO_ACCEPTCONN 0x0002
#define SO_REUSEADDR 0x0004
#define SO_KEEPALIVE 0x0008
#define SO_DONTROUTE 0x0010
#define SO_BROADCAST 0x0020
#define SO_USELOOPBACK 0x0040
#define SO_LINGER 0x0080
#define SO_OOBINLINE 0x0100

#define SO_DONTLINGER (int)(~SO_LINGER)
#define SO_EXCLUSIVEADDRUSE ((int)(~SO_REUSEADDR))

/*

 * Additional options.

 */
# 426 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SO_SNDBUF 0x1001
#define SO_RCVBUF 0x1002
#define SO_SNDLOWAT 0x1003
#define SO_RCVLOWAT 0x1004
#define SO_SNDTIMEO 0x1005
#define SO_RCVTIMEO 0x1006
#define SO_ERROR 0x1007
#define SO_TYPE 0x1008

/*

 * WinSock 2 extension -- new options

 */
# 438 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SO_GROUP_ID 0x2001
#define SO_GROUP_PRIORITY 0x2002
#define SO_MAX_MSG_SIZE 0x2003
#define SO_PROTOCOL_INFOA 0x2004
#define SO_PROTOCOL_INFOW 0x2005



#define SO_PROTOCOL_INFO SO_PROTOCOL_INFOA

#define PVD_CONFIG 0x3001
#define SO_CONDITIONAL_ACCEPT 0x3002
                                       /*  connection is not ack-ed to the */
                                       /*  other side until conditional */
                                       /*  function returns CF_ACCEPT */

/*

 * Structure used by kernel to pass protocol

 * information in raw sockets.

 */
# 458 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct sockproto {
        u_short sp_family; /* address family */
        u_short sp_protocol; /* protocol */
};

/*

 * Protocol families, same as address families for now.

 */
# 466 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define PF_UNSPEC AF_UNSPEC
#define PF_UNIX AF_UNIX
#define PF_INET AF_INET
#define PF_IMPLINK AF_IMPLINK
#define PF_PUP AF_PUP
#define PF_CHAOS AF_CHAOS
#define PF_NS AF_NS
#define PF_IPX AF_IPX
#define PF_ISO AF_ISO
#define PF_OSI AF_OSI
#define PF_ECMA AF_ECMA
#define PF_DATAKIT AF_DATAKIT
#define PF_CCITT AF_CCITT
#define PF_SNA AF_SNA
#define PF_DECnet AF_DECnet
#define PF_DLI AF_DLI
#define PF_LAT AF_LAT
#define PF_HYLINK AF_HYLINK
#define PF_APPLETALK AF_APPLETALK
#define PF_VOICEVIEW AF_VOICEVIEW
#define PF_FIREFOX AF_FIREFOX
#define PF_UNKNOWN1 AF_UNKNOWN1
#define PF_BAN AF_BAN
#define PF_ATM AF_ATM
#define PF_INET6 AF_INET6

#define PF_BTH AF_BTH


#define PF_MAX AF_MAX

/*

 * Structure used for manipulating linger option.

 */
# 500 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
struct linger {
        u_short l_onoff; /* option on/off */
        u_short l_linger; /* linger time */
};

/*

 * Level number for (get/set)sockopt() to apply to socket itself.

 */
# 508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SOL_SOCKET 0xffff

/*

 * Maximum queue length specifiable by listen.

 */
# 513 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SOMAXCONN 0x7fffffff

#define MSG_OOB 0x1
#define MSG_PEEK 0x2
#define MSG_DONTROUTE 0x4


#define MSG_WAITALL 0x8


#define MSG_PARTIAL 0x8000

/*

 * WinSock 2 extension -- new flags for WSASend(), WSASendTo(), WSARecv() and

 *                          WSARecvFrom()

 */
# 529 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define MSG_INTERRUPT 0x10

#define MSG_MAXIOVLEN 16

/*

 * Define constant based on rfc883, used by gethostbyxxxx() calls.

 */
# 536 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define MAXGETHOSTSTRUCT 1024

/*

 * WinSock 2 extension -- bit values and indices for FD_XXX network events

 */
# 541 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define FD_READ_BIT 0
#define FD_READ (1 << FD_READ_BIT)

#define FD_WRITE_BIT 1
#define FD_WRITE (1 << FD_WRITE_BIT)

#define FD_OOB_BIT 2
#define FD_OOB (1 << FD_OOB_BIT)

#define FD_ACCEPT_BIT 3
#define FD_ACCEPT (1 << FD_ACCEPT_BIT)

#define FD_CONNECT_BIT 4
#define FD_CONNECT (1 << FD_CONNECT_BIT)

#define FD_CLOSE_BIT 5
#define FD_CLOSE (1 << FD_CLOSE_BIT)

#define FD_QOS_BIT 6
#define FD_QOS (1 << FD_QOS_BIT)

#define FD_GROUP_QOS_BIT 7
#define FD_GROUP_QOS (1 << FD_GROUP_QOS_BIT)

#define FD_ROUTING_INTERFACE_CHANGE_BIT 8
#define FD_ROUTING_INTERFACE_CHANGE (1 << FD_ROUTING_INTERFACE_CHANGE_BIT)

#define FD_ADDRESS_LIST_CHANGE_BIT 9
#define FD_ADDRESS_LIST_CHANGE (1 << FD_ADDRESS_LIST_CHANGE_BIT)

#define FD_MAX_EVENTS 10
#define FD_ALL_EVENTS ((1 << FD_MAX_EVENTS) - 1)


/*

 * WinSock error codes are also defined in winerror.h

 * Hence the IFDEF.

 */
# 748 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*

 * Compatibility macros.

 */
# 752 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define h_errno WSAGetLastError()
#define HOST_NOT_FOUND WSAHOST_NOT_FOUND
#define TRY_AGAIN WSATRY_AGAIN
#define NO_RECOVERY WSANO_RECOVERY
#define NO_DATA WSANO_DATA
/* no address, look for MX record */
#define WSANO_ADDRESS WSANO_DATA
#define NO_ADDRESS WSANO_ADDRESS



/*

 * Windows Sockets errors redefined as regular Berkeley error constants.

 * These are commented out in Windows NT to avoid conflicts with errno.h.

 * Use the WSA constants instead.

 */
# 808 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*

 * WinSock 2 extension -- new error codes and type definition

 */

#define WSAAPI FAR PASCAL
#define WSAEVENT HANDLE
#define LPWSAEVENT LPHANDLE
#define WSAOVERLAPPED OVERLAPPED
typedef struct _OVERLAPPED * LPWSAOVERLAPPED;

#define WSA_IO_PENDING (ERROR_IO_PENDING)
#define WSA_IO_INCOMPLETE (ERROR_IO_INCOMPLETE)
#define WSA_INVALID_HANDLE (ERROR_INVALID_HANDLE)
#define WSA_INVALID_PARAMETER (ERROR_INVALID_PARAMETER)
#define WSA_NOT_ENOUGH_MEMORY (ERROR_NOT_ENOUGH_MEMORY)
#define WSA_OPERATION_ABORTED (ERROR_OPERATION_ABORTED)

#define WSA_INVALID_EVENT ((WSAEVENT)NULL)
#define WSA_MAXIMUM_WAIT_EVENTS (MAXIMUM_WAIT_OBJECTS)
#define WSA_WAIT_FAILED (WAIT_FAILED)
#define WSA_WAIT_EVENT_0 (WAIT_OBJECT_0)
#define WSA_WAIT_IO_COMPLETION (WAIT_IO_COMPLETION)
#define WSA_WAIT_TIMEOUT (WAIT_TIMEOUT)
#define WSA_INFINITE (INFINITE)
# 864 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*

 * Include qos.h to pull in FLOWSPEC and related definitions

 */
# 867 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h" 1
/*++



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    qos.h - QoS definitions for NDIS components.



Abstract:



    This module defines the Quality of Service structures and types used

    by Winsock applications.



WARNING:



    This api is deprecated and will be removed in a future release of Windows.

    Please use the QOS2.h api.



Revision History:



--*/
# 24 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
#define __QOS_H_ 

       

/*

 *  Definitions for valued-based Service Type for each direction of data flow.

 */
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef ULONG SERVICETYPE;

#define SERVICETYPE_NOTRAFFIC 0x00000000

#define SERVICETYPE_BESTEFFORT 0x00000001
#define SERVICETYPE_CONTROLLEDLOAD 0x00000002
#define SERVICETYPE_GUARANTEED 0x00000003

#define SERVICETYPE_NETWORK_UNAVAILABLE 0x00000004

#define SERVICETYPE_GENERAL_INFORMATION 0x00000005


#define SERVICETYPE_NOCHANGE 0x00000006




#define SERVICETYPE_NONCONFORMING 0x00000009
#define SERVICETYPE_NETWORK_CONTROL 0x0000000A
#define SERVICETYPE_QUALITATIVE 0x0000000D



/*********  The usage of these is currently not supported.  ***************/
#define SERVICE_BESTEFFORT 0x80010000
#define SERVICE_CONTROLLEDLOAD 0x80020000
#define SERVICE_GUARANTEED 0x80040000
#define SERVICE_QUALITATIVE 0x80200000
/* **************************** ***** ************************************ */



/*

 * Flags to control the usage of RSVP on this flow.

 */
# 69 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
/*

 * to turn off traffic control, 'OR' ( | ) this flag with the 

 * ServiceType field in the FLOWSPEC

 */
# 73 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
#define SERVICE_NO_TRAFFIC_CONTROL 0x81000000


/*

 * this flag can be used to prevent any rsvp signaling messages from being 

 * sent. Local traffic control will be invoked, but no RSVP Path messages 

 * will be sent.This flag can also be used in conjunction with a receiving 

 * flowspec to suppress the automatic generation of a Reserve message.  

 * The application would receive notification that a Path  message had arrived 

 * and would then need to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), 

 * to unset this flag and thereby causing Reserve messages to go out.

 */
# 86 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
#define SERVICE_NO_QOS_SIGNALING 0x40000000




/*

 *  Flow Specifications for each direction of data flow.

 */
# 94 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct _flowspec
{
    ULONG TokenRate; /* In Bytes/sec */
    ULONG TokenBucketSize; /* In Bytes */
    ULONG PeakBandwidth; /* In Bytes/sec */
    ULONG Latency; /* In microseconds */
    ULONG DelayVariation; /* In microseconds */
    SERVICETYPE ServiceType;
    ULONG MaxSduSize; /* In Bytes */
    ULONG MinimumPolicedSize; /* In Bytes */

} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;

/*

 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service 

 * provider to derive the appropriate default value for the parameter.  Note 

 * that not all values in the FLOWSPEC structure can be defaults. In the

 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.  

 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be

 * defaulted. Other defaults may be possible. Refer to the appropriate

 * documentation.

 */
# 116 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
#define QOS_NOT_SPECIFIED 0xFFFFFFFF

/*

 * define a value that can be used for the PeakBandwidth, which will map into 

 * positive infinity when the FLOWSPEC is converted into IntServ floating point 

 * format.  We can't use (-1) because that value was previously defined to mean

 * "select the default".

 */
# 124 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
#define POSITIVE_INFINITY_RATE 0xFFFFFFFE



/*

 * the provider specific structure can have a number of objects in it.

 * Each next structure in the

 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual

 * data with a type and length for that object.  This QOS_OBJECT struct can 

 * repeat several times if there are several objects.  This list of objects

 * terminates either when the buffer length has been reached ( WSABUF ) or

 * an object of type QOS_END_OF_LIST is encountered.

 */
# 137 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct {

    ULONG ObjectType;
    ULONG ObjectLength; /* the length of object buffer INCLUDING 

                            * this header */
} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;


/*

 * general QOS objects start at this offset from the base and have a range 

 * of 1000

 */
# 150 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
#define QOS_GENERAL_ID_BASE 2000

#define QOS_OBJECT_END_OF_LIST (0x00000001 + QOS_GENERAL_ID_BASE)
          /* QOS_End_of_list structure passed */
#define QOS_OBJECT_SD_MODE (0x00000002 + QOS_GENERAL_ID_BASE)
          /* QOS_ShapeDiscard structure passed */
#define QOS_OBJECT_SHAPING_RATE (0x00000003 + QOS_GENERAL_ID_BASE)
          /* QOS_ShapingRate structure */
#define QOS_OBJECT_DESTADDR (0x00000004 + QOS_GENERAL_ID_BASE)
          /* QOS_DestAddr structure (defined in qossp.h) */


/*

 * This structure is used to define the behaviour that the traffic

 * control packet shaper will apply to the flow.

 *

 * TC_NONCONF_BORROW - the flow will receive resources remaining 

 *  after all higher priority flows have been serviced. If a 

 *  TokenRate is specified, packets may be non-conforming and

 *  will be demoted to less than best-effort priority.

 *  

 * TC_NONCONF_SHAPE - TokenRate must be specified. Non-conforming

 *  packets will be retianed in the packet shaper until they become

 *  conforming.

 *

 * TC_NONCONF_DISCARD - TokenRate must be specified. Non-conforming

 *  packets will be discarded.

 *

 */
# 180 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct _QOS_SD_MODE {

    QOS_OBJECT_HDR ObjectHdr;
    ULONG ShapeDiscardMode;

} QOS_SD_MODE, *LPQOS_SD_MODE;

#define TC_NONCONF_BORROW 0
#define TC_NONCONF_SHAPE 1
#define TC_NONCONF_DISCARD 2
#define TC_NONCONF_BORROW_PLUS 3


/*

 * This structure allows an app to specify a prorated "average token rate" using by

 * the traffic shaper under SHAPE modehaper queue. It is expressed in bytes per sec.

 *

 * ShapingRate (bytes per sec.)

 *

 */
# 201 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/qos.h"
typedef struct _QOS_SHAPING_RATE {

    QOS_OBJECT_HDR ObjectHdr;
    ULONG ShapingRate;

} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;
# 868 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h" 2

typedef struct _QualityOfService
{
    FLOWSPEC SendingFlowspec; /* the flow spec for data sending */
    FLOWSPEC ReceivingFlowspec; /* the flow spec for data receiving */
    WSABUF ProviderSpecific; /* additional provider specific stuff */
} QOS, * LPQOS;

/*

 * WinSock 2 extension -- manifest constants for return values of the condition function

 */
# 879 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define CF_ACCEPT 0x0000
#define CF_REJECT 0x0001
#define CF_DEFER 0x0002

/*

 * WinSock 2 extension -- manifest constants for shutdown()

 */
# 886 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SD_RECEIVE 0x00
#define SD_SEND 0x01
#define SD_BOTH 0x02

/*

 * WinSock 2 extension -- data type and manifest constants for socket groups

 */
# 893 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef unsigned int GROUP;

#define SG_UNCONSTRAINED_GROUP 0x01
#define SG_CONSTRAINED_GROUP 0x02

/*

 * WinSock 2 extension -- data type for WSAEnumNetworkEvents()

 */
# 901 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef struct _WSANETWORKEVENTS {
       long lNetworkEvents;
       int iErrorCode[10];
} WSANETWORKEVENTS, * LPWSANETWORKEVENTS;

/*

 * WinSock 2 extension -- WSAPROTOCOL_INFO structure and associated

 * manifest constants

 */


#define MAX_PROTOCOL_CHAIN 7

#define BASE_PROTOCOL 1
#define LAYERED_PROTOCOL 0

typedef struct _WSAPROTOCOLCHAIN {
    int ChainLen; /* the length of the chain,     */
                                                  /* length = 0 means layered protocol, */
                                                  /* length = 1 means base protocol, */
                                                  /* length > 1 means protocol chain */
    DWORD ChainEntries[7]; /* a list of dwCatalogEntryIds */
} WSAPROTOCOLCHAIN, * LPWSAPROTOCOLCHAIN;

#define WSAPROTOCOL_LEN 255

typedef struct _WSAPROTOCOL_INFOA {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    CHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOA, * LPWSAPROTOCOL_INFOA;
typedef struct _WSAPROTOCOL_INFOW {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    WCHAR szProtocol[255 +1];
} WSAPROTOCOL_INFOW, * LPWSAPROTOCOL_INFOW;




typedef WSAPROTOCOL_INFOA WSAPROTOCOL_INFO;
typedef LPWSAPROTOCOL_INFOA LPWSAPROTOCOL_INFO;


/* Flag bit definitions for dwProviderFlags */
#define PFL_MULTIPLE_PROTO_ENTRIES 0x00000001
#define PFL_RECOMMENDED_PROTO_ENTRY 0x00000002
#define PFL_HIDDEN 0x00000004
#define PFL_MATCHES_PROTOCOL_ZERO 0x00000008
#define PFL_NETWORKDIRECT_PROVIDER 0x00000010

/* Flag bit definitions for dwServiceFlags1 */
#define XP1_CONNECTIONLESS 0x00000001
#define XP1_GUARANTEED_DELIVERY 0x00000002
#define XP1_GUARANTEED_ORDER 0x00000004
#define XP1_MESSAGE_ORIENTED 0x00000008
#define XP1_PSEUDO_STREAM 0x00000010
#define XP1_GRACEFUL_CLOSE 0x00000020
#define XP1_EXPEDITED_DATA 0x00000040
#define XP1_CONNECT_DATA 0x00000080
#define XP1_DISCONNECT_DATA 0x00000100
#define XP1_SUPPORT_BROADCAST 0x00000200
#define XP1_SUPPORT_MULTIPOINT 0x00000400
#define XP1_MULTIPOINT_CONTROL_PLANE 0x00000800
#define XP1_MULTIPOINT_DATA_PLANE 0x00001000
#define XP1_QOS_SUPPORTED 0x00002000
#define XP1_INTERRUPT 0x00004000
#define XP1_UNI_SEND 0x00008000
#define XP1_UNI_RECV 0x00010000
#define XP1_IFS_HANDLES 0x00020000
#define XP1_PARTIAL_MESSAGE 0x00040000
#define XP1_SAN_SUPPORT_SDP 0x00080000

#define BIGENDIAN 0x0000
#define LITTLEENDIAN 0x0001

#define SECURITY_PROTOCOL_NONE 0x0000

/*

 * WinSock 2 extension -- manifest constants for WSAJoinLeaf()

 */
# 1019 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define JL_SENDER_ONLY 0x01
#define JL_RECEIVER_ONLY 0x02
#define JL_BOTH 0x04

/*

 * WinSock 2 extension -- manifest constants for WSASocket()

 */
# 1026 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define WSA_FLAG_OVERLAPPED 0x01
#define WSA_FLAG_MULTIPOINT_C_ROOT 0x02
#define WSA_FLAG_MULTIPOINT_C_LEAF 0x04
#define WSA_FLAG_MULTIPOINT_D_ROOT 0x08
#define WSA_FLAG_MULTIPOINT_D_LEAF 0x10
#define WSA_FLAG_ACCESS_SYSTEM_SECURITY 0x40

/*

 * WinSock 2 extensions -- data types for the condition function in

 * WSAAccept() and overlapped I/O completion routine.

 */
# 1038 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef
int
( * LPCONDITIONPROC)(
    LPWSABUF lpCallerId,
    LPWSABUF lpCallerData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    LPWSABUF lpCalleeId,
    LPWSABUF lpCalleeData,
    GROUP * g,
    DWORD_PTR dwCallbackData
    );

typedef
void
( * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );



/*

 * WinSock 2 extension -- manifest constants and associated structures

 * for WSANSPIoctl()

 */
# 1066 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SIO_NSP_NOTIFY_CHANGE _WSAIOW(IOC_WS2,25)

typedef enum _WSACOMPLETIONTYPE {
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC,
} WSACOMPLETIONTYPE, *PWSACOMPLETIONTYPE, * LPWSACOMPLETIONTYPE;

typedef struct _WSACOMPLETION {
    WSACOMPLETIONTYPE Type;
    union {
        struct {
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION, *LPWSACOMPLETION;


/*

 * WinSock 2 extension -- manifest constants for SIO_TRANSLATE_HANDLE ioctl

 */
# 1103 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define TH_NETDEV 0x00000001
#define TH_TAPI 0x00000002

/*

 * Manifest constants and type definitions related to name resolution and

 * registration (RNR) API

 */
# 1112 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define _tagBLOB_DEFINED 
#define _BLOB_DEFINED 
#define _LPBLOB_DEFINED 
typedef struct _BLOB {
    ULONG cbSize ;



    BYTE *pBlobData ;

} BLOB, *LPBLOB ;


/*

 * Service Install Flags

 */
# 1129 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SERVICE_MULTIPLE (0x00000001)

/*

 *& Name Spaces

 */
# 1135 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define NS_ALL (0)

#define NS_SAP (1)
#define NS_NDS (2)
#define NS_PEER_BROWSE (3)
#define NS_SLP (5)
#define NS_DHCP (6)

#define NS_TCPIP_LOCAL (10)
#define NS_TCPIP_HOSTS (11)
#define NS_DNS (12)
#define NS_NETBT (13)
#define NS_WINS (14)


#define NS_NLA (15)



#define NS_BTH (16)


#define NS_NBP (20)

#define NS_MS (30)
#define NS_STDA (31)
#define NS_NTDS (32)


#define NS_EMAIL (37)
#define NS_PNRPNAME (38)
#define NS_PNRPCLOUD (39)


#define NS_X500 (40)
#define NS_NIS (41)
#define NS_NISPLUS (42)

#define NS_WRQ (50)

#define NS_NETDES (60)

/*

 *& Name Spaces

 */
# 1181 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define NS_ALL (0)

#define NS_SAP (1)
#define NS_NDS (2)
#define NS_PEER_BROWSE (3)
#define NS_SLP (5)
#define NS_DHCP (6)

#define NS_TCPIP_LOCAL (10)
#define NS_TCPIP_HOSTS (11)
#define NS_DNS (12)
#define NS_NETBT (13)
#define NS_WINS (14)


#define NS_NLA (15)



#define NS_BTH (16)


#define NS_LOCALNAME (19)

#define NS_NBP (20)

#define NS_MS (30)
#define NS_STDA (31)
#define NS_NTDS (32)


#define NS_EMAIL (37)
#define NS_PNRPNAME (38)
#define NS_PNRPCLOUD (39)


#define NS_X500 (40)
#define NS_NIS (41)
#define NS_NISPLUS (42)

#define NS_WRQ (50)

#define NS_NETDES (60)

/*

 * Resolution flags for WSAGetAddressByName().

 * Note these are also used by the 1.1 API GetAddressByName, so

 * leave them around.

 */
# 1230 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define RES_UNUSED_1 (0x00000001)
#define RES_FLUSH_CACHE (0x00000002)

#define RES_SERVICE (0x00000004)


/*

 * Well known value names for Service Types

 */
# 1240 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SERVICE_TYPE_VALUE_IPXPORTA "IpxSocket"
#define SERVICE_TYPE_VALUE_IPXPORTW L"IpxSocket"
#define SERVICE_TYPE_VALUE_SAPIDA "SapId"
#define SERVICE_TYPE_VALUE_SAPIDW L"SapId"

#define SERVICE_TYPE_VALUE_TCPPORTA "TcpPort"
#define SERVICE_TYPE_VALUE_TCPPORTW L"TcpPort"

#define SERVICE_TYPE_VALUE_UDPPORTA "UdpPort"
#define SERVICE_TYPE_VALUE_UDPPORTW L"UdpPort"

#define SERVICE_TYPE_VALUE_OBJECTIDA "ObjectId"
#define SERVICE_TYPE_VALUE_OBJECTIDW L"ObjectId"
# 1263 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define SERVICE_TYPE_VALUE_SAPID SERVICE_TYPE_VALUE_SAPIDA
#define SERVICE_TYPE_VALUE_TCPPORT SERVICE_TYPE_VALUE_TCPPORTA
#define SERVICE_TYPE_VALUE_UDPPORT SERVICE_TYPE_VALUE_UDPPORTA
#define SERVICE_TYPE_VALUE_OBJECTID SERVICE_TYPE_VALUE_OBJECTIDA



/*

 *  Address Family/Protocol Tuples

 */
# 1273 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef struct _AFPROTOCOLS {
    INT iAddressFamily;
    INT iProtocol;
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS;

/*

 * Client Query API Typedefs

 */
# 1282 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/*

 * The comparators

 */
# 1285 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef enum _WSAEcomparator
{
    COMP_EQUAL = 0,
    COMP_NOTLESS
} WSAECOMPARATOR, *PWSAECOMPARATOR, *LPWSAECOMPARATOR;

typedef struct _WSAVersion
{
    DWORD dwVersion;
    WSAECOMPARATOR ecHow;
}WSAVERSION, *PWSAVERSION, *LPWSAVERSION;

typedef struct _WSAQuerySetA
{
    DWORD dwSize;
    LPSTR lpszServiceInstanceName;
    LPGUID lpServiceClassId;
    LPWSAVERSION lpVersion;
    LPSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSETA, *PWSAQUERYSETA, *LPWSAQUERYSETA;
typedef struct _WSAQuerySetW
{
    DWORD dwSize;
    LPWSTR lpszServiceInstanceName;
    LPGUID lpServiceClassId;
    LPWSAVERSION lpVersion;
    LPWSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPWSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPWSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW;

typedef struct _WSAQuerySet2A
{
    DWORD dwSize;
    LPSTR lpszServiceInstanceName;
    LPWSAVERSION lpVersion;
    LPSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSET2A, *PWSAQUERYSET2A, *LPWSAQUERYSET2A;
typedef struct _WSAQuerySet2W
{
    DWORD dwSize;
    LPWSTR lpszServiceInstanceName;
    LPWSAVERSION lpVersion;
    LPWSTR lpszComment;
    DWORD dwNameSpace;
    LPGUID lpNSProviderId;
    LPWSTR lpszContext;
    DWORD dwNumberOfProtocols;
    LPAFPROTOCOLS lpafpProtocols;
    LPWSTR lpszQueryString;
    DWORD dwNumberOfCsAddrs;
    LPCSADDR_INFO lpcsaBuffer;
    DWORD dwOutputFlags;
    LPBLOB lpBlob;
} WSAQUERYSET2W, *PWSAQUERYSET2W, *LPWSAQUERYSET2W;
# 1377 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef WSAQUERYSETA WSAQUERYSET;
typedef PWSAQUERYSETA PWSAQUERYSET;
typedef LPWSAQUERYSETA LPWSAQUERYSET;
typedef WSAQUERYSET2A WSAQUERYSET2;
typedef PWSAQUERYSET2A PWSAQUERYSET2;
typedef LPWSAQUERYSET2A LPWSAQUERYSET2;


#define LUP_DEEP 0x0001
#define LUP_CONTAINERS 0x0002
#define LUP_NOCONTAINERS 0x0004
#define LUP_NEAREST 0x0008
#define LUP_RETURN_NAME 0x0010
#define LUP_RETURN_TYPE 0x0020
#define LUP_RETURN_VERSION 0x0040
#define LUP_RETURN_COMMENT 0x0080
#define LUP_RETURN_ADDR 0x0100
#define LUP_RETURN_BLOB 0x0200
#define LUP_RETURN_ALIASES 0x0400
#define LUP_RETURN_QUERY_STRING 0x0800
#define LUP_RETURN_ALL 0x0FF0
#define LUP_RES_SERVICE 0x8000

#define LUP_FLUSHCACHE 0x1000
#define LUP_FLUSHPREVIOUS 0x2000

#define LUP_NON_AUTHORITATIVE 0x4000
#define LUP_SECURE 0x8000
#define LUP_RETURN_PREFERRED_NAMES 0x10000

#define LUP_ADDRCONFIG 0x00100000
#define LUP_DUAL_ADDR 0x00200000
#define LUP_FILESERVER 0x00400000


/*

 * Return flags

 */
# 1416 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define RESULT_IS_ALIAS 0x0001

#define RESULT_IS_ADDED 0x0010
#define RESULT_IS_CHANGED 0x0020
#define RESULT_IS_DELETED 0x0040


/*

 * Service Address Registration and Deregistration Data Types.

 */
# 1427 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef enum _WSAESETSERVICEOP
{
    RNRSERVICE_REGISTER=0,
    RNRSERVICE_DEREGISTER,
    RNRSERVICE_DELETE
} WSAESETSERVICEOP, *PWSAESETSERVICEOP, *LPWSAESETSERVICEOP;

/*

 * Service Installation/Removal Data Types.

 */
# 1438 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef struct _WSANSClassInfoA
{
    LPSTR lpszName;
    DWORD dwNameSpace;
    DWORD dwValueType;
    DWORD dwValueSize;
    LPVOID lpValue;
}WSANSCLASSINFOA, *PWSANSCLASSINFOA, *LPWSANSCLASSINFOA;
typedef struct _WSANSClassInfoW
{
    LPWSTR lpszName;
    DWORD dwNameSpace;
    DWORD dwValueType;
    DWORD dwValueSize;
    LPVOID lpValue;
}WSANSCLASSINFOW, *PWSANSCLASSINFOW, *LPWSANSCLASSINFOW;





typedef WSANSCLASSINFOA WSANSCLASSINFO;
typedef PWSANSCLASSINFOA PWSANSCLASSINFO;
typedef LPWSANSCLASSINFOA LPWSANSCLASSINFO;


typedef struct _WSAServiceClassInfoA
{
    LPGUID lpServiceClassId;
    LPSTR lpszServiceClassName;
    DWORD dwCount;
    LPWSANSCLASSINFOA lpClassInfos;
}WSASERVICECLASSINFOA, *PWSASERVICECLASSINFOA, *LPWSASERVICECLASSINFOA;
typedef struct _WSAServiceClassInfoW
{
    LPGUID lpServiceClassId;
    LPWSTR lpszServiceClassName;
    DWORD dwCount;
    LPWSANSCLASSINFOW lpClassInfos;
}WSASERVICECLASSINFOW, *PWSASERVICECLASSINFOW, *LPWSASERVICECLASSINFOW;





typedef WSASERVICECLASSINFOA WSASERVICECLASSINFO;
typedef PWSASERVICECLASSINFOA PWSASERVICECLASSINFO;
typedef LPWSASERVICECLASSINFOA LPWSASERVICECLASSINFO;


typedef struct _WSANAMESPACE_INFOA {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPSTR lpszIdentifier;
} WSANAMESPACE_INFOA, *PWSANAMESPACE_INFOA, *LPWSANAMESPACE_INFOA;

typedef struct _WSANAMESPACE_INFOW {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPWSTR lpszIdentifier;
} WSANAMESPACE_INFOW, *PWSANAMESPACE_INFOW, *LPWSANAMESPACE_INFOW;

typedef struct _WSANAMESPACE_INFOEXA {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPSTR lpszIdentifier;
    BLOB ProviderSpecific;
} WSANAMESPACE_INFOEXA, *PWSANAMESPACE_INFOEXA, *LPWSANAMESPACE_INFOEXA;

typedef struct _WSANAMESPACE_INFOEXW {
    GUID NSProviderId;
    DWORD dwNameSpace;
    BOOL fActive;
    DWORD dwVersion;
    LPWSTR lpszIdentifier;
    BLOB ProviderSpecific;
} WSANAMESPACE_INFOEXW, *PWSANAMESPACE_INFOEXW, *LPWSANAMESPACE_INFOEXW;
# 1530 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
typedef WSANAMESPACE_INFOA WSANAMESPACE_INFO;
typedef PWSANAMESPACE_INFOA PWSANAMESPACE_INFO;
typedef LPWSANAMESPACE_INFOA LPWSANAMESPACE_INFO;
typedef WSANAMESPACE_INFOEXA WSANAMESPACE_INFOEX;
typedef PWSANAMESPACE_INFOEXA PWSANAMESPACE_INFOEX;
typedef LPWSANAMESPACE_INFOEXA LPWSANAMESPACE_INFOEX;





/* Event flag definitions for WSAPoll(). */

#define POLLRDNORM 0x0100
#define POLLRDBAND 0x0200
#define POLLIN (POLLRDNORM | POLLRDBAND)
#define POLLPRI 0x0400

#define POLLWRNORM 0x0010
#define POLLOUT (POLLWRNORM)
#define POLLWRBAND 0x0020

#define POLLERR 0x0001
#define POLLHUP 0x0002
#define POLLNVAL 0x0004

typedef struct pollfd {

    SOCKET fd;
    SHORT events;
    SHORT revents;

} WSAPOLLFD, *PWSAPOLLFD, *LPWSAPOLLFD;




/* Socket function prototypes */




SOCKET

accept(
    SOCKET s,
    struct sockaddr * addr,
    int * addrlen
    );
# 1593 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

bind(
    SOCKET s,
    const struct sockaddr * name,
    int namelen
    );
# 1614 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

closesocket(
    SOCKET s
    );
# 1631 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

connect(
    SOCKET s,
    const struct sockaddr * name,
    int namelen
    );
# 1652 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

ioctlsocket(
    SOCKET s,
    long cmd,
    u_long * argp
    );
# 1673 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

getpeername(
    SOCKET s,
    struct sockaddr * name,
    int * namelen
    );
# 1694 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

getsockname(
    SOCKET s,
    struct sockaddr * name,
    int * namelen
    );
# 1715 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

getsockopt(
    SOCKET s,
    int level,
    int optname,
    char * optval,
    int * optlen
    );
# 1740 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

u_long

htonl(
    u_long hostlong
    );
# 1757 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

u_short

htons(
    u_short hostshort
    );
# 1774 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


unsigned long

inet_addr(
    const char * cp
    );
# 1792 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

char *

inet_ntoa(
    struct in_addr in
    );
# 1809 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

listen(
    SOCKET s,
    int backlog
    );
# 1828 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

u_long

ntohl(
    u_long netlong
    );
# 1845 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

u_short

ntohs(
    u_short netshort
    );
# 1862 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

recv(
    SOCKET s,
    char * buf,
    int len,
    int flags
    );
# 1885 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

recvfrom(
    SOCKET s,
    char * buf,
    int len,
    int flags,
    struct sockaddr * from,
    int * fromlen
    );
# 1912 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

select(
    int nfds,
    fd_set * readfds,
    fd_set * writefds,
    fd_set * exceptfds,
    const struct timeval * timeout
    );
# 1937 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

send(
    SOCKET s,
    const char * buf,
    int len,
    int flags
    );
# 1960 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

sendto(
    SOCKET s,
    const char * buf,
    int len,
    int flags,
    const struct sockaddr * to,
    int tolen
    );
# 1987 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

setsockopt(
    SOCKET s,
    int level,
    int optname,
    const char * optval,
    int optlen
    );
# 2012 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

shutdown(
    SOCKET s,
    int how
    );
# 2031 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


SOCKET

socket(
    int af,
    int type,
    int protocol
    );
# 2053 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* Database function prototypes */



struct hostent *

gethostbyaddr(
    const char * addr,
    int len,
    int type
    );
# 2077 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


struct hostent *

gethostbyname(
    const char * name
    );
# 2095 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

gethostname(
    char * name,
    int namelen
    );
# 2114 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


struct servent *

getservbyport(
    int port,
    const char * proto
    );
# 2134 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


struct servent *

getservbyname(
    const char * name,
    const char * proto
    );
# 2154 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


struct protoent *

getprotobynumber(
    int number
    );
# 2172 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


struct protoent *

getprotobyname(
    const char * name
    );
# 2189 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* Microsoft Windows Extension function prototypes */





int

WSAStartup(
    WORD wVersionRequested,
    LPWSADATA lpWSAData
    );
# 2214 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSACleanup(
    void
    );
# 2231 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

void

WSASetLastError(
    int iError
    );
# 2248 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSAGetLastError(
    void
    );
# 2265 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

BOOL

WSAIsBlocking(
    void
    );
# 2282 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSAUnhookBlockingHook(
    void
    );
# 2299 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

FARPROC

WSASetBlockingHook(
    FARPROC lpBlockFunc
    );
# 2316 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSACancelBlockingCall(
    void
    );
# 2333 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

HANDLE

WSAAsyncGetServByName(
    HWND hWnd,
    u_int wMsg,
    const char * name,
    const char * proto,
    char * buf,
    int buflen
    );
# 2360 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

HANDLE

WSAAsyncGetServByPort(
    HWND hWnd,
    u_int wMsg,
    int port,
    const char * proto,
    char * buf,
    int buflen
    );
# 2387 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

HANDLE

WSAAsyncGetProtoByName(
    HWND hWnd,
    u_int wMsg,
    const char * name,
    char * buf,
    int buflen
    );
# 2412 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

HANDLE

WSAAsyncGetProtoByNumber(
    HWND hWnd,
    u_int wMsg,
    int number,
    char * buf,
    int buflen
    );
# 2437 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

HANDLE

WSAAsyncGetHostByName(
    HWND hWnd,
    u_int wMsg,
    const char * name,
    char * buf,
    int buflen
    );
# 2462 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

HANDLE

WSAAsyncGetHostByAddr(
    HWND hWnd,
    u_int wMsg,
    const char * addr,
    int len,
    int type,
    char * buf,
    int buflen
    );
# 2491 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSACancelAsyncRequest(
    HANDLE hAsyncTaskHandle
    );
# 2508 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSAAsyncSelect(
    SOCKET s,
    HWND hWnd,
    u_int wMsg,
    long lEvent
    );
# 2531 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* WinSock 2 API new function prototypes */




SOCKET

WSAAccept(
    SOCKET s,
    struct sockaddr * addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD_PTR dwCallbackData
    );
# 2561 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

BOOL

WSACloseEvent(
    HANDLE hEvent
    );
# 2578 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSAConnect(
    SOCKET s,
    const struct sockaddr * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS
    );







#define WSAConnectByName WSAConnectByNameA




BOOL

WSAConnectByNameW(
    SOCKET s,
    LPWSTR nodename,
    LPWSTR servicename,
    LPDWORD LocalAddressLength,
    LPSOCKADDR LocalAddress,
    LPDWORD RemoteAddressLength,
    LPSOCKADDR RemoteAddress,
    const struct timeval * timeout,
    LPWSAOVERLAPPED Reserved);



BOOL

WSAConnectByNameA(
    SOCKET s,
    LPCSTR nodename,
    LPCSTR servicename,
    LPDWORD LocalAddressLength,
    LPSOCKADDR LocalAddress,
    LPDWORD RemoteAddressLength,
    LPSOCKADDR RemoteAddress,
    const struct timeval * timeout,
    LPWSAOVERLAPPED Reserved);



BOOL

WSAConnectByList(
    SOCKET s,
    PSOCKET_ADDRESS_LIST SocketAddress,
    LPDWORD LocalAddressLength,
    LPSOCKADDR LocalAddress,
    LPDWORD RemoteAddressLength,
    LPSOCKADDR RemoteAddress,
    const struct timeval * timeout,
    LPWSAOVERLAPPED Reserved);
# 2660 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

HANDLE

WSACreateEvent(
    void
    );
# 2677 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSADuplicateSocketA(
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOA lpProtocolInfo
    );


int

WSADuplicateSocketW(
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo
    );



#define WSADuplicateSocket WSADuplicateSocketA
# 2725 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSAEnumNetworkEvents(
    SOCKET s,
    HANDLE hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents
    );
# 2747 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSAEnumProtocolsA(
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    LPDWORD lpdwBufferLength
    );

int

WSAEnumProtocolsW(
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength
    );



#define WSAEnumProtocols WSAEnumProtocolsA
# 2793 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSAEventSelect(
    SOCKET s,
    HANDLE hEventObject,
    long lNetworkEvents
    );
# 2814 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


BOOL

WSAGetOverlappedResult(
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags
    );
# 2840 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


BOOL

WSAGetQOSByName(
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS
    );
# 2862 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSAHtonl(
    SOCKET s,
    u_long hostlong,
    u_long * lpnetlong
    );
# 2884 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSAHtons(
    SOCKET s,
    u_short hostshort,
    u_short * lpnetshort
    );
# 2906 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSAIoctl(
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 2939 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

SOCKET

WSAJoinLeaf(
    SOCKET s,
    const struct sockaddr * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags
    );
# 2970 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSANtohl(
    SOCKET s,
    u_long netlong,
    u_long * lphostlong
    );
# 2992 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSANtohs(
    SOCKET s,
    u_short netshort,
    u_short * lphostshort
    );
# 3014 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSARecv(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3043 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSARecvDisconnect(
    SOCKET s,
    LPWSABUF lpInboundDisconnectData
    );
# 3062 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSARecvFrom(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3095 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

BOOL

WSAResetEvent(
    HANDLE hEvent
    );
# 3112 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSASend(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3142 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSASendMsg(
    SOCKET Handle,
    LPWSAMSG lpMsg,
    DWORD dwFlags,
    LPDWORD lpNumberOfBytesSent,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );






int

WSASendDisconnect(
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData
    );
# 3177 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

int

WSASendTo(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3210 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

BOOL

WSASetEvent(
    HANDLE hEvent
    );
# 3227 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"



SOCKET

WSASocketA(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    GROUP g,
    DWORD dwFlags
    );




SOCKET

WSASocketW(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags
    );



#define WSASocket WSASocketA
# 3293 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

DWORD

WSAWaitForMultipleEvents(
    DWORD cEvents,
    const HANDLE * lphEvents,
    BOOL fWaitAll,
    DWORD dwTimeout,
    BOOL fAlertable
    );
# 3318 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

INT

WSAAddressToStringA(
    LPSOCKADDR lpsaAddress,
    DWORD dwAddressLength,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    LPSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength
    );

INT

WSAAddressToStringW(
    LPSOCKADDR lpsaAddress,
    DWORD dwAddressLength,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPWSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength
    );



#define WSAAddressToString WSAAddressToStringA
# 3372 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

INT

WSAStringToAddressA(
    LPSTR AddressString,
    INT AddressFamily,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    LPSOCKADDR lpAddress,
    LPINT lpAddressLength
    );

INT

WSAStringToAddressW(
    LPWSTR AddressString,
    INT AddressFamily,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPSOCKADDR lpAddress,
    LPINT lpAddressLength
    );



#define WSAStringToAddress WSAStringToAddressA
# 3425 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
/* Registration and Name Resolution API functions */





INT

WSALookupServiceBeginA(
    LPWSAQUERYSETA lpqsRestrictions,
    DWORD dwControlFlags,
    LPHANDLE lphLookup
    );


INT

WSALookupServiceBeginW(
    LPWSAQUERYSETW lpqsRestrictions,
    DWORD dwControlFlags,
    LPHANDLE lphLookup
    );



#define WSALookupServiceBegin WSALookupServiceBeginA
# 3477 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

INT

WSALookupServiceNextA(
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSETA lpqsResults
    );

INT

WSALookupServiceNextW(
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSETW lpqsResults
    );



#define WSALookupServiceNext WSALookupServiceNextA
# 3528 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


INT

WSANSPIoctl(
    HANDLE hLookup,
    DWORD dwControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSACOMPLETION lpCompletion
    );
# 3561 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

INT

WSALookupServiceEnd(
    HANDLE hLookup
    );
# 3578 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


INT

WSAInstallServiceClassA(
    LPWSASERVICECLASSINFOA lpServiceClassInfo
    );


INT

WSAInstallServiceClassW(
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );



#define WSAInstallServiceClass WSAInstallServiceClassA
# 3618 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


INT

WSARemoveServiceClass(
    LPGUID lpServiceClassId
    );
# 3636 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

INT

WSAGetServiceClassInfoA(
    LPGUID lpProviderId,
    LPGUID lpServiceClassId,
    LPDWORD lpdwBufSize,
    LPWSASERVICECLASSINFOA lpServiceClassInfo
    );

INT

WSAGetServiceClassInfoW(
    LPGUID lpProviderId,
    LPGUID lpServiceClassId,
    LPDWORD lpdwBufSize,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );



#define WSAGetServiceClassInfo WSAGetServiceClassInfoA
# 3686 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

INT

WSAEnumNameSpaceProvidersA(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOA lpnspBuffer
    );

INT

WSAEnumNameSpaceProvidersW(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOW lpnspBuffer
    );




#define WSAEnumNameSpaceProviders WSAEnumNameSpaceProvidersA




INT

WSAEnumNameSpaceProvidersExA(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOEXA lpnspBuffer
    );

INT

WSAEnumNameSpaceProvidersExW(
    LPDWORD lpdwBufferLength,
    LPWSANAMESPACE_INFOEXW lpnspBuffer
    );




#define WSAEnumNameSpaceProvidersEx WSAEnumNameSpaceProvidersExA
# 3777 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"

 INT

WSAGetServiceClassNameByClassIdA(
    LPGUID lpServiceClassId,
    LPSTR lpszServiceClassName,
    LPDWORD lpdwBufferLength
    );

 INT

WSAGetServiceClassNameByClassIdW(
    LPGUID lpServiceClassId,
    LPWSTR lpszServiceClassName,
    LPDWORD lpdwBufferLength
    );



#define WSAGetServiceClassNameByClassId WSAGetServiceClassNameByClassIdA
# 3823 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


INT

WSASetServiceA(
    LPWSAQUERYSETA lpqsRegInfo,
    WSAESETSERVICEOP essoperation,
    DWORD dwControlFlags
    );


INT

WSASetServiceW(
    LPWSAQUERYSETW lpqsRegInfo,
    WSAESETSERVICEOP essoperation,
    DWORD dwControlFlags
    );



#define WSASetService WSASetServiceA
# 3871 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


INT

WSAProviderConfigChange(
    LPHANDLE lpNotificationHandle,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
# 3894 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"


int

WSAPoll(
    LPWSAPOLLFD fdArray,
    ULONG fds,
    INT timeout
    );





/* Microsoft Windows Extended data types */
typedef struct sockaddr_in *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger *LPLINGER;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval *LPTIMEVAL;

/*

 * Windows message parameter composition and decomposition

 * macros.

 *

 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation

 * when constructing the response to a WSAAsyncGetXByY() routine.

 */
# 3942 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define WSAMAKEASYNCREPLY(buflen,error) MAKELONG(buflen,error)
/*

 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation

 * when constructing the response to WSAAsyncSelect().

 */
# 3947 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define WSAMAKESELECTREPLY(event,error) MAKELONG(event,error)
/*

 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application

 * to extract the buffer length from the lParam in the response

 * to a WSAAsyncGetXByY().

 */
# 3953 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define WSAGETASYNCBUFLEN(lParam) LOWORD(lParam)
/*

 * WSAGETASYNCERROR is intended for use by the Windows Sockets application

 * to extract the error code from the lParam in the response

 * to a WSAGetXByY().

 */
# 3959 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define WSAGETASYNCERROR(lParam) HIWORD(lParam)
/*

 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application

 * to extract the event code from the lParam in the response

 * to a WSAAsyncSelect().

 */
# 3965 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define WSAGETSELECTEVENT(lParam) LOWORD(lParam)
/*

 * WSAGETSELECTERROR is intended for use by the Windows Sockets application

 * to extract the error code from the lParam in the response

 * to a WSAAsyncSelect().

 */
# 3971 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/winsock2.h"
#define WSAGETSELECTERROR(lParam) HIWORD(lParam)
# 31 "c_include/windows/original/ws2tcpip.h" 2
# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h" 1
/*++



Copyright (c) Microsoft Corporation. All rights reserved.



Module Name:



    ws2ipdef.h



Abstract:



    This file contains TCP/IP specific information for use

    by WinSock2 compatible applications.

  

   Copyright (c) Microsoft Corporation. All rights reserved.

  

    To provide the backward compatibility, all the TCP/IP

    specific definitions that were included in the WINSOCK.H

    file are now included in WINSOCK2.H file. WS2TCPIP.H

    file includes only the definitions  introduced in the

    "WinSock 2 Protocol-Specific Annex" document.

  

    Rev 0.3 Nov 13, 1995

        Rev 0.4 Dec 15, 1996



Environment:



    user mode or kernel mode



--*/
# 32 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h"
#define _WS2IPDEF_ 
# 42 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h"
#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4127)







#define WS2IPDEF_ASSERT(exp) ((VOID) 0)





#define WS2TCPIP_INLINE extern inline


# 1 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/in6addr.h" 1
/*++



Copyright (c) Microsoft Corporation



Module Name:



    in6addr.h



Environment:



    user mode or kernel mode



--*/
# 16 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/in6addr.h"
       

//
// IPv6 Internet address (RFC 2553)
// This is an 'on-wire' format structure.
//
typedef struct in6_addr {
    union {
        UCHAR Byte[16];
        USHORT Word[8];
    } u;
} IN6_ADDR, *PIN6_ADDR, *LPIN6_ADDR;

#define in_addr6 in6_addr

//
// Defines to match RFC 2553.
//
#define _S6_un u
#define _S6_u8 Byte
#define s6_addr _S6_un._S6_u8

//
// Defines for our implementation.
//
#define s6_bytes u.Byte
#define s6_words u.Word
# 62 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h" 2

//
// Old IPv6 socket address structure (retained for sockaddr_gen definition).
//

struct sockaddr_in6_old {
    SHORT sin6_family; // AF_INET6.
    USHORT sin6_port; // Transport level port number.
    ULONG sin6_flowinfo; // IPv6 flow information.
    IN6_ADDR sin6_addr; // IPv6 address.
};

typedef union sockaddr_gen {
    struct sockaddr Address;
    struct sockaddr_in AddressIn;
    struct sockaddr_in6_old AddressIn6;
} sockaddr_gen;

//
// Structure to keep interface specific information
//

typedef struct _INTERFACE_INFO {
    ULONG iiFlags; // Interface flags.
    sockaddr_gen iiAddress; // Interface address.
    sockaddr_gen iiBroadcastAddress; // Broadcast address.
    sockaddr_gen iiNetmask; // Network mask.
} INTERFACE_INFO, *LPINTERFACE_INFO;

//
// New structure that does not have dependency on the address size.
//

typedef struct _INTERFACE_INFO_EX {
    ULONG iiFlags; // Interface flags.
    SOCKET_ADDRESS iiAddress; // Interface address.
    SOCKET_ADDRESS iiBroadcastAddress; // Broadcast address.
    SOCKET_ADDRESS iiNetmask; // Network mask.
} INTERFACE_INFO_EX, *LPINTERFACE_INFO_EX;

//
// Possible flags for the  iiFlags - bitmask.
//

#define IFF_UP 0x00000001
#define IFF_BROADCAST 0x00000002
#define IFF_LOOPBACK 0x00000004
#define IFF_POINTTOPOINT 0x00000008
#define IFF_MULTICAST 0x00000010


//
// Options to use with [gs]etsockopt at the IPPROTO_IP level.
// The values should be consistent with the IPv6 equivalents.
//
#define IP_OPTIONS 1
#define IP_HDRINCL 2
#define IP_TOS 3
#define IP_TTL 4
#define IP_MULTICAST_IF 9
#define IP_MULTICAST_TTL 10
#define IP_MULTICAST_LOOP 11
#define IP_ADD_MEMBERSHIP 12
#define IP_DROP_MEMBERSHIP 13
#define IP_DONTFRAGMENT 14
#define IP_ADD_SOURCE_MEMBERSHIP 15
#define IP_DROP_SOURCE_MEMBERSHIP 16
#define IP_BLOCK_SOURCE 17
#define IP_UNBLOCK_SOURCE 18
#define IP_PKTINFO 19
#define IP_HOPLIMIT 21
#define IP_RECEIVE_BROADCAST 22
#define IP_RECVIF 24
#define IP_RECVDSTADDR 25
#define IP_IFLIST 28
#define IP_ADD_IFLIST 29
#define IP_DEL_IFLIST 30
#define IP_UNICAST_IF 31
#define IP_RTHDR 32
#define IP_RECVRTHDR 38
#define IP_TCLASS 39
#define IP_RECVTCLASS 40
#define IP_ORIGINAL_ARRIVAL_IF 47

#define IP_UNSPECIFIED_TYPE_OF_SERVICE -1

#define IPV6_ADDRESS_BITS RTL_BITS_OF(IN6_ADDR)

//
// IPv6 socket address structure, RFC 3493.
//

//
// NB: The LH version of sockaddr_in6 has the struct tag sockaddr_in6 rather
// than sockaddr_in6_lh.  This is to make sure that standard sockets apps
// that conform to RFC 2553 (Basic Socket Interface Extensions for IPv6).
//
typedef struct sockaddr_in6 {
    ADDRESS_FAMILY sin6_family; // AF_INET6.
    USHORT sin6_port; // Transport level port number.
    ULONG sin6_flowinfo; // IPv6 flow information.
    IN6_ADDR sin6_addr; // IPv6 address.
    union {
        ULONG sin6_scope_id; // Set of interfaces for a scope.
        SCOPE_ID sin6_scope_struct;
    };
} SOCKADDR_IN6_LH, *PSOCKADDR_IN6_LH, *LPSOCKADDR_IN6_LH;

typedef struct sockaddr_in6_w2ksp1 {
    short sin6_family; /* AF_INET6 */
    USHORT sin6_port; /* Transport level port number */
    ULONG sin6_flowinfo; /* IPv6 flow information */
    struct in6_addr sin6_addr; /* IPv6 address */
    ULONG sin6_scope_id; /* set of interfaces for a scope */
} SOCKADDR_IN6_W2KSP1, *PSOCKADDR_IN6_W2KSP1, *LPSOCKADDR_IN6_W2KSP1;


typedef SOCKADDR_IN6_LH SOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *LPSOCKADDR_IN6;
# 192 "C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/Include/ws2ipdef.h"
typedef union _SOCKADDR_INET {
    SOCKADDR_IN Ipv4;
    SOCKADDR_IN6 Ipv6;
    ADDRESS_FAMILY si_family;
} SOCKADDR_INET, *PSOCKADDR_INET;

//
// Structure to hold a pair of source, destination addresses.
//
typedef struct _sockaddr_in6_pair
{
    PSOCKADDR_IN6 SourceAddress;
    PSOCKADDR_IN6 DestinationAddress;
} SOCKADDR_IN6_PAIR, *PSOCKADDR_IN6_PAIR;

//
// Macro that works for both IPv4 and IPv6
//
#define SS_PORT(ssp) (((PSOCKADDR_IN)(ssp))->sin_port)


//
// N.B. These addresses are in network byte order.
//

#define IN6ADDR_ANY_INIT { 0 }

#define IN6ADDR_LOOPBACK_INIT { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }

#define IN6ADDR_ALLNODESONNODE_INIT { 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }




#define IN6ADDR_ALLNODESONLINK_INIT { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }




#define IN6ADDR_ALLROUTERSONLINK_INIT { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 }




#define IN6ADDR_ALLMLDV2ROUTERSONLINK_INIT { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16 }




#define IN6ADDR_TEREDOINITIALLINKLOCALADDRESS_INIT { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe }




//
// The old link local address for XP-SP2/Win2K3 machines.
//
#define IN6ADDR_TEREDOOLDLINKLOCALADDRESSXP_INIT { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 'T', 'E', 'R', 'E', 'D', 'O' }




//
// The old link local address for Vista Beta-2 and earlier machines.
//
#define IN6ADDR_TEREDOOLDLINKLOCALADDRESSVISTA_INIT { 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }




#define IN6ADDR_LINKLOCALPREFIX_INIT { 0xfe, 0x80, }

#define IN6ADDR_MULTICASTPREFIX_INIT { 0xff, 0x00, }

#define IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_INIT { 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, }




#define IN6ADDR_V4MAPPEDPREFIX_INIT { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, }




#define IN6ADDR_6TO4PREFIX_INIT { 0x20, 0x02, }

#define IN6ADDR_TEREDOPREFIX_INIT { 0x20, 0x01, 0x00, 0x00, }

#define IN6ADDR_TEREDOPREFIX_INIT_OLD { 0x3f, 0xfe, 0x83, 0x1f, }

#define IN6ADDR_LINKLOCALPREFIX_LENGTH 64

#define IN6ADDR_MULTICASTPREFIX_LENGTH 8

#define IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH 104

#define IN6ADDR_V4MAPPEDPREFIX_LENGTH 96

#define IN6ADDR_6TO4PREFIX_LENGTH 16

#define IN6ADDR_TEREDOPREFIX_LENGTH 32





//
// N.B. These addresses are in network byte order.
//
extern const SCOPE_ID scopeid_unspecified;

extern const IN_ADDR in4addr_any;
extern const IN_ADDR in4addr_loopback;
extern const IN_ADDR in4addr_broadcast;
extern const IN_ADDR in4addr_allnodesonlink;
extern const IN_ADDR in4addr_allroutersonlink;
extern const IN_ADDR in4addr_alligmpv3routersonlink;
extern const IN_ADDR in4addr_allteredohostsonlink;
extern const IN_ADDR in4addr_linklocalprefix;
extern const IN_ADDR in4addr_multicastprefix;

extern const IN6_ADDR in6addr_any;
extern const IN6_ADDR in6addr_loopback;
extern const IN6_ADDR in6addr_allnodesonnode;
extern const IN6_ADDR in6addr_allnodesonlink;
extern const IN6_ADDR in6addr_allroutersonlink;
extern const IN6_ADDR in6addr_allmldv2routersonlink;
extern const IN6_ADDR in6addr_teredoinitiallinklocaladdress;
extern const IN6_ADDR in6addr_linklocalprefix;
extern const IN6_ADDR in6addr_multicastprefix;
extern const IN6_ADDR in6addr_solicitednodemulticastprefix;
extern const IN6_ADDR in6addr_v4mappedprefix;
extern const IN6_ADDR in6addr_6to4prefix;
extern const IN6_ADDR in6addr_teredoprefix;
extern const IN6_ADDR in6addr_teredoprefix_old;







extern inline
BOOLEAN
IN6_ADDR_EQUAL(const IN6_ADDR *x, const IN6_ADDR *y)
{
    __int64 *a;
    __int64 *b;

    a = (__int64 *)x;
    b = (__int64 *)y;

    return (BOOLEAN)((a[1] == b[1]) && (a[0] == b[0]));
}

//
// RFC 3542 uses IN6_ARE_ADDR_EQUAL().
//
#define IN6_ARE_ADDR_EQUAL IN6_ADDR_EQUAL

extern inline
BOOLEAN
IN6_IS_ADDR_UNSPECIFIED(const IN6_ADDR *a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     (a->u.Word[6] == 0) &&
                     (a->u.Word[7] == 0));
}

extern inline
BOOLEAN
IN6_IS_ADDR_LOOPBACK(const IN6_ADDR *a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     (a->u.Word[6] == 0) &&
                     (a->u.Word[7] == 0x0100));
}

extern inline
BOOLEAN
IN6_IS_ADDR_MULTICAST(const IN6_ADDR *a)
{
    return (BOOLEAN)(a->u.Byte[0] == 0xff);
}

//
//  Does the address have a format prefix
//  that indicates it uses EUI-64 interface identifiers?
//
extern inline
BOOLEAN
IN6_IS_ADDR_EUI64(const IN6_ADDR *a)
{
    //
    // Format prefixes 001 through 111, except for multicast.
    //
    return (BOOLEAN)(((a->u.Byte[0] & 0xe0) != 0) &&
                     !IN6_IS_ADDR_MULTICAST(a));
}

//
//  Is this the subnet router anycast address?
//  See RFC 2373.
//
extern inline
BOOLEAN
IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     (a->u.Word[6] == 0) &&
                     (a->u.Word[7] == 0));
}

//
//  Is this a subnet reserved anycast address?
//  See RFC 2526. It talks about non-EUI-64
//  addresses as well, but IMHO that part
//  of the RFC doesn't make sense. For example,
//  it shouldn't apply to multicast or v4-compatible
//  addresses.
//
extern inline
BOOLEAN
IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->u.Word[4] == 0xfffd) &&
                     (a->u.Word[5] == 0xffff) &&
                     (a->u.Word[6] == 0xffff) &&
                     ((a->u.Word[7] & 0x80ff) == 0x80ff));
}

//
//  As best we can tell from simple inspection,
//  is this an anycast address?
//
extern inline
BOOLEAN
IN6_IS_ADDR_ANYCAST(const IN6_ADDR *a)
{
    return (IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(a) ||
            IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(a));
}

extern inline
BOOLEAN
IN6_IS_ADDR_LINKLOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Byte[0] == 0xfe) &&
                     ((a->u.Byte[1] & 0xc0) == 0x80));
}

extern inline
BOOLEAN
IN6_IS_ADDR_SITELOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Byte[0] == 0xfe) &&
                     ((a->u.Byte[1] & 0xc0) == 0xc0));
}

extern inline
BOOLEAN
IN6_IS_ADDR_GLOBAL(const IN6_ADDR *a)
{
    //
    // Check the format prefix and exclude addresses
    // whose high 4 bits are all zero or all one.
    // This is a cheap way of excluding v4-compatible,
    // v4-mapped, loopback, multicast, link-local, site-local.
    //
    ULONG High = (a->u.Byte[0] & 0xf0);
    return (BOOLEAN)((High != 0) && (High != 0xf0));
}

extern inline
BOOLEAN
IN6_IS_ADDR_V4MAPPED(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0xffff));
}

extern inline
BOOLEAN
IN6_IS_ADDR_V4COMPAT(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0) &&
                     (a->u.Word[5] == 0) &&
                     !((a->u.Word[6] == 0) &&
                       (a->u.Byte[14] == 0) &&
                       ((a->u.Byte[15] == 0) || (a->u.Byte[15] == 1))));
}

extern inline
BOOLEAN
IN6_IS_ADDR_V4TRANSLATED(const IN6_ADDR *a)
{
    return (BOOLEAN)((a->u.Word[0] == 0) &&
                     (a->u.Word[1] == 0) &&
                     (a->u.Word[2] == 0) &&
                     (a->u.Word[3] == 0) &&
                     (a->u.Word[4] == 0xffff) &&
                     (a->u.Word[5] == 0));
}

extern inline
BOOLEAN
IN6_IS_ADDR_MC_NODELOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 1));
}

extern inline
BOOLEAN
IN6_IS_ADDR_MC_LINKLOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 2));
}

extern inline
BOOLEAN
IN6_IS_ADDR_MC_SITELOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 5));
}

extern inline
BOOLEAN
IN6_IS_ADDR_MC_ORGLOCAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 8));
}

extern inline
BOOLEAN
IN6_IS_ADDR_MC_GLOBAL(const IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->u.Byte[1] & 0xf) == 0xe));
}

extern inline
void
IN6_SET_ADDR_UNSPECIFIED(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->u.Byte, 0, sizeof(IN6_ADDR));
}

extern inline
void
IN6_SET_ADDR_LOOPBACK(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->u.Byte, 0, sizeof(IN6_ADDR));
    a->u.Byte[15] = 1;
}

extern inline
void
IN6ADDR_SETANY(PSOCKADDR_IN6 a)
{
    a->sin6_family = 23;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_UNSPECIFIED(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

extern inline
void
IN6ADDR_SETLOOPBACK(PSOCKADDR_IN6 a)
{
    a->sin6_family = 23;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_LOOPBACK(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

extern inline
BOOLEAN
IN6ADDR_ISANY(const SOCKADDR_IN6 *a)
{
    ((void) 0);
    return IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr);
}

extern inline
BOOLEAN
IN6ADDR_ISLOOPBACK(const SOCKADDR_IN6 *a)
{
    ((void) 0);
    return IN6_IS_ADDR_LOOPBACK(&a->sin6_addr);
}

extern inline
BOOLEAN
IN6ADDR_ISEQUAL(const SOCKADDR_IN6 *a, const SOCKADDR_IN6 *b)
{
    ((void) 0);
    return (BOOLEAN)(a->sin6_scope_id == b->sin6_scope_id &&
                     IN6_ADDR_EQUAL(&a->sin6_addr, &b->sin6_addr));
}

extern inline
BOOLEAN
IN6ADDR_ISUNSPECIFIED(const SOCKADDR_IN6 *a)
{
    ((void) 0);
    return (BOOLEAN)(a->sin6_scope_id == 0 &&
                     IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr));
}





//
// TCP/IP specific Ioctl codes.
//
#define SIO_GET_INTERFACE_LIST _IOR('t', 127, ULONG)
#define SIO_GET_INTERFACE_LIST_EX _IOR('t', 126, ULONG)
#define SIO_SET_MULTICAST_FILTER _IOW('t', 125, ULONG)
#define SIO_GET_MULTICAST_FILTER _IOW('t', 124 | IOC_IN, ULONG)
#define SIOCSIPMSFILTER SIO_SET_MULTICAST_FILTER
#define SIOCGIPMSFILTER SIO_GET_MULTICAST_FILTER

//
// Protocol independent ioctls for setting and retrieving multicast filters. 
//
#define SIOCSMSFILTER _IOW('t', 126, ULONG)
#define SIOCGMSFILTER _IOW('t', 127 | IOC_IN, ULONG)



#define IDEAL_SEND_BACKLOG_IOCTLS 

//
// Query and change notification ioctls for the ideal send backlog size
// for a given connection. Clients should use the wrappers defined in 
// ws2tcpip.h rather than using these ioctls directly.
//

#define SIO_IDEAL_SEND_BACKLOG_QUERY _IOR('t', 123, ULONG)
#define SIO_IDEAL_SEND_BACKLOG_CHANGE _IO('t', 122)



//
// Protocol independent multicast source filter options.
//
#define MCAST_JOIN_GROUP 41
#define MCAST_LEAVE_GROUP 42
#define MCAST_BLOCK_SOURCE 43
#define MCAST_UNBLOCK_SOURCE 44
#define MCAST_JOIN_SOURCE_GROUP 45
#define MCAST_LEAVE_SOURCE_GROUP 46

//
// Definitions of MCAST_INCLUDE and MCAST_EXCLUDE for multicast source filter. 
//
typedef enum {
    MCAST_INCLUDE = 0,
    MCAST_EXCLUDE
} MULTICAST_MODE_TYPE;

//
// Structure for IP_MREQ (used by IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP). 
//
typedef struct ip_mreq {
    IN_ADDR imr_multiaddr; // IP multicast address of group.
    IN_ADDR imr_interface; // Local IP address of interface.
} IP_MREQ, *PIP_MREQ;

//
// Structure for IP_MREQ_SOURCE (used by IP_BLOCK_SOURCE, IP_UNBLOCK_SOURCE
// etc.). 
//
typedef struct ip_mreq_source {
    IN_ADDR imr_multiaddr; // IP multicast address of group.
    IN_ADDR imr_sourceaddr; // IP address of source.
    IN_ADDR imr_interface; // Local IP address of interface.
} IP_MREQ_SOURCE, *PIP_MREQ_SOURCE;

//
// Structure for IP_MSFILTER (used by SIOCSIPMSFILTER and SIOCGIPMSFILTER). 
// 
typedef struct ip_msfilter {
    IN_ADDR imsf_multiaddr; // IP multicast address of group.
    IN_ADDR imsf_interface; // Local IP address of interface.
    MULTICAST_MODE_TYPE imsf_fmode; // Filter mode.
    ULONG imsf_numsrc; // Number of sources in src_list.
    IN_ADDR imsf_slist[1]; // Start of source list.
} IP_MSFILTER, *PIP_MSFILTER;

#define IP_MSFILTER_SIZE(NumSources) (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (NumSources) * sizeof(IN_ADDR))


//
// Options to use with [gs]etsockopt at the IPPROTO_IPV6 level.
// These are specified in RFCs 3493 and 3542.
// The values should be consistent with the IPv6 equivalents.
//
#define IPV6_HOPOPTS 1
#define IPV6_HDRINCL 2
#define IPV6_UNICAST_HOPS 4
#define IPV6_MULTICAST_IF 9
#define IPV6_MULTICAST_HOPS 10
#define IPV6_MULTICAST_LOOP 11
#define IPV6_ADD_MEMBERSHIP 12
#define IPV6_JOIN_GROUP IPV6_ADD_MEMBERSHIP
#define IPV6_DROP_MEMBERSHIP 13
#define IPV6_LEAVE_GROUP IPV6_DROP_MEMBERSHIP
#define IPV6_DONTFRAG 14
#define IPV6_PKTINFO 19
#define IPV6_HOPLIMIT 21
#define IPV6_PROTECTION_LEVEL 23
#define IPV6_RECVIF 24
#define IPV6_RECVDSTADDR 25
#define IPV6_CHECKSUM 26
#define IPV6_V6ONLY 27
#define IPV6_IFLIST 28
#define IPV6_ADD_IFLIST 29
#define IPV6_DEL_IFLIST 30
#define IPV6_UNICAST_IF 31
#define IPV6_RTHDR 32
#define IPV6_RECVRTHDR 38
#define IPV6_TCLASS 39
#define IPV6_RECVTCLASS 40

#define IP_UNSPECIFIED_HOP_LIMIT -1

#define IP_PROTECTION_LEVEL IPV6_PROTECTION_LEVEL
//
// Values of IPV6_PROTECTION_LEVEL.
//
#define PROTECTION_LEVEL_UNRESTRICTED 10
#define PROTECTION_LEVEL_EDGERESTRICTED 20
                                           // Teredo.
#define PROTECTION_LEVEL_RESTRICTED 30




#define PROTECTION_LEVEL_DEFAULT ((UINT)-1)

//
// Structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP (also,
// IPV6_ADD_MEMBERSHIP and IPV6_DROP_MEMBERSHIP).
//
typedef struct ipv6_mreq {
    IN6_ADDR ipv6mr_multiaddr; // IPv6 multicast address.
    ULONG ipv6mr_interface; // Interface index.
} IPV6_MREQ, *PIPV6_MREQ;


//
// Structure for GROUP_REQ used by protocol independent source filters
// (MCAST_JOIN_GROUP and MCAST_LEAVE_GROUP). 
//
typedef struct group_req {
    ULONG gr_interface; // Interface index.
    SOCKADDR_STORAGE gr_group; // Multicast address.
} GROUP_REQ, *PGROUP_REQ;

//
// Structure for GROUP_SOURCE_REQ used by protocol independent source filters
// (MCAST_JOIN_SOURCE_GROUP, MCAST_LEAVE_SOURCE_GROUP etc.).
//
typedef struct group_source_req {
    ULONG gsr_interface; // Interface index.
    SOCKADDR_STORAGE gsr_group; // Group address.
    SOCKADDR_STORAGE gsr_source; // Source address.
} GROUP_SOURCE_REQ, *PGROUP_SOURCE_REQ;

//
// Structure for GROUP_FILTER used by protocol independent source filters
// (SIOCSMSFILTER and SIOCGMSFILTER).
//
typedef struct group_filter {
    ULONG gf_interface; // Interface index.
    SOCKADDR_STORAGE gf_group; // Multicast address.
    MULTICAST_MODE_TYPE gf_fmode; // Filter mode.
    ULONG gf_numsrc; // Number of sources.
    SOCKADDR_STORAGE gf_slist[1]; // Source address.
} GROUP_FILTER, *PGROUP_FILTER;

#define GROUP_FILTER_SIZE(numsrc) (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) + (numsrc) * sizeof(SOCKADDR_STORAGE))




//
// Structure for IP_PKTINFO option.
//
typedef struct in_pktinfo {
    IN_ADDR ipi_addr; // Source/destination IPv4 address.
    ULONG ipi_ifindex; // Send/receive interface index.
} IN_PKTINFO, *PIN_PKTINFO;

typedef char __C_ASSERT__[(sizeof(IN_PKTINFO) == 8)?1:-1];

//
// Structure for IPV6_PKTINFO option.
//
typedef struct in6_pktinfo {
    IN6_ADDR ipi6_addr; // Source/destination IPv6 address.
    ULONG ipi6_ifindex; // Send/receive interface index.
} IN6_PKTINFO, *PIN6_PKTINFO;

typedef char __C_ASSERT__[(sizeof(IN6_PKTINFO) == 20)?1:-1];

//
// Maximum length of address literals (potentially including a port number)
// generated by any address-to-string conversion routine.  This length can
// be used when declaring buffers used with getnameinfo, WSAAddressToString,
// inet_ntoa, etc.  We just provide one define, rather than one per api,
// to avoid confusion.
//
// The totals are derived from the following data:
//  15: IPv4 address
//  45: IPv6 address including embedded IPv4 address
//  11: Scope Id
//   2: Brackets around IPv6 address when port is present
//   6: Port (including colon)
//   1: Terminating null byte
//
#define INET_ADDRSTRLEN 22
#define INET6_ADDRSTRLEN 65



//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
// TCP_NODELAY is defined in ws2def.h for historical reasons.
//

//
// Offload preferences supported.
//
#define TCP_OFFLOAD_NO_PREFERENCE 0
#define TCP_OFFLOAD_NOT_PREFERRED 1
#define TCP_OFFLOAD_PREFERRED 2

//      TCP_NODELAY         	 0x0001
#define TCP_EXPEDITED_1122 0x0002
#define TCP_KEEPALIVE 3
#define TCP_MAXSEG 4
#define TCP_MAXRT 5
#define TCP_STDURG 6
#define TCP_NOURG 7
#define TCP_ATMARK 8
#define TCP_NOSYNRETRIES 9
#define TCP_TIMESTAMPS 10
#define TCP_OFFLOAD_PREFERENCE 11
#define TCP_CONGESTION_ALGORITHM 12
#define TCP_DELAY_FIN_ACK 13





#pragma warning(pop)
# 32 "c_include/windows/original/ws2tcpip.h" 2
# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h" 1
/***

*limits.h - implementation dependent values

*

*       Copyright (c) Microsoft Corporation.  All rights reserved.

*

*Purpose:

*       Contains defines for a number of implementation dependent values

*       which are commonly used in C programs.

*       [ANSI]

*

*       [Public]

*

****/
# 15 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h"
       

# 1 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h" 1
/***

*crtdefs.h - definitions/declarations common to all CRT

*

*       Copyright (c) Microsoft Corporation. All rights reserved.

*

*Purpose:

*       This file has mostly defines used by the entire CRT.

*

*       [Public]

*

****/
# 13 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/crtdefs.h"
/* Lack of pragma once is deliberate */

/* Define _CRTIMP */
# 18 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h" 2


#define _INC_LIMITS 


#define CHAR_BIT 8
#define SCHAR_MIN (-128)
#define SCHAR_MAX 127
#define UCHAR_MAX 0xff


#define CHAR_MIN SCHAR_MIN
#define CHAR_MAX SCHAR_MAX





#define MB_LEN_MAX 5
#define SHRT_MIN (-32768)
#define SHRT_MAX 32767
#define USHRT_MAX 0xffff
#define INT_MIN (-2147483647 - 1)
#define INT_MAX 2147483647
#define UINT_MAX 0xffffffff
#define LONG_MIN (-2147483647L - 1)
#define LONG_MAX 2147483647L
#define ULONG_MAX 0xffffffffUL
#define LLONG_MAX 9223372036854775807i64
#define LLONG_MIN (-9223372036854775807i64 - 1)
#define ULLONG_MAX 0xffffffffffffffffui64

#define _I8_MIN (-127i8 - 1)
#define _I8_MAX 127i8
#define _UI8_MAX 0xffui8

#define _I16_MIN (-32767i16 - 1)
#define _I16_MAX 32767i16
#define _UI16_MAX 0xffffui16

#define _I32_MIN (-2147483647i32 - 1)
#define _I32_MAX 2147483647i32
#define _UI32_MAX 0xffffffffui32

/* minimum signed 64 bit value */
#define _I64_MIN (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX 9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX 0xffffffffffffffffui64
# 80 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h"
#define SIZE_MAX _UI64_MAX






/* While waiting to the C standard committee to finalize the decision on RSIZE_MAX and rsize_t,

 * we define RSIZE_MAX as SIZE_MAX

 */
# 91 "C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/limits.h"
#define RSIZE_MAX SIZE_MAX
# 33 "c_include/windows/original/ws2tcpip.h" 2

/* Option to use with [gs]etsockopt at the IPPROTO_UDP level */

#define UDP_NOCHECKSUM 1
#define UDP_CHECKSUM_COVERAGE 20




#define WS2TCPIP_INLINE extern inline


/* Error codes from getaddrinfo() */

#define EAI_AGAIN WSATRY_AGAIN
#define EAI_BADFLAGS WSAEINVAL
#define EAI_FAIL WSANO_RECOVERY
#define EAI_FAMILY WSAEAFNOSUPPORT
#define EAI_MEMORY WSA_NOT_ENOUGH_MEMORY
#define EAI_NOSECURENAME WSA_SECURE_HOST_NOT_FOUND
//#define EAI_NODATA        WSANO_DATA
#define EAI_NONAME WSAHOST_NOT_FOUND
#define EAI_SERVICE WSATYPE_NOT_FOUND
#define EAI_SOCKTYPE WSAESOCKTNOSUPPORT
#define EAI_IPSECPOLICY WSA_IPSEC_NAME_POLICY_ERROR
//
//  DCR_FIX:  EAI_NODATA remove or fix
//
//  EAI_NODATA was removed from rfc2553bis
//  need to find out from the authors why and
//  determine the error for "no records of this type"
//  temporarily, we'll keep #define to avoid changing
//  code that could change back;  use NONAME
//

#define EAI_NODATA EAI_NONAME

//  Switchable definition for GetAddrInfo()




typedef ADDRINFOA ADDRINFOT, *PADDRINFOT;


//  RFC standard definition for getaddrinfo()

typedef ADDRINFOA ADDRINFO, * LPADDRINFO;






typedef ADDRINFOEXA ADDRINFOEX, *PADDRINFOEX;
# 96 "c_include/windows/original/ws2tcpip.h"

INT

getaddrinfo(
    PCSTR pNodeName,
    PCSTR pServiceName,
    const ADDRINFOA * pHints,
    PADDRINFOA * ppResult
    );



INT

GetAddrInfoW(
    PCWSTR pNodeName,
    PCWSTR pServiceName,
    const ADDRINFOW * pHints,
    PADDRINFOW * ppResult
    );

#define GetAddrInfoA getaddrinfo




#define GetAddrInfo GetAddrInfoA
# 156 "c_include/windows/original/ws2tcpip.h"
typedef
void
( * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD dwBytes,
    LPWSAOVERLAPPED lpOverlapped
    );


INT

GetAddrInfoExA(
    PCSTR pName,
    PCSTR pServiceName,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    const ADDRINFOEXA *hints,
    PADDRINFOEXA * ppResult,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpNameHandle
    );


INT

GetAddrInfoExW(
    PCWSTR pName,
    PCWSTR pServiceName,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    const ADDRINFOEXW *hints,
    PADDRINFOEXW * ppResult,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpHandle
    );




#define GetAddrInfoEx GetAddrInfoExA
# 245 "c_include/windows/original/ws2tcpip.h"

INT

SetAddrInfoExA(
    PCSTR pName,
    PCSTR pServiceName,
    SOCKET_ADDRESS *pAddresses,
    DWORD dwAddressCount,
    LPBLOB lpBlob,
    DWORD dwFlags,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpNameHandle
    );


INT

SetAddrInfoExW(
    PCWSTR pName,
    PCWSTR pServiceName,
    SOCKET_ADDRESS *pAddresses,
    DWORD dwAddressCount,
    LPBLOB lpBlob,
    DWORD dwFlags,
    DWORD dwNameSpace,
    LPGUID lpNspId,
    struct timeval *timeout,
    LPOVERLAPPED lpOverlapped,
    LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine,
    LPHANDLE lpNameHandle
    );




#define SetAddrInfoEx SetAddrInfoExA
# 331 "c_include/windows/original/ws2tcpip.h"

void

freeaddrinfo(
    PADDRINFOA pAddrInfo
    );



void

FreeAddrInfoW(
    PADDRINFOW pAddrInfo
    );

#define FreeAddrInfoA freeaddrinfo




#define FreeAddrInfo FreeAddrInfoA
# 379 "c_include/windows/original/ws2tcpip.h"

void

FreeAddrInfoEx(
    PADDRINFOEXA pAddrInfoEx
    );


void

FreeAddrInfoExW(
    PADDRINFOEXW pAddrInfoEx
    );

#define FreeAddrInfoExA FreeAddrInfoEx






typedef
void
( *LPFN_FREEADDRINFOEXA)(
    PADDRINFOEXA pAddrInfoEx
    );

typedef
void
( *LPFN_FREEADDRINFOEXW)(
    PADDRINFOEXW pAddrInfoEx
    );





#define LPFN_FREEADDRINFOEX LPFN_FREEADDRINFOEXA





typedef int socklen_t;


INT

getnameinfo(
    const SOCKADDR * pSockaddr,
    socklen_t SockaddrLength,
    PCHAR pNodeBuffer,
    DWORD NodeBufferSize,
    PCHAR pServiceBuffer,
    DWORD ServiceBufferSize,
    INT Flags
    );



INT

GetNameInfoW(
    const SOCKADDR * pSockaddr,
    socklen_t SockaddrLength,
    PWCHAR pNodeBuffer,
    DWORD NodeBufferSize,
    PWCHAR pServiceBuffer,
    DWORD ServiceBufferSize,
    INT Flags
    );

#define GetNameInfoA getnameinfo




#define GetNameInfo GetNameInfoA
# 496 "c_include/windows/original/ws2tcpip.h"

INT

inet_pton(
    INT Family,
    PCSTR pszAddrString,
    PVOID pAddrBuf
    );

INT

InetPtonW(
    INT Family,
    PCWSTR pszAddrString,
    PVOID pAddrBuf
    );

PCSTR

inet_ntop(
    INT Family,
    PVOID pAddr,
    PSTR pStringBuf,
    size_t StringBufSize
    );

PCWSTR

InetNtopW(
    INT Family,
    PVOID pAddr,
    PWSTR pStringBuf,
    size_t StringBufSize
    );

#define InetPtonA inet_pton
#define InetNtopA inet_ntop





#define InetPton InetPtonA
#define InetNtop InetNtopA
# 594 "c_include/windows/original/ws2tcpip.h"
#define gai_strerror gai_strerrorA


// WARNING: The gai_strerror inline functions below use static buffers,
// and hence are not thread-safe.  We'll use buffers long enough to hold
// 1k characters.  Any system error messages longer than this will be
// returned as empty strings.  However 1k should work for the error codes
// used by getaddrinfo().
#define GAI_STRERROR_BUFFER_SIZE 1024

extern inline
char *
gai_strerrorA(
    int ecode)
{
    DWORD dwMsgLen;
    static char buff[1024 + 1];

    dwMsgLen = FormatMessageA(0x00001000
                             |0x00000200
                             |0x000000FF,
                              ((void *)0),
                              ecode,
                              ((((WORD )(0x01)) << 10) | (WORD )(0x00)),
                              (LPSTR)buff,
                              1024,
                              ((void *)0));

    return buff;
}

extern inline
WCHAR *
gai_strerrorW(
    int ecode
    )
{
    DWORD dwMsgLen;
    static WCHAR buff[1024 + 1];

    dwMsgLen = FormatMessageW(0x00001000
                             |0x00000200
                             |0x000000FF,
                              ((void *)0),
                              ecode,
                              ((((WORD )(0x01)) << 10) | (WORD )(0x00)),
                              (LPWSTR)buff,
                              1024,
                              ((void *)0));

    return buff;
}



/* Multicast source filter APIs from RFC 3678. */

extern inline
int
setipv4sourcefilter(
    SOCKET Socket,
    IN_ADDR Interface,
    IN_ADDR Group,
    MULTICAST_MODE_TYPE FilterMode,
    ULONG SourceCount,
    const IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;

    if (SourceCount >
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }

    Size = (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (SourceCount) * sizeof(IN_ADDR));
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }

    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_fmode = FilterMode;
    Filter->imsf_numsrc = SourceCount;
    if (SourceCount > 0) {
        memcpy((Filter->imsf_slist),(SourceList),(SourceCount * sizeof(*SourceList)))
                                                     ;
    }

    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(125)), Filter, Size, ((void *)0), 0,
                     &Returned, ((void *)0), ((void *)0));

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

extern inline
int
getipv4sourcefilter(
    SOCKET Socket,
    IN_ADDR Interface,
    IN_ADDR Group,
    MULTICAST_MODE_TYPE *FilterMode,
    ULONG *SourceCount,
    IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;

    if (*SourceCount >
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }

    Size = (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (*SourceCount) * sizeof(IN_ADDR));
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }

    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_numsrc = *SourceCount;

    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(124 | 0x80000000)), Filter, Size, Filter, Size,
                     &Returned, ((void *)0), ((void *)0));

    if (Error == 0) {
        if (*SourceCount > 0) {
            memcpy((SourceList),(Filter->imsf_slist),(*SourceCount * sizeof(*SourceList)))
                                                          ;
            *SourceCount = Filter->imsf_numsrc;
        }
        *FilterMode = Filter->imsf_fmode;
    }

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}


extern inline
int
setsourcefilter(
    SOCKET Socket,
    ULONG Interface,
    const SOCKADDR *Group,
    int GroupLength,
    MULTICAST_MODE_TYPE FilterMode,
    ULONG SourceCount,
    const SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;

    if (SourceCount >=
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }

    Size = (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) + (SourceCount) * sizeof(SOCKADDR_STORAGE));
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }

    Filter->gf_interface = Interface;
    memset((&Filter->gf_group),0,(sizeof(Filter->gf_group)));
    memcpy((&Filter->gf_group),(Group),(GroupLength));
    Filter->gf_fmode = FilterMode;
    Filter->gf_numsrc = SourceCount;
    if (SourceCount > 0) {
        memcpy((Filter->gf_slist),(SourceList),(SourceCount * sizeof(*SourceList)))
                                                     ;
    }

    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(126)), Filter, Size, ((void *)0), 0,
                     &Returned, ((void *)0), ((void *)0));

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

extern inline
int
getsourcefilter(
    SOCKET Socket,
    ULONG Interface,
    const SOCKADDR *Group,
    int GroupLength,
    MULTICAST_MODE_TYPE *FilterMode,
    ULONG *SourceCount,
    SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;

    if (*SourceCount >
        (((ULONG) (0xffffffffUL - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(10055L);
        return (-1);
    }

    Size = (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) + (*SourceCount) * sizeof(SOCKADDR_STORAGE));
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == ((void *)0)) {
        WSASetLastError(10055L);
        return (-1);
    }

    Filter->gf_interface = Interface;
    memset((&Filter->gf_group),0,(sizeof(Filter->gf_group)));
    memcpy((&Filter->gf_group),(Group),(GroupLength));
    Filter->gf_numsrc = *SourceCount;

    Error = WSAIoctl(Socket, (0x80000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(127 | 0x80000000)), Filter, Size, Filter, Size,
                     &Returned, ((void *)0), ((void *)0));

    if (Error == 0) {
        if (*SourceCount > 0) {
            memcpy((SourceList),(Filter->gf_slist),(*SourceCount * sizeof(*SourceList)))
                                                          ;
            *SourceCount = Filter->gf_numsrc;
        }
        *FilterMode = Filter->gf_fmode;
    }

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}




//
// Wrapper functions for the ideal send backlog query and change notification
// ioctls
//

extern inline
int
idealsendbacklogquery(
    SOCKET s,
    ULONG *pISB
    )
{
    DWORD bytes;

    return WSAIoctl(s, (0x40000000|(((long)sizeof(ULONG)&0x7f)<<16)|(('t')<<8)|(123)),
                    ((void *)0), 0, pISB, sizeof(*pISB), &bytes, ((void *)0), ((void *)0));
}


extern inline
int
idealsendbacklognotify(
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    DWORD bytes;

    return WSAIoctl(s, (0x20000000|(('t')<<8)|(122)),
                    ((void *)0), 0, ((void *)0), 0, &bytes,
                    lpOverlapped, lpCompletionRoutine);
}
# 957 "c_include/windows/original/ws2tcpip.h"
//
// Unless the build environment is explicitly targeting only
// platforms that include built-in getaddrinfo() support, include
// the backwards-compatibility version of the relevant APIs.
//
